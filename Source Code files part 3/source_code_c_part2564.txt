///////////////////////////////////////

NODECODE(TB_ISBUTTONHIDDEN);

DECODERET(TB_ISBUTTONHIDDEN)
{
	PARM(fIsHidden, INT, RET);
	TABLEORINT(tblTrueFalse, fIsHidden);

	return TRUE;
}

NODECODEPARM(TB_ISBUTTONHIDDEN);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_ISBUTTONINDETERMINATE);

DECODERET(TB_ISBUTTONINDETERMINATE)
{
	PARM(fIsIndeterminate, INT, RET);
	TABLEORINT(tblTrueFalse, fIsIndeterminate);

	return TRUE;
}

NODECODEPARM(TB_ISBUTTONINDETERMINATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_SETSTATE)
{
	PARM(idButton, INT, WP);
	PARM(fState, UINT, LOLP);

	POUT(idButton);
	POUTC(fState, UINT);

	return TRUE;
}

DECODERET(TB_SETSTATE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_SETSTATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_GETSTATE)
{
	PARM(idButton, INT, WP);
	POUT(idButton);

	return TRUE;
}

NODECODERET(TB_GETSTATE);
	// REVIEW: crack state?

NODECODEPARM(TB_GETSTATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_ADDBITMAP)
{
	PARM(nButtons, INT, WP);
	PARM(lptbab, LPTBADDBITMAP, LP);

	POUT(nButtons);
	POUTC(lptbab, DWORD);

	return TRUE;
}

DECODERET(TB_ADDBITMAP)
{
	PARM(nIndex, INT, RET);
	POUT(nIndex);

	return TRUE;
}

DECODEPARM(TB_ADDBITMAP)
{
	P2WPOUT();

	P2LPOUTPTR(TBADDBITMAP);
	P2IFSIZEOF(TBADDBITMAP)
	{
		PARM(lptbab, LPTBADDBITMAP, ED2);
		INDENT();
		P2OUTC(lptbab, hInst, DWORD);
		P2OUTC(lptbab, nID, UINT);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_ADDBUTTONS)
{
	PARM(uNumButtons, UINT, WP);
	PARM(lpButtons, LPTBBUTTON, LP);

	POUTC(uNumButtons, UINT);
	POUTC(lpButtons, DWORD);

	return TRUE;
}

DECODERET(TB_ADDBUTTONS)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TB_ADDBUTTONS)
{
	P2WPOUT();

	P2LPOUTPTR(TBBUTTON);
	P2IFSIZEOF(TBBUTTON)
	{
		PARM(lpButtons, LPTBBUTTON, ED2);
		INDENT();
		P2OUT(lpButtons, iBitmap);
		P2OUT(lpButtons, idCommand);
		P2OUTC(lpButtons, fsState, BYTE);
		P2OUTC(lpButtons, fsStyle, BYTE);
#ifdef _WIN32
		P2OUTC(lpButtons, bReserved[1], BYTE);
		P2OUTC(lpButtons, bReserved[2], BYTE);
#endif
		P2OUTC(lpButtons, dwData, DWORD);
		P2OUT(lpButtons, iString);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_INSERTBUTTON)
{
	DECODELIKE(TB_GETBUTTON);
}

DECODERET(TB_INSERTBUTTON)
{
	DECODERETLIKE(TB_GETBUTTON);
}

DECODEPARM(TB_INSERTBUTTON)
{
	DECODEPARMLIKE(TB_GETBUTTON);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_DELETEBUTTON)
{
	PARM(iButton, INT, WP);
	POUT(iButton);

	return TRUE;
}

DECODERET(TB_DELETEBUTTON)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_DELETEBUTTON);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_GETBUTTON)
{
	PARM(iButton, INT, WP);
	PARM(lpButton, LPTBBUTTON, LP);

	POUT(iButton);
	POUTC(lpButton, DWORD);

	return TRUE;
}

DECODERET(TB_GETBUTTON)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TB_GETBUTTON)
{
	P2WPOUT();

	P2LPOUTPTR(TBBUTTON);
	P2IFSIZEOF(TBBUTTON)
	{
		PARM(lpButton, LPTBBUTTON, ED2);
		INDENT();
		P2OUT(lpButton, iBitmap);
		P2OUT(lpButton, idCommand);
		P2OUTC(lpButton, fsState, BYTE);
		P2OUTC(lpButton, fsStyle, BYTE);
#ifdef _WIN32
		P2OUTC(lpButton, bReserved[1], BYTE);
		P2OUTC(lpButton, bReserved[2], BYTE);
#endif
		P2OUTC(lpButton, dwData, DWORD);
		P2OUT(lpButton, iString);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_BUTTONCOUNT);

DECODERET(TB_BUTTONCOUNT)
{
	PARM(nCount, INT, RET);
	POUT(nCount);

	return TRUE;
}

NODECODEPARM(TB_BUTTONCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_COMMANDTOINDEX)
{
	PARM(idButton, INT, WP);
	POUT(idButton);

	return TRUE;
}

DECODERET(TB_COMMANDTOINDEX)
{
	PARM(nIndex, INT, RET);
	POUT(nIndex);

	return TRUE;
}

NODECODEPARM(TB_COMMANDTOINDEX);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_SAVERESTORE)
{
	PARM(fSave, BOOL, WP);
	PARM(ptbsp, TBSAVEPARAMS FAR *, LP);

	POUTB(fSave);
	POUTC(ptbsp, DWORD);

	return TRUE;
}

NODECODERET(TB_SAVERESTORE);

DECODEPARM(TB_SAVERESTORE)
{
	P2WPOUT();

	P2LPOUTPTR(TBSAVEPARAMS);
	P2IFSIZEOF(TBSAVEPARAMS)
	{
		PARM(ptbsp, TBSAVEPARAMS FAR *, ED2);
		INDENT();
//		PARM(pszName1, LPSTR, ptbsp->pszSubKey);
//		PARM(pszName2, LPSTR, ptbsp->pszValueName);
		P2OUTC(ptbsp, hkr, DWORD);
		P2OUTPTRSTR(ptbsp, pszSubKey);
//		INDENT();
//		P2OUTS(pszName1);
//		OUTDENT();
		P2OUTPTRSTR(ptbsp, pszValueName);
//		INDENT();
//		P2OUTS(pszName2);
//		OUTDENT();
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_CUSTOMIZE);

NODECODERET(TB_CUSTOMIZE);

NODECODEPARM(TB_CUSTOMIZE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_ADDSTRING)
{
	PARM(hinst, HINSTANCE, WP);
	PARM(idString, INT, LOLP);

	POUTC(hinst, DWORD);
	POUT(idString);

	return TRUE;
}

DECODERET(TB_ADDSTRING)
{
	PARM(nIndex, INT, RET);
	POUT(nIndex);

	return TRUE;
}

NODECODEPARM(TB_ADDSTRING);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_GETITEMRECT)
{
	PARM(iButton, INT, WP);
	PARM(lprc, LPRECT, LP);

	POUT(iButton);
	POUTC(lprc, DWORD);

	return TRUE;
}

DECODERET(TB_GETITEMRECT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TB_GETITEMRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(lprc, LPRECT, ED2);
		INDENT();
		P2OUT(lprc, left);
		P2OUT(lprc, top);
		P2OUT(lprc, right);
		P2OUT(lprc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_BUTTONSTRUCTSIZE)
{
	PARM(cb, INT, WP);
	POUT(cb);

	return TRUE;
}

NODECODERET(TB_BUTTONSTRUCTSIZE);

NODECODEPARM(TB_BUTTONSTRUCTSIZE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_SETBUTTONSIZE)
{
	PARM(dxButton, INT, LOLP);
	PARM(dyButton, INT, HILP);

	POUT(dxButton);
	POUT(dyButton);

	return TRUE;
}

DECODERET(TB_SETBUTTONSIZE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_SETBUTTONSIZE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_SETBITMAPSIZE)
{
	PARM(dxBitmap, INT, LOLP);
	PARM(dyBitmap, INT, HILP);

	POUT(dxBitmap);
	POUT(dyBitmap);

	return TRUE;
}

DECODERET(TB_SETBITMAPSIZE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_SETBITMAPSIZE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_AUTOSIZE);

NODECODERET(TB_AUTOSIZE);

NODECODEPARM(TB_AUTOSIZE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_SETBUTTONTYPE);

DECODERET(TB_SETBUTTONTYPE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_SETBUTTONTYPE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_GETTOOLTIPS);

DECODERET(TB_GETTOOLTIPS)
{
	PARM(hwndToolTip, HWND, RET);
	POUTC(hwndToolTip, DWORD);

	return TRUE;
}

NODECODEPARM(TB_GETTOOLTIPS);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_SETTOOLTIPS)
{
	PARM(hwndToolTip, HWND, WP);
	POUTC(hwndToolTip, DWORD);

	return TRUE;
}

NODECODERET(TB_SETTOOLTIPS);

NODECODEPARM(TB_SETTOOLTIPS);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_SETPARENT)
{
	PARM(hwndParent, HWND, WP);
	POUTC(hwndParent, DWORD);

	return TRUE;
}

NODECODERET(TB_SETPARENT);

NODECODEPARM(TB_SETPARENT);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_SETROWS)
{
	PARM(cRows, INT, LOWP);
	PARM(fLarger, BOOL, HIWP);
	PARM(lprc, LPRECT, LP);

	POUT(cRows);
	POUTB(fLarger);
	POUTC(lprc, DWORD);

	return TRUE;
}

NODECODERET(TB_SETROWS);

DECODEPARM(TB_SETROWS)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(lprc, LPRECT, ED2);
		INDENT();
		P2OUT(lprc, left);
		P2OUT(lprc, top);
		P2OUT(lprc, right);
		P2OUT(lprc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_GETROWS);

DECODERET(TB_GETROWS)
{
	PARM(nCount, INT, RET);
	POUT(nCount);

	return TRUE;
}

NODECODEPARM(TB_GETROWS);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_SETCMDID)
{
	PARM(index, UINT, WP);
	PARM(cmdId, UINT, LP);

	POUTC(index, UINT);
	POUTC(cmdId, UINT);

	return TRUE;
}

DECODERET(TB_SETCMDID)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_SETCMDID);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_CHANGEBITMAP)
{
	PARM(idButton, INT, WP);
	PARM(iBitmap, INT, LOLP);

	POUT(idButton);
	POUT(iBitmap);

	return TRUE;
}

DECODERET(TB_CHANGEBITMAP)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_CHANGEBITMAP);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_GETBITMAP)
{
	PARM(idButton, INT, WP);
	POUT(idButton);

	return TRUE;
}

DECODERET(TB_GETBITMAP)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_GETBITMAP);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_GETBUTTONTEXT)
{
	PARM(idButton, INT, WP);
	PARM(lpszText, LPSTR, LP);

	POUT(idButton);
	POUTC(lpszText, DWORD);

	return TRUE;
}

DECODERET(TB_GETBUTTONTEXT)
{
	PARM(nLength, INT, RET);
	POUT(nLength);

	return TRUE;
}

DECODEPARM(TB_GETBUTTONTEXT)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(lpszText, LPSTR, ED2);
		INDENT();
		P2OUTS(lpszText);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_GETBITMAPFLAGS);

NODECODERET(TB_GETBITMAPFLAGS);
	// REVIEW: crack?

NODECODEPARM(TB_GETBITMAPFLAGS);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\tabdlg.h ===
// tabdlg.h : header file
//

#ifndef __TABDLG_H__
#define __TABDLG_H__

//{patbr] we are not a DLL
//#undef AFXAPP_DATA
//#define AFXAPP_DATA AFXEXT_DATA

class CDlgTab;			// One "tab" page in the tabbed dialog (a child)
class CTabRow;			// The row of tabs along top of tabbed dialog
class CTabbedDialog;	// A tabbed "dialog" (really a modal popup window)


#define cxTabMargin		6	// margins between non-client and outlines
#define cyTabMargin		6	//                  ''


////////////////////////////////////////////////////////////////////////////
// CDlgTab -- one page of a tabbed dialog

class CDlgTab : public CDialog
{
protected:
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CDlgTab)
	
// Construction
public:
	CDlgTab(UINT nIDTemplate, UINT nIDCaption);
	CDlgTab(LPCSTR lpszTemplateName, UINT nIDCaption);

protected:
// Implementation
	CDlgTab();

	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

public:
	virtual BOOL ValidateTab();

protected:
	virtual void CommitTab();
	virtual void CancelTab();

	virtual BOOL PreTranslateMessage(MSG* pMsg);

#ifdef _DEBUG	
	void EndDialog(int nEndID);
#endif

	CString m_strCaption;
	
	friend class CTabbedDialog;

private:
	virtual void OnOK();
	virtual void OnCancel();

// Attributes
public:
	int m_nOrder;
};

extern BOOL IsTabNextFocus(CDialog* pDlg, UINT nCmd);

////////////////////////////////////////////////////////////////////////////
// CTabs -- implementation for a generic row of tabs along the top of dialog

class CTabRecord : public CObject
{
public:
	CTabRecord(const char* szCaption, int nWidth, int nOrder, DWORD dw);

	CString	m_strCaption;
	CRect	m_rect;
	int 	m_nWidth;
	BOOL	m_bClipped;
	int     m_nOrder;
	DWORD	m_dw;
};

class CTabRow : public CObject
{
public:
	enum {
		SCROLL_LEFT = -5,		// all the SCROLL_ items must be less
		SCROLL_RIGHT = -6,		// than -1 to avoid ID conflict
		SCROLL_NULL = -7,

		cxScrollSize = 31,		// size of the scroll button bitmap
		cyScrollSize = 17,
		cxScrollMargin = 10,	// blank margin between scroll buttons and tabs

		cxSelectedTab = 2,		// amount to inflate the selected tab
		cySelectedTab = 2,
		cxTabTextMargin = 10,	// extra width for a tab past text width
		cyTabTextMargin = 3,	// extra height for a tab past text height

		TIMER_ID = 15,
		TIMER_DELAY = 500
	};

	// Construction
	CTabRow();
	~CTabRow();

	void	ResetContent();
	void	AddTab(CString& szCaption, CDC* pDC, int nOrder, DWORD dw = 0);
	void	SetPos(CRect rect);		// set position of tab row within window
	int 	DesiredHeight(CDC* pDC);	// how much space does tab row need?
	void	SetParent(CWnd* pWndOwner)
	    		{ m_pWndOwner = pWndOwner; }

	// Operations
	int		SetActiveTab(int nTab);
	int		SetActiveTab(const CString& str);
	int 	GetActiveTab()
	    		{ return m_curTab; }

	void	PutFocus(BOOL bTabsHaveFocus);
	BOOL	HasFocus()
	    		{ return m_bHasFocus; }

	void	Scroll(int nDirection);
	void	ScrollIntoView(int nTab);

	// Drawing stuff
	void	Draw(CDC* pDC);
	void	DrawFocusRect(CDC* pDC);
	void	DrawPageRect(CDC* pDC, const CRect& rectPage);
	void	InvalidateTab(int nTab, BOOL bInflate = TRUE);
	CRect	GetRect() const
				{ return m_rowRect; }

	// Mouse stuff
	int 	TabFromPoint(CPoint pt);
	void	OnMouseMove(CPoint pt);
	void	OnLButtonUp(CPoint pt);
	void	OnTimer();
	void	Capture(int nDirection);
	BOOL	HasCapture()
	    		{ return m_nScrollState != SCROLL_NULL; }

	// Misc
	DWORD	GetTabDWord(int nTab)
				{ return GetTab(nTab)->m_dw; }
	LPCTSTR GetTabString(int nTab)
				{ return GetTab(nTab)->m_strCaption; }
	int 	MaxTab()
	    		{ return m_tabs.GetSize() - 1; }

private:
	void	DrawTab(CDC* pDC, int nTab, BOOL bCurTab);
	void	DrawScrollers(CDC* pDC);

	BOOL	CanScroll();
	void	SetFirstTab(int nTab);
	CTabRecord*	GetTab(int nTab)
				{ return (CTabRecord*)m_tabs[nTab]; }
	BOOL	IsTabVisible(int nTab, BOOL bPartials = TRUE);

	// Member variables
	CRect	m_rowRect;		// location of entire tab row within owning window
	CRect	m_scrollRect;	// location of scroll buttons
	int 	m_curTab;		// index of current selected tab
	int 	m_firstTab;		// index of leftmost visible tab
	BOOL	m_bHasFocus;	// whether tab row has the focus
	int 	m_nScrollState;	// shows whether left or right scroll btn is down
	BOOL	m_bScrollPause;	// if we have capture, has the mouse wandered off btn?

	CWnd*	m_pWndOwner;	// pointer to owning window (used for InvalidateRect)
	CObArray	m_tabs;		// list of CTabRecords, in order
};


////////////////////////////////////////////////////////////////////////////
// CTabbedDialog -- a tabbed "dialog" (really a popup-window)
class CLastTabMap : public CMapWordToOb
{
	public:
		~CLastTabMap();
		__inline void RememberTab(WORD wCaptionID, CString & strCaption)
		{
			CString * pStr; if (!Lookup(wCaptionID, (CObject *&)pStr))	pStr = new CString;
			*pStr = strCaption; SetAt(wCaptionID, (CObject *&)pStr);
		}
		__inline BOOL LookupTab(WORD wCaptionID, CString & strCaption)
		{
			CString * pStr; if (!Lookup(wCaptionID, (CObject *&)pStr))	return FALSE;
			strCaption = *pStr; return TRUE;
		}
};

class CTabbedDialog : public CWnd
{
// Construction
public:
	enum COMMIT_MODEL { commitOnOk, commitOnTheFly };
	enum FC { FC_THIS, FC_NEXT, FC_PREVIOUS };

	CTabbedDialog(UINT nIDCaption, CWnd* pParentWnd = NULL,
	              UINT iSelectTab = -1, COMMIT_MODEL = commitOnOk);
	
	// Modeless operation
	BOOL Create();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// Modal operation
	int DoModal();
	void EndDialog(int nEndID);
	
// Operations
public:
	virtual void OnOK();
	virtual void OnCancel();
	virtual void OnHelp();

	virtual void OnSelectTab(int nTab) {};

	void AddTab(CDlgTab* pDlgTab);
	// may return failure (FALSE) if the tabs cannot be
	// cleared (most likely because the current one
	// failed the validation check)
	BOOL ClearAllTabs();
	// nTab == -1 will de-select the current tab
	// and not re-select any other
	void SelectTab(int nTab);
	int GetTabCount() const
		{ return m_tabs.GetSize(); }
	void SetCaption( const char *szCaption )
		{ m_strCaption = szCaption; }

	// PreTranslate processing
	BOOL MessageStolenByTabbedDialog(MSG* pMsg);
	void HandleTab(BOOL bShift, BOOL bControl);
	BOOL HandleAcceleratorKey(char ch);
	BOOL HandleTabRowKey(char ch);

// Implementation
protected:
	CDlgTab* GetTab(int nTab) {return 0 <= nTab && nTab < GetTabCount() ? (CDlgTab*)m_tabs[nTab] : (CDlgTab *)NULL;}
	void DrawFocusRect();
	BOOL ActivateTab(int nTab);
	void BuildTabItemList(CObList& list, CMapWordToOb& map, CWnd* pWndCur = NULL);
	CWnd* FindControl(CWnd* pWndGoal, CObList& list, FC fc = FC_NEXT);
	void SetFocusToControl(CWnd* pControl, CObList* list = NULL, BOOL bSetSel = TRUE);

	// Sizing
	CPoint GetDlgTabPos();
	virtual void GetTabSize(CRect& rect);
	virtual void GetMargins(CRect& rect);

	// Buttons
	BOOL IsButton(HWND hWnd);
	virtual void CreateButtons();
	virtual void MoveButtons(int nLeft, int nCenter);
	virtual CButton* GetButtonFromIndex(int index);
	void SetDefButtonIndex(int index);

	enum {
		cyBottomMargin = 6,	// plus button height, of course
		duButtonWidth = 45,
		duButtonHeight = 14,
		duBetweenButtons = 6
	};

	CSize m_buttonSize;
	int   m_cxBetweenButtons;

	CObArray m_tabs;	// array of CDlgTab pointers
	int m_nTabCur;  	// which is the current tab
	//CWnd* m_pFocusWnd; // focus when we lost activation
	HWND m_hFocusWnd;	// focus when we lost activation
	CWnd* m_pParentWnd; // owner of the tabbed dialog
	int m_nID;      	// ID passed to EndDialog and returned from DoModal
	CString m_strCaption; // caption of the pseudo-dialog
	UINT nCaptionID;
	static CLastTabMap m_DialogMap;	// Used to remember the last used page in all tabbed dialogs
	COMMIT_MODEL	m_commitModel;

	CTabRow	m_tabRow;		// entire row of tabs at top of dialog

	CButton m_btnOk;
	CButton m_btnCancel;
	CButton m_btnHelp;
	int m_iDefBtnIndex;

	// Generated message map functions
	//{{AFX_MSG(CTabbedDialog)
	afx_msg void OnPaint();
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT nTimerID);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnClose();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CTabbedDialog);
};

//[patbr] we are not a DLL
//#undef AFXAPP_DATA
//#define AFXAPP_DATA NEAR

/////////////////////////////////////////////////////////////////////////////
#endif // __TABDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\thdnode.cpp ===
// thdtreec.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "treectl.h"
#include "spytreec.h"
#include "thdnode.h"
#include "wndnode.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



BOOL CALLBACK EnumWndProc(HWND hwnd, LPARAM lParam);
BOOL CALLBACK EnumChildWndProc(HWND hwnd, LPARAM lParam);



/////////////////////////////////////////////////////////////////////////////
// CThdTreeNode

IMPLEMENT_DYNCREATE(CThdTreeNode, CSpyTreeNode);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BOOL CThdTreeNode::Create(CPROCDB *pProcessDatabase, int iThdIndex)
{
	LPWSTR pszExe;
	LPWSTR pszModule;
	CPROCDB::PRFCNTRTHRD PrfCntrThrd;

	memset((void *)&PrfCntrThrd, 0, sizeof(CPROCDB::PRFCNTRTHRD));
	pProcessDatabase->GetPrfCntrThrd(iThdIndex, &PrfCntrThrd);

	m_tid = (DWORD)PrfCntrThrd.dwThreadId;

	pszExe = (LPWSTR)pProcessDatabase->GetThreadName(iThdIndex);

	if (pszModule = wcsrchr(pszExe, '\\'))
	{
		pszModule++;
	}
	else
	{
		pszModule = pszExe;
	}

	m_strModule = wcsupr(pszModule);

	return TRUE;
}



BOOL CThdTreeNode::Create(HANDLE hThreadList, DWORD dwThreadID, char *szExePath)
{
	m_tid = dwThreadID;

	char szFileName[_MAX_FNAME];
	_splitpath(szExePath, NULL, NULL, szFileName, NULL);

	m_strModule = szFileName;
//	m_strModule += " (";
//	m_strModule += szExePath;
//	m_strModule += ")";

	return TRUE;
}



void CThdTreeNode::GetDescription(CString& str)
{
	LPSTR psz = str.GetBuffer(260);

	_stprintf(psz, ids(IDS_THREAD_PARAM), m_tid, m_strModule.GetBuffer(0));

	str.ReleaseBuffer();
	m_strModule.ReleaseBuffer();
}



void CThdTreeNode::AddChildren(CMapPtrToPtr* pMap)
{
	EnumWindows(EnumWndProc, (LPARAM)pMap);
}



BOOL CALLBACK EnumWndProc(HWND hwnd, LPARAM lParam)
{
	CMapPtrToPtr* pMap = (CMapPtrToPtr*)lParam;
	void * pThdTreeNode;
	DWORD tid = GetWindowThreadProcessId(hwnd, NULL);

	if (pMap->Lookup((void*)tid, pThdTreeNode))
	{
		CWndTreeNode* pWndTreeNode = new CWndTreeNode;
		pWndTreeNode->Create(hwnd, FALSE);

		((CThdTreeNode*)pThdTreeNode)->AddChild(pWndTreeNode);

		EnumChildWindows(hwnd, EnumChildWndProc, lParam);
	}

	return TRUE;
}



BOOL CALLBACK EnumChildWndProc(HWND hwnd, LPARAM lParam)
{
	CMapPtrToPtr* pMap = (CMapPtrToPtr*)lParam;
	void * pThdTreeNode;
	DWORD tid = GetWindowThreadProcessId(hwnd, NULL);

	if (pMap->Lookup((void*)tid, pThdTreeNode))
	{
		CWndTreeNode* pWndTreeNode = new CWndTreeNode;
		pWndTreeNode->Create(hwnd, FALSE);

		((CThdTreeNode*)pThdTreeNode)->AddChild(pWndTreeNode);
	}

	return TRUE;
}



void CThdTreeNode::ShowProperties()
{
	CPropertyInspector::ShowObjectProperties((DWORD)m_tid, OT_THREAD);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\thdptabs.h ===
// thdptabs.h : header file
//



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CThreadGeneralPropTab window

class CThreadGeneralPropTab : public CPropertyTab
{
// Construction
public:
	CThreadGeneralPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CThreadGeneralPropTab)
	enum { IDD = IDD_THREADGENERALTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CThreadGeneralPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

protected:
	CHotLinkCtrlPrc m_HotLinkProcessID;

protected:
	static INT m_aControlIDs[];
	static VALUETABLE m_astThreadState[];
	static VALUETABLE m_astWaitReason[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CThreadGeneralPropTab)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CThreadTabbedDialog;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\thdnode.h ===
// thdnode.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CThdTreeNode object

class CThdTreeNode : public CSpyTreeNode
{
	DECLARE_DYNCREATE(CThdTreeNode);

public:
	// Win32 version
	BOOL Create(CPROCDB *pProcessDatabase, int iThdIndex);
	// Chicago version
	BOOL Create(HANDLE hThreadList, DWORD dwThreadID, char *szExePath);

// Attributes
public:

// Operations
public:
	virtual void GetDescription(CString& str);
	virtual void ShowProperties();
	virtual int GetBitmapIndex()
	{
		return IDX_THDBITMAP;
	}
	virtual DWORD GetObjectHandle()
	{
		return (DWORD)m_tid;
	}
	virtual int GetObjectType()
	{
		return OT_THREAD;
	}
	virtual CString GetModule()
	{
		return m_strModule;
	}

	static void AddChildren(CMapPtrToPtr* pMap);

// Implementation
protected:
	DWORD m_tid;
	CString m_strModule;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\thdptabs.cpp ===
// thdptabs.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#pragma message("Remove local copy of TLHELP32.H when official version available.")

#include "hotlinkc.h"
#include "proptab.h"
#include "thdptabs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CThreadGeneralPropTab

VALUETABLE CThreadGeneralPropTab::m_astThreadState[] =
{
	0, NULL,
	1, NULL,
	2, NULL,
	3, NULL,
	4, NULL,
	5, NULL,
	6, NULL,
	7, NULL,
	0, NULL
};

VALUETABLE CThreadGeneralPropTab::m_astWaitReason[] =
{
	0, NULL,
	1, NULL,
	2, NULL,
	3, NULL,
	4, NULL,
	5, NULL,
	6, NULL,
	7, NULL,
	8, NULL,
	9, NULL,
	10, NULL,
	11, NULL,
	12, NULL,
	13, NULL,
	14, NULL,
	15, NULL,
	16, NULL,
	17, NULL,
	18, NULL,
	19, NULL,
	0, NULL
};



CThreadGeneralPropTab::~CThreadGeneralPropTab()
{
}


INT CThreadGeneralPropTab::m_aControlIDs[] =
{
	IDC_TGT_THREADID,
	IDC_TGT_PROCESSID,
	IDC_TGT_EXECUTABLE,
	IDC_TGT_CURRENTPRIORITY,
	IDC_TGT_BASEPRIORITY,
	IDC_TGT_THREADSTATE,
	IDC_TGT_WAITREASON,
	IDC_TGT_STARTADDRESS,
//	IDC_TGT_USERPC,
	IDC_TGT_CPUTIME,
	IDC_TGT_USERTIME,
	IDC_TGT_PRIVILEGEDTIME,
	IDC_TGT_ELAPSEDTIME,
	IDC_TGT_CONTEXTSWITCHES,
	IDC_TGT_USERPC,
	0
};


BEGIN_MESSAGE_MAP(CThreadGeneralPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CThreadGeneralPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CThreadGeneralPropTab message handlers


BOOL CThreadGeneralPropTab::OnInitDialog()
{
	CPropertyTab::OnInitDialog();

	m_astThreadState[0].pszValue = ids(IDS_THDP_INITIALIZED);
	m_astThreadState[1].pszValue = ids(IDS_THDP_READY);
	m_astThreadState[2].pszValue = ids(IDS_THDP_RUNNING);
	m_astThreadState[3].pszValue = ids(IDS_THDP_STANDBY);
	m_astThreadState[4].pszValue = ids(IDS_THDP_TERMINATED);
	m_astThreadState[5].pszValue = ids(IDS_THDP_WAIT);
	m_astThreadState[6].pszValue = ids(IDS_THDP_TRANSITION);
	m_astThreadState[7].pszValue = ids(IDS_THDP_UNKNOWN);

	m_astWaitReason[0].pszValue  = ids(IDS_THDP_EXECUTIVE);
	m_astWaitReason[1].pszValue  = ids(IDS_THDP_FREE_PAGE);
	m_astWaitReason[2].pszValue  = ids(IDS_THDP_PAGE_IN);
	m_astWaitReason[3].pszValue  = ids(IDS_THDP_POOL_ALLOCATION);
	m_astWaitReason[4].pszValue  = ids(IDS_THDP_EXECUTION_DELAY);
	m_astWaitReason[5].pszValue  = ids(IDS_THDP_SUSPENDED);
	m_astWaitReason[6].pszValue  = ids(IDS_THDP_USER_REQUEST);
	m_astWaitReason[7].pszValue  = ids(IDS_THDP_EXECUTIVE);
	m_astWaitReason[8].pszValue  = ids(IDS_THDP_FREE_PAGE);
	m_astWaitReason[9].pszValue  = ids(IDS_THDP_PAGE_IN);
	m_astWaitReason[10].pszValue = ids(IDS_THDP_POOL_ALLOCATION);
	m_astWaitReason[11].pszValue = ids(IDS_THDP_EXECUTION_DELAY);
	m_astWaitReason[12].pszValue = ids(IDS_THDP_SUSPENDED);
	m_astWaitReason[13].pszValue = ids(IDS_THDP_USER_REQUEST);
	m_astWaitReason[14].pszValue = ids(IDS_THDP_EVENT_PAIR_HIGH);
	m_astWaitReason[15].pszValue = ids(IDS_THDP_EVENT_PAIR_LOW);
	m_astWaitReason[16].pszValue = ids(IDS_THDP_LPC_RECEIVE);
	m_astWaitReason[17].pszValue = ids(IDS_THDP_LPC_REPLY);
	m_astWaitReason[18].pszValue = ids(IDS_THDP_VIRTUAL_MEMORY);
	m_astWaitReason[19].pszValue = ids(IDS_THDP_PAGE_OUT);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		CFont* pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		HFONT hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_TGT_EXECUTABLE, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	m_HotLinkProcessID.SubclassDlgItem(IDC_TGT_PROCESSID, this);

	return TRUE;  // return TRUE  unless you set the focus to a control
}



void CThreadGeneralPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	if (!theApp.IsChicago())
	{
		// Win32
		SetDlgItemText(IDC_TGT_THREADID, FormatHex((DWORD)pTabDlg->m_ThreadInfo.dwThreadId));
		m_HotLinkProcessID.SetJumpObject((DWORD)pTabDlg->m_ThreadInfo.dwProcessId);
		SetDlgItemText(IDC_TGT_EXECUTABLE, pTabDlg->m_strExecutable);
		SetDlgItemText(IDC_TGT_CURRENTPRIORITY, FormatULong(pTabDlg->m_ThreadInfo.dwPriorityCrnt));
		SetDlgItemText(IDC_TGT_BASEPRIORITY, FormatULong(pTabDlg->m_ThreadInfo.dwPriorityBase));
		SetDlgItemText(IDC_TGT_THREADSTATE, FormatULongFromTable(pTabDlg->m_ThreadInfo.dwThreadState, m_astThreadState));
		SetDlgItemText(IDC_TGT_WAITREASON, FormatULongFromTable(pTabDlg->m_ThreadInfo.dwThreadWaitReason, m_astWaitReason));
		SetDlgItemText(IDC_TGT_STARTADDRESS, FormatHex((DWORD)pTabDlg->m_ThreadInfo.dwStartAddr));
		SetDlgItemText(IDC_TGT_CPUTIME, FormatTime(pTabDlg->m_ThreadInfo.liPctCPUTime));
		SetDlgItemText(IDC_TGT_USERTIME, FormatTime(pTabDlg->m_ThreadInfo.liPctUserTime));
		SetDlgItemText(IDC_TGT_PRIVILEGEDTIME, FormatTime(pTabDlg->m_ThreadInfo.liPctPrivTime));
		SetDlgItemText(IDC_TGT_ELAPSEDTIME, FormatTimeDiff(pTabDlg->m_ThreadInfo.liElapsedTime, pTabDlg->m_ThreadInfo.PerfTime));
		SetDlgItemText(IDC_TGT_CONTEXTSWITCHES, FormatULong(pTabDlg->m_ThreadInfo.dwCntxSwtchPerSec));
		if (pTabDlg->m_ThreadDetInfo.dwUserPC)
			SetDlgItemText(IDC_TGT_USERPC, FormatHex((DWORD)pTabDlg->m_ThreadDetInfo.dwUserPC));
		else
			SetDlgItemText(IDC_TGT_USERPC, ids(IDS_UNAVAILABLE));
	}
	else
	{
		// Chicago
		SetDlgItemText(IDC_TGT_THREADID, FormatHex((DWORD)pTabDlg->m_ThreadEntry.th32ThreadID));
		m_HotLinkProcessID.SetJumpObject((DWORD)pTabDlg->m_ThreadEntry.th32OwnerProcessID);
		SetDlgItemText(IDC_TGT_EXECUTABLE, pTabDlg->m_strExecutable);
		SetDlgItemText(IDC_TGT_CURRENTPRIORITY, FormatULong(pTabDlg->m_ThreadEntry.tpBasePri + pTabDlg->m_ThreadEntry.tpDeltaPri));
		SetDlgItemText(IDC_TGT_BASEPRIORITY, FormatULong(pTabDlg->m_ThreadEntry.tpBasePri));
	//	SetDlgItemText(IDC_TGT_THREADSTATE, ids(IDS_UNAVAILABLE));
	//	SetDlgItemText(IDC_TGT_WAITREASON, ids(IDS_UNAVAILABLE));
	//	SetDlgItemText(IDC_TGT_STARTADDRESS, ids(IDS_UNAVAILABLE));
	//	SetDlgItemText(IDC_TGT_CPUTIME, FormatTimeAdd(pTabDlg->m_ftThdKernelTime, pTabDlg->m_ftThdUserTime));
	//	SetDlgItemText(IDC_TGT_USERTIME, FormatTime(pTabDlg->m_ftThdUserTime));
	//	SetDlgItemText(IDC_TGT_PRIVILEGEDTIME, FormatTime(pTabDlg->m_ftThdKernelTime));
	//	SetDlgItemText(IDC_TGT_ELAPSEDTIME, FormatTimeDiff(pTabDlg->m_stThdSnapshotTime, pTabDlg->m_ftThdCreationTime));
	//	SetDlgItemText(IDC_TGT_CONTEXTSWITCHES, ids(IDS_UNAVAILABLE));
	//	SetDlgItemText(IDC_TGT_USERPC, ids(IDS_UNAVAILABLE));
		GetDlgItem(IDC_TGT_THREADSTATELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_THREADSTATE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_WAITREASONLABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_WAITREASON)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_STARTADDRESSLABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_STARTADDRESS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_CPUTIMELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_CPUTIME)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_USERTIMELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_USERTIME)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_PRIVILEGEDTIMELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_PRIVILEGEDTIME)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_ELAPSEDTIMELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_ELAPSEDTIME)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_CONTEXTSWITCHESLABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_CONTEXTSWITCHES)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_USERPCLABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TGT_USERPC)->ShowWindow(SW_HIDE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\thdtreed.h ===
// thdtreed.h : header file
//

#define SRCHFLAG_THREAD_USETHREAD	0x01
#define SRCHFLAG_THREAD_USEMODULE	0x02

/////////////////////////////////////////////////////////////////////////////
// CThdTreeDoc document

class CThdTreeDoc : public CSpyTreeDoc
{
	DECLARE_DYNCREATE(CThdTreeDoc);

protected:
	CThdTreeDoc();		  // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Implementation
protected:
	// data variables use in searching
	WORD	m_wSearchFlags;
	DWORD	m_dwThread;
	CString	m_strModule;
	BOOL	m_fSearchUp;	// TRUE if searching up, FALSE if searching down (from dialog)

	virtual void InitializeData();
	virtual void SetSearchMenuText(CCmdUI *pCmdUI);
	virtual BOOL DoFind();
	virtual BOOL DoFindNext();
	virtual BOOL DoFindPrev();
	virtual BOOL HasValidFind();
	virtual BOOL FindFirstMatchingNode();
	virtual BOOL FindNextMatchingNode();
	virtual BOOL FindPreviousMatchingNode();
	virtual BOOL FindLastMatchingNode();
	virtual ~CThdTreeDoc();

	// Generated message map functions
protected:
	//{{AFX_MSG(CThdTreeDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\thdtreed.cpp ===
// thdtreed.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "spytreed.h"
#include "thdtreed.h"
#include "treectl.h"
#include "spytreec.h"
#include "thdnode.h"
#include "findtool.h"
#include "spytreev.h"
#include "srchdlgs.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CThdTreeDoc

IMPLEMENT_DYNCREATE(CThdTreeDoc, CSpyTreeDoc);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CThdTreeDoc::CThdTreeDoc()
{
	m_dwThread = (DWORD)-1;
	m_strModule.Empty();
	m_fSearchUp = FALSE;
}



CThdTreeDoc::~CThdTreeDoc()
{
}



void CThdTreeDoc::InitializeData()
{
	CMapPtrToPtr ThdMap;

	if (!theApp.IsChicago())
	{
		// Win32
//		enum CPROCDB::PROCDBERR error;
		WORD wQueryType = PROCDBQ_THREAD;
		CPROCDB ProcessDatabase(wQueryType/*, &error*/);
		CPROCDB::PRFCNTRTHRD PrfCntrThrd;
		int iCount = 0, iLoop = ProcessDatabase.GetNumThreads();

		for (; iCount < iLoop; iCount++)
		{
			memset((void *)&PrfCntrThrd, 0, sizeof(CPROCDB::PRFCNTRTHRD));
			ProcessDatabase.GetPrfCntrThrd(iCount, &PrfCntrThrd);

			CThdTreeNode* pThdTreeNode = new CThdTreeNode;
			pThdTreeNode->Create(&ProcessDatabase, iCount);
			m_TopLevelNodeList.AddTail(pThdTreeNode);
			ThdMap.SetAt((void*)pThdTreeNode->GetObjectHandle(), pThdTreeNode);
		}
	}
	else
	{
		// Chicago
		HANDLE hThreadList;
		THREADENTRY32 te32;

		te32.dwSize = sizeof(THREADENTRY32);

		if ((hThreadList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPTHREAD, 0)) != NULL)
		{
			HANDLE hProcessList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPPROCESS, 0);
			PROCESSENTRY32 pe32;
			char *szExePath;

			if ((*theApp.pfnThread32First)(hThreadList, &te32))
			{
				CThdTreeNode* pThdTreeNode = new CThdTreeNode;

				pe32.dwSize = sizeof(PROCESSENTRY32);
				if (((*theApp.pfnProcess32First)(hProcessList, &pe32)) && (pe32.dwSize >= sizeof(PROCESSENTRY32)))
				{
					if (pe32.th32ProcessID == te32.th32OwnerProcessID)
					{
						szExePath = pe32.szExeFile;
					}
					else
					{
						while ((*theApp.pfnProcess32Next)(hProcessList, &pe32))
						{
							if (pe32.th32ProcessID == te32.th32OwnerProcessID)
							{
								szExePath = pe32.szExeFile;
								break;
							}
						}
					}
				}
				else
					szExePath = "";

				pThdTreeNode->Create(hThreadList, te32.th32ThreadID, szExePath);
				m_TopLevelNodeList.AddTail(pThdTreeNode);
				ThdMap.SetAt((void*)pThdTreeNode->GetObjectHandle(), pThdTreeNode);

				while ((*theApp.pfnThread32Next)(hThreadList, &te32))
				{
					CThdTreeNode* pThdTreeNode = new CThdTreeNode;

					if (((*theApp.pfnProcess32First)(hProcessList, &pe32)) && (pe32.dwSize >= sizeof(PROCESSENTRY32)))
					{
						if (pe32.th32ProcessID == te32.th32OwnerProcessID)
						{
							szExePath = pe32.szExeFile;
						}
						else
						{
							while ((*theApp.pfnProcess32Next)(hProcessList, &pe32))
							{
								if (pe32.th32ProcessID == te32.th32OwnerProcessID)
								{
									szExePath = pe32.szExeFile;
									break;
								}
							}
						}
					}
					else
						szExePath = "";

					pThdTreeNode->Create(hThreadList, te32.th32ThreadID, szExePath);
					m_TopLevelNodeList.AddTail(pThdTreeNode);
					ThdMap.SetAt((void*)pThdTreeNode->GetObjectHandle(), pThdTreeNode);
				}
			}

			CloseHandle(hThreadList);
		}
	}

	CThdTreeNode::AddChildren(&ThdMap);
}

void CThdTreeDoc::SetSearchMenuText(CCmdUI *pCmdUI)
{
	pCmdUI->SetText(ids(IDS_MENU_FINDTHREAD));
}

BOOL CThdTreeDoc::DoFind()
{
#ifdef USE_TABBED_SEARCH_DIALOGS
	CSearchTabbedDialog dlgTest(IDS_SEARCHCAPTION, NULL, (UINT)-1);

	dlgTest.AddTab(new CSearchThreadDlgTab(IDD_SEARCHTHREADTAB, IDS_SEARCHTHREADTAB));
	dlgTest.AddTab(new CSearchWindowDlgTab(IDD_SEARCHWINDOWTAB, IDS_SEARCHWINDOWTAB));

	dlgTest.DoModal();
#else	// USE_TABBED_SEARCH_DIALOGS
	CSearchThreadDlg dlg;
	CSpyTreeView *pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
	CThdTreeNode *pcttn = (CThdTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(pcstvActive->m_SpyTreeCtl.GetCurSel())->m_dwData;

	m_dwThread = pcttn->GetObjectHandle();
	m_strModule = pcttn->GetModule();

	dlg.SetSelectedThread(m_dwThread);
	dlg.SetModule(m_strModule);
	dlg.SetDirection(m_fSearchUp);

	if (dlg.DoModal() == TRUE)
	{
		m_wSearchFlags	= dlg.GetSearchFlags();
		m_dwThread		= dlg.GetSelectedThread();
		m_strModule		= dlg.GetModule();
		m_fSearchUp		= dlg.GetDirection();

		if (m_fSearchUp)
		{
			if (!FindPreviousMatchingNode() && !FindLastMatchingNode())
			{
				// notify user that no matching node found
				SpyMessageBox(IDS_NO_MATCHING_THD);
			}
		}
		else
		{
			if (!FindNextMatchingNode() && !FindFirstMatchingNode())
			{
				// notify user that no matching node found
				SpyMessageBox(IDS_NO_MATCHING_THD);
			}
		}
	}
#endif	// USE_TABBED_SEARCH_DIALOGS

	return(TRUE);
}

BOOL CThdTreeDoc::DoFindNext()
{
	if (!FindNextMatchingNode() && !FindFirstMatchingNode())
	{
		// notify user that no next matching node found
		SpyMessageBox(IDS_NO_NEXT_MATCH_THD);
	}

	return(TRUE);
}

BOOL CThdTreeDoc::DoFindPrev()
{
	if (!FindPreviousMatchingNode() && !FindLastMatchingNode())
	{
		// notify user that no previous matching node found
		SpyMessageBox(IDS_NO_PREV_MATCH_THD);
	}

	return(TRUE);
}

BOOL CThdTreeDoc::HasValidFind()
{
	if (m_wSearchFlags & SRCHFLAG_THREAD_USETHREAD)
		return(FALSE);
	else if (m_wSearchFlags & SRCHFLAG_THREAD_USEMODULE)
		return(!m_strModule.IsEmpty());
	else
		return(FALSE);
}

BOOL CThdTreeDoc::FindFirstMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CThdTreeNode *pcttn;

	for (int i = 0; i < pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount(); i++)
	{
		pcttn = (CThdTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (!(pcttn->IsKindOf(RUNTIME_CLASS(CThdTreeNode))))
			continue;

		// do comparison of node contents with search criteria
		switch (m_wSearchFlags)
		{
			case SRCHFLAG_THREAD_USETHREAD:

				if (pcttn->GetObjectHandle() == m_dwThread)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;

			case SRCHFLAG_THREAD_USEMODULE:

				if (pcttn->GetModule() == m_strModule)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;
		}
	}

	return(FALSE);
}

BOOL CThdTreeDoc::FindNextMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CThdTreeNode *pcttn;

	for (int i = pcstvActive->m_SpyTreeCtl.GetCurSel() + 1; i < pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount(); i++)
	{
		pcttn = (CThdTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (!(pcttn->IsKindOf(RUNTIME_CLASS(CThdTreeNode))))
			continue;

		// do comparison of node contents with search criteria
		switch (m_wSearchFlags)
		{
			case SRCHFLAG_THREAD_USETHREAD:

				if (pcttn->GetObjectHandle() == m_dwThread)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;

			case SRCHFLAG_THREAD_USEMODULE:

				if (pcttn->GetModule() == m_strModule)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;
		}
	}

	return(FALSE);
}

BOOL CThdTreeDoc::FindPreviousMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CThdTreeNode *pcttn;

	for (int i = pcstvActive->m_SpyTreeCtl.GetCurSel() - 1; i >= 0; i--)
	{
		pcttn = (CThdTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (!(pcttn->IsKindOf(RUNTIME_CLASS(CThdTreeNode))))
			continue;

		// do comparison of node contents with search criteria
		switch (m_wSearchFlags)
		{
			case SRCHFLAG_THREAD_USETHREAD:

				if (pcttn->GetObjectHandle() == m_dwThread)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;

			case SRCHFLAG_THREAD_USEMODULE:

				if (pcttn->GetModule() == m_strModule)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;
		}
	}

	return(FALSE);
}

BOOL CThdTreeDoc::FindLastMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CThdTreeNode *pcttn;

	for (int i = pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount() - 1; i >= 0; i--)
	{
		pcttn = (CThdTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (!(pcttn->IsKindOf(RUNTIME_CLASS(CThdTreeNode))))
			continue;

		// do comparison of node contents with search criteria
		switch (m_wSearchFlags)
		{
			case SRCHFLAG_THREAD_USETHREAD:

				if (pcttn->GetObjectHandle() == m_dwThread)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;

			case SRCHFLAG_THREAD_USEMODULE:

				if (pcttn->GetModule() == m_strModule)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;
		}
	}

	return(FALSE);
}

BEGIN_MESSAGE_MAP(CThdTreeDoc, CSpyTreeDoc)
	//{{AFX_MSG_MAP(CThdTreeDoc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\treectl.cpp ===
// treectl.cpp : implementation file
//

//[byrond] Change to Spy++ headers.
#include "stdafx.h"
#pragma hdrstop

#include "treectl.h"
#include "imgwell.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

int CTreeCtl::c_cyBorder = GetSystemMetrics(SM_CYBORDER);
int CTreeCtl::c_cyBorderX2 = c_cyBorder * 2;

// This image well contains: +box, -box, closed-folder, open-folder
CImageWell CTreeCtl::c_imageWell;
#define nPlusImage		0
#define nMinusImage		1
#define nClosedImage	2
#define nOpenImage		3

// width&height of the boxed + and - images
#define cxExpandBox 11
#define cyExpandBox 11

// size of the folder images
#define cxFolder	16
#define cyFolder	15


/////////////////////////////////////////////////////////////////////////////
// CTreeCtl

CTreeCtl::CTreeCtl(BOOL bIsMultiSelection /*= FALSE*/, BOOL bKeepSelectionRect /*=FALSE*/)
{
	if (!c_imageWell.IsOpen())
	{
		VERIFY(c_imageWell.Load(IDB_TREECTL, CSize(16, 16)));
		VERIFY(c_imageWell.Open());
		VERIFY(c_imageWell.CalculateMask());
	}
	
	m_bIsMultiSelection = bIsMultiSelection;
	m_bKeepSelectionRect= bKeepSelectionRect;
	m_EnableUpdates = 0;
	m_bEnableDragDrop = FALSE;
	m_bShowContextPopup = FALSE;
	m_bShowProperties = FALSE;
	m_timeLastKey = 0;
	m_bSorted = TRUE;		   //[byrond] needed for unsorted tree support
}

CTreeCtl::~CTreeCtl()
{
	if (m_hWnd != NULL)
		DestroyWindow();
}

BOOL CTreeCtl::PreCreateWindow(CREATESTRUCT& cs)
{
	if (cs.lpszClass == NULL)
		cs.lpszClass = AfxRegisterWndClass(0);
			
	return TRUE;
}

IMPLEMENT_DYNAMIC(CTreeListBox, CWnd)

BEGIN_MESSAGE_MAP(CTreeListBox, CWnd)
	//{{AFX_MSG_MAP(CTreeListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_RBUTTONUP()
	ON_WM_RBUTTONDOWN()
	ON_WM_CHAR()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CTreeCtl, CWnd)

BEGIN_MESSAGE_MAP(CTreeCtl, CWnd)
	//{{AFX_MSG_MAP(CTreeCtl)
	ON_WM_CHARTOITEM()
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_WM_VKEYTOITEM()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_SETFONT, OnSetFont)
	ON_MESSAGE(WM_GETFONT, OnGetFont)
	ON_LBN_DBLCLK(IDCW_TREELISTBOX, OnLbDblClk)
	ON_LBN_SELCHANGE(IDCW_TREELISTBOX, OnLbSelChange)
	ON_LBN_SETFOCUS(IDCW_TREELISTBOX, InvalSelection)
	ON_LBN_KILLFOCUS(IDCW_TREELISTBOX, InvalSelection)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl message handlers

int CTreeCtl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	CClientDC dc(this);
	ResetSizes(&dc);
	
	FlushTheCache();	//[byrond]

	m_listBox.m_pTree = this;
	if (!m_listBox.Create(WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_BORDER |
		LBS_NOTIFY | LBS_OWNERDRAWFIXED | LBS_NOINTEGRALHEIGHT |
		LBS_WANTKEYBOARDINPUT | ( (m_bIsMultiSelection) ? LBS_EXTENDEDSEL : 0),
		CRect(0, 0, 0, 0), this, IDCW_TREELISTBOX))
	{
		return -1;
	}
	
	SetFont(GetStdFont(font_Normal));
	
	return 0;
}

void CTreeCtl::OnDestroy()
{
	FreeAllTreeData();
}

void CTreeCtl::OnPaint()
{
	// we want to search through the tree control
	// for any dirty nodes, if we find one of these
	// we want to update it's contents

	// [patbr] don't need to do this in Spy++ since nodes never get dirty...
	// RefreshAllRoots();		// refresh from our roots down

	CWnd::OnPaint();	// pass on to our base instance
}

void CTreeCtl::ResetSizes(CDC* pDC)
{
	// REVIEW: Should maybe be using TEXTMETRIC's
	m_sizeM = pDC->GetTextExtent("M", 1);
	// Make sure this is even so our brush lines up when we scroll:
	m_cyNode = (max(m_sizeM.cy, cyFolder) + 2) & ~1;
		
	m_cxExtent = 0; // not calculated yet...
}

void CTreeCtl::RecalcHorizontalExtent ()
{
	m_cxExtent = 0;
	int nIndex = m_listBox.GetCount();
	while (--nIndex >= 0)
	{
		CNode * pNode = (CNode *)m_listBox.GetItemDataPtr(nIndex);
		if (pNode->m_nWidth > m_cxExtent) m_cxExtent = pNode->m_nWidth;
	}

	// If the listbox fits, set the scroll position to 0 to make sure
	// the scroll bar goes away:
	CRect rcWindow;
	m_listBox.GetClientRect(rcWindow);
	if (m_cxExtent <= rcWindow.right && m_listBox.GetScrollPos(SB_HORZ))
		m_listBox.SendMessage(WM_HSCROLL, SB_TOP);

	m_listBox.SetHorizontalExtent(m_cxExtent);

}
	
LPARAM CTreeCtl::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	CFont* pFont = CFont::FromHandle((HFONT)wParam);

	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(pFont);
	ResetSizes(&dc);
	RecalcHorizontalExtent();
	dc.SelectObject(pOldFont);

	m_listBox.SetFont(pFont);
	m_listBox.SetItemHeight(0, m_cyNode);
	
	return 0;
}

LPARAM CTreeCtl::OnGetFont(WPARAM wParam, LPARAM lParam)
{
	return m_listBox.SendMessage(WM_GETFONT, wParam, lParam);
}

void CTreeCtl::OnSetFocus(CWnd* pOldWnd)
{
	m_listBox.SetFocus();
}

void CTreeCtl::InvalItem(int nItem)
{
	CRect rect;
	m_listBox.GetItemRect(nItem, rect);
	m_listBox.InvalidateRect(rect);
}

void CTreeCtl::InvalSelection()
{
	if (m_bIsMultiSelection)
	{
		CRect client;
		m_listBox.GetClientRect(client);
		for (int nItem = m_listBox.GetTopIndex(); nItem != -1; nItem += 1)
		{
			CRect rect;
			if (m_listBox.GetItemRect(nItem, &rect) == LB_ERR || rect.top >= client.bottom)
				break;
			
			if (m_listBox.GetSel(nItem))
				m_listBox.InvalidateRect(rect);
		}
	}
	else
	{
		InvalItem(GetCurSel());
	}
}

void CTreeCtl::OnSize(UINT nType, int cx, int cy)
{
	if (GetParent()->IsIconic())
		return;

	// Put the client area of the listbox in the client area of the tree.
	CRect rectNew, rectCurrent;
	GetClientRect(rectNew);
	::AdjustWindowRect(rectNew, m_listBox.GetStyle(), FALSE);

	m_listBox.GetWindowRect(rectCurrent);
	ScreenToClient(rectCurrent);

	if (rectNew == rectCurrent)
		return;
		
	m_listBox.MoveWindow(rectNew.left, rectNew.top,
		rectNew.Width(), rectNew.Height());
		
	int iMax = GetCurSel();
	if (iMax >= 0)
	{
		int top, bottom;
			
		m_listBox.GetClientRect(rectCurrent);
		top = m_listBox.GetTopIndex();
		bottom = top + rectCurrent.bottom / m_cyNode;
		if (iMax < top || iMax > bottom)
			m_listBox.SetTopIndex(iMax - (bottom - top) / 2);
	}
	RecalcHorizontalExtent();
}


// REVIEW: This must be made to work with or without DBCS at all times!  (NO IFDEFS)
int CTreeCtl::OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex)
{
#ifdef DBCS
	char szB [3], szW [3];
#else
	char szB [2];
#endif

	int nItems = m_listBox.GetCount();
	int i = GetCurSel();
	
	if (i < 0 || nChar <= ' ')
		return -2;
	
#ifdef DBCS
	if (nChar > 255)
		nChar = (nChar << 8) | ((nChar >> 8) & 0xFF);
	szW[0] = (unsigned char)nChar;
	szW[1] = (unsigned char)(nChar >> 8);
	szW[2] = '\0';
	szB[2] = '\0';
#else
	szB[1] = '\0';
	nChar &= 0xFF;
#endif

	for (int j = 1; j < nItems; j += 1)
	{
		CNode* pNode = GetNode((i + j) % nItems);
		szB[0] = pNode->m_szText[0];
		
#ifdef DBCS
	if (IsDBCSLeadByte(szB[0]))
		szB[1] = pNode->m_szText[1];
	else
		szB[1] = '\0';
	
	if (lstrcmpi(szW, szB) == 0)
		break;
#else
	if (lstrcmpi((char*)&nChar, szB) == 0)
		break;
#endif

	}
	
	if (j == nItems)
		return -2;
	
	m_listBox.SetTopIndex((i + j) % nItems);
	
	return (i + j) % nItems;
}

BOOL CTreeCtl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message != WM_KEYDOWN || GetParentFrame()->IsIconic())
		return FALSE;
		
	switch (pMsg->wParam)
	{
	case VK_UP:
	case VK_DOWN:
	case VK_LEFT:
	case VK_RIGHT:
	case VK_PRIOR:
	case VK_NEXT:
	case VK_BACK:
	case VK_RETURN:
	case VK_ADD:
	case VK_SUBTRACT:
	case VK_MULTIPLY:
		// Make sure we get the keys we handle in OnKeyDown!
		::TranslateMessage(pMsg);
		::DispatchMessage(pMsg);
		return TRUE;
	}
	
	return FALSE;
}

// OnKeyDown and OnChar
//
// These two functions are called as the listbox receives keyboard input,
// and give you a chance to add specific keyboard processing for your
// tree.
//
// Note that you will receive both an OnKeyDown AND an OnChar for character
// input.
//
// Return TRUE if you handle this message, FALSE if you want default listbox
// handling to occur.
//
BOOL CTreeCtl::OnKeyDown(UINT nChar)
{
	int i = GetCurSel();
	if (i < 0)
		return TRUE;

	int j = 1;
	CNode* pNode = GetNode(i);
	CNode* pNodeT;

	switch (nChar)
	{
	case VK_LEFT:
		while ((pNodeT = GetNode(--i)) != NULL)
		{
			if (pNodeT == pNode->m_pParent)
			{
				KeySetSel(i);
				return TRUE;
			}
		}
		goto LSameSelection;
		
	case VK_RIGHT:
		if ((pNodeT = GetNode(i + 1)) == NULL || pNodeT->m_pParent != pNode)
		{
			goto LSameSelection;
		}
		KeySetSel(i + 1);
		return TRUE;
		
	case VK_UP:
		j = -1;
		// FALL THROUGH
		
	case VK_DOWN:
		if (GetKeyState(VK_CONTROL) >= 0)
		{
			ClearSearchBuffer();
			return FALSE;
		}
		
		while ((i += j) >= 0 && (pNodeT = GetNode(i)) != NULL)
		{
			if (pNodeT->m_pParent == pNode->m_pParent)
			{
				KeySetSel(i);
				return TRUE;
			}
		}
LSameSelection:
		MessageBeep(0);
		return TRUE;
		
	case VK_BACK:
		{
			if (i <= 0)
				return TRUE;
			
			int nStartLevel = pNode->m_nLevels;
			do
			{
				pNodeT = GetNode(--i);
			}
			while (i > 0 && pNodeT->m_nLevels >= nStartLevel);
			
			KeySetSel(i);
			return TRUE;
		}
		
	case VK_RETURN:
		OnPrimary();
		return TRUE;

	case VK_ADD:
		BeginWaitCursor();
		OnExpand();
		EndWaitCursor();
		return TRUE;
		
	case VK_SUBTRACT:
		BeginWaitCursor();
		OnCollapse();
		EndWaitCursor();
		return TRUE;
		
	case VK_MULTIPLY:
		BeginWaitCursor();
		if (GetKeyState(VK_CONTROL) < 0)
			OnExpandAll();
		else
			OnExpandBranch();
		EndWaitCursor();
		return TRUE;
	}

	return FALSE;
}

BOOL CTreeCtl::OnChar(UINT nChar)
{
	switch (nChar)
	{
	case '+':
		if (GetKeyState(VK_ADD) >= 0)
		{
			BeginWaitCursor();
			OnExpand();
			EndWaitCursor();
		}
		return TRUE;
		
	case '-':
		if (GetKeyState(VK_SUBTRACT) >= 0)
		{
			BeginWaitCursor();
			OnCollapse();
			EndWaitCursor();
		}
		return TRUE;
		
	case '*':
		if (GetKeyState(VK_MULTIPLY) >= 0)
		{
			BeginWaitCursor();
			if (GetKeyState(VK_CONTROL) < 0)
				OnExpandAll();
			else
				OnExpandBranch();
			EndWaitCursor();
		}
		return TRUE;
	}
	
	// if enough time has elapsed, or the user hits a control key (e.g.
	// backspace) zero the string.
	time_t timeNow = time(NULL);
	
	// need a place to store the lead byte of a DBC
	static TCHAR cLead;

	if (iscntrl(nChar) || (timeNow - m_timeLastKey > LIST_SEARCH_DELAY))
		ClearSearchBuffer();

	// process the key
	if ((m_listBox.GetCount() == 0) || iscntrl(nChar))
		return FALSE;

	if (cLead)
	{
		TCHAR szTmp[3];
		szTmp[0] = cLead;
		szTmp[1] = (TCHAR) nChar;
		szTmp[2] = _T('\0');
		
		cLead = 0;
		m_strSearch += CString( szTmp );
	}
	else
	{
		if (IsDBCSLeadByte( (char) nChar ))
		{
			cLead = (TCHAR) nChar;
			return TRUE;
		}

		m_strSearch += CString((char)nChar);
	}
	
	m_timeLastKey = timeNow;

	// look for a match
	CString str;
	int index, indexStart;
	index = indexStart = max(GetCurSel(), 0);

	do
	{
		GetNodeTitle(GetNode(index), str);
		if (m_strSearch.CompareNoCase(str.Left(m_strSearch.GetLength())) == 0)
		{
			// found a match
			KeySetSel(index, FALSE);
			return TRUE;
		}

		if (++index >= m_listBox.GetCount())
			index = 0;
	} while (index != indexStart);

	// no match found, but we did handle the key
	return TRUE;
}

void CTreeCtl::KeySetSel(int nIndex, BOOL bClearSearchBuffer)
{
	// called when user selects a specific item with the keyboard
	if (bClearSearchBuffer)
		ClearSearchBuffer();

	if (m_bIsMultiSelection)
		SetSel(-1, FALSE);

	SetSel(nIndex, TRUE);
	OnLbSelChange();
}

void CTreeCtl::ClearSearchBuffer()
{
	m_strSearch.Empty();
}



////////////////////////////////////////////////////////////////////////////
// Outline "command" handlers...

void CTreeCtl::OnPrimary()
{
	if (m_listBox.GetCaretIndex() != -1)
		OnOpen(m_listBox.GetCaretIndex());
	ClearSearchBuffer();
}

void CTreeCtl::OnExpand()
{
	CNode* pNode = GetNode();
	if (pNode != NULL && (pNode->m_nFlags & TF_EXPANDABLE) != 0 && !IsExpanded())
		Expand();
	ClearSearchBuffer();
}

void CTreeCtl::OnCollapse()
{
	CNode* pNode = GetNode();
	int nItem = m_listBox.GetCurSel();
	
	if ((pNode->m_nFlags & TF_EXPANDABLE) == 0)
	{
		if (nItem <= 0)
			return;
		
		int nStartLevel = pNode->m_nLevels;
		do
		{
			pNode = GetNode(--nItem);
		}
		while (nItem > 0 && pNode->m_nLevels >= nStartLevel);
	}
	
	if (pNode != NULL && IsExpanded(nItem))
		Collapse(nItem);
		
	ClearSearchBuffer();
}

void CTreeCtl::OnExpandBranch()
{
	int nIndex = GetCurSel();
	if (nIndex != LB_ERR)
		Expand(nIndex, TRUE);
	ClearSearchBuffer();
}

void CTreeCtl::OnExpandAll()
{
	// UNDONE: these cases could be consolidated
	SetCurSel(0);	// work-around for #2909
	ExpandAll();
	ClearSearchBuffer();
}

////////////////////////////////////////////////////////////////////////////


void CTreeCtl::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	lpMeasureItemStruct->itemHeight = m_cyNode;
}

void CTreeCtl::DrawNodeGlyph(CDC* pDC, CNode* pNode, BOOL bHighlight, CPoint pt)
{
	// Override this function to provide custom glyphs for folders or other nodes...
	
	c_imageWell.DrawImage(pDC, pt, (pNode->m_nFlags & TF_EXPANDED) != 0 ? 
		nOpenImage : nClosedImage);
}

void CTreeCtl::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	// dolphin 13143 [patbr] tree control faults with empty list box
	if (lpDrawItemStruct->itemData == NULL)
	{
		// list box is empty (only when Daytona not allowing access 
		// to process/thread info), so indicate that list box has focus.
		DrawFocusRect(lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem));
		return;								 
	}

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	CNode* pNode = (CNode*)lpDrawItemStruct->itemData;
//	CFont* pOldFont = pDC->SelectObject(pNode->GetFont());
	int cchText = _tcslen(pNode->m_szText);
	
	// our drawing starting point for this node from left and top
	CPoint	pt(c_cyBorderX2 + pNode->m_nLevels * m_sizeM.cx * 2, lpDrawItemStruct->rcItem.top);

	// our focus/highlight rectangle for the text
	CRect rect;

	rect.top = lpDrawItemStruct->rcItem.top;
	rect.left = pt.x + 2 * m_sizeM.cx + pNode->GetGlyphWidth() + c_cyBorderX2;
	rect.bottom = lpDrawItemStruct->rcItem.bottom;
	rect.right = rect.left + pDC->GetTextExtent(pNode->m_szText, cchText).cx + 4 * c_cyBorderX2;
	
	if (lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT))
	{
		int x = pt.x + m_sizeM.cx;	// initial drawing starting position
		x &= ~1;	// Make even;
		int y = pt.y + m_cyNode / 2; 
	//	int yp = y | 1; 

		BOOL bDrawSelected = (lpDrawItemStruct->itemState & ODS_SELECTED) != 0 ||
			(pNode->m_nFlags & TF_DROPTARGET) != 0;
		BOOL bHasFocus = ::GetFocus() == lpDrawItemStruct->hwndItem ||
			(pNode->m_nFlags & TF_DROPTARGET) != 0;
		COLORREF rgbText, rgbBackground;

		// First see if we have tested for expandability yet
		if (!((pNode->m_nFlags & TF_EXPANDABLE) || (pNode->m_nFlags & TF_NOT_EXPANDABLE)))
		{
			pNode->m_nFlags |= NodeIsExpandable(pNode) ? TF_EXPANDABLE : TF_NOT_EXPANDABLE;
			if (pNode->m_nFlags	& TF_NOT_EXPANDABLE)
			{
				pNode->m_nFlags &= ~TF_EXPANDED;
			}
		}
		
		
		// Draw the dotted lines...
		// use system color (button shadow) for tree control dotted lines (as in Windows95)
		COLORREF rgbForeground = pDC->SetTextColor(GetSysColor(COLOR_BTNSHADOW));
		CBrush* pOldBrush = pDC->SelectObject(CDC::GetHalftoneBrush());

		if (pNode->m_pParent != NULL || (pNode->m_nFlags & TF_EXPANDABLE) != 0)
		{
			// Draw the horizontal line over the (possible) folder
			// Draw on an odd lines so our hatch brush looks nice.
			pDC->PatBlt (x, y, m_sizeM.cx, 1, PATCOPY);
		}
		
		if (pNode->m_pParent != NULL)
		{
			// Draw the top part of the vertical line
			pDC->PatBlt (x, rect.top, 1, m_cyNode / 2, PATCOPY); 
			
			// If not the end of a node, draw the bottom part
			if ((pNode->m_nFlags & TF_LASTLEVELENTRY) == 0)
			{
				pDC->PatBlt (x, y + c_cyBorder, 1, m_cyNode / 2, PATCOPY); 
			}

			// Draw the verticals on the left connecting other nodes
			int nLevel = pNode->m_nLevels;
			for (CNode* pNodeT = pNode->m_pParent; pNodeT != NULL; pNodeT = pNodeT->m_pParent)
			{
				nLevel -= 1;

				if (!(pNodeT->m_nFlags & TF_LASTLEVELENTRY) && (pNodeT->m_pParent != NULL))
				{
					int	x = (nLevel + 1) * m_sizeM.cx * 2 + c_cyBorderX2 - m_sizeM.cx;
					x &= ~1;	// Make even;
					pDC->PatBlt(x, rect.top, 1, m_cyNode, PATCOPY); 
				}
			}
		}
		
		pDC->SetTextColor(rgbForeground);
		pDC->SelectObject(pOldBrush);
		
		
		// Draw the boxed plus/minus sign if appropriate...

		//[byrond] Use our own brush
		pDC->SelectObject ( &theApp.m_BrushWindow );
		
		if ((pNode->m_nFlags & TF_EXPANDABLE) != 0)
		{
			// Draw the box	[+] or [-]
			c_imageWell.DrawImage(pDC, 
				CPoint(x - cxExpandBox / 2, y - cyExpandBox / 2), 
				(pNode->m_nFlags & TF_EXPANDED) ? nMinusImage : nPlusImage);

			// use system color (button shadow) for plus/minus sign frames (as in Windows95)
			COLORREF rgbForeground = GetSysColor(COLOR_BTNSHADOW);
			CBrush br(rgbForeground);
			pOldBrush = pDC->SelectObject(&br);

			pDC->PatBlt(x - cxExpandBox / 2 + 1, y - cyExpandBox / 2 + 1, cxExpandBox - 2, 1, PATCOPY); 
			pDC->PatBlt(x - cxExpandBox / 2 + 1, y + cyExpandBox / 2 - 1, cxExpandBox - 2, 1, PATCOPY); 
			pDC->PatBlt(x - cxExpandBox / 2 + 1, y - cyExpandBox / 2 + 1, 1, cyExpandBox - 2, PATCOPY); 
			pDC->PatBlt(x + cxExpandBox / 2 - 1, y - cyExpandBox / 2 + 1, 1, cyExpandBox - 2, PATCOPY); 
	
			pDC->SelectObject(pOldBrush);
		}
		
		
		// Draw the glyph...
		
		DrawNodeGlyph(pDC, pNode, bDrawSelected && bHasFocus,
			CPoint(x + m_sizeM.cx + c_cyBorder, y - (cyFolder / 2)));
		
		
		// Draw the text...
		
		if ((bHasFocus || m_bKeepSelectionRect) && bDrawSelected)
		{
			rgbText = pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
			rgbBackground = pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		}
		
		pDC->ExtTextOut(rect.left + c_cyBorderX2 * 2,
			y - (m_sizeM.cy / 2), ETO_OPAQUE, &rect, pNode->m_szText, cchText, NULL);
		
		if (bDrawSelected)
		{
			if (bHasFocus || m_bKeepSelectionRect)
			{
				pDC->SetTextColor(rgbText);
				pDC->SetBkColor(rgbBackground);
			}
			else
			{
				// Highlight is a frame when we don't have the focus...
				CBrush brush;
				if (brush.CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)))
					pDC->FrameRect(&rect, &brush);
			}
		}
	}
	
	if (lpDrawItemStruct->itemAction == ODA_FOCUS)
		pDC->DrawFocusRect(&rect);

//	pDC->SelectObject(pOldFont);
}


void CTreeCtl::Collapse(CNode* pNode, int nIndex)
{
	CNode* pParentNode = pNode;
	int nIndexT = nIndex;
	int cDeleted = 0;
	int iCurSel = m_listBox.GetCurSel();
	
	m_listBox.SetRedraw(FALSE);
	
	nIndexT += 1;
	
	for (;;)
	{
		if ((pNode = GetNode(nIndexT)) == NULL)
			break;
		
		if (pNode->m_nLevels <= pParentNode->m_nLevels)
			break;

		DeleteNode(pNode);
		cDeleted++;
		
		m_listBox.DeleteString(nIndexT);
	}
	
	FlushTheCache();	//[byrond]
	pParentNode->m_nFlags &= ~TF_EXPANDED;

	if (iCurSel > nIndex)
	{
		// selection/focus needs was after the collapsed item,
		// need to adjust...

		if (iCurSel <= nIndex + cDeleted)
		{
			// selection/focus was inside the block of deleted
			// items, make the top level node the selected node
			iCurSel = nIndex;

		}
		else
		{
			// selection/focus was after the block of deleted
			// items, move the selection up by the number of
			// deleted items

			iCurSel -= cDeleted;
		}

		m_listBox.SetCurSel(iCurSel);

		if (m_bIsMultiSelection)
		{
			m_listBox.SetCaretIndex(iCurSel);
			m_listBox.SetSel(iCurSel, TRUE);
		}

	#ifdef _WIN32
		SendMessage(WM_COMMAND, 
			MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetListBox()->GetSafeHwnd());
	#else
		SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
			MAKELPARAM(GetListBox()->GetSafeHwnd(), LBN_SELCHANGE));
	#endif
	}
	
	if (m_EnableUpdates == 0) 
	{
		m_listBox.SetRedraw (TRUE);
		m_listBox.Invalidate();
	}
}

void CTreeCtl::Refresh(CNode *pParentNode, int nIndex)
{
	CNode * pNextNode;
	int nIndexT;

	// is this node dirty?
	if (pParentNode->m_nFlags & TF_DIRTY_CONTENT)
	{
		// reset this node dirty bit
		pParentNode->m_nFlags &= ~TF_DIRTY_CONTENT;

		// if is is expanded? then collapse it
		if (pParentNode->m_nFlags & TF_EXPANDED)
			Collapse(nIndex);

		// reset the expandablity of this node
		pParentNode->m_nFlags &= ~(TF_EXPANDABLE | TF_NOT_EXPANDABLE);
		pParentNode->m_nFlags |= NodeIsExpandable(pParentNode) ? TF_EXPANDABLE : TF_NOT_EXPANDABLE;
		// is it potentially expandable?
		if (pParentNode->m_nFlags & TF_EXPANDABLE)
		{
			Expand(nIndex, FALSE);
		}
	}
	// if we have children and we are expanded
	// then perform this function on each of the children first
	else if (pParentNode->m_nFlags & (TF_HASCHILDREN | TF_EXPANDED))
	{
		nIndexT = nIndex + 1;
		for (;;)
		{
			if ((pNextNode = GetNode(nIndexT)) == NULL)
				break;	// do we have a child? ie. not end of list
		
			if (pNextNode->m_nLevels <= pParentNode->m_nLevels)
				break;	// is this one of our siblings?

			if (pNextNode->m_nLevels == (pParentNode->m_nLevels + 1))
				Refresh(pNextNode, nIndexT);	// refresh this child

			nIndexT++;
		}
	}


	if (pParentNode->m_nFlags & TF_DIRTY_ITEM)
	{
		// reset this node dirty bit
		pParentNode->m_nFlags &= ~TF_DIRTY_ITEM;

		// get the (possibly new) text for this node
		CString	strTitle;
		GetNodeTitle(pParentNode, strTitle);

		ASSERT(pParentNode->m_szText != NULL);
		delete [] pParentNode->m_szText;
		pParentNode->m_szText = new char[strTitle.GetLength() + 1];
		_tcscpy(pParentNode->m_szText, strTitle);
		// [byrond] Don't need to flush the cache
		// because the indices didn't change
	}
}

void CTreeCtl::FreeAllTreeData()
{
	int nIndex = m_listBox.GetCount();
	while (--nIndex >= 0)
	{
		CNode * pNode = (CNode *)m_listBox.GetItemDataPtr(nIndex);

		DeleteNode(pNode);
	}
	m_listBox.ResetContent();
	FlushTheCache();	//[byrond]
}

int CTreeCtl::CompareData(const CNode* pNode1, const CNode* pNode2)
{
	if (pNode1 == pNode2)
		return 0;
	
	int ret = CompareData(pNode1->m_pParent, pNode2->m_pParent);
	
	if (ret == 0)
	{
		ret = _tcsicmp (pNode1->m_szText, pNode2->m_szText);

		// if we have a match then compare the data
		if (ret == 0 && (pNode1->m_dwData != 0 || pNode2->m_dwData != 0))
		{
			if (pNode1->m_dwData == pNode2->m_dwData)
				ret = 0;
			else
				ret = (int) (pNode1->m_dwData - pNode2->m_dwData);
		}
	}
	
	return ret;
}

int CTreeCtl::CompareNodes(const CNode* pNode1, const CNode* pNode2)
{
	const CNode* pSav1;
	const CNode* pSav2;
	
	pSav1 = pNode1;
	pSav2 = pNode2;
	
	while (pNode1->m_nLevels > pNode2->m_nLevels)
		pNode1 = pNode1->m_pParent;
		
	while (pNode2->m_nLevels > pNode1->m_nLevels)
		pNode2 = pNode2->m_pParent;

	int ret = CompareData(pNode1, pNode2);

	if (ret == 0)
		ret = pSav1->m_nLevels - pSav2->m_nLevels;
	
	return ret;
}

int CTreeCtl::FindNode(DWORD dwData)
{
	int nCount = m_listBox.GetCount();
	for (int i = 0; i < nCount; i += 1)
	{
		if (GetNode(i)->m_dwData == dwData)
			return i;
	}
	
	return LB_ERR;
}

int CTreeCtl::FindNode(const TCHAR * szText, DWORD & dwData, BOOL fMatchCase)
{
	int nCount = m_listBox.GetCount();
	for (int i = 0; i < nCount; i += 1)
	{
		CNode * pNode = GetNode(i); ASSERT(pNode != (CNode *)NULL);

		if ((fMatchCase && !_tcsicmp(pNode->m_szText, szText) || !_tcscmp(pNode->m_szText, szText)))
		{
			dwData = pNode->m_dwData;
			return i;	// success, return index of node and assoc. data
		}
	}

	return LB_ERR;	// not found
}

int CTreeCtl::InsertNode(int iParentNode, const char* szName, DWORD dwData)
{
	CNode * pNode;
	int iNode;
	
	if (!InsertNode(GetNode(iParentNode), iParentNode, szName, dwData, pNode, iNode))
		return LB_ERR;
	
	return iNode;
}

void CTreeCtl::DirtyNode(int iNode, WORD tf)
{
	CRect rect;
	CNode * pNode = GetNode(iNode);
	ASSERT(pNode != NULL);
	pNode->m_nFlags |= tf;

	Invalidate();
}

void CTreeCtl::RemoveNode(int iNode, BOOL bUpdateSel /* = TRUE*/)
{
	CRect rect,rect1;
	CNode* pNode = GetNode(iNode), *pNode1;
	int i;
	ASSERT(pNode != NULL);
	if ((pNode->m_nFlags & TF_EXPANDED) != 0)
		Collapse(pNode, iNode);

	// Don't know anymore if parent is expandable or not:
	if (pNode->m_pParent != NULL)
		pNode->m_pParent->m_nFlags &= ~(TF_EXPANDABLE | TF_NOT_EXPANDABLE);

	if (pNode->m_nFlags & TF_LASTLEVELENTRY)
	{
		m_listBox.GetItemRect(iNode, &rect);
		i = iNode - 1;
		do
		{
			ASSERT(i >= 0);
			pNode1 = GetNode(i);
			m_listBox.GetItemRect(i, &rect1);
			rect.UnionRect (rect, rect1);
			i--;
		}
		while (i >= 0 && pNode1->m_nLevels != pNode->m_nLevels);

		if (pNode1->m_nLevels == pNode->m_nLevels)
			pNode1->m_nFlags |= TF_LASTLEVELENTRY;
		m_listBox.InvalidateRect(&rect);
	}

	int iCurSel = m_listBox.GetCurSel();
	m_listBox.DeleteString(iNode);
	DeleteNode(pNode);
	if (iCurSel == iNode && bUpdateSel)
	{
		int nCount = m_listBox.GetCount();
		if (iCurSel > nCount - 1)
			iCurSel = nCount - 1;

		m_listBox.SetCurSel(iCurSel);

		if (m_bIsMultiSelection)
		{
			m_listBox.SetCaretIndex(iCurSel);
			m_listBox.SetSel(iCurSel, TRUE);
		}

#ifdef _WIN32
	    SendMessage(WM_COMMAND, 
			MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetListBox()->GetSafeHwnd());
#else
	    SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
	        MAKELPARAM(GetListBox()->GetSafeHwnd(), LBN_SELCHANGE));
#endif
	}
	FlushTheCache();	//[byrond]
}

BOOL CTreeCtl::InsertNode(CNode* pParentNode, int iParentNode, 
	const char* szName, DWORD dwData, CNode*& rpNodeRet, int& riNodeRet)
{
	CClientDC dc(this);
//	[patbr] don't reset the font--horz. scroll bars will screw up.
	dc.SelectObject((CFont *)CFont::FromHandle((HFONT)SendMessage(WM_GETFONT, 0, 0)));
	
	int len = _tcslen(szName);
	CNode* pNode = CreateNode(dwData);
	
	pNode->m_pParent = pParentNode;

#ifdef _DEBUG
	// make sure that the parent links are valid CNode address
	// (we'd use ASSERT_VALID, but CNode is not a CObject)
	CNode * pTemp = pNode;
	while ((pTemp = pTemp->m_pParent) != NULL)
	{	
		ASSERT(AfxIsValidAddress(pTemp, sizeof(CNode)));
	}
#endif

	pNode->m_nLevels = pParentNode != NULL ? (pParentNode->m_nLevels + 1) : 0;
	pNode->m_dwData = dwData;
	pNode->m_nFlags = 0;
	pNode->m_szText = new char[len + 1];
	_tcscpy(pNode->m_szText, szName);
	
	if (pParentNode != NULL)
	{
		pParentNode->m_nFlags |= TF_HASCHILDREN | TF_EXPANDED | TF_EXPANDABLE;
	 	pParentNode->m_nFlags &= ~TF_NOT_EXPANDABLE;
	}
	// Get text extent from a compatible DC that we know is already
	// setup with our font:
	pNode->m_nWidth =  dc.GetTextExtent (pNode->m_szText, len).cx
						+ (2 * (pNode->m_nLevels + 1)) * m_sizeM.cx +
						cxFolder + c_cyBorderX2 * 6;

	// Find the insert point with a binary search	
	int iMax = m_listBox.GetCount();
	if (iMax > 0)
	{
		int iMin = iParentNode + 1;
		iMax -= 1;
		
		//[byrond] We allow unsorted trees in Spy++ (for Windows, for instance)
		if (m_bSorted)
		{
			// Find the insert point with a binary search
			do
			{
				int iMid = (iMax + iMin) / 2;

				CNode* pMid = GetNode(iMid);
#ifdef _DEBUG
				CNode * pTemp = pMid;
				while ((pTemp = pTemp->m_pParent) != NULL)
				{	
					ASSERT(AfxIsValidAddress(pTemp, sizeof(CNode)));
				}
#endif
				if (CompareNodes(pNode, pMid) > 0)
					iMin = iMid + 1;
				else
					iMax = iMid - 1;
			}
			while (iMax > iMin);

			// can't compare to our parent? (we are at the root if iMax < 0)
			if (iMax >= 0)
			{
				CNode* pNodeT = GetNode(iMax);
				if (CompareNodes(pNode, pNodeT) > 0)
					iMax += 1;
			}
			else
			{
				iMax = 0;   // insert at front
			}
		}
		//[byrond] Handle unsorted lines quickly, using the cache
		else
		{
			if (m_pParentNodeCache == pParentNode)
			{
				iMax = m_iNextCache;
			}
			else
			{
				CNode* pNodeT;

				//
				// Look for the last item on this level
				//
				do
				{
					pNodeT = GetNode(iMin);

					if (!pNodeT || pNodeT->m_nLevels < pNode->m_nLevels)
					{
						break;
					}

					iMin++;
				}
				while (iMax >= iMin);

				iMax = iMin;
			}

			//
			// Cache this parent node and the next insert point.
			// Note that this is only done if the tree is not sorted.
			//
			m_pParentNodeCache = pParentNode;
			m_iNextCache = iMax + 1;
		}
	}
	
	// look for the first node on this level above us and turn off its
	// TFD_LASTLEVELENTRY flag so it gets a line down to this node
	
	int i = iMax - 1;
	while (i >= 0)
	{
		CNode* pNodeT = GetNode(i--);
		if (pNodeT->m_nLevels == pNode->m_nLevels)
		{
			pNodeT->m_nFlags &= ~TF_LASTLEVELENTRY;
			break;
		}
		
		if (pNodeT->m_nLevels < pNode->m_nLevels)
			break;
	}
	
	CNode* pNodeT;
	if ((pNodeT = GetNode(iMax)) == NULL ||
		pNodeT->m_nLevels < pNode->m_nLevels)
	{
		pNode->m_nFlags |= TF_LASTLEVELENTRY;
	}
	
    rpNodeRet = pNode;
	VERIFY((riNodeRet = m_listBox.InsertString(iMax, (LPSTR)pNode)) != LB_ERR);
	VERIFY((m_listBox.SetItemDataPtr(riNodeRet, (void *)pNode)) != LB_ERR);
	// [byrond] The cache for the next insert point was set above if needed...
		
	return TRUE;
}

BOOL CTreeCtl::InsertLevel(CNode* pParentNode, int nParentIndex, BOOL bExpandAll)
{
	// NOTE: This function must be overridden for a CTreeCtl to be useful,
	// this is a template of what a real one should look like.
	/*
	for (each item in pParentNode)
	{
		CNode* pNode;
		int iNode;
		if (!InsertNode(pParentNode, nParentIndex, "string", 0, pNode, iNode))
		{
			TRACE("CTreeCtl::InsertLevel: call to InsertNode failed!\n");
			return FALSE;
		}
		
		if (pNode has children && bExpandAll && !InsertLevel(pNode, iNode, TRUE))
			return FALSE;
	}
	*/

	ASSERT(FALSE);
	
	return TRUE;
}

CNode* CTreeCtl::GetNode(int nIndex)
{
	if (nIndex == -1 && (nIndex = GetCurSel()) == LB_ERR)
		return NULL;
	
	CNode* pNode = (CNode*)m_listBox.GetItemDataPtr(nIndex);
	if (pNode == (CNode*)LB_ERR)
		return NULL;
	
	return pNode;
}

BOOL CTreeCtl::NodeIsExpandable(CNode *)
{
	// NOTE: This function must be overridden for a CTreeCtl to be useful,
	ASSERT (FALSE);

	return FALSE;
}

void CTreeCtl::Expand(int nIndex, BOOL bWholeBranch)
{
	if (nIndex == -1)
	{
		nIndex = GetCurSel();
		if (nIndex == LB_ERR)	// ignore if no current selection
			return;
	}
	else if (bWholeBranch && GetCurSel() != LB_ERR && nIndex != GetCurSel())
	{
		SetCurSel(nIndex);
	}
	
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::Expand: %d invalid index!\n", nIndex);
		return;
	}

	// Update the nodes expandable/unexpandable bit.  Then see if we can
	// really expand this node:
	if (!((pNode->m_nFlags & TF_EXPANDABLE) || (pNode->m_nFlags & TF_NOT_EXPANDABLE)))
	{
		pNode->m_nFlags |= NodeIsExpandable(pNode) ? TF_EXPANDABLE : TF_NOT_EXPANDABLE;
		if (pNode->m_nFlags	& TF_NOT_EXPANDABLE)
		{
			pNode->m_nFlags &= ~TF_EXPANDED;
			return;
		}
	}
	
	if ((pNode->m_nFlags & TF_EXPANDED) && (!bWholeBranch))  // [KRS:2020]
		return;			// nothing to do unless recursive
	
	m_listBox.SetRedraw(FALSE);
	
	int iCurrentIndex = GetCurSel();
	int iNumExpanded = m_listBox.GetCount();
	int iTopIndex = m_listBox.GetTopIndex();
	CRect rc; m_listBox.GetClientRect(&rc);
	int iBottomIndex = iTopIndex + (rc.bottom + 1) / m_cyNode;
	
	// this is a really bad hack and it complicates the logic
	// for figuring out how to adjust the selection as a result
	// of doing an expand.  The problem is that this might be
	// an expand-all operation in which case we want the whole
	// tree to appear but we don't have code to do that if
	// the tree is already partly expanded so we do this collapse
	// and then expand thing... swell... [rm]
	
	if (pNode->m_nFlags & TF_EXPANDED) // [KRS:2020]
	{
		ASSERT(bWholeBranch);
		// PDC hack: collapse tree before expanding to avoid having
		// to deal with partially expanded branches
		Collapse(pNode,nIndex);
		m_listBox.SetRedraw(FALSE);
	}

	// must get the state after the possible delete above because
	// the selection and count may have changed...  I know this
	// is redundant but until the above code can be deleted
	// we can't use the variables that are already available [rm]

	int iCurSel   = m_listBox.GetCurSel();	// sel after possible collapse above
	int cItemsNew = m_listBox.GetCount();  // kinda redundant with iNumExpanded

	InsertLevel(pNode, nIndex, bWholeBranch);
	
	int iExpandInView = iBottomIndex - iCurrentIndex;
	iNumExpanded = m_listBox.GetCount() - iNumExpanded;
	
	cItemsNew = m_listBox.GetCount() - cItemsNew;

	if (iCurSel > nIndex)
	{
		// selection was after the expand point, must adjust...

		iCurSel += cItemsNew;

		m_listBox.SetCurSel(iCurSel);

		if (m_bIsMultiSelection)
		{
			m_listBox.SetCaretIndex(iCurSel);
			m_listBox.SetSel(iCurSel, TRUE);
		}

#ifdef _WIN32
	    SendMessage(WM_COMMAND, 
			MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetListBox()->GetSafeHwnd());
#else
	    SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
	        MAKELPARAM(GetListBox()->GetSafeHwnd(), LBN_SELCHANGE));
#endif
	}
	
	if (iNumExpanded >= iExpandInView)
	{
		m_listBox.SetTopIndex(min(iCurrentIndex, 
			iTopIndex + iNumExpanded - iExpandInView + 1));
	}
	
	RecalcHorizontalExtent ();
	if (m_EnableUpdates == 0) 
	{
		m_listBox.SetRedraw (TRUE);
		if (iNumExpanded != 0)
			m_listBox.Invalidate();
	}
	
}

void CTreeCtl::ExpandAll()
{
	int nIndex = 0;
	CNode * pNode;

	HoldUpdates();

	while ((pNode = GetNode(nIndex)) != (CNode *)NULL)
	{
		// root node?
		if (pNode->m_nLevels == 0)
			Expand(nIndex, TRUE);
		nIndex++;
	}
	SetCurSel(0);

	EnableUpdates();
}

void CTreeCtl::Collapse(int nIndex)
{
	if (nIndex == -1)
		nIndex = GetCurSel();
	
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::Collapse: %d invalid index!\n", nIndex);
		return;
	}
	
	if ((pNode->m_nFlags & TF_EXPANDED) == 0)
		return;
	
	Collapse(pNode, nIndex);
	RecalcHorizontalExtent ();
}

void CTreeCtl::RefreshAllRoots()
{
	if (m_EnableUpdates > 0) return;

	int nIndex = 0;
	CNode * pNode;
	while ((pNode = GetNode(nIndex)) != (CNode *)NULL)
	{
		// root node?
		if (pNode->m_nLevels == 0)
			Refresh(pNode, nIndex);
		nIndex++;
	}
}

void CTreeCtl::Refresh(int nIndex)
{
	if (m_EnableUpdates > 0) return;

	if (nIndex == -1)
		nIndex = GetCurSel();
	
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::Refresh: %d invalid index!\n", nIndex);
		return;
	}
	
	Refresh(pNode, nIndex);
}

BOOL CTreeCtl::IsExpanded(int nIndex)
{
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::IsExpanded: %d invalid index!\n", nIndex);
		return FALSE;                             
	}
	
	return (pNode->m_nFlags & TF_EXPANDED) != 0;
}

BOOL CTreeCtl::HasChildren(int nIndex /*= -1*/ )
{
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::HasChildren: %d invalid index!\n", nIndex);
		return FALSE;                             
	}
	
	return (pNode->m_nFlags & TF_HASCHILDREN) != 0;
}

DWORD CTreeCtl::GetData(int nIndex)
{
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
		return NULL;
	return pNode->m_dwData;
}

void CTreeCtl::SetData(int nIndex, DWORD dwData)
{
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::SetData %d invalid index\n", nIndex);
		return;
	}
	
	pNode->m_dwData = dwData;
}


CTreeCtl::HIT_ZONE CTreeCtl::HitTest(int nItem, int x)
{
	CNode* pNode = GetNode(nItem);
	ASSERT(pNode != NULL);
	
	CRect client;
	GetClientRect(client);
	
	if (m_cxExtent > client.right)
		x += m_listBox.GetScrollPos(SB_HORZ) * (m_cxExtent - client.right) / 100;
	
	int xLeft = c_cyBorderX2 + pNode->m_nLevels * m_sizeM.cx * 2;
	if ((pNode->m_nFlags & TF_EXPANDABLE) != 0)
	{
		if (x < xLeft)
			return left;
		if (x < xLeft + 2 * m_sizeM.cx)
			return expand;
	}
	
	xLeft += 2 * m_sizeM.cx;
	if (x < xLeft)
		return left;
	
	xLeft += cxFolder + c_cyBorderX2;
	if (x < xLeft)
		return glyph;
	
	CClientDC dc(this);
	dc.SelectObject(pNode->GetFont());

	// Extra area between primary glyph and text is in the text zone...
	xLeft += pNode->GetGlyphWidth() - cxFolder;
	
	xLeft += dc.GetTextExtent(pNode->m_szText, _tcslen(pNode->m_szText)).cx +
		4 * c_cyBorderX2;
	if (x < xLeft)
		return text;
	
	return right;
}

/////////////////////////////////////////////////////////////////////////////
// CTreeListBox -- the actual list box inside a tree control

int CTreeListBox::iSlobPixels = 5;
CPoint CTreeListBox::mouseDownPt;

CTreeListBox::CTreeListBox()
{
	m_pTree = NULL;
    m_bGotMouseDown = FALSE;
    m_bDeferedDeselection = FALSE;
	m_bStdMouse = TRUE;
}

int CTreeListBox::ItemFromPoint(const CPoint& point)
{
    CRect client;
    GetClientRect(&client);

    if (!client.PtInRect(point))
        return LB_ERR;

    CRect itemRect;
    GetItemRect(0, &itemRect);

	int nItem = (GetTopIndex() + (point.y / itemRect.Height()));
	return nItem < GetCount() ? nItem : LB_ERR;
}

void CTreeListBox::OnLButtonDown(UINT nFlags, CPoint pt)
{
	BOOL bPassOn = TRUE;

	SetFocus();
	SetCapture();

	m_bStdMouse = TRUE;
	
	int nItem = ItemFromPoint(pt);
	if (nItem != LB_ERR)
	{
		int nCurSel = GetCurSel();
		int nCount = GetCount();
	//	SetCurSel(nItem);
		CTreeCtl::HIT_ZONE hitZone = m_pTree->HitTest(nItem, pt.x);
		
		if (hitZone == CTreeCtl::expand)
		{
			// Inside the expand/collapse box...
		
			m_pTree->OnOpen(nItem);

			if (nItem < nCurSel)
			{
				if (GetCount() > nCount)
				{
					// did expand, change selection accordingly
					SetCurSel(nCurSel + GetCount() - nCount);
				}
				else if (GetCount() < nCount)
				{
					// did collapse, change selection accordingly
					if (nCurSel > (nItem + (nCount - GetCount())))
					{
						// previous selection not in collapsed area, reset selection
						SetCurSel(nCurSel + GetCount() - nCount);
					}
					else
					{
						// previous selection in collapsed area, set selection to collapsed node
						SetCurSel(nItem);
					}
				}
			}

			// don't change selection unless we just cleared in
			// by collapsing the tree...
			if (GetSelCount() != 0)
				return;
		}
	
		if (m_pTree->m_bEnableDragDrop && 
			(hitZone == CTreeCtl::glyph || hitZone == CTreeCtl::text))
		{
			// Inside glyph or text and D&D is enabled...
		
			m_bStdMouse = FALSE;
		    m_bGotMouseDown = TRUE;
		    mouseDownPt = pt;

		    if ((nFlags & MK_SHIFT) == 0 && GetSel(nItem))
			{
		        // don't deselect yet, wait for either a mouse up or a drag and drop
		        m_bDeferedDeselection = TRUE;
		        m_nDeferedItem = nItem;
				return;
			}
			else
			{
				if ((nFlags & MK_SHIFT) != 0)
				{
					// Shift held down - so select a range, but do not pass on.
					int nCurrentSel;

					SetSel(-1, FALSE);
					nCurrentSel = GetCaretIndex();
					if (nCurrentSel > nItem)
						SelItemRange(TRUE, nItem, nCurrentSel);
					else
						SelItemRange(TRUE, nCurrentSel, nItem);
 				}
				else
				{
 					// Only clear selection if CONTROL key not pressed
					if ((nFlags & MK_CONTROL) == 0)
						SetSel(-1, FALSE);
			    	SetSel(nItem, TRUE);
				}
				bPassOn = FALSE;
			}
		}
	}

	if (bPassOn)
		CListBox::OnLButtonDown(nFlags, pt);	// pass on

	if (m_pTree->m_bEnableDragDrop)
	{
#ifdef _WIN32
	    GetParent()->SendMessage(WM_COMMAND, 
			MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetSafeHwnd());
#else
	    GetParent()->SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
	        MAKELPARAM(GetSafeHwnd(), LBN_SELCHANGE));
#endif
	}
}

void CTreeListBox::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	int nItem = ItemFromPoint(point);
	if (nItem != LB_ERR)
	{
		switch (m_pTree->HitTest(nItem, point.x))
		{
		case CTreeCtl::expand:
			// Treat as single click...
			m_pTree->OnOpen(nItem);
			return;
			
		case CTreeCtl::left:
		case CTreeCtl::right:
			// Ignore the double click...
			return;
		
		case CTreeCtl::glyph:
		case CTreeCtl::text:
			break;
		}
	}

	CListBox::OnLButtonDblClk(nFlags, point);
}

void CTreeListBox::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bStdMouse || !m_pTree->m_bEnableDragDrop)
	{
		CListBox::OnMouseMove(nFlags, point);
		return;
	}

    // Nasty hack here because Windows sends a continuous stream of
    // WM_MOUSEMOVE messages when a button is held down...
    static CPoint NEAR lastPoint;
    if ((point == lastPoint) || (GetCount() == 0))
        return;

    lastPoint = point;

    CPoint offsetPoint (abs(mouseDownPt.x - point.x),
                        abs(mouseDownPt.y - point.y));

    if (m_bGotMouseDown && offsetPoint.x + offsetPoint.y > iSlobPixels && GetSelCount() > 0)
    {
		// Begin a drag...
		m_pTree->BeginDragDrop();

        m_bGotMouseDown = FALSE;
        m_bDeferedDeselection = FALSE;
    }
}

void CTreeListBox::OnLButtonUp(UINT nFlags, CPoint pt)
{
	if (!m_bStdMouse && m_pTree->m_bEnableDragDrop)
	{
		m_bGotMouseDown = FALSE;

		if (m_bDeferedDeselection)
		{
		    if (nFlags & MK_CONTROL)
		    {
		        SetSel(m_nDeferedItem, FALSE);
		    }
		    else
		    {
		        SetSel(-1, FALSE);
		        SetSel(m_nDeferedItem, TRUE);
		    }
		    m_bDeferedDeselection = FALSE;
#ifdef _WIN32
	        GetParent()->SendMessage(WM_COMMAND, 
				MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetSafeHwnd());
#else
	        GetParent()->SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
	            MAKELPARAM(GetSafeHwnd(), LBN_SELCHANGE));
#endif
		}
    }

    // need to call Windows so notifications get sent
    CListBox::OnLButtonUp(nFlags, pt);
	ReleaseCapture();
}

void CTreeListBox::OnRButtonUp(UINT nFlags, CPoint pt)
{
	CListBox::OnRButtonUp(nFlags, pt);	// pass on

	CWnd *	pwnd = GetParent();

	ASSERT(pwnd->IsKindOf(RUNTIME_CLASS(CTreeCtl)));

	// inform the tree control of this
	((CTreeCtl *)pwnd)->OnRightButtonUp(nFlags, pt);
}

void CTreeListBox::OnRButtonDown(UINT nFlags, CPoint pt)
{
	//[byrond] Don't update this routine because we don't have CSlobWnds,
	// and our handler for OnRightButtonDown will handle it!
	CListBox::OnRButtonDown(nFlags, pt);	// pass on

	CWnd *  pwnd = GetParent();

	ASSERT(pwnd->IsKindOf(RUNTIME_CLASS(CTreeCtl)));

	// inform the tree control of this
	((CTreeCtl *)pwnd)->OnRightButtonDown(nFlags, pt);
}

void CTreeListBox::OnKeyDown(UINT nChar, UINT nRepCount, UINT nFlags)
{
	if (m_pTree->OnKeyDown(nChar))
		return;

	CListBox::OnKeyDown(nChar, nRepCount, nFlags);
}

void CTreeListBox::OnChar(UINT nChar, UINT nRepCount, UINT nFlags)
{
	if (m_pTree->OnChar(nChar))
		return;

	CListBox::OnChar(nChar, nRepCount, nFlags);
}

void CTreeCtl::OnRightButtonUp(UINT, CPoint)
{
	// do nothing .. derived class implementation is more useful
}

void CTreeCtl::OnRightButtonDown(UINT, CPoint)
{
	// do nothing .. derived class implementation is more useful
}

void CTreeCtl::OnLbDblClk()
{	
	// CHICAGO: Move property activation to rbutton.
	//if (m_bShowProperties && (GetKeyState(VK_MENU) & ~1) != 0)
	//{
	//	ActivatePropertyBrowser();
	//	return;
	//}

	OnPrimary();
}

void CTreeCtl::OnLbSelChange()
{
	OnSelect(GetCurSel());
}

void CTreeCtl::OnOpen(int nIndex)
{
	CNode* pNode = GetNode(nIndex);
	if (pNode != NULL)
	{
		if (IsExpanded(nIndex))
		{
			BeginWaitCursor();
			Collapse(nIndex);
			EndWaitCursor();
		}
		else if (pNode->m_nFlags & TF_EXPANDABLE)
		{
			BeginWaitCursor();
			Expand(nIndex);
			EndWaitCursor();
		}
	}
}

void CTreeCtl::OnSelect(int nIndex)
{
}

#if 0 //[byrond] Unused code follows:
struct TreeData
{
	WORD	wSize;
	int 	nCurSel;
	int		nLastSel;
	int		nTopIndex;
	int		nExpandedNodes[1];
};

BYTE* CTreeCtl::GetInitData()
{
	// Create a block of intit data for workspace saving.  This should enable the
	// reconstruct its state in ReadInitData.

	int nIndex = m_listBox.GetCount(), nExpanded = 0, i, nDataSize;
	int *pint = new int[nIndex];
	TreeData *pdata;
	ASSERT (nIndex);
	for (i=0; i < nIndex; i++)
	{
		CNode * pNode = (CNode *) m_listBox.GetItemDataPtr(i);
		if (pNode->m_nFlags & TF_EXPANDED) pint[nExpanded++] = i;
	}

	nDataSize = sizeof (TreeData) + max (nExpanded -1,0) * sizeof (int);

	pdata = (TreeData *) new BYTE[ nDataSize ];
	pdata->wSize = nDataSize - sizeof ( WORD );

	pdata->nTopIndex = m_listBox.GetTopIndex ();

	if (nExpanded > 0)
		memcpy ( pdata->nExpandedNodes, pint, nExpanded * sizeof (int));
	else pdata->nExpandedNodes[0] = -1;

	if (m_bIsMultiSelection)
	{
		pdata->nLastSel = m_listBox.GetSelItems (m_listBox.GetCount(), pint);
		pdata->nCurSel = *pint;
		pdata->nLastSel += *pint;
	}
	else pdata->nCurSel = m_listBox.GetCurSel ();

	delete [] (pint);
	return (BYTE *) pdata;
}						 	

void CTreeCtl::ReadInitData (CPartFrame *pFrame)
{
	int i,j, nItems, nItemsBox;
	CNode *pNode;
	ASSERT (pFrame->IsKindOf ( RUNTIME_CLASS ( CPartFrame )));
	TreeData  *pdata = (TreeData  *) pFrame->GetCurData ();

	if (pdata == NULL) return;

	RefreshAllRoots();

	if (pdata->nExpandedNodes[0] != -1)
	{
		nItems = (pdata->wSize + sizeof (WORD) - sizeof ( TreeData ))
					 / sizeof (int) + 1;
		nItemsBox = m_listBox.GetCount();
		Expand (0);
		i=0; j=0;
		while ( i < nItems && j < nItemsBox)
		{
			while (j < pdata->nExpandedNodes[i] )
			{
				if ((pNode = (CNode *) m_listBox.GetItemDataPtr(j))
									== (CNode *) -1 )
				{
					TRACE ("Tree control state read failed.\n");
					return;
				}
				if (pNode->m_nFlags & TF_EXPANDED)
				{
					Collapse (j);
					nItemsBox = m_listBox.GetCount();
				}
				j++;
			}
			if ((pNode = (CNode *) m_listBox.GetItemDataPtr(j))
									== (CNode *) -1 )
			{
				TRACE ("Tree control state read failed.\n");
				return;
			}
			if ( !(pNode->m_nFlags & TF_EXPANDED) ) 
			{
				Expand (j);
				nItemsBox = m_listBox.GetCount();
			}
			j++;
			i++;	
		}
		// Collaps any remaining nodes: 
		while (j < nItemsBox) 
		{
			VERIFY ((pNode =  (CNode *) m_listBox.GetItemDataPtr(j))
									!= (CNode *) -1 );
			if (pNode->m_nFlags & TF_EXPANDED)
			{
				Collapse (j);
				nItemsBox = m_listBox.GetCount();
			}
			j++;
		}

	}
	else Collapse (0);

	if (m_bIsMultiSelection)
	{
		for (i = pdata->nCurSel; i < pdata->nLastSel; i++)
			m_listBox.SetSel (i, TRUE);
	}
	else m_listBox.SetCurSel (pdata->nCurSel);

	m_listBox.SetTopIndex (pdata->nTopIndex);	
}

void CTreeCtl::SizeViewToTree ( CPartFrame *pFrame )
{
	CRect rcView, rcListBox, rcParent;
	int dl, curWidth, cxm, cxe;
	BOOL bIsMax;

	RefreshAllRoots();

	// If the MDI child is maximized, then don't do anything:
	pFrame->GetMDIFrame()->MDIGetActive ( &bIsMax );
	if (bIsMax) return;

	m_listBox.GetWindowRect (rcListBox);	 
	pFrame->GetWindowRect   (rcView);
	curWidth = rcView.Width (); 
	cxe = m_cxExtent + GetSystemMetrics (SM_CXHSCROLL) * 2;
	cxm = m_sizeM.cx << 5;
	dl = curWidth - rcListBox.Width () + max (cxe, cxm);
	// If we're make the window bigger, don't make it too big:
	if (dl > rcView.Width () )
	{
		pFrame->GetParent()->GetWindowRect   (rcParent);
		cxe = rcParent.Width() * 2 / 3;
		cxm = max (curWidth, cxe); 
		dl = min (dl, cxm);
	}
	pFrame->SetWindowPos (
						NULL, 
						0,
						0,
						dl,
						rcView.Height (),
						SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE	
						);

	if (m_bIsMultiSelection) m_listBox.SetSel (0, TRUE);
	else m_listBox.SetCurSel (0);
	m_listBox.SetTopIndex (0);	
}
#endif //[byrond] ...end of the unused code

void  CTreeCtl::HoldUpdates ()
{
	if (m_EnableUpdates == 0) m_listBox.SetRedraw (FALSE);
	m_EnableUpdates++;
}
void  CTreeCtl::EnableUpdates ()
{
	m_EnableUpdates--;
	if (m_EnableUpdates == 0)
	{
		m_listBox.SetRedraw (TRUE);
		m_listBox.Invalidate();
	}

	ASSERT (m_EnableUpdates >= 0);
}

void CTreeCtl::GetNodeTitle(CNode* pNode, CString& strTitle)
{
	strTitle = pNode->m_szText;
}

CNode* CTreeCtl::CreateNode(DWORD dwData)
{
	return new CNode(dwData);
}

void CTreeCtl::DeleteNode(CNode* pNode)
{
	delete pNode;
}

void CTreeCtl::BeginDragDrop()
{
	TRACE("Must override CTreeCtl::BeginDragDrop for drag/drop functionality!\n");
}

CNode::CNode(DWORD dwData)
{
	m_szText = NULL;
	m_dwData = dwData;
}

CNode::~CNode()
{
	delete [] m_szText;
}

CFont* CNode::GetFont() const
{
	return GetStdFont(font_Normal);
}

int CNode::GetGlyphWidth()
{
	return cxFolder;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\ttmsgs.cpp ===
//-----------------------------------------------------------------------------
//  TTMsgs.cpp
//
//  Tooltips (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES

static VALUETABLE tblTTDelayTime[] =
{
	TABLEENTRY(TTDT_AUTOMATIC),
//	TABLEENTRY(TTDT_AUTOPOPUP),
	TABLEENTRY(TTDT_INITIAL),
	TABLEENTRY(TTDT_RESHOW),
	TABLEEND
};


//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_ACTIVATE)
{
	PARM(Activate, BOOL, WP);
	POUTB(Activate);

	return TRUE;
}

NODECODERET(TTM_ACTIVATE);

NODECODEPARM(TTM_ACTIVATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_SETDELAYTIME)
{
	PARM(uFlag, UINT, WP);
	PARM(iDelay, INT, LP);

	TABLEORVALUE(tblTTDelayTime, uFlag);
	POUT(iDelay);

	return TRUE;
}

NODECODERET(TTM_SETDELAYTIME);

NODECODEPARM(TTM_SETDELAYTIME);

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_ADDTOOL)
{
	PARM(lpti, LPTOOLINFO, LP);
	POUTC(lpti, DWORD);

	return TRUE;
}

DECODERET(TTM_ADDTOOL)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TTM_ADDTOOL)
{
	P2WPOUT();

	P2LPOUTPTR(TOOLINFO);
	P2IFSIZEOF(TOOLINFO)
	{
		PARM(lpti, LPTOOLINFO, ED2);
//		PARM(pszName, LPSTR, lpti->lpszText);
		INDENT();
		P2OUTC(lpti, cbSize, UINT);
		P2OUTC(lpti, uFlags, UINT);
		P2OUTC(lpti, hwnd, HWND);
		P2OUTC(lpti, uId, UINT);
		P2OUTRECT(lpti, rect);
		P2OUTC(lpti, hinst, DWORD);
		P2OUTPTRSTR(lpti, lpszText);
//		INDENT();
//		P2OUTS(pszName);
//		OUTDENT();
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_DELTOOL)
{
	DECODELIKE(TTM_ADDTOOL);
}

NODECODERET(TTM_DELTOOL);

DECODEPARM(TTM_DELTOOL)
{
	DECODEPARMLIKE(TTM_ADDTOOL);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_NEWTOOLRECT)
{
	DECODELIKE(TTM_ADDTOOL);
}

NODECODERET(TTM_NEWTOOLRECT);

DECODEPARM(TTM_NEWTOOLRECT)
{
	DECODEPARMLIKE(TTM_ADDTOOL);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_RELAYEVENT)
{
	PARM(lpmsg, LPMSG, LP);
	POUTC(lpmsg, DWORD);

	return TRUE;
}

NODECODERET(TTM_RELAYEVENT);

DECODEPARM(TTM_RELAYEVENT)
{
	P2WPOUT();

	P2LPOUTPTR(MSG);
	P2IFSIZEOF(MSG)
	{
		PARM(lpmsg, LPMSG, ED2);
		INDENT();
		P2OUTC(lpmsg, hwnd, HWND);
		P2OUTC(lpmsg, message, UINT);
		P2OUTC(lpmsg, wParam, WPARAM);
		P2OUTC(lpmsg, lParam, LPARAM);
		P2OUTC(lpmsg, time, DWORD);
		P2OUTPT(lpmsg, pt);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_GETTOOLINFO)
{
	DECODELIKE(TTM_ADDTOOL);
}

DECODERET(TTM_GETTOOLINFO)
{
	DECODERETLIKE(TTM_ADDTOOL);
}

DECODEPARM(TTM_GETTOOLINFO)
{
	DECODEPARMLIKE(TTM_ADDTOOL);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_SETTOOLINFO)
{
	DECODELIKE(TTM_ADDTOOL);
}

NODECODERET(TTM_SETTOOLINFO);

DECODEPARM(TTM_SETTOOLINFO)
{
	DECODEPARMLIKE(TTM_ADDTOOL);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_HITTEST)
{
	PARM(lphti, TTHITTESTINFO FAR *, LP);
	POUTC(lphti, DWORD);

	return TRUE;
}

DECODERET(TTM_HITTEST)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TTM_HITTEST)
{
	P2WPOUT();

	P2LPOUTPTR(TTHITTESTINFO);
	P2IFSIZEOF(TTHITTESTINFO)
	{
		PARM(lphti, TTHITTESTINFO FAR *, ED2);
		INDENT();
		P2OUTC(lphti, hwnd, HWND);
		P2OUTPT(lphti, pt);
		P2OUTPTR(&lphti, ti, TOOLINFO);
		{
			PARM(lpti, LPTOOLINFO, &lphti->ti);
//			PARM(pszName, LPSTR, lpti->lpszText);
			INDENT();
			P2OUTC(lpti, cbSize, UINT);
			P2OUTC(lpti, uFlags, UINT);
			P2OUTC(lpti, hwnd, HWND);
			P2OUTC(lpti, uId, UINT);
			P2OUTRECT(lpti, rect);
			P2OUTC(lpti, hinst, DWORD);
			P2OUTPTRSTR(lpti, lpszText);
//			INDENT();
//			P2OUTS(pszName);
//			OUTDENT();
		}
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_GETTEXT)
{
	DECODELIKE(TTM_ADDTOOL);
}

DECODERET(TTM_GETTEXT)
{
	DECODERETLIKE(TTM_ADDTOOL);
}

DECODEPARM(TTM_GETTEXT)
{
	DECODEPARMLIKE(TTM_ADDTOOL);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_UPDATETIPTEXT)
{
	DECODELIKE(TTM_ADDTOOL);
}

NODECODERET(TTM_UPDATETIPTEXT);

DECODEPARM(TTM_UPDATETIPTEXT)
{
	DECODEPARMLIKE(TTM_ADDTOOL);
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(TTM_GETTOOLCOUNT);

DECODERET(TTM_GETTOOLCOUNT)
{
	PARM(nCount, INT, RET);
	POUT(nCount);

	return TRUE;
}

NODECODEPARM(TTM_GETTOOLCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_ENUMTOOLS)
{
	PARM(iTool, UINT, WP);
	PARM(lpti, LPTOOLINFO, LP);

	POUTC(iTool, UINT);
	POUTC(lpti, DWORD);

	return TRUE;
}

DECODERET(TTM_ENUMTOOLS)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TTM_ENUMTOOLS)
{
	DECODEPARMLIKE(TTM_ADDTOOL);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TTM_GETCURRENTTOOL)
{
	DECODELIKE(TTM_ADDTOOL);
}

DECODERET(TTM_GETCURRENTTOOL)
{
	DECODERETLIKE(TTM_ADDTOOL);
}

DECODEPARM(TTM_GETCURRENTTOOL)
{
	DECODEPARMLIKE(TTM_ADDTOOL);
}

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\trkmsgs.cpp ===
//-----------------------------------------------------------------------------
//  TrkMsgs.cpp
//
//  Trackbar (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES
//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETPOS);

DECODERET(TBM_GETPOS)
{
	PARM(lPosition, INT, RET);
	POUT(lPosition);

	return TRUE;
}

NODECODEPARM(TBM_GETPOS);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETRANGEMIN);

DECODERET(TBM_GETRANGEMIN)
{
	PARM(lMinimum, INT, RET);
	POUT(lMinimum);

	return TRUE;
}

NODECODEPARM(TBM_GETRANGEMIN);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETRANGEMAX);

DECODERET(TBM_GETRANGEMAX)
{
	PARM(lMaximum, INT, RET);
	POUT(lMaximum);

	return TRUE;
}

NODECODEPARM(TBM_GETRANGEMAX);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_GETTIC)
{
	PARM(iTic, INT, WP);
	POUT(iTic);

	return TRUE;
}

DECODERET(TBM_GETTIC)
{
	PARM(lPosition, INT, RET);
	POUT(lPosition);

	return TRUE;
}

NODECODEPARM(TBM_GETTIC);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETTIC)
{
	PARM(lPosition, INT, LP);
	POUT(lPosition);

	return TRUE;
}

DECODERET(TBM_SETTIC)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TBM_SETTIC);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETPOS)
{
	PARM(fPosition, BOOL, WP);
	PARM(lPosition, INT, LP);

	POUTB(fPosition);
	POUT(lPosition);

	return TRUE;
}

NODECODERET(TBM_SETPOS);

NODECODEPARM(TBM_SETPOS);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETRANGE)
{
	PARM(fRedraw, BOOL, WP);
	PARM(lMinimum, INT, LOLP);
	PARM(lMaximum, INT, HILP);

	POUTB(fRedraw);
	POUT(lMinimum);
	POUT(lMaximum);

	return TRUE;
}

NODECODERET(TBM_SETRANGE);

NODECODEPARM(TBM_SETRANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETRANGEMIN)
{
	PARM(fRedraw, BOOL, WP);
	PARM(lMinimum, INT, LP);

	POUTB(fRedraw);
	POUT(lMinimum);

	return TRUE;
}

NODECODERET(TBM_SETRANGEMIN);

NODECODEPARM(TBM_SETRANGEMIN);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETRANGEMAX)
{
	PARM(fRedraw, BOOL, WP);
	PARM(lMaximum, INT, LP);

	POUTB(fRedraw);
	POUT(lMaximum);

	return TRUE;
}

NODECODERET(TBM_SETRANGEMAX);

NODECODEPARM(TBM_SETRANGEMAX);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_CLEARTICS)
{
	PARM(fRedraw, BOOL, WP);
	TABLEORINT(tblTrueFalse, fRedraw);

	return TRUE;
}

NODECODERET(TBM_CLEARTICS);

NODECODEPARM(TBM_CLEARTICS);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETSEL)
{
	PARM(fRedraw, BOOL, WP);
	PARM(lMinimum, INT, LOLP);
	PARM(lMaximum, INT, HILP);

	POUTB(fRedraw);
	POUT(lMinimum);
	POUT(lMaximum);

	return TRUE;
}

NODECODERET(TBM_SETSEL);

NODECODEPARM(TBM_SETSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETSELSTART)
{
	PARM(fRedraw, BOOL, WP);
	PARM(lStart, INT, LP);

	POUTB(fRedraw);
	POUT(lStart);

	return TRUE;
}

NODECODERET(TBM_SETSELSTART);

NODECODEPARM(TBM_SETSELSTART);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETSELEND)
{
	PARM(fRedraw, BOOL, WP);
	PARM(lEnd, INT, LP);

	POUTB(fRedraw);
	POUT(lEnd);

	return TRUE;
}

NODECODERET(TBM_SETSELEND);

NODECODEPARM(TBM_SETSELEND);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETPTICS);

DECODERET(TBM_GETPTICS)
{
	PARM(apTicks, DWORD, RET);
	POUTC(apTicks, DWORD);

	return TRUE;
}

NODECODEPARM(TBM_GETPTICS);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_GETTICPOS)
{
	DECODELIKE(TBM_GETTIC);
}

DECODERET(TBM_GETTICPOS)
{
	DECODERETLIKE(TBM_GETTIC);
}

NODECODEPARM(TBM_GETTICPOS);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETNUMTICS);

DECODERET(TBM_GETNUMTICS)
{
	PARM(nTickMarks, INT, RET);
	POUT(nTickMarks);

	return TRUE;
}

NODECODEPARM(TBM_GETNUMTICS);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETSELSTART);

DECODERET(TBM_GETSELSTART)
{
	PARM(lStart, INT, RET);
	POUT(lStart);

	return TRUE;
}

NODECODEPARM(TBM_GETSELSTART);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETSELEND);

DECODERET(TBM_GETSELEND)
{
	PARM(lEnd, INT, RET);
	POUT(lEnd);

	return TRUE;
}

NODECODEPARM(TBM_GETSELEND);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_CLEARSEL)
{
	PARM(fRedraw, BOOL, WP);
	TABLEORINT(tblTrueFalse, fRedraw);

	return TRUE;
}

NODECODERET(TBM_CLEARSEL);

NODECODEPARM(TBM_CLEARSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETTICFREQ)
{
	PARM(wFreq, INT, WP);
	PARM(lPosition, INT, LP);

	POUT(wFreq);
	POUT(lPosition);

	return TRUE;
}

NODECODERET(TBM_SETTICFREQ);

NODECODEPARM(TBM_SETTICFREQ);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETPAGESIZE)
{
	PARM(lPageSize, INT, LP);
	POUT(lPageSize);

	return TRUE;
}

DECODERET(TBM_SETPAGESIZE)
{
	PARM(lPrevPageSize, INT, RET);
	POUT(lPrevPageSize);

	return TRUE;
}

NODECODEPARM(TBM_SETPAGESIZE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETPAGESIZE);

DECODERET(TBM_GETPAGESIZE)
{
	PARM(lPageSize, INT, RET);
	POUT(lPageSize);

	return TRUE;
}

NODECODEPARM(TBM_GETPAGESIZE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETLINESIZE)
{
	PARM(lLineSize, INT, LP);
	POUT(lLineSize);

	return TRUE;
}

DECODERET(TBM_SETLINESIZE)
{
	PARM(lPrevLineSize, INT, RET);
	POUT(lPrevLineSize);

	return TRUE;
}

NODECODEPARM(TBM_SETLINESIZE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETLINESIZE);

DECODERET(TBM_GETLINESIZE)
{
	PARM(lLineSize, INT, RET);
	POUT(lLineSize);

	return TRUE;
}

NODECODEPARM(TBM_GETLINESIZE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_GETTHUMBRECT)
{
	DECODELIKE(TBM_GETCHANNELRECT);
}

NODECODERET(TBM_GETTHUMBRECT);

DECODEPARM(TBM_GETTHUMBRECT)
{
	DECODEPARMLIKE(TBM_GETCHANNELRECT);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_GETCHANNELRECT)
{
	PARM(lprc, LPRECT, LP);
	POUTC(lprc, DWORD);

	return TRUE;
}

NODECODERET(TBM_GETCHANNELRECT);

DECODEPARM(TBM_GETCHANNELRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(lprc, LPRECT, ED2);
		INDENT();
		P2OUT(lprc, left);
		P2OUT(lprc, top);
		P2OUT(lprc, right);
		P2OUT(lprc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TBM_SETTHUMBLENGTH)
{
	PARM(iLength, INT, WP);
	POUT(iLength);

	return TRUE;
}

NODECODERET(TBM_SETTHUMBLENGTH);

NODECODEPARM(TBM_SETTHUMBLENGTH);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TBM_GETTHUMBLENGTH);

DECODERET(TBM_GETTHUMBLENGTH)
{
	PARM(iLength, INT, RET);
	POUT(iLength);

	return TRUE;
}

NODECODEPARM(TBM_GETTHUMBLENGTH);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\tlhelp32.h ===
/*****************************************************************************\
*                                                                             *
* tlhelp32.h -	WIN32 tool help functions, types, and definitions	      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h/winbase.h must be #included first			      *
*                                                                             *
* Copyright (c) 1994-1995, Microsoft Corp.   All rights reserved. 	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP32
#define _INC_TOOLHELP32

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MAX_MODULE_NAME32 255

/****** Shapshot function **********************************************/

HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//	lists which are process specific. To enumerate the heap or module
//	state for all WIN32 processes call with TH32CS_SNAPALL and the
//	current process. Then for each process in the TH32CS_SNAPPROCESS
//	list that isn't the current process, do a call with just
//	TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//
#define TH32CS_SNAPHEAPLIST 0x00000001
#define TH32CS_SNAPPROCESS  0x00000002
#define TH32CS_SNAPTHREAD   0x00000004
#define TH32CS_SNAPMODULE   0x00000008
#define TH32CS_SNAPALL	    (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)
#define TH32CS_INHERIT	    0x80000000
//
// Use CloseHandle to destroy the snapshot
//

/****** heap walking ***************************************************/

typedef struct tagHEAPLIST32
{
    DWORD  dwSize;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap (in owning process's context!)
    DWORD  dwFlags;
} HEAPLIST32;
typedef HEAPLIST32 *  PHEAPLIST32;
typedef HEAPLIST32 *  LPHEAPLIST32;
//
// dwFlags
//
#define HF32_DEFAULT	  1  // process's default heap
#define HF32_SHARED	  2  // is shared heap

BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL WINAPI Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl);

typedef struct tagHEAPENTRY32
{
    DWORD  dwSize;
    HANDLE hHandle;	// Handle of this heap block
    DWORD  dwAddress;	// Linear address of start of block
    DWORD  dwBlockSize; // Size of block in bytes
    DWORD  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap block is in
} HEAPENTRY32;
typedef HEAPENTRY32 *  PHEAPENTRY32;
typedef HEAPENTRY32 *  LPHEAPENTRY32;
//
// dwFlags
//
#define LF32_FIXED    0x00000001
#define LF32_FREE     0x00000002
#define LF32_MOVEABLE 0x00000004

BOOL WINAPI Heap32First(LPHEAPENTRY32 lphe, DWORD th32ProcessID,
			DWORD th32HeapID);
BOOL WINAPI Heap32Next(LPHEAPENTRY32 lphe);
BOOL WINAPI Toolhelp32ReadProcessMemory(DWORD	th32ProcessID,
					LPCVOID lpBaseAddress,
					LPVOID	lpBuffer,
					DWORD	cbRead,
					LPDWORD lpNumberOfBytesRead);

/***** Process walking *************************************************/

typedef struct tagPROCESSENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;	    // this process
    DWORD   th32DefaultHeapID;
    DWORD   th32ModuleID;	    // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;	    // Base priority of process's threads
    DWORD   dwFlags;
	char    szExeFile[_MAX_PATH];
} PROCESSENTRY32;
typedef PROCESSENTRY32 *  PPROCESSENTRY32;
typedef PROCESSENTRY32 *  LPPROCESSENTRY32;

BOOL WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
BOOL WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

/***** Thread walking **************************************************/

typedef struct tagTHREADENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;	// this thread
    DWORD   th32OwnerProcessID; // Process this thread is associated with
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
} THREADENTRY32;
typedef THREADENTRY32 *  PTHREADENTRY32;
typedef THREADENTRY32 *  LPTHREADENTRY32;

BOOL WINAPI Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL WINAPI Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);

/***** Module walking *************************************************/

typedef struct tagMODULEENTRY32
{
    DWORD   dwSize;
    DWORD   th32ModuleID;	// This module
    DWORD   th32ProcessID;	// owning process
    DWORD   GlblcntUsage;	// Global usage count on the module
    DWORD   ProccntUsage;	// Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;	// Base address of module in th32ProcessID's context
    DWORD   modBaseSize;	// Size in bytes of module starting at modBaseAddr
    HMODULE hModule;		// The hModule of this module in th32ProcessID's context
    char    szModule[MAX_MODULE_NAME32 + 1];
    char    szExePath[MAX_PATH];
} MODULEENTRY32;
typedef MODULEENTRY32 *  PMODULEENTRY32;
typedef MODULEENTRY32 *  LPMODULEENTRY32;

//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

BOOL WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
BOOL WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

#ifdef __cplusplus
}
#endif

#endif // _INC_TOOLHELP32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\winmain.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
// Standard WinMain implementation
//  Can be replaced as long as 'AfxWinInit' is called first

#ifndef _USRDLL
#ifdef _MAC
extern "C" int PASCAL
#else
extern "C" int WINAPI
#endif
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow)
{
	ASSERT(hPrevInstance == NULL);

	int nReturnCode = -1;
	CWinApp* pApp = AfxGetApp();

	// AFX internal initialization
	if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))
		goto InitFailure;

	// App global initializations (rare)
	ASSERT_VALID(pApp);
	if (!pApp->InitApplication())
		goto InitFailure;
	ASSERT_VALID(pApp);

	// Perform specific initializations
	if (!pApp->InitInstance())
	{
		if (pApp->m_pMainWnd != NULL)
		{
			TRACE0("Warning: Destroying non-NULL m_pMainWnd\n");
			pApp->m_pMainWnd->DestroyWindow();
		}
		nReturnCode = pApp->ExitInstance();
		goto InitFailure;
	}
	ASSERT_VALID(pApp);

	nReturnCode = pApp->Run();
	ASSERT_VALID(pApp);

InitFailure:
	AfxWinTerm();
	return nReturnCode;
}

#else
// _USRDLL library initialization

extern "C" BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
	CWinApp* pApp = AfxGetApp();
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// initialize MFC exception handling
#ifndef _AFX_OLD_EXCEPTIONS
		set_terminate(&AfxStandardTerminate);
#endif
		_set_new_handler(&AfxNewHandler);

		// initialize DLL's instance(/module) not the app's
		if (!AfxWinInit(hInstance, NULL, &afxChNil, 0))
		{
			AfxWinTerm();
			return FALSE;   // Init Failed
		}

		// initialize the single instance DLL
		if (pApp != NULL && !pApp->InitInstance())
		{
			pApp->ExitInstance();
			AfxWinTerm();
			return FALSE;   // Init Failed
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		if (pApp != NULL)
			pApp->ExitInstance();

#ifdef _DEBUG
		// check for missing AfxLockTempMap calls
		if (AfxGetThreadState()->m_nTempMapLock != 0)
			TRACE1("Warning: Temp map lock count non-zero (%ld).\n",
				AfxGetThreadState()->m_nTempMapLock);
#endif
		// terminate the library before destructors are called
		AfxWinTerm();

		// free safety pool buffer
		AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
		if (pThreadState->m_pSafetyPoolBuffer != NULL)
		{
			free(pThreadState->m_pSafetyPoolBuffer);
			pThreadState->m_pSafetyPoolBuffer = NULL;
		}
		// clean up map objects before it is too late
		pThreadState->m_mapHWND.CHandleMap::~CHandleMap();
		pThreadState->m_mapHMENU.CHandleMap::~CHandleMap();
		pThreadState->m_mapHDC.CHandleMap::~CHandleMap();
		pThreadState->m_mapHGDIOBJ.CHandleMap::~CHandleMap();

#ifdef _DEBUG
		// trace any memory leaks that may have occurred
		AfxDumpMemoryLeaks();
#endif
	}
	return TRUE;    // ok
}

// Note: need to initialize _pRawDllMain to RawDllMain so it gets called
extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &RawDllMain;
#endif //!_USRDLL

/////////////////////////////////////////////////////////////////////////////
// Common DLL initialization

#ifdef _WINDLL
extern BOOL _afxSharedData; // set to TRUE if running Win32s
extern DWORD _afxAppTlsIndex;

extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// make sure we have enough memory to attempt to start (8kb)
		void* pMinHeap = LocalAlloc(NONZEROLPTR, 0x2000);
		if (pMinHeap == NULL)
			return FALSE;   // fail if memory alloc fails
		LocalFree(pMinHeap);

		// cache Win32s version info
		if (_afxSharedData == (BOOL)-1)
		{
			DWORD dwVersion = ::GetVersion();
			_afxSharedData = (dwVersion & 0x80000000) && (BYTE)dwVersion <= 3;
		}

		// allocate initial thread local storage index
		if (_afxThreadTlsIndex == NULL_TLS)
		{
			_afxThreadTlsIndex = TlsAlloc();
			if (_afxThreadTlsIndex == NULL_TLS)
				return FALSE;   // failure
		}

		// initialize thread state for before constructors run
		AFX_THREAD_STATE* pThreadState = new AFX_THREAD_STATE;
		if (pThreadState == NULL)
			return FALSE;

		// initialize process state before constructors run
		AFX_APP_STATE* pAppState;
		if (_afxSharedData)
		{
			// Win32s: allocate thread local storage index if necessary
			if (_afxAppTlsIndex == NULL_TLS)
			{
				_afxAppTlsIndex = TlsAlloc();
				if (_afxAppTlsIndex == NULL_TLS)
					return FALSE;   // failure
			}

			// allocate AFX_APP_STATE structure for this process
			ASSERT(TlsGetValue(_afxAppTlsIndex) == NULL);
			pAppState = new AFX_APP_STATE;
			ASSERT(TlsGetValue(_afxAppTlsIndex) == pAppState);
			if (pAppState == NULL)
				return FALSE;   // failure
		}
		else
		{
			// Win32: use global buffer for app state instead
			pAppState = new AFX_APP_STATE;
			ASSERT(pAppState != NULL);
		}

		// make sure everything worked
		ASSERT(AfxGetAppState() == pAppState);
		ASSERT(AfxGetThreadState() == pThreadState);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// free the thread state (for primary thread)
		AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
		delete pThreadState;

		// free the process state
		AFX_APP_STATE* pAppState = AfxGetAppState();
		delete pAppState;
	}
	return TRUE;    // ok
}
#endif //_WINDLL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\updnmsgs.cpp ===
//-----------------------------------------------------------------------------
//  UpDnMsgs.cpp
//
//  Up-Down (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES
//////////////////////////////////////////////////////////////////////////////

DECODE(UDM_SETRANGE)
{
	PARM(nUpper, INT, LOLP);
	PARM(nLower, INT, HILP);

	POUT(nUpper);
	POUT(nLower);

	return TRUE;
}

NODECODERET(UDM_SETRANGE);

NODECODEPARM(UDM_SETRANGE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(UDM_GETRANGE);

DECODERET(UDM_GETRANGE)
{
	PARM(nUpper, INT, LORET);
	PARM(nLower, INT, HIRET);

	POUT(nUpper);
	POUT(nLower);

	return TRUE;
}

NODECODEPARM(UDM_GETRANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(UDM_SETPOS)
{
	PARM(nPos, INT, LOLP);
	POUT(nPos);

	return TRUE;
}

DECODERET(UDM_SETPOS)
{
	PARM(nPrevPos, INT, RET);
	POUT(nPrevPos);

	return TRUE;
}

NODECODEPARM(UDM_SETPOS);

//////////////////////////////////////////////////////////////////////////////

NODECODE(UDM_GETPOS);

DECODERET(UDM_GETPOS)
{
	PARM(nPos, INT, LORET);
	PARM(fError, BOOL, HIRET);

	POUT(nPos);
	POUTB(fError);

	return TRUE;
}

NODECODEPARM(UDM_GETPOS);

//////////////////////////////////////////////////////////////////////////////

DECODE(UDM_SETBUDDY)
{
	PARM(hwndBuddy, HWND, WP);
	POUTC(hwndBuddy, DWORD);

	return TRUE;
}

DECODERET(UDM_SETBUDDY)
{
	PARM(hwndPrevBuddy, HWND, RET);
	POUTC(hwndPrevBuddy, DWORD);

	return TRUE;
}

NODECODEPARM(UDM_SETBUDDY);

//////////////////////////////////////////////////////////////////////////////

NODECODE(UDM_GETBUDDY);

DECODERET(UDM_GETBUDDY)
{
	PARM(hwndBuddy, HWND, RET);
	POUTC(hwndBuddy, DWORD);

	return TRUE;
}

NODECODEPARM(UDM_GETBUDDY);

//////////////////////////////////////////////////////////////////////////////

DECODE(UDM_SETACCEL)
{
	PARM(cAccels, INT, WP);
	PARM(aAccels, LPUDACCEL, LP);

	POUT(cAccels);
	POUTC(aAccels, DWORD);

	return TRUE;
}

DECODERET(UDM_SETACCEL)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(UDM_SETACCEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(UDM_GETACCEL)
{
	PARM(cAccels, INT, WP);
	PARM(paAccels, LPUDACCEL, LP);

	POUT(cAccels);
	POUTC(paAccels, DWORD);

	return TRUE;
}

DECODERET(UDM_GETACCEL)
{
	PARM(cAccels, INT, RET);
	POUT(cAccels);

	return TRUE;
}

NODECODEPARM(UDM_GETACCEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(UDM_SETBASE)
{
	PARM(nBase, INT, WP);
	POUT(nBase);

	return TRUE;
}

DECODERET(UDM_SETBASE)
{
	PARM(nPrevBase, INT, RET);
	POUT(nPrevBase);

	return TRUE;
}

NODECODEPARM(UDM_SETBASE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(UDM_GETBASE);

DECODERET(UDM_GETBASE)
{
	PARM(nBase, INT, RET);
	POUT(nBase);

	return TRUE;
}

NODECODEPARM(UDM_GETBASE);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\tvmsgs.cpp ===
//-----------------------------------------------------------------------------
//  TVMsgs.cpp
//
//  TreeView (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static VALUETABLE tblTVRetOK[] =
{
	TABLEENTRY(LB_OKAY),
	TABLEENTRY(LB_ERR),
	TABLEENTRY(LB_ERRSPACE),
	TABLEEND
};

#ifndef DISABLE_WIN95_MESSAGES

static VALUETABLE tblTVExpand[] =
{
	TABLEENTRY(TVE_COLLAPSE),
	TABLEENTRY(TVE_COLLAPSERESET),
	TABLEENTRY(TVE_EXPAND),
	TABLEENTRY(TVE_TOGGLE),
	TABLEEND
};

static VALUETABLE tblTVGetImage[] =
{
	TABLEENTRY(TVSIL_NORMAL),
	TABLEENTRY(TVSIL_STATE),
	TABLEEND
};

static VALUETABLE tblTVGetNext[] =
{
	TABLEENTRY(TVGN_CARET),
	TABLEENTRY(TVGN_CHILD),
	TABLEENTRY(TVGN_DROPHILITE),
	TABLEENTRY(TVGN_FIRSTVISIBLE),
	TABLEENTRY(TVGN_NEXT),
	TABLEENTRY(TVGN_NEXTVISIBLE),
	TABLEENTRY(TVGN_PARENT),
	TABLEENTRY(TVGN_PREVIOUS),
	TABLEENTRY(TVGN_PREVIOUSVISIBLE),
	TABLEENTRY(TVGN_ROOT),
	TABLEEND
};


//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_INSERTITEM)
{
	PARM(lpis, TV_INSERTSTRUCT FAR *, LP);
	POUTC(lpis, DWORD);

	return TRUE;
}

DECODERET(TVM_INSERTITEM)
{
	PARM(hItem, HANDLE, RET);
	POUTC(hItem, DWORD);

	return TRUE;
}

DECODEPARM(TVM_INSERTITEM)
{
	P2WPOUT();

	P2LPOUTPTR(TV_INSERTSTRUCT);
	P2IFSIZEOF(TV_INSERTSTRUCT)
	{
		PARM(lpis, TV_INSERTSTRUCT FAR *, ED2);
		INDENT();
		P2OUTC(lpis, hParent, DWORD);
		P2OUTC(lpis, hInsertAfter, DWORD);
		P2OUTPTR(&lpis, item, TV_ITEM);
		{
			PARM(item, TV_ITEM FAR *, &lpis->item);
//			PARM(pszName, LPSTR, item->pszText);
			INDENT();
			P2OUTC(item, mask, UINT);
			P2OUTC(item, hItem, DWORD);
			P2OUTC(item, state, UINT);
			P2OUTC(item, stateMask, UINT);
			P2OUTPTRSTR(item, pszText);
//			INDENT();
//			P2OUTS(pszName);
//			OUTDENT();
			P2OUT(item, cchTextMax);
			P2OUT(item, iImage);
			P2OUT(item, iSelectedImage);
			P2OUT(item, cChildren);
			P2OUTC(item, lParam, DWORD);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_DELETEITEM)
{
	PARM(hitem, HTREEITEM, LP);
	POUTC(hitem, DWORD);

	return TRUE;
}

DECODERET(TVM_DELETEITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TVM_DELETEITEM);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_EXPAND)
{
	PARM(flag, UINT, WP);
	PARM(hitem, HTREEITEM, LP);

	TABLEORVALUE(tblTVExpand, flag);
	POUTC(hitem, DWORD);

	return TRUE;
}

DECODERET(TVM_EXPAND)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TVM_EXPAND);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_GETITEMRECT)
{
	PARM(fItemRect, BOOL, WP);
	PARM(prc, LPRECT, LP);

	POUTB(fItemRect);
	POUTC(prc, DWORD);

	return TRUE;
}

DECODERET(TVM_GETITEMRECT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TVM_GETITEMRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(TVM_GETCOUNT);

DECODERET(TVM_GETCOUNT)
{
	PARM(nCount, INT, RET);
	POUT(nCount);

	return TRUE;
}

NODECODEPARM(TVM_GETCOUNT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TVM_GETINDENT);

DECODERET(TVM_GETINDENT)
{
	PARM(indent, INT, RET);
	POUT(indent);

	return TRUE;
}

NODECODEPARM(TVM_GETINDENT);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_SETINDENT)
{
	PARM(indent, INT, WP);
	POUT(indent);

	return TRUE;
}

NODECODERET(TVM_SETINDENT);

NODECODEPARM(TVM_SETINDENT);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_GETIMAGELIST)
{
	PARM(iImage, UINT, WP);
	TABLEORVALUE(tblTVGetImage, iImage);

	return TRUE;
}

DECODERET(TVM_GETIMAGELIST)
{
	PARM(hImageList, HANDLE, RET);
	POUTC(hImageList, DWORD);

	return TRUE;
}

NODECODEPARM(TVM_GETIMAGELIST);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_SETIMAGELIST)
{
	PARM(iImage, UINT, WP);
	PARM(himl, HIMAGELIST, LP);

	TABLEORVALUE(tblTVGetImage, iImage);
	POUTC(himl, DWORD);

	return TRUE;
}

DECODERET(TVM_SETIMAGELIST)
{
	PARM(hPrevImageList, HANDLE, RET);
	POUTC(hPrevImageList, DWORD);

	return TRUE;
}

NODECODEPARM(TVM_SETIMAGELIST);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_GETNEXTITEM)
{
	PARM(flag, UINT, WP);
	PARM(hitem, HTREEITEM, LP);

	TABLEORVALUE(tblTVGetNext, flag);
	POUTC(hitem, DWORD);

	return TRUE;
}

DECODERET(TVM_GETNEXTITEM)
{
	PARM(hItem, HANDLE, RET);
	POUTC(hItem, DWORD);

	return TRUE;
}

NODECODEPARM(TVM_GETNEXTITEM);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_SELECTITEM)
{
	DECODELIKE(TVM_GETNEXTITEM);
}

DECODERET(TVM_SELECTITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TVM_SELECTITEM);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_GETITEM)
{
	PARM(pitem, TV_ITEM FAR *, LP);
	POUTC(pitem, DWORD);

	return TRUE;
}

DECODERET(TVM_GETITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TVM_GETITEM)
{
	P2WPOUT();

	P2LPOUTPTR(TV_ITEM);
	P2IFSIZEOF(TV_ITEM)
	{
		PARM(pitem, TV_ITEM FAR *, ED2);
//		PARM(pszName, LPSTR, pitem->pszText);
		INDENT();
		P2OUTC(pitem, mask, UINT);
		P2OUTC(pitem, hItem, DWORD);
		P2OUTC(pitem, state, UINT);
		P2OUTC(pitem, stateMask, UINT);
		P2OUTPTRSTR(pitem, pszText);
//		INDENT();
//		P2OUTS(pszName);
//		OUTDENT();
		P2OUT(pitem, cchTextMax);
		P2OUT(pitem, iImage);
		P2OUT(pitem, iSelectedImage);
		P2OUT(pitem, cChildren);
		P2OUTC(pitem, lParam, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_SETITEM)
{
	DECODELIKE(TVM_GETITEM);
}

DECODERET(TVM_SETITEM)
{
	PARM(nRet, INT, RET);
	POUT(nRet);

	return TRUE;
}

DECODEPARM(TVM_SETITEM)
{
	DECODEPARMLIKE(TVM_GETITEM);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_EDITLABEL)
{
	PARM(hitem, HTREEITEM, LP);
	POUTC(hitem, DWORD);

	return TRUE;
}

DECODERET(TVM_EDITLABEL)
{
	PARM(hwndEdit, HWND, RET);
	POUTC(hwndEdit, DWORD);

	return TRUE;
}

NODECODEPARM(TVM_EDITLABEL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TVM_GETEDITCONTROL);

DECODERET(TVM_GETEDITCONTROL)
{
	PARM(hwndEdit, HWND, RET);
	POUTC(hwndEdit, DWORD);

	return TRUE;
}

NODECODEPARM(TVM_GETEDITCONTROL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TVM_GETVISIBLECOUNT);

DECODERET(TVM_GETVISIBLECOUNT)
{
	PARM(nCount, INT, RET);
	POUT(nCount);

	return TRUE;
}

NODECODEPARM(TVM_GETVISIBLECOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_HITTEST)
{
	PARM(lpht, TV_HITTESTINFO FAR *, LP);
	POUTC(lpht, DWORD);

	return TRUE;
}

DECODERET(TVM_HITTEST)
{
	PARM(hItem, HANDLE, RET);
	POUTC(hItem, DWORD);

	return TRUE;
}

DECODEPARM(TVM_HITTEST)
{
	P2WPOUT();

	P2LPOUTPTR(TV_HITTESTINFO);
	P2IFSIZEOF(TV_HITTESTINFO)
	{
		PARM(lpht, TV_HITTESTINFO FAR *, ED2);
		INDENT();
		P2OUTPT(lpht, pt);
		P2OUTC(lpht, flags, UINT);
		P2OUTC(lpht, hItem, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_CREATEDRAGIMAGE)
{
	PARM(hitem, HTREEITEM, LP);
	POUTC(hitem, DWORD);

	return TRUE;
}

DECODERET(TVM_CREATEDRAGIMAGE)
{
	PARM(hImageList, HIMAGELIST, RET);
	POUTC(hImageList, DWORD);

	return TRUE;
}

NODECODEPARM(TVM_CREATEDRAGIMAGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_SORTCHILDREN)
{
	PARM(fReserved, UINT, WP);
	PARM(hitem, HTREEITEM, LP);

	POUTC(fReserved, UINT);
	POUTC(hitem, DWORD);

	return TRUE;
}

DECODERET(TVM_SORTCHILDREN)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TVM_SORTCHILDREN);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_ENSUREVISIBLE)
{
	PARM(hitem, HTREEITEM, LP);
	POUTC(hitem, DWORD);

	return TRUE;
}

DECODERET(TVM_ENSUREVISIBLE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TVM_ENSUREVISIBLE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_SORTCHILDRENCB)
{
	PARM(fReserved, UINT, WP);
	PARM(psort, TV_SORTCB FAR *, LP);

	POUTC(fReserved, UINT);
	POUTC(psort, DWORD);

	return TRUE;
}

DECODERET(TVM_SORTCHILDRENCB)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TVM_SORTCHILDRENCB);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_ENDEDITLABELNOW)
{
	PARM(fCancel, BOOL, WP);
	POUTB(fCancel);

	return TRUE;
}

DECODERET(TVM_ENDEDITLABELNOW)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TVM_ENDEDITLABELNOW);

//////////////////////////////////////////////////////////////////////////////

DECODE(TVM_GETISEARCHSTRING)
{
	PARM(lpsz, LPSTR, LP);
	POUTC(lpsz, DWORD);

	return TRUE;
}

DECODERET(TVM_GETISEARCHSTRING)
{
	PARM(cchChar, INT, RET);
	POUT(cchChar);

	return TRUE;
}

DECODEPARM(TVM_GETISEARCHSTRING)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\treectl.h ===
// treectl.h : header file
//

#ifndef __TREECTL_H__
#define __TREECTL_H__

#ifndef __IMGWELL_H__
#include "imgwell.h"
#endif

//[patbr] we are not a DLL
//#undef AFXAPP_DATA
//#define AFXAPP_DATA AFXEXT_DATA

//[patbr] get rid of this external dependency
//class CPartFrame;
/////////////////////////////////////////////////////////////////////////////
// Values for CNode::m_nFlags
// CNode -- one entry in a CTreeCtl

// Specify packing becuase this gets used accross DLL's:
#pragma pack(4)
class CNode
{
public:
	CNode(DWORD dwData);
	virtual ~CNode();

	virtual CFont* GetFont() const;
	virtual int GetGlyphWidth();

	CNode* m_pParent;
	int m_nLevels;
	DWORD m_dwData;
	WORD m_nFlags;
	TCHAR * m_szText;
	int  m_nWidth;
};
#pragma pack()

#define TF_LASTLEVELENTRY		0x0001
#define TF_HASCHILDREN			0x0002
#define TF_EXPANDED				0x0004
#define TF_DISABLED				0x0008
#define TF_EXPANDABLE			0x0020
#define TF_NOT_EXPANDABLE		0x0040
#define TF_DIRTY_CONTENT		0x0080
#define TF_DIRTY_ITEM			0x0010
#define TF_DROPTARGET           0x0100
#define TF_DRAGSOURCE           0x0200

#define LIST_SEARCH_DELAY (2)

/////////////////////////////////////////////////////////////////////////////
// CTreeListBox item

class CTreeListBox : public CListBox
{
	DECLARE_DYNCREATE(CTreeListBox)

	CTreeListBox();

private:
	int ItemFromPoint(const CPoint& point);

	class CTreeCtl* m_pTree;
	BOOL m_bGotMouseDown : 1;
	BOOL m_bDeferedDeselection : 1;
	BOOL m_bStdMouse : 1;
	int m_nDeferedItem;
	int m_nLastItem;

	static int iSlobPixels;
	static CPoint mouseDownPt;

	friend class CTreeCtl;

	// Generated message map functions
protected:
	//{{AFX_MSG(CTreeListBox)
	afx_msg void OnLButtonDown(UINT, CPoint);
	afx_msg void OnLButtonUp(UINT, CPoint);
	afx_msg void OnLButtonDblClk(UINT, CPoint);
	afx_msg void OnRButtonUp(UINT, CPoint);
	afx_msg void OnRButtonDown(UINT, CPoint);
	afx_msg void OnMouseMove(UINT, CPoint);
	afx_msg void OnChar(UINT nChar, UINT nRepCount, UINT nFlags);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl window

class CTreeCtl : public CWnd
{
	DECLARE_DYNCREATE(CTreeCtl)
	DECLARE_MESSAGE_MAP()

// Construction
public:
	CTreeCtl(BOOL bIsMultiSelection = FALSE, BOOL bKeepSelectionRect = FALSE);
	
	BOOL PreCreateWindow(CREATESTRUCT& cs);

// Attributes
public:

protected:
	BOOL m_bIsMultiSelection : 1;	// Allow multiple selections;
	BOOL m_bKeepSelectionRect : 1;	// keep the selecton rect when not focus
	BOOL m_bEnableDragDrop : 1;
	BOOL m_bShowContextPopup : 1;
	BOOL m_bShowProperties : 1;

	CTreeListBox m_listBox;		// our only child

	CSize m_sizeM;				// size of an "M" in the current font
								// used to determine horiz/vert tree bar dimensions

	int m_cyNode;				// height of one node in the list
	int m_cxExtent;				// approximate width of the whole list
	
	int m_EnableUpdates;		// Reference count of update holding;

	CString m_strSearch;		// typomatic search string
	time_t	m_timeLastKey;		// time since last typomatic key stroke

	//[byrond] Support for unsorted bitmaps (added using a cache)
	BOOL m_bSorted;				// TRUE if the levels should be sorted
	CNode* m_pParentNodeCache;	// Last parent node that had a child
								// added.  This is used for the cache.
	int m_iNextCache;			// Cached next index for the above parent node

// Operations
public:
	// expansion/contraction

	// override this method so that containment can be determined
	virtual BOOL NodeIsExpandable(CNode *);
	
	// *must* override this method so that the text of a node can be
	// determined through means other than the passed 'sz' arg to InsertNode
	// N.B. generally this is for the a node that was set dirty
	virtual void GetNodeTitle(CNode *, CString &);

	// expand/collapse a node (referenced by index)
	void Expand(int nIndex = -1, BOOL bWholeBranch = FALSE);
	void Collapse(int nIndex = -1);
	void Refresh(int nIndex = -1);
	void RefreshAllRoots();

	// expand all nodes (full-expansion)
	//void ExpandAll() 
	//	{Expand(0, TRUE);}
	void ExpandAll();

	// is a particular node expanded?
	BOOL IsExpanded(int nIndex = -1);
	
	// does a particular node have children?
	BOOL HasChildren(int nIndex = -1);

	// get/set the node dwData (referenced by index)
	DWORD GetData(int nIndex = -1);
	void SetData(int nIndex, DWORD dwData);

	// get/set the current selection
	int GetCurSel() { return m_listBox.GetCurSel(); }
	void SetCurSel(int nIndex) { m_listBox.SetCurSel(nIndex); }
	void KeySetSel(int nIndex, BOOL bClearSearchBuffer = TRUE);

	// get/set the current selection if multi-select is on
	int GetSelCount() { return m_listBox.GetSelCount(); }
	int GetSelItems(int nMaxItems, LPINT rgItems) { return m_listBox.GetSelItems(nMaxItems, rgItems); }
	int SetSel(int nIndex, BOOL bSelect = TRUE) { return m_listBox.SetSel(nIndex, bSelect); }
	void SelectAll()
		{ SetSel(-1, TRUE); }

	// our tree-control node modification functions
	int FindNode(DWORD dwData);
	int FindNode(const TCHAR * szText, DWORD & dwData, BOOL fMatchCase = FALSE);
	int InsertNode(int iParentNode, const char* szName, DWORD dwData);
	void DirtyNode(int iNode, WORD);	// where the 2nd arg. is TF_DIRTY_???
	void RemoveNode(int iNode, BOOL bUpdateSel = TRUE);

	void RecalcHorizontalExtent ();
	void ClearSearchBuffer();
	
	int ItemFromPoint(const CPoint& point)
		{ return m_listBox.ItemFromPoint(point); }

	int GetItemRect(int nItem, LPRECT lpRect)
		{ return m_listBox.GetItemRect(nItem, lpRect); }

	CListBox* GetListBox()
		{ return &m_listBox; }
		
	enum HIT_ZONE { left, expand, glyph, text, right };
	
	HIT_ZONE HitTest(int nItem, int x);
	
	// override these methods to support your own actions for the user input

	virtual void OnOpen(int nIndex);				// called on Enter key or double-click
	virtual void OnSelect(int nIndex);				// called on selection change

	virtual BOOL OnKeyDown(UINT nChar);				// called on any Keydown msg
	virtual BOOL OnChar(UINT nChar);					// called on any Char msg

	// specific key handlers
	void OnPrimary();
	void OnExpand();
	void OnExpandBranch();
	void OnExpandAll();
	void OnCollapse();
	
	virtual void OnRightButtonUp(UINT, CPoint);		// called on right mouse button up
	virtual void OnRightButtonDown(UINT, CPoint);	// called on right mouse button down
	
// Implementation
public:
	virtual ~CTreeCtl();
	void FreeAllTreeData();
	
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual BOOL InsertLevel(CNode* pNode, int nIndex, BOOL bExpandAll = FALSE);
	virtual void DrawNodeGlyph(CDC* pDC, CNode* pNode, BOOL bHighlight, CPoint pt);
	
	BOOL InsertNode(CNode* pParentNode, int iParentNode, const char* szName,
					DWORD dwData, CNode*& rpNodeRet, int& riNodeRet);
	void Collapse(CNode* pNode, int nIndex);
	void Refresh(CNode* pNode, int nIndex);
    CNode* GetNode(int nIndex = -1);
    void ResetSizes(CDC* pDC);
    void InvalSelection();
    void InvalItem(int nItem);
    
	int  GetMaxItemExent () { return m_cxExtent; };

#if 0	//[patbr] usused code
	// For save/loading expanded state:
	BYTE* GetInitData();
	void ReadInitData ( CPartFrame *pFrame );
	void SizeViewToTree ( CPartFrame *pFrame );
#endif	//[patbr] end of unused code...

	void HoldUpdates ();
	void EnableUpdates ();

	virtual int CompareData(const CNode* pNode1, const CNode* pNode2);
	int CompareNodes(const CNode* pNode1, const CNode* pNode2);

	virtual CNode* CreateNode(DWORD dwData);
	virtual void DeleteNode(CNode* pNode);

	virtual void BeginDragDrop();

	//[byrond] Support for the unsorted tree cache
	void FlushTheCache() { m_pParentNodeCache = NULL; m_iNextCache = 0; }

	// Generated message map functions

protected:
	//{{AFX_MSG(CTreeCtl)
	afx_msg int OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex);
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	afx_msg void OnLbDblClk();
	afx_msg void OnLbSelChange();
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetFont(WPARAM wParam, LPARAM lParam);
	
	static CImageWell c_imageWell;
	static int c_cyBorder;		// SM_CYBORDER
	static int c_cyBorderX2;	// SM_CYBORDER * 2
	
	friend class CTreeListBox;
};

#define IDCW_TREELISTBOX	1 // child id for listbox



/////////////////////////////////////////////////////////////////////////////

//[patbr] we are not a DLL
//#undef AFXAPP_DATA
//#define AFXAPP_DATA NEAR

#endif // __TREECTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\version.h ===
#define rmj		3
#define rmm		0
#define rup		5128
#define szVerName	"Olympus M2"
#define szVerUser	"WBRYAN"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\winfdlg.cpp ===
// winfdlg.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"
#include "findtool.h"
#include "filtrdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFiltersWindowDlgTab dialog

CFiltersWindowDlgTab::~CFiltersWindowDlgTab()
{
}

BEGIN_MESSAGE_MAP(CFiltersWindowDlgTab, CDlgTab)
	//{{AFX_MSG_MAP(CFiltersWindowDlgTab)
	ON_BN_CLICKED(IDC_FWT_ALLWINDOWS, OnClickedWinFiltersAllWindows)
	ON_BN_CLICKED(IDC_FWT_HIDE, OnClickedHide)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFiltersWindowDlgTab message handlers

BOOL CFiltersWindowDlgTab::OnInitDialog()
{
	CDlgTab::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_FWT_SOBHANDLE, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FWT_SOBTEXT, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FWT_SOBCLASS, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FWT_SOBSTYLE, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FWT_SOBRECT, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FWT_SOBTHREAD, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FWT_SOBPROCESS, WM_SETFONT, (WPARAM)hfont, FALSE);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_FWT_SOBTEXT, WM_SETFONT, (WPARAM)hfont, FALSE);
		SendDlgItemMessage(IDC_FWT_SOBCLASS, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	m_pDoc = ((CFiltersTabbedDialog*)GetParent())->m_pDoc;

	if (m_pDoc->m_fIncludeParent)
	{
		CheckDlgButton(IDC_FWT_PARENT, 1);
	}

	if (m_pDoc->m_fIncludeChildren)
	{
		CheckDlgButton(IDC_FWT_CHILDREN, 1);
	}

	if (m_pDoc->m_fIncludeThread)
	{
		CheckDlgButton(IDC_FWT_SAMETHREAD, 1);
	}

	if (m_pDoc->m_fIncludeProcess)
	{
		CheckDlgButton(IDC_FWT_SAMEPROCESS, 1);
	}

	m_FindToolIcon.SubclassDlgItem(IDC_FWT_FINDTOOL, this);
	m_FindToolIcon.Initialize(this);

	m_nObjectType = m_pDoc->m_nObjectType;

	if (m_nObjectType == OT_WINDOW)
	{
		m_hwndSelected = m_pDoc->m_hwndToSpyOn;
	}
	else
	{
		m_hwndSelected = (HWND)NULL;
	}

	UpdateSOBFields();

	return TRUE;  // return TRUE unless you set the focus to a control
}



void CFiltersWindowDlgTab::UpdateSOBFields()
{
	BOOL fEnable = FALSE;

	ShowSOBLabels(m_nObjectType);

	switch (m_nObjectType)
	{
		case OT_WINDOW:
			SetSelectedWindow(m_hwndSelected);
			fEnable = TRUE;
			break;

		case OT_THREAD:
			SetSelectedThread(m_pDoc->m_tidToSpyOn);
			break;

		case OT_PROCESS:
			SetSelectedProcess(m_pDoc->m_pidToSpyOn);
			break;

		case OT_NONE:
			break;

		default:
			ASSERT(FALSE);
			break;
	}

	if (m_pDoc->m_fAllWindows)
	{
		CheckDlgButton(IDC_FWT_ALLWINDOWS, 1);
		GraySOB(TRUE);
		fEnable = FALSE;
	}

	EnableCheckboxes(fEnable);
}



void CFiltersWindowDlgTab::ShowSOBLabels(int nObjectType)
{
	switch (nObjectType)
	{
		case OT_WINDOW:
			GetDlgItem(IDC_FWT_SOBNOSELECTIONLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBSTYLE)->ShowWindow(SW_SHOW);

			SetDlgItemText(IDC_FWT_SOBHANDLELABEL, ids(IDS_WINDOWLABEL));
			SetDlgItemText(IDC_FWT_SOBTEXTLABEL, ids(IDS_TEXTLABEL));
			SetDlgItemText(IDC_FWT_SOBCLASSLABEL, ids(IDS_CLASSLABEL));

			GetDlgItem(IDC_FWT_SOBHANDLELABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBTEXTLABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBCLASSLABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBSTYLELABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBRECTLABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBTHREADLABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBPROCESSLABEL)->ShowWindow(SW_SHOW);

			break;

		case OT_THREAD:
			GetDlgItem(IDC_FWT_SOBNOSELECTIONLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBSTYLE)->ShowWindow(SW_SHOW);

			SetDlgItemText(IDC_FWT_SOBHANDLELABEL, ids(IDS_THREADIDLABEL));
			SetDlgItemText(IDC_FWT_SOBTEXTLABEL, ids(IDS_PROCESSIDLABEL));
			SetDlgItemText(IDC_FWT_SOBCLASSLABEL, ids(IDS_EXECUTABLELABEL));

			GetDlgItem(IDC_FWT_SOBHANDLELABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBTEXTLABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBCLASSLABEL)->ShowWindow(SW_SHOW);

			GetDlgItem(IDC_FWT_SOBSTYLELABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBRECTLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBTHREADLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBPROCESSLABEL)->ShowWindow(SW_HIDE);

			break;

		case OT_PROCESS:
			GetDlgItem(IDC_FWT_SOBNOSELECTIONLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBSTYLE)->ShowWindow(SW_SHOW);

			SetDlgItemText(IDC_FWT_SOBHANDLELABEL, ids(IDS_PROCESSIDLABEL));
			SetDlgItemText(IDC_FWT_SOBTEXTLABEL, ids(IDS_EXECUTABLELABEL));

			GetDlgItem(IDC_FWT_SOBHANDLELABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_FWT_SOBTEXTLABEL)->ShowWindow(SW_SHOW);

			GetDlgItem(IDC_FWT_SOBCLASSLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBSTYLELABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBRECTLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBTHREADLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBPROCESSLABEL)->ShowWindow(SW_HIDE);

			break;

		case OT_NONE:
			GetDlgItem(IDC_FWT_SOBHANDLELABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBTEXTLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBCLASSLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBSTYLELABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBRECTLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBTHREADLABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBPROCESSLABEL)->ShowWindow(SW_HIDE);

			GetDlgItem(IDC_FWT_SOBSTYLE)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_FWT_SOBNOSELECTIONLABEL)->ShowWindow(SW_SHOW);

			break;

		default:
			ASSERT(FALSE);
			break;
	}
}



//-----------------------------------------------------------------------------
// SetSelectedWindow
//
//
//
// Arguments:
//
//
//-----------------------------------------------------------------------------

void CFiltersWindowDlgTab::SetSelectedWindow(HWND hwndSelected)
{
	CHAR sz[256];
	LPSTR lpszClass;
	int cch;
	RECT rc;

	if (::IsWindow(hwndSelected))
	{
		wsprintf(sz, "%08X", hwndSelected);
		SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

		sz[0] = '"';
		cch = ::GetWindowText(hwndSelected, &sz[1], 256 - 2);
		sz[cch + 1] = '"';
		sz[cch + 2] = 0;
		SetDlgItemText(IDC_FWT_SOBTEXT, sz);

		::GetClassName(hwndSelected, sz, 256);
		if ((lpszClass = GetExpandedClassName(sz)) != NULL)
			_tcscat(sz, lpszClass);
		SetDlgItemText(IDC_FWT_SOBCLASS, sz);

		wsprintf(sz, "%08X", ::GetWindowLong(hwndSelected, GWL_STYLE));
		SetDlgItemText(IDC_FWT_SOBSTYLE, sz);

		::GetWindowRect(hwndSelected, &rc);
		wsprintf(sz, "(%d, %d)-(%d, %d) %dx%d", rc.left, rc.top, rc.right, rc.bottom, rc.right - rc.left, rc.bottom - rc.top);
		SetDlgItemText(IDC_FWT_SOBRECT, sz);

		DWORD pid;
		DWORD tid = GetWindowThreadProcessId(hwndSelected, &pid);
		wsprintf(sz, "%08X", tid);
		SetDlgItemText(IDC_FWT_SOBTHREAD, sz);

		wsprintf(sz, "%08X", pid);
		SetDlgItemText(IDC_FWT_SOBPROCESS, sz);
	}
	else
	{
		//
		// If the handle is NULL, do not even print it out.  If it
		// is not NULL, then it is an hwnd for a destroyed window
		// that the user selected at one time, so we need to display
		// it's value even though it is invalid.
		//
		if (hwndSelected == NULL)
		{
			SetDlgItemText(IDC_FWT_SOBHANDLE, "");
		}
		else
		{
			wsprintf(sz, ids(IDS_INVALID_PARAM), hwndSelected);
			SetDlgItemText(IDC_FWT_SOBHANDLE, sz);
		}

		SetDlgItemText(IDC_FWT_SOBTEXT, "");
		SetDlgItemText(IDC_FWT_SOBCLASS, "");
		SetDlgItemText(IDC_FWT_SOBSTYLE, "");
		SetDlgItemText(IDC_FWT_SOBRECT, "");
		SetDlgItemText(IDC_FWT_SOBTHREAD, "");
		SetDlgItemText(IDC_FWT_SOBPROCESS, "");
	}
}



//-----------------------------------------------------------------------------
// SetSelectedThread
//
//
//
// Arguments:
//
//
//-----------------------------------------------------------------------------

void CFiltersWindowDlgTab::SetSelectedThread(DWORD tid)
{
	CHAR sz[256];
	LPWSTR lpwsz;
	int iIndex = -1;

	if (!theApp.IsChicago())
	{
		// Win32
//		enum CPROCDB::PROCDBERR error;
		WORD wQueryType = PROCDBQ_THREAD;
		CPROCDB ProcessDatabase(wQueryType/*, &error*/);
		CPROCDB::PRFCNTRTHRD PrfCntrThrd;

		if ((iIndex = ProcessDatabase.GetThrdIndexFromId(tid)) != -1)
		{
			ProcessDatabase.GetPrfCntrThrd(iIndex, &PrfCntrThrd);

			wsprintf(sz, "%08X", tid);
			SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

			wsprintf(sz, "%08X", PrfCntrThrd.dwProcessId);
			SetDlgItemText(IDC_FWT_SOBTEXT, sz);

			lpwsz = (LPWSTR)ProcessDatabase.GetThreadName(iIndex);
			::SetDlgItemTextW(m_hWnd, IDC_FWT_SOBCLASS, lpwsz);
		}
		else
		{
			wsprintf(sz, ids(IDS_INVALID_PARAM), tid);
			SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

			SetDlgItemText(IDC_FWT_SOBTEXT, "");
			SetDlgItemText(IDC_FWT_SOBCLASS, "");
		}
	}
	else
	{
		// Chicago
		HANDLE hThreadList;
		THREADENTRY32 te32;
		BOOL fFound = FALSE;

		te32.dwSize = sizeof(THREADENTRY32);

		if ((hThreadList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPTHREAD, 0)) != NULL)
		{
			if ((*theApp.pfnThread32First)(hThreadList, &te32))
			{
				if (te32.th32ThreadID == tid)
				{
					fFound = TRUE;
				}
				else
				{
					while ((*theApp.pfnThread32Next)(hThreadList, &te32))
					{
						if (te32.th32ThreadID == tid)
						{
							fFound = TRUE;
							break;
						}
					}
				}

				if (fFound)
				{
					wsprintf(sz, "%08X", tid);
					SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

					wsprintf(sz, "%08X", te32.th32OwnerProcessID);
					SetDlgItemText(IDC_FWT_SOBTEXT, sz);

					HANDLE hProcessList;
					PROCESSENTRY32 pe32;

					pe32.dwSize = sizeof(PROCESSENTRY32);

					if ((hProcessList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPPROCESS, 0)) != NULL)
					{
						if ((*theApp.pfnProcess32First)(hProcessList, &pe32))
						{
							if (pe32.th32ProcessID == te32.th32OwnerProcessID)
							{
								if (pe32.dwSize == sizeof(PROCESSENTRY32))
								{
									char szFileName[_MAX_FNAME];
									_splitpath(pe32.szExeFile, NULL, NULL, szFileName, NULL);
									SetDlgItemText(IDC_FWT_SOBCLASS, szFileName);
								}
								else
									SetDlgItemText(IDC_FWT_SOBCLASS, "");
							}
							else
							{
								while ((*theApp.pfnProcess32Next)(hProcessList, &pe32))
								{
									if (pe32.th32ProcessID == te32.th32OwnerProcessID)
									{
										if (pe32.dwSize == sizeof(PROCESSENTRY32))
										{
											char szFileName[_MAX_FNAME];
											_splitpath(pe32.szExeFile, NULL, NULL, szFileName, NULL);
											SetDlgItemText(IDC_FWT_SOBCLASS, szFileName);
										}
										else
											SetDlgItemText(IDC_FWT_SOBCLASS, "");
										break;
									}
								}
							}
						}
					}
				}
				else
				{
					wsprintf(sz, ids(IDS_INVALID_PARAM), tid);
					SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

					SetDlgItemText(IDC_FWT_SOBTEXT, "");
					SetDlgItemText(IDC_FWT_SOBCLASS, "");
				}
			}

			CloseHandle(hThreadList);
		}
	}

	SetDlgItemText(IDC_FWT_SOBSTYLE, "");
	SetDlgItemText(IDC_FWT_SOBRECT, "");
	SetDlgItemText(IDC_FWT_SOBTHREAD, "");
	SetDlgItemText(IDC_FWT_SOBPROCESS, "");
}



//-----------------------------------------------------------------------------
// SetSelectedProcess
//
//
//
// Arguments:
//
//
//-----------------------------------------------------------------------------

void CFiltersWindowDlgTab::SetSelectedProcess(DWORD pid)
{
	CHAR sz[260];
	LPWSTR lpwsz;
	int iIndex = -1;

	if (!theApp.IsChicago())
	{
		// Win32
//		enum CPROCDB::PROCDBERR error;
		WORD wQueryType = PROCDBQ_PROCESS;
		CPROCDB ProcessDatabase(wQueryType/*, &error*/);
		CPROCDB::PRFCNTRPROC PrfCntrProc;

		if ((iIndex = ProcessDatabase.GetProcIndexFromId(pid)) != -1)
		{
			ProcessDatabase.GetPrfCntrProc(iIndex, &PrfCntrProc);

			wsprintf(sz, "%08X", pid);
			SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

			lpwsz = (LPWSTR)ProcessDatabase.GetProcessName(iIndex);
			::SetDlgItemTextW(m_hWnd, IDC_FWT_SOBTEXT, lpwsz);
		}
		else
		{
			wsprintf(sz, ids(IDS_INVALID_PARAM), pid);
			SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

			SetDlgItemText(IDC_FWT_SOBTEXT, "");
		}
	}
	else
	{
		// Chicago
		HANDLE hProcessList;
		PROCESSENTRY32 pe32;
		BOOL fFound = FALSE;

		pe32.dwSize = sizeof(PROCESSENTRY32);

		if ((hProcessList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPPROCESS, 0)) != NULL)
		{
			if ((*theApp.pfnProcess32First)(hProcessList, &pe32))
			{
				if (pe32.th32ProcessID == pid)
				{
					fFound = TRUE;
				}
				else
				{
					while ((*theApp.pfnProcess32Next)(hProcessList, &pe32))
					{
						if (pe32.th32ProcessID == pid)
						{
							fFound = TRUE;
							break;
						}
					}
				}

				if (fFound)
				{
					wsprintf(sz, "%08X", pid);
					SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

					if (pe32.dwSize == sizeof(PROCESSENTRY32))
					{
						char szFileName[_MAX_FNAME];
						_splitpath(pe32.szExeFile, NULL, NULL, szFileName, NULL);
						SetDlgItemText(IDC_FWT_SOBTEXT, szFileName);
					}
					else
						SetDlgItemText(IDC_FWT_SOBTEXT, "");
				}
				else
				{
					wsprintf(sz, ids(IDS_INVALID_PARAM), pid);
					SetDlgItemText(IDC_FWT_SOBHANDLE, sz);

					SetDlgItemText(IDC_FWT_SOBTEXT, "");
				}
			}

			CloseHandle(hProcessList);
		}
	}

	SetDlgItemText(IDC_FWT_SOBCLASS, "");
	SetDlgItemText(IDC_FWT_SOBSTYLE, "");
	SetDlgItemText(IDC_FWT_SOBRECT, "");
	SetDlgItemText(IDC_FWT_SOBTHREAD, "");
	SetDlgItemText(IDC_FWT_SOBPROCESS, "");
}



void CFiltersWindowDlgTab::BeginFindWindowTracking()
{
	SetSelectedWindow((HWND)NULL);
	ShowSOBLabels(OT_WINDOW);
	GraySOB(FALSE);
	CheckDlgButton(IDC_FWT_ALLWINDOWS, 0);
	EnableCheckboxes(TRUE);
	m_hwndFound = NULL;
}



void CFiltersWindowDlgTab::UpdateFindWindowTracking(HWND hwndFound)
{
	SetSelectedWindow(hwndFound);
	m_hwndFound = hwndFound;
}



void CFiltersWindowDlgTab::EndFindWindowTracking()
{
	if (m_hwndFound)
	{
		m_hwndSelected = m_hwndFound;
		m_nObjectType = OT_WINDOW;
	}
	else
	{
		UpdateSOBFields();
	}
}



void CFiltersWindowDlgTab::OnClickedWinFiltersAllWindows()
{
	GraySOB(IsDlgButtonChecked(IDC_FWT_ALLWINDOWS));

	if (!IsDlgButtonChecked(IDC_FWT_ALLWINDOWS) && m_nObjectType == OT_WINDOW)
	{
		EnableCheckboxes(TRUE);
	}
	else
	{
		EnableCheckboxes(FALSE);
	}
}



void CFiltersWindowDlgTab::EnableCheckboxes(BOOL fEnable)
{
	GetDlgItem(IDC_FWT_PARENT)->EnableWindow(fEnable);
	GetDlgItem(IDC_FWT_CHILDREN)->EnableWindow(fEnable);
	GetDlgItem(IDC_FWT_SAMETHREAD)->EnableWindow(fEnable);
	GetDlgItem(IDC_FWT_SAMEPROCESS)->EnableWindow(fEnable);
}



void CFiltersWindowDlgTab::GraySOB(BOOL fGray)
{
	GetDlgItem(IDC_FWT_SOBHANDLE)->EnableWindow(!fGray);
	GetDlgItem(IDC_FWT_SOBTEXT)->EnableWindow(!fGray);
	GetDlgItem(IDC_FWT_SOBCLASS)->EnableWindow(!fGray);
	GetDlgItem(IDC_FWT_SOBSTYLE)->EnableWindow(!fGray);
	GetDlgItem(IDC_FWT_SOBRECT)->EnableWindow(!fGray);
	GetDlgItem(IDC_FWT_SOBTHREAD)->EnableWindow(!fGray);
	GetDlgItem(IDC_FWT_SOBPROCESS)->EnableWindow(!fGray);
	GetDlgItem(IDC_FWT_SOBNOSELECTIONLABEL)->EnableWindow(!fGray);
}



void CFiltersWindowDlgTab::OnClickedHide()
{
	if (IsDlgButtonChecked(IDC_FWT_HIDE))
	{
		theApp.m_pMainWnd->ShowWindow(SW_HIDE);
	}
	else
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
	}
}


BOOL CFiltersWindowDlgTab::ValidateTab()
{
	if (m_hwndSelected)
	{
		if (!IsDlgButtonChecked(IDC_FWT_ALLWINDOWS) && !IsSpyableWindow(m_hwndSelected))
		{
			SpyMessageBox(IDS_WND_NOT_SPYABLE);
			GotoDlgCtrl(GetDlgItem(IDC_FWT_HIDE));
			return(FALSE);
		}
	}

	return(TRUE);
}


void CFiltersWindowDlgTab::CommitTab()
{
	BOOL fSelectedSave = m_pDoc->IsSomethingSelected();

	if (m_hwndSelected)
	{
		m_pDoc->SetWindowToSpyOn(m_hwndSelected);
	}

	m_pDoc->m_fAllWindows = IsDlgButtonChecked(IDC_FWT_ALLWINDOWS);
	m_pDoc->m_fIncludeParent = IsDlgButtonChecked(IDC_FWT_PARENT);
	m_pDoc->m_fIncludeChildren = IsDlgButtonChecked(IDC_FWT_CHILDREN);
	m_pDoc->m_fIncludeThread = IsDlgButtonChecked(IDC_FWT_SAMETHREAD);
	m_pDoc->m_fIncludeProcess = IsDlgButtonChecked(IDC_FWT_SAMEPROCESS);

	m_pDoc->UpdateTitle();

	//
	// If they have selected "Save as Default", copy the
	// current settings to the default settings.
	//
	if (IsDlgButtonChecked(IDC_FWT_SAVE))
	{
		CMsgDoc::m_fIncludeParentDef = m_pDoc->m_fIncludeParent;
		CMsgDoc::m_fIncludeChildrenDef = m_pDoc->m_fIncludeChildren;
		CMsgDoc::m_fIncludeThreadDef = m_pDoc->m_fIncludeThread;
		CMsgDoc::m_fIncludeProcessDef = m_pDoc->m_fIncludeProcess;
	}

	//
	// Restore the Spy app if needed.
	//
	if (IsDlgButtonChecked(IDC_FWT_HIDE))
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
		CheckDlgButton(IDC_FWT_HIDE, 0);
	}

	if (m_pDoc->IsSomethingSelected())
	{
		//
		// If there was nothing selected before, and they selected
		// something (this includes All Windows) then we want to turn
		// on the logging now.  If there was already something
		// selected before, and they change the selection, we just
		// leave the Logging state as it is.
		//
		if (!fSelectedSave)
		{
			if (!m_pDoc->IsLogging())
			{
				m_pDoc->OnMessagesStartStop();
			}
		}
	}
	else
	{
		//
		// Else if they have nothing selected then we want to be sure
		// logging is stopped.  This could happen if they had nothing
		// selected originally, then they turned on All Windows, then
		// they went back again and turned off All Windows.  If we don't
		// explicitly stop the logging here, then logging will still
		// be enabled with some overhead involved in the hook (although
		// nothing will match the filters and actually be displayed).
		//
		if (m_pDoc->IsLogging())
		{
			m_pDoc->OnMessagesStartStop();
		}
	}

	CDlgTab::CommitTab();
}



void CFiltersWindowDlgTab::CancelTab()
{
	//
	// Restore the Spy app if needed.
	//
	if (IsDlgButtonChecked(IDC_FWT_HIDE))
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
		CheckDlgButton(IDC_FWT_HIDE, 0);
	}

	CDlgTab::CancelTab();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\wndnode.cpp ===
// wndtreec.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "treectl.h"
#include "imgwell.h"
#include "spytreec.h"
#include "wndnode.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CWndTreeNode

IMPLEMENT_DYNCREATE(CWndTreeNode, CSpyTreeNode);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BOOL CWndTreeNode::Create(HWND hwnd, BOOL fEnumChildren)
{
	HWND hwndChild;
	CWndTreeNode* pWndTreeNode;
	CHAR szTemp[256];
	LPSTR lpszClass;

	m_hwnd = hwnd;

	if (GetWindowText(hwnd, szTemp, 256))
	{
		m_strText = szTemp;
	}

	if (GetClassName(hwnd, szTemp, 256))
	{
		m_strClass = szTemp;
		if ((lpszClass = GetExpandedClassName((LPSTR)(const char *)m_strClass)) != NULL)
			m_strClass += lpszClass;
	}

	if (fEnumChildren)
	{
		hwndChild = ::GetWindow(hwnd, GW_CHILD);
		while (hwndChild)
		{
			pWndTreeNode = new CWndTreeNode;
			pWndTreeNode->Create(hwndChild, TRUE);
			this->AddChild(pWndTreeNode);

			hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT);
		}
	}

	return TRUE;
}



void CWndTreeNode::GetDescription(CString& str)
{
	LPSTR psz = str.GetBuffer(600);

	sprintf(psz, "Window %8.8X \"%s\" %s", (DWORD)m_hwnd, m_strText.GetBuffer(0), m_strClass.GetBuffer(0));

	str.ReleaseBuffer();
	m_strText.ReleaseBuffer();
	m_strClass.ReleaseBuffer();
}



void CWndTreeNode::ShowProperties()
{
	CPropertyInspector::ShowObjectProperties((DWORD)m_hwnd, OT_WINDOW);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\wndptabs.cpp ===
// wndptabs.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "hotlinkc.h"
#include "proptab.h"
#include "wndptabs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CWindowGeneralPropTab

CWindowGeneralPropTab::~CWindowGeneralPropTab()
{
}


INT CWindowGeneralPropTab::m_aControlIDs[] =
{
	IDC_WGT_TEXT,
	IDC_WGT_WINDOWHANDLE,
	IDC_WPT_WINDOWPROC,
	IDC_WGT_RECTANGLE,
	IDC_WGT_RESTOREDRECT,
	IDC_WGT_CLIENTRECT,
	IDC_WPT_INSTANCEHANDLE,
	IDC_WGT_MENUHANDLE,
	IDC_WGT_USERDATA,
	IDC_WGT_EXTRABYTES,
	0
};


BEGIN_MESSAGE_MAP(CWindowGeneralPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CWindowGeneralPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWindowGeneralPropTab message handlers

BOOL CWindowGeneralPropTab::OnInitDialog()
{
	CPropertyTab::OnInitDialog();

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		CFont* pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		HFONT hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_WGT_TEXT, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	return TRUE;  // return TRUE  unless you set the focus to a control
}



void CWindowGeneralPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	if (pTabDlg->m_flStyles & WS_CHILD)
		SetDlgItemText(IDC_WGT_MENUHANDLELABEL, ids(IDS_CONTROLID));
	else
		SetDlgItemText(IDC_WGT_MENUHANDLELABEL, ids(IDS_MENUHANDLE));

	SetDlgItemText(IDC_WGT_TEXT, pTabDlg->m_strWindowCaption);
	SetDlgItemText(IDC_WGT_WINDOWHANDLE, FormatHex((DWORD)pTabDlg->m_hwnd));
	SetDlgItemText(IDC_WPT_WINDOWPROC, pTabDlg->m_strWndProc);
	SetDlgItemText(IDC_WGT_RECTANGLE, pTabDlg->m_strRectangle);
	SetDlgItemText(IDC_WGT_RESTOREDRECT, pTabDlg->m_strRestoredRect);
	SetDlgItemText(IDC_WGT_CLIENTRECT, pTabDlg->m_strClientRect);
	SetDlgItemText(IDC_WPT_INSTANCEHANDLE, FormatHex((DWORD)pTabDlg->m_hInstance));
	SetDlgItemText(IDC_WGT_MENUHANDLE, FormatHex(pTabDlg->m_dwID));
	SetDlgItemText(IDC_WGT_USERDATA, FormatHex(pTabDlg->m_dwUserData));
	FillCBFromStrList((CComboBox*)GetDlgItem(IDC_WGT_EXTRABYTES), &pTabDlg->m_strListExtraBytes);
}


/////////////////////////////////////////////////////////////////////////////
// CWindowStylesPropTab

CWindowStylesPropTab::~CWindowStylesPropTab()
{
}


INT CWindowStylesPropTab::m_aControlIDs[] =
{
	IDC_WST_STYLES,
	IDC_WST_STYLESLIST,
	IDC_WST_EXTSTYLES,
	IDC_WST_EXTSTYLESLIST,
	0
};


BEGIN_MESSAGE_MAP(CWindowStylesPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CWindowStylesPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWindowStylesPropTab message handlers


void CWindowStylesPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	SetDlgItemText(IDC_WST_STYLES, FormatHex(pTabDlg->m_flStyles));

	FillLBFromStrList((CListBox*)GetDlgItem(IDC_WST_STYLESLIST), &pTabDlg->m_strListStyles);

	SetDlgItemText(IDC_WST_EXTSTYLES, FormatHex(pTabDlg->m_flExtStyles));

	FillLBFromStrList((CListBox*)GetDlgItem(IDC_WST_EXTSTYLESLIST), &pTabDlg->m_strListExtStyles);
}



/////////////////////////////////////////////////////////////////////////////
// CWindowWindowsPropTab

CWindowWindowsPropTab::~CWindowWindowsPropTab()
{
}


INT CWindowWindowsPropTab::m_aControlIDs[] =
{
	IDC_WWT_NEXTWINDOW,
	IDC_WWT_PREVWINDOW,
	IDC_WWT_PARENTWINDOW,
	IDC_WWT_FIRSTCHILD,
	IDC_WWT_OWNERWINDOW,
	0
};


BEGIN_MESSAGE_MAP(CWindowWindowsPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CWindowWindowsPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWindowWindowsPropTab message handlers


BOOL CWindowWindowsPropTab::OnInitDialog()
{
	CPropertyTab::OnInitDialog();

	m_HotLinkNextWindow.SubclassDlgItem(IDC_WWT_NEXTWINDOW, this);
	m_HotLinkPrevWindow.SubclassDlgItem(IDC_WWT_PREVWINDOW, this);
	m_HotLinkParentWindow.SubclassDlgItem(IDC_WWT_PARENTWINDOW, this);
	m_HotLinkFirstChild.SubclassDlgItem(IDC_WWT_FIRSTCHILD, this);
	m_HotLinkOwnerWindow.SubclassDlgItem(IDC_WWT_OWNERWINDOW, this);

	return TRUE;  // return TRUE  unless you set the focus to a control
}



void CWindowWindowsPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	m_HotLinkNextWindow.SetJumpObject((DWORD)pTabDlg->m_hwndNext);
	m_HotLinkPrevWindow.SetJumpObject((DWORD)pTabDlg->m_hwndPrevious);
	m_HotLinkParentWindow.SetJumpObject((DWORD)pTabDlg->m_hwndParent);
	m_HotLinkFirstChild.SetJumpObject((DWORD)pTabDlg->m_hwndChild);
	m_HotLinkOwnerWindow.SetJumpObject((DWORD)pTabDlg->m_hwndOwner);
}



/////////////////////////////////////////////////////////////////////////////
// CWindowClassPropTab

CWindowClassPropTab::~CWindowClassPropTab()
{
}


INT CWindowClassPropTab::m_aControlIDs[] =
{
	IDC_WCT_CLASSNAME,
	IDC_WCT_STYLES,
	IDC_WCT_STYLESCOMBO,
	IDC_WCT_CLASSEXTRABYTES,
	IDC_WCT_CLASSEXTRABYTESCOMBO,
	IDC_WCT_CLASSATOM,
	IDC_WCT_WINDOWEXTRABYTES,
	IDC_WCT_MENUNAME,
	IDC_WCT_ICONHANDLE,
	IDC_WCT_CURSORHANDLE,
	IDC_WCT_BACKGROUNDBRUSH,
	IDC_WCT_INSTANCEHANDLE,
	IDC_WCT_WINDOWPROC,
	0
};


BEGIN_MESSAGE_MAP(CWindowClassPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CWindowClassPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWindowClassPropTab message handlers


BOOL CWindowClassPropTab::OnInitDialog()
{
	CPropertyTab::OnInitDialog();

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		CFont* pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		HFONT hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_WCT_CLASSNAME, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	return TRUE;  // return TRUE  unless you set the focus to a control
}



void CWindowClassPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	SetDlgItemText(IDC_WCT_CLASSNAME, pTabDlg->m_strClassName);
	SetDlgItemText(IDC_WCT_STYLES, pTabDlg->m_strClassStyles);
	FillCBFromStrList((CComboBox*)GetDlgItem(IDC_WCT_STYLESCOMBO), &pTabDlg->m_strListClassStyles);
	SetDlgItemText(IDC_WCT_CLASSEXTRABYTES, pTabDlg->m_strClassExtraBytes);
	FillCBFromStrList((CComboBox*)GetDlgItem(IDC_WCT_CLASSEXTRABYTESCOMBO), &pTabDlg->m_strListClassExtraBytes);
	SetDlgItemText(IDC_WCT_CLASSATOM, pTabDlg->m_strClassAtom);
	SetDlgItemText(IDC_WCT_WINDOWEXTRABYTES, pTabDlg->m_strClassWndExtraBytes);
	SetDlgItemText(IDC_WCT_MENUNAME, pTabDlg->m_strClassMenuName);
	SetDlgItemText(IDC_WCT_ICONHANDLE, pTabDlg->m_strClassIcon);
	SetDlgItemText(IDC_WCT_CURSORHANDLE, pTabDlg->m_strClassCursor);
	SetDlgItemText(IDC_WCT_BACKGROUNDBRUSH, pTabDlg->m_strClassBrush);
	SetDlgItemText(IDC_WCT_INSTANCEHANDLE, pTabDlg->m_strClassInstance);
	SetDlgItemText(IDC_WCT_WINDOWPROC, pTabDlg->m_strClassWndProc);
}



/////////////////////////////////////////////////////////////////////////////
// CWindowProcessPropTab

CWindowProcessPropTab::~CWindowProcessPropTab()
{
}


INT CWindowProcessPropTab::m_aControlIDs[] =
{
	IDC_WPT_PROCESSID,
	IDC_WPT_THREADID,
	0
};


BEGIN_MESSAGE_MAP(CWindowProcessPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CWindowProcessPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWindowProcessPropTab message handlers


BOOL CWindowProcessPropTab::OnInitDialog()
{
	CPropertyTab::OnInitDialog();

	m_HotLinkProcessID.SubclassDlgItem(IDC_WPT_PROCESSID, this);
	m_HotLinkThreadID.SubclassDlgItem(IDC_WPT_THREADID, this);

	return TRUE;  // return TRUE  unless you set the focus to a control
}



void CWindowProcessPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	if (pTabDlg->m_fValidProcessThreadID)
	{
		m_HotLinkProcessID.SetJumpObject(pTabDlg->m_ProcessID);
		m_HotLinkThreadID.SetJumpObject(pTabDlg->m_ThreadID);
	}
	else
	{
		m_HotLinkProcessID.MarkInvalid();
		m_HotLinkThreadID.MarkInvalid();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\wndnode.h ===
// wndnode.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CWndTreeNode object

class CWndTreeNode : public CSpyTreeNode
{
	DECLARE_DYNCREATE(CWndTreeNode);

public:
	BOOL Create(HWND hwnd, BOOL fEnumChildren);

// Attributes
public:

// Operations
public:
	virtual void GetDescription(CString& str);
	virtual void ShowProperties();
	virtual int GetBitmapIndex()
	{
		return IDX_WNDBITMAP;
	}
	virtual DWORD GetObjectHandle()
	{
		return (DWORD)m_hwnd;
	}
	virtual int GetObjectType()
	{
		return OT_WINDOW;
	}
	virtual CString GetCaption()
	{
		return m_strText;
	}
	virtual CString GetClass()
	{
		return m_strClass;
	}

// Implementation
protected:
	HWND m_hwnd;
	CString m_strText;
	CString m_strClass;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\winmsgs.cpp ===
//-----------------------------------------------------------------------------
//  WinMsgs.cpp
//
//  Window message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//-----------------------------------------------------------------------------
// Tables
//-----------------------------------------------------------------------------

VALUETABLE tblWindowStyles[] =
{
	TABLEENTRY(WS_POPUP),
	TABLEENTRY(WS_CHILD),
	TABLEENTRY(WS_MINIMIZE),
	TABLEENTRY(WS_VISIBLE),
	TABLEENTRY(WS_DISABLED),
	TABLEENTRY(WS_CLIPSIBLINGS),
	TABLEENTRY(WS_CLIPCHILDREN),
	TABLEENTRY(WS_MAXIMIZE),
	TABLEENTRY(WS_BORDER),
	TABLEENTRY(WS_DLGFRAME),
	TABLEENTRY(WS_VSCROLL),
	TABLEENTRY(WS_HSCROLL),
	TABLEENTRY(WS_SYSMENU),
	TABLEENTRY(WS_THICKFRAME),
	TABLEENTRY(WS_GROUP),
	TABLEENTRY(WS_TABSTOP),
	TABLEEND
};

VALUETABLE tblDialogStyles[] =
{
	TABLEENTRY(DS_ABSALIGN),
	TABLEENTRY(DS_SYSMODAL),
	TABLEENTRY(DS_LOCALEDIT),
	TABLEENTRY(DS_SETFONT),
	TABLEENTRY(DS_MODALFRAME),
	TABLEENTRY(DS_NOIDLEMSG),
	TABLEENTRY(DS_SETFOREGROUND),
	TABLEEND
};

VALUETABLE tblButtonStyles[] =
{
	// don't change ordering here--having the styles ordered
	// from largest hex value to smallest allows property page
	// to display them correctly.
	TABLEENTRY(BS_LEFTTEXT),
	TABLEENTRY(BS_OWNERDRAW),
	TABLEENTRY(BS_AUTORADIOBUTTON),
	TABLEENTRY(BS_USERBUTTON),
	TABLEENTRY(BS_GROUPBOX),
	TABLEENTRY(BS_AUTO3STATE),
	TABLEENTRY(BS_3STATE),
	TABLEENTRY(BS_RADIOBUTTON),
	TABLEENTRY(BS_AUTOCHECKBOX),
	TABLEENTRY(BS_CHECKBOX),
	TABLEENTRY(BS_DEFPUSHBUTTON),
	TABLEENTRY(BS_PUSHBUTTON),
	TABLEEND
};

VALUETABLE tblComboBoxStyles[] =
{
	// don't change ordering here--having the styles ordered
	// from largest hex value to smallest allows property page
	// to display them correctly.
	TABLEENTRY(CBS_DISABLENOSCROLL),
	TABLEENTRY(CBS_NOINTEGRALHEIGHT),
	TABLEENTRY(CBS_HASSTRINGS),
	TABLEENTRY(CBS_SORT),
	TABLEENTRY(CBS_OEMCONVERT),
	TABLEENTRY(CBS_AUTOHSCROLL),
	TABLEENTRY(CBS_OWNERDRAWVARIABLE),
	TABLEENTRY(CBS_OWNERDRAWFIXED),
	TABLEENTRY(CBS_DROPDOWNLIST),
	TABLEENTRY(CBS_DROPDOWN),
	TABLEENTRY(CBS_SIMPLE),
	TABLEEND
};

VALUETABLE tblEditStyles[] =
{
	// don't change ordering here--having the styles ordered
	// from largest hex value to smallest allows property page
	// to display them correctly.
	TABLEENTRY(ES_WANTRETURN),
	TABLEENTRY(ES_READONLY),
	TABLEENTRY(ES_OEMCONVERT),
	TABLEENTRY(ES_NOHIDESEL),
	TABLEENTRY(ES_AUTOHSCROLL),
	TABLEENTRY(ES_AUTOVSCROLL),
	TABLEENTRY(ES_PASSWORD),
	TABLEENTRY(ES_LOWERCASE),
	TABLEENTRY(ES_UPPERCASE),
	TABLEENTRY(ES_MULTILINE),
	TABLEENTRY(ES_RIGHT),
	TABLEENTRY(ES_CENTER),
	TABLEENTRY(ES_LEFT),
	TABLEEND
};

VALUETABLE tblListBoxStyles[] =
{
	TABLEENTRY(LBS_NOTIFY),
	TABLEENTRY(LBS_SORT),
	TABLEENTRY(LBS_NOREDRAW),
	TABLEENTRY(LBS_MULTIPLESEL),
	TABLEENTRY(LBS_OWNERDRAWFIXED),
	TABLEENTRY(LBS_OWNERDRAWVARIABLE),
	TABLEENTRY(LBS_HASSTRINGS),
	TABLEENTRY(LBS_USETABSTOPS),
	TABLEENTRY(LBS_NOINTEGRALHEIGHT),
	TABLEENTRY(LBS_MULTICOLUMN),
	TABLEENTRY(LBS_WANTKEYBOARDINPUT),
	TABLEENTRY(LBS_EXTENDEDSEL),
	TABLEENTRY(LBS_DISABLENOSCROLL),
	TABLEENTRY(LBS_NODATA),
	TABLEENTRY(LBS_STANDARD),
	TABLEEND
};

VALUETABLE tblScrollBarStyles[] =
{
	TABLEENTRY(SBS_HORZ),
	TABLEENTRY(SBS_VERT),
	TABLEENTRY(SBS_TOPALIGN),
	TABLEENTRY(SBS_LEFTALIGN),
	TABLEENTRY(SBS_BOTTOMALIGN),
	TABLEENTRY(SBS_RIGHTALIGN),
	TABLEENTRY(SBS_SIZEBOXTOPLEFTALIGN),
	TABLEENTRY(SBS_SIZEBOXBOTTOMRIGHTALIGN),
	TABLEENTRY(SBS_SIZEBOX),
// TODO: TABLEENTRY(SBS_SIZEGRIP),
	TABLEEND
};

VALUETABLE tblStaticStyles[] =
{
	TABLEENTRY(SS_NOPREFIX),
	TABLEENTRY(SS_LEFTNOWORDWRAP),
	TABLEENTRY(SS_SIMPLE),
	TABLEENTRY(SS_USERITEM),	  // TODO: is this obsolete?
	TABLEENTRY(SS_WHITEFRAME),
	TABLEENTRY(SS_GRAYFRAME),
	TABLEENTRY(SS_BLACKFRAME),
	TABLEENTRY(SS_WHITERECT),
	TABLEENTRY(SS_GRAYRECT),
	TABLEENTRY(SS_BLACKRECT),
	TABLEENTRY(SS_ICON),
	TABLEENTRY(SS_RIGHT),
	TABLEENTRY(SS_CENTER),
	TABLEENTRY(SS_LEFT),
// TODO: TABLEENTRY(SS_BITMAP),
// TODO: TABLEENTRY(SS_CENTERIMAGE),
// TODO: TABLEENTRY(SS_METAPICT),
// TODO: TABLEENTRY(SS_NOTIFY),
// TODO: TABLEENTRY(SS_OWNERDRAW),
// TODO: TABLEENTRY(SS_RIGHTIMAGE),
	TABLEEND
};

VALUETABLE tblExtWindowStyles[] =
{
	TABLEENTRY(WS_EX_TRANSPARENT),	// TODO: is this obsolete?
	TABLEENTRY(WS_EX_ACCEPTFILES),
	TABLEENTRY(WS_EX_TOPMOST),
	TABLEENTRY(WS_EX_NOPARENTNOTIFY),
	TABLEENTRY(WS_EX_DLGMODALFRAME),
	TABLEEND
};
#ifndef DISABLE_WIN95_MESSAGES
VALUETABLE tblHeaderStyles[] =
{
	TABLEENTRY(HDS_HORZ),
	TABLEENTRY(HDS_BUTTONS),
	TABLEENTRY(HDS_HIDDEN),
	TABLEEND
};
#endif
VALUETABLE tblToolbarStyles[] =
{
	TABLEENTRY(TBSTYLE_BUTTON),
	TABLEENTRY(TBSTYLE_SEP),
	TABLEENTRY(TBSTYLE_CHECK),
	TABLEENTRY(TBSTYLE_GROUP),
	#ifndef DISABLE_WIN95_MESSAGES
	TABLEENTRY(TBSTYLE_TOOLTIPS),
	TABLEENTRY(TBSTYLE_WRAPABLE),
	TABLEENTRY(TBSTYLE_ALTDRAG),
	#endif
	TABLEEND
};
#ifndef DISABLE_WIN95_MESSAGES
VALUETABLE tblToolTipStyles[] =
{
	TABLEENTRY(TTS_ALWAYSTIP),
	TABLEENTRY(TTS_NOPREFIX),
	TABLEEND
};
#endif
#ifndef DISABLE_WIN95_MESSAGES
VALUETABLE tblStatusBarStyles[] =
{
	TABLEENTRY(SBT_OWNERDRAW),
	TABLEENTRY(SBT_NOBORDERS),
	TABLEENTRY(SBT_POPOUT),
	TABLEENTRY(HBT_SPRING),
	TABLEEND
};
#endif
#ifndef DISABLE_WIN95_MESSAGES
VALUETABLE tblTrackBarStyles[] =
{
	TABLEENTRY(TBS_AUTOTICKS),
	TABLEENTRY(TBS_VERT),
	TABLEENTRY(TBS_HORZ),
	TABLEENTRY(TBS_TOP),
	TABLEENTRY(TBS_BOTTOM),
	TABLEENTRY(TBS_LEFT),
	TABLEENTRY(TBS_RIGHT),
	TABLEENTRY(TBS_BOTH),
	TABLEENTRY(TBS_NOTICKS),
	TABLEENTRY(TBS_ENABLESELRANGE),
	TABLEENTRY(TBS_FIXEDLENGTH),
	TABLEENTRY(TBS_NOTHUMB),
	TABLEEND
};
#endif
VALUETABLE tblUpDownStyles[] =
{
	TABLEENTRY(UDS_WRAP),
	TABLEENTRY(UDS_SETBUDDYINT),
	TABLEENTRY(UDS_ALIGNRIGHT),
	TABLEENTRY(UDS_ALIGNLEFT),
	TABLEENTRY(UDS_AUTOBUDDY),
	TABLEENTRY(UDS_ARROWKEYS),
	#ifndef DISABLE_WIN95_MESSAGES
	TABLEENTRY(UDS_HORZ),
	TABLEENTRY(UDS_NOTHOUSANDS),
	#endif
	TABLEEND
};
#ifndef DISABLE_WIN95_MESSAGES
VALUETABLE tblListViewStyles[] =
{
	TABLEENTRY(LVS_LIST),
	TABLEENTRY(LVS_SMALLICON),
	TABLEENTRY(LVS_REPORT),
	TABLEENTRY(LVS_ICON),
	TABLEENTRY(LVS_SINGLESEL),
	TABLEENTRY(LVS_SHOWSELALWAYS),
	TABLEENTRY(LVS_SORTASCENDING),
	TABLEENTRY(LVS_SORTDESCENDING),
	TABLEENTRY(LVS_SHAREIMAGELISTS),
	TABLEENTRY(LVS_NOLABELWRAP),
	TABLEENTRY(LVS_AUTOARRANGE),
	TABLEENTRY(LVS_EDITLABELS),
	TABLEENTRY(LVS_NOSCROLL),
	TABLEENTRY(LVS_NOCOLUMNHEADER),
	TABLEENTRY(LVS_NOSORTHEADER),
	TABLEEND
};

VALUETABLE tblTreeViewStyles[] =
{
	TABLEENTRY(TVS_HASBUTTONS),
	TABLEENTRY(TVS_HASLINES),
	TABLEENTRY(TVS_LINESATROOT),
	TABLEENTRY(TVS_EDITLABELS),
	TABLEENTRY(TVS_DISABLEDRAGDROP),
	TABLEENTRY(TVS_SHOWSELALWAYS),
	TABLEEND
};

VALUETABLE tblTabControlStyles[] =
{
	TABLEENTRY(TCS_FORCEICONLEFT),
	TABLEENTRY(TCS_FORCELABELLEFT),
	TABLEENTRY(TCS_SHAREIMAGELISTS),
	TABLEENTRY(TCS_TABS),
	TABLEENTRY(TCS_BUTTONS),
	TABLEENTRY(TCS_SINGLELINE),
	TABLEENTRY(TCS_MULTILINE),
	TABLEENTRY(TCS_RIGHTJUSTIFY),
	TABLEENTRY(TCS_FIXEDWIDTH),
	TABLEENTRY(TCS_RAGGEDRIGHT),
	TABLEENTRY(TCS_FOCUSONBUTTONDOWN),
	TABLEENTRY(TCS_OWNERDRAWFIXED),
	TABLEENTRY(TCS_TOOLTIPS),
	TABLEENTRY(TCS_FOCUSNEVER),
	TABLEEND
};

VALUETABLE tblAnimateStyles[] =
{
	TABLEENTRY(ACS_CENTER),
	TABLEENTRY(ACS_TRANSPARENT),
	TABLEENTRY(ACS_AUTOPLAY),
	TABLEEND
};
#endif
VALUETABLE tblHScroll[] =
{
	TABLEENTRY(SB_LINELEFT),
	TABLEENTRY(SB_LINERIGHT),
	TABLEENTRY(SB_PAGELEFT),
	TABLEENTRY(SB_PAGERIGHT),
	TABLEENTRY(SB_LEFT),
	TABLEENTRY(SB_RIGHT),
	TABLEENTRY(SB_THUMBPOSITION),
	TABLEENTRY(SB_THUMBTRACK),
	TABLEENTRY(SB_ENDSCROLL),
	TABLEEND
};

VALUETABLE tblVScroll[] =
{
	TABLEENTRY(SB_LINEUP),
	TABLEENTRY(SB_LINEDOWN),
	TABLEENTRY(SB_PAGEUP),
	TABLEENTRY(SB_PAGEDOWN),
	TABLEENTRY(SB_TOP),
	TABLEENTRY(SB_BOTTOM),
	TABLEENTRY(SB_THUMBPOSITION),
	TABLEENTRY(SB_THUMBTRACK),
	TABLEENTRY(SB_ENDSCROLL),
	TABLEEND
};

VALUETABLE tblWindowPos[] =
{
	TABLEENTRY(SWP_NOSIZE),
	TABLEENTRY(SWP_NOMOVE),
	TABLEENTRY(SWP_NOZORDER),
	TABLEENTRY(SWP_NOREDRAW),
	TABLEENTRY(SWP_NOACTIVATE),
	TABLEENTRY(SWP_DRAWFRAME),
	TABLEENTRY(SWP_SHOWWINDOW),
	TABLEENTRY(SWP_HIDEWINDOW),
	TABLEENTRY(SWP_NOCOPYBITS),
	TABLEENTRY(SWP_NOREPOSITION),
	TABLEEND
};

VALUETABLE tblCreateWindowPos[] =
{
	TABLEENTRY(CW_USEDEFAULT),
	TABLEEND
};

VALUETABLE tblTrueFalse[] =
{
	// didn't use TABLEENTRY because 
	// wanted True and False in mixed case.
	(UINT)TRUE, "True",
	(UINT)FALSE, "False",
	TABLEEND
};

static VALUETABLE tblActivate[] =
{
	TABLEENTRY(WA_ACTIVE),
	TABLEENTRY(WA_CLICKACTIVE),
	TABLEENTRY(WA_INACTIVE),
	TABLEEND
};

static VALUETABLE tblButtonNC[] =
{
	TABLEENTRY(BN_CLICKED),
	TABLEENTRY(BN_PAINT),
	TABLEENTRY(BN_HILITE),
	TABLEENTRY(BN_UNHILITE),
	TABLEENTRY(BN_DISABLE),
	TABLEENTRY(BN_DOUBLECLICKED),
	TABLEEND
};

static VALUETABLE tblComboboxNC[] =
{
	TABLEENTRY(CBN_ERRSPACE),
	TABLEENTRY(CBN_SELCHANGE),
	TABLEENTRY(CBN_DBLCLK),
	TABLEENTRY(CBN_SETFOCUS),
	TABLEENTRY(CBN_KILLFOCUS),
	TABLEENTRY(CBN_EDITCHANGE),
	TABLEENTRY(CBN_EDITUPDATE),
	TABLEENTRY(CBN_DROPDOWN),
	TABLEENTRY(CBN_CLOSEUP),
	TABLEEND
};

static VALUETABLE tblListboxNC[] =
{
	TABLEENTRY(LBN_ERRSPACE),
	TABLEENTRY(LBN_SELCHANGE),
	TABLEENTRY(LBN_DBLCLK),
	TABLEENTRY(LBN_SELCANCEL),
	TABLEENTRY(LBN_SETFOCUS),
	TABLEENTRY(LBN_KILLFOCUS),
	TABLEEND
};

static VALUETABLE tblEditNC[] =
{
	TABLEENTRY(EN_SETFOCUS),
	TABLEENTRY(EN_KILLFOCUS),
	TABLEENTRY(EN_CHANGE),
	TABLEENTRY(EN_UPDATE),
	TABLEENTRY(EN_ERRSPACE),
	TABLEENTRY(EN_MAXTEXT),
	TABLEENTRY(EN_HSCROLL),
	TABLEENTRY(EN_VSCROLL),
	TABLEEND
};

static VALUETABLE tblEnterIdle[] =
{
	TABLEENTRY(MSGF_DIALOGBOX),
	TABLEENTRY(MSGF_MENU),
	TABLEEND
};

static VALUETABLE tblDlgCode[] =
{
	TABLEENTRY(DLGC_BUTTON),
	TABLEENTRY(DLGC_DEFPUSHBUTTON),
	TABLEENTRY(DLGC_HASSETSEL),
	TABLEENTRY(DLGC_RADIOBUTTON),
	TABLEENTRY(DLGC_STATIC),
	TABLEENTRY(DLGC_UNDEFPUSHBUTTON),
	TABLEENTRY(DLGC_WANTALLKEYS),
	TABLEENTRY(DLGC_WANTARROWS),
	TABLEENTRY(DLGC_WANTCHARS),
//
// The DLGC_WANTMESSAGE value is the same as DLGC_WANTALLKEYS
//
//	TABLEENTRY(DLGC_WANTMESSAGE),
	TABLEENTRY(DLGC_WANTTAB),
	TABLEEND
};

static VALUETABLE tblMenuFlags[] =
{
	TABLEENTRY(MF_BITMAP),
	TABLEENTRY(MF_CHECKED),
	TABLEENTRY(MF_DISABLED),
	TABLEENTRY(MF_GRAYED),
	TABLEENTRY(MF_HILITE),
	TABLEENTRY(MF_MOUSESELECT),
	TABLEENTRY(MF_OWNERDRAW),
	TABLEENTRY(MF_POPUP),
	TABLEENTRY(MF_SYSMENU),
	TABLEEND
};

static VALUETABLE tblPower[] =
{
	TABLEENTRY(PWR_SUSPENDREQUEST),
	TABLEENTRY(PWR_SUSPENDRESUME),
	TABLEENTRY(PWR_CRITICALRESUME),
	TABLEEND
};

static VALUETABLE tblPowerRet[] =
{
	TABLEENTRY(PWR_OK),
	TABLEENTRY(PWR_FAIL),
	TABLEEND
};

static VALUETABLE tblShowWindow[] =
{
	TABLEENTRY(SW_PARENTCLOSING),
	TABLEENTRY(SW_OTHERZOOM),
	TABLEENTRY(SW_PARENTOPENING),
	TABLEENTRY(SW_OTHERUNZOOM),
	TABLEEND
};

static VALUETABLE tblSizeType[] =
{
	TABLEENTRY(SIZE_MAXIMIZED),
	TABLEENTRY(SIZE_MINIMIZED),
	TABLEENTRY(SIZE_RESTORED),
	TABLEENTRY(SIZE_MAXHIDE),
	TABLEENTRY(SIZE_MAXSHOW),
	TABLEEND
};

static VALUETABLE tblSpoolerStatus[] =
{
	TABLEENTRY(PR_JOBSTATUS),
	TABLEEND
};

static VALUETABLE tblSysCmds[] =
{
	TABLEENTRY(SC_SIZE),
	TABLEENTRY(SC_MOVE),
	TABLEENTRY(SC_MINIMIZE),
	TABLEENTRY(SC_MAXIMIZE),
	TABLEENTRY(SC_NEXTWINDOW),
	TABLEENTRY(SC_PREVWINDOW),
	TABLEENTRY(SC_CLOSE),
	TABLEENTRY(SC_VSCROLL),
	TABLEENTRY(SC_HSCROLL),
	TABLEENTRY(SC_MOUSEMENU),
	TABLEENTRY(SC_KEYMENU),
	TABLEENTRY(SC_ARRANGE),
	TABLEENTRY(SC_RESTORE),
	TABLEENTRY(SC_TASKLIST),
	TABLEENTRY(SC_SCREENSAVE),
	TABLEENTRY(SC_HOTKEY),
	TABLEENTRY(SC_ARRANGE),  // Is this constant obsolete?
	TABLEEND
};

static VALUETABLE tblOwnerDrawCtlType[] =
{
	TABLEENTRY(ODT_MENU),
	TABLEENTRY(ODT_LISTBOX),
	TABLEENTRY(ODT_COMBOBOX),
	TABLEENTRY(ODT_BUTTON),
	TABLEEND
};

static VALUETABLE tblOwnerDrawAction[] =
{
	TABLEENTRY(ODA_DRAWENTIRE),
	TABLEENTRY(ODA_SELECT),
	TABLEENTRY(ODA_FOCUS),
	TABLEEND
};

static VALUETABLE tblOwnerDrawState[] =
{
	TABLEENTRY(ODS_SELECTED),
	TABLEENTRY(ODS_GRAYED),
	TABLEENTRY(ODS_DISABLED),
	TABLEENTRY(ODS_CHECKED),
	TABLEENTRY(ODS_FOCUS),
	TABLEEND
};

static VALUETABLE tblOkCancel[] =
{
	TABLEENTRY(IDOK),
	TABLEENTRY(IDCANCEL),
	TABLEENTRY(IDABORT),
	TABLEENTRY(IDRETRY),
	TABLEENTRY(IDIGNORE),
	TABLEENTRY(IDYES),
	TABLEENTRY(IDNO),
	TABLEEND
};

static VALUETABLE tblNotifyCode[] =
{
	#ifndef DISABLE_WIN95_MESSAGES
	TABLEENTRY(NM_OUTOFMEMORY),
	TABLEENTRY(NM_CLICK),
	TABLEENTRY(NM_DBLCLK),
	TABLEENTRY(NM_RETURN),
	TABLEENTRY(NM_RCLICK),
	TABLEENTRY(NM_RDBLCLK),
	TABLEENTRY(NM_SETFOCUS),
	TABLEENTRY(NM_KILLFOCUS),
	TABLEENTRY(NM_STARTWAIT),
	TABLEENTRY(NM_ENDWAIT),
	TABLEENTRY(NM_BTNCLK),
	TABLEENTRY(LVN_ITEMCHANGING),
	TABLEENTRY(LVN_ITEMCHANGED),
	TABLEENTRY(LVN_INSERTITEM),
	TABLEENTRY(LVN_DELETEITEM),
	TABLEENTRY(LVN_DELETEALLITEMS),
	TABLEENTRY(LVN_BEGINLABELEDIT),
	TABLEENTRY(LVN_ENDLABELEDIT),
	TABLEENTRY(LVN_COLUMNCLICK),
	TABLEENTRY(LVN_BEGINDRAG),
	TABLEENTRY(LVN_ENDDRAG),
	TABLEENTRY(LVN_BEGINRDRAG),
	TABLEENTRY(LVN_ENDRDRAG),
//	TABLEENTRY(LVN_PEN),
	TABLEENTRY(LVN_GETDISPINFO),
	TABLEENTRY(LVN_SETDISPINFO),
	TABLEENTRY(LVN_KEYDOWN),
	TABLEENTRY(HDN_ITEMCHANGING),
	TABLEENTRY(HDN_ITEMCHANGED),
	TABLEENTRY(HDN_ITEMCLICK),
	TABLEENTRY(HDN_ITEMDBLCLICK),
	TABLEENTRY(HDN_DIVIDERDBLCLICK),
	TABLEENTRY(HDN_BEGINTRACK),
	TABLEENTRY(HDN_ENDTRACK),
	TABLEENTRY(HDN_TRACK),
	TABLEENTRY(TVN_SELCHANGING),
	TABLEENTRY(TVN_SELCHANGED),
	TABLEENTRY(TVN_GETDISPINFO),
	TABLEENTRY(TVN_SETDISPINFO),
	TABLEENTRY(TVN_ITEMEXPANDING),
	TABLEENTRY(TVN_ITEMEXPANDED),
	TABLEENTRY(TVN_BEGINDRAG),
	TABLEENTRY(TVN_BEGINRDRAG),
	TABLEENTRY(TVN_DELETEITEM),
	TABLEENTRY(TVN_BEGINLABELEDIT),
	TABLEENTRY(TVN_ENDLABELEDIT),
	TABLEENTRY(TVN_KEYDOWN),
	TABLEENTRY(TTN_NEEDTEXT),
	TABLEENTRY(TTN_SHOW),
	TABLEENTRY(TTN_POP),
	TABLEENTRY(TCN_KEYDOWN),
	TABLEENTRY(TCN_SELCHANGE),
	TABLEENTRY(TCN_SELCHANGING),
	TABLEENTRY(TBN_GETBUTTONINFO),
	TABLEENTRY(TBN_BEGINDRAG),
	TABLEENTRY(TBN_ENDDRAG),
	TABLEENTRY(TBN_BEGINADJUST),
	TABLEENTRY(TBN_ENDADJUST),
	TABLEENTRY(TBN_RESET),
	TABLEENTRY(TBN_QUERYINSERT),
	TABLEENTRY(TBN_QUERYDELETE),
	TABLEENTRY(TBN_TOOLBARCHANGE),
	TABLEENTRY(TBN_CUSTHELP),
	TABLEENTRY(UDN_DELTAPOS),
	TABLEENTRY(ACN_START),
	TABLEENTRY(ACN_STOP),
	#endif
	TABLEENTRY(TB_LINEUP),
	TABLEENTRY(TB_LINEDOWN),
	TABLEENTRY(TB_PAGEUP),
	TABLEENTRY(TB_PAGEDOWN),
	TABLEENTRY(TB_THUMBPOSITION),
	TABLEENTRY(TB_THUMBTRACK),
	TABLEENTRY(TB_TOP),
	TABLEENTRY(TB_BOTTOM),
	TABLEENTRY(TB_ENDTRACK),
	TABLEEND
};

static VALUETABLE tblStyleChange[] =
{
	TABLEENTRY(GWL_EXSTYLE),
	TABLEENTRY(GWL_STYLE),
	TABLEEND
};

#ifndef DISABLE_WIN95_MESSAGES

static VALUETABLE tblSizingFlags[] =
{
	TABLEENTRY(WMSZ_BOTTOM),
	TABLEENTRY(WMSZ_BOTTOMLEFT),
	TABLEENTRY(WMSZ_BOTTOMRIGHT),
	TABLEENTRY(WMSZ_LEFT),
	TABLEENTRY(WMSZ_RIGHT),
	TABLEENTRY(WMSZ_TOP),
	TABLEENTRY(WMSZ_TOPLEFT),
	TABLEENTRY(WMSZ_TOPRIGHT),
	TABLEEND
};

static VALUETABLE tblPrintFlags[] =
{
	TABLEENTRY(PRF_CHECKVISIBLE),
	TABLEENTRY(PRF_CHILDREN),
	TABLEENTRY(PRF_CLIENT),
	TABLEENTRY(PRF_ERASEBKGND),
	TABLEENTRY(PRF_NONCLIENT),
	TABLEENTRY(PRF_OWNED),
	TABLEEND
};

#endif

/*
static VALUETABLE tblDeviceChange[] =
{
	// TODO: activate this table/code for Chicago!
	TABLEENTRY(DBT_DeviceArrival),
	TABLEENTRY(DBT_DeviceQueryRemove),
	TABLEENTRY(DBT_DeviceQueryRemoveFailed),
	TABLEENTRY(DBT_DeviceRemovePending),
	TABLEENTRY(DBT_DeviceRemoveComplete),
	TABLEENTRY(DBT_ConfigChanged),
	TABLEENTRY(DBT_DevnodesChanged),
	TABLEEND
};
*/

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ACTIVATE)
{
	PARM(fActive, UINT, LOWP);
	PARM(fMinimized, BOOL, HIWP);
	PARM(hwnd, HWND, LP);

	TABLEORVALUE(tblActivate, fActive);
	POUTB(fMinimized);
	POUT(hwnd);

	return TRUE;
}

NODECODERET(WM_ACTIVATE);

NODECODEPARM(WM_ACTIVATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ACTIVATEAPP)
{
	PARM(fActive, BOOL, WP);
	PARM(dwThreadID, DWORD, LP);

	POUTB(fActive);
	PLABEL(dwThreadID);
	MOUT << (DWORD)dwThreadID;

	return TRUE;
}

NODECODERET(WM_ACTIVATEAPP);

NODECODEPARM(WM_ACTIVATEAPP);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_CANCELJOURNAL);

NODECODERET(WM_CANCELJOURNAL);

NODECODEPARM(WM_CANCELJOURNAL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_CANCELMODE);

NODECODERET(WM_CANCELMODE);

NODECODEPARM(WM_CANCELMODE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_CLOSE);

NODECODERET(WM_CLOSE);

NODECODEPARM(WM_CLOSE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_COMMAND)
{
	PARM(wNotifyCode, UINT, HIWP);
	PARM(wID, UINT, LOWP);
	PARM(hwndCtl, HWND, LP);

	PLABEL(wNotifyCode);

	//
	// Is this message being sent from a control or from a menu/accelerator?
	//
	if (hwndCtl)
	{
		UINT nClass;

		PIFSIZEOF(PACK_CLASS)
		{
			PARM(ppc, PPACK_CLASS, ED);
			nClass = ppc->nClass;
		}
		else
		{
			nClass = CLS_UNKNOWN;
		}

		switch (nClass)
		{
			case CLS_BUTTON:
				TableOrValue(tblButtonNC, wNotifyCode);
				PLABEL(wID);
				TableOrInt(tblOkCancel, wID);
				break;

			case CLS_COMBOBOX:
				TableOrValue(tblComboboxNC, wNotifyCode);
				POUTC(wID, INT);
				break;

			case CLS_EDIT:
				TableOrValue(tblEditNC, wNotifyCode);
				POUTC(wID, INT);
				break;

			case CLS_LISTBOX:
				TableOrValue(tblListboxNC, wNotifyCode);
				POUTC(wID, INT);
				break;

			default:
				MOUT << (WORD)wNotifyCode;
				POUTC(wID, INT);
				break;
		}

		POUT(hwndCtl);
	}
	else
	{
		switch (wNotifyCode)
		{
			case 0:
				MOUT << '0' << ids(IDS_SENT_FROM_A_MENU);
				break;

			case 1:
				MOUT << '1' << ids(IDS_SENT_FROM_AN_ACCEL);
				break;

			default:
				MOUT << (WORD)wNotifyCode;
				break;
		}

		POUT(wID);
	}

	return TRUE;
}

NODECODERET(WM_COMMAND);

NODECODEPARM(WM_COMMAND);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_COMPACTING)
{
	PARM(wCompactRatio, UINT, WP);

	POUT(wCompactRatio);
	MOUT << " (" << ((100 * wCompactRatio) / 0x10000) << "%)";

	return TRUE;
}

NODECODERET(WM_COMPACTING);

NODECODEPARM(WM_COMPACTING);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_COMPAREITEM)
{
	PARM(idCtl, INT, WP);
	PARM(lpcis, LPCOMPAREITEMSTRUCT, LP);

	POUT(idCtl);
	POUTC(lpcis, DWORD);

	return TRUE;
}

DECODERET(WM_COMPAREITEM)
{
	PARM(fCompare, INT, RET);

	POUT(fCompare);
	switch (fCompare)
	{
		case -1:
			MOUT << ids(IDS_1_PRECEDES_2);
			break;

		case 0:
			MOUT << ids(IDS_1_MATCHES_2);
			break;

		case 1:
			MOUT << ids(IDS_1_FOLLOWS_2);
			break;
	}

	return TRUE;
}

DECODEPARM(WM_COMPAREITEM)
{
	P2WPOUT();

	P2LPOUTPTR(COMPAREITEMSTRUCT);
	P2IFSIZEOF(COMPAREITEMSTRUCT)
	{
		PARM(pcis, LPCOMPAREITEMSTRUCT, ED2);
		INDENT();
		P2TABLEORVALUE(tblOwnerDrawCtlType, pcis, CtlType);
		P2OUT(pcis, CtlID);
		P2OUT(pcis, hwndItem);
		P2OUT(pcis, itemID1);
		P2OUT(pcis, itemData1);
		P2OUT(pcis, itemID2);
		P2OUT(pcis, itemData2);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_COPYDATA)
{
	PARM(hwndFrom, HWND, WP);
	PARM(pcds, PCOPYDATASTRUCT, LP);

	POUT(hwndFrom);
	POUTC(pcds, DWORD);

	return TRUE;
}

DECODERET(WM_COPYDATA)
{
	PARM(fProcessed, BOOL, RET);

	POUTB(fProcessed);

	return TRUE;
}

DECODEPARM(WM_COPYDATA)
{
	P2WPOUT();

	P2LPOUTPTR(COPYDATASTRUCT);
	P2IFSIZEOF(COPYDATASTRUCT)
	{
		PARM(pcds, PCOPYDATASTRUCT, ED2);
		INDENT();
		P2OUT(pcds, dwData);
		P2OUTC(pcds, cbData, UINT);
		P2OUTC(pcds, lpData, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////
/*
// TODO: do some cracking here!
NODECODE(WM_CPL_LAUNCH);

NODECODERET(WM_CPL_LAUNCH);

NODECODEPARM(WM_CPL_LAUNCH);
*/
//////////////////////////////////////////////////////////////////////////////
/*
// TODO: do some cracking here!
NODECODE(WM_CPL_LAUNCHED);

NODECODERET(WM_CPL_LAUNCHED);

NODECODEPARM(WM_CPL_LAUNCHED);
*/
//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CREATE)
{
	PARM(lpcs, LPCREATESTRUCT, LP);

	POUTC(lpcs, DWORD);

	return TRUE;
}

DECODERET(WM_CREATE)
{
	PARM(fContinue, INT, RET);

	//
	// Note the return value is different from WM_NCCREATE.
	//
	POUT(fContinue);
	switch (fContinue)
	{
		case 0:
			MOUT << ids(IDS_CONTINUECREATION);
			break;

		case -1:
			MOUT << ids(IDS_DONTCONTINUECREATION);
			break;
	}

	return TRUE;
}

DECODEPARM(WM_CREATE)
{
	P2WPOUT();

	P2LPOUTPTR(CREATESTRUCT);

	P2IFSIZEOF(PACK_CREATESTRUCT)
	{
		PARM(ppcs, PPACK_CREATESTRUCT, ED2);
		PARM(pcs, LPCREATESTRUCT, &ppcs->cs);

		INDENT();
		P2OUTC(pcs, lpCreateParams, DWORD);
		P2OUTC(pcs, hInstance, DWORD);
		P2OUTC(pcs, hMenu, DWORD);
		P2OUT(pcs, hwndParent);
		P2TABLEORINT(tblCreateWindowPos, pcs, cy);
		P2TABLEORINT(tblCreateWindowPos, pcs, cx);
		P2TABLEORINT(tblCreateWindowPos, pcs, y);
		P2TABLEORINT(tblCreateWindowPos, pcs, x);
		P2TABLEFLAGS(tblWindowStyles, pcs, style);

		if (ppcs->fValidName)
		{
			PARM(pszName, LPSTR, ppcs->szName);
			P2OUTPTRSTR(pcs, lpszName);
			INDENT();
			P2OUTS(pszName);
			OUTDENT();
		}
		else
		{
			P2OUTC(pcs, lpszName, DWORD);
		}

		if (ppcs->fValidClass)
		{
			PARM(pszClass, LPSTR, ppcs->szClass);
			P2OUTPTRSTR(pcs, lpszClass);
			INDENT();
			P2OUTS(pszClass);
			OUTDENT();
		}
		else
		{
			CHAR szClass[50];

			if (GetClipboardFormatName((UINT)pcs->lpszClass, szClass,
				sizeof(szClass) / sizeof(CHAR)))
			{
				P2LABEL(lpszClass);
				M2OUT << (DWORD)pcs->lpszClass << " (Class: \""
					<< szClass << "\")";
				P2ENDLINE();
			}
			else
			{
				P2OUTC(pcs, lpszClass, DWORD);
			}
		}

		P2TABLEFLAGS(tblExtWindowStyles, pcs, dwExStyle);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CTLCOLORBTN)
{
	PARM(hdcButton, HDC, WP);
	PARM(hwndButton, HWND, LP);

	POUTC(hdcButton, DWORD);
	POUT(hwndButton);

	return TRUE;
}

DECODERET(WM_CTLCOLORBTN)
{
	PARM(hBrush, HBRUSH, RET);

	POUTC(hBrush, DWORD);

	return TRUE;
}

NODECODEPARM(WM_CTLCOLORBTN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CTLCOLORDLG)
{
	PARM(hdcDlg, HDC, WP);
	PARM(hwndDlg, HWND, LP);

	POUTC(hdcDlg, DWORD);
	POUT(hwndDlg);

	return TRUE;
}

DECODERET(WM_CTLCOLORDLG)
{
	DECODERETLIKE(WM_CTLCOLORBTN);
}

NODECODEPARM(WM_CTLCOLORDLG);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CTLCOLOREDIT)
{
	PARM(hdcEdit, HDC, WP);
	PARM(hwndEdit, HWND, LP);

	POUTC(hdcEdit, DWORD);
	POUT(hwndEdit);

	return TRUE;
}

DECODERET(WM_CTLCOLOREDIT)
{
	DECODERETLIKE(WM_CTLCOLORBTN);
}

NODECODEPARM(WM_CTLCOLOREDIT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CTLCOLORLISTBOX)
{
	PARM(hdcLB, HDC, WP);
	PARM(hwndLB, HWND, LP);

	POUTC(hdcLB, DWORD);
	POUT(hwndLB);

	return TRUE;
}

DECODERET(WM_CTLCOLORLISTBOX)
{
	DECODERETLIKE(WM_CTLCOLORBTN);
}

NODECODEPARM(WM_CTLCOLORLISTBOX);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CTLCOLORMSGBOX)
{
	PARM(hdcMB, HDC, WP);
	PARM(hwndMB, HWND, LP);

	POUTC(hdcMB, DWORD);
	POUT(hwndMB);

	return TRUE;
}

DECODERET(WM_CTLCOLORMSGBOX)
{
	DECODERETLIKE(WM_CTLCOLORBTN);
}

NODECODEPARM(WM_CTLCOLORMSGBOX);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CTLCOLORSCROLLBAR)
{
	PARM(hdcSB, HDC, WP);
	PARM(hwndSB, HWND, LP);

	POUTC(hdcSB, DWORD);
	POUT(hwndSB);

	return TRUE;
}

DECODERET(WM_CTLCOLORSCROLLBAR)
{
	DECODERETLIKE(WM_CTLCOLORBTN);
}

NODECODEPARM(WM_CTLCOLORSCROLLBAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CTLCOLORSTATIC)
{
	PARM(hdcStatic, HDC, WP);
	PARM(hwndStatic, HWND, LP);

	POUTC(hdcStatic, DWORD);
	POUT(hwndStatic);

	return TRUE;
}

DECODERET(WM_CTLCOLORSTATIC)
{
	DECODERETLIKE(WM_CTLCOLORBTN);
}

NODECODEPARM(WM_CTLCOLORSTATIC);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DELETEITEM)
{
	PARM(idCtl, UINT, WP);
	PARM(lpdis, LPDELETEITEMSTRUCT, LP);

	POUT(idCtl);
	POUTC(lpdis, DWORD);

	return TRUE;
}

NODECODERET(WM_DELETEITEM);

DECODEPARM(WM_DELETEITEM)
{
	P2WPOUT();

	P2LPOUTPTR(DELETEITEMSTRUCT);
	P2IFSIZEOF(DELETEITEMSTRUCT)
	{
		PARM(pdis, LPDELETEITEMSTRUCT, ED2);
		INDENT();
		P2TABLEORVALUE(tblOwnerDrawCtlType, pdis, CtlType);
		P2OUT(pdis, CtlID);
		P2OUT(pdis, itemID);
		P2OUT(pdis, hwndItem);
		P2OUTC(pdis, itemData, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_DESTROY);

NODECODERET(WM_DESTROY);

NODECODEPARM(WM_DESTROY);

//////////////////////////////////////////////////////////////////////////////
/*
// TODO: activate this table/code for Chicago!
DECODE(WM_DEVICECHANGE)
{
	PARM(wParam, WPARAM, WP);

	PLABEL(wParam);

	TableOrValue(tblDeviceChange, wNotifyCode);
}

// TODO: activate this table/code for Chicago!
NODECODERET(WM_DEVICECHANGE);

// TODO: activate this table/code for Chicago!
NODECODEPARM(WM_DEVICECHANGE);
*/
//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DEVMODECHANGE)
{
	PARM(lpszDev, LPCTSTR, LP);

	POUTC(lpszDev, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

NODECODERET(WM_DEVMODECHANGE);

DECODEPARM(WM_DEVMODECHANGE)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DRAWITEM)
{
	PARM(idCtl, UINT, WP);
	PARM(lpdis, LPDRAWITEMSTRUCT, LP);

	POUT(idCtl);
	POUTC(lpdis, DWORD);

	return TRUE;
}

DECODERET(WM_DRAWITEM)
{
	PARM(fProcessed, BOOL, RET);

	POUTB(fProcessed);

	return TRUE;
}

DECODEPARM(WM_DRAWITEM)
{
	P2WPOUT();

	P2LPOUTPTR(DRAWITEMSTRUCT);
	P2IFSIZEOF(DRAWITEMSTRUCT)
	{
		PARM(pdis, LPDRAWITEMSTRUCT, ED2);
		INDENT();
		P2TABLEORVALUE(tblOwnerDrawCtlType, pdis, CtlType);
		P2OUT(pdis, CtlID);
		P2OUT(pdis, itemID);
		P2TABLEORVALUE(tblOwnerDrawAction, pdis, itemAction);
		P2TABLEORVALUE(tblOwnerDrawState, pdis, itemState);
		P2OUT(pdis, hwndItem);
		P2OUTC(pdis, hDC, DWORD);
		P2OUTRECT(pdis, rcItem);
		P2OUTC(pdis, itemData, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DROPFILES)
{
	PARM(hDrop, HANDLE, WP);

	POUTC(hDrop, DWORD);

	return TRUE;
}

NODECODERET(WM_DROPFILES);

NODECODEPARM(WM_DROPFILES);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ENABLE)
{
	PARM(fEnable, BOOL, WP);

	POUTB(fEnable);

	return TRUE;
}

NODECODERET(WM_ENABLE);

NODECODEPARM(WM_ENABLE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ENDSESSION)
{
	PARM(fEndSession, BOOL, WP);

	POUTB(fEndSession);

	return TRUE;
}

NODECODERET(WM_ENDSESSION);

NODECODEPARM(WM_ENDSESSION);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ENTERIDLE)
{
	PARM(fuSource, UINT, WP);
	PARM(hwnd, HWND, LP);

	TABLEORVALUE(tblEnterIdle, fuSource);
	POUT(hwnd);

	return TRUE;
}

NODECODERET(WM_ENTERIDLE);

NODECODEPARM(WM_ENTERIDLE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ENTERMENULOOP)
{
	PARM(fIsTrackPopupMenu, BOOL, WP);

	POUTB(fIsTrackPopupMenu);

	return TRUE;
}

NODECODERET(WM_ENTERMENULOOP);

NODECODEPARM(WM_ENTERMENULOOP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_EXITMENULOOP)
{
	DECODELIKE(WM_ENTERMENULOOP);
}

NODECODERET(WM_EXITMENULOOP);

NODECODEPARM(WM_EXITMENULOOP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ERASEBKGND)
{
	PARM(hdc, HDC, WP);

	POUTC(hdc, DWORD);

	return TRUE;
}

DECODERET(WM_ERASEBKGND)
{
	PARM(fErased, BOOL, RET);

	POUTB(fErased);

	return TRUE;
}

NODECODEPARM(WM_ERASEBKGND);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_FONTCHANGE);

NODECODERET(WM_FONTCHANGE);

NODECODEPARM(WM_FONTCHANGE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_GETDLGCODE);

DECODERET(WM_GETDLGCODE)
{
	PARM(fuDlgCode, UINT, RET);

	TABLEFLAGS(tblDlgCode, fuDlgCode);

	return TRUE;
}

NODECODEPARM(WM_GETDLGCODE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_GETFONT);

DECODERET(WM_GETFONT)
{
	PARM(hfont, HFONT, RET);

	POUTC(hfont, DWORD);
	if (hfont)
	{
		PIFSIZEOF(PACK_FONT)
		{
			PARM(ppf, PPACK_FONT, ED);

			PrintFont(ppf);
		}
	}
	else
	{
		MOUT << ids(IDS_SYSTEM_FONT);
	}

	return TRUE;
}

NODECODEPARM(WM_GETFONT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_GETMINMAXINFO)
{
	PARM(lpmmi, LPMINMAXINFO, LP);

	POUTC(lpmmi, DWORD);

	return TRUE;
}

DECODERET(WM_GETMINMAXINFO)
{
	PARM(lpmmi, LPMINMAXINFO, LP);

	POUTC(lpmmi, DWORD);

	return TRUE;
}

DECODEPARM(WM_GETMINMAXINFO)
{
	P2WPOUT();

	P2LPOUTPTR(MINMAXINFO);
	P2IFSIZEOF(MINMAXINFO)
	{
		PARM(pmmi, LPMINMAXINFO, ED2);
		INDENT();
		P2OUTPT(pmmi, ptReserved);
		P2OUTPT(pmmi, ptMaxSize);
		P2OUTPT(pmmi, ptMaxPosition);
		P2OUTPT(pmmi, ptMinTrackSize);
		P2OUTPT(pmmi, ptMaxTrackSize);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_GETTEXT)
{
	PARM(cchTextMax, INT, WP);
	PARM(lpszText, LPSTR, LP);

	POUT(cchTextMax);
	POUTC(lpszText, DWORD);

	return TRUE;
}

DECODERET(WM_GETTEXT)
{
	PARM(cchCopied, INT, RET);
	PARM(lpszText, LPSTR, LP);

	POUT(cchCopied);
	POUTC(lpszText, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		// REVIEW: is this the way to check for ordinal returned?  assuming that if
		// an ordinal is returned in lParam here--four bytes with no NULL?
		if (cchCopied == 4 && *(pstr + 4) != 0)
		{
			POUTC(pstr, DWORD);
		}
		else
		{
			POUTS(pstr);
		}
	}

	return TRUE;
}

DECODEPARM(WM_GETTEXT)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_GETTEXTLENGTH);

DECODERET(WM_GETTEXTLENGTH)
{
	PARM(cch, INT, RET);

	POUT(cch);

	return TRUE;
}

NODECODEPARM(WM_GETTEXTLENGTH);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_HSCROLL)
{
	PARM(fuScrollCode, UINT, LOWP);
	PARM(nPos, INT, (short)HIWP);
	PARM(hwndScrollBar, HWND, LP);

	TABLEORVALUE(tblHScroll, fuScrollCode);

	switch (fuScrollCode)
	{
		case SB_THUMBPOSITION:
		case SB_THUMBTRACK:
			POUT(nPos);
			break;
	}

	POUT(hwndScrollBar);

	return TRUE;
}

NODECODERET(WM_HSCROLL);

NODECODEPARM(WM_HSCROLL);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ICONERASEBKGND)
{
	PARM(hdc, HDC, WP);

	POUTC(hdc, DWORD);

	return TRUE;
}

NODECODERET(WM_ICONERASEBKGND);

NODECODEPARM(WM_ICONERASEBKGND);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_INITDIALOG)
{
	PARM(hwndFocus, HWND, WP);
	PARM(lInitParam, DWORD, LP);

	POUT(hwndFocus);
	POUT(lInitParam);

	return TRUE;
}

DECODERET(WM_INITDIALOG)
{
	PARM(fSetFocus, BOOL, RET);

	POUTB(fSetFocus);

	return TRUE;
}

NODECODEPARM(WM_INITDIALOG);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_INITMENU)
{
	PARM(hmenuInit, HMENU, WP);

	POUTC(hmenuInit, DWORD);

	return TRUE;
}

NODECODERET(WM_INITMENU);

NODECODEPARM(WM_INITMENU);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_INITMENUPOPUP)
{
	PARM(hmenuPopup, HMENU, WP);
	PARM(uPos, UINT, LOLP);
	PARM(fSystemMenu, BOOL, HILP);

	POUTC(hmenuPopup, DWORD);
	POUT(uPos);
	POUTB(fSystemMenu);

	return TRUE;
}

NODECODERET(WM_INITMENUPOPUP);

NODECODEPARM(WM_INITMENUPOPUP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_KILLFOCUS)
{
	PARM(hwndGetFocus, HWND, WP);

	POUT(hwndGetFocus);

	return TRUE;
}

NODECODERET(WM_KILLFOCUS);

NODECODEPARM(WM_KILLFOCUS);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MEASUREITEM)
{
	PARM(idCtl, UINT, WP);
	PARM(lpmis, LPMEASUREITEMSTRUCT, LP);

	POUT(idCtl);
	POUTC(lpmis, DWORD);

	return TRUE;
}

DECODERET(WM_MEASUREITEM)
{
	PARM(fProcessed, BOOL, RET);

	POUTB(fProcessed);

	return TRUE;
}

DECODEPARM(WM_MEASUREITEM)
{
	P2WPOUT();

	P2LPOUTPTR(MEASUREITEMSTRUCT);
	P2IFSIZEOF(MEASUREITEMSTRUCT)
	{
		PARM(pmis, LPMEASUREITEMSTRUCT, ED2);
		INDENT();
		P2TABLEORVALUE(tblOwnerDrawCtlType, pmis, CtlType);
		P2OUT(pmis, CtlID);
		P2OUT(pmis, itemID);
		P2OUT(pmis, itemWidth);
		P2OUT(pmis, itemHeight);
		P2OUTC(pmis, itemData, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MENUCHAR)
{
	PARM(chUser, CHAR, LOWP);
	PARM(fuFlag, UINT, HIWP);
	PARM(hmenu, HMENU, LP);

	MOUT << " chUser:'" << chUser
		<< "' (" << (INT)(UCHAR)chUser << ')';
	TABLEORVALUE(tblMenuFlags, fuFlag);
	POUTC(hmenu, DWORD);

	return TRUE;
}

DECODERET(WM_MENUCHAR)
{
	PARM(fAction, UINT, HIRET);
	PARM(nPos, UINT, LORET);

	POUT(fAction);
	switch (fAction)
	{
		case 0:
			MOUT << ids(IDS_DISCARD_CHAR_AND_BEEP);
			break;

		case 1:
			MOUT << ids(IDS_CLOSE_ACTIVE_MENU);
			break;

		case 2:
			MOUT << ids(IDS_SELECT_MENU_ITEM) << nPos << ')';
			break;
	}

	return TRUE;
}

NODECODEPARM(WM_MENUCHAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MENUSELECT)
{
	PARM(uItem, UINT, LOWP);
	PARM(fuFlags, UINT, HIWP);
	PARM(hmenu, HMENU, LP);

	POUT(uItem);
	PLABEL(fuFlags);
	if (fuFlags == 0xFFFF && hmenu == 0)
	{
		MOUT << "FFFF" << ids(IDS_MENU_WAS_CLOSED);
	}
	else
	{
		TableFlags(tblMenuFlags, fuFlags);
	}

	POUTC(hmenu, DWORD);

	return TRUE;
}

NODECODERET(WM_MENUSELECT);

NODECODEPARM(WM_MENUSELECT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MOVE)
{
	PARM(xPos, INT, LOLP);
	PARM(yPos, INT, HILP);

	POUT(xPos);
	POUT(yPos);

	return TRUE;
}

NODECODERET(WM_MOVE);

NODECODEPARM(WM_MOVE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NEXTDLGCTL)
{
	PARM(wCtlFocus, DWORD, WP);
	PARM(fHandle, BOOL, LOLP);

	if (fHandle)
	{
		POUTC(wCtlFocus, HWND);
		MOUT << ids(IDS_HANDLE_CONTROL_FOCUS);
	}
	else
	{
		POUT(wCtlFocus);
		if (wCtlFocus)
		{
			MOUT << ids(IDS_PREV_RECEIVES_FOCUS);
		}
		else
		{
			MOUT << ids(IDS_NEXT_RECEIVES_FOCUS);
		}
	}

	POUTB(fHandle);

	return TRUE;
}

NODECODERET(WM_NEXTDLGCTL);

NODECODEPARM(WM_NEXTDLGCTL);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NOTIFY)
{
	PARM(idCtrl, UINT, WP);
	PARM(pnmh, NMHDR FAR *, LP);

	POUT(idCtrl);
	POUTC(pnmh, DWORD);

	return TRUE;
}

NODECODERET(WM_NOTIFY);

DECODEPARM(WM_NOTIFY)
{
	P2WPOUT();

	P2LPOUTPTR(NMHDR);
	P2IFSIZEOF(NMHDR)
	{
		PARM(pnmh, NMHDR FAR *, ED2);
		INDENT();
		P2OUT(pnmh, hwndFrom);
		P2OUT(pnmh, idFrom);
		P2TABLEORVALUE(tblNotifyCode, pnmh, code);
	}
}

//////////////////////////////////////////////////////////////////////////////
NODECODE(WM_NULL);

NODECODERET(WM_NULL);

NODECODEPARM(WM_NULL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_PAINT);

NODECODERET(WM_PAINT);

NODECODEPARM(WM_PAINT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_PAINTICON);

NODECODERET(WM_PAINTICON);

NODECODEPARM(WM_PAINTICON);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_PALETTECHANGED)
{
	PARM(hwndPalChg, HWND, WP);

	POUT(hwndPalChg);

	return TRUE;
}

NODECODERET(WM_PALETTECHANGED);

NODECODEPARM(WM_PALETTECHANGED);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_PALETTEISCHANGING)
{
	PARM(hwndRealize, HWND, WP);

	POUT(hwndRealize);

	return TRUE;
}

NODECODERET(WM_PALETTEISCHANGING);

NODECODEPARM(WM_PALETTEISCHANGING);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_POWER)
{
	PARM(fwPowerEvt, UINT, WP);

	TABLEORVALUE(tblPower, fwPowerEvt);

	return TRUE;
}

DECODERET(WM_POWER)
{
	PARM(lResult, UINT, RET);

	TABLEORVALUE(tblPowerRet, lResult);

	return TRUE;
}

NODECODEPARM(WM_POWER);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_QUERYDRAGICON);

DECODERET(WM_QUERYDRAGICON)
{
	PARM(hcur, HCURSOR, RET);

	POUTC(hcur, DWORD);
	if (!hcur)
	{
		MOUT << ids(IDS_USE_DEFAULT_CURSOR);
	}

	return TRUE;
}

NODECODEPARM(WM_QUERYDRAGICON);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_QUERYENDSESSION)
{
	PARM(nSource, UINT, WP);

	POUT(nSource);
	if (nSource)
	{
		MOUT << ids(IDS_END_FROM_TASK_LIST);
	}
	else
	{
		MOUT << ids(IDS_LOGOFF_OR_SHUTDOWN);
	}

	return TRUE;
}

DECODERET(WM_QUERYENDSESSION)
{
	PARM(fShutdownIsOk, BOOL, RET);

	POUTB(fShutdownIsOk);

	return TRUE;
}

NODECODEPARM(WM_QUERYENDSESSION);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_QUERYNEWPALETTE);

DECODERET(WM_QUERYNEWPALETTE)
{
	PARM(fLogicalPalRealized, BOOL, RET);

	POUTB(fLogicalPalRealized);

	return TRUE;
}

NODECODEPARM(WM_QUERYNEWPALETTE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_QUERYOPEN);

DECODERET(WM_QUERYOPEN)
{
	PARM(fOpenIsOk, BOOL, RET);

	POUTB(fOpenIsOk);

	return TRUE;
}

NODECODEPARM(WM_QUERYOPEN);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_QUEUESYNC);

NODECODERET(WM_QUEUESYNC);

NODECODEPARM(WM_QUEUESYNC);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_QUIT)
{
	PARM(nExitCode, INT, WP);

	POUT(nExitCode);

	return TRUE;
}

NODECODERET(WM_QUIT);

NODECODEPARM(WM_QUIT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SETFOCUS)
{
	PARM(hwndLoseFocus, HWND, WP);

	POUT(hwndLoseFocus);

	return TRUE;
}

NODECODERET(WM_SETFOCUS);

NODECODEPARM(WM_SETFOCUS);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SETFONT)
{
	PARM(hfont, HFONT, WP);
	PARM(fRedraw, BOOL, LP);

	POUTC(hfont, DWORD);
	if (hfont)
	{
		PIFSIZEOF(PACK_FONT)
		{
			PARM(ppf, PPACK_FONT, ED);

			PrintFont(ppf);
		}
	}
	else
	{
		MOUT << ids(IDS_USE_DEFAULT_FONT);
	}

	POUTB(fRedraw);

	return TRUE;
}

NODECODERET(WM_SETFONT);

NODECODEPARM(WM_SETFONT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SETREDRAW)
{
	PARM(fRedraw, BOOL, WP);

	POUTB(fRedraw);

	return TRUE;
}

NODECODERET(WM_SETREDRAW);

NODECODEPARM(WM_SETREDRAW);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SETTEXT)
{
	PARM(lpsz, LPCTSTR, LP);

	POUTC(lpsz, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(WM_SETTEXT)
{
	PARM(fSuccess, INT, RET);

	CHAR szClass[64];
	GetClassName(pmsd->hwnd, szClass, sizeof(szClass));

	if (!_tcsicmp(szClass, "COMBOBOX"))
	{
		if (fSuccess < 0)
		{
			TABLEORINT(tblCBRet, fSuccess);
		}
		else
		{
			TABLEORINT(tblTrueFalse, fSuccess);
		}
	}
	else if (!_tcsicmp(szClass, "LISTBOX"))
	{
		if (fSuccess < 0)
		{
			TABLEORINT(tblLBRet, fSuccess);
		}
		else
		{
			TABLEORINT(tblTrueFalse, fSuccess);
		}
	}
	else
		TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(WM_SETTEXT)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SHOWWINDOW)
{
	PARM(fShow, BOOL, WP);
	PARM(fuStatus, UINT, LP);

	POUTB(fShow);

	PLABEL(fuStatus);
	if (fuStatus == 0)
	{
		MOUT << '0' << ids(IDS_SHOWWINDOW_CALLED);
	}
	else
	{
		TableOrValue(tblShowWindow, fuStatus);
	}

	return TRUE;
}

NODECODERET(WM_SHOWWINDOW);

NODECODEPARM(WM_SHOWWINDOW);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SIZE)
{
	PARM(fwSizeType, UINT, WP);
	PARM(nWidth, UINT, LOLP);
	PARM(nHeight, UINT, HILP);

	TABLEORVALUE(tblSizeType, fwSizeType);
	POUTC(nWidth, INT);
	POUTC(nHeight, INT);

	return TRUE;
}

NODECODERET(WM_SIZE);

NODECODEPARM(WM_SIZE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SPOOLERSTATUS)
{
	PARM(fwJobStatus, UINT, WP);
	PARM(cJobsLeft, UINT, LOLP);

	TABLEORVALUE(tblSpoolerStatus, fwJobStatus);
	POUTC(cJobsLeft, INT);

	return TRUE;
}

NODECODERET(WM_SPOOLERSTATUS);

NODECODEPARM(WM_SPOOLERSTATUS);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_SYSCOLORCHANGE);

NODECODERET(WM_SYSCOLORCHANGE);

NODECODEPARM(WM_SYSCOLORCHANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SYSCOMMAND)
{
	PARM(uCmdType, UINT, WP);
	PARM(xPos, UINT, LOLP);
	PARM(yPos, UINT, HILP);

	PLABEL(uCmdType);
	TableOrValue(tblSysCmds, uCmdType & 0xFFF0);
	POUTC(xPos, INT);
	POUTC(yPos, INT);

	return TRUE;
}

NODECODERET(WM_SYSCOMMAND);

NODECODEPARM(WM_SYSCOMMAND);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_TIMECHANGE);

NODECODERET(WM_TIMECHANGE);

NODECODEPARM(WM_TIMECHANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_TIMER)
{
	PARM(wTimerID, INT, WP);
//
// This message should never be seen by the app if tmprc is not
// NULL, so there is no reason to decode it...
//
//	PARM(tmprc, DWORD, LP);

	POUT(wTimerID);

	return TRUE;
}

NODECODERET(WM_TIMER);

NODECODEPARM(WM_TIMER);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_VSCROLL)
{
	PARM(fuScrollCode, UINT, LOWP);
	PARM(nPos, INT, (short)HIWP);
	PARM(hwndScrollBar, HWND, LP);

	TABLEORVALUE(tblVScroll, fuScrollCode);

	switch (fuScrollCode)
	{
		case SB_THUMBPOSITION:
		case SB_THUMBTRACK:
			POUT(nPos);
			break;
	}

	POUT(hwndScrollBar);

	return TRUE;
}

NODECODERET(WM_VSCROLL);

NODECODEPARM(WM_VSCROLL);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_WINDOWPOSCHANGED)
{
	PARM(lpwp, LPWINDOWPOS, LP);

	POUTC(lpwp, DWORD);

	return TRUE;
}

NODECODERET(WM_WINDOWPOSCHANGED);

DECODEPARM(WM_WINDOWPOSCHANGED)
{
	P2WPOUT();

	P2LPOUTPTR(WINDOWPOS);
	P2IFSIZEOF(WINDOWPOS)
	{
		PARM(pwp, LPWINDOWPOS, ED2);
		INDENT();
		P2OUT(pwp, hwnd);
		P2OUT(pwp, hwndInsertAfter);
		P2OUT(pwp, x);
		P2OUT(pwp, y);
		P2OUT(pwp, cx);
		P2OUT(pwp, cy);
		P2TABLEFLAGS(tblWindowPos, pwp, flags);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_WINDOWPOSCHANGING)
{
	DECODELIKE(WM_WINDOWPOSCHANGED);
}

NODECODERET(WM_WINDOWPOSCHANGING);

DECODEPARM(WM_WINDOWPOSCHANGING)
{
	DECODEPARMLIKE(WM_WINDOWPOSCHANGED);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_WININICHANGE)
{
	PARM(pszSection, LPCTSTR, LP);

	POUTC(pszSection, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

NODECODERET(WM_WININICHANGE);

DECODEPARM(WM_WININICHANGE)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_INPUTLANGCHANGEREQUEST)
{
	PARM(fSysCharset, BOOL, WP);
	PARM(hkl, HKL, LP);

	POUTB(fSysCharset);
	POUTC(hkl, DWORD);

	return TRUE;
}

NODECODERET(WM_INPUTLANGCHANGEREQUEST);

NODECODEPARM(WM_INPUTLANGCHANGEREQUEST);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_INPUTLANGCHANGE)
{
	PARM(charset, WPARAM, WP);
	PARM(hkl, HKL, LP);

	POUT(charset);
	POUTC(hkl, DWORD);

	return TRUE;
}

NODECODERET(WM_INPUTLANGCHANGE);

NODECODEPARM(WM_INPUTLANGCHANGE);

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_TCARD);

NODECODERET(WM_TCARD);

NODECODEPARM(WM_TCARD);

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_HELP);

NODECODERET(WM_HELP);

NODECODEPARM(WM_HELP);

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_USERCHANGED);

NODECODERET(WM_USERCHANGED);

NODECODEPARM(WM_USERCHANGED);

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_NOTIFYFORMAT);

NODECODERET(WM_NOTIFYFORMAT);

NODECODEPARM(WM_NOTIFYFORMAT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CONTEXTMENU)
{
	PARM(hwnd, HWND, WP);
	PARM(xPos, WORD, LOLP);
	PARM(yPos, WORD, HILP);

	POUTC(hwnd, DWORD);
	POUTC(xPos, UINT);
	POUTC(yPos, UINT);

	return TRUE;
}

NODECODERET(WM_CONTEXTMENU);

NODECODEPARM(WM_CONTEXTMENU);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_STYLECHANGING)
{
	PARM(wStyleType, WPARAM, WP);
	PARM(lpss, DWORD, LP);

	TABLEFLAGS(tblStyleChange, wStyleType);
	POUTC(lpss, DWORD);

	return TRUE;
}

NODECODERET(WM_STYLECHANGING);

DECODEPARM(WM_STYLECHANGING)
{
	P2WPOUT();

#ifndef DISABLE_WIN95_MESSAGES
	P2LPOUTPTR(STYLESTRUCT);
	P2IFSIZEOF(STYLESTRUCT)
	{
		PARM(lpss, LPSTYLESTRUCT, ED2);
		INDENT();
		P2TABLEFLAGS(tblWindowStyles, lpss, styleOld);
		P2TABLEFLAGS(tblWindowStyles, lpss, styleNew);
	}
#endif
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_STYLECHANGED)
{
	DECODELIKE(WM_STYLECHANGING);
}

DECODERET(WM_STYLECHANGED)
{
	DECODERETLIKE(WM_STYLECHANGING);
}

DECODEPARM(WM_STYLECHANGED)
{
	DECODEPARMLIKE(WM_STYLECHANGING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DISPLAYCHANGE)
{
	PARM(fChanged, BOOL, WP);
	PARM(cxScreen, WORD, LOLP);
	PARM(cyScreen, WORD, HILP);

	POUTB(fChanged);
	POUTC(cxScreen, UINT);
	POUTC(cyScreen, UINT);

	return TRUE;
}

NODECODERET(WM_DISPLAYCHANGE);

NODECODEPARM(WM_DISPLAYCHANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_GETICON)
{
	PARM(fType, BOOL, WP);

	POUTB(fType);

	return TRUE;
}

DECODERET(WM_GETICON)
{
	PARM(hicon, HANDLE, RET);

	POUTC(hicon, DWORD);

	return TRUE;
}

NODECODEPARM(WM_GETICON);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SETICON)
{
	PARM(fType, BOOL, WP);
	PARM(hicon, HANDLE, LP);

	POUTB(fType);
	POUTC(hicon, DWORD);

	return TRUE;
}

DECODERET(WM_SETICON)
{
	PARM(hPrevIcon, HANDLE, RET);

	POUTC(hPrevIcon, DWORD);

	return TRUE;
}

NODECODEPARM(WM_SETICON);

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_NEXTMENU);

NODECODERET(WM_NEXTMENU);

NODECODEPARM(WM_NEXTMENU);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SIZING)
{
	PARM(fwSide, WPARAM, WP);
	PARM(lprc, LPRECT, LP);

#ifndef DISABLE_WIN95_MESSAGES
	TABLEFLAGS(tblSizingFlags, fwSide);
#endif
	POUTC(lprc, DWORD);

	return TRUE;
}

NODECODERET(WM_SIZING);

DECODEPARM(WM_SIZING)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(lprc, LPRECT, ED2);
		INDENT();
		P2OUT(lprc, top);
		P2OUT(lprc, bottom);
		P2OUT(lprc, left);
		P2OUT(lprc, right);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CAPTURECHANGED)
{
	PARM(hwndNewCapture, HWND, LP);

	POUTC(hwndNewCapture, DWORD);

	return TRUE;
}

NODECODERET(WM_CAPTURECHANGED);

NODECODEPARM(WM_CAPTURECHANGED);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MOVING)
{
	DECODELIKE(WM_SIZING);
}

DECODERET(WM_MOVING)
{
	DECODERETLIKE(WM_SIZING);
}

DECODEPARM(WM_MOVING)
{
	DECODEPARMLIKE(WM_SIZING);
}

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_POWERBROADCAST);

NODECODERET(WM_POWERBROADCAST);

NODECODEPARM(WM_POWERBROADCAST);

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_DEVICECHANGE);

NODECODERET(WM_DEVICECHANGE);

NODECODEPARM(WM_DEVICECHANGE);

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_SETTINGCHANGE);

NODECODERET(WM_SETTINGCHANGE);

NODECODEPARM(WM_SETTINGCHANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_PRINT)
{
	PARM(hdc, HDC, WP);
	PARM(uFlags, LPARAM, LP);

	POUTC(hdc, DWORD);
#ifndef DISABLE_WIN95_MESSAGES
	TABLEFLAGS(tblPrintFlags, uFlags);
#endif
	return TRUE;
}

NODECODERET(WM_PRINT);

NODECODEPARM(WM_PRINT);

//////////////////////////////////////////////////////////////////////////////
// TODO: find information about this message
NODECODE(WM_PRINTCLIENT);

NODECODERET(WM_PRINTCLIENT);

NODECODEPARM(WM_PRINTCLIENT);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\wndtreed.h ===
// wndtreed.h : header file
//

#define SRCHFLAG_WINDOW_USEHANDLE	0x01
#define SRCHFLAG_WINDOW_USECAPTION	0x02
#define SRCHFLAG_WINDOW_USECLASS	0x04

/////////////////////////////////////////////////////////////////////////////
// CWndTreeDoc document

class CWndTreeDoc : public CSpyTreeDoc
{
	DECLARE_DYNCREATE(CWndTreeDoc);

protected:
	CWndTreeDoc();		  // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Implementation
protected:
	// data variables use in searching
	WORD 	m_wSearchFlags;
	HWND	m_hwndWnd;
	CString	m_strCaption;
	CString m_strClass;
	BOOL	m_fSearchUp;	// TRUE if searching up, FALSE if searching down (from dialog)

	virtual void InitializeData();
	virtual void SetSearchMenuText(CCmdUI *pCmdUI);
	virtual BOOL DoFind();
	virtual BOOL DoFindNext();
	virtual BOOL DoFindPrev();
	virtual BOOL HasValidFind();
	virtual BOOL FindFirstMatchingNode();
	virtual BOOL FindNextMatchingNode();
	virtual BOOL FindPreviousMatchingNode();
	virtual BOOL FindLastMatchingNode();
	virtual BOOL FindNodeRecurse(CWndTreeNode *pcwtn, CObList &listExpand, BOOL fSearchingUp = FALSE);
	virtual BOOL CompareNode(CWndTreeNode *pcwtn);
	virtual BOOL ExpandFirstLine()
	{
		//
		// Yes, we want to expand the first line in the new view.
		// It is not very useful to just see one line (the desktop
		// window) in the initial view.
		//
		return TRUE;
	}

	virtual BOOL SortLines()
	{
		//
		// Do NOT sort lines as they are added.  Windows are
		// enumerated in a specific order that must be preserved
		// for the tree to be useful.
		//
		return FALSE;
	}

	virtual ~CWndTreeDoc();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWndTreeDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\compitem.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * COMPITEM.H
 */

/* handle to a CompItem */
typedef struct compitem FAR* COMPITEM;


COMPITEM compitem_new(DIRITEM left, DIRITEM right, LIST list, BOOL fExact);
void compitem_delete(COMPITEM item);
LIST compitem_getcomposite(COMPITEM item);
void compitem_discardsections(COMPITEM item);
LIST compitem_getleftsections(COMPITEM item);
LIST compitem_getrightsections(COMPITEM item);
FILEDATA compitem_getleftfile(COMPITEM item);
FILEDATA compitem_getrightfile(COMPITEM item);
int compitem_getstate(COMPITEM item);
LPSTR compitem_gettext_tag(COMPITEM item);
LPSTR compitem_gettext_result(COMPITEM item);
LPSTR compitem_getfilename(COMPITEM item, int option);
void compitem_freefilename(COMPITEM item, int option, LPSTR filename);

/*
 * options for compitem_getfilename, indicating which name is desired
 */
#define CI_LEFT         1       /* name of left file */
#define CI_RIGHT        2       /* name of right file */
#define CI_COMP         3       /* name of composite file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\wndtreed.cpp ===
// wndtreed.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "treectl.h"
#include "imgwell.h"
#include "findtool.h"
#include "spytreed.h"
#include "spytreec.h"
#include "wndnode.h"
#include "wndtreed.h"
#include "spytreev.h"
#include "srchdlgs.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWndTreeDoc

IMPLEMENT_DYNCREATE(CWndTreeDoc, CSpyTreeDoc);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CWndTreeDoc::CWndTreeDoc()
{
	m_hwndWnd = NULL;
	m_strCaption.Empty();
	m_strClass.Empty();
	m_fSearchUp = FALSE;
}



CWndTreeDoc::~CWndTreeDoc()
{
}



void CWndTreeDoc::InitializeData()
{
	//
	// Create the one and only top level node based on the windows
	// desktop window.  The create of this node will automatically
	// populate all the children entries, creating nodes for them
	// as well.
	//
	CWndTreeNode* pWndTreeNode = new CWndTreeNode;
	pWndTreeNode->Create(::GetDesktopWindow(), TRUE);
	m_TopLevelNodeList.AddTail(pWndTreeNode);
}

void CWndTreeDoc::SetSearchMenuText(CCmdUI *pCmdUI)
{
	pCmdUI->SetText(ids(IDS_MENU_FINDWINDOW));
}

BOOL CWndTreeDoc::DoFind()
{
#ifdef USE_TABBED_SEARCH_DIALOGS
	CSearchTabbedDialog dlgTest(IDS_SEARCHCAPTION, NULL, (UINT)-1);

	dlgTest.AddTab(new CSearchWindowDlgTab(IDD_SEARCHWINDOWTAB, IDS_SEARCHWINDOWTAB));

	dlgTest.DoModal();
#else	// USE_TABBED_SEARCH_DIALOGS
	CSearchWindowDlg dlg;
	CSpyTreeView *pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
	CWndTreeNode *pcwtn = (CWndTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(pcstvActive->m_SpyTreeCtl.GetCurSel())->m_dwData;

	m_hwndWnd = (HWND)pcwtn->GetObjectHandle();
	m_strCaption = pcwtn->GetCaption();
	m_strClass = pcwtn->GetClass();

	dlg.SetWindow(m_hwndWnd);
	dlg.SetCaption(m_strCaption);     
	dlg.SetClass(m_strClass);       
	dlg.SetDirection(m_fSearchUp);

	if (dlg.DoModal() == TRUE)
	{
		m_wSearchFlags	= dlg.GetSearchFlags();
		m_hwndWnd		= dlg.GetSelectedHwnd();
		m_strCaption	= dlg.GetCaption();
		m_strClass		= dlg.GetClass();
		m_fSearchUp		= dlg.GetDirection();

		if (m_fSearchUp)
		{
			if (!FindPreviousMatchingNode() && !FindLastMatchingNode())
			{
				// notify user that no matching node found
				SpyMessageBox(IDS_NO_MATCHING_WND);
			}
		}
		else
		{
			if (!FindNextMatchingNode() && !FindFirstMatchingNode())
			{
				// notify user that no matching node found
				SpyMessageBox(IDS_NO_MATCHING_WND);
			}
		}
	}
#endif	// USE_TABBED_SEARCH_DIALOGS

	return(TRUE);
}

BOOL CWndTreeDoc::DoFindNext()
{
	if (!FindNextMatchingNode() && !FindFirstMatchingNode())
	{
		// notify user that no next matching node found
		SpyMessageBox(IDS_NO_NEXT_MATCH_WND);
	}

	return(TRUE);
}

BOOL CWndTreeDoc::DoFindPrev()
{
	if (!FindPreviousMatchingNode() && !FindLastMatchingNode())
	{
		// notify user that no previous matching node found
		SpyMessageBox(IDS_NO_PREV_MATCH_WND);
	}

	return(TRUE);
}

BOOL CWndTreeDoc::HasValidFind()
{
	if (m_wSearchFlags & SRCHFLAG_WINDOW_USEHANDLE)
		return(FALSE);
	else if (m_wSearchFlags & SRCHFLAG_WINDOW_USECAPTION)
		return(!m_strCaption.IsEmpty());
	else if (m_wSearchFlags & SRCHFLAG_WINDOW_USECLASS)
		return(!m_strClass.IsEmpty());
	else
		return(FALSE);
}

BOOL CWndTreeDoc::CompareNode(CWndTreeNode *pcwtn)
{
	// do comparison of node contents with search criteria
	switch (m_wSearchFlags)
	{
		case SRCHFLAG_WINDOW_USEHANDLE:

			if (pcwtn->GetObjectHandle() == (DWORD)m_hwndWnd)
				return(TRUE);
			break;

		case SRCHFLAG_WINDOW_USECAPTION:

			if (pcwtn->GetCaption() == m_strCaption)
				return(TRUE);
			break;

		case SRCHFLAG_WINDOW_USECLASS:

			if (pcwtn->GetClass() == m_strClass)
				return(TRUE);
			break;

		case (SRCHFLAG_WINDOW_USECAPTION | SRCHFLAG_WINDOW_USECLASS):

			if ((pcwtn->GetCaption() == m_strCaption) && (pcwtn->GetClass() == m_strClass))
				return(TRUE);
			break;
	}

	return(FALSE);
}

BOOL CWndTreeDoc::FindNodeRecurse(CWndTreeNode *pcwtn, CObList &listExpand, BOOL fSearchingUp)
{
	// do comparison
	if (CompareNode(pcwtn))
	{
		if (fSearchingUp)
			listExpand.RemoveAll();
		listExpand.AddTail(pcwtn);
		if (!fSearchingUp)
			return(TRUE);
	}

	POSITION pos = pcwtn->GetFirstChildPosition();
	while (pos)
	{
		CWndTreeNode *pcwtnLoop = (CWndTreeNode*)pcwtn->GetNextChild(pos);

		if (FindNodeRecurse(pcwtnLoop, listExpand, fSearchingUp))
		{
			listExpand.AddTail(pcwtn);
			if (!fSearchingUp)
				return(TRUE);
		}
	}

	if (fSearchingUp)
		return(!listExpand.IsEmpty());

	return(FALSE);
	
}

BOOL CWndTreeDoc::FindFirstMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CWndTreeNode *pcwtn;
	CObList listExpand;

	for (int i = 0; i < pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount(); i++)
	{
		pcwtn = (CWndTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (FindNodeRecurse(pcwtn, listExpand))
		{
			CWndTreeNode *pcwtnLoop;
			int iLoop = 0;
			BOOL fHeld = FALSE;

			POSITION pos = listExpand.GetTailPosition();
			while (pos)
			{
				iLoop++;
				pcwtnLoop = (CWndTreeNode*)listExpand.GetPrev(pos);

				if (iLoop != listExpand.GetCount())
				{
					if (!(pcstvActive->m_SpyTreeCtl.IsExpanded(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop))))
					{
						if (!fHeld)
						{
							pcstvActive->m_SpyTreeCtl.HoldUpdates();
							fHeld = TRUE;
						}
						pcstvActive->m_SpyTreeCtl.Expand(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop));
					}
				}
			}
			listExpand.RemoveAll();

			if (fHeld)
				pcstvActive->m_SpyTreeCtl.EnableUpdates();

			pcstvActive->m_SpyTreeCtl.SetCurSel(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop));
			return(TRUE);
		}
	}

	return(FALSE);
}

BOOL CWndTreeDoc::FindNextMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CWndTreeNode *pcwtn;
	CObList listExpand;

	for (int i = pcstvActive->m_SpyTreeCtl.GetCurSel() + 1; i < pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount(); i++)
	{
		pcwtn = (CWndTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (FindNodeRecurse(pcwtn, listExpand))
		{
			CWndTreeNode *pcwtnLoop;
			int iLoop = 0;
			BOOL fHeld = FALSE;

			POSITION pos = listExpand.GetTailPosition();
			while (pos)
			{
				iLoop++;
				pcwtnLoop = (CWndTreeNode*)listExpand.GetPrev(pos);

				if (iLoop != listExpand.GetCount())
				{
					if (!(pcstvActive->m_SpyTreeCtl.IsExpanded(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop))))
					{
						if (!fHeld)
						{
							pcstvActive->m_SpyTreeCtl.HoldUpdates();
							fHeld = TRUE;
						}
						pcstvActive->m_SpyTreeCtl.Expand(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop));
					}
				}
			}
			listExpand.RemoveAll();

			if (fHeld)
				pcstvActive->m_SpyTreeCtl.EnableUpdates();

			pcstvActive->m_SpyTreeCtl.SetCurSel(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop));
			return(TRUE);
		}
	}

	return(FALSE);
}

BOOL CWndTreeDoc::FindPreviousMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CWndTreeNode *pcwtn;
	CObList listExpand;

	for (int i = pcstvActive->m_SpyTreeCtl.GetCurSel() - 1; i >= 0; i--)
	{
		pcwtn = (CWndTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (pcstvActive->m_SpyTreeCtl.GetNode(i) == pcstvActive->m_SpyTreeCtl.GetNode(i + 1)->m_pParent)
		{
			if (CompareNode(pcwtn))
			{
				pcstvActive->m_SpyTreeCtl.SetCurSel(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtn));
				return(TRUE);
			}
		}
		else
		{
			if (FindNodeRecurse(pcwtn, listExpand, TRUE))
			{
				CWndTreeNode *pcwtnLoop;
				int iLoop = 0;
				BOOL fHeld = FALSE;

				POSITION pos = listExpand.GetTailPosition();
				while (pos)
				{
					iLoop++;
					pcwtnLoop = (CWndTreeNode*)listExpand.GetPrev(pos);

					if (iLoop != listExpand.GetCount())
					{
						if (!(pcstvActive->m_SpyTreeCtl.IsExpanded(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop))))
						{
							if (!fHeld)
							{
								pcstvActive->m_SpyTreeCtl.HoldUpdates();
								fHeld = TRUE;
							}
							pcstvActive->m_SpyTreeCtl.Expand(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop));
						}
					}
				}
				listExpand.RemoveAll();

				if (fHeld)
					pcstvActive->m_SpyTreeCtl.EnableUpdates();

				pcstvActive->m_SpyTreeCtl.SetCurSel(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop));
				return(TRUE);
			}
		}
	}

	return(FALSE);
}

BOOL CWndTreeDoc::FindLastMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CWndTreeNode *pcwtn;
	CObList listExpand;

	for (int i = pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount() - 1; i >= 0; i--)
	{
		pcwtn = (CWndTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if ((i < pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount() - 1) &&
			(pcstvActive->m_SpyTreeCtl.GetNode(i) == pcstvActive->m_SpyTreeCtl.GetNode(i + 1)->m_pParent))
		{
			if (CompareNode(pcwtn))
			{
				pcstvActive->m_SpyTreeCtl.SetCurSel(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtn));
				return(TRUE);
			}
		}
		else
		{
			if (FindNodeRecurse(pcwtn, listExpand, TRUE))
			{
				CWndTreeNode *pcwtnLoop;
				int iLoop = 0;
				BOOL fHeld = FALSE;

				POSITION pos = listExpand.GetTailPosition();
				while (pos)
				{
					iLoop++;
					pcwtnLoop = (CWndTreeNode*)listExpand.GetPrev(pos);

					if (iLoop != listExpand.GetCount())
					{
						if (!(pcstvActive->m_SpyTreeCtl.IsExpanded(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop))))
						{
							if (!fHeld)
							{
								pcstvActive->m_SpyTreeCtl.HoldUpdates();
								fHeld = TRUE;
							}
							pcstvActive->m_SpyTreeCtl.Expand(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop));
						}
					}
				}
				listExpand.RemoveAll();

				if (fHeld)
					pcstvActive->m_SpyTreeCtl.EnableUpdates();

				pcstvActive->m_SpyTreeCtl.SetCurSel(pcstvActive->m_SpyTreeCtl.FindNode((DWORD)pcwtnLoop));
				return(TRUE);
			}
		}
	}

	return(FALSE);
}

BEGIN_MESSAGE_MAP(CWndTreeDoc, CSpyTreeDoc)
	//{{AFX_MSG_MAP(CWndTreeDoc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\wndptabs.h ===
// wndptabs.h : header file
//


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CWindowGeneralPropTab window

class CWindowGeneralPropTab : public CPropertyTab
{
// Construction
public:
	CWindowGeneralPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CWindowGeneralPropTab)
	enum { IDD = IDD_WINDOWGENERALTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CWindowGeneralPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CWindowGeneralPropTab)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CWindowStylesPropTab window

class CWindowStylesPropTab : public CPropertyTab
{
// Construction
public:
	CWindowStylesPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CWindowStylesPropTab)
	enum { IDD = IDD_WINDOWSTYLESTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CWindowStylesPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CWindowStylesPropTab)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CWindowWindowsPropTab window

class CWindowWindowsPropTab : public CPropertyTab
{
// Construction
public:
	CWindowWindowsPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CWindowWindowsPropTab)
	enum { IDD = IDD_WINDOWWINDOWSTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CWindowWindowsPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	CHotLinkCtrlWnd m_HotLinkNextWindow;
	CHotLinkCtrlWnd m_HotLinkPrevWindow;
	CHotLinkCtrlWnd m_HotLinkParentWindow;
	CHotLinkCtrlWnd m_HotLinkFirstChild;
	CHotLinkCtrlWnd m_HotLinkOwnerWindow;

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CWindowWindowsPropTab)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CWindowClassPropTab window

class CWindowClassPropTab : public CPropertyTab
{
// Construction
public:
	CWindowClassPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CWindowClassPropTab)
	enum { IDD = IDD_WINDOWCLASSTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CWindowClassPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CWindowClassPropTab)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CWindowProcessPropTab window

class CWindowProcessPropTab : public CPropertyTab
{
// Construction
public:
	CWindowProcessPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CWindowProcessPropTab)
	enum { IDD = IDD_WINDOWPROCESSTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CWindowProcessPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	CHotLinkCtrlPrc m_HotLinkProcessID;
	CHotLinkCtrlThd m_HotLinkThreadID;

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CWindowProcessPropTab)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\complist.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * COMPLIST.H
 */

/* The file view.h includes the term COMPLIST: we need to use the term VIEW.
 * Due to MIPS limitations,the module which declares it first does
 * the real declares and the second one gets no-ops.
 */
#ifndef INC_VIEW_COMPLIST
#define INC_VIEW_COMPLIST
typedef struct view FAR * VIEW;                 /* handle to a VIEW     */
typedef struct complist FAR * COMPLIST;         /* handle to a complist */
#endif // INC_VIEW_COMPLIST


COMPLIST complist_filedialog(VIEW view);
COMPLIST complist_dirdialog(VIEW view);
COMPLIST complist_args(LPSTR path1, LPSTR path2, VIEW view, BOOL fDeep);
void complist_delete(COMPLIST cl);
LIST complist_getitems(COMPLIST cl);
void complist_savelist(COMPLIST cl, LPSTR savename, UINT saveopts);
void complist_copyfiles(COMPLIST cl, LPSTR newroot, UINT options);
DWORD complist_querytime(void);
BOOL APIENTRY complist_open(LPSTR prompt, LPSTR ext, LPSTR spec,
        OFSTRUCT FAR *osp, LPSTR fn);
LPSTR complist_getroot_left(COMPLIST cl);
LPSTR complist_getroot_right(COMPLIST cl);
void complist_freeroot_left(COMPLIST cl, LPSTR path);
void complist_freeroot_right(COMPLIST cl, LPSTR path);

/*
 * Copy file options are either COPY_FROMLEFT or COPY_FROMRIGHT 
 * (indicating which
 * tree is to be the source of the files, plus any or all of
 * INCLUDE_SAME, INCLUDE_DIFFER and INCLUDE_LEFT (INCLUDE_LEFT
 * and INCLUDE_RIGHT are treated the same here since the COPY_FROM* option
 * indicates which side to copy from).
 */

#define COPY_FROMLEFT   0x100           /* copy files from left tree */
#define COPY_FROMRIGHT  0x200           /* copy files from right tree */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\complist.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: COMPLIST.C
*
* Supports a list of compitems, where each compitem represents
* a pair of matching files, or an unmatched file.
*
* Functions:
*
* complist_filedialog()
* complist_dirdialog()
* complist_args()
* complist_getitems()
* complist_delete()
* complist_savelist()
* complist_copyfiles()
* complist_dodlg_savelist()
* complist_dodlg_copyfiles()
* complist_match()
* complist_new()
* complist_dodlg_dir()
*
* Comments:
*
* We build lists of filenames from two pathnames (using the
* scandir module) and then traverse the two lists comparing names.
* Where the names match, we create a CompItem from the matching
* names. Where there is an unmatched name, we create a compitem for it.
*
* We may also be asked to create a complist for two individual files:
* here we create a single compitem for them as a matched pair even if
* the names don't match.
*
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <direct.h>

#include "gutils.h"
#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"
#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "view.h"


extern BOOL bAbort;             /* defined in windiff.c  Read only here */

/*
 * The COMPLIST handle is typedef-ed to be a pointer to one
 * of these struct complist
 */
struct complist {
        DIRLIST left;           /* left list of files */
        DIRLIST right;          /* right list of files */
        LIST items;             /* list of COMPITEMs */
};

/* ---- module-wide data -------------------------------------*/

/* data for communicating between the SaveList dlg and complist_savelist() */

char dlg_file[256];                /* filename to save to */

/* checkbox options */
BOOL dlg_identical, dlg_differ, dlg_left, dlg_right;
BOOL dlg_recursive = FALSE;

/* data for Directory and SaveList */
char dialog_leftname[256];
char dialog_rightname[256];

/*
 * data used by dodlg_copyfiles
 */
UINT dlg_options;
char dlg_root[256];

/*------------------------timing for performance measurements-----------------*/

static DWORD TickCount;         /* time operation started, then time taken*/


int FAR PASCAL complist_dodlg_savelist(HWND hDlg, UINT message,
        UINT wParam, long lParam);
int FAR PASCAL complist_dodlg_copyfiles(HWND hDlg, UINT message,
        UINT wParam, long lParam);
BOOL complist_match(COMPLIST cl, VIEW view, BOOL fDeep, BOOL fExact);
COMPLIST complist_new(void);
int FAR PASCAL complist_dodlg_dir(HWND hDlg, unsigned message,
        WORD wParam, LONG lParam);



/***************************************************************************
 * Function: complist_filedialog
 *
 * Purpose:
 *
 * Builds a complist by putting up two dialogs to allow the user to
 * select two files. This will build a Complist with one CompItem (even
 * if the names don't match).
 *
 ***************************************************************************/
COMPLIST
complist_filedialog(VIEW view)
{
        COMPLIST cl;
        OFSTRUCT os1, os2;
        char fname[256], FileExt[256], FileOpenSpec[256];

        /* ask for the filenames */
        lstrcpy(FileExt, ".c");
        lstrcpy(FileOpenSpec, "*.*");
        lstrcpy(fname,"");

        if (!complist_open("Select First File", FileExt, FileOpenSpec,
                        &os1, fname) )
                return(NULL);

        lstrcpy(FileExt, ".c");
        lstrcpy(FileOpenSpec, "*.*");
        lstrcpy(fname,"");

        if (!complist_open("Select Second File", FileExt, FileOpenSpec,
                        &os2, fname) )
                return(NULL);

        /* alloc a new structure */
        cl = complist_new();

        cl->left = dir_buildlist(os1.szPathName, TRUE);
        cl->right = dir_buildlist(os2.szPathName, TRUE);


        /* register with the view (must be done after the list is non-null) */
        view_setcomplist(view, cl);

        complist_match(cl, view, FALSE, TRUE);

        return(cl);
}/* complist_filedialog */

/***************************************************************************
 * Function: complist_dirdialog
 *
 * Purpose:
 *
 * Builds a new complist by querying the user for two directory
 * names and scanning those in parallel.
 *
 * Names that match in the same directory will be paired - unmatched
 * names will go in a compitem on their own.
 *
 ***************************************************************************/
COMPLIST
complist_dirdialog(VIEW view)
{
        DLGPROC lpProc;
        BOOL fOK;

        /* put up a dialog for the two pathnames */
        lpProc = (DLGPROC)MakeProcInstance((WNDPROC)complist_dodlg_dir, hInst);
        windiff_UI(TRUE);
        fOK = DialogBox(hInst, "Directory", hwndClient, lpProc);
        windiff_UI(FALSE);
        FreeProcInstance(lpProc);

        if (!fOK) {
                return(NULL);
        }

        return complist_args( dialog_leftname, dialog_rightname
                            , view, dlg_recursive);
} /* complist_dirdialog */


/***************************************************************************
 * Function: complist_args
 *
 * Purpose:
 *
 * Given two pathname strings, scan the directories and traverse them
 * in parallel comparing matching names.
 *
 ***************************************************************************/
COMPLIST
complist_args(LPSTR p1, LPSTR p2, VIEW view, BOOL fDeep)
{
        COMPLIST cl;
        char msg[256];


        /* alloc a new complist */
        cl = complist_new();

        cl->left = dir_buildlist(p1, TRUE);
        /* check that we could find the paths, and report if not */
        if (cl->left == NULL) {
                wsprintf((LPTSTR)msg, "Couldn't find %s", p1);
                MessageBox(NULL, msg, "Error", MB_OK | MB_ICONSTOP);
                return(NULL);
        }

        cl->right = dir_buildlist(p2, TRUE);
        if (cl->right == NULL) {
                wsprintf((LPTSTR)msg, "Couldn't find %s", p2);
                MessageBox(NULL, msg, "Error", MB_OK | MB_ICONSTOP);
                return(NULL);
        }

        /* register with the view (must be done after building lists) */
        view_setcomplist(view, cl);

        complist_match(cl, view, fDeep, TRUE);

        return(cl);
} /* complist_args */

/***************************************************************************
 * Function: complist_getitems
 *
 * Purpose:
 *
 * Gets the handle to the list of COMPITEMs. The list continues to be
 * owned by the COMPLIST, so don't delete except by calling complist_delete.
 *
 ***************************************************************************/
LIST
complist_getitems(COMPLIST cl)
{
        if (cl == NULL) {
                return(NULL);
        }

        return(cl->items);
}

/***************************************************************************
 * Function: complist_delete
 *
 * Purpose:
 *
 * Deletes a complist and all associated CompItems and DIRLISTs. Note this
 * does not delete any VIEW - the VIEW owns the COMPLIST and not the other
 * way around.
 *
 **************************************************************************/
void
complist_delete(COMPLIST cl)
{
        COMPITEM item;

        if (cl == NULL) {
                return;
        }

        /* delete the two directory scan lists */
        dir_delete(cl->left);
        dir_delete(cl->right);

        /* delete the compitems in the list */
        List_TRAVERSE(cl->items, item) {
                        compitem_delete(item);
        }

        /* delete the list itself */
        List_Destroy(&cl->items);

        gmem_free(hHeap, (LPSTR) cl, sizeof(struct complist));

}

/***************************************************************************
 * Function: complist_savelist
 *
 * Purpose:
 *
 * Writes out to a text file the list of compitems as relative filenames
 * one per line.
 *
 * If savename is non-null, use this as the filename for output; otherwise,
 * query the user via a dialog for the filename and include options.
 *
 **************************************************************************/
void
complist_savelist(COMPLIST cl, LPSTR savename, UINT options)
{
        DLGPROC lpProc;
        static BOOL done_init = FALSE;
        BOOL bOK;
        int fh, state;
        OFSTRUCT os;
        char msg[256];
        HCURSOR hcurs;
        COMPITEM ci;
        LPSTR pstr, lhead, rhead;
        int nFiles = 0;

        if (!done_init) {
                /* init the options once round - but keep the same options
                 * for the rest of the session.
                 */

                /* first init default options */
                dlg_identical = FALSE;
                dlg_differ = TRUE;
                dlg_left = TRUE;
                dlg_right = FALSE;

                dlg_file[0] = '\0';

                done_init = TRUE;
        }

        if (cl == NULL) {
                return;
        }

        if (savename == NULL) {

                /* store the left and right rootnames so that dodlg_savelist
                 * can display them in the dialog.
                 */
                pstr = dir_getroot_list(cl->left);
                lstrcpy(dialog_leftname, pstr);
                dir_freeroot_list(cl->left, pstr);

                pstr = dir_getroot_list(cl->right);
                lstrcpy(dialog_rightname, pstr);
                dir_freeroot_list(cl->right, pstr);

                lpProc = (DLGPROC)MakeProcInstance((WNDPROC)complist_dodlg_savelist, hInst);
                windiff_UI(TRUE);
                bOK = DialogBox(hInst, "SaveList", hwndClient, lpProc);
                windiff_UI(FALSE);
                FreeProcInstance(lpProc);

                if (!bOK) {
                        /* user cancelled from dialog box */
                        return;
                }
                savename = dlg_file;

        } else {
                dlg_identical = (options & INCLUDE_SAME);
                dlg_differ = (options & INCLUDE_DIFFER);
                dlg_left = (options & INCLUDE_LEFTONLY);
                dlg_right = (options & INCLUDE_RIGHTONLY);
        }


        /* try to open the file */
        fh = OpenFile(savename, &os, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
        if (fh < 0) {
                wsprintf((LPTSTR)msg, "Cannot open %s", savename);
                windiff_UI(TRUE);
                MessageBox(NULL, msg, "Windiff", MB_ICONSTOP|MB_OK);
                windiff_UI(FALSE);
                return;
        }

        hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

        /* write out the header line */
        lhead = dir_getroot_list(cl->left);
        rhead = dir_getroot_list(cl->right);
        wsprintf((LPTSTR)msg, "-- %s : %s -- includes %s%s%s%s files\n",
                lhead, rhead,
                (LPSTR) (dlg_identical ? "identical," : ""),
                (LPSTR) (dlg_left ? "left-only," : ""),
                (LPSTR) (dlg_right ? "right-only," : ""),
                (LPSTR) (dlg_differ ? "differing" : "") );
        _lwrite(fh, msg, lstrlen(msg));
        dir_freeroot_list(cl->left, lhead);
        dir_freeroot_list(cl->right, rhead);


        /* traverse the list of compitems looking for the
         * ones we are supposed to include
         */
        List_TRAVERSE(cl->items, ci) {

                /* check if files of this type are to be listed */
                state = compitem_getstate(ci);

                if ((state == STATE_SAME) && (!dlg_identical)) {
                        continue;
                } else if ((state == STATE_DIFFER) && (!dlg_differ)) {
                        continue;
                } else if ((state == STATE_FILELEFTONLY) && (!dlg_left)) {
                        continue;
                } else if ((state == STATE_FILERIGHTONLY) && (!dlg_right)) {
                        continue;
                }

                nFiles++;

                /* output the list line */
                wsprintf((LPTSTR)msg, "%s", compitem_gettext_tag(ci));
                _lwrite(fh, msg, lstrlen(msg));

                wsprintf((LPTSTR)msg, "\n");
                _lwrite(fh, msg, strlen(msg));
        }

        /* write tail line */
        wsprintf((LPTSTR)msg, "-- %d files listed\n", nFiles);
        _lwrite(fh, msg, lstrlen(msg));

        /* - close file and we are finished */
        _lclose(fh);

        SetCursor(hcurs);
} /* complist_savelist */

/***************************************************************************
 * Function: complist_copyfiles
 *
 * Purpose:
 *
 * To copy files to a new directory newroot. if newroot is NULL, query the user
 * via a dialog to get the new dir name and options.
 *
 * Options are either COPY_FROMLEFT or COPY_FROMRIGHT (indicating which
 * tree is to be the source of the files, plus any or all of
 * INCLUDE_SAME, INCLUDE_DIFFER and INCLUDE_LEFT (INCLUDE_LEFT
 * and INCLUDE_RIGHT are treated the same here since the COPY_FROM* option
 * indicates which side to copy from).
 *
 ***************************************************************************/
void
complist_copyfiles(COMPLIST cl, LPSTR newroot, UINT options)
{
        int nFiles = 0;
        int nFails = 0;
        static BOOL done_init = FALSE;
        LPSTR pstr;
        char buffer[64];
        DIRITEM diritem;
        DLGPROC lpProc;
        BOOL bOK;
        COMPITEM ci;
        int state;

        if (!done_init) {
                /*
                 * one-time initialisation of dialog defaults
                 */
                dlg_options = COPY_FROMLEFT|INCLUDE_LEFTONLY|INCLUDE_DIFFER;
                dlg_root[0] = '\0';
                done_init = TRUE;
        }

        if (cl == NULL) {
                return;
        }


        if (newroot == NULL) {
                /*
                 * put up dialog to query rootname and options
                 */

                /* store the left and right rootnames so that the dlg proc
                 * can display them in the dialog.
                 */
                pstr = dir_getroot_list(cl->left);
                lstrcpy(dialog_leftname, pstr);
                dir_freeroot_list(cl->left, pstr);

                pstr = dir_getroot_list(cl->right);
                lstrcpy(dialog_rightname, pstr);
                dir_freeroot_list(cl->right, pstr);

                do {
                        lpProc = (DLGPROC)MakeProcInstance((WNDPROC)complist_dodlg_copyfiles, hInst);
                        windiff_UI(TRUE);
                        bOK = DialogBox(hInst, "CopyFiles", hwndClient, lpProc);
                        windiff_UI(FALSE);
                        FreeProcInstance(lpProc);

                        if (!bOK) {
                                /* user cancelled from dialog box */
                                return;
                        }
                        if (lstrlen(dlg_root) == 0) {
                                windiff_UI(TRUE);
                                MessageBox(NULL, "Please enter the directory name",
                                                "Windiff", MB_ICONSTOP|MB_OK);
                                windiff_UI(FALSE);
                        }
                } while (lstrlen(dlg_root) == 0);

        } else {
                dlg_options = options;
                lstrcpy(dlg_root, newroot);
        }

        TickCount = GetTickCount();

        if (dlg_options & COPY_FROMLEFT) {
                if (!dir_startcopy(cl->left))
                        return;
        } else {
                if (!dir_startcopy(cl->right))
                        return;
        }

        /*
         * traverse the list of compitems copying files as necessary
         */
        List_TRAVERSE(cl->items, ci) {

                if (bAbort){
                        break;  /* fall into end_copy processing */
                }
                /* check if files of this type are to be copied */
                state = compitem_getstate(ci);

                if ((state == STATE_SAME) && !(dlg_options & INCLUDE_SAME)) {
                        continue;
                } else if ((state == STATE_DIFFER) && !(dlg_options & INCLUDE_DIFFER)) {
                        continue;
                } else if (state == STATE_FILELEFTONLY) {
                        if (dlg_options & COPY_FROMRIGHT) {
                                continue;
                        }
                        if ((dlg_options & (INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY)) == 0) {
                                continue;
                        }
                } else if (state == STATE_FILERIGHTONLY) {
                        if (dlg_options & COPY_FROMLEFT) {
                                continue;
                        }
                        if ((dlg_options & (INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY)) == 0) {
                                continue;
                        }
                }

                if (dlg_options & COPY_FROMLEFT) {
                        diritem = file_getdiritem(compitem_getleftfile(ci));
                } else {
                        diritem = file_getdiritem(compitem_getrightfile(ci));
                }

                /*
                 * copy the file to the new root directory
                 */
                if (dir_copy(diritem, dlg_root) == FALSE) {
                        nFails++;
                        pstr = dir_getrelname(diritem);
                        wsprintf((LPTSTR)buffer, "failed to copy %s", pstr);
                        dir_freerelname(diritem, pstr);

                        if (MessageBox(NULL, buffer, "Error", MB_OKCANCEL | MB_ICONSTOP) == IDCANCEL)
                            /* user pressed cancel - abort current operation*/
                            /* fall through to end-copy processing */
                            break;

                } else {
                        nFiles++;
                }

                wsprintf((LPTSTR)buffer, "%4d files requested. Copying...", nFiles);
                SetStatus(buffer);


                /*
                 * allow user interface to continue
                 */
                if (Poll()) {
                        /* abort requested */
                        TickCount = GetTickCount()-TickCount;
                        windiff_UI(TRUE);
                        MessageBox(hwndClient, "Copy Aborted",
                                "WinDiff", MB_OK|MB_ICONINFORMATION);
                        windiff_UI(FALSE);
                        break;
                }

        } /* traverse */
        if (dlg_options & COPY_FROMLEFT) {
                nFails = dir_endcopy(cl->left);
        } else {
                nFails = dir_endcopy(cl->right);
        }
        TickCount = GetTickCount()-TickCount;

        if (nFails<0) {
                wsprintf((LPTSTR)buffer, "Copy Complete: %d files failed", -nFails);
        } else {
                wsprintf((LPTSTR)buffer, "Copy Complete %d files copied", nFails);
        }
        windiff_UI(TRUE);
        MessageBox(hwndClient, buffer, "WinDiff", MB_OK|MB_ICONINFORMATION);
        windiff_UI(FALSE);

        buffer[0] = '\0';
        SetStatus(buffer);
} /* complist_copyfiles */


/***************************************************************************
 * Function: complist_match
 *
 * Purpose:
 *
 * Matches up two lists of filenames
 *
 * Commentsz:
 *
 * We can find out from the DIRLIST handle whether the original list
 * was a file or a directory name.
 * If the user typed:
 *      two file names  - match these two item even if the names differ
 *
 *      two dirs        - match only those items whose names match
 *
 *      one file and one dir
 *                      - try to find a file of that name in the dir.
 *
 * This function returns TRUE if the complist_match was ok, or FALSE if it was
 * aborted in some way.
 *
 ***************************************************************************/
BOOL
complist_match(COMPLIST cl, VIEW view, BOOL fDeep, BOOL fExact)
{
        LPSTR lname;
        LPSTR rname;
        DIRITEM leftitem, rightitem;
        int cmpvalue;

        TickCount = GetTickCount();

        if (dir_isfile(cl->left) ) {

                if (dir_isfile(cl->right)) {
                        /* two files */

                        /* there should be one item in each list - make
                         * a compitem by matching these two and append it to the
                         * list
                         */
                        compitem_new(dir_firstitem(cl->left),
                                       dir_firstitem(cl->right), cl->items, fExact);

                        view_newitem(view);

                        TickCount = GetTickCount() - TickCount;
                        return TRUE;
                }
                /* left is file, right is dir */
                leftitem = dir_firstitem(cl->left);
                rightitem = dir_firstitem(cl->right);
                lname = dir_getrelname(leftitem);
                while (rightitem != NULL) {
                        rname = dir_getrelname(rightitem);
                        cmpvalue = lstrcmpi(lname, rname);
                        dir_freerelname(rightitem, rname);

                        if (cmpvalue == 0) {
                                /* this is the match */
                                compitem_new(leftitem, rightitem, cl->items, fExact);
                                view_newitem(view);

                                dir_freerelname(leftitem, lname);

                                TickCount = GetTickCount() - TickCount;
                                return(TRUE);
                        }

                        rightitem = dir_nextitem(cl->right, rightitem, fDeep);
                }
                /* not found */
                dir_freerelname(leftitem, lname);
                compitem_new(leftitem, NULL, cl->items, fExact);
                view_newitem(view);
                TickCount = GetTickCount() - TickCount;
                return(TRUE);

        } else if (dir_isfile(cl->right)) {

                /* left is dir, right is file */

                /* loop through the left dir, looking for
                 * a file that has the same name as rightitem
                 */

                leftitem = dir_firstitem(cl->left);
                rightitem = dir_firstitem(cl->right);
                rname = dir_getrelname(rightitem);
                while (leftitem != NULL) {
                        lname = dir_getrelname(leftitem);
                        cmpvalue = lstrcmpi(lname, rname);
                        dir_freerelname(leftitem, lname);

                        if (cmpvalue == 0) {
                                /* this is the match */
                                compitem_new(leftitem, rightitem, cl->items, fExact);
                                view_newitem(view);

                                dir_freerelname(rightitem, rname);

                                TickCount = GetTickCount() - TickCount;
                                return(TRUE);
                        }

                        leftitem = dir_nextitem(cl->left, leftitem, fDeep);
                }
                /* not found */
                dir_freerelname(rightitem, rname);
                compitem_new(NULL, rightitem, cl->items, fExact);
                view_newitem(view);
                TickCount = GetTickCount() - TickCount;
                return(TRUE);
        }

        /* two directories */

        /* traverse the two lists in parallel comparing the relative names*/

        leftitem = dir_firstitem(cl->left);
        rightitem = dir_firstitem(cl->right);
        while ((leftitem != NULL) && (rightitem != NULL)) {

                lname = dir_getrelname(leftitem);
                rname = dir_getrelname(rightitem);
                cmpvalue = utils_CompPath(lname, rname);
                dir_freerelname(leftitem, lname);
                dir_freerelname(rightitem, rname);

                if (cmpvalue == 0) {
                        compitem_new(leftitem, rightitem, cl->items, fExact);
                        if (view_newitem(view)) {
                                TickCount = GetTickCount() - TickCount;
                                return(FALSE);
                        }
                        leftitem = dir_nextitem(cl->left, leftitem, fDeep);
                        rightitem = dir_nextitem(cl->right, rightitem, fDeep);

                } else if (cmpvalue < 0) {
                        compitem_new(leftitem, NULL, cl->items, fExact);
                        if (view_newitem(view)) {
                                TickCount = GetTickCount() - TickCount;
                                return(FALSE);
                        }
                        leftitem = dir_nextitem(cl->left, leftitem, fDeep);
                }  else {
                        compitem_new(NULL, rightitem, cl->items, fExact);
                        if (view_newitem(view)) {
                                TickCount = GetTickCount() - TickCount;
                                return(FALSE);
                        }
                        rightitem = dir_nextitem(cl->right, rightitem, fDeep);
                }
        }


        /* any left over are unmatched */
        while (leftitem != NULL) {
                compitem_new(leftitem, NULL, cl->items, fExact);
                if (view_newitem(view)) {
                        TickCount = GetTickCount() - TickCount;
                        return(FALSE);
                }
                leftitem = dir_nextitem(cl->left, leftitem, fDeep);
        }
        while (rightitem != NULL) {
                compitem_new(NULL, rightitem, cl->items, fExact);
                if (view_newitem(view)) {
                        TickCount = GetTickCount() - TickCount;
                        return(FALSE);
                }
                rightitem = dir_nextitem(cl->right, rightitem, fDeep);
        }
        TickCount = GetTickCount() - TickCount;
        return(TRUE);
} /* complist_match */

/* return time last operation took in milliseconds */
DWORD complist_querytime(void)
{       return TickCount;
}


/***************************************************************************
 * Function: complist_dodlg_savelist
 *
 * Purpose:
 *
 * Dialog to query about filename and types of files. Init dlg fields from
 * the dlg_* variables, and save state to the dlg_* variables on dialog
 * close. return TRUE for OK, or FALSE for cancel (from the dialogbox()
 * using EndDialog).
 *
 **************************************************************************/
int FAR PASCAL
complist_dodlg_savelist(HWND hDlg, UINT message, UINT wParam, long lParam)
{
        static char buffer[256];

        switch(message) {


        case WM_INITDIALOG:
                SendDlgItemMessage(hDlg, IDD_IDENTICAL, BM_SETCHECK,
                        dlg_identical ? 1 : 0, 0);
                SendDlgItemMessage(hDlg, IDD_DIFFER, BM_SETCHECK,
                        dlg_differ ? 1 : 0, 0);
                SendDlgItemMessage(hDlg, IDD_LEFT, BM_SETCHECK,
                        dlg_left ? 1 : 0, 0);
                SendDlgItemMessage(hDlg, IDD_RIGHT, BM_SETCHECK,
                        dlg_right ? 1 : 0, 0);

                SetDlgItemText(hDlg, IDD_FILE, dlg_file);

                /* convert 'left tree' into the right name */
                wsprintf((LPTSTR)buffer, "Files only in %s", (LPSTR) dialog_leftname);
                SendDlgItemMessage(hDlg, IDD_LEFT, WM_SETTEXT, 0, (DWORD) (LPSTR) buffer);

                /* convert 'right tree' msg into correct path */
                wsprintf((LPTSTR)buffer, "Files only in %s", (LPSTR) dialog_rightname);
                SendDlgItemMessage(hDlg, IDD_RIGHT, WM_SETTEXT, 0, (DWORD) (LPSTR) buffer);


                return(TRUE);

        case WM_COMMAND:
                switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                        dlg_identical = (SendDlgItemMessage(hDlg, IDD_IDENTICAL,
                                        BM_GETCHECK, 0, 0) == 1);
                        dlg_differ = (SendDlgItemMessage(hDlg, IDD_DIFFER,
                                        BM_GETCHECK, 0, 0) == 1);
                        dlg_left = (SendDlgItemMessage(hDlg, IDD_LEFT,
                                        BM_GETCHECK, 0, 0) == 1);
                        dlg_right = (SendDlgItemMessage(hDlg, IDD_RIGHT,
                                        BM_GETCHECK, 0, 0) == 1);
                        GetDlgItemText(hDlg, IDD_FILE, dlg_file, sizeof(dlg_file));

                        EndDialog(hDlg, TRUE);
                        break;

                case IDCANCEL:
                        EndDialog(hDlg, FALSE);
                        break;
                }
        }
        return(FALSE);
} /* complist_dodlg_savelist */

/***************************************************************************
 * Function: complist_dodlg_copyfiles
 *
 * Purpose:
 *
 * dialog to get directory name and inclusion options. Init dlg fields from
 * the dlg_* variables, and save state to the dlg_* variables on dialog
 * close. return TRUE for OK, or FALSE for cancel (from the dialogbox()
 * using EndDialog).
 * 
 **************************************************************************/
int FAR PASCAL
complist_dodlg_copyfiles(HWND hDlg, UINT message, UINT wParam, long lParam)
{
        static char buffer[256];

        switch(message) {


        case WM_INITDIALOG:
                /*
                 * set checkboxes and directory field to defaults
                 */
                CheckDlgButton(hDlg, IDD_IDENTICAL,
                        (dlg_options & INCLUDE_SAME) ? 1 : 0);

                CheckDlgButton(hDlg, IDD_DIFFER,
                        (dlg_options & INCLUDE_DIFFER) ? 1 : 0);

                CheckDlgButton(hDlg, IDD_LEFT,
                        (dlg_options & (INCLUDE_LEFTONLY|INCLUDE_RIGHTONLY)) ? 1 : 0);

                SetDlgItemText(hDlg, IDD_DIR1, dlg_root);

                /*
                 * set 'copy from' buttons to have the full pathname
                 */
                SetDlgItemText(hDlg, IDD_FROMLEFT, dialog_leftname);
                SetDlgItemText(hDlg, IDD_FROMRIGHT, dialog_rightname);

                /*
                 * set default radio button for copy from, and set
                 * the text on the 'files only in...' checkbox to
                 * indicate which path is being selected
                 */
                if (dlg_options & COPY_FROMLEFT) {
                        CheckRadioButton(hDlg, IDD_FROMLEFT, IDD_FROMRIGHT,
                                        IDD_FROMLEFT);

                        wsprintf((LPTSTR)buffer, "Files only in %s", (LPSTR) dialog_leftname);
                        SetDlgItemText(hDlg, IDD_LEFT, buffer);
                } else {
                        CheckRadioButton(hDlg, IDD_FROMLEFT, IDD_FROMRIGHT,
                                        IDD_FROMRIGHT);

                        wsprintf((LPTSTR)buffer, "Files only in %s", (LPSTR) dialog_rightname);
                        SetDlgItemText(hDlg, IDD_LEFT, buffer);
                }

                return(TRUE);

        case WM_COMMAND:
                switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDD_FROMLEFT:
                        wsprintf((LPTSTR)buffer, "Files only in %s", (LPSTR) dialog_leftname);
                        SetDlgItemText(hDlg, IDD_LEFT, buffer);

                        dlg_options &= ~(COPY_FROMRIGHT);
                        dlg_options |= COPY_FROMLEFT;
                        break;

                case IDD_FROMRIGHT:
                        wsprintf((LPTSTR)buffer, "Files only in %s", (LPSTR) dialog_rightname);
                        SetDlgItemText(hDlg, IDD_LEFT, buffer);

                        dlg_options &= ~(COPY_FROMLEFT);
                        dlg_options |= COPY_FROMRIGHT;
                        break;

                case IDOK:
                        if (SendDlgItemMessage(hDlg, IDD_IDENTICAL,
                            BM_GETCHECK, 0, 0) == 1) {
                                dlg_options |= INCLUDE_SAME;
                        } else {
                                dlg_options &= ~INCLUDE_SAME;
                        }
                        if (SendDlgItemMessage(hDlg, IDD_DIFFER,
                            BM_GETCHECK, 0, 0) == 1) {
                                dlg_options |= INCLUDE_DIFFER;
                        } else {
                                dlg_options &= ~INCLUDE_DIFFER;
                        }
                        if (SendDlgItemMessage(hDlg, IDD_LEFT,
                            BM_GETCHECK, 0, 0) == 1) {
                                dlg_options |= INCLUDE_LEFTONLY;
                        } else {
                                dlg_options &= ~INCLUDE_LEFTONLY;
                        }
                        GetDlgItemText(hDlg, IDD_DIR1, dlg_root, sizeof(dlg_root));

                        EndDialog(hDlg, TRUE);
                        break;

                case IDCANCEL:
                        EndDialog(hDlg, FALSE);
                        break;
                }
        }
        return(FALSE);
} /* complist_dodlg_copyfiles */

/***************************************************************************
 * Function: complist_new
 *
 * Purpose:
 *
 * Allocates a new complist and initialise it 
 *
 **************************************************************************/
COMPLIST
complist_new(void)
{
        COMPLIST cl;

        cl = (COMPLIST) gmem_get(hHeap, sizeof(struct complist));
        cl->left = NULL;
        cl->right = NULL;
        cl->items = List_Create();

        return(cl);
} /* complist_new */

/***************************************************************************
 * Function: complist_dodlg_dir
 *
 * Purpose:
 *
 * Dialog box function to ask for two directory names.
 * no listing of files etc - just two edit fields  in which the
 * user can type a file or a directory name.
 *
 * Initialises the names from win.ini, and stores them to win.ini first.
 *
 **************************************************************************/
int FAR PASCAL
complist_dodlg_dir(HWND hDlg, unsigned message, WORD wParam, LONG lParam)
{
        static char path[256];
        static char buffer[256];

        switch (message) {

        case WM_INITDIALOG:

                /* fill the edit fields with the current
                 * directory as a good starting point
                 */
                _getcwd(path, sizeof(path));
                AnsiLowerBuff(path, strlen(path));
                GetProfileString(APPNAME, "NameLeft", path, buffer, 256);
                SetDlgItemText(hDlg, IDD_DIR1, buffer);
                GetProfileString(APPNAME, "NameRight", path, buffer, 256);
                SetDlgItemText(hDlg, IDD_DIR2, buffer);
                /* set recursive option to most recent value */
                CheckDlgButton(hDlg, IDD_RECURSIVE, dlg_recursive);
                return(TRUE);

        case WM_COMMAND:
                switch (LOWORD(wParam)) {
                case IDCANCEL:
                        EndDialog(hDlg, FALSE);
                        return(TRUE);

                case IDOK:
                        /* fetch the text from the dialog, and remember
                         * it in win.ini
                         */

                        GetDlgItemText(hDlg, IDD_DIR1,
                                dialog_leftname, sizeof(dialog_leftname));
                        WriteProfileString(APPNAME, "NameLeft", dialog_leftname);

                        GetDlgItemText(hDlg, IDD_DIR2,
                                dialog_rightname, sizeof(dialog_rightname));
                        WriteProfileString(APPNAME, "NameRight", dialog_rightname);

                        /* fetch recursive option */
                        dlg_recursive = SendDlgItemMessage(hDlg, IDD_RECURSIVE,
                                BM_GETCHECK, 0, 0);

                        EndDialog(hDlg, TRUE);
                        return(TRUE);
                }
                break;
        }
        return(FALSE);
} /* complist_dodlg_dir */

/***************************************************************************
 * Function: complist_open
 *
 * Purpose:
 *      
 * Puts up dialog asking the user to select an existing file to open.
 *
 * Parameters:
 *
 *      prompt - message to user indicating purpose of file
 *               (to be displayed somewhere in dialog box.
 *
 *      ext    - default file extension if user enters file without
 *               extension.
 *
 *      spec   - default file spec (eg *.*)
 *
 *      osp    - OFSTRUCT representing file, if successfully open.
 *
 *      fn     - buffer where filename (just final element) is returned.
 *
 * Returns:
 *
 * TRUE - if file selected and exists (tested with OF_EXIST).
 *
 * FALSE - if dialog cancelled. If user selects a file that we cannot
 *           open, we complain and restart the dialog.
 *
 * Comments:
 *
 *           if TRUE is returned, the file will have been successfully opened,
 *           for reading and then closed again.
 *
 **************************************************************************/

BOOL FAR PASCAL
complist_open(LPSTR prompt, LPSTR ext, LPSTR spec, OFSTRUCT FAR *osp, LPSTR fn)
{
    OPENFILENAME ofn;
    char achFilters[256];
    char achPath[256];
    LPSTR chp;
    int fh;

    /* build filter-pair buffer to contain one pair - the spec filter,
     * twice (one of the pair should be the filter, the second should be
     * the title of the filter - we don't have a title so we use the
     * filter both times. remember double null at end of list of strings.
     */
    lstrcpy(achFilters, spec);             // filter + null
    chp = &achFilters[lstrlen(achFilters)+1];      //2nd string just after null
    lstrcpy(chp, spec);                    // filter name (+null)
    chp[lstrlen(chp)+1] = '\0';            // double null at end of list
    /*
     * initialise arguments to dialog proc
     */
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = achFilters;
    ofn.lpstrCustomFilter = (LPSTR)NULL;
    ofn.nMaxCustFilter = 0L;
    ofn.nFilterIndex = 1L;              // first filter pair in list
    achPath[0] = '\0';
    ofn.lpstrFile = achPath;            // we need to get the full path to open
    ofn.nMaxFile = sizeof(achPath);
    ofn.lpstrFileTitle = fn;            // return final elem of name here
    ofn.nMaxFileTitle = sizeof(fn);
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = prompt;            // dialog title is good place for prompt text
    ofn.Flags = OFN_FILEMUSTEXIST |
                OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = ext;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lCustData = 0;

    /*
     * loop until the user cancels, or selects a file that we can open
     */
    do {
        if (!GetOpenFileName(&ofn)) {
            return(FALSE);
        }

        fh = OpenFile(achPath, osp, OF_READ);
        
        if (fh == HFILE_ERROR) {
            if (MessageBox(NULL, "File Could Not Be Opened", "File Open",
                            MB_OKCANCEL|MB_ICONSTOP) == IDCANCEL) {
                return(FALSE);
            }
        }
    } while (fh == HFILE_ERROR);

    _lclose(fh);

    return(TRUE);
}

/***************************************************************************
 * Function: complist_getroot_left
 *
 * Purpose:
 *
 * Gets the root names of the left tree used to build this complist.
 *
 **************************************************************************/
LPSTR
complist_getroot_left(COMPLIST cl)
{
        return( dir_getroot_list(cl->left));
}

/***************************************************************************
 * Function: complist_getroot_right
 *
 * Purpose:
 *
 * Gets the root names of the right tree used to build this complist.
 *
 **************************************************************************/
LPSTR
complist_getroot_right(COMPLIST cl)
{
        return( dir_getroot_list(cl->right));
}
/***************************************************************************
 * Function: complist_freeroot_*
 *
 * Purpose:
 *
 * Frees up memory allocated in a call to complist_getroot*() 
 *
 **************************************************************************/
void
complist_freeroot_left(COMPLIST cl, LPSTR path)
{
        dir_freeroot_list(cl->left, path);
}

void
complist_freeroot_right(COMPLIST cl, LPSTR path)
{
        dir_freeroot_list(cl->right, path);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\compitem.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: COMPITEM.C
*
* Module which does the comparison between two files. 
*
* Functions:
*
* ci_copytext()
* ci_makecomposite()
* ci_compare()
* ci_onesection()
* compitem_new()
* compitem_delete()
* compitem_discardsections()
* compitem_getcomposite()
* compitem_getleftsections()
* compitem_getrightsections()
* compitem_getleftfile()
* compitem_getrightfile()
* compitem_getstate()
* compitem_gettext_tag()
* compitem_gettext_result()
* compitem_getfilename()
* compitem_frefilename()
*
* Comments:
*
* This module uses the structure compitem which is a data type that knows
* about two files, and can compare them. The result of the comparison
* is a list of sections for each file, and a composite list of sections
* representing the comparison of the two files.
*
* A compitem has a state (one of the integer values defined in state.h)
* representing the result of the comparison. It can also be
* queried for the text result (text equivalent of the state) as well
* as the tag - or title for this compitem (usually a text string containing
* the name(s) of the files being compared).
*
* A compitem will supply a composite section list even if the files are
* the same, or if there is only one file. The composite section list will
* only be built (and the files read in) when the compitem_getcomposite()
* call is made (and not at compitem_new time).
* 
*  
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include "gutils.h"
#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"
#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"


struct compitem {

        FILEDATA left;          /* handle for left-hand file */
        FILEDATA right;         /* handle for right-hand file */

        LIST secs_composite;    /* list of sections (composite file)*/
        LIST secs_left;         /* list of sections (left file) */
        LIST secs_right;        /* list of sections (right file) */

        int state;              /* compitem state - result of compare */
        BOOL bDiscard;          /* true if not alloc-ed on list */
        LPSTR tag;              /* text for tag (title of compitem) */
        LPSTR result;           /* text equivalent of state */

};


LPSTR ci_copytext(LPSTR in);
void ci_makecomposite(COMPITEM ci);
void ci_compare(COMPITEM ci);


/***************************************************************************
 * Function: compitem_new
 *
 * Purpose:
 *
 * Returns a handle to a new compitem - given the filenames for the
 * left and right files to be compared. Either left or right or neither
 * (but not both) may be null. In this case we set the state accordingly.
 *
 * The parameters are handles to DIRITEM objects: these allow us to get the
 * the name of the file relative to the compare roots (needed for the tag)
 * and the absolute name of the file (needed for opening the file).
 *
 * Comments:
 *
 * If the list parameter is not null, the List_New* functions are used to
 * allocate memory for the compitem. We remember this (in the bDiscard flag)
 * so we do not delete the compitem if it was allocated on the list.
 *
 * If the list parameter is null, the memory
 * for the compitem is allocated from the gmem_* heap initialised by the app.
 *
 ****************************************************************************/
COMPITEM
compitem_new(DIRITEM leftname, DIRITEM rightname, LIST list, BOOL fExact)
{
        COMPITEM ci;
        LPSTR str1, str2;
        char buf[2*MAX_PATH+20];


        /*
         * Allocate the memory for the compitem, either at the end of the
         * list or in the gmem_* heap.
         */
        if (list == NULL) {
                /* no list passed */
                ci = (COMPITEM) gmem_get(hHeap, sizeof(struct compitem));
                memset(ci, 0, sizeof(struct compitem));
                ci->bDiscard = TRUE;
        } else {
                /* add to end of list */
                ci = (COMPITEM) List_NewLast(list, sizeof(struct compitem));
                ci->bDiscard = FALSE;
        }

        ci->secs_composite = NULL;
        ci->secs_left = NULL;
        ci->secs_right = NULL;

        /*
         * Make a filedata for each of the files that are non-null.
         * Filedata objects are responsible for reading the file and
         * accessing the lines in it. Don't read in the files until we need to.
         */
        if (leftname != NULL) {
                ci->left = file_new(leftname, FALSE);
                if (ci->left == NULL) {
                        return(NULL);
                }
        } else {
                ci->left = NULL;
        }
        if ( rightname != NULL) {
                ci->right = file_new(rightname, FALSE);
                if (ci->right == NULL) {
                        return(NULL);
                }
        } else {
                ci->right = NULL;
        }


        /*
         * See if we have one or two files, and set the state accordingly
         */
        if ( ! ci->left && !ci->right) {
                /* two NULL files - this is wrong */
                return(NULL);
        }


        /* Set the tag (title field) for this item. If the
         * two files have names that match, we use just that name -
         * otherwise we use both names separated by a colon 'left : right'.
         *
         * In both cases, use the names relative to compare root (the
         * names will certainly be different if we compare the abs paths)
         */
        str1 = dir_getrelname(leftname);
        str2 = dir_getrelname(rightname);

        /* If only one file - set name to that */
        if (ci->left == NULL) {
                ci->tag = ci_copytext(str2);
        } else if (ci->right == NULL) {
                ci->tag = ci_copytext(str1);
        } else {
                if (lstrcmpi(str1, str2) == 0) {
                        ci->tag = ci_copytext(str2);
                } else {
                        wsprintf(buf, "%s : %s", str1, str2);
                        ci->tag = ci_copytext(buf);
                }
        }

        dir_freerelname(leftname, str1);
        dir_freerelname(leftname, str2);


        if (ci->left == NULL) {
                str1 = dir_getroot_item(rightname);
                wsprintf(buf, "only in %s", str1);
                dir_freeroot_item(rightname, str1);

                ci->result = ci_copytext(buf);
                ci->state = STATE_FILERIGHTONLY;
        } else if (ci->right == NULL) {
                str1 = dir_getroot_item(leftname);
                wsprintf(buf, "only in %s", str1);
                dir_freeroot_item(leftname, str1);

                ci->result = ci_copytext(buf);
                ci->state = STATE_FILELEFTONLY;
        } else {
                /* two files - are they the same ? compare
                 * the file sizes
                 */


                if (dir_getfilesize(leftname) != dir_getfilesize(rightname)) 
                {
                    ci->state = STATE_DIFFER;
                    ci->result = ci_copytext("different sizes");
                } else if (!fExact){
                    ci->result = ci_copytext("same size");
                    ci->state = STATE_SAME;
                } else {
                    ci->result =  ci_copytext("identical");
                    ci->state = STATE_SAME;
                }
        }


#if FALSE
                if (dir_getfilesize(leftname) == dir_getfilesize(rightname)) {
                    if (  !fExact )
                       {
                        ci->result = ci_copytext("same size etc.");
                        ci->state = STATE_SAME;
                    } else {
                        ci->result = ci_copytext("files differ");
                        ci->state = STATE_DIFFER;
                        ci->result = ci_copytext("files differ");
                     }
                } else {
                        ci->result = ci_copytext("files differ");
                        ci->state = STATE_DIFFER;
                }
        }
#endif

        /*
         * Building the section lists and composite lists can wait
         * until needed.
         */
        return(ci);
} /* compitem_new */

/***************************************************************************
 * Function: compitem_delete
 *
 * Purpose:
 *
 * Deletes a compitem and free all associated data.
 *
 * Comments:
 *
 * If the ci->bDiscard flag is set, the compitem was alloc-ed on a list,
 * and should not be discarded (the list itself will be deleted).
 *
 * The DIRDATA we were passed are not deleted. the filedata, lines
 * and sections are.
 ***************************************************************************/
void
compitem_delete(COMPITEM ci)
{
        if (ci == NULL) {
                return;
        }

        compitem_discardsections(ci);

        /* Delete the two filedatas (and associated line lists) */
        file_delete(ci->left);
        file_delete(ci->right);

        /* text we allocated */
        gmem_free(hHeap, ci->tag, lstrlen(ci->tag) + 1);
        gmem_free(hHeap, ci->result, lstrlen(ci->result) + 1);

        /* Free the compitem struct itself if not alloced on a list */
        if (ci->bDiscard) {
                gmem_free(hHeap, (LPSTR) ci, sizeof(struct compitem));
        }
}


/*
/***************************************************************************
 * Function: compitem_discardsections
 *
 * Purpose:
 *
 * To discard sections - throw away cached information relating to the
 * comparison (but not the files if they are read into memory). This
 * is used to force a re-compare if changes in the comparison options
 * are made
 *
 ***************************************************************************/
void
compitem_discardsections(COMPITEM ci)
{
        /* delete the lists of sections we built */
        if (ci == NULL) {
                return;
        }
        if (ci->secs_composite) {
                section_deletelist(ci->secs_composite);
                ci->secs_composite = NULL;
        }
        if (ci->secs_left) {
                section_deletelist(ci->secs_left);
                ci->secs_left = NULL;
        }
        if (ci->secs_right) {
                section_deletelist(ci->secs_right);
                ci->secs_right = NULL;
        }

        /* reset the line lists to throw away cached hash codes and links */
        if (ci->left != NULL) {
                file_reset(ci->left);
        }
        if (ci->right != NULL) {
                file_reset(ci->right);
        }

}

/***************************************************************************
 * Function: compitem_getcomposite
 *
 * Purpose:
 *
 * To get the handle for the composite section list 
 *
 ***************************************************************************/
LIST
compitem_getcomposite(COMPITEM ci)
{
        if (ci == NULL) {
                return NULL;
        }
        /*
         * do the comparison if we haven't already done it
         */
        if (ci->secs_composite == NULL) {
                ci_makecomposite(ci);
        }

        return(ci->secs_composite);
}

/***************************************************************************
 * Function: compitem_getleftsections
 *
 * Purpose:
 *
 * To get the handle for the list of sections in the left file 
 *
 ***************************************************************************/
LIST
compitem_getleftsections(COMPITEM ci)
{
        if (ci == NULL) {
                return NULL;
        }
        /*
         * do the comparison if we haven't already done it
         */
        if (ci->secs_composite == NULL) {
                ci_makecomposite(ci);
        }

        return(ci->secs_left);
}

/***************************************************************************
 * Function: compitem_getrightsections
 *
 * Purpose:
 *
 * To get the handle for the list of sections in the right file 
 *
 ***************************************************************************/
LIST
compitem_getrightsections(COMPITEM ci)
{
        if (ci == NULL) {
                return NULL;
        }
        /*
         * do the comparison if we haven't already done it
         */
        if (ci->secs_composite == NULL) {
                ci_makecomposite(ci);
        }

        return(ci->secs_right);
}

/***************************************************************************
 * Function: compitem_getleftfile
 *
 * Purpose:
 *
 * To get the handle to the left file itself
 *
 ***************************************************************************/
FILEDATA
compitem_getleftfile(COMPITEM ci)
{
        if (ci == NULL) {
                return(NULL);
        }
        return(ci->left);
}

/***************************************************************************
 * Function: compitem_getrightfile
 *
 * Purpose:
 *
 * To get the handle to the right file itself 
 *
 ***************************************************************************/
FILEDATA
compitem_getrightfile(COMPITEM ci)
{
        if (ci == NULL) {
                return(NULL);
        }
        return(ci->right);
}

/***************************************************************************
 * Function: compitem_getstate
 *
 * Purpose:
 *
 * To get the state (compare result) of this compitem 
 *
 ***************************************************************************/
int
compitem_getstate(COMPITEM ci)
{
        if (ci == NULL) {
                return(0);
        }
        return(ci->state);
}

/***************************************************************************
 * Function: compitem_gettext_tag
 *
 * Purpose:
 *
 * To get the tag (text for the compitem title) 
 *
 ***************************************************************************/
LPSTR
compitem_gettext_tag(COMPITEM ci)
{
        if (ci == NULL) {
                return(NULL);
        }
        return(ci->tag);
}

/***************************************************************************
 * Function: compitem_gettext_result
 *
 * Purpose:
 *
 * To get the result text (text equiv of state) 
 *
 ***************************************************************************/
LPSTR
compitem_gettext_result(COMPITEM ci)
{
        if (ci == NULL) {
                return(NULL);
        }
        return(ci->result);
}

/***************************************************************************
 * Function: compitem_getfilename
 *
 * Purpose:
 *
 * To return the name of the file associated with this compitem. The option
 * argument (one of CI_LEFT, CI_RIGHT, CI_COMP) indicates which file
 * is required.
 *
 * Comments:
 *
 * CI_LEFT and CI_RIGHT just result in calls to dir_getopenname to get
 * an open-able filename.
 *
 * For CI_COMP, we create a temporary file, write out all the text in the
 * composite section list to this file, and then pass the name of the
 * temporary file to the caller. This file will be deleted on
 * the call to compitem_freefilename().
 * 
 ***************************************************************************/
LPSTR
compitem_getfilename(COMPITEM item, int option)
{
        LPSTR fname;
        LINE line;
        LPSTR tag, text;
        SECTION sec;
        OFSTRUCT os;
        int fh;

        if (item == NULL) {
                return(NULL);
        }

        switch(option) {
        case CI_LEFT:
                if (item->left != NULL) {
                        return(dir_getopenname(file_getdiritem(item->left)));
                } else {
                        return(NULL);
                }

        case CI_RIGHT:
                if (item->right != NULL) {
                        return(dir_getopenname(file_getdiritem(item->right)));
                } else {
                        return(NULL);
                }

        case CI_COMP:

                /* caller has asked for the filename of the composite file.
                 * we need to create a temporary file and write the
                 * lines in the composite section list out to it.
                 */
                fname = gmem_get(hHeap, MAX_PATH);
                GetTempPath(MAX_PATH, fname);
                GetTempFileName(fname, "wdf", 0, fname);

                fh = OpenFile(fname, &os, OF_READWRITE|OF_SHARE_DENY_NONE);
                if (fh < 0) {
                        MessageBox(NULL, "Cannot open temp file", "Error", MB_OK | MB_ICONSTOP);
                        return(NULL);
                }

                /* make sure the composite list has been built */

                if (item->secs_composite == NULL) {
                        ci_makecomposite(item);
                }

                /* write out every line in every section on the composite
                 * list to the temp file.
                 */
                List_TRAVERSE(item->secs_composite, sec) {

                        /* get the tag field based on the section state*/
                        switch(section_getstate(sec)) {
                        case STATE_SAME:
                                tag = "    ";
                                break;

                        case STATE_LEFTONLY:
                                tag = " <! ";
                                break;
                        case STATE_RIGHTONLY:
                                tag = " !> ";
                                break;

                        case STATE_MOVEDLEFT:
                                tag = " <- ";
                                break;

                        case STATE_MOVEDRIGHT:
                                tag = " -> ";
                                break;
                        }

                        /* write out each line in this section.
                         * non-standard traverse of list as we only
                         * want to go from section first to section last
                         * inclusive.
                         */
                        for (line = section_getfirstline(sec);
                             line != NULL;
                             line = List_Next(line) ) {

                                text = line_gettext(line);

                                /* write out to file */
                                _lwrite(fh, tag, lstrlen(tag));
                                _lwrite(fh, text, lstrlen(text));

                                if (line == section_getlastline(sec)) {
                                        break;
                                }
                        }
                }

                /* now close the file and return its name */
                _lclose(fh);
                return(fname);


        default:
                MessageBox(NULL, "Bad argument", "Error", MB_OK | MB_ICONSTOP);
                return(NULL);
        }
}

/***************************************************************************
 * Function: compitem_freefilename
 *
 * Purpose:
 *
 * Free memory created by a call to compitem_getfilename. If a temporary
 * file was created, this may cause it to be deleted. The option argument must
 * be the same as passed to the original compitem_getfilename call.
 *
 * If we created a temporary file for CI_COMP, then delete it; otherwise,
 * just pass the name to dir_freeopenname.
 *
 ***************************************************************************/
void
compitem_freefilename(COMPITEM item, int option, LPSTR filename)
{
        OFSTRUCT os;


        if ((item == NULL) || (filename == NULL)) {
                return;
        }

        switch(option) {

        case CI_LEFT:
                dir_freeopenname(file_getdiritem(item->left), filename);
                break;

        case CI_RIGHT:
                dir_freeopenname(file_getdiritem(item->right), filename);
                break;

        case CI_COMP:

                /* this is a temporary file we created. Delete it. */
                OpenFile(filename, &os, OF_DELETE);

                gmem_free(hHeap, filename, MAX_PATH);
                break;
        }
}


/***************************************************************************
 * Function: ci_copytext
 *
 * Purpose:
 *
 * To alloc a buffer large enough for the text string and copy the text into
 * it and return a pointer to the string.
 *
 ***************************************************************************/
LPSTR
ci_copytext(LPSTR in)
{
        LPSTR out;

        if (in == NULL) {
                out = gmem_get(hHeap, 1);
                out[0] = '\0';
        } else {
                out = gmem_get(hHeap, lstrlen(in) + 1);
                lstrcpy(out, in);
        }
        return(out);
}

/***************************************************************************
 * Function: ci_onesection
 *
 * Purpose:
 *
 * To make a list containing a single section from the whole list of lines 
 *
 ***************************************************************************/
LIST
ci_onesection(FILEDATA file)
{
        LIST lines;
        LIST sections;
        SECTION section;

        lines = file_getlinelist(file);

        /* create a null list */
        sections = List_Create();

        /* tell the section to create itself on the end of this list. */
        section = section_new(List_First(lines), List_Last(lines), sections);
        section_setstate(section, STATE_SAME);


        return(sections);
}



/***************************************************************************
 * Function: ci_makecomposite
 *
 * Purpose:
 *
 * Compare the two files and build the composite list. This function is
 * called whenever we need one of the section lists and only does the 
 * comparison if the composite list does not already exist.
 *
 ***************************************************************************/
void
ci_makecomposite(COMPITEM ci)
{
        if (ci->secs_composite != NULL) {
                return;
        }

        /* if there is only one file, make a single item list
         * of sections
         */
        if (ci->left == NULL) {
                ci->secs_left = NULL;
                ci->secs_right = ci_onesection(ci->right);

                /* make a second list, not a pointer to the first
                 * or we will get confused when deleting
                 */
                ci->secs_composite = ci_onesection(ci->right);
                return;
        } else if (ci->right == NULL) {
                ci->secs_right = NULL;
                ci->secs_left = ci_onesection(ci->left);

                /* make a second list, not a pointer to the first
                 * or we will get confused when deleting
                 */
                ci->secs_composite = ci_onesection(ci->left);
                return;
        }

        /* we have two files - we need to compare them fully */
        ci_compare(ci);
}

/***************************************************************************
 * Function: ci_compare
 *
 * Purpose:
 *
 * Compare files and build a composite list.
 *
 * Comments:
 *
 * Comparison method:
 *
 *    0   Break each file into lines and hash each line.  Lines which 
 *        don't match can be rapidly eliminated by comparing the hash code.
 *
 *        Store the hash codes in a binary search tree that
 *        will give for each hash code the number of times that it
 *        occurred in each file and one of the lines where it occurred
 *        in each file.  The tree is used to rapidly find the partner
 *        of a line which occurs exactly once in each file.
 *
 *    1   Make a section covering the whole file (for both)
 *        and link unique lines between these sections (i.e. link lines
 *        which occur exactly once in each file as they must match each other).
 *        These are referred to as anchor points.
 *
 *    2   Build section lists for both files by traversing line lists and
 *        making a section for each set of adjacent lines that are unmatched
 *        and for each set of adjacent lines that match a set of adjacent
 *        lines in the other file.  In making a section we start from a
 *        known matching line and work both forwards and backwards through
 *        the file including lines which match, whether they are unique or not.
 *
 *    3   Establish links between sections that match
 *        and also between sections that don't match but do
 *        correspond (by position in file between matching sections)
 *
 *    4   For each section pair that don't match but do correspond,
 *        link up matching lines unique within that section.  (i.e. do
 *        the whole algorithm again on just this section).
 *
 *    There may be some lines which occur many times over in each file.
 *    As these occurrences are matched up, so the number left to match
 *    reduces, and may reach one in each file.  At this point these two
 *    can be matched.  Therefore we...
 *
 *    Repeat steps 0-4 until no more new links are added, but (especially
 *    in step 0) we only bother with lines which have not yet been matched.
 *    This means that a line which has only one unmatched instance in each
 *    file gets a count of one and so is a new anchor point.
 *
 *    Finally build a composite list from the two lists of sections.
 *
 ***************************************************************************/
void
ci_compare(COMPITEM ci)
{
        LIST lines_left, lines_right;
        SECTION whole_left, whole_right;
        BOOL bChanges;

        /* get the list of lines for each file */
        lines_left = file_getlinelist(ci->left);
        lines_right = file_getlinelist(ci->right);

        if ((lines_left == NULL) || (lines_right == NULL)) {
                ci->secs_left = NULL;
                ci->secs_right = NULL;
                ci->secs_composite = NULL;
                return;
        }

        do {

                /* we have made no changes so far this time round the
                 * loop
                 */
                bChanges = FALSE;

                /* make a section covering the whole file */
                whole_left = section_new(List_First(lines_left),
                                         List_Last(lines_left), NULL);

                whole_right = section_new(List_First(lines_right),
                                         List_Last(lines_right), NULL);

                /* link up matching unique lines between these sections */
                if (section_match(whole_left, whole_right)) {
                        bChanges = TRUE;
                }

                /* delete the two temp sections */
                section_delete(whole_left);
                section_delete(whole_right);

                /* discard previous section lists if made */
                if (ci->secs_left) {
                        section_deletelist(ci->secs_left);
                        ci->secs_left = NULL;
                }
                if (ci->secs_right) {
                        section_deletelist(ci->secs_right);
                        ci->secs_right = NULL;
                }
                /* build new section lists for both files */
                ci->secs_left = section_makelist(lines_left, TRUE);
                ci->secs_right = section_makelist(lines_right, FALSE);

                /* match up sections - make links and corresponds between
                 * sections. Attempts to section_match corresponding
                 * sections that are not matched. returns true if any
                 * further links were made
                 */
                if (section_matchlists(ci->secs_left, ci->secs_right)) {
                        bChanges = TRUE;
                }

        /* repeat as long as we keep adding new links */

        } while (bChanges);

        /* all possible lines linked, and section lists made .
         * combine the two section lists to get a view of the
         * whole comparison - the composite section list. This also
         * sets the state of each section in the composite list.
         */
        ci->secs_composite = section_makecomposite(ci->secs_left, ci->secs_right);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\bar.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: BAR.C
*
* This module contains functions for bar window 
* graphically showing two lists of sections and showing 
* colored vertical bars for the sections of text,
* with linking lines for the sections that are the same.
*
* Functions:
*
* BarWndProc()
* BarPaint()
* DrawSection()
* DrawLink()
* BarClick() 
* InitBarClass()
* BarDrawPosition()
* 
* Comments:
*
****************************************************************************/

#include <windows.h>
#include <commdlg.h>

#include "gutils.h"
#include "table.h"
#include "state.h"
#include "wdiffrc.h"
#include "windiff.h"
#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "view.h"


long APIENTRY BarWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam);
void BarPaint(HWND hwnd);
void DrawSection(HDC hdc, int cx, int cy, int lines, SECTION sec, int sidecode);
void DrawLink(HDC hdc, int cx, int cy, int lines, SECTION sec);
void BarClick(HWND hwnd, int x, int y);


HPEN hpenSame, hpenLeft, hpenRight;
HBRUSH hbrSame, hbrLeft, hbrRight;
HBRUSH hbrSideBar;


/***************************************************************************
 * Function: InitBarClass
 *
 * Purpose:
 *
 * Create bar window class
 */
BOOL
InitBarClass(HINSTANCE hInstance)
{
        WNDCLASS    wc;
        BOOL resp;



        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = BarWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInstance;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszClassName = "BarClass";
        wc.lpszMenuName = NULL;

        resp = RegisterClass(&wc);

        return(resp);
}



/***************************************************************************
 * Function: BarWndProc
 *
 * Purpose:
 *
 * Window procedure supporting bar window
 *
 */

long APIENTRY
BarWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam)
{

        switch(message) {


        case WM_CREATE:

                hpenSame = CreatePen(PS_SOLID, 1, RGB(0,0,0));
                hbrSame = CreateSolidBrush(RGB(255,255,255));

                hpenLeft = CreatePen(PS_SOLID, 1, rgb_barleft);
                hbrLeft = CreateSolidBrush(rgb_barleft);

                hpenRight = CreatePen(PS_SOLID, 1, rgb_barright);
                hbrRight = CreateSolidBrush(rgb_barright);

                hbrSideBar = CreateSolidBrush(rgb_barcurrent);
                break;

        case WM_DESTROY:
                DeleteObject(hpenSame);
                DeleteObject(hpenLeft);
                DeleteObject(hpenRight);
                DeleteObject(hbrSame);
                DeleteObject(hbrLeft);
                DeleteObject(hbrRight);
                DeleteObject(hbrSideBar);
                break;

        case WM_PAINT:
                BarPaint(hWnd);
                break;

        case WM_LBUTTONDOWN:
                BarClick(hWnd, LOWORD(lParam), HIWORD(lParam));
                break;

        default:
                return(DefWindowProc(hWnd, message, wParam, lParam));
        }
        return 0;
}

/***************************************************************************
 * Function: BarDrawPosition
 *
 * Purpose:
 *
 * Draw the current position as side-bars down the bar window,
 * showing which lines from each file are currently in view. HDC can be
 * NULL (we get one ourselves if so). If bErase is true, we clear
 * the previous side-bars first.
 *
 * This is called from BarPaint when we paint the whole window, and
 * from TableServer() whenever it receives a TQ_SCROLL notification that
 * the table window has been scrolled.
 */
void
BarDrawPosition(HWND hwndBar, HDC hdcIn, BOOL bErase)
{
        HDC hdc;
        int total_lines, cy, cx;
        RECT rc, rcLeft, rcRight;
        VIEW view;
        COMPITEM item;
        LIST listleft, listright;
        long toprow, endrow, i;
        int left_first, left_last, right_first, right_last, linenr;


        /* get a hdc if we weren't given one */
        if (hdcIn == NULL) {
                hdc = GetDC(hwndBar);
        } else {
                hdc = hdcIn;
        }

        /* set horz position of bars */
        GetClientRect(hwndBar, &rc);
        cx = (int)(rc.right - rc.left);
        cy = (int)(rc.bottom - rc.top);

        /* layout constants are defined as percentages of window width */
        rcLeft.left = cx * L_POS_START / 100;
        rcRight.left = cx * R_POS_START / 100;
        rcLeft.right = rcLeft.left +  (cx * L_POS_WIDTH / 100);
        rcRight.right = rcRight.left +  (cx * R_POS_WIDTH / 100);

        /* erase the whole marker section if requested */
        if (bErase) {
                rcLeft.top = rc.top;
                rcLeft.bottom = rc.bottom;
                rcRight.top = rc.top;
                rcRight.bottom = rc.bottom;

                FillRect(hdc, &rcLeft, GetStockObject(WHITE_BRUSH));

                FillRect(hdc, &rcRight, GetStockObject(WHITE_BRUSH));
        }


        /*
         * calculate the vertical scaling - depends on the
         * total number of lines shown
         */

        /* get the handles to the two lists of sections */
        view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);
        /* make sure we are in expand mode */
        if (view_isexpanded(view) == FALSE) {
                /* get rid of the dc if we made it ourselves */
                if (hdcIn == NULL) {
                        ReleaseDC(hwndBar, hdc);
                }
                return;
        }

        item = view_getitem(view, 0);

        listleft = compitem_getleftsections(item);
        listright = compitem_getrightsections(item);

        /* if there is only one list of sections, draw nothing. The
         * picture for a single file is not very exciting.
         */

        if ((listleft == NULL) || (listright == NULL)) {
                /* get rid of the dc if we made it ourselves */
                if (hdcIn == NULL) {
                        ReleaseDC(hwndBar, hdc);
                }
                return;
        }

        /* take the longest of the two files and use this
         * for vertical scaling. the scale is such that the longest file
         * *just fits*.
         */
        total_lines = line_getlinenr(section_getlastline(List_Last(listleft)));
        total_lines = max(total_lines,
                       (int) line_getlinenr(section_getlastline(List_Last(listright))));


        /* get the current top row and nr of rows visible */
        toprow = SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);
        endrow = SendMessage(hwndRCD, TM_ENDROW, FALSE, 0);
        endrow = min(endrow, view_getrowcount(view)-1);



        /*
         * find the first and last line nrs from each file currently visible.
         *
         */
        left_first = left_last = right_first = right_last = 0;

        for (i = toprow; i <= endrow; i++) {
                linenr = view_getlinenr_left(view, i);

                if (linenr > 0) {

                        if (left_first == 0) {
                                left_first = linenr;
                        }
                        left_first = min(left_first, linenr);
                        left_last = max(left_last, linenr);
                }

                linenr = view_getlinenr_right(view, i);
                if (linenr > 0) {
                        if (right_first == 0) {
                                right_first = linenr;
                        }
                        right_first = min(right_first, linenr);
                        right_last = max(right_last, linenr);
                }

        }

        /* draw the two markers as thick bars -> elongated rectangles */
        rcLeft.top = MulDiv(left_first-1, cy, total_lines);
        rcLeft.bottom = MulDiv(left_last, cy, total_lines);
        FillRect(hdc, &rcLeft, hbrSideBar);

        rcRight.top = MulDiv(right_first-1, cy, total_lines);
        rcRight.bottom = MulDiv(right_last, cy, total_lines);
        FillRect(hdc, &rcRight, hbrSideBar);

        /* get rid of the dc if we made it ourselves */
        if (hdcIn == NULL) {
                ReleaseDC(hwndBar, hdc);
        }

}


/***************************************************************************
 * Function: BarPaint
 *
 * Purpose:
 *
 * Paint the bar window 
 */
void
BarPaint(HWND hwnd)
{
        PAINTSTRUCT ps;
        HDC hdc;
        VIEW view;
        COMPITEM item;
        LIST listleft, listright;
        SECTION sec;
        int total_lines, cx, cy;
        RECT rc;

        hdc = BeginPaint(hwnd, &ps);

        /* draw a separator line at the very edge of the window */
        GetClientRect(hwnd, &rc);
        MoveToEx(hdc, (int)(rc.right-1), rc.top, NULL);
        LineTo(hdc, (int)(rc.right-1), rc.bottom);


        /* first gather information about what is to be displayed */

        /* find the total lines (for horz. scaling) */

        /* get the handles to the two lists of sections */
        view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);

        /* make sure we are in expand mode */
        if (view_isexpanded(view) == FALSE) {
                return;
        }

        item = view_getitem(view, 0);

        listleft = compitem_getleftsections(item);
        listright = compitem_getrightsections(item);

        /*
         * don't bother if there is only one list - not very interesting
         */
        if ((listleft == NULL) || (listright == NULL)) {
                EndPaint(hwnd, &ps);
                return;
        }

        /* take the longest of the two files and use this
         * for vertical scaling. the scale is such that the longest file
         * *just fits*.
         */
        total_lines = (int) line_getlinenr(section_getlastline(List_Last(listleft)));
        total_lines = max(total_lines,
                       (int) line_getlinenr(section_getlastline(List_Last(listright))));



        /* horizontal spacing:
         *
         * there are two columns, for the left and right files, and a gap
         * between them criss-crossed by lines marking the links.
         *
         * Each of the columns then has three sections, for the
         * position marker, the different sections
         * and the linked sections. The width and positions of these items
         * are defined (in windiff.h) as percentages of the window width.
         */

        cx = (int)(rc.right - rc.left);
        cy = (int)(rc.bottom - rc.top);


        /* draw all the left sections and links */
        List_TRAVERSE(listleft, sec) {
                DrawSection(hdc, cx, cy, total_lines, sec, STATE_LEFTONLY);

                if (section_getlink(sec) != NULL) {
                        DrawLink(hdc, cx, cy, total_lines, sec);
                }
        }

        /* draw all the right sections */
        List_TRAVERSE(listright, sec) {
                DrawSection(hdc, cx, cy, total_lines, sec, STATE_RIGHTONLY);
        }



        /* now draw current position markers */
        BarDrawPosition(hwnd, hdc, FALSE);

        EndPaint(hwnd, &ps);
}

/***************************************************************************
 * Function: DrawSection
 *
 * Purpose:
 *
 * Paint a single section 
 */
void
DrawSection(HDC hdc, int cx, int cy, int lines, SECTION sec, int sidecode)
{
        int x1, y1, x2, y2;
        HPEN hpenOld;
        HBRUSH hbrOld;

        /* calculate the vertical position from the scaling. the scaling
         * is such that the longest file just fits
         */
        y1 = MulDiv(line_getlinenr(section_getfirstline(sec))- 1, cy, lines);
        y2 = MulDiv(line_getlinenr(section_getlastline(sec)), cy, lines);


        /* left or right  - set bar position and width*/
        if (sidecode == STATE_LEFTONLY) {
                if (section_getlink(sec) != NULL) {
                        x1 = L_MATCH_START;
                        x2 = L_MATCH_WIDTH;
                } else {
                        x1 = L_UNMATCH_START;
                        x2 = L_UNMATCH_WIDTH;
                }
        } else {
                if (section_getlink(sec) != NULL) {
                        x1 = R_MATCH_START;
                        x2 = R_MATCH_WIDTH;
                } else {
                        x1 = R_UNMATCH_START;
                        x2 = R_UNMATCH_WIDTH;
                }
        }
        /* bar position defines are in percentages of the win width (cx) */
        x1 = cx * x1 / 100;
        x2 = (cx * x2 / 100) + x1;


        /* select pens and brushes */
        if (section_getlink(sec) != NULL) {
                hpenOld = SelectObject(hdc, hpenSame);
                hbrOld = SelectObject(hdc, hbrSame);
        } else if (sidecode == STATE_LEFTONLY) {
                hpenOld = SelectObject(hdc, hpenLeft);
                hbrOld = SelectObject(hdc, hbrLeft);
        } else {
                hpenOld = SelectObject(hdc, hpenRight);
                hbrOld = SelectObject(hdc, hbrRight);
        }

        /* draw the section as a coloured elongated rectangle */
        Rectangle(hdc, x1, y1, x2, y2);

        /* de-select the pen and brush in favour of the default */
        SelectObject(hdc, hpenOld);
        SelectObject(hdc, hbrOld);

}

/***************************************************************************
 * Function: DrawLink
 *
 * Purpose:
 *
 * Draw a line linking two sections. Indicates a section from each
 * file that match each other. psec points to the section in the
 * left file.
 */
void
DrawLink(HDC hdc, int cx, int cy, int lines, SECTION sec)
{
        int x1, y1, x2, y2;
        int ybase, yrange;
        SECTION other;

        other = section_getlink(sec);

        /* position the link line halfway down the section
         * - allow for the case where
         * the section is one line (ie halve the co-ords, not the line nr)
         */
        ybase = MulDiv(line_getlinenr(section_getfirstline(sec)) - 1, cy, lines);
        yrange = MulDiv(line_getlinenr(section_getlastline(sec)), cy, lines);
        y1 = ((yrange - ybase) / 2) + ybase;

        ybase = MulDiv(line_getlinenr(section_getfirstline(other)) - 1, cy, lines);
        yrange = MulDiv(line_getlinenr(section_getlastline(other)), cy, lines);
        y2 = ((yrange - ybase) / 2) + ybase;

        /* horizontal layout constants are defined as percentages of the
         * window width
         */
        x1 = cx * (L_MATCH_START + L_MATCH_WIDTH) / 100;
        x2 = cx * R_UNMATCH_START / 100;

        MoveToEx(hdc, x1, y1, NULL);
        LineTo(hdc, x2, y2);
}


/***************************************************************************
 * Function: BarClick
 *
 * Purpose:
 *
 * The user has clicked on the bar window. Translate the clicked position into
 * a line in one of the files if possible, and scroll the table window to
 * show that line.
 */
void
BarClick(HWND hwnd, int x, int y)
{
        RECT rc;
        int xleft, xright;
        int linenr, i, this;
        BOOL bIsLeft;
        int tot_left, tot_right, total_lines;
        LIST listleft, listright;
        VIEW view;
        COMPITEM item;
        TableSelection select;


        /* find size of the window to get horz scaling, and see
         * where click was
         */
        GetClientRect(hwnd, &rc);

        /* was it near either of the bars ? */

        /* horz positioning is in percentages of window width */
        xleft = max(L_UNMATCH_START + L_UNMATCH_WIDTH,
                     L_MATCH_START + L_MATCH_WIDTH);
        xright = min(R_UNMATCH_START, R_MATCH_START);
        xleft = xleft * (rc.right - rc.left) / 100;
        xright = xright * (rc.right - rc.left) / 100;


        if (x < xleft) {
                bIsLeft = TRUE;
        } else if (x > xright) {
                bIsLeft = FALSE;
        } else {
                /* click was between the two bars - ignore it */
                return;
        }


        /* calculate the vertical scaling (based on total lines displayed)
         * so that we can convert the y position into a line nr
         */

        /* get the handles to the two lists of sections */
        view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);

        /* make sure we are in expand mode */
        if (view_isexpanded(view) == FALSE) {
                return;
        }

        item = view_getitem(view, 0);

        listleft = compitem_getleftsections(item);
        listright = compitem_getrightsections(item);

        /* ignore the click if only one list of sections, since in
         * this case there is nothing drawn for him to click on.
         */
        if ((listleft == NULL) || (listright == NULL)) {
                return;
        }

        /* take the longest of the two files and use this
         * for vertical scaling. the scale is such that the longest file
         * *just fits*.
         */
        tot_left = line_getlinenr(section_getlastline(List_Last(listleft)));
        tot_right = line_getlinenr(section_getlastline(List_Last(listright)));

        total_lines = max(tot_left, tot_right);


        /* convert vertical position into a line nr. The vertical scaling
         * can be calculated from knowing that the longest list of
         * lines just fits in the window.
         */
        linenr = (int) (((long) total_lines * y) / (rc.bottom - rc.top)) + 1;

        /* check that the line is valid */
        if (bIsLeft) {
                if (linenr > tot_left) {
                        return;
                }
        } else {
                if (linenr > tot_right) {
                        return;
                }
        }

        /* search the current view, looking for a row with this
         * line nr on the correct side
         */
        for (i = 0; i < view_getrowcount(view); i++) {
                if (bIsLeft) {
                        this = view_getlinenr_left(view,i);
                } else {
                        this = view_getlinenr_right(view,i);
                }

                if (linenr == this) {
                        /* found the matching line- select it in the
                         * table window
                         */
                        select.startrow = i;
                        select.startcell = 0;
                        select.nrows = 1;
                        select.ncells = 1;
                        SendMessage(hwndRCD, TM_SELECT, 0, (long) (LPSTR)&select);
                        return;
                }
        }

        windiff_UI(TRUE);
        MessageBox(hwndClient, "Line not visible in this view",
                "WinDiff", MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\file.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: FILE.C
*
* An object representing a file and the lines of text it contains.
*
* Functions:
*
* file_new()
* file_getdiritem()
* file_delete()
* file_getlinelist()
* file_discardlines()
* file_reset()
* file_readlines()
*
* Comments:
*
* A FILEDATA object is initialised with a DIRITEM handle from which it
* can get a filename. It knows how to supply a list of LINE handles for the
* lines of text in the file.
*
* The file is read into memory optionally on creation of the FILEDATA object:
* otherwise, at the first call to file_getlinelist. It can be discarded
* by calling file_discardlines: in this case, it will be re-read next time
* file_getlinelist is called.
*
* Calling file_reset will cause line_reset to be called for all lines
* in the list. This clears any links.
*
* We allocate all memory from a gmem* heap hHeap, assumed to be declared and
* initialised elsewhere.
*
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include "gutils.h"
#include "windiff.h"
#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"

extern HANDLE hHeap;

struct filedata {

        DIRITEM diritem;        /* handle to file name information */
        LIST lines;             /* NULL if lines not read in */
};


void file_readlines(FILEDATA fd);

/****************************************************************************
 * Function: file_new
 *
 * Purpose:
 * 
 * Creates a new FILEDATA, based on a DIRITEM. the filedata will retain
 * the diritem handle for use in fetching filenames and handles.
 *
 * If the bRead is set, the file will be read into memory. If not, this
 * will be done during the first call to file_getlines.
 *
 ***************************************************************************/
FILEDATA
file_new(DIRITEM fiName, BOOL bRead)
{
        FILEDATA fd;

        fd = (FILEDATA) gmem_get(hHeap, sizeof(struct filedata));
        if (fd == NULL) {
                return(NULL);
        }

        fd->diritem = fiName;
        fd->lines = NULL;

        if (bRead) {
                file_readlines(fd);
        }

        return(fd);
}

/****************************************************************************
 * Function: file_getdiritem
 *
 * Purpose:
 * 
 * Returns a handle to the DIRITEM used to create this FILEDATA
 *
 ***************************************************************************/
DIRITEM
file_getdiritem(FILEDATA fd)
{
        if (fd == NULL) {
                return(NULL);
        }

        return(fd->diritem);
}


/****************************************************************************
 * Function: file_delete
 *
 * Purpose:
 * 
 * Deletes a filedata and its associated list of lines. Note that the diritem
 * is not deleted (this is owned by the DIRLIST, and will be deleted
 * when the DIRLIST is deleted)
 *
 ***************************************************************************/
void
file_delete(FILEDATA fd)
{
        if (fd == NULL) {
                return;
        }

        /* throw away the line list, if there is one */
        file_discardlines(fd);

        gmem_free(hHeap, (LPSTR) fd, sizeof(struct filedata));
}

/****************************************************************************
 * Function: file_getlinelist
 *
 * Purpose:
 * 
 * Returns a handle to a list of lines in this file. The items in the
 * list are LINE handles.
 *
 * The first call to this function will cause the file to be read into
 * memory if bRead was FALSE on the call to file_new, or if file_discardlines
 * has since been called.
 *
 * The list of lines returned should not be deleted except by calls to
 * file_delete or file_discardlines.
 *
 ***************************************************************************/
LIST
file_getlinelist(FILEDATA fd)
{
        if (fd == NULL) {
                return NULL;
        }

        if (fd->lines == NULL) {
                file_readlines(fd);
        }
        return(fd->lines);
}


/****************************************************************************
 * Function: file_discardlines
 *
 * Purpose:
 * 
 * Discards the list of lines associated with a file. This will cause
 * the file to be re-read next time file_getlinelist is called.
 *
 ***************************************************************************/
void
file_discardlines(FILEDATA fd)
{
        LINE line;

        if (fd == NULL) {
                return;
        }

        if (fd->lines != NULL) {

                /* clear each line to free any memory associated
                 * with them, then discard the entire list
                 */
                List_TRAVERSE(fd->lines, line) {
                        line_delete(line);
                }
                List_Destroy(&fd->lines);
        }

        /* this is probably done in List_Destroy, but better do it anyway*/
        fd->lines = NULL;
}


/****************************************************************************
 * Function: file_reset
 *
 * Purpose:
 * 
 * Forces a reset of each line in the list. The function line_reset discards 
 * links between lines, and any hashcode information. This would be used if
 * the compare options or hashcode options have changed.
 *
 ***************************************************************************/
void
file_reset(FILEDATA fd)
{
        LINE line;

        if (fd == NULL) {
                return;
        }

        if (fd->lines != NULL) {

                List_TRAVERSE(fd->lines, line)  {
                        line_reset(line);
                }
        }
}


/****************************************************************************
 * Function: file_readlines
 *
 * Purpose:
 * 
 * Reads the file into a list of lines.
 *
 * Comments:
 *
 * We use the buffered read functions to read a block at a time, and
 * return us a pointer to a line within the block. The line we are
 * pointed to is not null terminated. from this we do a line_new: this
 * will make a copy of the text (since we want to re-use the buffer), and
 * will null-terminate its copy.
 *
 *
 ***************************************************************************/
void
file_readlines(FILEDATA fd)
{
        LPSTR textp;
        int fh;
        FILEBUFFER fbuf;
        int linelen;
        int linenr = 1;
        HCURSOR hcurs;

        hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

        /* open the file */
        fh = dir_openfile(fd->diritem);

        if (fh < 0) {
                SetCursor(hcurs);
                return;
        }
        /* initialise the file buffering */
        fbuf = readfile_new(fh);


        /* make an empty list for the files */
        fd->lines = List_Create();

        while ( (textp = readfile_next(fbuf, &linelen)) != NULL) {

                line_new(textp, linelen, linenr++, fd->lines);

        }

        /* close filehandle and free buffer */
        readfile_delete(fbuf);

        dir_closefile(fd->diritem, fh);

        SetCursor(hcurs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\gutilres.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by GUTILS.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\gbit.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: GBIT.C
*
* Bitmap allocation routines to manage a bit-mapped free list, and find
* free sections.
*
* Functions:
*
* gbit_set()
* gbit_init()
* gbit_alloc()
* gbit_free()
* gbit_findfree()
*
* Comments:
*
* Each map is an array of unsigned longs where bit 0 of the first 
* long represents block 1.
*
****************************************************************************/

#include <windows.h>
#include "gutils.h"


BOOL gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set);

/***************************************************************************
 * Function: gbit_init
 *
 * Purpose:
 *
 * Initialise a pre-allocated map of ulongs to represent a free
 * area of nblks
 */
void APIENTRY
gbit_init(DWORD FAR * map, long nblks)
{
        long i;
        long leftover = nblks % 32;
        long blks = nblks / 32;
        DWORD last = 0;

        for (i=0; i < blks; i++) {
                map[i] = 0xffffffff;
        }
        for (i = 0; i < leftover; i++) {
                last = (last << 1) | 1;
        }
        if(leftover)
                map[blks] = last;
}

/***************************************************************************
 * Function: gbit_alloc
 *
 * Purpose:
 *
 * Mark a region starting at blknr for nblks, as busy (ie 0) 
 */
BOOL APIENTRY
gbit_alloc(DWORD FAR * map, long blknr, long nblks)
{
        return(gbit_set(map, blknr, nblks, FALSE));
}


/***************************************************************************
 * Function: gbit_set
 *
 * Purpose:
 *
 * Mark region - if op_set, to 1s, otherwise to 0s 
 */
BOOL
gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set)
{
        long first;
        long last;
        long fullwords;
        long startbit, startword;
        long i;
        DWORD dword = 0;

        blknr--;
        first = min(32 - (blknr % 32), nblks);
        nblks -= first;
        last = nblks % 32;
        fullwords = (nblks - last) / 32;
        
        startword = blknr / 32;
        startbit = blknr % 32;
        for (i = 0; i < first; i++) {
                dword = (dword << 1) | 1;
        }
        dword <<= startbit;
        if (op_set) {
                map[startword] |= dword;
                dword = 0xffffffff;
        } else {
                map[startword] &= ~dword;
                dword = 0;
        }
        startword++;
        for (i = 0; i < fullwords; i++) {
                map[startword+i] = dword;
        }
        startword += fullwords;
        for(i = 0, dword = 0; i < last; i++) {
                dword = (dword << 1) | 1;
        }
        if (last) {
                if (op_set) {
                        map[startword] |= dword;
                } else {
                        map[startword] &= ~dword;
                }
        }

        return(TRUE);
}

/***************************************************************************
 * Function: gbit_free
 *
 * Purpose:
 *
 * Mark region of nblks starting at blknr to 0s - ie not busy 
 */
BOOL APIENTRY
gbit_free(DWORD FAR * map, long blknr, long nblks)
{
        return(gbit_set(map, blknr, nblks, TRUE));
}


/***************************************************************************
 * Function: gbit_findfree
 *
 * Purpose:
 *
 * Find a free segment (ie contiguous sequence of 1s) of nblks in length.
 * If not found, find longest sequence. Store address of segment in *blknr.
 *
 * Return value is nr of blks in sequence found. Region is *not* marked busy.
 */
long APIENTRY
gbit_findfree(DWORD FAR* map, long nblks, long mapsize, long FAR * blknr)
{
        long curblk, startblk, len, i;
        long startbit, nfull, nlast, nbitsleft;
        DWORD mask;
        long mapblks = (mapsize + 31) / 32;
        long aubegin = 0, aulen = 0;
        long curbit = 0;

        /* main loop looking at segments */
        for (curblk = 0; curblk < mapblks; ) {
loop:
                /* loop finding first 1 */
                for (; curblk < mapblks; curblk++, curbit = 0) {
                        if (map[curblk] > 0) {
                                break;
                        }
                }
                if (curblk >= mapblks) 
                        break;
                
                /* find first 1 in this long */
                startblk = curblk;
                for (mask = 1, i = 0; i < curbit; i++) {
                        mask <<= 1;
                }
                for(; curbit < 32; curbit++, mask <<= 1) {
                        if (map[curblk] & mask) {
                                break;
                        }
                } 
                if (curbit >= 32) {
                        /* abandon this word - start again with next word */
                        curblk++;
                        curbit = 0;
                        goto loop;
                }

                /* we've now found a 1 - calc remaining
                 * bits in this word, complete words etc required.
                 */
                startbit = curbit;
                nbitsleft = min( (32 - curbit), nblks);
                nfull = (nblks - nbitsleft) / 32;
                nlast = (nblks - nbitsleft) % 32;

                /* check for required sequence within this word */

                for (i = 0; i < nbitsleft; i++, curbit++, mask <<= 1) {
                        if ((map[curblk] & mask) == 0) {
                                /* abandon and start again - start
                                 * next pass at curbit in same word
                                 */
                                /* store free region if longest yet */
                                if (i > aulen) {
                                        aulen = i;
                                        aubegin = curblk * 32 + startbit +1;
                                }
                                goto loop;
                        }
                }
                
                /* check for nfull full words */
                for (curblk++; curblk <= startblk + nfull; curblk++) {
                        if (curblk >= mapblks) {
                                /* end of map - abandon here and exit at top
                                 * of loop
                                 */
                                len = nbitsleft +
                                        ((curblk - (startblk + 1)) * 32);
                                if (len > aulen) {
                                        aubegin = startblk * 32 + startbit + 1;
                                        aulen = len;
                                }
                                goto loop;
                        }
                        if (map[curblk] != 0xffffffff) {
                                /* not a full word - start again at this bit */
                                len = 0;
                                curbit = 0;
                                for (mask = 1; mask & map[curblk]; mask <<= 1) {
                                        len++;
                                        curbit++;
                                }
                                len += nbitsleft +
                                        (curblk - (startblk+ 1)) * 32;
                                if (len > aulen) {
                                        aulen = len;
                                        aubegin = startblk * 32 + startbit + 1;
                                }
                                /* continue with current blk, bit */
                                goto loop;
                        }
                }

                /* left-over bits required in last word */
                mask = 1;
                for (curbit = 0; curbit < nlast;  curbit++, mask <<= 1) {
                        if ((map[curblk] & mask) == 0) {
                                len = nbitsleft + (nfull * 32);
                                len += curbit;
                                if (len > aulen) {
                                        aulen = len;
                                        aubegin = startblk * 32 + startbit + 1;
                                }
                                goto loop;
                        }
                }
                /* ok - found a block big enough! */
                aubegin = startblk * 32 + startbit + 1;
                *blknr = aubegin;
                return(nblks);
        }

        /* end of map - return longest sequence */
        *blknr = aubegin;
        return(aulen);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\gmem.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: GMEM.C
*
* Memory utility functions.
*
* Functions:
*
* gmem_panic()
* gmem_init()
* gmem_get()
* gmem_free()
* gmem_freeall()
*
* Comments:
*
* Global heap functions - allocate and free many small
* pieces of memory by calling global alloc for large pieces
* and breaking them up. A heap contains a critical section, so
* multiple simultaneous calls to gmem_get and gmem_free will be
* protected.
*
* gmem_freeall should not be called until all other users have finished
* with the heap.
*
* Out-of-memory is not something we regard as normal.
* If we cannot allocate memory - we put up an abort-retry-ignore
* error, and only return from the function if the user selects ignore.
*
****************************************************************************/

#include <windows.h>
#include <memory.h>

#include "gutils.h"

int gmem_panic(void);


/* ensure BLKSIZE is multiple of sizeof(DWORD) */
#define BLKSIZE         64               /* blk size in bytes */
#define ALLOCSIZE       32768
#define NBLKS           (ALLOCSIZE / BLKSIZE)
#define MAPSIZE         (NBLKS / 8)
#define MAPLONGS        (MAPSIZE / sizeof(DWORD))
#define TO_BLKS(x)      (((x) + BLKSIZE - 1) / BLKSIZE)

typedef struct seghdr {
        HANDLE hseg;
        CRITICAL_SECTION critsec;
        struct seghdr FAR * pnext;
        long nblocks;
        DWORD segmap[MAPLONGS];
} SEGHDR, FAR * SEGHDRP;


/* anything above this size, we alloc directly from global heap */
#define MAXGALLOC       20000


/***************************************************************************
 * Function: gmem_init
 *
 * Purpose:
 *
 * init heap - create first segment
 */
HANDLE APIENTRY
gmem_init(void)
{
        HANDLE hNew;
        SEGHDRP hp;

        /* retry all memory allocations after calling gmem_panic */
        do {
                hNew = GlobalAlloc(GHND, ALLOCSIZE);
                if (hNew == NULL) {
                        if (gmem_panic() == IDIGNORE) {
                                return(NULL);
                        }
                }
        } while  (hNew == NULL);

        hp = (SEGHDRP) GlobalLock(hNew);
        if (hp == NULL) {
                return(NULL);
        }
        hp->hseg = hNew;
        InitializeCriticalSection(&hp->critsec);
        hp->pnext = NULL;
        gbit_init(hp->segmap, NBLKS);
        gbit_alloc(hp->segmap, 1, TO_BLKS(sizeof(SEGHDR)));
        hp->nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR));

        return(hNew);
}

/***************************************************************************
 * Function: gmem_get
 *
 * Purpose:
 *
 * Get memory from heap
 */
LPSTR APIENTRY
gmem_get(HANDLE hHeap, int len)
{
        SEGHDRP chainp;
        HANDLE hNew;
        SEGHDRP hp;
        LPSTR chp;
        long nblks;
        long start;
        long nfound;


        /* the heap is always locked (in gmem_init)- so having got the
         * pointer, we can always safely unlock it
         */
        chainp = (SEGHDRP) GlobalLock(hHeap);
        GlobalUnlock(hHeap);

        if (len < 1) {
                return(NULL);
        }

        /*
         * too big to be worth allocing from heap - get from globalalloc
         */
        if (len > MAXGALLOC) {
                /* retry all memory allocations after calling gmem_panic */
                do {
                        hNew = GlobalAlloc(GHND, len);
                        if (hNew == NULL) {
                                if (gmem_panic() == IDIGNORE) {
                                        return(NULL);
                                }
                        }
                } while  (hNew == NULL);

                chp = GlobalLock(hNew);
                if (chp == NULL) {
                        return(NULL);
                }
                return(chp);
        }


        /*
         * get critical section during all access to the heap itself
         */
        EnterCriticalSection(&chainp->critsec);

        nblks = TO_BLKS(len + sizeof(HANDLE));

        for (hp = chainp; hp !=NULL; hp = hp->pnext) {
                if (hp->nblocks >= nblks) {
                        nfound = gbit_findfree(hp->segmap, nblks,NBLKS, &start);
                        if (nfound >= nblks) {
                                gbit_alloc(hp->segmap, start, nblks);
                                hp->nblocks -= nblks;

                                /* convert blocknr to pointer
                                 * store seg handle in block
                                 */
                                chp = (LPSTR) hp;
                                chp = &chp[ (start-1) * BLKSIZE];
                                * ( (HANDLE FAR *) chp) = hp->hseg;
                                chp += sizeof(HANDLE);

                                break;
                        }
                }
        }
        if (hp == NULL) {
                /* retry all memory allocations after calling gmem_panic */
                do {
                        hNew = GlobalAlloc(GHND, ALLOCSIZE);
                        if (hNew == NULL) {
                                if (gmem_panic() == IDIGNORE) {
                                        LeaveCriticalSection(&chainp->critsec);
                                        return(NULL);
                                }
                        }
                } while  (hNew == NULL);

                hp = (SEGHDRP) GlobalLock(hNew);
                if (hp == NULL) {
                        LeaveCriticalSection(&chainp->critsec);
                        return(NULL);
                }
                hp->pnext = chainp->pnext;
                hp->hseg = hNew;
                chainp->pnext = hp;
                gbit_init(hp->segmap, NBLKS);
                gbit_alloc(hp->segmap, 1, TO_BLKS(sizeof(SEGHDR)));
                hp->nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR));
                nfound = gbit_findfree(hp->segmap, nblks, NBLKS, &start);
                if (nfound >= nblks) {
                        gbit_alloc(hp->segmap, start, nblks);
                        hp->nblocks -= nblks;

                        /* convert block nr to pointer */
                        chp = (LPSTR) hp;
                        chp = &chp[ (start-1) * BLKSIZE];
                        /* add a handle into the block and skip past */
                        * ( (HANDLE FAR *) chp) = hp->hseg;
                        chp += sizeof(HANDLE);
                }
        }
        LeaveCriticalSection(&chainp->critsec);
        memset(chp, 0, len);
        return(chp);
}

/***************************************************************************
 * Function: gmem_free
 *
 * Purpose:
 *
 * Free memory alloced
 */
void APIENTRY
gmem_free(HANDLE hHeap, LPSTR ptr, int len)
{
        SEGHDRP chainp;
        SEGHDRP hp;
        HANDLE hmem;
        long nblks, blknr;
        LPSTR chp;

        if (len < 1) {
                return;
        }

        /*
         * allocs greater than MAXGALLOC are too big to be worth
         * allocing from the heap - they will have been allocated
         * directly from globalalloc
         */
        if (len > MAXGALLOC) {
                hmem = GlobalHandle( (LPSTR) ptr);
                GlobalUnlock(hmem);
                GlobalFree(hmem);
                return;
        }

        chainp = (SEGHDRP) GlobalLock(hHeap);
        EnterCriticalSection(&chainp->critsec);


        /* just before the ptr we gave the user, is the handle to
         * the block
         */
        chp = (LPSTR) ptr;
        chp -= sizeof(HANDLE);
        hmem = * ((HANDLE FAR *) chp);
        hp = (SEGHDRP) GlobalLock(hmem);

        nblks = TO_BLKS(len + sizeof(HANDLE));

        /* convert ptr to block nr */
        blknr = TO_BLKS( (unsigned) (chp - (LPSTR) hp) ) + 1;

        gbit_free(hp->segmap, blknr, nblks);
        hp->nblocks += nblks;

        GlobalUnlock(hmem);

   LeaveCriticalSection(&chainp->critsec);
        GlobalUnlock(hHeap);

}

/***************************************************************************
 * Function: gmem_freeall
 *
 * Purpose:
 *
 * Free heap
 */
void APIENTRY
gmem_freeall(HANDLE hHeap)
{
        SEGHDRP chainp;
        HANDLE hSeg;

        chainp = (SEGHDRP) GlobalLock(hHeap);
        /* this segment is always locked - so we need to unlock
         * it here as well as below
         */
        GlobalUnlock(hHeap);

        /* finished with the critical section  -
         * caller must ensure that at this point there is no
         * longer any contention
         */
        DeleteCriticalSection(&chainp->critsec);

        while (chainp != NULL) {
                hSeg = chainp->hseg;
                chainp = chainp->pnext;
                GlobalUnlock(hSeg);
                GlobalFree(hSeg);
        }
}

/***************************************************************************
 * Function: gmem_panic
 *
 * Purpose:
 *
 * A memory allocation attempt has failed. Return IDIGNORE to ignore the
 * error and return NULL to the caller, and IDRETRY to retry the allocation
 * attempt.
 */
int
gmem_panic(void)
{
        int code;

        code = MessageBox(NULL, "Memory allocation failed", "Out Of Memory",
                        MB_ICONSTOP|MB_ABORTRETRYIGNORE);
        if (code == IDABORT) {
                /* abort this whole process */
                ExitProcess(1);
        } else {
                return(code);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\gdate.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: GDATE.C
*
* Contains date conversion functions.
*
* Functions:
*
* gdi_isleap()
* gdate_daytodmy()
* gdate_dmytoday()
* gdate_monthdays()
* gdate_weeklyday()
*
* Comments:
*
****************************************************************************/

#include <windows.h>
#include <string.h>

#include "gutils.h"


BOOL gdi_isleap(LONG year);

/*---static data--------------------------------------------*/

int monthdays[] = {
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
};


/***************************************************************************
 * Function: gdate_daytomy
 *
 * Purpose:
 *
 * converts day to d/m/y
 */
void APIENTRY
gdate_daytodmy(LONG days, int FAR* yrp, int FAR* monthp, int FAR* dayp)
{
        int years;
        int nleaps;
        int month;
        int mdays;

        /* get number of completed years and calc leap days */
        years = (int) (days / 365);
        days = days % 365;
        nleaps = (years / 4) - (years / 100) + (years / 400);
        while (nleaps > days) {
                days += 365;
                years--;
                nleaps = (years / 4) - (years / 100) + (years / 400);
        }
        days -= nleaps;

        /* add one year for current (non-complete) year */
        years++;


        /* current month */
        for (month = 0; month < 12; month++) {
                mdays = monthdays[month];
                if (gdi_isleap(years) && (month == 1)) {
                        mdays++;
                }
                if (days == mdays) {
                        days = 0;
                        month++;
                        break;
                } else if (days < mdays) {
                        break;
                } else {
                        days -= mdays;
                }
        }
        /* conv month from 0-11 to 1-12 */
        if (monthp != NULL) {
                *monthp = month+1;
        }
        if (dayp != NULL) {
                *dayp = (int) days + 1;
        }
        if (yrp != NULL) {
                *yrp = years;
        }
}


/***************************************************************************
 * Function: gdate_dmytoday
 *
 * Purpose:
 *
 * converts d/m/y to a day
 */ 
LONG APIENTRY
gdate_dmytoday(int yr, int month, int day)
{
        int nleaps;
        int i;
        long ndays;

        /* exclude the current year */
        yr--;
        nleaps = (yr / 4) - (yr / 100) + (yr / 400);

        /* in any given year, day 0 is jan1 */
        month--;
        day--;
        ndays = 0;
        for (i = 0; i < month ; i++) {
                ndays += monthdays[i];
                if (gdi_isleap(yr+1) && (i == 1)) {
                        ndays++;
                }
        }
        ndays = ndays + day + nleaps + (yr * 365L);
        return(ndays);
}

/***************************************************************************
 * Function: gdate_monthdays
 *
 * Purpose:
 *
 * Gets number of days in month
 */
int APIENTRY
gdate_monthdays(int month, int year)
{
        int ndays;

        ndays = monthdays[month - 1];
        if (gdi_isleap(year) && (month == 2)) {
                ndays++;
        }
        return(ndays);
}

/***************************************************************************
 * Function: gdate_weekday
 *
 * Purpose:
 * 
 * Gets the day of the week
 */
int APIENTRY
gdate_weekday(long daynr)
{
        return((int) ((daynr + 1) % 7));
}


/***************************************************************************
 * Function: gdi_isleap
 *
 * Purpose:
 * 
 * Determines whether the year is a leap year
 */
BOOL
gdi_isleap(LONG year)
{
        if ( ((year % 4) == 0) &&
                (((year % 100) != 0) ||
                ((year % 400) == 0))) {
                        return TRUE;
        } else {
                return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\file.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * FILE.H
 */

/* handle to filedata */
typedef struct filedata FAR * FILEDATA;

FILEDATA file_new(DIRITEM fiName, BOOL bRead);
DIRITEM file_getdiritem(FILEDATA fi);
void file_delete(FILEDATA fi);
LIST file_getlinelist(FILEDATA fi);
void file_discardlines(FILEDATA fi);
void file_reset(FILEDATA fi);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\gutils.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: GUTILS.C
*
* Entry point for GUTILS.DLL
*
* Functions:
*
* DllMain()
*
****************************************************************************/

#include <windows.h>

#include "gutils.h"
#include "gutilsrc.h"

/* dll global data */
HANDLE hLibInst;
extern void gtab_init(void);
extern BOOL StatusInit(HANDLE);

BOOL APIENTRY DllMain(HANDLE hInstance, DWORD dwReason, LPVOID reserved)
{
        if (dwReason == DLL_PROCESS_ATTACH) {
                hLibInst = hInstance;
                gtab_init();
                StatusInit(hLibInst);
        }
        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\gutils.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * GUTILS.H
 */

/* win32 msg crackers */
#define GET_WM_COMMAND_ID(w, l) (LOWORD(w))
#define GET_WM_COMMAND_CMD(w, l) (HIWORD(w))
#define GET_WM_COMMAND_HWND(w, l) (l)
#define GET_SCROLL_OPCODE(w, l)     (LOWORD(w))
#define GET_SCROLL_POS(w, l)        (HIWORD(w))

/* ------- memory allocator ------------------------------------------*/
HANDLE APIENTRY gmem_init(void);
LPSTR APIENTRY gmem_get(HANDLE hHeap, int len);
void APIENTRY gmem_free(HANDLE hHeap, LPSTR ptr, int len);
void APIENTRY gmem_freeall(HANDLE hHeap);


/* --------- date conversion functions    -----------------------*/
void APIENTRY gdate_daytodmy(LONG days,
        int FAR* yrp, int FAR* monthp, int FAR* dayp);
LONG APIENTRY gdate_dmytoday(int yr, int month, int day);
int APIENTRY gdate_monthdays(int month, int year);
int APIENTRY gdate_weekday(long daynr);


/* --- status line window class ---------------------------------- */
/* The status line is a bar across the top or bottom of the window.
 * It can hold a number of fields which can be either static text
 * or buttons.  The so called "static" text can be changed at any time.
 * The fields can be left or right aligned (default is RIGHT).
 * If the text is marked as VAR then the screen real estate allocated
 * for it will be adjusted whenever the text changes.  VAR fields
 * can be given minimum or maximum sizes (but not both).
 *
 * STATIC text fields can be drawn as raised or lowered rectangles (using
 * shades of grey), or (default) without a border. BUTTON fields will
 * always be drawn as raised rectangles, and will lower when pressed.
 *
 * Button fields will send WM_COMMAND messages when clicked including the
 * field id and the WM_LBUTTONUP notification code. Note that that this
 * is not a full implementation of the button class, and no other messages
 * will be sent. In general, none of the fields of a status bar are
 * implemented as separate windows, so GetDlgItem() and similar calls will not
 * work. Buttons only respond to mouse down events, and there is no handling
 * of the focus or of keyboard events.
 *
 * To use:
 *    call StatusAlloc giving the number of items you are going to add to the
 *    status bar. This returns a handle to use in subsequent calls.
 *
 *    Then call StatusAddItem to define each item in turn.
 *    Buttons are placed in order of definition along the bar starting from
 *    the left (SF_LEFT) and from the right (SF_RIGHT) until the two
 *    sides meet.
 *
 *    Call StatusHeight to find the expected height of this status bar, and
 *    set its position within the parent window, then call StatusCreate to
 *    create the window.
 *
 * Having created the window, send SM_SETTEXT messages to set the new
 * text of a field (static or button), or SM_NEW with a handle (obtained from
 * StatusAlloc) to change the contents of the status line.
 */

/* values for type argument to StatusAddItem */
#define SF_BUTTON       1
#define SF_STATIC       2

/* bits in flags argument to StatusAddItem */
#define SF_RAISE        1       /* paint static as raised 3D rectangle */
#define SF_LOWER        2       /* paint static as lowered 3D rectangle */
#define SF_LEFT         4       /* align field on left of status bar */
#define SF_RIGHT        8       /* align field on right (DEFAULT) */
#define SF_VAR          0x10    /* size of field depends on actual text extent*/
#define SF_SZMAX        0x20    /* (with SF_VAR): width argument is maximum */
#define SF_SZMIN        0x40    /* (with SF_VAR) width arg is minimum size */

HWND APIENTRY StatusCreate(HANDLE hInst, HWND hParent, int id,
                LPRECT rcp, HANDLE hmem);
int APIENTRY StatusHeight(HANDLE hmem);
HANDLE APIENTRY StatusAlloc(int nitems);
BOOL APIENTRY StatusAddItem(HANDLE hmem, int itemnr, int type, int flags,
        int id, int width, LPSTR text);

/* send these window messages to the class */

#define SM_NEW          (WM_USER+1)     /* wParam handle for new status line */
#define SM_SETTEXT      (WM_USER+2)     /* wparam: item id, lparam new label*/

void APIENTRY gbit_init(DWORD FAR * map, long nblks);
BOOL APIENTRY gbit_alloc(DWORD FAR * map, long blknr, long nblks);
BOOL APIENTRY gbit_free(DWORD FAR * map, long blknr, long nblks);
long APIENTRY gbit_findfree(DWORD FAR* map, long nblks,
                long mapsize, long FAR * blknr);


/* ----- buffered line input ----------------------------------*/
 /* handle to a file buffer */
typedef struct filebuffer * FILEBUFFER;

FILEBUFFER APIENTRY readfile_new(int fh);
LPSTR APIENTRY readfile_next(FILEBUFFER fb, int FAR * plen);
void APIENTRY readfile_delete(FILEBUFFER fb);


/* ------ hashing  ------------------------------------------- */
DWORD APIENTRY hash_string(LPSTR string, BOOL bIgnoreBlanks);
BOOL APIENTRY utils_isblank(LPSTR string);
int APIENTRY
utils_CompPath(LPSTR left, LPSTR right);

/* --- simple input ------------------------------------------------------*/
int APIENTRY StringInput(LPSTR result, int resultsize, LPSTR prompt,
                         LPSTR caption, LPSTR def_input);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\gutilsrc.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

#define IDC_LFNAME    201
#define IDC_FNAME     202
#define IDC_PROMPT    203
#define IDC_LFILES    204
#define IDC_LSDIR     205
#define IDC_SDIR      206
#define IDC_LDIRS     207
#define IDC_FILES     208
#define IDC_DIRS      209
#define IDC_OPEN      210
#define IDC_CANCEL    211


#define IDC_LPAGENR                 102

#define IDD_LABEL     301
#define IDD_FILE      302
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\line.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: LINE.C
*
* Functions that handle lines of text to be output.
*
* Functions:
*
* line_new()
* line_delete()
* line_reset()
* line_gettext()
* line_gettabbedlength()
* line_getlink()
* line_getlinenr()
* line_compare()
* line_link()
* line_isblank()
*
* Comments:
*
* LINE is a data type representing a string of ascii text along with 
* a line number.
*
* A LINE can compare itself to another line, and maintain a link if the
* lines are similar. 
*
* Comparisons between lines take note of the global option flag
* ignore_blanks, defined elsewhere. If this is true, we ignore
* differences in spaces and tabs when comparing lines, and when
* generating hashcodes.
*
* Links and are only generated once. To clear the link call line_reset.
*
* Lines can be allocated on a list. If a null list handle is passed, the
* line will be allocated using gmem_get() from the hHeap defined and
* initialised elsewhere.
*
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include "gutils.h"
#include "windiff.h"    /* defines hHeap and ignore_blanks */
#include "list.h"
#include "line.h"

struct fileline {

        UINT flags;     /* see below */

        LPSTR text;     /* null-terminated copy of line text */
        DWORD hash;     /* hashcode for line */
        LINE link;      /* handle for linked line */
        UINT linenr;    /* line number (any arbitrary value) */
};

/* flag values (or-ed) */
#define LF_DISCARD      1       /* if true, alloced from gmem heap */
#define LF_HASHVALID    2       /* if true, hashcode need not be recalced */


/***************************************************************************
 * Function: line_new
 *
 * Purpose:
 *
 * Creates a new line and makes a copy of the text.
 *
 * If the list is non-null, allocate on the list. If null, alloc from
 * gmem_get.
 *
 ***************************************************************************/
LINE
line_new(LPSTR text, int linelength, UINT linenr, LIST list)
{
        LINE line;

        /* alloc a line. from the list if there is a list */
        if (list) {
                line = List_NewLast(list, sizeof(struct fileline));
                if (line == NULL) {
                        return(NULL);
                }
                line->flags = 0;
        } else {
                line = (LINE) gmem_get(hHeap, sizeof(struct fileline));
                if (line == NULL) {
                        return(NULL);
                }
                line->flags = LF_DISCARD;
        }

        /* alloc space for the text. remember the null character */
        line->text = gmem_get(hHeap, linelength + 1);
        strncpy(line->text, text, linelength);
        line->text[linelength] = '\0';

        line->link = NULL;
        line->linenr = linenr;

        return(line);
}

/***************************************************************************
 * Function: line_delete
 *
 * Purpose:
 *
 * Deletes a line and frees up all associated memory and if the line
 * was not alloc-ed from a list, frees up the line struct itself
 *
 ***************************************************************************/
void
line_delete(LINE line)
{
        if (line == NULL) {
                return;
        }

        /* free up text space */
        gmem_free(hHeap, line->text, lstrlen(line->text)+1);

        /* free up line itself only if not on list */
        if (line->flags & LF_DISCARD) {
                gmem_free(hHeap, (LPSTR) line, sizeof(struct fileline));
        }
}

/***************************************************************************
 * Function: line_reset
 *
 * Purpose:
 *
 * Clears the link and force recalc of the hash code.
 *
 ***************************************************************************/
void
line_reset(LINE line)
{
        if (line == NULL) {
                return;
        }

        line->link = NULL;

        line->flags &= ~LF_HASHVALID;
}


/***************************************************************************
 * Function: line_gettext
 *
 * Purpose:
 *
 * Returns a pointer to the line text
 *
 ***************************************************************************/
LPSTR
line_gettext(LINE line)
{
        if (line == NULL) {
                return(NULL);
        }

        return (line->text);
}

/***************************************************************************
 * Function: line_gettabbedlength
 *
 * Purpose:
 *
 * Returns the length of line in characters, expanding tabs. 
 *
 ***************************************************************************/
int
line_gettabbedlength(LINE line, int tabstops)
{
        int length;
        LPSTR chp;

        if (line == NULL) {
                return(0);
        }

        for (length = 0, chp = line->text; *chp != '\0'; chp++) {
                if (*chp == '\t') {
                         length = (length + tabstops) / tabstops * tabstops;
                } else {
                        length++;
                }
        }
        return(length);
}


/***************************************************************************
 * Function: line_gethashcode
 *
 * Purpose:
 *
 * Returns the hashcode for this line 
 *
 ***************************************************************************/
DWORD
line_gethashcode(LINE line)
{
        if (line == NULL) {
                return(0);
        }

        if (! (line->flags & LF_HASHVALID)) {


                /* hashcode needs to be recalced */
                line->hash = hash_string(line->text, ignore_blanks);
                line->flags |= LF_HASHVALID;
        }
        return (line->hash);
}

/***************************************************************************
 * Function: line_getlink
 *
 * Purpose:
 *
 * Returns the handle for the line that is linked to this line (the
 * result of a successful line_link() operation). This line is
 * identical in text to the linked line (allowing for ignore_blanks).
 *
 ***************************************************************************/
LINE
line_getlink(LINE line)
{
        if (line == NULL) {
                return(NULL);
        }

        return(line->link);
}

/***************************************************************************
 * Function: line_getlinenr
 *
 * Purpose:
 *
 * Returns the line number associated with this line 
 *
 ***************************************************************************/
UINT
line_getlinenr(LINE line)
{
        if (line == NULL) {
                return(0);
        }

        return(line->linenr);
}

/***************************************************************************
 * Function: line_compare
 *
 * Purpose:
 *
 * Compares two lines and returns TRUE if they are the same.
 *
 ***************************************************************************/
BOOL
line_compare(LINE line1, LINE line2)
{
        LPSTR p1, p2;

        /* Assert: At least one of them is not null ??? */

        if ((line1 == NULL) || (line2 == NULL)) {
                /* null line handles do not compare */
                return(FALSE);
        }

        /* check that the hashcodes match */
        if (line_gethashcode(line1) != line_gethashcode(line2)) {
                return(FALSE);
        }

        /* hashcodes match - are the lines really the same ? */
        /* note that this is coupled to gutils\utils.c in definition of blank */
        p1 = line_gettext(line1);
        p2 = line_gettext(line2);
        do {
                if (ignore_blanks) {
                        while ( (*p1 == ' ') || (*p1 == '\t')) {
                                p1++;
                        }
                        while ( (*p2 == ' ') || (*p2 == '\t')) {
                                p2++;
                        }
                }
                if (*p1 != *p2) {
                        return(FALSE);
                }
        } while ( (*p1++ != '\0') && (*p2++ != '\0'));

        return(TRUE);
}

/***************************************************************************
 * Function: line_link
 *
 * Purpose:
 *
 * Attempts to link two lines and returns TRUE if succesful.
 *
 * This will fail if either line is NULL, or already linked, or if
 * they differ.
 *
 ***************************************************************************/
BOOL
line_link(LINE line1, LINE line2)
{
        if ( (line1 == NULL) || (line2 == NULL)) {
                return(FALSE);
        }

        if ( (line1->link != NULL) || (line2->link != NULL)) {
                return(FALSE);
        }

        if (line_compare(line1, line2)) {
                line1->link = line2;
                line2->link = line1;
                return(TRUE);
        } else {
                return(FALSE);
        }
}


/***************************************************************************
 * Function: line_isblank
 *
 * Purpose:
 *
 * Returns TRUE iff line is blank.  NULL => return FALSE 
 *
 ***************************************************************************/
BOOL line_isblank(LINE line)
{
        return line!=NULL && utils_isblank(line->text);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\section.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * SECTION.H
 */

/* handle to a section */
typedef struct section FAR * SECTION;


SECTION section_new(LINE first, LINE last, LIST list);
void section_delete(SECTION section);
BOOL section_match(SECTION section1, SECTION section2);
LINE section_getfirstline(SECTION section);
LINE section_getlastline(SECTION section);
SECTION section_getlink(SECTION section);
SECTION section_getcorrespond(SECTION section);
void section_setstate(SECTION section, int state);
int section_getstate(SECTION section);
int section_getlinecount(SECTION section);
int section_getleftbasenr(SECTION section);
int section_getrightbasenr(SECTION section);
LIST section_makelist(LIST linelist, BOOL left);
void section_deletelist(LIST sections);
LIST section_makecomposite(LIST secsleft, LIST secsright);
BOOL section_matchlists(LIST secsleft, LIST secsright);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\section.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: SECTION.C
*
* Manages sections of lines, and lists of sections.
*
* Functions:
*
* section_new()
* section_delete()
* section_match()
* section_getfirstline()
* section_getlastline()
* section_getlink()
* section_getcorrespond()
* section_getstate()
* section_setstate()
* section_getlinecount()
* section_getleftbasenr()
* section_setleftbasenr()
* section_getrightbasenr()
* section_setrightbasenr()
* FindEndOfUnmatched()
* NextNonIngnorable()
* FinEndOfMatched()
* section_makelist()
* section_deletelist()
* FindFirstWithLink()
* section_matchlists()
* section_takesection()
* section_makecomposite()
* AbsorbAnyBlanks()
* section_makectree()
* section_expandanchor()
*
* Comments:
*
* A section is a data type that represents a contiguous block of lines
* of the same state (all unmatched, or all matched to a contiguous block of
* lines). A section can link up matching lines within the section.
*
* Section list functions can make and match lists of sections from lists of
* lines, and create a composite list by combining sections from two lists
* to create a list that 'best represents' the similarities and differences
* between the two lists of lines.
* 
* Assumptions: the lines passed in are on a list (can be traversed with
* List_Next() etc. Line numbering using the section_get*basenr()
* functions work only if lines are numbered sequentially in ascending order.
*
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include "gutils.h"
#include "tree.h"
#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"
#include "list.h"
#include "line.h"
#include "section.h"

/*
 * a section handle (SECTION) is a pointer to one of these structures
 */
struct section {
        LINE first;             /* first line in section */
        LINE last;              /* last line in section */

        BOOL bDiscard;          /* true if not alloc-ed on list */

        SECTION link;           /* we match this section */
        SECTION correspond;     /* we correspond to this section, but
                                 * don't match it
                                 */

        int state;              /* compare state for section */

        int leftbase;           /* nr in original left list of first line*/
        int rightbase;          /* nr in original right list of first line*/
};

/* --- function prototypes ------------------------------------------*/

TREE section_makectree(SECTION sec);
BOOL section_expandanchor(SECTION sec1, LINE line1, SECTION sec2, LINE line2);



/***************************************************************************
 * Function: section_new
 *
 * Purpose:
 *
 * Makes a new section, given handles to a first and last line.
 *
 * A section must be at least one line long. The lines passed in must be
 * on a list in order.
 *
 * If the list parameter is non-null, we will allocate the section struct
 * on the list. otherwise we will alloc it from gmem_get(hHeap). We remember
 * this in the bDiscard flag for section_delete, so that we only
 * hand back to gmem_free memory that we got.
 **************************************************************************/
SECTION
section_new(LINE first, LINE last, LIST list)
{
        SECTION sec;

        /* alloc the sec and remember where we alloc-ed it */
        if (list) {
                sec = (SECTION) List_NewLast(list, sizeof(struct section));
                sec->bDiscard = TRUE;
        } else {
                sec = (SECTION) gmem_get(hHeap, sizeof(struct section));
                sec->bDiscard = FALSE;
        }

        sec->first = first;
        sec->last = last;
        sec->link = NULL;
        sec->correspond = NULL;
        sec->state = 0;
        sec->leftbase = 1;
        sec->rightbase = 1;

        return(sec);
}

/***************************************************************************
 * Function: section_delete
 *
 * Purpose:
 *
 * Discard a section. Free all associated memory (not the line list).
 * Free up the section itself if it was not alloc-ed on a list.
 */
void
section_delete(SECTION section)
{
        if (section->bDiscard) {
                gmem_free(hHeap, (LPSTR) section, sizeof(struct section));
        }
}

/***************************************************************************
 * Function: section_match
 *
 * Purpose:
 *
 * Match up two sections: match all lines that
 * are unique and identical between the two sections.
 *
 * We use a tree of line handles, keyed by the line hash code. We use a
 * ctree, which keeps a count for multiple identical keys. This allows
 * us to rapidly find lines that are unique within this section.
 * We build two of these trees (one for each line list). For each line
 * that is unique in both trees, we attempt to link the lines.
 *
 * We also attempt to link the first and last line of the section.
 *
 * For each line we successfully link, we spread up and down from
 * this anchor point attempting to link lines.
 *
 * We return true if we linked any lines
 *
 * This routine may be called more than once on the same list of lines.
 * In matching lines we want to find unique, *unmatched* lines: so we only
 * insert lines into the ctree if they are currently unlinked.
 */
BOOL
section_match(SECTION sec1, SECTION sec2)
{
        TREE ctleft, ctright;
        LINE line, line2;
        BOOL bLinked = FALSE;


        if ((sec1 == NULL) || (sec2 == NULL)) {
                return(FALSE);
        }

        if ((sec1->first == NULL) || (sec2->first == NULL)) {
                return(FALSE);
        }
        /* ASSERT if first is non-null, so is last */

        /* attempt to link the first line of each file, and
         * if matched, expand as long as we keep matching
         */
        bLinked |= section_expandanchor(sec1, sec1->first, sec2, sec2->first);

        /* attempt to link the last lines of each file and
         * expand upwards
         */
        bLinked |= section_expandanchor(sec1, sec1->last, sec2, sec2->last);


        /* build a tree of lines, indexed by the line hashcode.
         * a ctree will hold only the first value of any given key, but
         * it will keep track of the number of items inserted on this key.
         * thus we can keep count of the number of times this line
         * (or at least this hashcode) appears.
         */
        ctleft = section_makectree(sec1);
        ctright = section_makectree(sec2);

        /* for each unlinked line in one list (doesnt matter which), find if
         * appears once only in each list. if so, link, and expand
         * the link to link lines before and after the matching line
         * as long as they continue to match.
         */
        for (line = sec1->first; line != NULL; line = List_Next(line)) {

                if ((line_getlink(line) == NULL) &&
                   (ctree_getcount(ctleft, line_gethashcode(line)) == 1) &&
                   (ctree_getcount(ctright, line_gethashcode(line)) == 1)) {

                        /* line appears exactly once in each list */
                        line2 = * ((LINE FAR *)ctree_find(ctright,
                                        line_gethashcode(line)));
                        bLinked |= section_expandanchor(sec1, line, sec2, line2);
                }               

                if (line == sec1->last) {
                        break;
                }
        }

        /* delete the ctrees */
        ctree_delete(ctleft);
        ctree_delete(ctright);

        return(bLinked);
} /* section_match */

/***************************************************************************
 * Function: section_getfirstline
 *
 * Purpose:
 *
 * Gets a handle to the first line in this section
 */
LINE
section_getfirstline(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->first);
}

/***************************************************************************
 * Function: section_getlastline
 *
 * Purpose:
 *
 * Returns a handle to the last line in a section
 */
LINE
section_getlastline(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->last);
}

/***************************************************************************
 * Function: section_getlink
 *
 * Purpose:
 *
 * Returns a handle to the linked section, if any. A linked section
 * is a section whose lines all match the lines in this section
 */
SECTION
section_getlink(SECTION section)
{
        if (section == NULL) {
                return NULL;
        }
        return(section->link);
}

/***************************************************************************
 * Function: section_getcorrespond
 *
 * Purpose:
 *
 * Returns a handle to the corresponding section (a section which
 * corresponds in position to this one, but whose lines do not match).
 */
SECTION
section_getcorrespond(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->correspond);    
}
/***************************************************************************
 * Function: section_getstate
 *
 * Purpose:
 *
 * Gets the state for this section */
int
section_getstate(SECTION section)
{
        if (section == NULL) 
                return(0);
        return(section->state);
}

/***************************************************************************
 * Function: section_setstate
 *
 * Purpose:
 *
 * Sets the state for this section */
void
section_setstate(SECTION section, int state)
{
        section->state = state;
}

/***************************************************************************
 * Function: section_getlinecount
 *
 * Purpose:
 *
 * Returns the number of lines in the section. Here we assume that
 * lines in the section are number sequentially in ascending order, and we
 * simply look at the first and last line numbers.
 */
int
section_getlinecount(SECTION section)
{
        return(line_getlinenr(section->last) -
                        line_getlinenr(section->first)) + 1;
}

/*
 * -- base line numbers --
 *
 * These functions only apply to sections in the composite list. When creating
 * a composite section, we record the line number of the first line in each
 * of the two sections we built it from. Thus we can calculate the
 * line number of any line in the section in either file it appeared in,
 * by adding the index of the line within the section to the base line
 * number.
 */
int
section_getleftbasenr(SECTION section)
{
        return(section->leftbase);
}

void
section_setleftbasenr(SECTION section, int base)
{
        section->leftbase = base;
}

int
section_getrightbasenr(SECTION section)
{
        return(section->rightbase);
}

void
section_setrightbasenr(SECTION section, int base)
{
        section->rightbase = base;
}


/* --- section list functions -------------------------------------*/

/* Theory of handling blank lines:
|   
|  If ignore_blanks is FALSE then a blank is just another character.
|  If it is TRUE then we will normally include unmatched blanks in whatever
|  section is surrounding them.  It would be nice if we could arrange to
|  never have a section that is only unmatched blanks, but (at least at
|  the start of the file) it can happen.
|
|  Note that there are two DIFFERENT blank handling techniques:
|  In the first phase of the comparison when we are just trying to match up
|  lines, we skip over blank lines both forwards and backwards from an anchor.
|  When we are making real sections for display we only go forwards.
|  This results in a possible anomaly at the top of the whole file where
|  there could be some blanks which do not match and which can only possibly
|  be described as the start of a section.
|  For this reason, we label the sections with their state as early as possible
|  and go by that rather than by the presence or absence of link fields.
|  (It takes some scanning to find a link.  The first line in the section
|  could be a blank).
*/

/***************************************************************************
 * Function: FindEndOfUnmatched
 *
 * Purpose:
 *
 * Returns a LINE which is the last line in an unmatched section
 * containing (probably starting with) Line.
 * Note that it does not necessarily make progress.
 *
 * As noted above, even if blank lines are being ignored, we don't
 * mind tagging them onto the end of an already unmatching section.
 * This means we carry on until we find the first real link
 */
LINE FindEndOfUnmatched(LINE line)
{
        LINE next;

        for (; ; )
        {       next = List_Next(line);
                if (next==NULL) return line;
                if (line_getlink(next)!=NULL) return line;
                line = next;
        }
} /* FindEndOfUnmatched */


/***************************************************************************
 * Function: NextNonIgnorable
 *
 * Purpose:
 *
 * An ignorable line is a blank line with no link and ignore_blanks set
 *
 * Given that line is initially not NULL and not ignorable:
 * If line is the last line in the list then return NULL
 * Else If ignore_blanks is FALSE then return the next line after line
 * else return next line which has a link or which is non-blank.
 * If there is no such line then return the last line in the list.
 *
 * Note that this does always make progress (at the cost of
 * sometimes returning NULL).
 */
LINE NextNonIgnorable(LINE line)
{       LINE next;

        next = List_Next(line);
        if (next==NULL) return NULL;
        for (; ; ) {
                line = next;
                if (  line_getlink(line)!=NULL) return line;
                if (! ignore_blanks)            return line;
                if (! line_isblank(line))       return line;
                next = List_Next(line);
                if (next==NULL) return line;
        }
} /* NextNonIgnorable */


/***************************************************************************
 * Function: FindEndOfMatched
 *
 * Purpose:
 *
 * Given that line is either linked or an ignorable blank:
 * Return a LINE which is the last line in a matched section
 * containing (probably starting with) line.
 * This could mean returning the line we were given.
 *
 * If the lines linked to are not consecutive then the section ends.
 * If blanks are being ignored, then any blank line is deemed
 * to match (even if it doesn't match).  In this case we need the
 * links of the lines before and after the blanks to be consecutive
 * in order to carry on.  There could be blank lines on either or both
 * ends of the links.
 */
LINE FindEndOfMatched(LINE line)
{
        LINE next;              /* next non-ignored or linked line */
        LINE nextlink;          /* next in other file */

        /* The basic algorithm is to set up next and nextlink to point to
           candidate lines.  Examine them.  If they are good then step
           on to them, else return the line one before.
           There are confusion factors associated with the beginning and
           end of the file.
        */

        /* ASSERT( line is either an ignorable blank or else is linked) */

        /* As a section (at least at the start of the file) might start
           with an ignored non-linked blank line, first step over any such
        */
        if( line_getlink(line)==NULL && line_isblank(line) ) {
                next = NextNonIgnorable(line);

                /* There are unfortunately 6 cases to deal with
                   * marks where next will be. * against eof means next==NULL
                   blank(s) refer to ignorable unlinked blanks.
                          A         B        C        D        E        F
                   line-> xxxxx     xxxxx    xxxxx    xxxxx    xxxxx    xxxxx
                         *unlinked  blanks  *linked   blanks  *eof     *blanks
                                   *unlinked         *linked            eof

                   next could be:
                
                      null - case E => return line
                      unlinked ignorable blank - case F => return that blank line
                      unlinked other - cases A,B return prev(that unlinked line)
                      linked - cases C,D continue from that linked line
                */
                if (next==NULL) return line;
                if (line_getlink(next)==NULL) {
                        if (ignore_blanks && line_isblank(next)) {
                                return next;
                        }
                        return List_Prev(next);
                }

                line = next;
        }

        /* we have stepped over inital blanks and now do have a link */

        for ( ; ; ) {

                next = NextNonIgnorable(line);
                /* Same 6 cases - basically same again */
                if (next==NULL) return line;
                if (line_getlink(next)==NULL) {
                        if (ignore_blanks && line_isblank(next)) {
                                return next;
                        }
                        return List_Prev(next);
                }

                nextlink = NextNonIgnorable(line_getlink(line));

                /* WEAK LOOP INVARIANT
                   line is linked.
                   next is the next non-ignorable line in this list after line.
                   nextlink is the next non-ignorable line after link(line)
                                        in the other list (could be NULL etc).
                */
                if (line_getlink(next) != nextlink) return List_Prev(next);

                line = next;
        }
        return line;
} /* FindEndOfMatched */


/***************************************************************************
 * Function: section_makelist
 *
 * Purpose:
 *
 * Make a list of sections by traversing a list of lines. Consecutive
 * linked lines that are linked to consecutive lines are put in a single
 * section. Blocks of unlinked lines are placed in a section.
 * If ignore_blanks is set then we first try to link them as normal.
 * but if they won't link then we just skip over them and keep them
 * in the same section.
 *
 * Left must be set TRUE iff the list of lines is a left hand section.
 * Returns a handle to a list of sections
 */
LIST
section_makelist(LIST linelist, BOOL left)
{
        LINE line1, line2;
        LIST sections;
        BOOL matched;
        SECTION sect;

        /* make an empty list of sections */
        sections = List_Create();

        /* for each line in the list */

        List_TRAVERSE(linelist, line1) {

                /* is it linked ? */

                if( line_getlink(line1) != NULL
                  || ( ignore_blanks && line_isblank(line1))
                  ) {
                        line2 = FindEndOfMatched(line1);
                        matched = TRUE;
                } else {
                        line2 = FindEndOfUnmatched(line1);
                        matched = FALSE;
                }

                /* create the section and add to list */
                sect = section_new(line1, line2, sections);
                sect->state = (matched ? STATE_SAME
                                       : left ? STATE_LEFTONLY
                                              : STATE_RIGHTONLY
                              );

                /* advance to end of section (no-op if 1 line section) */
                line1 = line2;
        }

        return(sections);
} /* section_makelist */



/***************************************************************************
 * Function: section_deletelist
 *
 * Purpose:
 *
 * Delete a list of sections
 *
 * Sections have no dangling pointers, so all we do is delete the list
 */
void    
section_deletelist(LIST sections)
{
        List_Destroy(&sections);
}

/***************************************************************************
 * Function: FindFirstWithLink
 *
 * Purpose:
 *
 * Return the first line in the range first..last
 * which has a link.  Return last if none of them have a link.
 * List_Next must lead from first to last eventually.
 * It is legit for last to be NULL.
 */
LINE FindFirstWithLink(LINE first, LINE last)
{       
        /* The strategy of including blanks on the ENDS of sections rather
           than the start of new sections will mean that this function
           usually strikes gold immediately.  A file with a leading
           blank section is its raison d'etre.
        */
        while (line_getlink(first)==NULL && first!=last)
                first = List_Next(first);

        if (line_getlink(first)==NULL) {
        }
        return first;
} /* FindFirstWithLink */


/***************************************************************************
 * Function: section_matchlists
 *
 * Purpose:
 *
 * Match up two lists of sections. Establish links between sections
 * that match, and establish 'correspondence' between sections that
 * are in the same place, but don't match.
 *
 * For each pair of corresponding sections, we also call section_match
 * to try and link up more lines.
 *
 * We return TRUE if we made any more links between lines, or false
 * otherwise.
 *
 */
BOOL
section_matchlists(LIST secsleft, LIST secsright)
{
        BOOL bLinked = FALSE;
        SECTION sec1, sec2;

        /* match up linked sections - We know whether a section is
           supposed to link from its state, but we don't know what section
           it links to.  Also we can have sections which are defined to
           be matching but actually contain nothing but ignorable
           blank lines
        */
        
        /*  for each linked section try to find the section  linked to it. */
        List_TRAVERSE(secsleft, sec1) {
                if (sec1->state==STATE_SAME) {
                        LINE FirstWithLink = FindFirstWithLink(sec1->first, sec1->last);
                        List_TRAVERSE(secsright, sec2) {
                                if ( sec2->state==STATE_SAME
                                   && line_getlink(FirstWithLink)
                                        == FindFirstWithLink(sec2->first, sec2->last)) {
                                            break;
                                }
                        }
                        /* sec2 could be NULL if sec1 is all allowable blanks */
                        if (sec2!=NULL) {
                                sec1->link = sec2;
                                sec2->link = sec1;
                        }
                }
        }

        /* go through all unmatched sections. Note that we need to complete
         * the link-up of matching sections before this, since we need
         * all the links in place for this to work.
         */

        List_TRAVERSE(secsleft, sec1) {
                SECTION secTemp;

                if (sec1->state == STATE_SAME) {
                        /* skip the linked sections */
                        continue;
                }

                /* check that the previous and next sections, if
                 * they exist, are linked. this should not fail since
                 * two consecutive unlinked sections should be made into
                 * one section
                 */
                secTemp = List_Prev(sec1);
                if (secTemp && secTemp->state!= STATE_SAME) {
                        continue;
                }
                secTemp = List_Next(sec1);
                if (secTemp && secTemp->state!= STATE_SAME) {
                        continue;
                }

                /* find the section that corresponds to this - that is, the
                 * section following the section linked to our previous section.
                 * we could be at beginning or end of list.
                 */
                if (List_Prev(sec1) != NULL) {
                        SECTION secOther;
                        secOther = section_getlink(List_Prev(sec1));
                        if (secOther==NULL)
                                continue;

                        sec2 = List_Next(secOther);

                        /* check this section is not linked */
                        if ((sec2 == NULL) || (section_getlink(sec2) != NULL)) {
                                continue;
                        }
                        
                        /* check that the section after these are linked
                         * to each other (or both are at end of list).
                         */
                        if (List_Next(sec1) != NULL) {

                                if (section_getlink(List_Next(sec1)) !=
                                    List_Next(sec2)) {
                                        continue;
                                }
                        } else {
                                if (List_Next(sec2) == NULL) {
                                        continue;
                                }
                        }

                } else if (List_Next(sec1) != NULL) {
                        SECTION secOther;
                        secOther = section_getlink(List_Next(sec1));
                        if (secOther==NULL)
                                continue;

                        sec2 = List_Prev(secOther);

                        /* check this section is not linked */
                        if ((sec2 == NULL) || (section_getlink(sec2) != NULL)) {
                                continue;
                        }
                        
                        /* check that the section before these are linked
                         * to each other (or both are at start of list).
                         */
                        if (List_Prev(sec1) != NULL) {

                                if (section_getlink(List_Prev(sec1)) !=
                                    List_Prev(sec2)) {
                                        continue;
                                }
                        } else {
                                if (List_Prev(sec2) == NULL) {
                                        continue;
                                }
                        }
                } else {
                        /* there must be at most one section in each
                         * file, and they are unmatched. make these correspond.
                         */
                        sec2 = List_First(secsright);
                }


                /* make the correspondence links
                 */
                if ((sec1 != NULL) && (sec2 != NULL)) {
                        sec1->correspond = sec2;
                        sec2->correspond = sec1;
                }

                /* attempt to link up lines */
                if (section_match(sec1, sec2)) {
                        bLinked = TRUE;
                }
        }

        return(bLinked);
} /* section_matchlists */

/***************************************************************************
 * Function: section_takesection
 *
 * Purpose:
 *
 * Add a section to the composite list. Called from make_composites
 * to copy a section, add it to the composite list and set the state,
 * leftbase and rightbase.   Note that the state could be STATE_SAME
 * with a NULL section on the left.  May NOT call with STATE_SAME and
 * a NULL right section!
 *
 */
void
section_takesection(LIST compo, SECTION left, SECTION right, int state)
{
        SECTION newsec;
        SECTION sec;

        /* select which section is being output, and change the state
         * to indicate it has been output
         */
        switch(state) {
        case STATE_SAME:
                /* both the same. we mark both as output, and
                 * take the right one.  It is possible that the
                 * left one could be NULL (an ignorable blank section)
                 */
                if (left!=NULL) left->state = STATE_MARKED;
                right->state = STATE_MARKED;
                sec = right;
                break;

        case STATE_LEFTONLY:
        case STATE_MOVEDLEFT:
                sec = left;
                left->state = STATE_MARKED;
                break;

        case STATE_RIGHTONLY:
        case STATE_MOVEDRIGHT:
                sec = right;
                right->state = STATE_MARKED;
                break;
        }


        /* create a new section on the list */
        newsec = section_new(sec->first, sec->last, compo);

        newsec->state = state;


        if (left != NULL) {
                newsec->leftbase = line_getlinenr(left->first);
        } else {
                newsec->leftbase = 0;
        }

        if (right != NULL) {
                newsec->rightbase = line_getlinenr(right->first);
        } else {
                newsec->rightbase = 0;
        }

} /* section_takesection */

/***************************************************************************
 * Function: section_makecomposite
 *
 * Purpose:
 *
 * Make a composite list of sections by traversing a list of sections.
 *
 * Return a handle to a list of sections.
 *
 * During this, set state, leftbase and rightbase for sections.
 *
 * Comments:
 *
 * This function creates a list that corresponds to the 'best' view
 * of the differences between the two lists. We place sections from the
 * two lists into one composite list. Sections that match each other are only
 * inserted once (from the right list). Sections that match, but in different
 * positions in the two lists are inserted twice, once in each position, with
 * status to indicate this. Unmatched sections are inserted in the correct
 * position.
 *
 * - Take sections from the left list until the section is linked to one not
 *   already taken.
 * - Then take sections from right until we find a section linked to one not
 *   already taken.
 * - If the two sections waiting are linked to each other, take them both
 *   (once- we take the right one and advance past both).
 *
 * - Now we have to decide which to take in place and which to declare
 *   'moved'. Consider the case where the only change is that the first line
 *   has been moved to the end. We should take the first line (as a move),
 *   then the bulk of the file (SAME) then the last line (as a move). Hence,
 *   in difficult cases, we take the smaller section first, to ensure that
 *   the larger section is taken as SAME.
 *
 *   To indicate which section has been output, we set the state field
 *   to STATE_MARKED once we have taken it.   States in left and right
 *   lists are of no further interest once we have built the composite.
 *
 *   Up to this point we have worked off the STATE of a section.  By now
 *   all the section links are in place, so we can use them too.
 */
LIST
section_makecomposite(LIST secsleft, LIST secsright)
{
        SECTION left, right;
        LIST compo;

        /* make an empty list for the composite */
        compo = List_Create();

        left = List_First(secsleft);
        right = List_First(secsright);

        while ( (left != NULL) || (right != NULL)) {

                if (left == NULL) {
                        /* no more in left list - take right section */
                        /* is it moved or just unmatched ? */
                        if (right->link == NULL) {
                                section_takesection(compo, NULL, right, STATE_RIGHTONLY);
                                right = List_Next(right);
                        } else {
                                section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                                right = List_Next(right);
                        }
                } else if (right == NULL) {
                        /* right list empty - must be left next */

                        /* is it moved or just unmatched ? */
                        if (left->link == NULL) {
                                section_takesection(compo, left, NULL, STATE_LEFTONLY);
                                left = List_Next(left);
                        } else {
                                section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                                left = List_Next(left);
                        }

                } else if (left->state == STATE_LEFTONLY) {
                        /* unlinked section on left */
                        section_takesection(compo, left, NULL, STATE_LEFTONLY);
                        left = List_Next(left);

                } else if (left->link==NULL) {
                        /* This is an ignorable blank section on the left.
                         * We ignore it. (We will take any such from the right)
                         */
                        left = List_Next(left);

                } else if (left->link->state==STATE_MARKED) {
                        /* left is linked to section that is already taken*/
                        section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                        left = List_Next(left);

                } else  if (right->link == NULL) {
                        /* take unlinked section on right
                         * Either unmatched or ignorable blanks
                         */
                        section_takesection(compo, NULL, right, right->state);
                        right = List_Next(right);
                
                } else if (right->link->state==STATE_MARKED) {
                        /* right is linked to section that's already taken */
                        section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                        right = List_Next(right);
                
                } else if (left->link == right) {
                        /* sections match */
                        section_takesection(compo, left, right, STATE_SAME);
                        right = List_Next(right);
                        left = List_Next(left);
                } else {
                        /* both sections linked to forward sections
                         * decide first based on size of sections
                         * - smallest first as a move so that largest
                         * is an unchanged.
                         */
                        if (section_getlinecount(right) > section_getlinecount(left)) {
                                section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                                left = List_Next(left);
                        } else {
                                section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                                right = List_Next(right);
                        }
                }
        }

        return(compo);
} /* section_makecomposite */

typedef LINE (APIENTRY * MOVEPROC)(LINE);

/***************************************************************************
 * Function: AbsorbAnyBlanks
 *
 * Purpose:
 *
 * Update PLINE by making it point to the first non-blank
 * at-or-after from but not after limit.
 * If they are all blank then make it point to limit
 * If from is non-blank then leave it alone.
 * Return TRUE iff PLINE was updated.
 * It is legit for limit to be NULL (meaning end of file).
 */
BOOL AbsorbAnyBlanks(LINE * from, LINE limit, MOVEPROC Move)
{       BOOL progress = FALSE;

        while ( (from!=NULL)
              && (line_isblank(*from))
              && (*from!=limit)
              ) {
                *from = Move(*from);
                progress = TRUE;
        }
        return progress;
} /* AbsorbAnyBlanks */


/***************************************************************************
 * Function: section_expandanchor
 *
 * Purpose:
 *
 * Given an anchor point (two lines that we think should match),
 * try to link them, and the lines above and below them for as long
 * as the lines can be linked (are the same, are unlinked).
 *
 * Return TRUE if we make any links.
 *
 */
BOOL
section_expandanchor(SECTION sec1, LINE line1, SECTION sec2, LINE line2)
{
        /* when a line is matched we set bChanges.  If we notice some
         * blank lines, but do NOT link any new non-blank lines, we
         * do NOT set bChanges.  (If we did it would cause a closed
         * loop as they would get noticed again next time.  line_link
         * only returns TRUE if it is a NEW link).
         * At this stage we are only interested in making links, not in
         * the size of the section that results (that fun comes later).
         * therefore trailing blanks at the end of a section are not
         * interesting and we don't look for them.
         */
        BOOL bChanges = FALSE;
        LINE left, right;

        /* We handle the section limits by using a sentinel which is one
         * past the end of the section.  (If the section ends at the end
         * of the list then the sentinel is NULL).
         */
        LINE leftend, rightend;
        leftend = List_Next(sec1->last);
        rightend = List_Next(sec2->last);

        /* null lines shall not match */
        if ((line1 == NULL) || (line2 == NULL)) {
                return(FALSE);
        }

        /* check all lines forward until fail to link (because null,
         * not matching, or already linked).
         * include the passed in anchor point since this has not
         * yet been linked.
         * If blanks are ignorable then skip over any number of whole
         * blank lines.
         */
        left = line1;
        right = line2;
        for (; ; ) {
                if (line_link(left, right) ) {

                        bChanges = TRUE;
                        left = List_Next(left);
                        right = List_Next(right);
                        if (left==leftend || right==rightend) break;
                }
                else if (ignore_blanks){
                        /* even though no match, maybe an ignorable blank? */

                        BOOL moved = FALSE;
                        moved |= AbsorbAnyBlanks(&left, leftend, (MOVEPROC)List_Next);
                        moved |= AbsorbAnyBlanks(&right, rightend, (MOVEPROC)List_Next);
                        if (!moved) break; /* it didn't match and we didn't move on */
                        if (left==leftend || right==rightend) break;
                }
                else break;
        }

        /* check all matches going backwards from anchor point
           but only if it was a real anchor  (could have been
           end-of-section/end-of-file and non-matching).
        */
        if (line_getlink(line1)==NULL) return bChanges;

        left = List_Prev(line1);
        right = List_Prev(line2);
        if (left==NULL || right==NULL) return bChanges;

        leftend = List_Prev(sec1->first);
        rightend = List_Prev(sec2->first);

        for (; ; ) {
                if (line_link(left, right)) {

                        bChanges = TRUE;
                        left = List_Prev(left);
                        right = List_Prev(right);
                        if (left == leftend || right == rightend) break;

                }
                else if (ignore_blanks){
                        /* even though no match, maybe an ignorable blank? */

                        BOOL moved = FALSE;
                        moved |= AbsorbAnyBlanks(&left, leftend, (MOVEPROC)List_Prev);
                        moved |= AbsorbAnyBlanks(&right, rightend, (MOVEPROC)List_Prev);
                        if (!moved) break; /* it didn't match and we didn't move on */
                        if (left==leftend || right==rightend) break;

                }
                else break;
        }

        return(bChanges);
}


/***************************************************************************
 * Function: section_makectree
 *
 * Purpose:
 *
 * Build a ctree from the lines in the section given
 *
 * Remember that we are only interested in the lines that are
 * not already linked.
 *
 * The value we store in the tree is the handle of the line. the key
 * is the line hash code
 */
TREE
section_makectree(SECTION sec)
{
        TREE tree;
        LINE line;

        /* make an empty tree */
        tree = ctree_create(hHeap);

        for (line = sec->first; line != NULL; line = List_Next(line)) {
                if (line_getlink(line) == NULL) {
                        ctree_update(tree, line_gethashcode(line),
                                        &line, sizeof(LINE));
                }
                if (line == sec->last) {
                        break;
                }
        }
        return(tree);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\scandir.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: SCANDIR.C
*
* Scan a directory tree and build a sorted list of filenames within that
* tree.
*
* Functions:
*
* dir_buildlist()
* dir_delete()
* dir_isfile()
* dir_firstitem()
* dir_nextitem()
* dir_findnextfile()
* dir_getrelname()
* dir_getfullname()
* dir_getroot_list()
* dir_getroot_item()
* dir_freerelname()
* dir_freefullname()
* dir_freeroot_list()
* dir_freerootitem()
* dir_getopenname()
* dir_freeopenname()
* dir_openfile()
* dir_closefile()
* dir_filesize()
* dir_startcopy()
* dir_endcopy()
* dir_copy()
* dir_finalelem()
* dir_cleardirect()
* dir_adddirect()
* dir_addfile()
* dir_scan()
* dir_isvaliddir()
* dir_isvalidfile()
* dir_fileinit()
* dir_dirinit()
* dir_getpathsize()
* dir_findnextfile()
*
* Comments:
*
* The call dir_buildlist takes a pathname and returns a handle. Subsequent
* calls to dir_firstitem and dir_nextitem return handles to
* items within the list, from which you can get the name of the
* file (relative to the original pathname, or complete), and filesize.
*
* The list can be either built entirely during the build call, or
* built one directory at a time as required by dir_nextitem calls. This
* option affects only relative performance, and is taken as a
* recommendation only (ie some of the time we will ignore the flag).
*
* The list is ordered alphabetically (case-insensitive using lstrcmpi).
* within any one directory, we list filenames before going on
* to subdirectory contents.
*
* All memory is allocated from a gmem_* heap hHeap declared
* and initialised elsewhere.
*
* The caller gets handles to two things: a DIRLIST, representing the
* entire list of filenames, and a DIRITEM: one item within the list.
*
* From the DIRITEM he can get the filename (including or excluding the
* tree root passed to dir_build*) - and also he can get to the next
* DIRITEM.
*
* We permit lazy building of the tree (usually so the caller can keep
* the user-interface up-to-date as we go along). In this case,
* we need to store information about how far we have scanned and
* what is next to do. We need to scan an entire directory at a time and then
* sort it so we can return files in the correct order.
*
* We scan an entire directory and store it in a DIRECT struct. This contains
* a list of DIRITEMs for the files in the current directory, and a list of
* DIRECTs for the subdirectories (possible un-scanned).
*
* dir_nextitem will use the list functions to get the next DIRITEM on the list.
* When the end of the list is reached, it will use the backpointer back to the
* DIRECT struct to find the next directory to scan.
*
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <direct.h>

#include "gutils.h"
#include "list.h"
#include "scandir.h"
#include "windiff.h"
#include "wdiffrc.h"

/*
 * Hold name and information about a given file (one ITEM in a DIRectory)
 * caller's DIRITEM handle is a pointer to one of these structures
 */
struct diritem {
        LPSTR name;             /* ptr to filename (final element only) */
        long size;              /* filesize */
        struct direct FAR * direct; /* containing directory */
        LPSTR localname;        /* name of temp copy of file */
        BOOL bLocalIsTemp;      /* true if localname is tempfile.
                                 */
};


/* DIRECT: Hold state about directory and current position in list of filenames.
 */
typedef struct direct {
        LPSTR relname;          /* name of dir relative to DIRLIST root */
        DIRLIST head;           /* back ptr (to get fullname) */
        struct direct FAR * parent; /* parent directory (NULL if above tree root)*/

        BOOL bScanned;          /* TRUE if scanned */
        LIST diritems;          /* list of DIRITEMs for files in cur. dir */
        LIST directs;           /* list of DIRECTs for child dirs */

        int pos;                /* where are we begin, files, dirs */
        struct direct FAR * curdir; /* subdir being scanned (ptr to list element)*/
} FAR * DIRECT;

/* Values for direct.pos */
#define DL_FILES        1       /* reading files from the diritems */
#define DL_DIRS         2       /* in the dirs: List_Next on curdir */


/*
 * The DIRLIST handle returned from a build function is in fact
 * a pointer to one of these
 */
struct dirlist {

        char rootname[256];        /* name of root of tree */
        BOOL bFile;             /* TRUE if root of tree is file, not dir */
        DIRECT dot;             /* dir  for '.' - for tree root dir */
};

extern BOOL bAbort;             /* from windiff.c (read only here). */


/* ------ memory allocation ---------------------------------------------*/

/* All memory is allocated from a heap created by the application */
extern HANDLE hHeap;

/*-- forward declaration of internal functions ---------------------------*/

LPSTR dir_finalelem(LPSTR path);
void dir_cleardirect(DIRECT dir);
void dir_adddirect(DIRECT dir, LPSTR path);
void dir_addfile(DIRECT dir, LPSTR path, DWORD size);
void dir_scan(DIRECT dir, BOOL bRecurse);
BOOL dir_isvaliddir(LPSTR path);
BOOL dir_isvalidfile(LPSTR path);
void dir_fileinit(DIRITEM pfile, DIRECT dir, LPSTR path, long size);
void dir_dirinit(DIRECT dir, DIRLIST head, DIRECT parent, LPSTR name);
long dir_getpathsize(LPSTR path);
DIRITEM dir_findnextfile(DIRLIST dl, DIRECT curdir);



/***************************************************************************
 * Function: dir_buildlist
 *
 * Purpose:
 *
 * Build a list of filenames
 *
 * Optionally build the list on demand, in which case we scan the
 * entire directory but don't recurse into subdirs until needed
 *
 */

DIRLIST
dir_buildlist(LPSTR path, BOOL bOnDemand)
{
        DIRLIST dl;
        BOOL bFile;
        
        /* first check if the path is valid */
        if (dir_isvaliddir(path)) {
                bFile = FALSE;
        } else if (dir_isvalidfile(path)) {
                bFile = TRUE;
        } else {
                /* not valid */
                return(NULL);
        }


        /* alloc and init the DIRLIST head */

        dl = (DIRLIST) gmem_get(hHeap, sizeof(struct dirlist));
        memset(dl, 0, sizeof(struct dirlist));

        /* convert the pathname to an absolute path */

        _fullpath(dl->rootname, path, sizeof(dl->rootname));

        dl->bFile = bFile;
        /* make a '.' directory for the current directory -
         * all files and subdirs will be listed from here
         */
        dl->dot = (DIRECT) gmem_get(hHeap, sizeof(struct direct));
        dir_dirinit(dl->dot, dl, NULL, ".");

        /* were we given a file or a directory ? */
        if (bFile) {
                /* its a file. create a single file entry
                 * and set the state accordingly
                 */
                dl->dot->bScanned = TRUE;

                dir_addfile(dl->dot, dir_finalelem(path),
                                dir_getpathsize(path));

                return(dl);
        }

        /* scan the root directory and return. if we are asked
         * to scan the whole thing, this will cause a recursive
         * scan all the way down the tree
         */
        dir_scan(dl->dot, (!bOnDemand) );

        return(dl);
} /* dir_buildlist */

/***************************************************************************
 * Function: dir_delete
 *
 * Purpose:
 *
 * Free up the DIRLIST and all associated memory 
 */
void
dir_delete(DIRLIST dl)
{
        if (dl == NULL) {
                return;
        }
        dir_cleardirect(dl->dot);
        gmem_free(hHeap, (LPSTR) dl->dot, sizeof(struct direct));


        gmem_free(hHeap, (LPSTR) dl, sizeof(struct dirlist));
}



/***************************************************************************
 * Function: dir_isfile
 *
 * Purpose:
 *
 * Was the original build request a file or a directory ? 
 */
BOOL
dir_isfile(DIRLIST dl)
{
        if (dl == NULL) {
                return(FALSE);
        }

        return(dl->bFile);
}

/***************************************************************************
 * Function: dir_firstitem
 *
 * Purpose:
 *
 * Return the first file in the list, or NULL if no files found.
 * Returns a DIRITEM. This can be used to get filename, size and chcksum.
 * If there are no files in the root, we recurse down until we find a file.
 */
DIRITEM
dir_firstitem(DIRLIST dl)
{
        if (dl == NULL) {
                return(NULL);
        }
        /*
         * reset the state to indicate that no files have been read yet
         */
        dl->dot->pos = DL_FILES;
        dl->dot->curdir = NULL;

        /* now get the next filename */
        return(dir_findnextfile(dl, dl->dot));
} /* dir_firstitem */


/***************************************************************************
 * Function:dir_nextitem
 *
 * Purpose:
 *
 * Get the next filename after the one given.
 *
 * The List_Next function can give us the next element on the list of files.
 * If this is null, we need to go back to the DIRECT and find the
 * next list of files to traverse (in the next subdir).
 *
 * After scanning all the subdirs, return to the parent to scan further
 * dirs that are peers of this, if there are any. If we have reached the end of
 * the tree (no more dirs in dl->dot to scan), return NULL.
 *
 * Don't recurse to lower levels unless fDeep is TRUE
 */
DIRITEM
dir_nextitem(DIRLIST dl, DIRITEM cur, BOOL fDeep)
{
        DIRITEM next;

        if ((dl == NULL) || (cur == NULL)) {
                return(NULL);
        }
        if (bAbort) return NULL;  /* user requested abort */

        if ( (next = List_Next(cur)) != NULL) {
                /* there was another file on this list */
                return(next);
        }
        if (!fDeep) return NULL;

        /* get the head of the next list of filenames from the directory */
        cur->direct->pos = DL_DIRS;
        cur->direct->curdir = NULL;
        return(dir_findnextfile(dl, cur->direct));
} /* dir_nextitem */

/***************************************************************************
 * Function: dir_findnextfile
 *
 * Purpose:
 *
 * Gets the next file in the directory
 */
DIRITEM
dir_findnextfile(DIRLIST dl, DIRECT curdir)
{
        DIRITEM curfile;

        if ((dl == NULL) || (curdir == NULL)) {
                return(NULL);
        }

        /* scan the subdir if necessary */
        if (!curdir->bScanned) {
                dir_scan(curdir, FALSE);
        }

        /* have we already read the files in this directory ? */
        if (curdir->pos == DL_FILES) {
                /* no - return head of file list */
                curfile = (DIRITEM) List_First(curdir->diritems);
                if (curfile != NULL) {
                        return(curfile);
                }

                /* no more files - try the subdirs */
                curdir->pos = DL_DIRS;
        }

        /* try the next subdir on the list, if any */
        /* is this the first or the next */
        if (curdir->curdir == NULL) {
                curdir->curdir = (DIRECT) List_First(curdir->directs);
        } else {
                curdir->curdir = (DIRECT) List_Next(curdir->curdir);
        }
        /* did we find a subdir ? */
        if (curdir->curdir == NULL) {

                /* no more dirs - go back to parent if there is one */
                if (curdir->parent == NULL) {
                        /* no parent - we have exhausted the tree */
                        return(NULL);
                }

                /* reset parent state to indicate this is the current
                 * directory - so that next gets the next after this.
                 * this ensures that multiple callers of dir_nextitem()
                 * to the same tree work.
                 */
                curdir->parent->pos = DL_DIRS;
                curdir->parent->curdir = curdir;

                return(dir_findnextfile(dl, curdir->parent));
        }

        /* there is a next directory - set it to the
         * beginning and get the first file from it
         */
        curdir->curdir->pos = DL_FILES;
        curdir->curdir->curdir = NULL;
        return(dir_findnextfile(dl, curdir->curdir));

} /* dir_findnextfile */


/*-- pathnames ----
 *
 * This module supports two types of pathnames, called relative and full.
 * Relative names are relative to the root passed in the initial call
 * to dir_build*, and full names include the tree root.
 *
 * Note that this is a different distinction to relative vs absolute
 * pathnames, since the tree root may still be either relative or absolute.
 *
 * Examples:
 *
 *  - if you called dir_buildlist("c:\")
 *              getrelname gives:               ".\config.sys"
 *              getfullname gives:              "c:\config.sys"
 *
 * - if you called dir_buildlist(".\geraintd")
 *              getrelname gives:               ".\source\scandir.h"
 *              getfullname gives either
 *                      ".\geraintd\source\scandir.h"
 *                    or "c:\geraintd\source\scandir.h"
 *                   (depending on the implementation).
 *
 * To support this, we maintain the tree root name in the DIRLIST head, and
 * in each directory, the name of that directory relative to tree root.
 * Files just have the filename, so we need to prepend the directory name,
 * and (for getfullname) the tree root name as well
 *
 * We store the directory name with a trailing
 * slash to make concatenation easier
 *
 * -----
 */

/***************************************************************************
 * Function: dir_getrelname
 *
 * Purpose:
 *
 * Return the name of the current file relative to tree root
 */
LPSTR
dir_getrelname(DIRITEM cur)
{
        LPSTR name;
        int size;

        /* check this is a valid item */
        if (cur == NULL) {
                return(NULL);
        }
        /* remember to include the NULL when sizing */
        size = lstrlen(cur->direct->relname) + lstrlen(cur->name) + 1;
        name = gmem_get(hHeap, size);
        lstrcpy(name, cur->direct->relname);
        lstrcat(name, cur->name);

        return(name);
} /* dir_getrelname */

/***************************************************************************
 * Function: dir_getfullname
 *
 * Purpose:
 *
 * Return the fullname of the file (including the tree root passed in) 
 */
LPSTR
dir_getfullname(DIRITEM cur)
{
        LPSTR name;
        int size;
        LPSTR head;

        /* check this is a valid item */
        if (cur == NULL)  {
                return(NULL);
        }

        if (cur->direct->head->bFile) {
                return(cur->direct->head->rootname);
        }

        /* remember to include the NULL when sizing */
        size = lstrlen(cur->name) + 1;

        size += lstrlen(cur->direct->relname);

        /* add on root name */
        head = cur->direct->head->rootname;
        size += lstrlen(head);

        /* root names may not end in a slash. we need to
         * insert one in this case. Also, relnames always begin .\, so
         * we skip the . always, and the .\ if we don't need to
         * append a slash
         *
         */
        size--;         /* omit the '.' */
        if (head[lstrlen(head) -1] == '\\') {
                size--;                         /* omit the .\ */
        }

        name = gmem_get(hHeap, size);

        lstrcpy(name, cur->direct->head->rootname);

        /* add relname and then name, omiting the .\ */

                /* skip . or .\ before relname */
                if (head[lstrlen(head) -1] == '\\') {
                        lstrcat(name, &cur->direct->relname[2]);
                } else {
                        lstrcat(name, &cur->direct->relname[1]);
                }
                lstrcat(name, cur->name);
        return(name);
} /* dir_getfullname */


/***************************************************************************
 * Function: dir_getroot_list
 *
 * Purpose:
 *
 * Return the name of the tree root given a handle to the DIRLIST.
 */
LPSTR
dir_getroot_list(DIRLIST dl)
{
        if (dl == NULL) 
                return(NULL);
        return(dl->rootname);
} /* dir_getroot_list */

/***************************************************************************
 * Function: dir_getroot_item
 *
 * Purpose:
 *
 * Return the root name of this tree given a handle to a DIRITEM in the
 * list.
 */
LPSTR dir_getroot_item(DIRITEM item)
{
        if (item == NULL) 
                return(NULL);

        return(dir_getroot_list(item->direct->head));
}


/***************************************************************************
 * Function: dir_freerelname
 *
 * Purpose:
 *
 * Free up a relname that we allocated. This interface allows us
 * some flexibility in how we store relative and complete names
 *
 */
void
dir_freerelname(DIRITEM cur, LPSTR name)
{
        if((cur != NULL) && (name != NULL))
                        gmem_free(hHeap, name, lstrlen(name) +1);
} /* dir_freerelname */

/***************************************************************************
 * Function: dir_freefullname
 *
 * Purpose:
 *
 */
void
dir_freefullname(DIRITEM cur, LPSTR name)
{
        if (cur->direct->head->bFile)
                return;

        if (name != NULL) 
                gmem_free(hHeap, name, lstrlen(name) + 1);
} /* dir_freefullname            */

/***************************************************************************
 * Function: dir_freeroot_list
 *
 * Purpose:
 *
 * Free up rootname allocated by dir_getroot_list.
 * We just gave a pointer to the rootname, so do nothing.
 */
void
dir_freeroot_list(DIRLIST dl, LPSTR name)
{
        if ((dl == NULL) || (name == NULL)) {
                return;
        }
        return;
} /* dir_freeroot_list */

/***************************************************************************
 * Function: dir_freeroot_item
 *
 * Purpose:
 *
 * Free up memory alloc-ed by a call to dir_getroot_item. 
 */
void
dir_freeroot_item(DIRITEM item, LPSTR name)
{
        if ((item == NULL) || (name == NULL)) 
                return;
        dir_freeroot_list(item->direct->head, name);
}

/***************************************************************************
 * Function: dir_getopenname
 *
 * Purpose:
 *
 * Get an open-able name for the file. This will be the same as the fullname.
 */
LPSTR
dir_getopenname(DIRITEM item)
{
        LPSTR fname;

        if (item == NULL) 
                return(NULL);

        fname = dir_getfullname(item);

                return(fname);
} /* dir_getopenname */


/***************************************************************************
 * Function: dir_freeopenname
 *
 * Purpose:
 *
 * Free up memory created by a call to dir_getopenname(). This *may*
 * cause the file to be deleted if it was a temporary copy.
 */
void
dir_freeopenname(DIRITEM item, LPSTR openname)
{
        if ((item == NULL) || (openname == NULL)) 
                return;

        dir_freefullname(item, openname);
} /* dir_freeopenname */

/***************************************************************************
 * Function: dir_openfile
 *
 * Purpose:
 *
 * Return an open file handle to the file. 
 */
int
dir_openfile(DIRITEM item)
{
        LPSTR fname;
        int fh;
        OFSTRUCT os;

        fname = dir_getfullname(item);
        fh = OpenFile(fname, &os, OF_READ|OF_SHARE_DENY_NONE);
        dir_freefullname(item, fname);
        return(fh);
} /* dir_openfile */

/***************************************************************************
 * Function: dir_closefile
 *
 * Purpose:
 *
 * Close a file opened with dir_openfile.
 */
void
dir_closefile(DIRITEM item, int fh)
{
        _lclose(fh);

} /* dir_closefile */


/***************************************************************************
 * Function: dir_getfilesize
 *
 * Purpose:
 *
 * Return the file size (set during scanning) 
 */
long
dir_getfilesize(DIRITEM cur)
{
        /* check this is a valid item */
        if (cur == NULL)
                return(0);

        return(cur->size);
} /* dir_getfilesize */



/* ss_endcopy returns a number indicating the number of files copied,
   but we may have some local copies too.  We need to count these
   ourselves and add them in
*/

int nLocalCopies;        /* cleared in startcopy, ++d in copy
                                ** inspected in endcopy
                                */

/***************************************************************************
 * Function: dir_startcopy
 *
 * Purpose:
 *
 * Start a bulk copy 
 */
BOOL dir_startcopy(DIRLIST dl)
{
        nLocalCopies = 0;
        return(TRUE);

} /* dir_startcopy */
/***************************************************************************
 * Function: dir_endcopy
 *
 */
 
int dir_endcopy(DIRLIST dl)
{
        return(nLocalCopies);

} /* dir_endcopy */

/***************************************************************************
 * Function: dir_copy
 *
 * Purpose:
 *
 * Create a copy of the file, in the new root directory. Creates sub-dirs as
 * necessary. 
 *
 * Returns TRUE for success and FALSE for failure.
 */
BOOL dir_copy(DIRITEM item, LPSTR newroot)
{
        static char newpath[256];
        LPSTR relname, fullname;
        LPSTR pstart, pdest, pel;
        BOOL bOK;

        BY_HANDLE_FILE_INFORMATION bhfi;
        HANDLE hfile;

        /*
         * check that the newroot directory itself exists
         */
        if ((item == NULL) || !dir_isvaliddir(newroot)) {
                return(FALSE);
        }

        /*
         * name of file relative to the tree root
         */
        relname = dir_getrelname(item);

        /*
         * build the new pathname by concatenating the new root and
         * the old relative name. add one path element at a time and
         * ensure that the directory exists, creating it if necessary.
         */
        lstrcpy(newpath, newroot);

        /* add separating slash if not already there */
        if (newpath[lstrlen(newpath) -1] != '\\') {
                lstrcat(newpath, "\\");
        }

        pstart = relname;
        while ( (pel = strchr(pstart, '\\')) != NULL) {

                /* found another element ending in slash. incr past the \\ */
                pel++;

                /*
                 * ignore .
                 */
                if (strncmp(pstart, ".\\", 2) != 0) {

                        pdest = &newpath[lstrlen(newpath)];
                        strncpy(pdest, pstart, pel - pstart);
                        pdest[pel - pstart] = '\0';

                        /* create subdir if necessary */
                        if (!dir_isvaliddir(newpath)) {
                                if (_mkdir(newpath) != 0) {
                                        return(FALSE);
                                }
                        }
                }

                pstart = pel;
        }

        /*
         * there are no more slashes, so pstart points at the final
         * element
         */
        lstrcat(newpath, pstart);

        fullname = dir_getfullname(item);

                bOK = CopyFile(fullname, newpath, FALSE);

                /* having copied the file, now copy the times, attributes */
                hfile = CreateFile(fullname, GENERIC_READ, 0, NULL,
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                bhfi.dwFileAttributes = GetFileAttributes(fullname);
                GetFileTime(hfile, &bhfi.ftCreationTime,
                                &bhfi.ftLastAccessTime, &bhfi.ftLastWriteTime);
                CloseHandle(hfile);

                hfile = CreateFile(newpath, GENERIC_WRITE, 0, NULL,
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                SetFileTime(hfile, &bhfi.ftCreationTime,
                                   &bhfi.ftLastAccessTime,
                                   &bhfi.ftLastWriteTime);
                CloseHandle(hfile);
                SetFileAttributes(newpath, bhfi.dwFileAttributes);


                if (bOK) ++nLocalCopies;

        dir_freerelname(item, relname);
        dir_freefullname(item, fullname);

        return(bOK);
} /* dir_copy */


/***************************************************************************
 * Function: dir_dirinit
 *
 * Purpose:
 *
 * Fill out a new DIRECT for a subdirectory (pre-allocated).
 * Init files and dirs lists to empty (List_Create). Set the relname
 * of the directory by pre-pending the parent relname if there
 * is a parent, and appending a trailing slash (if there isn't one).
 */
void
dir_dirinit(DIRECT dir, DIRLIST head, DIRECT parent, LPSTR name)
{
        int size;

        dir->head = head;
        dir->parent = parent;

        /* add on one for the null and one for the trailing slash */
        size = lstrlen(name) + 2;
        if (parent != NULL) {
                size += lstrlen(parent->relname);
        }

        /* build the relname from the parent and the current name
         * with a terminating slash
         */
        dir->relname = gmem_get(hHeap, size);
        if (parent != NULL) {
                lstrcpy(dir->relname, parent->relname);
        } else{
                dir->relname[0] = '\0';
        }

        lstrcat(dir->relname, name);

        if (dir->relname[lstrlen(dir->relname) -1] != '\\') {
                lstrcat(dir->relname, "\\");
        }

        /* force name to lowercase */
        AnsiLowerBuff(dir->relname, lstrlen(dir->relname));

        dir->diritems = List_Create();
        dir->directs = List_Create();
        dir->bScanned = FALSE;
        dir->pos = DL_FILES;

} /* dir_dirinit */


/***************************************************************************
 * Function: dir_fileinit
 *
 * Purpose:
 *
 * Initialise the contents of an (allocated) DIRITEM struct. 
 */
void
dir_fileinit(DIRITEM pfile, DIRECT dir, LPSTR path, long size)
{

        pfile->name = gmem_get(hHeap, lstrlen(path) + 1);
        lstrcpy(pfile->name, path);

        /* force name to lower case */
        AnsiLowerBuff(pfile->name, lstrlen(path));

        pfile->direct = dir;
        pfile->size = size;

        pfile->localname = NULL;

} /* dir_fileinit */

/***************************************************************************
 * Function: dir_isfilevalid
 *
 * Purpose:
 *
 * Is this a valid file or not 
 */
BOOL
dir_isvalidfile(LPSTR path)
{
        DWORD dwAttrib;

        dwAttrib = GetFileAttributes(path);
        if (dwAttrib == -1) {
                return(FALSE);
        }
        if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) {
                return(FALSE);
        }
        return(TRUE);
} /* dir_isvalidfile */

/***************************************************************************
 * Function: dir_isvaliddir
 *
 * Purpose:
 *
 * Is this a valid directory ? 
 */
BOOL
dir_isvaliddir(LPSTR path)
{
        DWORD dwAttrib;

        dwAttrib = GetFileAttributes(path);
        if (dwAttrib == -1) {
                return(FALSE);
        }
        if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) {
                return(TRUE);
        }
        return(FALSE);
} /* dir_isvaliddir */

/***************************************************************************
 * Function: dir_scan
 *
 * Purpose:
 *
 * Scan the directory given. Add all files to the list
 * in alphabetic order, and add all directories in alphabetic
 * order to the list of child DIRITEMs. If bRecurse is true, go on to
 * recursive call dir_scan for each of the child DIRITEMs
 */
void
dir_scan(DIRECT dir, BOOL bRecurse)
{
        PSTR path;
        int size;
        DIRECT child;
        BOOL bMore;
        long filesize;
        BOOL bIsDir;
        LPSTR name;

        HANDLE hFind;
        WIN32_FIND_DATA finddata;

        char debugmsg[200];
        wsprintf(debugmsg, "scandir: %s %s\n",
                 dir->relname, bRecurse?"recursive":"non-recursive"
                );

        /* make the complete search string including *.* */
        size = lstrlen(dir->head->rootname);
        size += lstrlen(dir->relname);

        /* add on one null and *.* */
        size += 4;

        path = LocalLock(LocalAlloc(LHND, size));

        lstrcpy(path, dir->head->rootname);

        /* omit the . at the beginning of the relname, and the
         * .\ if there is a trailing \ on the rootname
         */
        if (path[strlen(path)-1] == '\\') {
                lstrcat(path, &dir->relname[2]);
        } else {
                lstrcat(path, &dir->relname[1]);
        }
        lstrcat(path, "*.*");

        /* read all entries in the directory */
        hFind = FindFirstFile(path, &finddata);
        bMore = (hFind != (HANDLE) -1);
        LocalUnlock(LocalHandle ( (PSTR) path));
        LocalFree(LocalHandle ( (PSTR) path));

        while (bMore) {

                bIsDir = (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
                name = (LPSTR) &finddata.cFileName;
                filesize = finddata.nFileSizeLow;
                if (!bIsDir) {

                        dir_addfile(dir, name, filesize);

                } else if ( (lstrcmp(name, ".") != 0) &&
                           ( lstrcmp(name, "..") != 0) ) {

                        dir_adddirect(dir, name);
                }

                bMore = FindNextFile(hFind, &finddata);
        }

        FindClose(hFind);

        dir->bScanned = TRUE;
        dir->pos = DL_FILES;

        if (bRecurse) {
                List_TRAVERSE(dir->directs, child) {
                        dir_scan(child, TRUE);
                }
        }

} /* dir_scan */


/***************************************************************************
 * Function: dir_addfile
 *
 * Purpose:
 *
 * Add the file 'path' to the list of files in dir, in order.
 */
void
dir_addfile(DIRECT dir, LPSTR path, DWORD size)
{
        DIRITEM pfile;

        AnsiLowerBuff(path, lstrlen(path));  // needless?

        List_TRAVERSE(dir->diritems, pfile) {
                /////if (lstrcmpi(pfile->name, path) > 0) {
                if (utils_CompPath(pfile->name, path) > 0) {

                        /* goes before this one */
                        pfile = List_NewBefore(dir->diritems, pfile, sizeof(struct diritem));
                        dir_fileinit(pfile, dir, path, size);
                        return;
                }
        }
        /* goes at end */
        pfile = List_NewLast(dir->diritems, sizeof(struct diritem));
        dir_fileinit(pfile, dir, path, size);
} /* dir_addfile */


/***************************************************************************
 * Function: dir_addirect
 *
 * Purpose:
 *
 * Add a new directory in alphabetic order on
 * the list dir->directs
 *
 */
void
dir_adddirect(DIRECT dir, LPSTR path)
{
        DIRECT child;
        LPSTR finalel;
        char achTempName[256];

        AnsiLowerBuff(path, lstrlen(path));
        List_TRAVERSE(dir->directs, child) {

                int cmpval;

                /* we need to compare the child name with the new name.
                 * the child name is a relname with a trailing
                 * slash - so compare only the name up to but
                 * not including the final slash.
                 */
                finalel = dir_finalelem(child->relname);

                /*
                 * we cannot use strnicmp since this uses a different
                 * collating sequence to lstrcmpi. So copy the portion
                 * we are interested in to a null-term. buffer.
                 */
                strncpy(achTempName, finalel, lstrlen(finalel)-1);
                achTempName[lstrlen(finalel)-1] = '\0';

                cmpval = utils_CompPath(achTempName, path);

                if (cmpval > 0) {

                        /* goes before this one */
                        child = List_NewBefore(dir->directs, child, sizeof(struct direct));
                        dir_dirinit(child, dir->head, dir, path);
                        return;
                }
        }
        /* goes at end */
        child = List_NewLast(dir->directs, sizeof(struct direct));
        dir_dirinit(child, dir->head, dir, path);
} /* dir_adddirect */


/***************************************************************************
 * Function: dir_cleardirect
 *
 * Purpose:
 *
 * Free all memory associated with a DIRECT (including freeing
 * child lists). Don't de-alloc the direct itself (allocated on a list)
 */
void
dir_cleardirect(DIRECT dir)
{
        DIRITEM pfile;
        DIRECT child;

        /* clear contents of files list */
        List_TRAVERSE(dir->diritems, pfile) {
                gmem_free(hHeap, pfile->name, lstrlen(pfile->name));
                if ((pfile->localname) && (pfile->bLocalIsTemp)) {

                        /*
                         * the copy will have copied the attributes,
                         * including read-only. We should unset this bit
                         * so we can delete the temp file.
                         */
                        SetFileAttributes(pfile->localname,
                                GetFileAttributes(pfile->localname)
                                        & ~FILE_ATTRIBUTE_READONLY);
                        DeleteFile(pfile->localname);
                        gmem_free(hHeap, pfile->localname, 256);
                        pfile->localname = NULL;
                }

        }
        List_Destroy(&dir->diritems);

        /* clear contents of dirs list (recursively) */
        List_TRAVERSE(dir->directs, child) {
                dir_cleardirect(child);
        }
        List_Destroy(&dir->directs);

        gmem_free(hHeap, dir->relname, lstrlen(dir->relname) + 1);

} /* dir_cleardirect */

/***************************************************************************
 * Function: dir_finalelem
 *
 * Purpose:
 *
 * Return a pointer to the final element in a path. Note that
 * we may be passed relnames with a trailing final slash - ignore this
 * and return the element before that final slash.
 */
LPSTR
dir_finalelem(LPSTR path)
{
        LPSTR chp;
        int size;

        /* is the final character a slash ? */
        size = lstrlen(path) - 1;
        if (path[size] == '\\') {
                /* find the slash before this */
                for (size-- ; size > 0; size--) {
                        if (path[size] == '\\') {
                                /* skip the slash itself */
                                size++;
                                break;
                        }
                }
                return(&path[size]);
        }
        /* look for final slash */
        chp = strrchr(path, '\\');
        if (chp != NULL) {
                return(chp+1);
        }

        /* no slash - is there a drive letter ? */
        chp = strrchr(path, ':');
        if (chp != NULL) {
                return(chp+1);
        }

        /* this is a final-element anyway */
        return(path);

} /* dir_finalelem */

/***************************************************************************
 * Function: dir_getpathsize
 *
 * Purpose:
 *
 * Find the size of a file given a pathname to it 
 */
long
dir_getpathsize(LPSTR path)
{
        int fh;
        OFSTRUCT os;
        long size;
        fh = OpenFile(path, &os, OF_READ|OF_SHARE_DENY_NONE);
        if (fh == -1) {
                return(0);
        }

        size = GetFileSize( (HANDLE) fh, NULL);
        _lclose(fh);
        return(size);
} /* dir_getpathsize */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\scandir.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * SCANDIR.H
 *
 */

/* Handle to the list of files scanned */
typedef struct dirlist FAR * DIRLIST;

/* Handle to one item within the list of files */
typedef struct diritem FAR * DIRITEM;


DIRLIST dir_buildlist(LPSTR pathname, BOOL bOnDemand);
void dir_delete(DIRLIST list);
BOOL dir_isfile(DIRLIST list);
DIRITEM dir_firstitem(DIRLIST list);
DIRITEM dir_nextitem(DIRLIST list, DIRITEM previtem, BOOL fDeep);

/* Filenames
 *
 * From a DIRITEM, you can query either the relative or the full name.
 *
 * The relative name does not include the tree root that was originally
 * passed to dir_buildlist. The full name does include this. Note however
 * that if you passed a relative name to dir_buildlist, the full
 * name you get back will not be an *absolute* pathname.
 *
 * Thus, if you call dir_buildlist with "c:\",
 * we will return:
 *      relative name:  ".\config.sys"
 *      full name:      "c:\config.sys"
 *
 * If you call dir_buildlist with ".\geraintd",
 * we will return:
 *      relative name:  ".\source\scandir.h"
 *      full name:      ".\geraintd\source\scandir.h"
 *
 * In both cases, we return a pointer to a filename string: you must
 * call dir_freefullname or dir_freerelname to free this memory when you
 * have finished with it. Depending on the implementation, one or other
 * (or possibly both) of these names will have been built specially
 * when you called the query function.
 *
 * You can also return a pointer to the tree root name. (In the above
 * examples this would be c:\ and .\geraintd). Depending on the implementation,
 * this may have been forced to an absolute path.
 *
 */

LPSTR dir_getfullname(DIRITEM item);
LPSTR dir_getrelname(DIRITEM item);
LPSTR dir_getroot_item(DIRITEM item);
LPSTR dir_getroot_list(DIRLIST dl);
void dir_freefullname(DIRITEM item, LPSTR fullname);
void dir_freerelname(DIRITEM item, LPSTR relname);
void dir_freeroot_item(DIRITEM item, LPSTR rootname);
void dir_freeroot_list(DIRLIST dl, LPSTR rootname);
LPSTR dir_getopenname(DIRITEM item);
void dir_freeopenname(DIRITEM item, LPSTR openname);
int dir_openfile(DIRITEM item);
void dir_closefile(DIRITEM item, int fh);
long dir_getfilesize(DIRITEM item);
BOOL dir_copy(DIRITEM item, LPSTR newroot);
BOOL dir_startcopy(DIRLIST dl);
int dir_endcopy(DIRLIST dl);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by WINDIFF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\line.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * LINE.H
 */

typedef struct fileline FAR * LINE;

LINE line_new(LPSTR text, int linelength, UINT linenr, LIST list);
void line_delete(LINE line);
void line_reset(LINE line);
BOOL line_compare(LINE line1, LINE line2);
BOOL line_link(LINE line1, LINE line2);
LPSTR line_gettext(LINE line);
int line_gettabbedlength(LINE line, int tabstops);
DWORD line_gethashcode(LINE line);
LINE line_getlink(LINE line);
UINT line_getlinenr(LINE line);
BOOL line_isblank(LINE line);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\list.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: LIST.C
*
*
* Functions:
*
* Alloc()
* Free()
* List_Init()
* List_Dump()
* List_Show()
* List_Create()
* List_Destroy()
* List_AddFirst()
* List_NewFirst()
* List_DeleteFirst()
* List_AddLast()
* List_NewLast()
* LIst_DeleteLast()
* List_AddAfter()
* List_NewAfter()
* List_AddBefore()
* List_NewBefore()
* List_Delete()
* List_DeleteForwards()
* List_DeleteBackwards()
* List_ItemLength()
* List_First()
* List_Last()
* List_Next()
* List_Prev()
* List_Clear()
* List_IsEmpty()
* SwitchLists()
* List_Join()
* List_InsertListAfter()
* List_InsertListBefore()
* List_SplitAfter()
* List_SplitBefore()
* List_Card()
* List_IsOK()
* LIst_MakeOK()
* List_Check()
* List_Recover()
*
* Comments:
*
*
****************************************************************************/

#include <memory.h>
#include <windows.h>

#include "gutils.h"
#include "list.h"

#define memcpy  memcpy

char msg[80];  /* a temp for building up wsprintf messages in */

#define BLOCKSIZE 25000
 typedef struct
 { HANDLE hMem;     /* memory handle for this block */
   int iInUse;    /* number of allocations taken out of it.  0 => free it */
   int iNext;     /* next byte to use */
   char chData[BLOCKSIZE];
 } BLOCK, FAR *PBLOCK;

static CRITICAL_SECTION CritSec;  /* to protect pCurrent */
#define List_Enter_Crit(x)      EnterCriticalSection(x)
#define List_Leave_Crit(x)      LeaveCriticalSection(x)

static PBLOCK pCurrent = NULL;  /* block currently in use */
                          /* must always be either NULL or valid */

 /* Allocate storage for List elements.  n.b. after a call to this
    you MUST record the value of pCurrent as you need to hand that in
    to Free.  You don't hand in the value of the actual storage.
    See screed above.
    This function Enters the critical section.  The caller must Leave it.
 */
static LPVOID Alloc(int size)
 { HANDLE hMem;
   LPVOID pRet;
   List_Enter_Crit(&CritSec);
   if ((pCurrent==NULL)||(pCurrent->iNext+size>BLOCKSIZE+1))
   { hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE,(DWORD)(sizeof(BLOCK)));
     if (hMem==NULL)
       { pCurrent = NULL;
         OutputDebugString("GlobalAlloc failed!!\n");
         return NULL;
       }
     pCurrent = (PBLOCK)GlobalLock(hMem);
     if (pCurrent==NULL)
       { OutputDebugString("GlobalLock failed!!\n");
         return NULL;
       }
     pCurrent->hMem = hMem;
     pCurrent->iInUse = 0;
     pCurrent->iNext = 0;
   }
   pRet = &(pCurrent->chData[pCurrent->iNext]);
   ++(pCurrent->iInUse);
   pCurrent->iNext += size;

   /* for MIPS we must also ensure that the data is aligned 4 byte*/
   pCurrent->iNext += 3;
   pCurrent->iNext -= pCurrent->iNext % 4;

   return pRet;
 } /* Alloc */

static void Free(PBLOCK pBlock, LPVOID p)
 { HANDLE hMem;
   List_Enter_Crit(&CritSec);
    --pBlock->iInUse;
   if (pBlock->iInUse<=0)
   { if (pBlock->iInUse<0)
     { wsprintf(msg,"Problem in List code.\nList block allocation negative (%d)", pBlock->iInUse);
       MessageBox(NULL, msg, "Error", MB_OK | MB_ICONSTOP);
     }
     hMem = pBlock->hMem;
     GlobalUnlock(hMem);
     GlobalFree(hMem);
     if (pCurrent==pBlock) pCurrent = NULL; /* defend the invariant */
   }
   List_Leave_Crit(&CritSec);
 } /* Free */

  /* The following definition tells the truth about what an ITEM is.  The
  |  header file says only that there's a structure with the tag item_tag and
  |  that a LIST is a pointer to one.  Here we spell out what that structure
  |  is (and a LIST is still a pointer to one).  A PLIST is defined as a
  |  pointer to one of those, but is only really used because the C
  |  parameter mechanism demands an extra level of indirection for a
  |  parameter that can be updated.  (Modula-2 VAR parameter).
  */
  typedef struct item_tag
  { struct item_tag FAR *pitNext;    /* to next in circular list */
    struct item_tag FAR *pitPrev;    /* to prev in circular list */
    PBLOCK pBlock;               /* to memory block */
    BOOL bAnchor;                /* TRUE iff an anchor block */
    BOOL bOK;                    /* true unless a list op has failed */
    int iLen;                    /* length of data only */
    char Data[1];                /* the caller's data.  The '1' is a lie */
  } ITEM;

  /* For an anchor block, only the fields pitNext thru bAnchor are allocated.
  |  For a normal list element, Data may well be longer than 1 byte.
  |  The bOK flag is to support a style of programming where several
  |  successive operations can be done without having to check the return
  |  code at each stage.  At the end, the list can be examined to see if
  |  the data in it is valid or if it has been made invalid by the failure
  |  of any of the previous operations.  Certain operations may result in
  |  having no list at all if they fail (e.g. create) and for these, you'd
  |  better check the result at once!
  |  ??? Some of this screed belongs in the header!!!
  */

  static int iAnchorSize;      /* Size of anchor block (no data, no dummy) */
  static int iHeaderSize;      /* Size of data block not counting Data
                                  and offset from cursor back to item.
                               */
  static BOOL bInited = FALSE; /* TRUE <=> iAnchorSize and iHeaderSize are OK*/

#define MOVEBACK(Curs)                                               \
   { Curs = ((char FAR *)Curs-iHeaderSize); } /*move from Data to pitNext*/

  /*==================================================================
  || Lists are circular, doubly linked with an anchor block which holds
  || pointers to both ends.  Every block has a flag which shows whether
  || it's an anchor or not.
  ||
  || Empty list:
  ||
  ||      -------------
  ||     |             |
  ||     |   Anchor    |
  ||     v   -------   |
  ||  Ul--->| Next--+--|
  ||        |-------|  |
  ||        | Prev--+--
  ||         -------
  ||
  || One entry list:
  ||
  ||      ------------------------------------
  ||     |                                    |
  ||     |   Anchor                           |
  ||     v   -------                ------    |
  ||  Ul--->| Next--+------------->| Next-+---|
  ||        |-------|    |         |------|   |
  ||        | Prev--+----          | Prev-+---
  ||         -------               |------|
  ||                               | Len  |
  ||                               |------|
  ||                               | Data |
  ||                                ------
  || Two entry list:
  ||
  ||      -------------------------------------------------
  ||     | ---------------    ---------------              |
  ||     ||               |  |               |             |
  ||     ||  Anchor       |  |               |             |
  ||     vv  --------     |  v    ------     |    ------   |
  ||  Ul--->| Next--+-----+----->| Next-+----+-->| Next-+--
  ||        |-------|     |      |------|  | |   |------|
  ||        | Prev--+--    ------+-Prev |  |  ---+-Prev |
  ||         -------   |         |------|  |     |------|
  ||                   |         | Len  |  |     | Len  |
  ||                   |         |------|  |     |------|<----Cursor
  ||                   |         | Data |  |     | Data |
  ||                   |          ------   |      ------
  ||                   |                   |
  ||                    -------------------
  ||
  || etc.
  ||
  || Note that an external cursor (i.e one which is seen by the caller)
  || points to the Data field, not to the start of the structure.
  || This allows easy access to the data by the user at the cost of a
  || slightly slower traverse.
  || Within this module, we may sometimes traverse a list with  a cursor
  || that points to the start of an item.  This is called an item cursor.
  ===================================================================*/

  /*------------------------------------------------------------------
  | Set iAnchorSize and iHeaderSize.  Implementation independent!
   -------------------------------------------------------------------*/
void APIENTRY List_Init(void)
  {  LIST P;
     P = (LIST)&P;                  /* really any old address will do */
     iAnchorSize = (char FAR *)&(P->iLen) - (char FAR *)&(P->pitNext);
     iHeaderSize = (char FAR *)&(P->Data) - (char FAR *)&(P->pitNext);
     InitializeCriticalSection(&CritSec);
     /* assumes layout in storage is linear */
  }

  /* Dump the internals to the debugger. */
void APIENTRY List_Dump(LPSTR Header, LIST lst)
  {  LIST pit;
     char msg[250];

     OutputDebugString(Header);  OutputDebugString("\n");
     pit = lst;
     do
     { wsprintf(msg,"%8x %8x %8x %ld %s "
               , pit, pit->pitNext, pit->pitPrev, pit->iLen
               , (pit->bAnchor ? "Anchor" : "Data")
               );
       OutputDebugString(msg);
       if (pit->pitNext->pitPrev != pit)
         OutputDebugString(" Next Prev error!!");
       if (pit->pitPrev->pitNext != pit)
         OutputDebugString(" Prev Next error!!");
       OutputDebugString("\n");
       pit = pit->pitNext;
     } while (pit!=lst);
     OutputDebugString("End of list dump\n");
  } /* List_Dump */

  /* Dump hex representation of handle to debugger */
void APIENTRY List_Show(LIST lst)
  { char msg[50];               
    wsprintf(msg, "%8x", lst);
    OutputDebugString(msg);
  } /* List_Show */

  /*------------------------------------------------------------------
  | Create a list.  It will be initially empty
   -------------------------------------------------------------------*/
LIST APIENTRY List_Create(void)
  {  LIST lst;
     if (!bInited) {List_Init(); }          /* prevent some silly errors */
     lst = Alloc(iAnchorSize);
     if (lst==NULL) { return NULL; }
     lst->pBlock = pCurrent;
     List_Leave_Crit(&CritSec);
     lst->bOK = TRUE;
     lst->pitNext = lst;
     lst->pitPrev = lst;
     lst->bAnchor = TRUE;
     /* no length field set in an anchor block */
     return lst;
  } /* List_Create */

  /*------------------------------------------------------------------
  | Destroy *plst.  It does not need to be empty first
   -------------------------------------------------------------------*/
  void APIENTRY List_Destroy(PLIST plst)
  {  LIST pitP;    /* item cursor on * plst */
     LIST pitQ;    /* item cursor runs one step ahead of pitQ */

     if (plst==NULL)
       return;
     /* There is at least an anchor block to destroy */
     pitP = *plst;
     do
     {  pitQ = pitP->pitNext;
        Free(pitP->pBlock, pitP);
        pitP = pitQ;
     }while(pitP != *plst);
     *plst = NULL;
  } /* List_Destroy */

  /*------------------------------------------------------------------
  | Add an item holding Object to the beginning of * plst
   -------------------------------------------------------------------*/
  void APIENTRY List_AddFirst(LIST lst, LPVOID pObject, UINT uLen)
  {  LIST pit;      /* newly allocated item */

     if (lst==NULL)
       return;
     pit = Alloc(iHeaderSize+uLen);
     if (pit==NULL) { lst->bOK = FALSE; return; }
     pit->pBlock = pCurrent;
     List_Leave_Crit(&CritSec);
     pit->iLen = uLen;
     pit->pitPrev = lst;
     pit->pitNext = lst->pitNext;
     lst->pitNext->pitPrev = pit; /* for empty list that set lst->pitPrev */
     lst->pitNext = pit;
     pit->bAnchor = FALSE;
     memcpy( &(pit->Data), pObject, uLen );
  } /* List_AddFirst */

  /*------------------------------------------------------------------
  | Return the address of the place for Len bytes of data in a new
  | item at the start of lst
   -------------------------------------------------------------------*/
  LPVOID APIENTRY List_NewFirst(LIST lst, UINT uLen)
  {  LIST pit;

     if (lst==NULL)
       return NULL;
     pit = Alloc(iHeaderSize+uLen);
     if (pit==NULL) { lst->bOK = FALSE; return NULL; }
     pit->pBlock = pCurrent;
     List_Leave_Crit(&CritSec);
     pit->iLen = uLen;
     pit->pitPrev = lst;
     pit->pitNext = lst->pitNext;
     lst->pitNext->pitPrev = pit; /* for empty list that set lst->pitPrev */
     lst->pitNext = pit;
     pit->bAnchor = FALSE;
     return (char FAR *)&(pit->Data);
  } /* List_NewFirst */

  /*------------------------------------------------------------------
  | Delete the first item in lst.  Error if lst is empty
   -------------------------------------------------------------------*/
  void APIENTRY List_DeleteFirst(LIST lst)
  {  LIST pit;

     if (lst==NULL)
       return;
                               /* attempting to delete the anchor block! */
     if (lst->pitNext==lst) {lst->bOK = FALSE; }
     else
        {  pit = lst->pitNext;
           pit->pitNext->pitPrev = pit->pitPrev;
           pit->pitPrev->pitNext = pit->pitNext;
           Free(pit->pBlock, pit);
        }
  } /* List_DeleteFirst */

  /*------------------------------------------------------------------
  | Add an item holding Object to the end of lst
   -------------------------------------------------------------------*/
  void APIENTRY List_AddLast(LIST lst, LPVOID pObject, UINT uLen)
  {  LIST pit;

     if (lst==NULL)
       return;
     pit = Alloc(iHeaderSize+uLen);
     if (pit==NULL) { lst->bOK = FALSE; return; }
     pit->pBlock = pCurrent;
     List_Leave_Crit(&CritSec);
     pit->iLen = uLen;
     pit->pitNext = lst;
     pit->pitPrev = lst->pitPrev;
     lst->pitPrev->pitNext = pit; /* for empty list that set lst->pitNext */
     lst->pitPrev = pit;
     pit->bAnchor = FALSE;
     memcpy( &(pit->Data), pObject, uLen );
  } /* ListAddLast */

  /*------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  |  item at the end of lst
   -------------------------------------------------------------------*/
  LPVOID APIENTRY List_NewLast(LIST lst, UINT uLen)
  {  LIST pit;

     if (lst==NULL)
       return NULL;
     pit = Alloc(iHeaderSize+uLen);
     if (pit==NULL) { lst->bOK = FALSE; return NULL; }
     pit->pBlock = pCurrent;
     List_Leave_Crit(&CritSec);
     pit->iLen = uLen;
     pit->pitNext = lst;
     pit->pitPrev = lst->pitPrev;
     lst->pitPrev->pitNext = pit; /* for empty list that set lst->pitNext */
     lst->pitPrev = pit;
     pit->bAnchor = FALSE;
     return (char FAR *)&(pit->Data);
  } /* ListNewLast */

  /*------------------------------------------------------------------
  | Delete the last item in lst.  Error if lst is empty
   -------------------------------------------------------------------*/
  void APIENTRY List_DeleteLast(LIST lst)
  {  LIST pit;

     if (lst==NULL)
       return;
                               /* attempting to delete the anchor block! */
     if (lst->pitNext==lst) {lst->bOK = FALSE; }
     else
        {  pit = lst->pitPrev;
           pit->pitNext->pitPrev = pit->pitPrev;
           pit->pitPrev->pitNext = pit->pitNext;
           Free(pit->pBlock, pit);
        }
  } /* List_DeleteLast */

  /*--------------------------------------------------------------------
  | Add an item holding * pObject to lst immediately after Curs.
  | List_AddAfter(lst,NULL,pObject,Len) adds it to the start of the lst
   ---------------------------------------------------------------------*/
  void APIENTRY List_AddAfter( LIST lst
                    , LPVOID Curs
                    , LPVOID pObject
                    , UINT uLen
                    )
  {  LIST pitNew;
     LIST pitAfter;

     if (lst==NULL)
       return;
     if (Curs==NULL){ List_AddFirst(lst, pObject, uLen);}
     else
        {  MOVEBACK(Curs);
           pitAfter = (LIST)Curs;
           pitNew = Alloc(iHeaderSize+uLen);
           if (pitNew==NULL) { lst->bOK = FALSE; return; }
           pitNew->pBlock = pCurrent;
           List_Leave_Crit(&CritSec);
           pitNew->iLen = uLen;
           pitNew->pitPrev = pitAfter;
           pitNew->pitNext = pitAfter->pitNext;
           pitAfter->pitNext->pitPrev = pitNew;
           pitAfter->pitNext = pitNew;
           pitNew->bAnchor = FALSE;
           memcpy( &(pitNew->Data), pObject, uLen );
        }
  } /* List_AddAfter */

  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately after Curs.
  | List_NewAfter(Lst,NULL,uLen) returns a pointer
  | to space for uLen bytes in a new first element.
   ---------------------------------------------------------------------*/
  LPVOID APIENTRY List_NewAfter(LIST lst, LPVOID Curs, UINT uLen)
  {  LIST pitNew;
     LIST pitAfter;

     if (lst==NULL)
       return NULL;
     if (Curs==NULL){ return List_NewFirst(lst, uLen);}
     else
        {  MOVEBACK(Curs);
           pitAfter = (LIST)Curs;
           pitNew = Alloc(iHeaderSize+uLen);
           if (pitNew==NULL) { lst->bOK = FALSE; return NULL; }
           pitNew->pBlock = pCurrent;
           List_Leave_Crit(&CritSec);
           pitNew->iLen = uLen;
           pitNew->pitPrev = pitAfter;
           pitNew->pitNext = pitAfter->pitNext;
           pitAfter->pitNext->pitPrev = pitNew;
           pitAfter->pitNext = pitNew;
           pitNew->bAnchor = FALSE;
           return (char FAR *)&(pitNew->Data);
        }
  } /* List_NewAfter */

  /*--------------------------------------------------------------------
  | Add an item holding Object to lst immediately before Curs.
  | List_AddBefore(Lst,NULL,Object,uLen) adds it to the end of the list
   ---------------------------------------------------------------------*/
  void APIENTRY List_AddBefore( LIST lst
                     , LPVOID Curs
                     , LPVOID pObject
                     , UINT uLen
                     )
  {  LIST pitNew;
     LIST pitBefore;

     if (lst==NULL)
       return;
     if (Curs==NULL){ List_AddLast(lst, pObject, uLen);}
     else
        {  MOVEBACK(Curs);
           pitBefore = (LIST)Curs;
           pitNew = Alloc(iHeaderSize+uLen);
           if (pitNew==NULL) { lst->bOK = FALSE; return; }
           pitNew->pBlock = pCurrent;
           List_Leave_Crit(&CritSec);
           pitNew->iLen = uLen;
           pitNew->pitNext = pitBefore;
           pitNew->pitPrev = pitBefore->pitPrev;
           pitBefore->pitPrev->pitNext = pitNew;
           pitBefore->pitPrev = pitNew;
           pitNew->bAnchor = FALSE;
           memcpy( &(pitNew->Data), pObject, uLen );
        }
  } /* List_AddBefore */

  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately before Curs.
  | List_NewBefore(Lst,NULL,uLen) returns a pointer
  | to space for uLen bytes in a new last element.
   ---------------------------------------------------------------------*/
  LPVOID APIENTRY List_NewBefore(LIST lst, LPVOID Curs, UINT uLen )
  {  LIST pitNew;
     LIST pitBefore;

     if (lst==NULL)
       return NULL;
     if (Curs==NULL){ return List_NewLast(lst, uLen);}
     else
        {  MOVEBACK(Curs);
           pitBefore = (LIST)Curs;
           pitNew = Alloc(iHeaderSize+uLen);
           if (pitNew==NULL) { lst->bOK = FALSE; return NULL; }
           pitNew->pBlock = pCurrent;
           List_Leave_Crit(&CritSec);
           pitNew->iLen = uLen;
           pitNew->pitNext = pitBefore;
           pitNew->pitPrev = pitBefore->pitPrev;
           pitBefore->pitPrev->pitNext = pitNew;
           pitBefore->pitPrev = pitNew;
           pitNew->bAnchor = FALSE;
           return (char FAR *) &(pitNew->Data);
        }
  } /* List_NewBefore */

  /*------------------------------------------------------------------
  | Delete the item that Curs identifies.
  | This will be only a few (maybe as little as 3) machine instructions
  | quicker than DeleteForwards or DeleteBackwards but leaves Curs dangling.
  | It is therefore NOT usually to be preferred.
  | It may be useful when you have a function which returns an LPVOID
  | since the argument does not need to be a variable.
  |     Trivial example: List_Delete(List_First(L));
   -------------------------------------------------------------------*/
  void APIENTRY List_Delete(LPVOID Curs)
  {  LIST pit;

     if(Curs==NULL)
       return;
     MOVEBACK(Curs)
     pit = (LIST)Curs;
     pit->pitNext->pitPrev = pit->pitPrev;
     pit->pitPrev->pitNext = pit->pitNext;
     Free(pit->pBlock, pit);
  } /* List_Delete */

  /*-----------------------------------------------------------------------
  | Delete the item that Curs identifies and return a cursor that
  | identifies the next item (NULL if already on last)
   ------------------------------------------------------------------------*/
  LPVOID APIENTRY List_DeleteForwards(LPVOID Curs)
  {  LIST pitDel;  /* the item to delete */
     LIST pitN;    /* the item after (could be anchor) */

     if(Curs==NULL)
       return NULL;
     MOVEBACK(Curs)
     pitDel = (LIST)Curs;
     pitN = pitDel->pitNext;

     pitN->pitPrev = pitDel->pitPrev;
     pitDel->pitPrev->pitNext = pitN;
     Free(pitDel->pBlock, pitDel);
     if (pitN->bAnchor) return NULL;
     else return (char FAR *)&(pitN->Data);
  } /* List_DeleteForwards */

  /*-----------------------------------------------------------------------
  | Delete the item that Curs identifies and return a cursor that
  | identifies the previous item (NULL if already on first)
   ------------------------------------------------------------------------*/
  LPVOID APIENTRY List_DeleteBackwards(LPVOID Curs)
  {  LIST pitDel;  /* the one to delete */
     LIST pitB;    /* the one before */

     if(Curs==NULL)
       return NULL;
     MOVEBACK(Curs)
     pitDel = (LIST)Curs;
     pitB = pitDel->pitPrev;
     pitDel->pitNext->pitPrev = pitB;
     pitB->pitNext = pitDel->pitNext;
     Free(pitDel->pBlock, pitDel);
     if (pitB->bAnchor) return NULL;
     else return (char FAR *)&(pitB->Data);
  } /* List_DeleteBackwards */

  /*-------------------------------------------------------------------
  | Return the length of the object identified by the cursor Curs
   -------------------------------------------------------------------*/
  int APIENTRY List_ItemLength(LPVOID Curs)
  {  LIST pit;

     if(Curs==NULL)
       return 0;
     MOVEBACK(Curs)
     pit = (LIST)Curs;
     return pit->iLen;
  } /* List_ItemLength */

  /*------------------------------------------------------------------
  | Return the address of the first object in lst
  |  If lst is empty then Return NULL.
   -------------------------------------------------------------------*/
  LPVOID APIENTRY List_First(LIST lst)
  {  
     if (lst==NULL)
       return NULL;
     if (lst->pitNext==lst) { return NULL; }
     return &(lst->pitNext->Data);
  } /* List_First */

  /*------------------------------------------------------------------
  | Return the address of the last object in lst
  | If lst is empty then return NULL.
   -------------------------------------------------------------------*/
  LPVOID APIENTRY List_Last(LIST lst)
  {  
     if (lst==NULL)
       return NULL;
     if (lst->pitNext==lst) { return NULL; }
     return &(lst->pitPrev->Data);
  } /* List_Last */

  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error.
   -------------------------------------------------------------------*/
  LPVOID APIENTRY List_Next(LPVOID Curs)
  {  LIST pit;

     if(Curs==NULL)
       return NULL;
     MOVEBACK(Curs)
     pit = (LIST)Curs;
     pit = pit->pitNext;
     if (pit->bAnchor) {return NULL;} else {return &(pit->Data);}
  } /* List_Next */

  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error.
   -------------------------------------------------------------------*/
  LPVOID APIENTRY List_Prev(LPVOID Curs)
  {  LIST pit;

     if(Curs==NULL)
       return NULL;
     MOVEBACK(Curs)
     pit = (LIST)Curs;
     pit = pit->pitPrev;
     if (pit->bAnchor) {return NULL;} else {return &(pit->Data);}
  } /* List_Prev */

  /*-------------------------------------------------------------------
  | Arrange that lst is empty after this call
   --------------------------------------------------------------------*/
  void APIENTRY List_Clear(LIST lst)
  {  LIST pitP;   /* item cursor on List, points to element starts */
     LIST pitQ;   /* runs one step ahead of pitP                   */

     if (lst==NULL)
       return;
     pitP = lst->pitNext;   /* first element of list proper */
     while (pitP!=lst)      /* while not wrapped onto anchor */
        {  pitQ = pitP->pitNext;
           Free(pitP->pBlock, pitP);
           pitP = pitQ;
        }
     lst->bOK = TRUE;
     lst->pitNext = lst;
     lst->pitPrev = lst;
  } /* List Clear */

  /*---------------------------------------------------------------------
  | Return TRUE if and only if lst is empty
   ----------------------------------------------------------------------*/
  BOOL APIENTRY List_IsEmpty(LIST lst)
  {  if (lst==NULL)
       return TRUE;   /* well it's sort of true isn't it? */
     return lst->pitNext ==lst;
  } /* List_IsEmpty */

  /*------------------------------------------------------------------
  | l1 had better be empty.  l1 then acquires all the elements from l2
   -------------------------------------------------------------------*/
  void APIENTRY SwitchLists(LIST l1, LIST l2)
  {  /* connect l1 to l2's elements, l1 had better be initially empty */
     l1->pitPrev = l2->pitPrev;
     l1->pitNext = l2->pitNext;
     /* connect the elements to l1 anchor block. */
     l1->pitPrev->pitNext = l1;
     l1->pitNext->pitPrev = l1;
     /* make l2 empty */
     l2->pitPrev = l2;
     l2->pitNext = l2;
  } /* SwitchLists */

  /*-----------------------------------------------------------------------
  | l1 := l1||l2; l2 := empty
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets all the elements of l1 in their original order followed by
  | all the elements of l2 in the order they were in in l2.
  | l2 becomes empty.
   ------------------------------------------------------------------------*/
  void APIENTRY List_Join(LIST l1, LIST l2)
  {  if((l1==NULL)||(l2==NULL))
       return;
     l1->bOK = l1->bOK &&l2->bOK;  /* result OK if both inputs OK */
     l2->bOK = TRUE;               /* as l2 always becomes empty */
     if (l2->pitNext==l2) { /* no elements need moving */ }
     else if (l2->pitNext==l2) { SwitchLists(l1,l2); return; }
     else
        {  l2->pitNext->pitPrev = l1->pitPrev;
           l1->pitPrev->pitNext = l2->pitNext;
           l1->pitPrev = l2->pitPrev;
           l1->pitPrev->pitNext = l1;
           l2->pitNext = l2;
           l2->pitPrev = l2;
        }
  } /* List_Join */

  /*-----------------------------------------------------------------------
  | Let L1 be *pl1 and L2 be *pl2
  | L1 := L1[...Curs] || L2 || L1[Curs+1...]; L2 := empty
  | Curs=NULL means insert L2 at the start of L1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | L1 gets the elements of L1 from the start up to and including the element
  | that Curs points at, in their original order,
  | followed by all the elements that were in L2, in their original order,
  | followed by the rest of L1
   ------------------------------------------------------------------------*/
  void APIENTRY List_InsertListAfter(LIST l1, LIST l2, LPVOID Curs)
  {  LIST pitA;     /* The element after Curs, could be anchor */
     LIST pit;      /* The start of the element that Curs points at
                    |  or the anchor block if Curs==NULL
                    */

     if ( (l1==NULL) || (l2==NULL))
       return;
     l1->bOK = l1->bOK && l2->bOK;
     l2->bOK = TRUE;
     if (l2->pitNext==l2) { /* no elements need moving */ }
     else if ( l1->pitNext==l1)
     {  /* the easy way to code this would be simply to switch the two
        |  pointers l1 and l2, but they are value parameters and we don't
        |  want to change that.
        */
        SwitchLists(l1,l2);
        return;
     }
     else
     {  if(Curs==NULL){ pit = l1;}
        else
        {  MOVEBACK(Curs)
           pit = (LIST)Curs;
        }
        /* pit points to a block to insert after, could be anchor */
        pitA = pit->pitNext;      /* Cannot be same as P, already checked */
        l2->pitNext->pitPrev = pit;    /*  P<-- elems-of-l2    A */
        l2->pitPrev->pitNext = pitA;   /*  P<-- elems-of-l2 -->A */
        pit->pitNext = l2->pitNext;    /*  P<-->elems-of-l2 -->A */
        pitA->pitPrev = l2->pitPrev;   /*  P<-->elems-of-l2<-->A */

        l2->pitNext = l2;
        l2->pitPrev = l2;
     }
  }  /* List_InsertListAfter */


  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty
  | Curs=NULL means insert l2 at the end of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to but not including the
  | element that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1.
   ------------------------------------------------------------------------*/
  void APIENTRY List_InsertListBefore(LIST l1, LIST l2, LPVOID Curs)
  {  LIST pitB;     /* The element before Curs, could be anchor */
     LIST pit;      /* The start of the element that Curs points at
                    |  or the anchor block if Curs==NULL
                    */

     if ((l1==NULL) || (l2==NULL))
       return;
     l1->bOK = l1->bOK && l2->bOK;
     l2 ->bOK = TRUE;
     if (l2->pitNext==l2) { /* no action needed */ }
     else if (l1->pitNext==l1)
     {  /* the easy way to code this would be simply to switch the two
        |  pointers l1 and l2, but they are value parameters and we don't
        |  want to change that.
        */
        SwitchLists(l1,l2);
        return;
     }
     else
     {  if(Curs==NULL) { pit = l1; }
        else
        {  MOVEBACK(Curs)
           pit = (LIST)Curs;
        }

        /* P points to a block to insert before, could be anchor */
        pitB = pit->pitPrev;       /* Cannot be same as P, already checked */
        l2->pitNext->pitPrev = pitB; /*  B<-- elems-of-L2    P */
        l2->pitPrev->pitNext = pit;  /*  B<-- elems-of-L2 -->P */
        pitB->pitNext = l2->pitNext; /*  B<-->elems-of-L2 -->P */
        pit->pitPrev = l2->pitPrev;  /*  B<-->elems-of-L2<-->P */
        l2->pitNext = l2;
        l2->pitPrev = l2;
     }
  } /* List_InsertListBefore */


  /*-----------------------------------------------------------------------
  | Let l1 be l1 and l2 be l2
  | Split l2 off from the front of l1:    final l2,l1 = original l1
  |
  | Split l1 into l2: objects of l1 up to and including Curs object
  |               l1: objects of l1 after Curs
  | Any original contents of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all.
  | The elements themselves are not moved.
   ------------------------------------------------------------------------*/
  void APIENTRY List_SplitAfter(LIST l1, LIST l2, LPVOID Curs)
  {  LIST pit;

     if ((l1==NULL) || (l2==NULL))
       return;
     if (l2->pitNext!=l2){ List_Clear(l2); };
     if (Curs!=NULL)
     {  MOVEBACK(Curs)
        pit = (LIST)Curs;
        /* Curs had better be an item in l1! l2 had better be created! */
        if (pit==l1) { l1->bOK = FALSE; l2->bOK = FALSE; return; }
        if (pit->pitNext==l1)
        {  /* transfer whole of l2 to l1 */
           SwitchLists(l2,l1);
           return;
        }
        l2->pitPrev = pit;
        l2->pitNext = l1->pitNext;
        l1->pitNext = pit->pitNext;
        pit->pitNext = l2;
        l2->pitNext->pitPrev = l2;
        l1->pitNext->pitPrev = l1;
     }
  } /* List_SplitAfter */

  /*----------------------------------------------------------------------
  | Split l2 off from the back of l1:  final l1,l2 = original l1
  |
  | Split l1 into l1: objects of l1 up to but not including Curs object
  |               l2: objects of l1 from Curs onwards
  | Any original contants of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all.
  | The elements themselves are not moved.
   -----------------------------------------------------------------------*/
  void APIENTRY List_SplitBefore(LIST l1, LIST l2, LPVOID Curs)
  {  LIST pit;

     if ((l1==NULL) || (l2==NULL))
       return;
     if (l2->pitNext!=l2){ List_Clear(l2); }
     if (Curs!=NULL)
     {  MOVEBACK(Curs)
        pit = (LIST)Curs;
        /* Curs had better be an item in L1! L2 had better be created! */
        if (pit==l1){ l1->bOK = FALSE; l2->bOK = FALSE; return; }
        if (pit->pitPrev==l1) { SwitchLists(l2,l1); return; }
        l2->pitNext = pit;
        l2->pitPrev = l1->pitPrev;
        l1->pitPrev = pit->pitPrev;
        pit->pitPrev = l2;
        l2->pitPrev->pitNext = l2;
        l1->pitPrev->pitNext = l1;
     }
  } /* List_SplitBefore */

  /*------------------------------------------------------------------
  | Return the number of items in L
   -------------------------------------------------------------------*/
  int APIENTRY List_Card(LIST lst)
  {  LIST pit;     /* item cursor on lst */
     int cit;

     if (lst==NULL)
       return 0;    /* well it is sort of 0 */
     pit = lst->pitNext;
     cit = 0;
     while(pit!=lst)
        {  cit++;
           pit = pit->pitNext;
        }
     return cit;
  } /* List_Card */

  /*------------------------------------------------------------------
  | Check return code
   -------------------------------------------------------------------*/
  BOOL APIENTRY List_IsOK(LIST lst)
  {  if(lst==NULL)
       return FALSE;       /* well it is sick ain't it! */
     return lst->bOK;
  } /* List_IsOK */

  /*------------------------------------------------------------------
  | Set return code to good
   -------------------------------------------------------------------*/
  void APIENTRY List_MakeOK(LIST lst)
  {  if(lst==NULL)
       return;
     lst->bOK = TRUE;
  } /* List_MakeOK */

  BOOL APIENTRY List_Check(LIST lst)
  { LIST pel;
    BOOL bOK;
    /*-----------------------------------------------------------------
    | Check the anchor block has the Anchor flag set.
    | Run through the LIST using the Anchor flag (which should be FALSE)
    | to mark where we have been (to test for loops in the chain)
    | and carry on until we see the Anchor flag again.  Check that this
    | is the anchor block that we started from.  Now do another pass
    | turning the Anchor flags off again and checking the Prev pointers.
     -------------------------------------------------------------------*/
    if(lst==NULL) return FALSE;  /* Should we trap?  Arguable */
    bOK = lst->bAnchor;
    pel = lst->pitNext;
    while(! pel->bAnchor)
    { pel->bAnchor = TRUE;
      pel = pel->pitNext;
    }
    bOK = bOK && (pel==lst);
    if(bOK)
    { /* Turn all the bAnchor flags off */
      pel = lst;
      do
      { pel->bAnchor = FALSE;
        bOK = bOK & (pel->pitNext->pitPrev==pel);
        pel = pel->pitNext;
      } while (pel!=lst);
      lst->bAnchor = TRUE;  /* except the real one */
    }
    else
    { /* just turn off those that we set on */
      pel = lst->pitNext;
      while (pel->bAnchor)
      { pel->bAnchor = FALSE;
        pel = pel->pitNext;
      }
      lst->bAnchor = TRUE;
    }
    return bOK;
  } /* List_Check */


  void APIENTRY List_Recover(PLIST plst)
  {  LIST Last, P,Q;
     BOOL OK;
    /* For no particular reason we presume that the forward chain
       is good and reconstruct the back chain from it.  A better
       algorithm would do the kind of things that List_Check does
       to figure out where the problems lie.  This just steps along
       until it sees either an address that it has already seen or
       else the anchor block.  (It's an n-squared algorithm).
       It links the last good block found back to the anchor and
       fixes all the Anchor flags.
    */
    if (plst==NULL) return;
    if (*plst==NULL)
    {  *plst = List_Create();
       return;
    }
    (*plst)->bAnchor = TRUE;
    P = (*plst)->pitNext;
    Last = *plst;
    for (; ; )
    {  if (P==*plst) break;
       Last = P;
       if (P->pitNext!=*plst)
       {   OK = TRUE;
           Q = *plst;
           for (; ; )
           {   OK &= (P->pitNext!=Q);
               if (Q==P) break;
               Q = Q->pitNext;
           }
           if (!OK) break;
       }
       P = P->pitNext;
    }
    P = *plst;
    while (P!=Last)
    {  P->pitNext->pitPrev = P;
       P->bAnchor = FALSE;
       P = P->pitNext;
    }
    Last->pitNext = *plst;
    (*plst)->pitPrev = Last;
    (*plst)->bAnchor = TRUE;
    (*plst)->bOK = TRUE;   /* Here's hoping! */
  } /* List_Recover */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\list.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * LIST.H
 */
/*------------------------------------------------------------------------
| Abstract data type LIST OF (*untyped*) object.
| Different lists can have different types of object in them
| Different items in a list can have different types of object in them.
| The price of this lack of typing is that you have a slightly more
| awkward syntax and you get no help from the compiler if you try to
| put the wrong type of data into the list.
|
| The list is implemented as a collection of items.  Within the item
| somewhere is the object.
|
| Objects are stored UNALIGNED within items.
|
| Use:
|
|   #include <list.h>
|   . . .
|   LIST MyList; (* or LIST liMyList for Hungarians *)
|   . . .
|   MyList = List_Create();
|   List_AddLast(MyList,&MyObject,sizeof(OBJECT));
|
| In the abstract a LIST is a list of objects.  The representation
| is a linked collection of items.  The manner of the linking is
| implementation dependent (as I write this it's linear but when you
| read it it might be a tree (See Knuth for why a tree)).
|
| A LIST is a "handle" for a list which may be thought of as a POINTER
| (whether it is really a pointer or not is implementation dependent)
| so that it can be copied at the risk of creating an alias. e.g.
|
|   L = List_Create();
|   L1 = L;             (* L and L1 are both healthy and empty *)
|   List_AddFirst(L, &elem, sizeof(elem));
|   (* L1 may also appear to have one object, there again it may be sick *)
|   L1 = L;               (* Now they both surely see the one element *)
|   List_Destroy(&L1);    (* L is almost certainly sick now too *)
|   L1 = List_Create();   (* All bets off as to what L is like now
|                            but L1 is empty and healthy
|                         *)
|
| If two handles compare equal then the lists must be equal, but
| unequal handles could address two similar lists i.e. the same list
| of objects held in two different LISTs of items (like pointers).
|
| A LIST can be transferred from one variable to another like this:
|
|   NewList = OldList;           (* copy the handle *)
|   OldList = List_Create();     (* kill the old alias *)
|
| and the Create statement can be omitted if OldList is never touched again.
|
| Items are identified by Cursors.  A cursor is the address of an object
| within an item in the list. i.e. it is the address of the piece of your
| data that you had inserted.  (It is probably NOT the address of the item).
| It is typed as pointer to void here, but you should declare it as a pointer
| to whatever sort of object you are putting in the LIST.
|
| The operations AddFirst, AddLast, AddAfter and AddBefore
| all copy elements by direct assignment.  If an element is itself
| a complex structure (say a tree) then this will only copy a pointer
| or an anchor block or whatever and give all the usual problems of
| aliases.  Clear will make the list empty, but will only free the
| storage that it can "see" directly.  SplitBefore or Split After may
| also perform a Clear operation.  To deal with fancy data structures
| use New rather than Add calls and copy the data yourself
|   e.g.  P = List_NewLast(MyList, sizeof(MyArray[14])*(23-14+1));
|         CopyArraySlice(P, MyArray, 14, 23);
|
| The operations NewFirst, NewLast, NewAfter, NewBefore, First and Last
| all return pointers to elements and thus allow you to do any copying.
| This is how you might copy a whole list of fancy structures:
|
|    void CopyFancyList(LIST * To, LIST From)
|             (* Assumes that To has been Created and is empty *)
|    { PELEMENT Cursor;
|      PELEMENT P;
|
|      List_TRAVERSE(From, Cursor);
|      { P = List_NewLast(To, sizeof(element) );
|        FancyCopy(P, Cursor);    (* Copy so that *Cursor==*P afterwords *)
|      }
|    }
 --------------------------------------------------------------------*/

  typedef struct item_tag FAR * LIST;
  typedef LIST FAR * PLIST;

  void APIENTRY List_Init(void);
  /* MUST BE CALLED BEFORE ANY OF THE OTHER FUNCTIONS. */

  void APIENTRY List_Dump(LPSTR Header, LIST lst);
  /* Dump the internals to current output stream -- debug only */

  void APIENTRY List_Show(LIST lst);
  /* Dump hex representation of handle to current out stream -- debug only */

  LIST APIENTRY List_Create(void);
  /* Create a list.  It will be initially empty */

  void APIENTRY List_Destroy(PLIST plst);
  /* Destroy *plst.  It does not need to be empty first.
  |  All storage directly in the list wil be freed.
  */

  void APIENTRY List_AddFirst(LIST lst, LPVOID pObject, UINT uLen);
  /* Add an item holding Object to the beginning of * plst */

  LPVOID APIENTRY List_NewFirst(LIST lst, UINT uLen);
  /* Return the address of the place for Len bytes of data in a new
  |  item at the start of *plst
  */

  void APIENTRY List_DeleteFirst(LIST lst);
  /* Delete the first item in lst.  Error if lst is empty */

  void APIENTRY List_AddLast(LIST lst, LPVOID pObject, UINT uLen);
  /* Add an item holding Object to the end of lst */

  LPVOID APIENTRY List_NewLast(LIST lst, UINT uLen);
  /* Return the address of the place for uLen bytes of data in a new
  |  item at the end of lst
  */

  void APIENTRY List_DeleteLast(LIST lst);
  /* Delete the last item in lst.  Error if lst is empty */

  void APIENTRY List_AddAfter( LIST lst
                    , LPVOID Curs
                    , LPVOID pObject
                    , UINT uLen
                    );
  /*--------------------------------------------------------------------
  | Add an item holding *pObject to lst immediately after Curs.
  | List_AddAfter(lst, NULL, pObject, Len) adds it to the start of the lst
   ---------------------------------------------------------------------*/

  LPVOID APIENTRY List_NewAfter(LIST lst, LPVOID Curs, UINT uLen);
  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately after Curs.
  | List_NewAfter(Lst, NULL, uLen) returns a pointer
  | to space for uLen bytes in a new first element.
   ---------------------------------------------------------------------*/

  void APIENTRY List_AddBefore( LIST lst
                     , LPVOID Curs
                     , LPVOID pObject
                     , UINT uLen
                     );
  /*--------------------------------------------------------------------
  | Add an item holding Object to lst immediately before Curs.
  | List_AddBefore(Lst, NULL, Object, uLen) adds it to the end of the list
   ---------------------------------------------------------------------*/

  LPVOID APIENTRY List_NewBefore(LIST lst, LPVOID Curs, UINT uLen );
  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately before Curs.
  | List_NewBefore(Lst, NULL, uLen) returns a pointer
  | to space for uLen bytes in a new last element.
   ---------------------------------------------------------------------*/

  void APIENTRY List_Delete(LPVOID Curs);
  /*------------------------------------------------------------------
  | Delete the item that Curs identifies.
  | This will be only a few (maybe as little as 3) machine instructions
  | quicker than DeleteAndNext or DeleteAndPrev but leaves Curs dangling.
  | It is therefore NOT usually to be preferred.
  | It may be useful when you have a function which returns an LPVOID
  | since the argument does not need to be a variable.
  |     Trivial example: List_Delete(List_First(L));
   -------------------------------------------------------------------*/

  int APIENTRY List_ItemLength(LPVOID Curs);
  /* Return the length of the object identified by the cursor Curs */

  /*------------------------------------------------------------------
  | TRAVERSING THE ULIST
  |
  | LIST lst;
  | object * Curs;
  | . . .
  | Curs = List_First(lst);
  | while (Curs!=NULL)
  | {  DoSomething(*Curs);   (* Curs points to YOUR data not to chain ptrs *)
  |    Curs = List_Next(Curs);
  | }
  |
  | This is identically equal to
  | List_TRAVERSE(lst, Curs)  // note NO SEMI COLON!
  | {  DoSomething(*Curs); }
   -------------------------------------------------------------------*/

  #define List_TRAVERSE(lst, curs)  for(  curs=List_First(lst)            \
                                       ;  curs!=NULL                      \
                                       ;  curs = List_Next((LPVOID)curs)  \
                                       )

  LPVOID APIENTRY List_First(LIST lst);
  /*------------------------------------------------------------------
  | Return the address of the first object in lst
  |  If lst is empty then Return NULL.
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Last(LIST lst);
  /*------------------------------------------------------------------
  | Return the address of the last object in lst
  | If lst is empty then return NULL.
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Next(LPVOID Curs);
  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error.
  | List_Next(List_Prev(curs)) is illegal if curs identifies first el
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Prev(LPVOID Curs);
  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error.
  | List_Prev(List_Next(curs)) is illegal if curs identifies last el
  --------------------------------------------------------------------*/

  /*------------------------------------------------------------------
  |  Whole list operations
   -----------------------------------------------------------------*/
  void APIENTRY List_Clear(LIST lst);
  /* arrange that lst is empty after this */

  BOOL APIENTRY List_IsEmpty(LIST lst);
  /* Return TRUE if and only if lst is empty */

  void APIENTRY List_Join(LIST l1, LIST l2);
  /*-----------------------------------------------------------------------
  | l1 := l1||l2; l2 := empty
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets all the elements of l1 in their original order followed by
  | all the elements of l2 in the order they were in in l2.
  | l2 becomes empty.
   ------------------------------------------------------------------------*/

  void APIENTRY List_InsertListAfter(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs] || l2 || l1[Curs+1...]; l2 := empty
  | Curs=NULL means insert l2 at the start of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to and including the element
  | that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1
   ------------------------------------------------------------------------*/

  void APIENTRY List_InsertListBefore(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty
  | Curs=NULL means insert l2 at the end of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to but not including the
  | element that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1.
   ------------------------------------------------------------------------*/

  void APIENTRY List_SplitAfter(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | Let l1 be l1 and l2 be l2
  | Split l2 off from the front of l1:    final l2,l1 = original l1
  |
  | Split l1 into l2: objects of l1 up to and including Curs object
  |               l1: objects of l1 after Curs
  | Any original contents of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all.
  | The elements themselves are not moved.
   ------------------------------------------------------------------------*/

  void APIENTRY List_SplitBefore(LIST l1, LIST l2, LPVOID Curs);
  /*----------------------------------------------------------------------
  | Split l2 off from the back of l1:  final l1,l2 = original l1
  |
  | Split l1 into l1: objects of l1 up to but not including Curs object
  |               l2: objects of l1 from Curs onwards
  | Any original contants of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all.
  | The elements themselves are not moved.
   -----------------------------------------------------------------------*/

  int APIENTRY List_Card(LIST lst);
  /* Return the number of items in L */

  /*------------------------------------------------------------------
  | Error handling.
  |
  | Each list has within it a flag which indicates whether any illegal
  | operation has been detected (e.g. DeleteFirst when empty).
  | Rather than have a flag on every operation, there is a flag held
  | within the list that can be queried when convenient.  Many operations
  | do not have enough redundancy to allow any meaningful check.  This
  | is a design compromise (for instance to allow P = List_Next(P);
  | rather than P = List_Next(L, P); which is more awkward, especially
  | if L is actually a lengthy phrase).
  |
  | List_IsOK tests this flag (so is a very simple, quick operation).
  | MakeOK sets the flag to TRUE, in other words to accept the current
  | state of the list.
  |
  | It is possible for a list to be damaged (whether or not the flag
  | says OK) for instance by the storage being overwritten.
  |
  | List_Check attempts to verify that the list is sound (for instance where
  | there are both forward and backward pointers they should agree).
  |
  | List_Recover attempts to make a sound list out of whatever debris is left.
  | If the list is damaged, Recover may trap (e.g. address error) but
  | if the list was damaged then ANY operation on it may trap.
  | If Check succeeds without trapping then so will Recover.
   -----------------------------------------------------------------*/

  BOOL APIENTRY List_IsOK(LIST lst);
  /* Check return code */

  void APIENTRY List_MakeOK(LIST lst);
  /* Set return code to good */

  BOOL APIENTRY List_Check(LIST lst);
  /* Attempt to validate the chains */

  void APIENTRY List_Recover(PLIST plst);
  /* Desperate stuff.  Attempt to reconstruct something */

/*------------------------------------------------------------------
|  It is designed to be as easy to USE as possible, consistent
|  only with being an opaque type.
|
|  In particular, the decision to use the address of an object a list cursor
|  means that there is a small amount of extra arithmetic (in the
|  IMPLEMENTATION) in cursor operations (e.g. Next and Prev).
|  and spurious arguments are avoided whenever possible, even though
|  it would allow greater error checking.
|
| Of the "whole list" operations, Clear is given because it seems to be
| a common operation, even though the caller can implement it with almost
| the same efficiency as the List implementation module.
| Join, Split and InsertListXxx cannot be implemented efficiently without
| knowing the representation.
 --------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\state.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * STATE.H
 *
 * Definition of the results of comparisons for files and for lines
 * within files.
 *
 * These need to be globally declared so that the UI code in windiff.c can
 * map states to the colour scheme (to correctly highlight changed lines).
 *
 * They apply to files (compitem_getstate() ) and to sections in the
 * composite list (section_getstate). All lines within a section have the
 * same state. The UI code will use the view_getstate() function to find the
 * state for a given line on the screen.
 *
 */

/* Applies to both lines or files: they are the same */
#define STATE_SAME              1

/* Applies to files.  Same size, date, time */
#define STATE_COMPARABLE        2

/* Applies to files.  Different, but only in blanks
 * This state only turns up after the file has been expanded.
 */
#define STATE_SIMILAR           3

/* Applies only to files */

/* - Files differ (and can be expanded) */
#define STATE_DIFFER            4

/* They are only in the left or right tree */
#define STATE_FILELEFTONLY      5
#define STATE_FILERIGHTONLY     6


/* Applies to lines only */

/* the line only exists in one of the lists */
#define STATE_LEFTONLY          7       /* line only in left file */
#define STATE_RIGHTONLY         8       /* line only in right file */


/* The line is the same in both files, but in
 * different places (thus the line will appear twice in the composite list,
 * once with each of these two states
 */
#define STATE_MOVEDLEFT         9       /* this is the left file version */
#define STATE_MOVEDRIGHT        10      /* this is the right file version*/

/* In processing the sections to build the composite list, we need to
 * track which sections have been processed.  After this the left and
 * right lists of sections are of no further interest
 */
#define STATE_MARKED            99
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\status.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: STATUS.C
*
* Status line handler.
*
* Functions:
*
* StatusInit()
* StatusCreate()
* StatusHeight()
* StatusAlloc()
* StatusAddItem()
* StatusCreateTools()
* StatusDeleteTools()
* StatusWndProc()
* StatusResize()
* StatusCalcHeight()
* StatusCalcWidth()
* StatusGetItem()
* LowerRect()
* RaiseRect()
* StatusPaint()
* BottomRight()
* TopLeft()
* StatusButtonDown()
* StatusButtonUp()
* InitDC()
*
* Comments:
*
****************************************************************************/

#include <windows.h>
#include <string.h>

#include "gutils.h"


/* --- data structures ------------------------------------------------- */
#define SF_MAXLABEL     80   /* no more than 80 in an item within the bar */
                             /* Is this adequate for long pathnames on a
                                hi-res screen?
                             */

typedef struct statel {
        int type;                       /* SF_BUTTON or SF_STATIC */
        int flags;                      /* SF_VAR => variable width
                                           SF_LEFT=> left aligned (else right)
                                           SF_RAISE=> paint as 'raised' 3d rect
                                           SF_LOWER=> paint as lowered 3D rect
                                           SF_SZMIN=>together with SF_VAR
                                                     allows minimum size for
                                                     var sized item
                                           SF_SZMAX=>see SZMIN and use nouse
                                        */
        int id;                         /* control id */
        int width;                      /* width of control in chars */
        char text[SF_MAXLABEL+1];       /* null-term string for label */

        RECT rc;                        /* used by status.c */
} STATEL, FAR * PSTATEL;

typedef struct itemlist {
        int nitems;
        PSTATEL statels;

        int selitem;                    /* used by status.c */
        BOOL isselected;                /* used by status.c */
} ILIST, FAR * PILIST;

/* prototypes of routines in this module */

void StatusCreateTools(void);
void StatusDeleteTools(void);
long APIENTRY StatusWndProc(HWND, UINT, UINT, LONG);
void StatusResize(HWND hWnd, PILIST pilist);
int StatusCalcHeight(HWND hWnd, PSTATEL ip);
int StatusCalcWidth(HWND hWnd, PSTATEL ip);
PSTATEL StatusGetItem(PILIST plist, int id);
void LowerRect(HDC hDC, LPRECT rcp);
void RaiseRect(HDC hDC, LPRECT rcp);
void StatusPaint(HWND hWnd, PILIST iplistp);
void BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners);
void TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners);
void StatusButtonDown(HDC hDC, PSTATEL ip);
void StatusButtonUp(HDC hDC, PSTATEL ip);
void InitDC(HDC hdc);


/*--global data---------------------------------------------------------*/

HPEN hpenHilight, hpenLowlight;
HPEN hpenBlack, hpenNeutral;
HBRUSH hbrBackground; /* pieces and board */
HFONT hFont;
int status_charheight, status_charwidth;

/* default pt size for font (tenths of a pt) */
#define         DEF_PTSIZE      80

/***************************************************************************
 * Function: StatusInit
 *
 * Purpose:
 *
 * Create window class
 */
BOOL
StatusInit(HANDLE hInstance)
{
        WNDCLASS    wc;
        BOOL resp;
        TEXTMETRIC tm;
        HDC hDC;


        StatusCreateTools();

        wc.style = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS;
        wc.lpfnWndProc = (WNDPROC) StatusWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = sizeof(HANDLE);
        wc.hInstance = hInstance;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = hbrBackground;
        wc.lpszClassName = (LPSTR) "gdstatusclass";
        wc.lpszMenuName = NULL;

        resp = RegisterClass(&wc);

        hDC = GetDC(NULL);
        InitDC(hDC);
        GetTextMetrics(hDC, &tm);
        status_charheight = (int)(tm.tmHeight + tm.tmExternalLeading);
        status_charwidth = (int)tm.tmAveCharWidth;
        ReleaseDC(NULL, hDC);

        return(resp);
}

/*
/***************************************************************************
 * Function: StatusCreate
 *
 * Purpose:
 *
 * Create and show the window
 */
HWND APIENTRY
StatusCreate(HANDLE hInst, HWND hParent, int id, LPRECT rcp, HANDLE hmem)
{

        HWND hWnd;

        /* create a child window of status class */


        hWnd = CreateWindow("gdstatusclass",
                        NULL,
                        WS_CHILD | WS_VISIBLE,
                        rcp->left,
                        rcp->top,
                        (rcp->right - rcp->left),
                        (rcp->bottom - rcp->top),
                        hParent,
                        (HANDLE) id,
                        hInst,
                        (LPVOID) hmem);

        return(hWnd);
}

/***************************************************************************
 * Function: StatusHeight
 *
 * Purpose:
 *
 * Return default height of this window 
 */
int APIENTRY
StatusHeight(HANDLE hmem)
/* The window has a number of items which are arranged horizontally,
   so the window height is the maximum of the individual heights
*/
{
        PILIST plist;
        int i;
        int sz;
        int maxsize = 0;

        plist = (PILIST) GlobalLock(hmem);
        if (plist != NULL) {
                for (i = 0; i<plist->nitems; i++) {
                        sz = StatusCalcHeight(NULL, &plist->statels[i]);
                        maxsize = max(sz, maxsize);
                }
        }
        GlobalUnlock(hmem);
        if (maxsize > 0) {
                return(maxsize + 4);
        } else {
                return(status_charheight + 4);
        }
}

/***************************************************************************
 * Function: StatusAlloc
 *
 * Purpose:
 *
 * Alloc the plist struct and return handle to caller 
 */
HANDLE FAR PASCAL
StatusAlloc(int nitems)
{
        HANDLE hmem;
        PILIST pilist;
        LPSTR chp;

        hmem = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                sizeof(ILIST) + (sizeof(STATEL) * nitems));
        chp = GlobalLock(hmem);
        if (chp == NULL) {
                return(NULL);
        }

        pilist = (PILIST) chp;
        pilist->nitems = nitems;
        pilist->statels = (PSTATEL) &chp[sizeof(ILIST)];
        GlobalUnlock(hmem);

        return(hmem);
}


/***************************************************************************
 * Function: StatusAddItem
 *
 * Purpose:
 *
 * Insert an item into the plist 
 */
BOOL FAR PASCAL
StatusAddItem(HANDLE hmem, int itemnr, int type, int flags, int id,
        int width, LPSTR text)
{
        PILIST pilist;
        PSTATEL pel;

        pilist = (PILIST) GlobalLock(hmem);
        if ((pilist == NULL) || (itemnr >= pilist->nitems)) {
                GlobalUnlock(hmem);
                return(FALSE);
        }
        pel = &pilist->statels[itemnr];
        pel->type = type;
        pel->flags = flags;
        pel->id = id;
        pel->width = width;
        if (text == NULL) {
                pel->text[0] = '\0';
        } else {
                lstrcpy(pel->text, text);
        }


        GlobalUnlock(hmem);
        return(TRUE);
}

/***************************************************************************
 * Function: InitDC
 *
 * Purpose:
 *
 * Initialize colors and font
 */ 
void
InitDC(HDC hdc)
{
        SetBkColor(hdc, RGB(192,192,192));
        SelectObject(hdc, hbrBackground);
        SelectObject(hdc, hFont);
}


/***************************************************************************
 * Function: StatusCreateTools
 *
 * Purpose:
 *
 * Create Pens and brushes
 */ 
void
StatusCreateTools()
{
    LOGFONT lf;
    HDC hdc;
    int scale;

    hbrBackground = CreateSolidBrush(RGB(192,192,192));
    hpenHilight = CreatePen(0, 1, RGB(255, 255, 255));
    hpenLowlight = CreatePen(0, 1, RGB(128, 128, 128));
    hpenNeutral = CreatePen(0, 1, RGB(192, 192, 192));
    hpenBlack = CreatePen(0, 1, RGB(0, 0, 0));

    hdc = GetDC(NULL);
    scale = GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(NULL, hdc);

    lf.lfHeight = -MulDiv(DEF_PTSIZE, scale, 720);
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = FW_REGULAR;
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
    lf.lfFaceName[0] = '\0';
#ifdef COMPLEX
    hFont = CreateFontIndirect(&lf);
#else
    hFont = GetStockObject(SYSTEM_FONT);
#endif



}

/***************************************************************************
 * Function: StatusDeleteTools
 *
 * Purpose:
 *
 * Delete brushes and pens
 */
void
StatusDeleteTools()
{
    DeleteObject(hbrBackground);
    DeleteObject(hpenHilight);
    DeleteObject(hpenLowlight);
    DeleteObject(hpenBlack);
    DeleteObject(hpenNeutral);

#ifdef COMPLEX
    DeleteObject(hFont);
#endif
}

/***************************************************************************
 * Function: StatusWndProc
 *
 * Purpose:
 *
 * Main winproc for status windows
 *
 * handles create/destroy and paint requests
 */

long FAR PASCAL
StatusWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam)
{
    HANDLE hitems;
    PSTATEL ip;
    PILIST plist;
    CREATESTRUCT FAR * cp;
    int i;
    HDC hDC;
    RECT rc;
    POINT pt;

    switch(message) {

    case WM_CREATE:
        cp = (CREATESTRUCT FAR *) lParam;
        hitems = (HANDLE) (LONG) cp->lpCreateParams;
        SetWindowLong(hWnd, 0,  (LONG)hitems);
        plist = (PILIST) GlobalLock(hitems);
        if (plist != NULL) {
                plist->selitem = -1;
                GlobalUnlock(hitems);
        }
        break;

    case WM_SIZE:
        hitems = (HANDLE) GetWindowLong(hWnd, 0);
        plist = (PILIST) GlobalLock(hitems);
        if (plist != NULL) {
                StatusResize(hWnd, plist);
                GlobalUnlock(hitems);
        }
        break;

    case WM_PAINT:
        hitems = (HANDLE) GetWindowLong(hWnd, 0);
        plist = (PILIST) GlobalLock(hitems);
        StatusPaint(hWnd, plist);
        GlobalUnlock(hitems);

        break;

    case WM_LBUTTONUP:
        hitems = (HANDLE) GetWindowLong(hWnd, 0);
        plist = (PILIST) GlobalLock(hitems);
        pt.x = LOWORD(lParam);
        pt.y = HIWORD(lParam);

        if (plist == NULL) {
                break;
        }
        if (plist->selitem != -1) {
                ip = &plist->statels[plist->selitem];
                if (plist->isselected) {
                        hDC = GetDC(hWnd);
                        InitDC(hDC);
                        StatusButtonUp(hDC, ip);
                        ReleaseDC(hWnd, hDC);
                }
                plist->selitem = -1;
                ReleaseCapture();
                if (PtInRect(&ip->rc, pt)) {
                        SendMessage(GetParent(hWnd), WM_COMMAND,
                                MAKELONG(ip->id, WM_LBUTTONUP), (LONG)hWnd);
                }
        }
        GlobalUnlock(hitems);
        break;

    case WM_LBUTTONDOWN:
        hitems = (HANDLE) GetWindowLong(hWnd, 0);
        plist = (PILIST) GlobalLock(hitems);
        if (plist == NULL) {
                break;
        }
        pt.x = LOWORD(lParam);
        pt.y = HIWORD(lParam);
        if (plist->selitem == -1) {
                for (i = 0; i< plist->nitems; i++) {
                        ip = &plist->statels[i];
                        if (PtInRect(&ip->rc, pt)) {
                                if (ip->type != SF_BUTTON) {
                                        break;
                                }
                                plist->selitem = i;
                                SetCapture(hWnd);

                                plist->isselected = TRUE;
                                hDC = GetDC(hWnd);
                                InitDC(hDC);
                                StatusButtonDown(hDC, ip);
                                ReleaseDC(hWnd, hDC);
                                break;
                        }
                }
        }
        GlobalUnlock(hitems);
        break;

    case WM_MOUSEMOVE:
        hitems = (HANDLE) GetWindowLong(hWnd, 0);
        plist = (PILIST) GlobalLock(hitems);
        if (plist == NULL) {
                break;
        }
        pt.x = LOWORD(lParam);
        pt.y = HIWORD(lParam);
        if (plist->selitem != -1) {
                ip = &plist->statels[plist->selitem];
                if (PtInRect(&ip->rc, pt)) {
                        if (!plist->isselected) {
                                hDC = GetDC(hWnd);
                                InitDC(hDC);
                                StatusButtonDown(hDC, ip);
                                ReleaseDC(hWnd, hDC);
                                plist->isselected = TRUE;
                        }
                } else {
                        if(plist->isselected) {
                                hDC = GetDC(hWnd);
                                InitDC(hDC);
                                StatusButtonUp(hDC, ip);
                                ReleaseDC(hWnd, hDC);
                                plist->isselected = FALSE;
                        }
                }
        }
        GlobalUnlock(hitems);
        break;


    case WM_DESTROY:

        hitems = (HANDLE) GetWindowLong(hWnd, 0);
        GlobalUnlock(hitems);
        GlobalFree(hitems);

        SetWindowLong(hWnd, 0, 0L);
        break;

    case SM_NEW:
        hitems = (HANDLE) GetWindowLong(hWnd, 0);
        if (hitems != NULL) {
                GlobalFree(hitems);
        }
        hitems = (HANDLE) wParam;
        if (hitems == NULL) {
                SetWindowLong(hWnd, 0, 0L);
                InvalidateRect(hWnd, NULL, TRUE);
                break;
        }
        plist = (PILIST) GlobalLock(hitems);
        if (plist == NULL) {
                SetWindowLong(hWnd, 0, 0L);
                InvalidateRect(hWnd, NULL, TRUE);
                break;
        }
        plist->selitem = -1;
        StatusResize(hWnd, plist);
        GlobalUnlock(hitems);
        SetWindowLong(hWnd, 0, (LONG)hitems);
        InvalidateRect(hWnd, NULL, TRUE);
        break;

    case SM_SETTEXT:
        hitems = (HANDLE) GetWindowLong(hWnd, 0);
        if (hitems == NULL) {
                break;
        }
        plist = (PILIST) GlobalLock(hitems);
        ip = StatusGetItem(plist, wParam);
        if (ip != NULL) {
                if (lParam == 0) {
                        ip->text[0] = '\0';
                } else {
                        strncpy(ip->text, (LPSTR) lParam, SF_MAXLABEL);
                        ip->text[SF_MAXLABEL] = '\0';
                }

                /* if this is a variable width field, we need to redo
                 * all size calcs in case the field width has changed.
                 * in that case, we need to repaint the entire window
                 * and not just this field - so set rc to indicate the
                 * area to be redrawn.
                 */
                if (ip->flags & SF_VAR) {
                        StatusResize(hWnd, plist);
                        GetClientRect(hWnd, &rc);
                        RedrawWindow(hWnd, &rc, NULL,
                                RDW_INVALIDATE|RDW_ERASE|RDW_UPDATENOW);
                } else {
                        /* instead of just invalidating the window, we can
                         * force the window to be repainted now. This is
                         * essential for status updates during a busy
                         * loop when no messages are being processed,
                         * but we should still update the user on what's
                         * happening.
                         */
                        RedrawWindow(hWnd, &ip->rc, NULL,
                                RDW_INVALIDATE|RDW_NOERASE|RDW_UPDATENOW);
                }

        }
        GlobalUnlock(hitems);
        break;

    default:
        return(DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0;
}

/***************************************************************************
 * Function: StatusResize
 *
 * Purpose:
 *
 * Position the labels and buttons within the status window 
 */
void
StatusResize(HWND hWnd, PILIST iplistp)
{
        RECT rc;
        int curpos_right, curpos_left;
        int height, width;
        int i;
        PSTATEL ip;


        if (iplistp == NULL) {
                return;
        }
        GetClientRect(hWnd, &rc);
        curpos_left = rc.left + status_charwidth / 2;
        curpos_right = rc.right - (status_charwidth / 2);

        /* loop through all items setting their position rects.
         * items are flagged as being left or right. We place them
         * in order starting at the left and the right, with a single
         * char's width between each item
         */
        for (i = 0; i < iplistp->nitems; i++) {
                ip = &iplistp->statels[i];

                width = StatusCalcWidth(hWnd, ip);
                height = StatusCalcHeight(hWnd, ip);
                ip->rc.top = (rc.bottom - height) / 2;
                ip->rc.bottom = ip->rc.top + height;

                /* see if  this item fits. Items that partially fit
                 * are placed reduced in size.
                 */
                if (ip->flags & SF_LEFT) {

                        if (curpos_left+width >= curpos_right) {
                                /* doesn't completely fit-does it partly? */
                                if ((curpos_left + 1) >= curpos_right){

                                        /* no - this item does not fit */
                                        ip->rc.left = 0;
                                        ip->rc.right = 0;
                                } else {
                                        /* partial fit */
                                        ip->rc.left = curpos_left;
                                        ip->rc.right = curpos_right - 1;
                                        curpos_left = curpos_right;
                                }
                        } else {
                                /* complete fit */
                                ip->rc.left = curpos_left;
                                ip->rc.right = curpos_left + width;
                                curpos_left += width + 1;
                        }
                } else {

                        /* same size check for right-aligned items */
                        if (curpos_right-width <= curpos_left) {

                                /* partial fit ? */
                                if (curpos_right <= curpos_left+1) {
                                        ip->rc.left = 0;
                                        ip->rc.right = 0;
                                } else {
                                        /* yes - partial fit */
                                        ip->rc.left = curpos_left + 1;
                                        ip->rc.right = curpos_right;
                                        curpos_right = curpos_left;
                                }
                        } else {
                                /* complete fit */
                                ip->rc.right = curpos_right;
                                ip->rc.left = curpos_right - width;
                                curpos_right -= (width + 1);
                        }
                }
        }
}


/***************************************************************************
 * Function: StatusPaint
 *
 * Purpose:
 *
 * Paint the status window
 */
void
StatusPaint(HWND hWnd, PILIST iplistp)
{
        RECT rc;
        HDC hDC;
        PAINTSTRUCT ps;
        int i;
        PSTATEL ip;
        HPEN hpenOld;

        GetClientRect(hWnd, &rc);
        hDC = BeginPaint(hWnd, &ps);
        InitDC(hDC);

        RaiseRect(hDC, &rc);
        if (iplistp == NULL) {
                EndPaint(hWnd, &ps);
                return;
        }
        for (i =0; i < iplistp->nitems; i++) {
                ip = &iplistp->statels[i];

                if (ip->rc.left == ip->rc.right) {
                        continue;
                }
                if (ip->type == SF_STATIC) {
                        if (ip->flags & SF_RAISE) {
                                RaiseRect(hDC, &ip->rc);
                        } else if (ip->flags & SF_LOWER) {
                                LowerRect(hDC, &ip->rc);
                        }
                        rc = ip->rc;
                        rc.left += (status_charwidth / 2);
                        rc.right--;
                        rc.top++;
                        rc.bottom--;
                        hpenOld = SelectObject(hDC, hpenNeutral);
                        Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
                        SelectObject(hDC, hpenOld);
                        DrawText(hDC, ip->text, lstrlen(ip->text), &rc,
                                        DT_LEFT | DT_VCENTER);
                } else {
                        StatusButtonUp(hDC, ip);
                }
        }

        EndPaint(hWnd, &ps);
}

/***************************************************************************
 * Function: RaiseRect
 *
 * Purpose:
 *
 */
void
RaiseRect(HDC hDC, LPRECT rcp)
{
        TopLeft(hDC, rcp, hpenHilight, FALSE);
        BottomRight(hDC, rcp, hpenLowlight, FALSE);
}

/***************************************************************************
 * Function: LowerRect
 *
 * Purpose:
 *
 */ 
void
LowerRect(HDC hDC, LPRECT rcp)
{
        TopLeft(hDC, rcp, hpenLowlight, FALSE);
        BottomRight(hDC, rcp, hpenHilight, FALSE);
}

/***************************************************************************
 * Function: StatusButtonUp
 *
 * Purpose:
 *
 */
void
StatusButtonUp(HDC hDC, PSTATEL ip)
{
        RECT rc;
        HPEN hpenOld;

        rc = ip->rc;
        TopLeft(hDC, &rc, hpenBlack, TRUE);
        BottomRight(hDC, &rc, hpenBlack, FALSE);

        rc.top++;
        rc.bottom--;
        rc.left++;
        rc.right--;
        TopLeft(hDC, &rc, hpenHilight, FALSE);
        BottomRight(hDC, &rc, hpenLowlight, TRUE);

        rc.top++;
        rc.bottom--;
        rc.left++;
        rc.right--;
        BottomRight(hDC, &rc, hpenLowlight, TRUE);
        rc.bottom--;
        rc.right--;
        hpenOld = SelectObject(hDC, hpenNeutral);
        Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
        SelectObject(hDC, hpenOld);
        DrawText(hDC, ip->text, lstrlen(ip->text), &rc, DT_CENTER | DT_VCENTER);
}

/***************************************************************************
 * Function: StatusButtonDown
 *
 * Purpose:
 *
 */
void
StatusButtonDown(HDC hDC, PSTATEL ip)
{
        RECT rc;
        HPEN hpenOld;

        rc = ip->rc;
        TopLeft(hDC, &rc, hpenBlack, TRUE);
        BottomRight(hDC, &rc, hpenBlack, FALSE);

        rc.top++;
        rc.bottom--;
        rc.left++;
        rc.right--;
        TopLeft(hDC, &rc, hpenLowlight, TRUE);
        rc.top++;
        rc.left++;
        TopLeft(hDC, &rc, hpenNeutral, TRUE);
        rc.top++;
        rc.left++;
        TopLeft(hDC, &rc, hpenNeutral, TRUE);
        rc.top++;
        rc.left++;
        hpenOld = SelectObject(hDC, hpenNeutral);
        Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
        SelectObject(hDC, hpenOld);
        DrawText(hDC, ip->text, lstrlen(ip->text), &rc, DT_CENTER | DT_VCENTER);
}

/***************************************************************************
 * Function: TopLeft
 *
 * Purpose:
 *
 */
void
TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners)
{
        HPEN hpenOld;
        int x, y;

        hpenOld = SelectObject(hDC, hpen);
        x = rcp->right - 1;
        y = rcp->bottom;
        if (!bCorners) {
                x--;
                y--;
        }
        MoveToEx(hDC, x, rcp->top, NULL);
        LineTo(hDC, rcp->left, rcp->top);
        LineTo(hDC, rcp->left, y);
        SelectObject(hDC, hpenOld);
}

/***************************************************************************
 * Function: BottomRight
 *
 * Purpose:
 *
 */
void
BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners)
{
        HPEN hpenOld;
        int x, y;

        hpenOld = SelectObject(hDC, hpen);
        x = rcp->left - 1;
        y = rcp->top;
        if (!bCorners) {
                x++;
                y++;
        }
        MoveToEx(hDC, rcp->right-1, y, NULL);
        LineTo(hDC, rcp->right-1, rcp->bottom-1);
        LineTo(hDC, x, rcp->bottom-1);
        SelectObject(hDC, hpenOld);
}

/***************************************************************************
 * Function: StatusGetItem
 *
 * Purpose:
 *
 */
PSTATEL
StatusGetItem(PILIST plist, int id)
{
        int i;

        if (plist == NULL) {
                return(NULL);
        }
        for (i = 0; i < plist->nitems; i++) {
                if (plist->statels[i].id == id) {
                        return(&plist->statels[i]);
                }
        }
        return(NULL);
}

/***************************************************************************
 * Function: StatusCalcWidth
 *
 * Purpose:
 *
 * Calculate the width of a given field. This is the width in characters
 * multiplied by the average character width, plus a few units for
 * borders.
 *
 * If SF_VAR is set, this field size varies depending on the text, so
 * we use GetTextExtent for the field size. If SF_VAR is selected, the caller
 * can specify that the size is not to exceed the (width * avecharwidth)
 * size (using SF_SZMAX) or that it is not be less than it (SF_SZMIN).
 */
int
StatusCalcWidth(HWND hWnd, PSTATEL ip)
{
        int ch_size, t_size;
        SIZE sz;
        HDC hDC;

        ch_size = ip->width * status_charwidth;
        if (ip->flags & SF_VAR) {
                hDC = GetDC(hWnd);
                InitDC(hDC);
                GetTextExtentPoint(hDC, ip->text, lstrlen(ip->text), &sz);
                ReleaseDC(hWnd, hDC);
                t_size = sz.cx;

                /*
                 * check this size against min/max size if
                 * requested
                 */

                if (ip->flags & SF_SZMIN) {
                        if (ch_size > t_size) {
                                t_size = ch_size;
                        }
                }
                if (ip->flags & SF_SZMAX) {
                        if (ch_size < t_size) {
                                t_size = ch_size;
                        }
                }
                ch_size = t_size;
        }

        if (ch_size != 0) {
                if (ip->type == SF_BUTTON) {
                        return(ch_size+6);
                } else {
                        return(ch_size+4);
                }
        } else {
                return(0);
        }
}

/***************************************************************************
 * Function: StatusCalcHeight
 *
 * Purpose:
 *
 * Calculate the height of a given field
 */
int
StatusCalcHeight(HWND hWnd, PSTATEL ip)
{
        int size;

        size = status_charheight;
        if (ip->type == SF_BUTTON) {
                return(size + 6);
        } else {
                return(size + 2);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\table.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: TABLE.C
*
* Standard table class and main interface functions.
*
* Functions:
*
* gtab_init()
* gtab_deltools()
* gtab_sendtq()
* gtab_freelinedata()
* gtab_wndproc()
* gtab_createtools()
* gtab_deltable()
* gtab_buildtable()
* gtab_setsize()
* gtab_newsize()
* gtab_calcwidths()
* gtab_alloclinedata()
* gtab_invallines()
* gtab_append()
*
* Comments:
*
* The table class communicates with its 'owner' window to
* get the layout info and the data to display. The owner window handle
* can be sent as the lParam in CreateWindow - if not, the parent window will
* be used.
*
* After creating the window, send it a TM_NEWID message, with a 'data id'
* as the lParam. This is any non-zero 32-bit value. The table will then call
* back to its owner window to find out how many rows/columns, then to fetch
* the name/properties of each column, and finally to get the data to display.
*
* Send TM_NEWID of 0 to close (or destroy the window) - wait for TQ_CLOSE
* (in either case) before discarding data. Send
* TM_REFRESH if data or row-count changes; send TM_NEWLAYOUT if column
* properties or nr cols change etc - this is the same as sending TM_NEWID
* except that no TQ_CLOSE happens on TM_NEWLAYOUT.
*
* TQ_SELECT is sent whenever the current selection changes. TQ_ENTER is sent
* when enter or double-click occurs.
*
****************************************************************************/

#include <windows.h>
#include <commdlg.h>

#include "gutils.h"
#include "table.h"
#include "tpriv.h"

/* global tools etc */
extern HANDLE hLibInst;
HANDLE hVertCurs;
HANDLE hNormCurs;
HPEN hpenDotted;
UINT gtab_msgcode;

/* function prototypes */
long FAR PASCAL gtab_wndproc(HWND, UINT, UINT, long);
void gtab_createtools(void);
void gtab_deltable(HWND hwnd, lpTable ptab);
lpTable gtab_buildtable(HWND hwnd, DWORD id);
void gtab_setsize(HWND hwnd, lpTable ptab);
void gtab_newsize(HWND hwnd, lpTable ptab);
void gtab_calcwidths(HWND hwnd, lpTable ptab);
BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab);
void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count);
void gtab_append(HWND hwnd, lpTable ptab, int rows, DWORD id);

/***************************************************************************
 * Function: gtab_init
 *
 * Purpose:
 *
 * Initialise window class - called from DLL main init
 */
void
gtab_init(void)
{
        WNDCLASS wc;

        gtab_createtools();
        gtab_msgcode = RegisterWindowMessage(TableMessage);

        wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
        wc.lpfnWndProc = gtab_wndproc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = WLTOTAL;
        wc.hInstance = hLibInst;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszClassName = TableClassName;
        wc.lpszMenuName = NULL;

        RegisterClass(&wc);
}

/***************************************************************************
 * Function: gtab_createtools
 *
 * Purpose:
 *
 * Load cursors and pens.
 */
 void
gtab_createtools(void)
{
        hVertCurs = LoadCursor(hLibInst, "VertLine");
        hNormCurs = LoadCursor(NULL, IDC_ARROW);

        hpenDotted = CreatePen(PS_DOT, 1, RGB(0, 0, 0));
}

/***************************************************************************
 * Function: gtab_deltools
 *
 * Purpose:
 *
 * Delete pen
 */
 void
gtab_deltools(void)
{
        DeleteObject(hpenDotted);
}


/***************************************************************************
 * Function: gtab_wndproc
 *
 * Purpose:
 *
 * Window procedure for table
 */
 long FAR PASCAL
gtab_wndproc(HWND hwnd, UINT msg, UINT wParam, long lParam)
{
        CREATESTRUCT FAR * csp;
        HWND hOwner;
        lpTable ptab;
        HANDLE hHeap;
        PAINTSTRUCT ps;
        int y, y2, i;
        HDC hDC;
        lpTableSelection pselect;
        long oldtop;
        long change;

        switch(msg) {

        case WM_CREATE:
                /* create window. set the wnd extra bytes to
                 * contain the owner window, a heap and a null table.
                 * Owner window is either in lParam or the parent.
                 * Then wait for TM_NEWID.
                 */
                csp = (CREATESTRUCT FAR *) lParam;
                if (csp->lpCreateParams == NULL) {
                        hOwner = GetParent(hwnd);
                } else {
                        hOwner = (HWND) (long) csp->lpCreateParams;
                }
                ptab = NULL;
                hHeap = gmem_init();
                SetWindowLong(hwnd, WL_TABLE, (LONG) ptab);
                SetWindowLong(hwnd, WW_OWNER, (LONG) hOwner);
                SetWindowLong(hwnd, WW_HEAP, (LONG) hHeap);

                SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
                break;

        case TM_NEWID:
                /* complete change of table.
                 * close old table, discard memory and
                 * build new table
                 */
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_sendtq(hwnd, TQ_CLOSE, ptab->hdr.id);
                        gtab_deltable(hwnd, ptab);
                        SetCursor(hNormCurs);
                        SetWindowLong(hwnd, WL_TABLE, 0);
                }
                if ( (ptab = gtab_buildtable(hwnd, lParam)) != NULL) {
                        SetWindowLong(hwnd, WL_TABLE, (long) (LPSTR) ptab);
                        gtab_setsize(hwnd, ptab);
                } else {
                        SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                        SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
                }
                InvalidateRect(hwnd, NULL, TRUE);
                break;

        case TM_NEWLAYOUT:
                /* change of layout but for same id. no TQ_CLOSE,
                 * but otherwise same as TM_NEWID
                 */
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_deltable(hwnd, ptab);
                        SetCursor(hNormCurs);
                        SetWindowLong(hwnd, WL_TABLE, 0);
                }
                if ( (ptab = gtab_buildtable(hwnd, lParam)) != NULL) {
                        SetWindowLong(hwnd, WL_TABLE, (long) (LPSTR) ptab);
                        gtab_setsize(hwnd, ptab);
                } else {
                        SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                        SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
                }
                InvalidateRect(hwnd, NULL, TRUE);
                break;

        case TM_REFRESH:
                /* data in table has changed. nrows may have
                 * changed. ncols and col types have not changed
                 */
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_newsize(hwnd, ptab);
                }
                InvalidateRect(hwnd, NULL, TRUE);
                break;

        case TM_SELECT:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        pselect = (lpTableSelection) lParam;

                        /*
                         * we only support TM_SINGLE - so force the
                         * selection to a single row or cell.
                         */
                        gtab_select(hwnd, ptab, pselect->startrow,
                                pselect->startcell,
                                1,
                                (ptab->hdr.selectmode & TM_ROW) ?
                                        ptab->hdr.ncols : 1,
                                TRUE);
                        gtab_showsel_middle(hwnd, ptab);
                }
                break;

        case TM_PRINT:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                hHeap = (HANDLE) GetWindowLong(hwnd, WW_HEAP);
                if (ptab != NULL) {
                        gtab_print(hwnd, ptab, hHeap, (lpPrintContext) lParam);
                        return(TRUE);
                }

        case TM_TOPROW:

                /* return top row. if wParam is TRUE, set lParam
                 * as the new toprow
                 */
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab == NULL) {
                        return(0);
                }
                oldtop = ptab->toprow;
                if ((wParam) && (lParam < ptab->hdr.nrows)) {
                        change = lParam - ptab->toprow;
                        change -= ptab->hdr.fixedrows;
                        gtab_dovscroll(hwnd, ptab, change);
                }
                return(oldtop);

        case TM_ENDROW:
                /* return the last visible row in the window */
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab == NULL) {
                        return(0);
                }
                return(ptab->nlines + ptab->toprow - 1);


        case TM_APPEND:
                /* new rows have been added to the end of the
                 * table, but the rest of the table has no
                 * been change. Update without forcing redraw of
                 * everything.
                 * lParam contains the new total nr of rows
                 */
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_append(hwnd, ptab, wParam, lParam);
                        return(TRUE);
                }
                break;

        case WM_SIZE:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_setsize(hwnd, ptab);
                }
                break;

        case WM_DESTROY:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_sendtq(hwnd, TQ_CLOSE, ptab->hdr.id);
                        gtab_deltable(hwnd, ptab);
                }
                hHeap = (HANDLE) GetWindowLong(hwnd, WW_HEAP);
                gmem_freeall(hHeap);
                break;

        case WM_PAINT:
                hDC = BeginPaint(hwnd, &ps);
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        /* separator lines between fixed rows/columns
                         * (ie headers) and the rest - if enabled
                         */
                        /* paint here first for good impression,
                         * and again after to clean up!!
                         */
                        if (ptab->hdr.vseparator) {
                                gtab_vsep(hwnd, ptab, hDC);
                        }
                        if (ptab->hdr.hseparator) {
                                gtab_hsep(hwnd, ptab, hDC);
                        }

                        /* paint only the rows that need painting */
                        for (i = 0; i < ptab->nlines; i++) {
                                y = ptab->pdata[i].linepos.start;
                                y2 = y + ptab->pdata[i].linepos.size;
                                if ( (y <= ps.rcPaint.bottom) &&
                                     (y2 >= ps.rcPaint.top)) {
                                        gtab_paint(hwnd, hDC, ptab, i);
                                }
                        }
                        if (ptab->hdr.vseparator) {
                                gtab_vsep(hwnd, ptab, hDC);
                        }
                        if (ptab->hdr.hseparator) {
                                gtab_hsep(hwnd, ptab, hDC);
                        }
                        if (ptab->selvisible) {
                                gtab_invertsel(hwnd, ptab, hDC);
                        }
                }

                EndPaint(hwnd, &ps);
                break;

        case WM_HSCROLL:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_msg_hscroll(hwnd, ptab,
                          GET_SCROLL_OPCODE(wParam, lParam),
                          GET_SCROLL_POS(wParam, lParam));
                }
                break;

        case WM_VSCROLL:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_msg_vscroll(hwnd, ptab,
                          GET_SCROLL_OPCODE(wParam, lParam),
                          GET_SCROLL_POS(wParam, lParam));
                }
                break;

        case WM_MOUSEMOVE:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_move(hwnd, ptab, LOWORD(lParam), HIWORD(lParam));
                } else {
                        SetCursor(hNormCurs);
                }
                break;

        case WM_LBUTTONDOWN:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_press(hwnd, ptab, LOWORD(lParam), HIWORD(lParam));
                }
                break;

        case WM_LBUTTONUP:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_release(hwnd, ptab,
                                LOWORD(lParam), HIWORD(lParam));
                }
                break;

        case WM_LBUTTONDBLCLK:
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        gtab_dblclick(hwnd, ptab,
                                LOWORD(lParam), HIWORD(lParam));
                }
                break;

        case WM_KEYDOWN:
                /* handle key presses for cursor movement about
                 * the table, and return/space for selection.
                 * Any key we don't handle is passed to the owner window
                 * for him to handle.
                 * The table window should have the focus
                 */
                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE);
                if (ptab != NULL) {
                        if (gtab_key(hwnd, ptab, wParam) != 0) {
                                /* pass key to owner since
                                 * we don't know what to do with it
                                 */
                                hOwner = (HANDLE) GetWindowLong(hwnd, WW_OWNER);
                                return(SendMessage(hOwner, WM_KEYDOWN,
                                        wParam, lParam));
                        } else {
                                return(0);      
                        }
                }
                break;

        default:
                return(DefWindowProc(hwnd, msg, wParam, lParam));
        }
        return(TRUE);
}

/***************************************************************************
 * Function: gtab_sendtq
 *
 * Purpose:
 *
 * Send a table-query message to the owner window. Returns message
 * value.
 */
long
gtab_sendtq(HWND hwnd, UINT cmd, long lParam)
{
        HWND hOwner;

        hOwner = (HANDLE) GetWindowLong(hwnd, WW_OWNER);
        return (SendMessage(hOwner, gtab_msgcode, cmd, lParam));
}

/***************************************************************************
 * Function: gtab_freelinedata
 *
 * Purpose:
 *
 * Free the memory allocated for the array of lines (each containing
 * an array of Cells, each containing an array of chars for the actual
 * data). Called on any occasion that would change the number of visible lines
 */
void
gtab_freelinedata(HANDLE hHeap, lpTable ptab)
{
        int i, j, ncols;
        lpCellData cd;


        ncols = ptab->hdr.ncols;

        /* for each line */
        for(i = 0; i < ptab->nlines; i++) {
                /* for each cell */
                for (j = 0; j < ncols; j++) {
                        /* free up the actual text space */
                        cd = &ptab->pdata[i].pdata[j];
                        gmem_free(hHeap, (LPSTR) cd->ptext, cd->nchars);
                }
                /* dealloc array of CellData */
                gmem_free(hHeap, (LPSTR) ptab->pdata[i].pdata,
                        sizeof(CellData) * ncols);
        }
        /* de-alloc array of linedatas */
        gmem_free(hHeap, (LPSTR) ptab->pdata,
                sizeof(LineData) * ptab->nlines);
        ptab->pdata = NULL;
}

/***************************************************************************
 * Function: gtab_alloclinedata
 *
 * Purpose:
 *
 * Allocate and init array of linedatas (include cell array
 * and text for each cell)
 */
BOOL
gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab)
{
        lpLineData pline;
        lpCellData cd;
        int i, j;

        ptab->pdata = (lpLineData) gmem_get(heap,
                sizeof(LineData) * ptab->nlines);
        if (ptab->pdata == NULL) {
                return(FALSE);
        }
        for (i = 0; i < ptab->nlines; i++) {
                pline = &ptab->pdata[i];
                pline->linepos.size = ptab->rowheight;
                pline->pdata = (lpCellData) gmem_get(heap,
                        sizeof(CellData) * ptab->hdr.ncols);
                if (pline->pdata == NULL) {
                        return(FALSE);
                }
                for (j = 0; j < ptab->hdr.ncols; j++) {
                        cd = &pline->pdata[j];
                        cd->props.valid = 0;
                        cd->flags = 0;
                        cd->nchars = ptab->pcolhdr[j].nchars;
                        if (cd->nchars > 0) {
                                cd->ptext = gmem_get(heap, cd->nchars);
                                if (cd->ptext == NULL) {
                                        return(FALSE);
                                }
                        }
                }
        }
}

/***************************************************************************
 * Function: gtab_deltable
 *
 * Purpose:
 *
 * Free up all table data structures. Called for new layout or new data.
 */
void
gtab_deltable(HWND hwnd, lpTable ptab)
{
        HANDLE hHeap;
        int ncols;

        if (ptab == NULL) {
                return;
        }
        hHeap = (HANDLE) GetWindowLong(hwnd, WW_HEAP);
        ncols = ptab->hdr.ncols;

        if (ptab->pcolhdr != NULL) {
                gmem_free(hHeap, (LPSTR) ptab->pcolhdr,
                        sizeof(ColProps) * ncols);
        }
        if (ptab->pcellpos != NULL) {
                gmem_free(hHeap, (LPSTR) ptab->pcellpos,
                        sizeof(CellPos) * ncols);
        }
        if (ptab->pdata != NULL) {
                gtab_freelinedata(hHeap, ptab);
        }
        gmem_free(hHeap, (LPSTR) ptab, sizeof(Table));
}


/***************************************************************************
 * Function: gtab_buildtable
 *
 * Purpose:
 *
 * Build up a Table struct (excluding data allocation and
 * anything to do with font or window size).
 * Return ptr to this or NULL if error
 */
lpTable
gtab_buildtable(HWND hwnd, DWORD id)
{
        lpTable ptab;
        HANDLE hHeap;
        int ncols, i;
        ColPropsList cplist;

        hHeap = (HANDLE) GetWindowLong(hwnd, WW_HEAP);
        ptab = (lpTable) gmem_get(hHeap, sizeof(Table));
        if (ptab == NULL) {
                return(NULL);
        }

        /* get the row/column count from owner window */
        ptab->hdr.id = id;
        ptab->hdr.props.valid = 0;
        ptab->hdr.sendscroll = FALSE;
        if (gtab_sendtq(hwnd, TQ_GETSIZE, (long) (LPSTR)&ptab->hdr) == FALSE) {
                return(NULL);
        }

        ncols = ptab->hdr.ncols;
        ptab->pcolhdr = (lpColProps) gmem_get(hHeap, sizeof(ColProps) * ncols);
        if (ptab->pcolhdr == NULL) {
                /* should prob send TQ_CLOSE at this point */
                return(NULL);
        }

        /* init col properties to default */
        for (i=0; i < ncols; i++) {
                ptab->pcolhdr[i].props.valid = 0;
                ptab->pcolhdr[i].nchars = 0;
        }
        /* get the column props from owner */
        cplist.plist = ptab->pcolhdr;
        cplist.id = id;
        cplist.startcol = 0;
        cplist.ncols = ncols;
        gtab_sendtq(hwnd, TQ_GETCOLPROPS, (long) (LPSTR)&cplist);

        /* init remaining fields */
        ptab->pcellpos = (lpCellPos) gmem_get(hHeap, sizeof(CellPos) * ncols);
        if (ptab->pcellpos == NULL) {
                return(NULL);
        }

        ptab->scrollscale = 1;
        ptab->scroll_dx = 0;
        ptab->toprow = 0;
        ptab->pdata = NULL;
        ptab->nlines = 0;
        ptab->trackmode = TRACK_NONE;

        /* we have to notify owner of the current selection
         * whenever it is changed
         */
        ptab->select.id = id;
        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);

        /* calc ave height/width, cell widths and min height.
         * these change only when cell properties / col count changes -
         * ie only on rebuild-header events
         */
        gtab_calcwidths(hwnd, ptab);
        return(ptab);
}

/***************************************************************************
 * Function: gtab_setsize
 *
 * Purpose:
 *
 * Set sizes that are based on window size and scroll pos
 * set:
 *      winwidth
 *      nlines
 *      cellpos start, clip start/end
 * Alloc linedata and init
 */
void
gtab_setsize(HWND hwnd, lpTable ptab)
{
        RECT rc;
        int nlines;
        HANDLE heap;
        long range, change;

        GetClientRect(hwnd, &rc);
        ptab->winwidth = rc.right - rc.left;
        nlines = (rc.bottom - rc.top) / ptab->rowheight;
        /* nlines is the number of whole lines - add one extra
         * for the partial line at the bottom
         */
        nlines += 1;

        /* alloc space for nlines of data - if nlines has changed */
        if (nlines != ptab->nlines) {
                heap = (HANDLE) GetWindowLong(hwnd, WW_HEAP);
                gtab_freelinedata(heap, ptab);
                ptab->nlines = nlines;
                if (!gtab_alloclinedata(hwnd, heap, ptab)) {
                        ptab->nlines = 0;
                        return;
                }
        }

        /* set scroll vertical range */
        range = ptab->hdr.nrows - (ptab->nlines - 1);
        if (range < 0) {
                range = 0;
                change =  -(ptab->toprow);
        } else if (ptab->toprow > range) {
                change = range - ptab->toprow;
        } else {
                change = 0;
        }
        /* the scroll range must be 16-bits for Win3
         * scale until this is true
         */
        ptab->scrollscale = 1;
        while (range > 32766) {
                ptab->scrollscale *= 16;
                range /= 16;
        }

        SetScrollRange(hwnd, SB_VERT, 0, (int) range, TRUE);
        gtab_dovscroll(hwnd, ptab, change);

        /* set horz scroll range */
        range = ptab->rowwidth - ptab->winwidth;
        if (range < 0) {
                range = 0;
                change = -(ptab->scroll_dx);
        } else if (ptab->scroll_dx > range) {
                change = range - ptab->scroll_dx;
        } else {
                change = 0;
        }
        /* horz scroll range will always be < 16 bits */
        SetScrollRange(hwnd, SB_HORZ, 0, (int) range, TRUE);
        gtab_dohscroll(hwnd, ptab, change);
}

/***************************************************************************
 * Function: gtab_calcwidths
 *
 * Purpose:
 *
 * Set column widths/height and totals (based on column props)
 * - no assumption of window size (see gtab_setsize)
 * sets avewidth,rowheight,cellpos.size,rowwidth (total of cellpos.size)
 */
void
gtab_calcwidths(HWND hwnd, lpTable ptab)
{
        int i, cxtotal, cx, ave;
        TEXTMETRIC tm, tmcol;
        HDC hdc;
        lpProps hdrprops, cellprops;
        HFONT hfont;

        hdrprops = &ptab->hdr.props;
        hdc = GetDC(hwnd);
        if (hdrprops->valid & P_FONT) {
                hfont = SelectObject(hdc, hdrprops->hFont);
        }
        GetTextMetrics(hdc, &tm);
        if (hdrprops->valid & P_FONT) {
                SelectObject(hdc, hfont);
        }
        ReleaseDC(hwnd, hdc);

        /* get width and height of average character */
        ptab->avewidth = tm.tmAveCharWidth;
        ptab->rowheight = tm.tmHeight + tm.tmExternalLeading;
        if (hdrprops->valid & P_HEIGHT) {
                ptab->rowheight = hdrprops->height;
        }

        /* set pixel width of each cell (and add up for row total)
         * based on ave width * nr chars, unless P_WIDTH set
         */
        cxtotal = 0;
        for (i = 0; i < ptab->hdr.ncols; i++) {
                cellprops = &ptab->pcolhdr[i].props;

                if (cellprops->valid & P_WIDTH) {
                        cx = cellprops->width;
                } else if (hdrprops->valid & P_WIDTH) {
                        cx = hdrprops->width;
                } else {

                        if (cellprops->valid & P_FONT) {
                                hdc = GetDC(hwnd);
                                hfont = SelectObject(hdc, cellprops->hFont);
                                GetTextMetrics(hdc, &tmcol);
                                SelectObject(hdc, hfont);
                                ReleaseDC(hwnd, hdc);
                                ave = tmcol.tmAveCharWidth;
                        } else {
                                ave = ptab->avewidth;
                        }
                        /* ave width * nchars */
                        cx =  ptab->pcolhdr[i].nchars + 1;
                        cx *= ave;
                }
                /* add 2 pixels for box lines */
                cx += 2;
                ptab->pcellpos[i].size = cx;
                cxtotal += cx;
        }
        ptab->rowwidth = cxtotal;
}

/***************************************************************************
 * Function: gtab_newsize
 *
 * Purpose:
 *
 * Called when row data + possible nrows changes.
 * other changes are ignored
 */
void
gtab_newsize(HWND hwnd, lpTable ptab)
{
        TableHdr hdr;

        /* get new row count */
        hdr = ptab->hdr;
        gtab_sendtq(hwnd, TQ_GETSIZE, (long) (LPSTR) &hdr);
        if (hdr.nrows != ptab->hdr.nrows) {
                ptab->hdr.nrows = hdr.nrows;
                gtab_setsize(hwnd, ptab);
        }

        gtab_invallines(hwnd, ptab, 0, ptab->nlines);

        InvalidateRect(hwnd, NULL, TRUE);
}

void
gtab_invallines(HWND hwnd, lpTable ptab, int start, int count)
{
        int i, j;

        for (i = start; i < start + count; i++) {
                for (j = 0; j < ptab->hdr.ncols; j++) {
                        ptab->pdata[i].pdata[j].flags = 0;
                }
        }
}

/***************************************************************************
 * Function: gtab_append
 *
 * Purpose:
 *
 * New rows have been added to the table. Adjust the scroll range and
 * position, and redraw the rows if the end of the table is currently
 * visible.
 * rows = the new total row count.
 */
void
gtab_append(HWND hwnd, lpTable ptab, int rows, DWORD id)
{
        long range;
        long oldrows;
        int line, nupdates;
        RECT rc;


        /* change to the new id */
        ptab->hdr.id = id;
        ptab->select.id = id;

        /* update the header, but remember the old nr of rows
         * so we know where to start updating
         */
        oldrows = ptab->hdr.nrows;

        /* check that the new nr of rows is not smaller. this is
         * illegal at this point and should be ignored
         */
        if (oldrows >= rows) {
                return; 
        }

        ptab->hdr.nrows = rows;

        /* set the vertical scroll range */
        range = rows - (ptab->nlines - 1);

        if (range < 0) {
                range = 0;      
        }

        /* force the scroll range into 16-bits for win 3.1 */
        ptab->scrollscale = 1;
        while (range > 32766) {
                ptab->scrollscale *= 16;
                range /= 16;
        }

        /* now set the scroll bar range and position */
        SetScrollRange(hwnd, SB_VERT, 0, (int) range, TRUE);
        if (range > 0) {
                SetScrollPos(hwnd, SB_VERT,
                        (int) (ptab->toprow / ptab->scrollscale), TRUE);
        }

        /* calculate which screen lines need to be updated - find what
         * screen line the start of the new section is at
         */
        line = gtab_rowtoline(hwnd, ptab, oldrows);
        if (line == -1) {
                /* not visible -> no more to do */
                return;
        }

        /* how many lines to update - rest of screen or nr of
         * new lines if less than rest of screen
         */
        nupdates = min((ptab->nlines - line), (int)(rows - oldrows));

        /* invalidate the screen line buffers to indicate data
         * needs to be refetch from parent window
         */
        gtab_invallines(hwnd, ptab, line, nupdates);

        /* calculate the region of the screen to be repainted -
         * left and right are same as window. top and bottom
         * need to be calculated from screen line height
         */
        
        GetClientRect(hwnd, &rc);
        rc.top += line * ptab->rowheight;
        rc.bottom = rc.top + (nupdates * ptab->rowheight);

        /* force a repaint of the updated region */
        InvalidateRect(hwnd, &rc, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\table.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * TABLE.H
 *
 * public interface definition for table window class.
 *
 * include after gutils.h and commdlg.h
 */

/* -------class and message names --------------------------------------*/

/* create a window of this class */
#define  TableClassName "GTableClass"


/* all messages to the owner window are sent with this message.
 * call RegisterWindowsMessage with this string for the message UINT.
 */
#define TableMessage  "GTableQuery"

/* -------- messages to and from table class  --------------------------*/

/* messages to owner window are:
 *      message:        TableMessage
 *      wParam:         command code (below)
 * lParam:              struct pointer according to code
 * below is list of wParam codes & associated lParam struct
 */
#define TQ_GETSIZE      1       /* lParam: lpTableHdr */
#define TQ_GETCOLPROPS  2       /* lParam: lpColPropList */
#define TQ_GETDATA      3       /* lParam: lpCellDataList */
#define TQ_PUTDATA      4       /* lParam: lpCellDataList */
#define TQ_SELECT       5       /* lParam: lpTableSelection */
#define TQ_ENTER        6       /* lParam: lpTableSelection */
#define TQ_CLOSE        7       /* lParam: the data id to be closed */

/* optional */
#define TQ_SCROLL       8       /* lParam: the new top row nr */


/* messages to Table class */

/* data, or nrows has changed  wParam/lParam null*/
#define TM_REFRESH      (WM_USER)

/* nr cols/props/layout has changed  - wparam/lparam null */
#define TM_NEWLAYOUT    (WM_USER+1)

/* Close old id, and display new - wParam null, lParam has new id */
#define TM_NEWID        (WM_USER+2)

/* Select and show this area - wParam null, lParam is lpTableSelection */
#define TM_SELECT       (WM_USER+3)

/* Print current table - wParam null, lParam either null
 * or lpPrintContext.
 */
#define TM_PRINT        (WM_USER+4)

/* Return the top row in the window. If wParam is TRUE, then set
 * lParam to be the new toprow. top row is the number of rows scrolled down
 * from the top. Thus the first visible non-fixed row is toprow+fixedrows
 */
#define TM_TOPROW       (WM_USER+5)


/* Return the end row visible. This is the 0-based rownr of the last
 * visible row in the window
 */
#define TM_ENDROW       (WM_USER+6)

/* New rows have been added to the end of the table, but no other
 * rows or cols or properties have been changed.
 * wParam contains the new total nr of rows. lParam contains the id
 * in case this has changed.
 */
#define TM_APPEND       (WM_USER+7)

/*-----display properties -------------------------------------------------*/

/*
 * Display properties struct. can be set for whole table, for
 * each column, or for each cell. When looking for
 * a property, we search cell->column->table
 */
typedef struct {
        UINT valid;             /* flags (below) for what props we set */

/* remaining fields only valid when corresponding flag set in valid */

        DWORD forecolour;       /* RGB colour value */
        DWORD backcolour;       /* ditto */
        /* font to use - also set through WM_SETFONT. owner application
         * is responsible for DeleteObject call when no longer used
         */
        HFONT hFont;            /* handle to font  - caller should delete*/
        UINT alignment;         /* flags below */
        UINT box;               /* whether cell boxed (see below) */

        /* width/height settings not valid at cell level - only table or col.*/
        int width;              /* pixel width of this cell/column */
        int height;             /* pixel cell height */
} Props, FAR * lpProps;

/* Valid flags for fields that are changed in this Props struct */
#define P_FCOLOUR       1
#define P_BCOLOUR       2
#define P_FONT          4
#define P_ALIGN         8
#define P_BOX           0x20
#define P_WIDTH         0x40
#define P_HEIGHT        0x80

/* Box settings  or-ed together */
#define P_BOXTOP        1
#define P_BOXBOTTOM     2
#define P_BOXLEFT       4
#define P_BOXRIGHT      8
#define P_BOXALL        0xF

/* Alignment settings (expand later to include various tab-align settings */
#define P_LEFT          0
#define P_RIGHT         1
#define P_CENTRE        2

/* This struct is the master information about a table. It is
 * passed to the owner window with the id field filled in; fill in
 * all remaining fields and return.
 */
typedef struct {
        DWORD id;               /* owner's data id */

        long nrows;             /* how many rows ? TM_REFRESH to change */
        int ncols;              /* how many columns ? TM_NEWLAYOUT to chg */

        int fixedrows;          /* for headers - usually 0 or 1 */
        int fixedcols;          /* for hdrs - 0 or 1 normally */
        BOOL fixedselectable;   /* is fixed area selectable ? */
        BOOL hseparator;        /* is there a horz. line after fixed rows */
        BOOL vseparator;        /* is there a vert. line after fixed rows */

        UINT selectmode;        /* multiple/single selection - flags below*/
        BOOL sendscroll;        /* TRUE if TQ_SCROLL to be sent on scrolling*/

        Props props;
} TableHdr, FAR * lpTableHdr;

/*
 * selection mode;
 *
 * choose TM_CELL or TM_ROW, and TM_SINGLE or TM_MANY, and
 * TM_SOLID or TM_FOCUS and or them together.
 *
 * current implementation does not support TM_MANY !!
 */
#define TM_ROW          1       /* selectable items are rows */
#define TM_CELL         0       /* selectable items are cells */

#define TM_MANY         2       /* multiple selects possible */
#define TM_SINGLE       0       /* single item selectable at once only */

#define TM_SOLID        0       /* (default) use a solid black for selection*/
#define TM_FOCUS        4       /* use a dotted focus rect for selection */


/* --------- column header structs --------------------------------------*/

/*
 * This struct is sent to request column width and properties -
 * owner window must fill nchars and props.valid, at minimum.
 */
typedef struct {
        int nchars;     /* expected text width in chars */
        Props props;
} ColProps, FAR * lpColProps;


/* This is a set of column requests - owner should fill each one*/
typedef struct {
        DWORD id;               /* caller's id for data */
        int startcol;           /* zero-based column nr of first request */
        int ncols;              /* nr of columns in this set */
        lpColProps plist;       /* ptr to _array_ of ColProps */
} ColPropsList, FAR * lpColPropsList;


/* --- cell data structs ---------------------------------------------*/

/* This is the per-cell data struct.
 * When providing data (responding to TQ_GETDATA), fill out ptext[] and
 * props as appropriate. ptext will be pre-allocated with nchars bytes of
 * space. This may be larger than ColProps->nchars if the user has
 * stretched this column's width on screen
 *
 * Don't re-alloc ptext, or change flags.
 */
typedef struct {
        int nchars;             /* space in buffer */
        LPSTR ptext;            /* ptr to nchars of text space */
        Props props;            /* per-cell props */
        DWORD flags;            /* private table class flags */
} CellData, FAR * lpCellData;

/* List of cell data structures - please fill out all of these*/
typedef struct {
        DWORD id;               /* caller's id for data */
        long row;               /* zero-based row nr to fetch */
        int startcell;          /* zero-based cell nr on this row */
        int ncells;             /* count of cells to fetch */
        lpCellData plist;       /* ptr to array CellData[ncells] */
} CellDataList, FAR * lpCellDataList;


/*----- current selection----------------------------------------------*/

/* Describes the current selection - a rectangular selection area */
typedef struct {
        DWORD id;               /* caller's id for data */
        long startrow;          /* zero-based row nr of start of sel. */
        long startcell;         /* zero-based col nr of  start of sel */
        long nrows;             /* vertical depth of selection */
        long ncells;            /* horz width of selection */
} TableSelection, FAR * lpTableSelection;



/*----- print context -----------------------------------------------*/

/* Describes the margin settings for the print job - these are in CMs*/
typedef struct {
        int left;               /* edge of paper to start of print area */
        int right;              /* edge of paper to start of print area */
        int top;                /* edge of paper to start of hdr */
        int bottom;             /* end of hdr to end of paper */
        int topinner;           /* start of hdr to start of data */
        int bottominner;        /* end of data to start of hdr */
} Margin, FAR * lpMargin;

/* Position and clipping info - only used by table class
 */
typedef struct {
        int start;              /* co-ord of cell start (left or top) */
        int clipstart;          /* start of clipping (vis area) */
        int clipend;            /* end of clipping (vis area) */
        int size;               /* pixel size of cell (width or height) */
} CellPos, FAR * lpCellPos;


/* One of these for each header lines (top and bottom) */
typedef struct {
        CellPos xpos, ypos;     /* private: for table-class use only */
        Props props;
        LPSTR ptext;
} Title, FAR * lpTitle;

/* Print context data structure - any or all 4 pointers may be null */
typedef struct {
        DWORD id;               /* id of table to print */
        lpTitle head;
        lpTitle foot;
        lpMargin margin;
        PRINTDLG FAR * pd;
} PrintContext, FAR * lpPrintContext;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\tscroll.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: TSCROLL.C
*
* Scrolling and selection routines.
*
* Functions:
*
* gtab_msg_vscroll()
* gtab_msg_hscroll()
* gtab_dovscroll()
* gtab_dohscroll()
* gtab_linetorow()
* gtab_rowtoline()
* gtab_select()
* gtab_ytoline()
* gtab_xtocol()
* gtab_isborder()
* gtab_enter()
* gtab_trackcol()
* gtab_press()
* gtab_release()
* gtab_move()
* gtab_dblclick()
* gtab_showsel()
* gtab_showsel_middle()
* gtab_changesel()
* gtab_selhome()
* gtab_key()
*
* Comments:
*
* This implementation currently only supports TM_SINGLE, not TM_MANY
* modes of selection.
*
****************************************************************************/

#include <windows.h>
#include <commdlg.h>

#include "gutils.h"
#include "table.h"
#include "tpriv.h"

/***************************************************************************
 * Function: gtab_msg_vscroll
 *
 * Purpose:
 *
 * Handle a vscroll message 
 */
void
gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos)
{
        long change;

        switch(opcode) {
        case SB_THUMBPOSITION:
                change = (pos * ptab->scrollscale) - ptab->toprow;
                break;

        case SB_LINEUP:
                change = -1;
                break;

        case SB_LINEDOWN:
                change = 1;
                break;

        case SB_PAGEUP:
                change = - (ptab->nlines - 3);
                break;

        case SB_PAGEDOWN:
                change = (ptab->nlines - 3);
                break;

        default:
                return;
        }
        gtab_dovscroll(hwnd, ptab, change);
}

/***************************************************************************
 * Function: gtab_msg_hscroll
 *
 * Purpose:
 *
 * Handle a hscroll message 
 */
void
gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos)
{
        int change;

        switch(opcode) {
        case SB_THUMBPOSITION:
                change = pos - ptab->scroll_dx;
                break;

        case SB_LINEUP:
                change = -(ptab->avewidth);
                break;

        case SB_LINEDOWN:
                change = ptab->avewidth;
                break;

        case SB_PAGEUP:
                change = - (ptab->winwidth * 2 / 3);
                break;

        case SB_PAGEDOWN:
                change = (ptab->winwidth * 2 / 3);
                break;

        default:
                return;
        }
        gtab_dohscroll(hwnd, ptab, change);
}



/***************************************************************************
 * Function: gtab_dovscroll
 *
 * Purpose:
 *
 * Set new vertical scroll pos,
 * adjust linedata array
 * set line win-relative start posns & clip top/bottom posns
 * revise display.
 */
void
gtab_dovscroll(HWND hwnd, lpTable ptab, long change)
{
        int cury, i;
        long ncopy;
        lpCellPos cp;
        LineData ldtemp;
        RECT rc, rcpaint;
        long range;
        long newtop;
        int newpos;


        range = ptab->hdr.nrows - (ptab->nlines - 1);
        newtop = ptab->toprow + change;
        if (range < 0) {
                range = 0;
        }
        if (newtop > range) {
                change = range - ptab->toprow;
        } else if (newtop < 0) {
                change = -(ptab->toprow);
        }
        ptab->toprow += change;

        newpos = (int) (newtop / ptab->scrollscale);
        SetScrollPos(hwnd, SB_VERT, newpos, TRUE);

        if (ptab->hdr.sendscroll) {
                gtab_sendtq(hwnd, TQ_SCROLL, ptab->toprow);
        }

        /* adjust data ptrs rather than invalidate, to retain the
         * data we know is still valid
         */
        if (abs(change) >= ptab->nlines) {
                gtab_invallines(hwnd, ptab, ptab->hdr.fixedrows,
                        ptab->nlines - ptab->hdr.fixedrows);
                InvalidateRect(hwnd, NULL, TRUE);
                change = 0;
        } else if (change < 0) {
                /* copy data down */
                ncopy = (ptab->nlines - ptab->hdr.fixedrows) - abs(change);
                for (i =  ptab->nlines - 1;
                  i >= (ptab->hdr.fixedrows + abs(change)); i--) {
                        ldtemp = ptab->pdata[i - abs(change)];
                        ptab->pdata[i - abs(change)] = ptab->pdata[i];
                        ptab->pdata[i] = ldtemp;
                }
                gtab_invallines(hwnd, ptab,
                        ptab->hdr.fixedrows, (int) abs(change));
        } else if (change > 0) {
                ncopy = (ptab->nlines - ptab->hdr.fixedrows) - change;
                for (i = ptab->hdr.fixedrows;
                  i < (ncopy + ptab->hdr.fixedrows); i++) {
                        ldtemp = ptab->pdata[i + change];
                        ptab->pdata[i + change] = ptab->pdata[i];
                        ptab->pdata[i] = ldtemp;
                }
                gtab_invallines(hwnd, ptab,
                        (int) ncopy + ptab->hdr.fixedrows, (int) change);
        }

        /* scroll window */
        GetClientRect(hwnd, &rc);
        rcpaint = rc;
        if (change > 0) {
                rc.top += (int) (change + ptab->hdr.fixedrows) * ptab->rowheight;
                rcpaint.top = (ptab->hdr.fixedrows * ptab->rowheight);
                rcpaint.top += rc.bottom - rc.top;
        } else if (change < 0) {
                rc.top += (ptab->hdr.fixedrows * ptab->rowheight);
                rc.bottom -= (int) (change * ptab->rowheight);
                rcpaint.bottom -= rc.bottom - rc.top;
        }

        /* loop through each line setting relative posn and clipping */

        /* set up all rows  - the fixed/moveable difference for
         * rows is made at fetch-time during painting, when we remember
         * which absolute row nr to ask for, for a given screen line
         */
        cury = 0;
        for (i = 0; i < ptab->nlines; i++) {
                cp = &ptab->pdata[i].linepos;
                cp->start = cury;
                cp->clipstart = cury;
                cp->clipend = cury + cp->size;
                cury += cp->size;
        }

        /* now move and repaint the window */
        if (change != 0) {
                if (rc.top < rc.bottom) {
                        ScrollWindow(hwnd, 0, (int) -(change * ptab->rowheight),
                                &rc, NULL);

                }

                /* force repaint now, not just post message for later,
                 * since we want to repaint that line before the next
                 * scroll down occurs
                 */
                RedrawWindow(hwnd, &rcpaint, NULL,
                        RDW_ERASE | RDW_INVALIDATE|RDW_UPDATENOW);
        }
}

/***************************************************************************
 * Function: gtab_dohscroll
 *
 * Purpose:
 *
 * Set new horizontal scroll pos,
 * set col win-relative start posns & clip left/right posns
 * revise display.
 */
void
gtab_dohscroll(HWND hwnd, lpTable ptab, long change)
{
        int curx, i;
        int moveable;
        lpCellPos cp;
        int newdx, range;


        /* check that the new scroll pos is still within the valid range */
        range = ptab->rowwidth - ptab->winwidth;
        newdx = ptab->scroll_dx + (int) change;
        if (range < 0) {
                range = 0;
        }
        if (newdx > range) {
                change = range - ptab->scroll_dx;
        } else if (newdx < 0) {
                change = -(ptab->scroll_dx);
        }
        ptab->scroll_dx += (int) change;

        SetScrollPos(hwnd, SB_HORZ, ptab->scroll_dx, TRUE);
        InvalidateRect(hwnd, NULL, TRUE);
        
        /* loop through each col setting relative posn and clipping */
        /* clip off 1 pixel left and right (we added 2 on to size for this) */

        /* first set up fixed columns */
        curx = 0;
        for (i = 0; i < ptab->hdr.fixedcols; i++) {
                cp = &ptab->pcellpos[i];
                cp->start = curx + 1;
                cp->clipstart = cp->start;
                cp->clipend = cp->start + cp->size - 2;
                curx += cp->size;
        }

        /* now moveable columns. remember start of moveable cols */
        moveable = curx;
        curx = - ptab->scroll_dx;       /* rel. pos of col */
        for (i = ptab->hdr.fixedcols; i < ptab->hdr.ncols; i++) {
                cp = &ptab->pcellpos[i];
                cp->start = curx + moveable + 1;
                cp->clipstart = max(moveable+1, cp->start);
                cp->clipend = cp->start + cp->size - 2;
                curx += cp->size;
        }
}

/***************************************************************************
 * Function: gtab_linetorow
 *
 * Purpose:
 *
 * Convert screen line nr to table row nr
 */
long
gtab_linetorow(HWND hwnd, lpTable ptab, int line)
{
        if (line < ptab->hdr.fixedrows) {
                return(line);
        }

        return (line + ptab->toprow);
}

/***************************************************************************
 * Function: gtab_rowtoline
 *
 * Purpose:
 *
 * Convert table row nr to screen line nr or -1 if not on screen
 */
int
gtab_rowtoline(HWND hwnd, lpTable ptab, long row)
{
        if (row < ptab->hdr.fixedrows) {
                return( (int) row);
        }

        row -= ptab->toprow;
        if ((row >= ptab->hdr.fixedrows) && (row < ptab->nlines)) {
                return ( (int) row);
        }
        return(-1);
}

/***************************************************************************
 * Function: gtab_select
 *
 * Purpose:
 *
 * Replace old selection with new. Notify owner if bNotify. Change
 * display to reflect new display.
 */
void
gtab_select(
        HWND hwnd,
        lpTable ptab,
        long row,
        long col,
        long nrows,
        long ncells,
        BOOL bNotify)
{
        int line;

        /* if in ROW mode, force col and ncells to reflect the entire row. */
        if (ptab->hdr.selectmode & TM_ROW) {
                col = 0;
                ncells = ptab->hdr.ncols;
        }

        /* clear existing sel if valid and visible */
        if ((ptab->select.nrows > 0) && (ptab->selvisible == TRUE)) {

                /* only clear sel if it is different from the new one */
                if ((ptab->select.startrow != row) ||
                    (ptab->select.startcell != col) ||
                    (ptab->select.nrows != nrows) ||
                    (ptab->select.ncells != ncells)) {
                        line = gtab_rowtoline(hwnd, ptab,
                                ptab->select.startrow);
                        if (line >= 0) {
                                gtab_invertsel(hwnd, ptab, NULL);
                        }
                        ptab->selvisible = FALSE;
                }
        }

        /* set select fields and send TQ_SELECT */
        if (row < ptab->hdr.nrows) {
                ptab->select.startrow = row;
                ptab->select.startcell = col;
                ptab->select.nrows = nrows;
                ptab->select.ncells = ncells;
        } else {
                ptab->select.nrows = 0;
                ptab->select.startrow = 0;
                ptab->select.startcell = 0;
                ptab->select.ncells = 0;
        }

        if (bNotify) {
                gtab_sendtq(hwnd, TQ_SELECT, (long) (LPSTR) &ptab->select);
        }

        /* paint in selection */
        if (nrows > 0) {
                if (!ptab->selvisible) {
                        gtab_invertsel(hwnd, ptab, NULL);
                        ptab->selvisible = TRUE;
                }
        } else {
                if (ptab->selvisible) {
                        gtab_invertsel(hwnd, ptab, NULL);
                        ptab->selvisible = FALSE;
                }
                ptab->selvisible = FALSE;
        }
}

/***************************************************************************
 * Function: gtab_ytoline
 *
 * Purpose:
 *
 * Convert window y co-ord to a line nr
 */
int
gtab_ytoline(HWND hwnd, lpTable ptab, int y)
{
        return(y / ptab->rowheight);
}

/***************************************************************************
 * Function: gtab_xtocol
 *
 * Purpose:
 *
 * Convert window x co-ord to a cell nr
 */
int
gtab_xtocol(HWND hwnd, lpTable ptab, int x)
{
        int i;
        lpCellPos ppos;

        for (i = 0; i < ptab->hdr.ncols; i++) {
                ppos = &ptab->pcellpos[i];
                if (ppos->clipstart < ppos->clipend) {
                        if ( (x >= ppos->clipstart) && (x < ppos->clipend)) {
                                return(i);
                        }
                }
        }
        return(-1);
}


/***************************************************************************
 * Function: gtab_isborder
 *
 * Purpose:
 *
 * Check if x co-ord is 'near' (+- 2 pixels) the right border of given cell
 */
BOOL
gtab_isborder(HWND hwnd, lpTable ptab, int x, int col)
{
        
        if (abs(ptab->pcellpos[col].clipend - x) < 2) {
                return(TRUE);
        } else {
                return(FALSE);
        }
}


/***************************************************************************
 * Function: gtab_enter
 *
 * Purpose:
 *
 * Set selection and send 'TQ_ENTER' event to owner
 */
void
gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows,
        long ncells)
{
        int line;

        /* clear existing sel if valid and visible */
        if ((ptab->select.nrows > 0) && (ptab->selvisible == TRUE)) {

                /* only clear sel if it is different from the new one */
                if ((ptab->select.startrow != row) ||
                    (ptab->select.startcell != col) ||
                    (ptab->select.nrows != nrows) ||
                    (ptab->select.ncells != ncells)) {
                        line = gtab_rowtoline(hwnd, ptab,
                                ptab->select.startrow);
                        if (line >= 0) {
                                gtab_invertsel(hwnd, ptab, NULL);
                        }
                        ptab->selvisible = FALSE;
                }
        }

        /* set select fields and send TQ_SELECT */
        if (row < ptab->hdr.nrows) {
                ptab->select.startrow = row;
                ptab->select.startcell = col;
                ptab->select.nrows = nrows;
                ptab->select.ncells = ncells;
        } else {
                ptab->select.nrows = 0;
                ptab->select.startrow = 0;
                ptab->select.startcell = 0;
                ptab->select.ncells = 0;
        }

        /* paint in selection */
        if (nrows > 0) {
                if (!ptab->selvisible) {
                        gtab_invertsel(hwnd, ptab, NULL);
                        ptab->selvisible = TRUE;
                }
                /* do this at end because it could cause a layout-change */
                gtab_sendtq(hwnd, TQ_ENTER, (long) (LPSTR) &ptab->select);
        } else {
                if (ptab->selvisible) {
                        gtab_invertsel(hwnd, ptab, NULL);
                }
                ptab->selvisible = FALSE;
        }
}


/***************************************************************************
 * Function: gtab_trackcol
 *
 * Purpose:
 *
 * Start re-sizing a column
 */
void
gtab_trackcol(HWND hwnd, lpTable ptab, int col, int x)
{

        /* ensure we see the mouse-up */
        SetCapture(hwnd);
        ptab->trackmode = TRACK_COLUMN;
        ptab->tracknr = col;
        ptab->trackline1 = x;

        /* if line at other side of cell is visible, draw that too */
        if (ptab->pcellpos[col].start >= ptab->pcellpos[col].clipstart) {
                ptab->trackline2 = ptab->pcellpos[col].start;
        } else {
                ptab->trackline2 = -1;
        }
        gtab_drawvertline(hwnd, ptab);
}



/***************************************************************************
 * Function: gtab_press
 *
 * Purpose:
 *
 * Called on mouse-down events. decide what to start tracking.
 */
void
gtab_press(HWND hwnd, lpTable ptab, int x, int y)
{
        int cell;
        long row;

        if (ptab->trackmode != TRACK_NONE) {
                return;
        }

        /* has he grabbed a cell-edge to resize ? */
        cell = gtab_xtocol(hwnd, ptab, x);
        if (cell == -1) {
                return;
        }
        if (gtab_isborder(hwnd, ptab, x, cell)) {
                gtab_trackcol(hwnd, ptab, cell, x);
                return;
        }
        if ( (cell > 0) && gtab_isborder(hwnd, ptab, x, cell-1)) {
                gtab_trackcol(hwnd, ptab, cell, x);
                return;
        }

        /* find which line he selected */
        row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));

        /* is he selecting a disabled fixed area ? */
        if ( (row < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols)) {
                if (ptab->hdr.fixedselectable == FALSE) {
                        return;
                }
        }

        /* ok, start cell selection */
        ptab->trackmode = TRACK_CELL;
        SetCapture(hwnd);

        /* record and paint new selection */
        if (ptab->hdr.selectmode & TM_ROW) {
                gtab_select(hwnd, ptab, row, 0, 1, ptab->hdr.ncols, FALSE);
        } else {
                gtab_select(hwnd, ptab, row, cell, 1, 1, FALSE);
        }
        return;
}

/***************************************************************************
 * Function: gtab_release
 *
 * Purpose:
 *
 * Called on mouse-up. complete any tracking that was happening
 */
void
gtab_release(HWND hwnd, lpTable ptab, int x, int y)
{
        lpCellPos ppos;
        lpProps pprop;
        long row;
        int cx;

        switch(ptab->trackmode) {

        case TRACK_NONE:
                return;
        
        case TRACK_COLUMN:
                /* erase marker lines */
                gtab_drawvertline(hwnd, ptab);
                ReleaseCapture();
                ptab->trackmode = TRACK_NONE;

                /* adjust cell width */
                ppos = &ptab->pcellpos[ptab->tracknr];
                cx = ptab->trackline1 - ppos->start;
                pprop = &ptab->pcolhdr[ptab->tracknr].props;
                pprop->valid |= P_WIDTH;
                pprop->width = cx;
                gtab_calcwidths(hwnd, ptab);
                gtab_setsize(hwnd, ptab);
                InvalidateRect(hwnd, NULL, TRUE);
                return;

        case TRACK_CELL:
                row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));
                ReleaseCapture();
                ptab->trackmode = TRACK_NONE;

                /* keep the same selection. if the mouse is still
                 * in the box, select it, otherwise de-select it
                 */
                if ((row == ptab->select.startrow) &&
                  ( (ptab->hdr.selectmode & TM_ROW) ||
                    (ptab->select.startcell == gtab_xtocol(hwnd, ptab, x))) ) {

                        gtab_select(hwnd, ptab, ptab->select.startrow,
                                ptab->select.startcell,
                                ptab->select.nrows, ptab->select.ncells, TRUE);
                } else {
                        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
                }
                return;
        }
}


/***************************************************************************
 * Function: gtab_move
 *
 * Purpose:
 *
 * Called on mouse-move. if tracking - adjust position, if not,
 * set correct cursor
 */
void
gtab_move(HWND hwnd, lpTable ptab, int x, int y)
{
        BOOL fOK;
        long row;
        int col;
        lpCellPos ppos;

        switch(ptab->trackmode) {

        case TRACK_NONE:
                col = gtab_xtocol(hwnd, ptab, x);
                if (col == -1) {
                        SetCursor(hNormCurs);
                        return;
                }
                if (gtab_isborder(hwnd, ptab, x, col)) {
                        SetCursor(hVertCurs);
                        return;
                }
                if ( (col > 0) && gtab_isborder(hwnd, ptab, x, col-1)) {
                        SetCursor(hVertCurs);
                        return;
                }
                SetCursor(hNormCurs);
                return;

        case TRACK_CELL:
                row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));

                /* keep the same selection. if the mouse is still
                 * in the box, select it, otherwise de-select it
                 */
                if ((row == ptab->select.startrow) &&
                  ( (ptab->hdr.selectmode & TM_ROW) ||
                    (ptab->select.startcell == gtab_xtocol(hwnd, ptab, x))) ) {

                        if (!ptab->selvisible) {
                                gtab_invertsel(hwnd, ptab, NULL);
                                ptab->selvisible = TRUE;
                        }
                } else {
                        if (ptab->selvisible) {
                                gtab_invertsel(hwnd, ptab, NULL);
                                ptab->selvisible = FALSE;
                        }
                }
                return;
        
        case TRACK_COLUMN:
                /* check that new x is still visible/valid */
                ppos = &ptab->pcellpos[ptab->tracknr];
                fOK = FALSE;

                if (ptab->tracknr < ptab->hdr.fixedcols)  {
                        if ((x > ppos->start) && (x < ptab->winwidth)) {
                                fOK = TRUE;
                        }
                } else {
                        if ((x > ppos->clipstart) && (x < ptab->winwidth)) {
                                fOK = TRUE;
                        }
                }
                if (fOK == TRUE) {
                        gtab_drawvertline(hwnd, ptab);
                        ptab->trackline1 = x;
                        gtab_drawvertline(hwnd, ptab);
                }
                return;
        }
}

/***************************************************************************
 * Function: gtab_dblclick
 *
 * Purpose:
 *
 * dbl-click - send an TQ_ENTER event to the owner (if valid) 
 */
void
gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y)
{
        int cell, line;
        long row;

        line = gtab_ytoline(hwnd, ptab, y);
        cell = gtab_xtocol(hwnd, ptab, x);
        if ( (line < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols) ) {
                if (!ptab->hdr.fixedselectable) {
                        return;
                }
        }
        row = gtab_linetorow(hwnd, ptab, line);

        if (ptab->hdr.selectmode & TM_ROW) {
                gtab_enter(hwnd, ptab, row, 0, 1, ptab->hdr.ncols);
        } else {
                gtab_enter(hwnd, ptab, row, cell, 1, 1);
        }
}

/***************************************************************************
 * Function: gtab_showsel
 *
 * Purpose:
 *
 * Move selection area to visible part of window. Argument bToBottom
 * indicates whether to move the line onto the bottom or the top of the
 * window if not visible - this affects the smoothness of scrolling
 * line-by-line.
 */
void
gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom)
{
        int line;
        long change;

        line = gtab_rowtoline(hwnd, ptab, ptab->select.startrow);

        /* move up if last line or not at all visible */
        if ( (line < 0) || line == (ptab->nlines - 1)) {
                change = ptab->select.startrow - ptab->toprow;
                if (bToBottom) {
                        /* change to bottom of window. subtract 2 not 1
                         * since nlines includes one line that is only
                         * partly visible
                         */
                        change -= (ptab->nlines - 2);
                }
                change -= ptab->hdr.fixedrows;
                gtab_dovscroll(hwnd, ptab, change);
        }
        /* add support for TM_CELL here! */
}

/***************************************************************************
 * Function: gtab_showsel_middle
 *
 * Purpose:
 *
 * Scroll the window so that if possible, the selected row is in the
 * middle 60% of the screen so that context around it is visible.
 */
void
gtab_showsel_middle(HWND hwnd, lpTable ptab)
{
        int line;
        long change;
        int mid_top, mid_end;

        line = gtab_rowtoline(hwnd, ptab, ptab->select.startrow);


        /* is this within the middle 60 % ?  */
        mid_top = ptab->nlines * 20 / 100;
        mid_end = ptab->nlines * 80 / 100;
        if ((line < mid_top) || (line > mid_end)) {

                /* no - scroll so that selected line is at
                 * the 20% mark
                 */
                change = (ptab->select.startrow - mid_top) - ptab->toprow;              
                change -= ptab->hdr.fixedrows;
                gtab_dovscroll(hwnd, ptab, change);
        }
        /* again - need code here for TM_CELL mode to ensure that
         * active cell is horizontally scrolled correctly
         */
}



/***************************************************************************
 * Function: gtab_changesel
 *
 * Purpose:
 *
 * Move the selection a specified nr of rows or cells
 * if no selection, select first visible unit
 */
VOID
gtab_changesel(HWND hwnd, lpTable ptab, long rowincr, int cellincr, BOOL bToBottom)
{
        long row, col, nrows, ncols;

        /* is there a selection ? */
        if (ptab->select.nrows < 1) {

                /* no selection - force a selection
                 * at the first visible unit
                 */
                if (ptab->hdr.fixedselectable) {
                        row = 0;
                        col = 0;
                } else {
                        row = gtab_linetorow(hwnd, ptab, ptab->hdr.fixedrows);
                        /* should really check for first visible cell */
                        col = ptab->hdr.fixedcols;
                }
                nrows = 1;
                ncols = 1;
                if (ptab->hdr.selectmode & TM_ROW) {
                        col = 0;
                        ncols = ptab->hdr.ncols;
                }
        } else {
                row = ptab->select.startrow + rowincr;
                col = ptab->select.startcell + cellincr;
                while (col >= ptab->hdr.ncols) {
                        col -= ptab->hdr.ncols;
                        row++;
                }
                while (col < 0) {
                        col += ptab->hdr.ncols;
                        row--;
                }
                if (row < 0) {
                        row = 0;
                }
                if (row >= ptab->hdr.nrows) {
                        row = ptab->hdr.nrows-1;
                }
                /* check we haven't moved into non-selectable region */
                if ((row < ptab->hdr.fixedrows) &&
                        (!ptab->hdr.fixedselectable)) {
                                row = ptab->hdr.fixedrows;
                }
                nrows = ptab->select.nrows;
                ncols = ptab->select.ncells;
        }
        gtab_select(hwnd, ptab, row, col, nrows, ncols, TRUE);
        /* ensure selection visible */
        gtab_showsel(hwnd, ptab, bToBottom);
}

/***************************************************************************
 * Function: gtab_selhome
 *
 * Purpose:
 *
 * Set the topmost selectable unit in window as the selection 
 */
void
gtab_selhome(HWND hwnd, lpTable ptab)
{
        long row;

        if (ptab->hdr.fixedselectable) {
                row = gtab_linetorow(hwnd, ptab, 0);
                if (ptab->hdr.selectmode & TM_ROW) {
                        gtab_select(hwnd, ptab, row, 0, 1,
                                ptab->hdr.ncols, TRUE);
                } else {
                        gtab_select(hwnd, ptab, row, 0, 1, 1, TRUE);
                }
        } else {
                row = gtab_linetorow(hwnd, ptab, ptab->hdr.fixedrows);
                if (ptab->hdr.selectmode & TM_ROW) {
                        gtab_select(hwnd, ptab, row, 0, 1,
                                ptab->hdr.ncols, TRUE);
                } else {
                        gtab_select(hwnd, ptab, row,
                                ptab->hdr.fixedcols, 1, 1, TRUE);
                }
        }
}


/***************************************************************************
 * Function: gtab_key
 *
 * Purpose:
 *
 * Handle key-down events - scroll windows and/or move selection 
 */
int
gtab_key(HWND hwnd, lpTable ptab, int vkey)
{
        long row;
        BOOL bControl = FALSE;

        if (GetKeyState(VK_CONTROL) & 0x8000) {
                bControl = TRUE;
        }

        switch(vkey) {

        case VK_UP:
                if (bControl) {
                        /* control-uparrow scrolls window without selection.
                         * the selection is de-selected (to avoid surprises
                         * moving back to it).
                         */
                        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
                        gtab_dovscroll(hwnd, ptab, -1);
                } else {
                        /* uparrow moves selection up one line */
                        gtab_changesel(hwnd, ptab, -1, 0, FALSE);
                }
                return(0);

        case VK_DOWN:
                if (bControl) {
                        /* control downarrow scrolls window without
                         * a selection.
                         */
                        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
                        gtab_dovscroll(hwnd, ptab, 1);
                } else {
                        /* the normal gtab_changesel behaviour is
                         * that if the selected line is not visible now,
                         * we scroll it to the top of the window. This is fine
                         * in most cases but causes unacceptable jumps when
                         * repeatedly scrolling down with the down key.
                         *
                         * Thus we now have an argument to changesel to say
                         * that in this case, if you need to move the line onto
                         * the window, move it to the bottom and not the top
                         */
                        gtab_changesel(hwnd, ptab, 1, 0, TRUE);
                }
                return(0);

        case VK_LEFT:
                /* if cell-selection mode, move left one cell.
                 * otherwise the whole row is selected - scroll
                 * the line left a little
                 */

                if (ptab->hdr.selectmode & TM_ROW) {
                        if (bControl) {
                                /* ctrl-left moves to start of line */
                                gtab_dohscroll(hwnd, ptab, -(ptab->scroll_dx));
                        } else {
                                gtab_dohscroll(hwnd, ptab, -(ptab->avewidth));
                        }
                } else {
                        gtab_changesel(hwnd, ptab, 0, -1, FALSE);
                }
                return(0);

        case VK_RIGHT:
                /* if cell-selection mode, move right one cell.
                 * otherwise the whole row is selected - scroll
                 * the line right a little
                 */
                if (ptab->hdr.selectmode & TM_ROW) {
                        if (bControl) {
                                /* control-right moves to right end of line */
                                gtab_dohscroll(hwnd, ptab, ptab->rowwidth -
                                                ptab->winwidth);
                        } else {
                                gtab_dohscroll(hwnd, ptab, ptab->avewidth);
                        }
                } else {
                        gtab_changesel(hwnd, ptab, 0, 1, TRUE);
                }
                return(0);

        case VK_HOME:
                if (bControl) {
                        /* control-home == top of file */
                        gtab_dovscroll(hwnd, ptab, -(ptab->toprow));
                }
                /* top of window */
                gtab_selhome(hwnd, ptab);
                gtab_showsel(hwnd, ptab, FALSE);
                
                return(0);

        case VK_END:
                if (bControl) {
                        /* control-end -> end of file */
                        row = ptab->hdr.nrows-1;
                } else {
                        row = gtab_linetorow(hwnd, ptab, ptab->nlines - 1);
                        if (row >= ptab->hdr.nrows) {
                                row = ptab->hdr.nrows-1;
                        }
                }
                if (ptab->hdr.selectmode & TM_ROW) {
                        gtab_select(hwnd, ptab, row, 0, 1,
                                ptab->hdr.ncols, TRUE);
                } else {
                        gtab_select(hwnd, ptab, row,
                                ptab->hdr.ncols-1, 1, 1, TRUE);
                }
                /* we have selected the bottom line. We don't want to
                 * move it up into the window, since the intended
                 * effect is to select the lowest line. This doesn't
                 * apply to the ctrl-end behaviour (move to bottom of
                 * buffer.
                 */
                if (bControl) {
                        /* move the selection to make it visible - but move it
                         * to the bottom and not to the top of the window
                         */
                        gtab_showsel(hwnd, ptab, TRUE);
                }
                return(0);

        case VK_RETURN:
                if (ptab->select.nrows > 0) {
                        gtab_showsel(hwnd, ptab, FALSE);
                        gtab_enter(hwnd, ptab, ptab->select.startrow,
                                ptab->select.startcell,
                                ptab->select.nrows, ptab->select.ncells);
                }
                return(0);

        case VK_SPACE:
                /* toggle the selection */
                if (ptab->select.nrows < 1) {
                        /* no selection - make one */
                        gtab_changesel(hwnd, ptab, 0, 0, TRUE);
                } else {
                        /* there is a selection - deselect it */
                        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
                }
                return(0);

        case VK_PRIOR:          /* page up */

                gtab_dovscroll(hwnd, ptab, -(ptab->nlines - 3));
                gtab_selhome(hwnd, ptab);
                return(0);

        case VK_NEXT:           /* page down */

                /* scroll down one page */
                gtab_dovscroll(hwnd, ptab, (ptab->nlines - 3));

                /* select new bottom line */
                row = gtab_linetorow(hwnd, ptab, ptab->nlines - 1);
                if (row >= ptab->hdr.nrows) {
                        row = ptab->hdr.nrows-1;
                }
                /* select bottom line, but don't call showsel
                 * since we don't want to adjust it's position - we
                 * want it to remain at the bottom of the window
                 */
                if (ptab->hdr.selectmode & TM_ROW) {
                        gtab_select(hwnd, ptab, row, 0, 1,
                                ptab->hdr.ncols, TRUE);
                } else {
                        gtab_select(hwnd, ptab, row,
                                ptab->hdr.ncols-1, 1, 1, TRUE);
                }

                return(0);

        default:
                return(1);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\tpriv.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * TPRIV.H
 *
 * Data structures used internally by table class.
 *
 * Note: include after table.h
 */


#ifndef abs
#define abs(x)  (((x) > 0)? (x) : -(x))
#endif

/*  one of these per visible line */
typedef struct {
        CellPos linepos;        /* posn and clipping info for line */

        lpCellData pdata;       /* array of CellData structs for all cells */
} LineData, FAR * lpLineData;


/* master info struct pointed to by window extra bytes */

typedef struct {
        /* table info */
        TableHdr        hdr;            /* main hdr info from owner */
        lpColProps      pcolhdr;        /* ptr to array of phdr->ncols hdrs */

        /* window info */
        int     avewidth;       /* font ave width - for default cell sizing */
        int     rowheight;      /* height of one row */
        int     rowwidth;       /* total width of one row in pixels */
        int     winwidth;       /* width of window */
        int     nlines;         /* actual lines currently visible */
        
        lpCellPos pcellpos;     /* array of cell position structs */

        /* scroll settings */
        long    scrollscale;    /* scaling factor (force 16-bit range) */
        long    toprow;         /* 0-based rownr of top moveable line */
        int     scroll_dx;      /* horz scroll posn in pixels. */

        /* column data */
        lpLineData pdata;       /* ptr to array of nlines of LineData */

        /* selection/dragging */
        UINT    trackmode;      /* current mouse-tracking mode */
        int     tracknr;        /* col or row being resized */
        int     trackline1;     /* currently drawn track lines */
        int     trackline2;
        BOOL    selvisible;     /* used during mouse-down: T if sel drawn */
        TableSelection select;

} Table, FAR * lpTable;

/* trackmode constants */
#define TRACK_NONE              0
#define TRACK_COLUMN            1
#define TRACK_CELL              2

/* private flags in CellData struct */
#define CELL_VALID      1

/* window extra bytes are used to hold the owner, heap and Table structs */
#define WW_OWNER        0                               /* HWND of owner */
#define WW_HEAP         (WW_OWNER + sizeof(HWND))       /* gmem heap */
#define WL_TABLE        (WW_HEAP + sizeof(HANDLE))      /* lpTable */
#define WLTOTAL         (WL_TABLE + sizeof(lpTable))    /* total extra bytes */

/* ---------- global data -------------------*/

extern HPEN hpenDotted;         /* in table.c */
extern HANDLE hVertCurs;        /* in table.c */
extern HANDLE hNormCurs;        /* in table.c */

/*------function prototypes ---------------------------------------*/

/* in table.c */

void gtab_init(void);    /* called from DLL startup function */
long gtab_sendtq(HWND hwnd, UINT cmd, long lParam);
void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count);
void gtab_setsize(HWND hwnd, lpTable ptab);
void gtab_calcwidths(HWND hwnd, lpTable ptab);
void gtab_deltable(HWND hwnd, lpTable ptab);
BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab);

/* in tpaint.c */
void gtab_paint(HWND hwnd, HDC hdc, lpTable ptab, int line);
void gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc);
void gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc);
void gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in);
void gtab_drawvertline(HWND hwnd, lpTable ptab);

/* in tscroll.c */
void gtab_dovscroll(HWND hwnd, lpTable ptab, long change);
void gtab_dohscroll(HWND hwnd, lpTable ptab, long change);
long gtab_linetorow(HWND hwnd, lpTable ptab, int line);
int gtab_rowtoline(HWND hwnd, lpTable ptab, long row);
void gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos);
void gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos);
void gtab_select(HWND hwnd, lpTable ptab, long row, long col, long nrows,
        long ncells, BOOL bNotify);
void gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows,
        long ncells);
void gtab_press(HWND hwnd, lpTable ptab, int x, int y);
void gtab_release(HWND hwnd, lpTable ptab, int x, int y);
void gtab_move(HWND hwnd, lpTable ptab, int x, int y);
void gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y);
void gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom);
void gtab_showsel_middle(HWND hwnd, lpTable ptab);
int gtab_key(HWND hwnd, lpTable ptab, int vkey);

/* in tprint.c */
void gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext);
void gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\tpaint.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: TPAINT.C
*
* Paint functions
*
* Functions:
*
* GetTextExtent()
* gtab_updatecontig()
* gtab_delcr()
* gtab_updateline()
* gtab_updatecontig()
* gtab_boxcell()
* gtab_paintcell()
* gtab_paint()
* gtab_vsep()
* gtab_hsep()
* gtab_drawvertline()
* gtab_invertsel()
* 
* Comments:
*
* See table.h for interface design.
*
****************************************************************************/
#include <string.h>
#include <windows.h>
#include <commdlg.h>

#include "gutils.h"
#include "table.h"
#include "tpriv.h"


/***************************************************************************
 * Function: GetTextExtent
 *
 * Purpose:
 * 
 * Calls GetTextExtentPoint - for ease of porting.
 */
 int
GetTextExtent(HDC hdc, LPSTR text, int len)
{
    SIZE sz;

    GetTextExtentPoint(hdc, text, len, &sz);
    return(sz.cx);
}

void gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count);

/***************************************************************************
 * Function: gtab_delcr
 *
 * Purpose:
 *
 * change all cr/lf chars in input text to spaces 
 */
void gtab_delcr(LPSTR ptext)
{
        LPSTR chp;

        if (ptext == NULL) {
                return;
        }
        for(chp = ptext; (chp = strchr(chp, '\r')) != NULL; ) {
                *chp = ' ';
        }
        for(chp = ptext; (chp = strchr(chp, '\n')) != NULL; ) {
                *chp = ' ';
        }
}

/***************************************************************************
 * Function: gtab_updateline
 *
 * Purpose:
 *
 * Ensures that all visible cells in the given line have valid
 * text and property contents. loop through the cells, picking out
 * contiguous blocks of visible, invalid cells and call
 * gtab_updatecontig to update these from the owner window.
 */
void
gtab_updateline(HWND hwnd, lpTable ptab, int line)
{
        lpCellPos ppos;
        int cell1, cellcount;
        lpLineData pline;
        lpCellData cd;
        int i;

        pline = &ptab->pdata[line];
        cell1 = 0;
        cellcount = 0;
        for (i = 0; i < ptab->hdr.ncols; i++) {
                ppos = &ptab->pcellpos[i];
                cd = &pline->pdata[i];
                if (ppos->clipstart < ppos->clipend) {
                        if ((cd->flags & CELL_VALID) == 0) {
                                /* add a cell to the list to be updated*/
                                if (cellcount++ == 0) {
                                        cell1 = i;
                                }
                        } else {
                                /* this cell already valid - so end of
                                 * a contig block. if the contig
                                 * block just ended contained cells to update,
                                 * do it now
                                 */
                                if (cellcount > 0) {
                                        gtab_updatecontig(hwnd, ptab,
                                          line, cell1, cellcount);
                                }
                                cellcount = 0;
                        }
                }
                /* cell not visible - end of a contig block. If it was a
                 * non-empty contig block, then update it now.
                 */
                if (cellcount > 0)  {
                        gtab_updatecontig(hwnd, ptab, line, cell1, cellcount);
                        cellcount = 0;  
                }
        }
        if (cellcount > 0) {
                gtab_updatecontig(hwnd, ptab, line, cell1, cellcount);
                cellcount = 0;
        }
}

/***************************************************************************
 * Function: gtab_updatecontig
 *
 * Purpose:
 *
 * Updates a contiguous block of invalid cells by calling the owner window
 */
void
gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count)
{
        lpLineData pline;
        lpCellData cd;
        CellDataList list;
        lpProps colprops;
        int i;

        pline = &ptab->pdata[line];
        cd = &pline->pdata[cell1];

        list.id = ptab->hdr.id;
        list.row = gtab_linetorow(hwnd, ptab, line);
        list.startcell = cell1;
        list.ncells = count;
        list.plist = cd;

        /* clear out prop flags */
        for (i = 0; i < count; i++) {
                cd[i].props.valid = 0;
                if (cd[i].nchars > 0) {
                        cd[i].ptext[0] = '\0';
                }
        }

        if (list.row < ptab->hdr.nrows) {
                gtab_sendtq(hwnd, TQ_GETDATA, (long) (LPSTR) &list);
        }

        /* for each cell, mark valid and set properties */
        for (i = 0; i < count; i++) {
                cd[i].flags |= CELL_VALID;
                gtab_delcr(cd[i].ptext);
                /* fetch properties from hdr and colhdr */
                colprops = &ptab->pcolhdr[i + cell1].props;
                if (!(cd[i].props.valid & P_FCOLOUR)) {
                        if (colprops->valid & P_FCOLOUR) {
                                cd[i].props.valid |= P_FCOLOUR;
                                cd[i].props.forecolour = colprops->forecolour;
                        } else if (ptab->hdr.props.valid & P_FCOLOUR) {
                                cd[i].props.valid |= P_FCOLOUR;
                                cd[i].props.forecolour =
                                        ptab->hdr.props.forecolour;
                        }
                }

                if (!(cd[i].props.valid & P_BCOLOUR)) {
                        if (colprops->valid & P_BCOLOUR) {
                                cd[i].props.valid |= P_BCOLOUR;
                                cd[i].props.backcolour = colprops->backcolour;
                        } else if (ptab->hdr.props.valid & P_BCOLOUR) {
                                cd[i].props.valid |= P_BCOLOUR;
                                cd[i].props.backcolour =
                                        ptab->hdr.props.backcolour;
                        }
                }

                if (!(cd[i].props.valid & P_FONT)) {
                        if (colprops->valid & P_FONT) {
                                cd[i].props.valid |= P_FONT;
                                cd[i].props.hFont = colprops->hFont;
                        } else if (ptab->hdr.props.valid & P_FONT) {
                                cd[i].props.valid |= P_FONT;
                                cd[i].props.hFont = ptab->hdr.props.hFont;
                        }
                }

                if (!(cd[i].props.valid & P_ALIGN)) {
                        if (colprops->valid & P_ALIGN) {
                                cd[i].props.valid |= P_ALIGN;
                                cd[i].props.alignment = colprops->alignment;
                        } else if (ptab->hdr.props.valid & P_ALIGN) {
                                cd[i].props.valid |= P_ALIGN;
                                cd[i].props.alignment =
                                        ptab->hdr.props.alignment;
                        }
                }

                if (!(cd[i].props.valid & P_BOX)) {
                        if (colprops->valid & P_BOX) {
                                cd[i].props.valid |= P_BOX;
                                cd[i].props.box = colprops->box;
                        } else if (ptab->hdr.props.valid & P_BOX) {
                                cd[i].props.valid |= P_BOX;
                                cd[i].props.box = ptab->hdr.props.box;
                        }
                }
                /* you can't set width/height per cell - this
                 * is ignored at cell level.
                 */
        }

}

/***************************************************************************
 * Function: gtab_boxcell
 *
 * Purpose:
 *
 * Draws box around a cell in a table.
 */ 
void
gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode)
{
        if (boxmode & P_BOXTOP) {
                MoveToEx(hdc, max(rcp->left, pclip->left),
                        max(rcp->top, pclip->top), NULL);
                LineTo(hdc, min(rcp->right, pclip->right),
                        max(rcp->top, pclip->top));
        }
        if (boxmode & P_BOXBOTTOM) {
                MoveToEx(hdc, max(rcp->left, pclip->left),
                        min(rcp->bottom, pclip->bottom), NULL);
                LineTo(hdc, min(rcp->right, pclip->right),
                        min(rcp->bottom, pclip->bottom));
        }
        if (boxmode & P_BOXLEFT) {
                MoveToEx(hdc, max(rcp->left, pclip->left),
                        max(rcp->top, pclip->top), NULL);
                MoveToEx(hdc, max(rcp->left, pclip->left),
                        min(rcp->bottom, pclip->bottom), NULL);
        }
        if (boxmode & P_BOXRIGHT) {
                MoveToEx(hdc, min(rcp->right, pclip->right),
                        max(rcp->top, pclip->top), NULL);
                LineTo(hdc, min(rcp->right, pclip->right),
                        min(rcp->bottom, pclip->bottom));
        }
}

/***************************************************************************
 * Function: gtab_paintcell
 *
 * Purpose:
 *
 * Paints a cell.
 */
void
gtab_paintcell(HWND hwnd, HDC hdc, lpTable ptab, int line, int cell)
{
        lpLineData pline;
        lpCellData cd;
        lpCellPos ppos;
        RECT rc, rcbox;
        int cx, x, y, tabwidth;
        UINT align;
        LPSTR chp, tabp;
        DWORD fcol, bkcol;
        HFONT hfont;
        TEXTMETRIC tm;
        HBRUSH hbr;

        /* init pointers to cell text and properties */
        pline = &ptab->pdata[line];
        cd = &pline->pdata[cell];
        ppos = &ptab->pcellpos[cell];

        /* clip all output to this rectangle */
        rc.top = pline->linepos.clipstart;
        rc.bottom = pline->linepos.clipend;
        rc.left = ppos->clipstart;
        rc.right = ppos->clipend;


        /* check cell properties and colours */
        if (cd->props.valid & P_ALIGN) {
                align = cd->props.alignment;
        } else {
                align = P_LEFT;
        }
        if (cd->props.valid & P_FONT) {
                hfont = SelectObject(hdc, cd->props.hFont);
                GetTextMetrics(hdc, &tm);
                tabwidth = tm.tmAveCharWidth * 8;
        } else {
                tabwidth = ptab->avewidth * 8;
        }

        /* set colours if not default */
        if (cd->props.valid & P_FCOLOUR) {
                fcol = SetTextColor(hdc, cd->props.forecolour);
        }
        if (cd->props.valid & P_BCOLOUR) {
                /* there is a non-default background colour.
                 * create a brush and fill the entire cell with it
                 */
                hbr = CreateSolidBrush(cd->props.backcolour);
                FillRect(hdc, &rc, hbr);
                DeleteObject(hbr);

                /* also set colour as background colour for the text */
                bkcol = SetBkColor(hdc, cd->props.backcolour);
        }

        /* calc offset of text within cell for right-align or centering */
        if (align == P_LEFT) {
                cx = ptab->avewidth/2;
        } else {
                if (cd->ptext == NULL) {
                        cx = 0;
                } else {
                        cx = LOWORD(GetTextExtent(hdc, cd->ptext,
                                        lstrlen(cd->ptext)));
                }
                if (align == P_CENTRE) {
                        cx = (ppos->size - cx) / 2;
                } else {
                        cx = ppos->size - cx - (ptab->avewidth/2);
                }
        }
        cx += ppos->start;

        /* expand tabs on output */
        x = 0;
        y = pline->linepos.start;

        for (chp = cd->ptext;
            ((chp != NULL) && ((tabp = strchr(chp, '\t')) != NULL)); ) {
                /* perform output upto tab char */
                ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, tabp-chp, NULL);
                
                /* advance past the tab */
                x += LOWORD(GetTextExtent(hdc, chp, tabp - chp));
                x = ( (x + tabwidth) / tabwidth) * tabwidth;
                chp = ++tabp;
        }

        /*no more tabs - output rest of string */
        if (chp != NULL) {
                ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc,
                                chp, lstrlen(chp), NULL);
        }

        /* reset colours to original if not default */
        if (cd->props.valid & P_FCOLOUR) {
                SetTextColor(hdc, fcol);
        }
        if (cd->props.valid & P_BCOLOUR) {
                SetBkColor(hdc, bkcol);
        }
        if (cd->props.valid & P_FONT) {
                SelectObject(hdc, hfont);
        }

        /* now box cell if marked */
        if (cd->props.valid & P_BOX) {
                if (cd->props.box != 0) {
                        rcbox.top = pline->linepos.start;
                        rcbox.bottom = rcbox.top + pline->linepos.size;
                        rcbox.left = ppos->start;
                        rcbox.right = ppos->start + ppos->size;
                        gtab_boxcell(hwnd, hdc, &rcbox, &rc, cd->props.box);
                }
        }
}

/***************************************************************************
 * Function: gtab_paint
 *
 * Purpose:
 *
 * Fetch and paint the specified line 
 */
void
gtab_paint(HWND hwnd, HDC hdc, lpTable ptab, int line)
{
        lpCellPos ppos;
        int i;

        gtab_updateline(hwnd, ptab, line);

        for (i = 0; i < ptab->hdr.ncols; i++) {
                ppos = &ptab->pcellpos[i];
                if (ppos->clipstart < ppos->clipend) {
                        gtab_paintcell(hwnd, hdc, ptab, line, i);
                }
        }
}


/***************************************************************************
 * Function: gtab_vsep
 *
 * Purpose:
 *
 */
void
gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc)
{
        int x;
        RECT rc;

        if (ptab->hdr.fixedcols < 1) {
                return;
        }
        x = ptab->pcellpos[ptab->hdr.fixedcols - 1].clipend+1;
        GetClientRect(hwnd, &rc);
        MoveToEx(hdc, x, rc.top, NULL);
        LineTo(hdc, x, rc.bottom);
}

/***************************************************************************
 * Function: gtab_hsep
 *
 * Purpose:
 */
void
gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc)
{
        int y;
        RECT rc;

        if (ptab->hdr.fixedrows < 1) {
                return;
        }
        y = ptab->rowheight * ptab->hdr.fixedrows;
        GetClientRect(hwnd, &rc);
        MoveToEx(hdc, rc.left, y-1, NULL);
        LineTo(hdc, rc.right, y-1);
}

/***************************************************************************
 * Function: gtab_drawverline
 *
 * Purpose:
 *
 * Draw in (inverting) the dotted selection lines for tracking a col width
 */
void
gtab_drawvertline(HWND hwnd, lpTable ptab)
{
        RECT rc;
        HDC hdc;
        HPEN hpen;

        hdc = GetDC(hwnd);
        SetROP2(hdc, R2_XORPEN);
        hpen = SelectObject(hdc, hpenDotted);
        GetClientRect(hwnd, &rc);

        MoveToEx(hdc, ptab->trackline1, rc.top, NULL);
        LineTo(hdc, ptab->trackline1, rc.bottom);
        if (ptab->trackline2 != -1) {
                MoveToEx(hdc, ptab->trackline2, rc.top, NULL);
                LineTo(hdc, ptab->trackline2, rc.bottom);
        }

        SelectObject(hdc, hpen);
        ReleaseDC(hwnd, hdc);
}
        

/***************************************************************************
 * Function: gtab_invertsel
 *
 * Purpose:
 *
 * Mark the selected line, if visible, in the style chosen by the
 * client app. This can be TM_SOLID, meaning an inversion of
 * the whole selected area or TM_FOCUS, meaning, inversion of the first
 * cell, and then a dotted focus rectangle for the rest.
 *
 * This function inverts either style, and so will turn the selection
 * both on and off.
 */
void
gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in)
{
        HDC hdc;
        int line;
        RECT rc;
        int lastcell;


        /* is row visible on screen ?  */
        line = gtab_rowtoline(hwnd, ptab, ptab->select.startrow);
        if (line < 0) {
                return;
        }

        /* selection mode includes a flag TM_FOCUS indicating we should
         * use a focus rect instead of the traditional inversion for
         * selections in this table. This interferes with multiple backgrnd
         * colours less.  However we still do inversion for fixedcols.
         */

        lastcell = (int)(ptab->select.startcell + ptab->select.ncells - 1);

        rc.top = ptab->pdata[line].linepos.clipstart;
        rc.bottom = ptab->pdata[line].linepos.clipend;

        /*
         * invert the whole area for TM_SOLID or just the first
         * cell for TM_FOCUS
         */
        rc.left = ptab->pcellpos[ptab->select.startcell].clipstart;
        if (ptab->hdr.selectmode & TM_FOCUS) {
                rc.right = ptab->pcellpos[ptab->select.startcell].clipend;
        }else {
                rc.right = ptab->pcellpos[lastcell].clipend;
        }

        if (hdc_in == NULL) {
                hdc = GetDC(hwnd);
        } else {
                hdc = hdc_in;
        }

        InvertRect(hdc, &rc);

        /*
         * draw focus rectangle around remaining cells on this line, if there
         * are any
         */
        if (ptab->hdr.selectmode & TM_FOCUS) {
                if (ptab->select.ncells > 1) {
                        rc.left = ptab->pcellpos[ptab->select.startcell+1].clipstart;
                        rc.right = ptab->pcellpos[lastcell].clipend;
                        DrawFocusRect(hdc, &rc);
                }
        }

        if (hdc_in == NULL) {
                ReleaseDC(hwnd, hdc);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\tree.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * TREE.H
 *
 * NOTE: include gutils.h before this.
 */

/* handle for a tree */
typedef struct tree FAR * TREE;

/* keys in these trees are DWORDs */
typedef DWORD TREEKEY;

/* A place-holder understood only by tree_search and
 * tree_addafter
 */
typedef struct treeitem FAR * TREEITEM;

/* pointer to one of these place holders */
typedef TREEITEM FAR * PTREEITEM;


TREE APIENTRY tree_create(HANDLE hHeap);
void APIENTRY tree_delete(TREE tree);
LPVOID APIENTRY tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length);
LPVOID APIENTRY tree_find(TREE tree, TREEKEY key);
LPVOID APIENTRY tree_search(TREE tree, TREEKEY key, PTREEITEM place);
LPVOID APIENTRY tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value,
                        UINT length);
TREE APIENTRY ctree_create(HANDLE hHeap);
void APIENTRY ctree_delete(TREE tree);
LPVOID APIENTRY ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length);
long APIENTRY ctree_getcount(TREE tree, TREEKEY key);
LPVOID APIENTRY ctree_find(TREE tree, TREEKEY key);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\debugger.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Debugger.cpp
//
//	Created by :			Date :
//		Waynebr					2/18/94
//
//	Description :
//		Debugger tests helpers
//

#include "stdafx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	Debugging helpers

int ReturnCode =0;
bp  * ReturnBP =0;

void LogResult(int result,LPCSTR szoperation, int code=0) {
	CString szextra;
	//if (code==0)  szextra="Error Code="+itoa(code);
	if (!result) {
		LOG->RecordFailure(szextra + szoperation);
	}
	else {
		LOG->RecordInfo(szextra + szoperation);
	}
};

//
//	Returns the current directory of the first time this function was called.
//
LPCSTR HomeDir()
{
	static CString szCurDir;

	if( szCurDir.IsEmpty() )
	{
		char* psz = szCurDir.GetBufferSetLength(_MAX_DIR);

		GetCurrentDirectory(_MAX_DIR - 1, psz);
		szCurDir.ReleaseBuffer(-1);
		if( szCurDir.Right(1) != '\\' )
			szCurDir += "\\";
	}
 	return szCurDir;
 }

//
//	Returns the fully qualified path with szAddPath appended to the sniff dir.	
//
 LPCSTR FullPath( LPCSTR szAddPath )
 {
	static CString szFilespec;

	szFilespec = HomeDir();
	szFilespec += szAddPath;

	return szFilespec;
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\tprint.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: TPRINT.C
*
* Print functions.
*
* Functions:
*
* gtab_print()
* gtab_printsetup()
* gtab_prtwidths()
* gtab_printjob()
* AbortProc()
* AbortDlg()
* gtab_printpage()
* gtab_setrects()
* gtab_printhead()
*
* Comments:
*
* See table.h for interface description.
*
****************************************************************************/

#include <string.h>
#include <windows.h>
#include <commdlg.h>

#include "gutils.h"
#include "gutilsrc.h"
#include "table.h"
#include "tpriv.h"

/* in tpaint.c, calls GetTextExtentPoint */
extern int GetTextExtent(HDC, LPSTR, int);

extern HANDLE hLibInst;

/* function prototypes */
lpTable gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap,
        lpPrintContext pcontext);
BOOL gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext
        pcontext);
void gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext);
int APIENTRY AbortProc(HDC hpr, int code);
int APIENTRY AbortDlg(HWND hdlg, UINT msg, UINT wParam, LONG lParam);
BOOL gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page);
void gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter);
void gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page);


/***************************************************************************
 * Function: gtab_print
 *
 * Purpose:
 *
 * Prints a table.
 */
void
gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
        BOOL fNoContext, fNoMargin, fNoPD;
        lpTable ptab_prt;

        fNoContext = FALSE;
        fNoPD = FALSE;
        fNoMargin = FALSE;

        if (pcontext == NULL) {
                fNoContext = TRUE;
                pcontext = (lpPrintContext) gmem_get(heap,
                        sizeof(PrintContext));
                pcontext->head = pcontext->foot = NULL;
                pcontext->margin = NULL;
                pcontext->pd = NULL;
                pcontext->id = 0;
        }
        if (pcontext->pd == NULL) {
                fNoPD = TRUE;
        }
        if (pcontext->margin == NULL) {
                fNoMargin = TRUE;
        }
        ptab_prt = gtab_printsetup(hwnd, ptab, heap, pcontext);

        if (ptab_prt != NULL) {
                gtab_printjob(hwnd, ptab_prt, pcontext);

                gtab_deltable(hwnd, ptab_prt);
        }
        if (fNoMargin) {
                gmem_free(heap, (LPSTR)pcontext->margin,
                        sizeof(Margin));
                pcontext->margin = NULL;
        }
        if (fNoPD) {
                if (pcontext->pd->hDevMode != NULL) {
                        GlobalFree(pcontext->pd->hDevMode);
                }
                if (pcontext->pd->hDevNames != NULL) {
                        GlobalFree(pcontext->pd->hDevNames);
                }
                gmem_free(heap, (LPSTR) pcontext->pd, sizeof(PRINTDLG));
                pcontext->pd = NULL;
        }
        if (fNoContext) {
                gmem_free(heap, (LPSTR) pcontext, sizeof(PrintContext));
        }
}



/***************************************************************************
 * Function: gtab_printsetup
 *
 * Purpose:
 *
 * Sets up printercontext - builds lpTable for printer, incl. sizing
 * and initialises pcontext fields that may be null.
 */
lpTable
gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
        lpTable pprttab;
        PRINTDLG FAR * pd;
        int ncols, i;
        ColPropsList cplist;

        /* set fields for context that user left null */
        if (pcontext->margin == NULL) {
                pcontext->margin = (lpMargin) gmem_get(heap, sizeof(Margin));
                if (pcontext->margin == NULL) {
                        return(NULL);
                }
                pcontext->margin->left = 10;
                pcontext->margin->right = 10;
                pcontext->margin->top = 15;
                pcontext->margin->bottom = 15;
                pcontext->margin->topinner = 15;
                pcontext->margin->bottominner = 15;
        }

        if (pcontext->pd == NULL) {
                pd = (PRINTDLG FAR *) gmem_get(heap, sizeof(PRINTDLG));
                if (pd == NULL) {
                        return(NULL);
                }
                pcontext->pd = pd;

                pd->lStructSize = sizeof(PRINTDLG);
                pd->hwndOwner = hwnd;
                pd->hDevMode = (HANDLE) NULL;
                pd->hDevNames = (HANDLE) NULL;
                pd->Flags = PD_RETURNDC|PD_RETURNDEFAULT;

                if (PrintDlg(pd) == FALSE) {
                        return(NULL);
                }
        }

        /* now create a Table struct by querying the owner */
        pprttab = (lpTable) gmem_get(heap, sizeof(Table));

        if (pprttab == NULL) {
                return(NULL);
        }
        pprttab->hdr = ptab->hdr;

        /* get the row/column count from owner window */
        if (pcontext->id == 0) {
                pprttab->hdr.id = ptab->hdr.id;
        } else {
                pprttab->hdr.id = pcontext->id;
        }
        pprttab->hdr.props.valid = 0;
        pprttab->hdr.sendscroll = FALSE;
        if (gtab_sendtq(hwnd, TQ_GETSIZE, (long) (LPSTR)&pprttab->hdr) == FALSE) {
                return(NULL);
        }

        /* alloc and init the col data structs */
        ncols = pprttab->hdr.ncols;
        pprttab->pcolhdr = (lpColProps) gmem_get(heap, sizeof(ColProps) * ncols);
        if (pprttab->pcolhdr == NULL) {
                gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
                return(NULL);
        }

        /* init col properties to default */
        for (i=0; i < ncols; i++) {
                pprttab->pcolhdr[i].props.valid = 0;
                pprttab->pcolhdr[i].nchars = 0;
        }
        /* get the column props from owner */
        cplist.plist = pprttab->pcolhdr;
        cplist.id = pprttab->hdr.id;
        cplist.startcol = 0;
        cplist.ncols = ncols;
        gtab_sendtq(hwnd, TQ_GETCOLPROPS, (long) (LPSTR)&cplist);


        pprttab->scrollscale = 1;
        pprttab->pcellpos = (lpCellPos) gmem_get(heap,
                sizeof(CellPos) * ptab->hdr.ncols);
        if (pprttab->pcellpos == NULL) {
                gmem_free(heap, (LPSTR) pprttab->pcolhdr, sizeof(ColProps) * ncols);
                gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
                return(NULL);
        }
                

        pprttab->pdata = NULL;
        pprttab->nlines = 0;

        if (!gtab_prtwidths(hwnd, pprttab, heap, pcontext)) {
                gmem_free(heap, (LPSTR)pprttab->pcellpos,
                        sizeof(CellPos) * ptab->hdr.ncols);
                gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
                return(NULL);
        }
        return(pprttab);
}


/***************************************************************************
 * Function: gtab_prtwidths
 *
 * Purpose:
 *
 * Calc the height/width settings and alloc line data 
 */
BOOL
gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
        TEXTMETRIC tm;
        int cx, cxtotal, i, curx, cury;
        lpProps hdrprops, cellprops;
        lpCellPos xpos, ypos;
        RECT rcinner, rcouter;

        hdrprops = &ptab->hdr.props;
        GetTextMetrics(pcontext->pd->hDC, &tm);
        ptab->avewidth = tm.tmAveCharWidth;
        ptab->rowheight = tm.tmHeight + tm.tmExternalLeading;
        if (hdrprops->valid & P_HEIGHT) {
                ptab->rowheight = hdrprops->height;
        }

        /* set sizes for headers */
        gtab_setrects(pcontext, &rcinner, &rcouter);

        /* set width/pos for each col. */
        cxtotal = 0;
        curx = rcinner.left;
        for (i = 0; i < ptab->hdr.ncols; i++) {
                cellprops = &ptab->pcolhdr[i].props;
                xpos = &ptab->pcellpos[i];

                if (cellprops->valid & P_WIDTH) {
                        cx = cellprops->width;
                } else if (hdrprops->valid & P_WIDTH) {
                        cx = hdrprops->width;
                } else {
                        cx = ptab->pcolhdr[i].nchars + 1;
                        cx *= ptab->avewidth;
                }
                /* add 2 for intercol spacing */
                cx += 2;

                xpos->size = cx;
                xpos->start = curx + 1;
                xpos->clipstart = xpos->start;
                xpos->clipend = xpos->start + xpos->size - 2;
                xpos->clipend = min(xpos->clipend, rcinner.right);

                cxtotal += xpos->size;
                curx += xpos->size;
        }
        ptab->rowwidth = cxtotal;

        if(pcontext->head != NULL) {
                xpos = &pcontext->head->xpos;
                ypos = &pcontext->head->ypos;

                xpos->start = rcouter.left + 1;
                xpos->clipstart = rcouter.left + 1;
                xpos->clipend = rcouter.right - 1;
                xpos->size = rcouter.right - rcouter.left;

                ypos->start = rcouter.top;
                ypos->clipstart = rcouter.top;
                ypos->clipend = rcinner.top;
                ypos->size = ptab->rowheight;
        }

        if (pcontext->foot != NULL) {
                xpos = &pcontext->foot->xpos;
                ypos = &pcontext->foot->ypos;

                xpos->start = rcouter.left + 1;
                xpos->clipstart = rcouter.left + 1;
                xpos->clipend = rcouter.right - 1;
                xpos->size = rcouter.right - rcouter.left;

                ypos->start = rcouter.bottom - ptab->rowheight;
                ypos->clipstart = rcinner.bottom;
                ypos->clipend = rcouter.bottom;
                ypos->size = ptab->rowheight;
        }

        /* set nr of lines per page */
        ptab->nlines = (rcinner.bottom - rcinner.top) / ptab->rowheight;
        if (!gtab_alloclinedata(hwnd, heap, ptab)) {
                return(FALSE);
        }
        /* set line positions */
        cury = rcinner.top;
        for (i = 0; i < ptab->nlines; i++) {
                ypos = &ptab->pdata[i].linepos;
                ypos->start = cury;
                ypos->clipstart = ypos->start;
                ypos->clipend = ypos->start + ypos->size;
                ypos->clipend = min(ypos->clipend, rcinner.bottom);
                cury += ypos->size;
        }
        return(TRUE);
}


/* static information for this module */
BOOL bAbort;
FARPROC lpAbortProc;
DLGPROC lpAbortDlg;
HWND hAbortWnd;
int npage;
int pages;

/***************************************************************************
 * Function: gtab_printjob
 *
 * Purpose:
 *
 * Sets up print job and dialogs
 */ 
void
gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext)
{
        int moveables;
        int endpage;
        int startpage = 1;
        HDC hpr;
        int status;
        HANDLE hcurs;
        static char str[256];
        DOCINFO di;

        hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

        moveables = ptab->nlines - ptab->hdr.fixedrows;
        pages = (int) (ptab->hdr.nrows - ptab->hdr.fixedrows + moveables - 1)
                        / moveables;
        endpage = pages;

        if (pcontext->pd->Flags & PD_PAGENUMS) {
                startpage = pcontext->pd->nFromPage;
                endpage = pcontext->pd->nToPage;
        }
        hpr = pcontext->pd->hDC;

        lpAbortDlg = (DLGPROC) MakeProcInstance((WNDPROC) AbortDlg, hLibInst);
        lpAbortProc = (FARPROC) MakeProcInstance((WNDPROC)AbortProc, hLibInst);

        SetAbortProc(hpr, (ABORTPROC) lpAbortProc);

        di.lpszDocName = "Table";
        di.cbSize = lstrlen(di.lpszDocName);
        di.lpszOutput = NULL;

        StartDoc(hpr, &di);

        bAbort = FALSE;

        /* add abort modeless dialog later!! */
        hAbortWnd = CreateDialog(hLibInst, "GABRTDLG", hwnd, lpAbortDlg);
        if (hAbortWnd != NULL) {
                ShowWindow(hAbortWnd, SW_NORMAL);
                EnableWindow(hwnd, FALSE);
        }
        SetCursor(hcurs);


        for (npage = startpage; npage<=endpage; npage++) {
                wsprintf(str, "Page %d of %d pages",  npage, pages);
                SetDlgItemText(hAbortWnd, IDC_LPAGENR, str);
                status = gtab_printpage(hwnd, ptab, pcontext, npage);
                if (status < 0) {
                        AbortDoc(hpr);
                        break;
                }
        }
        if (status >= 0) {
                EndDoc(hpr);
        }
        
        if (hAbortWnd != NULL) {
                EnableWindow(hwnd, TRUE);
                DestroyWindow(hAbortWnd);
        }
        FreeProcInstance((WNDPROC) lpAbortDlg);
        FreeProcInstance(lpAbortProc);

        DeleteDC(hpr);
}

/***************************************************************************
 * Function: AbortProc
 *
 * Purpose:
 *
 * Abort procedure for print job
 */
int APIENTRY
AbortProc(HDC hpr, int code)
{

        MSG msg;

        if (!hAbortWnd) {
                return(TRUE);
        }
        while (!bAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                if (!IsDialogMessage(hAbortWnd, &msg)) {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                }
        }
        return(!bAbort);
}

/***************************************************************************
 * Function: AbortDlg
 *
 * Purpose:
 *
 * Dialog for abort procedure
 */
int APIENTRY
AbortDlg(HWND hdlg, UINT msg, UINT wParam, LONG lParam)
{
        switch(msg) {

        case WM_COMMAND:
                bAbort = TRUE;
                EndDialog(hdlg, TRUE);
                return TRUE;

        case WM_INITDIALOG:
                return TRUE;
        }
        return(FALSE);
}

/***************************************************************************
 * Function: gtab_printpage
 *
 * Purpose:
 *
 * Print a single page. page number is 1-based
 */
BOOL
gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page)
{
        HDC hpr;
        int moveables, i;
        int x1, y1, x2, y2;

        hpr = pcontext->pd->hDC;
        StartPage(hpr);

        moveables = ptab->nlines - ptab->hdr.fixedrows;
        ptab->toprow = moveables * (page-1);
        gtab_invallines(hwnd, ptab, ptab->hdr.fixedrows, moveables);

        for (i =0; i < ptab->nlines; i++) {
                gtab_paint(hwnd, hpr, ptab, i);
        }
        if ((ptab->hdr.vseparator) && (ptab->hdr.fixedcols > 0)) {
                x1 = ptab->pcellpos[ptab->hdr.fixedcols -1].clipend+1;
                y1 = ptab->pdata[0].linepos.clipstart;
                y2 = ptab->pdata[ptab->nlines-1].linepos.clipend;
                MoveToEx(hpr, x1, y1, NULL);
                LineTo(hpr, x1, y2);
        }
        if ((ptab->hdr.hseparator) && (ptab->hdr.fixedrows > 0)) {
                y1 = ptab->pdata[ptab->hdr.fixedrows-1].linepos.clipend;
                x1 = ptab->pcellpos[0].clipstart;
                x2 = ptab->pcellpos[ptab->hdr.ncols-1].clipend;
                MoveToEx(hpr, x1, y1, NULL);
                LineTo(hpr, x2, y1);
        }

        if (pcontext->head != NULL) {
                gtab_printhead(hwnd, hpr, ptab, pcontext->head, page);
        }
        if (pcontext->foot != NULL) {
                gtab_printhead(hwnd, hpr, ptab, pcontext->foot, page);
        }

        return(EndPage(hpr));
}


/***************************************************************************
 * Function: gtab_setrects
 *
 * Purpose:
 *
 * Calculate the outline positions in pixels for the headers
 * (outer rect) and for the page itself (inner rect). Based on
 * page size and PrintContext margin info (which is in millimetres).
 */
void
gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter)
{
        HDC hpr;
        int hpixels, hmms;
        int vpixels, vmms;
        int h_pixpermm, v_pixpermm;

        hpr = pcontext->pd->hDC;
        hpixels = GetDeviceCaps(hpr, HORZRES);
        vpixels = GetDeviceCaps(hpr, VERTRES);
        vmms = GetDeviceCaps(hpr, VERTSIZE);
        hmms = GetDeviceCaps(hpr, HORZSIZE);

        h_pixpermm = hpixels / hmms;
        v_pixpermm = vpixels / vmms;

        rcouter->top = (pcontext->margin->top * v_pixpermm);
        rcouter->bottom = vpixels - (pcontext->margin->bottom * v_pixpermm);
        rcouter->left = (pcontext->margin->left * h_pixpermm);
        rcouter->right = hpixels - (pcontext->margin->right * h_pixpermm);

        rcinner->left = rcouter->left;
        rcinner->right = rcouter->right;
        rcinner->top = rcouter->top +
                (pcontext->margin->topinner * v_pixpermm);
        rcinner->bottom = rcouter->bottom -
                (pcontext->margin->bottominner * v_pixpermm);
}


/***************************************************************************
 * Function: gtab_printhead
 *
 * Purpose:
 *
 * Print header information
 */
void
gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page)
{
        RECT rc, rcbox;
        int i, cx, x, y, tab;
        UINT align;
        LPSTR chp, tabp;
        DWORD fcol, bkcol;
        char str[256];

        rc.top = head->ypos.clipstart;
        rc.bottom = head->ypos.clipend;
        rc.left = head->xpos.clipstart;
        rc.right = head->xpos.clipend;

        /* update page number */
        chp = str;
        for (i = 0; i < lstrlen(head->ptext); i++) {
                switch(head->ptext[i]) {

                case '#':
                        chp += wsprintf(chp, "%d", page);
                        break;
                
                case '$':
                        chp += wsprintf(chp, "%d", pages);
                        break;
                
                default:
                        *chp++ = head->ptext[i];
                        break;
                }
        }
        *chp = '\0';
        chp = str;

        if (head->props.valid & P_ALIGN) {
                align = head->props.alignment;
        } else {
                align = P_LEFT;
        }

        /* set colours if not default */
        if (head->props.valid & P_FCOLOUR) {
                fcol = SetTextColor(hdc, head->props.forecolour);
        }
        if (head->props.valid & P_BCOLOUR) {
                bkcol = SetBkColor(hdc, head->props.backcolour);
        }

        /* calc offset of text within cell for right-align or centering */
        if (align == P_LEFT) {
                cx = ptab->avewidth/2;
        } else {
                cx = LOWORD(GetTextExtent(hdc, chp, lstrlen(chp)));
                if (align == P_CENTRE) {
                        cx = (head->xpos.size - cx) / 2;
                } else {
                        cx = head->xpos.size - cx - (ptab->avewidth/2);
                }
        }
        cx += head->xpos.start;

        /* expand tabs on output */
        tab = ptab->avewidth * 8;
        x = 0;
        y = head->ypos.start;

        for ( ; (tabp = strchr(chp, '\t')) != NULL; ) {
                /* perform output upto tab char */
                ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, tabp-chp, NULL);
                
                /* advance past the tab */
                x += LOWORD(GetTextExtent(hdc, chp, tabp - chp));
                x = ( (x + tab) / tab) * tab;
                chp = ++tabp;
        }

        /*no more tabs - output rest of string */
        ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, lstrlen(chp), NULL);

        /* reset colours to original if not default */
        if (head->props.valid & P_FCOLOUR) {
                SetTextColor(hdc, fcol);
        }
        if (head->props.valid & P_BCOLOUR) {
                SetBkColor(hdc, bkcol);
        }

        /* now box cell if marked */
        if (head->props.valid & P_BOX) {
                if (head->props.box != 0) {
                        rcbox.top = head->ypos.start;
                        rcbox.bottom = rcbox.top + head->ypos.size;
                        rcbox.left = head->xpos.start;
                        rcbox.right = rcbox.left + head->xpos.size;
                        gtab_boxcell(hwnd, hdc, &rcbox, &rc, head->props.box);
                }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\tree.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: TREE.C
*
* Functions supporting an unbalanced binary tree.
*
* Functions:
*
* tree_delitem()
* tree_newitem()
* tree_getitem()
* tree_create()
* tree_delete()
* tree_update()
* tree_find()
* tree_search()
* tree_addafter()
* ctree_create()
* ctree_delete()
* ctree_update()
* ctree_getcount()
* ctree_find()
*
* Comments:
*
* TREE is a data type providing a map between a KEY and a VALUE. The KEY is a
* 32-bit DWORD, and the VALUE is any arbitrary area of storage.
*
* Mmemory is allocated from gmem_get, using hHeap as the heap handle.
* hHeap must be declared and initialised elsewhere.
*
* Currently implemented as a unbalanced binary tree.
*
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <memory.h>

#include "gutils.h"
#include "tree.h"


/* -- data types ----------------------------------------------- */

/* on creating a tree, we return a TREE handle. This is in fact a pointer
 * to a struct tree, defined here.
 */
struct tree {
        HANDLE hHeap;
        TREEITEM first;
};

/* each element in the tree is stored in a TREEITEM. a TREEITEM handle
 * is a pointer to a struct treeitem, defined here
 */
struct treeitem {
        TREE root;

        TREEKEY key;

        TREEITEM left, right;

        UINT length;            /* length of the user's data */

        LPVOID data;            /* pointer to our copy of the users data */

};

/***************************************************************************
 * Function: tree_delitems
 *
 * Purpose:
 *
 * Free up an element of the tree. Recursively calls itself to
 * free left and right children
 */
void
tree_delitem(TREEITEM item)
{
        if (item == NULL) {
                return;
        }
        if (item->left != NULL) {
                tree_delitem(item->left);
        }
        if (item->right != NULL) {
                tree_delitem(item->right);
        }
        if (item->data != NULL) {
                gmem_free(item->root->hHeap, item->data, item->length);
        }

        gmem_free(item->root->hHeap, (LPSTR) item, sizeof(struct treeitem));
}

/***************************************************************************
 * Function: tree_newitem
 *
 * Purpose:
 *
 * Creates a new treeitem, with a data block of length bytes.
 * If the value pointer is not NULL, initialise the data block with
 * the contents of value.
 */
TREEITEM
tree_newitem(TREE root, TREEKEY key, LPVOID value, UINT length)
{
        TREEITEM item;

        item = (TREEITEM) gmem_get(root->hHeap, sizeof(struct treeitem));

        item->root = root;
        item->key = key;
        item->left = NULL;
        item->right = NULL;
        item->length = length;
        item->data = gmem_get(root->hHeap, length);
        if (value != NULL) {
                memcpy(item->data, value, length);
        }

        return(item);
}


/***************************************************************************
 * Function: tree_getitem
 *
 * Purpose:
 *
 * Finds the item with the given key. If it does not exist, return
 * the parent item to which it would be attached. Returns NULL if
 * no items in the tree
 */
TREEITEM
tree_getitem(TREE tree, TREEKEY key)
{
        TREEITEM item, prev;


        prev = NULL;
        for (item = tree->first; item != NULL; ) {
                
                if (item->key == key) {
                        return(item);
                }

                /* not this item - go on to the correct child item.
                 * remember this item as if the child is NULL, this item
                 * will be the correct insertion point for the new item
                 */
                prev = item;

                if (key < item->key) {
                        item = item->left;
                } else {
                        item = item->right;
                }
        }       
        /* prev is the parent - or null if nothing in tree */
        return(prev);
}

/***************************************************************************
 * Function: tree_create
 *
 * Purpose:
 *
 * Creates an empty tree. hHeap is the handle to use for all
 * memory allocations for this tree.
 */
TREE APIENTRY
tree_create(HANDLE hHeap)
{
        TREE tree;

        tree = (TREE) gmem_get(hHeap, sizeof(struct tree));
        tree->first = NULL;
        tree->hHeap = hHeap;
        return(tree);
}


/***************************************************************************
 * Function: tree_delete
 *
 * Purpose:
 *
 * Deletes an entire tree, including all the user data
 */
void APIENTRY
tree_delete(TREE tree)
{

        tree_delitem(tree->first);

        gmem_free(tree->hHeap, (LPSTR) tree, sizeof(struct tree));
}

/***************************************************************************
 * Function: tree_update
 *
 * Purpose:
 *
 * Adds a new element to the tree, mapping the key given to the value given.
 * The value is a block of storage: a copy of this is inserted into the tree.
 * We return a pointer to the copy of the data in the tree.
 *
 * The value pointer can be NULL: in this case, we insert a block of
 * length bytes, but don't initialise it. You get a pointer to it and
 * can initialise it yourself.
 *
 * If the key already exists, the value will be replaced with the new data.
 */
LPVOID APIENTRY
tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length)
{
        TREEITEM item;

        /* find the place in the tree for this key to go */
        item = tree_getitem(tree, key);

        if (item == NULL) {
                /* there is nothing in the tree: this item should
                 * go at the top
                 */
                tree->first = tree_newitem(tree, key, value, length);
                return(tree->first->data);
        }

        /* is this the same key ? */
        if (item->key == key) {

                /* this key already inserted. re-alloc the data */
                if (length != item->length) {
                        gmem_free(tree->hHeap, item->data, item->length);
                        item->data = gmem_get(tree->hHeap, length);
                }
                /* don't initialise block if no pointer passed */
                if (value != NULL) {
                        memcpy(item->data, value, length);
                }
                return(item->data);
        }

        /* not the same key - getitem returned the parent for
         * the new tree. insert it as a child of item.
         */
        return(tree_addafter(tree, &item, key, value, length));
}

/***************************************************************************
 * Function: tree_find
 *
 * Purpose:
 *
 * Returns a pointer to the value (data block) for a given key. Returns
 * null if not found.
 */
LPVOID APIENTRY
tree_find(TREE tree, TREEKEY key)
{
        TREEITEM item;

        /* find the correct place in the tree */
        item = tree_getitem(tree, key);

        if (item == NULL) {
                /* nothing in the tree */
                return(NULL);
        }

        if (item->key != key) {
                /* this key not in. getitem has returned parent */
                return(NULL);
        }

        /* found the right element - return pointer to the
         * data block
         */
        return(item->data);
}

/* The next two routines are an optimisation for a common tree operation. In
 * this case, the user will want to insert a new element only if
 * the key is not there. If it is there, he will want to modify the
 * existing value (increment a reference count, for example).
 *
 * If tree_search fails to find the key, it will return a TREEITEM handle
 * for the parent. This can be passed to tree_addafter to insert the
 * new element without re-searching the tree.
 */

/***************************************************************************
 * Function: tree_search
 *
 * Purpose:
 *
 * Find an element. If not, find it's correct parent item
 */
LPVOID APIENTRY
tree_search(TREE tree, TREEKEY key, PTREEITEM pplace)
{
        TREEITEM item;

        item = tree_getitem(tree, key);

        if (item == NULL) {
                /* no items in tree. set placeholder to NULL to
                 * indicate insert at top of tree
                 */
                *pplace = NULL;         

                /* return NULL to indicate key not found */
                return(NULL);
        }

        if (item->key == key) {
                /* found the key already there -
                 * set pplace to null just for safety
                 */
                *pplace = NULL;

                /* give the user a pointer to his data */
                return(item->data);
        }


        /* key was not found - getitem has returned the parent
         * - set this as the place for new insertions
         */
        *pplace = item;         

        /* return NULL to indicate that the key was not found */
        return(NULL);
}

/***************************************************************************
 * Function: tree_addafter
 *
 * Purpose:
 *
 * Insert a key in the position already found by tree_search.
 *
 * Return a pointer to the user's data in the tree. If the value
 * pointer passed in is null, then we allocate the block, but don't
 * initialise it to anything.
 */
LPVOID APIENTRY
tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value, UINT length)
{
        TREEITEM item, child;

        item = *place;
        if (item == NULL) {
                tree->first = tree_newitem(tree, key, value, length);
                return (tree->first->data);
        }               

        child = tree_newitem(tree, key, value, length);         
        if (child->key < item->key ) {
                /* should go on left leg */
                item->left = child;
        } else {        
                item->right = child;
        }
        return(child->data);
}


/* --- ctree ------------------------------------------------------*/

/*
 * ctree is a class of tree built on top of the tree interface. a
 * ctree keeps count of the number of insertions of identical keys.
 *
 * We do this be adding a long counter to the beginning of the user
 * data before inserting into the tree. If the key is not found, we set
 * this to one. If the key was already there, we *do not* insert the
 * data (data is always from the first insertion) - we simply increment
 * the count.
 */

/* Create a tree for use by CTREE - same as an ordinary tree
 */
TREE APIENTRY
ctree_create(HANDLE hHeap)
{
        return(tree_create(hHeap));
}

/*
 * Delete a ctree - same as for TREE
 */
void APIENTRY
ctree_delete(TREE tree)
{
        tree_delete(tree);
}


/***************************************************************************
 * Function: ctree_update
 *
 * Purpose:
 *
 * Insert an element in the tree. If the element is not there,
 * insert the data and set the reference count for this key to 1.
 * If the key was there already, don't change the data, just increment
 * the reference count
 *
 * If the value pointer is not null, we initialise the value block
 * in the tree to contain this.
 *
 * We return a pointer to the users data in the tree
 */
LPVOID APIENTRY
ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length)
{
        TREEITEM item;
        long FAR * pcounter;
        LPVOID datacopy;

        pcounter = tree_search(tree, key, &item);

        if (pcounter == NULL) {
                /* element not found - insert a new one
                 * the data block for this element should be
                 * the user's block with our reference count at
                 * the beginning
                 */
                pcounter = tree_addafter(tree, &item, key, NULL,
                                length + sizeof(long));
                *pcounter = 1;
                /* add on size of one long to get the start of the user
                 * data
                 */
                datacopy = pcounter + 1;
                if (value != NULL) {
                        memcpy(datacopy, value, length);
                }
                return(datacopy);
        }

        /* key was already there - increment reference count and
         * return pointer to data
         */

        (*pcounter)++;

        /* add on size of one long to get the start of the user
         * data
         */
        datacopy = pcounter + 1;
        return(datacopy);
}

/***************************************************************************
 * Function: ctree_getcount
 *
 * Purpose:
 *
 * Return the reference count for this key 
 */
long APIENTRY
ctree_getcount(TREE tree, TREEKEY key)
{
        long FAR * pcounter;

        pcounter = tree_find(tree, key);
        if (pcounter == NULL) {
                return(0);
        }
        return(*pcounter);
}

/***************************************************************************
 * Function: ctree_find
 *
 * Purpose:
 *
 * Return a pointer to the user's data block for this key,
 * or NULL if key not present
 */
LPVOID APIENTRY
ctree_find(TREE tree, TREEKEY key)
{
        long FAR * pcounter;


        pcounter = tree_find(tree, key);
        if (pcounter == NULL) {
                return(0);
        }

        /* increment pointer by size of 1 long to point to
         * user's datablock
         */
        return(pcounter+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\view.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * VIEW.H
 */

/* view.h includes the term COMPLIST: complist.h uses the term VIEW.
 */
#ifndef INC_VIEW_COMPLIST
#define INC_VIEW_COMPLIST
typedef struct view FAR * VIEW;                 /* handle to a VIEW     */
typedef struct complist FAR * COMPLIST;         /* handle to a complist */
#endif // INC_VIEW_COMPLIST

VIEW view_new(HWND hwndTable);
BOOL view_setcomplist(VIEW view, COMPLIST cl);
COMPLIST view_getcomplist(VIEW view);
void view_close(VIEW view);
void view_delete(VIEW view);
LPSTR view_gettext(VIEW view, long row, int col);
int view_getlinenr_left(VIEW view, long row);
int view_getlinenr_right(VIEW view, long row);
int view_getwidth(VIEW view, int col);
long view_getrowcount(VIEW view);
int view_getstate(VIEW view, long row);
BOOL view_expand(VIEW view, long row);
void view_outline(VIEW);
COMPITEM view_getitem(VIEW view, long row);
BOOL view_isexpanded(VIEW view);        
LPSTR view_getcurrenttag(VIEW view);
BOOL view_newitem(VIEW view);
void view_changeviewoptions(VIEW view);
void view_changediffoptions(VIEW view);
long view_findchange(VIEW view, long startrow, BOOL bForward);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\wdiffrc.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

#define IDM_FILE      111
#define IDM_DIR       112
#define IDM_PRINT     113
#define IDM_EXIT      115
#define IDM_TIME      116
#define IDM_OPEN      121
#define IDM_SAVELIST  122
#define IDM_EDITLEFT  123
#define IDM_EDITRIGHT 124
#define IDM_EDITCOMP  125
#define IDM_SETEDIT   126
#define IDM_COPYFILES 127

#define IDM_ABOUT     131

#define IDD_ICON      132
#define IDD_VERSION   133
#define IDD_LABEL     136
#define IDD_DIR1      137
#define IDD_DIR2      138
#define IDD_LAB1      139
#define IDD_LAB2      140
#define IDD_LAB3      141
#define IDD_RECURSIVE 143

#define IDM_CLOSE     161

#define IDM_OUTLINE   180
#define IDM_EXPAND    181
#define IDM_FCHANGE   182
#define IDM_LNRS      185
#define IDM_RNRS      186
#define IDM_NONRS     187
#define IDM_LONLY     188
#define IDM_RONLY     189
#define IDM_BOTHFILES 190
#define IDM_UPDATE    194
#define IDM_FPCHANGE  195
#define IDM_IGNBLANKS 196
#define IDM_PICTURE   197
#define IDM_LAZY      198
#define IDM_INCSAME   201
#define IDM_INCLEFT   202
#define IDM_INCRIGHT  203
#define IDM_INCDIFFER 204

#define IDC_RCDISP1   501
#define IDC_BAR       510
#define IDC_STATUS    550
#define IDM_ABORT     551
#define IDL_STATLAB   552
#define IDL_NAMES     553

#define IDD_FILE                    601
#define IDD_IDENTICAL               602
#define IDD_DIFFER                  603
#define IDD_LEFT                    604
#define IDD_RIGHT                   605

#define IDD_FROMGROUP               610
#define IDD_FROMLEFT                611
#define IDD_FROMRIGHT               612
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\windiff.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*
 * WINDIFF.H
 */

/* application-wide variables -------------------------------------*/

/* This is the section name in the win.ini file to which we
 * write profile info
 */
#define APPNAME "WinDiff"

/* A gmem_init() heap shared by the app. call gmem_get to alloc. */
extern HANDLE hHeap;

/* The instance handle for this app. Needed by anyone who uses resources
 * such as dialogs
 */
extern HINSTANCE hInst;

extern HWND hwndClient;
extern HWND hwndRCD;

/* global option flags-------------------------------------------  */

/* Which files do we show in outline mode ? all, changed... */
extern int outline_include;

/* Outline_include is an OR of the following */
#define INCLUDE_SAME            1
#define INCLUDE_DIFFER          2
#define INCLUDE_LEFTONLY        4
#define INCLUDE_RIGHTONLY       8


/* Do we ignore blanks during the line-by-line diff ? */
extern BOOL ignore_blanks;

/* Which line numbers do we show - left original, right original or none ?*/
extern int line_numbers;

/* What lines do we show in expand mode - all, left only, right only ? */
extern int expand_mode;

/*--- colour scheme ----------------------------------------------  */

/* Outline */
extern DWORD rgb_outlinehi;

/* Expand view */
extern DWORD rgb_leftfore;
extern DWORD rgb_leftback;
extern DWORD rgb_rightfore;
extern DWORD rgb_rightback;
extern DWORD rgb_mleftfore;
extern DWORD rgb_mleftback;
extern DWORD rgb_mrightfore;
extern DWORD rgb_mrightback;

/* Bar window */
extern DWORD rgb_barleft;
extern DWORD rgb_barright;
extern DWORD rgb_barcurrent;



/* -- display layout constants---------------------------------------*/

/* Percentage of width of window taken by bar display (when visible) */
#define BAR_WIN_WIDTH   10

/* Following are horizontal positions within the bar window, expressed
 * in percent of the width of the bar window
 */
#define L_POS_START     10      /* start of left position marker */
#define L_POS_WIDTH     5       /* width of left position marker */
#define R_POS_START     80      /* start of right position marker */
#define R_POS_WIDTH     5       /* width of right position marker */

#define L_UNMATCH_START 30      /* start of left bar for unmatched section */
#define L_UNMATCH_WIDTH 10      /* width of above */
#define R_UNMATCH_START 60      /* start of right bar for unmatch section */
#define R_UNMATCH_WIDTH 10      /* width of right unmatched section marker */
#define L_MATCH_START   30      /* start of left bar for matched section */
#define L_MATCH_WIDTH   10      /* width of left bar for matched section */
#define R_MATCH_START   60      /* start of right bar for matched section */
#define R_MATCH_WIDTH   10      /* width of right bar for matched section */




/* windiff.c functions */
void windiff_UI(BOOL bAttach);
BOOL Poll(void);                /* true if abort pending */
void SetNames(LPSTR names);
void SetStatus(LPSTR state);

/* in bar.c */
BOOL InitBarClass(HINSTANCE hInstance);
void BarDrawPosition(HWND hwndBar, HDC hdcIn, BOOL bErase);

/*-- private messages -- */
/* Send this to the main window. Return value is the VIEW handle */
#define TM_CURRENTVIEW  WM_USER


/* --- synchronisation ----------------------------------------- */
/*
 * In WIN32 we spawn worker threads to do time-consuming actions.
 * This causes a possible conflict with the UI thread when accessing the
 * BUSY flag.
 *
 * To protect against this we have a critical section. The UI thread
 * will get this before checking/changing the Busy flag,
 * The worker thread will get this before Busy flag* changes.
 *
 */

CRITICAL_SECTION CSWindiff;

#define WDEnter()       EnterCriticalSection(&CSWindiff);
#define WDLeave()       LeaveCriticalSection(&CSWindiff);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\view.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: VIEW.C
*
* Maps rows in window to items in COMPLIST
*
* Functions:
*
* view_new()
* view_setcomplist()
* view_getcomplist()
* view_close()
* view_delete()
* view_outline()
* view_expand()
* view_gettext()
* view_getlinenr_left()
* view_getlinenr_right()
* view_getwidth()
* view_getrowcount()
* view_getstate()
* view_getitem()
* view_isexpanded()
* view_getcurrenttag()
* view_newitem()
* view_changeviewoptions()
* view_changediffoptions()
* view_findchange()
* view_outline_opt()
* view_freemappings()
* view_findrow()
* view_expand_item()
*
* Comments:
*
* A view owns a COMPLIST, and talks to a table window. The table window
* shows 3 columns: line nr, tag and text. We also need to supply a state
* for each row (used to select colour scheme).
*
* The COMPLIST can give us a list of its COMPITEMs. Each of these can give
* us a tag (eg the filenames compared) and the text (usually the compare
* result), and the state. We make the line number from the
* COMPITEM's place in the list.
*
* If we are asked to switch to 'expand' mode, we ask the selected COMPITEM
* for its composite section list. We can then get the state (and thus
* the tag) from each SECTION, and the line nr and text from the LINEs within
* each section.
*
* When moving between expand and outline, and when refreshing the view
* for some option change, we have to be careful to keep the current row
* and the selected row in the table what the user would expect.
*
* Functions in this module can be called from the UI thread (to refresh
* the display) and simultaneously from a worker thread to update the
* view mapping (view_setcomplist, view_newitem). We use a critical section
* to manage the synchronisation. We need to protect all access/modification
* to the view structure elements (particularly bExpand, rows, pLines and
* pItems), BUT we must not hold the critical section over any calls
* to SendMessage.
*
* We use the global options in windiff.h, and we allocate memory from the
* heap hHeap which has been initialised elsewhere. Points in time-intensive
* loops call Poll() defined elsewhere.
*
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <commdlg.h>

#include "gutils.h"
#include "table.h"
#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"
#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "view.h"

/*
 * data structures
 */

/* in expand mode, we keep an array of one of these per screen line. */
typedef struct viewline {
        LINE line;              /* handle to LINE for this row */
        SECTION section;        /* handle to section containing this line */
        int nr_left;            /* line nr in left file */
        int nr_right;           /* line nr in right file */
} VIEWLINE, FAR * PVIEWLINE;


/*
 * The users VIEW handle is in fact a pointer to this structure
 */
struct view {

        HWND     hwnd;          /* the table window to send notifies to */

        COMPLIST cl;            /* the complist that we own */

   BOOL          bExpand;       /* true if we are in expand mode */

        COMPITEM ciSelect;      /* selected compitem (in expand mode) */

        int      rows;          /* number of rows in this view */

        char     nrtext[12];    /* we use this in view_gettext for the line
                                 * number column. overwritten on each call
                                 */
        int      maxtag, maxrest;/* column widths in characters for cols 1, 2 */

        /* if we are in outline mode, we map the row number to one entry
         * in this array of COMPITEM handles. this pointer will
         * be NULL in expand mode
         */
        COMPITEM FAR * pItems;

        /* in expand mode we use this array of line and section handles */
        PVIEWLINE pLines;
};


CRITICAL_SECTION CSView;
static BOOL bDoneInit = FALSE;

#define ViewEnter()     EnterCriticalSection(&CSView);
#define ViewLeave()     LeaveCriticalSection(&CSView);

void view_outline_opt(VIEW view, BOOL bRedraw);
void view_freemappings(VIEW view);
int view_findrow(VIEW view, int number, BOOL bRight);
BOOL view_expand_item(VIEW view, COMPITEM ci);


/***************************************************************************
 * Function: view_new
 *
 * Purpose:
 *
 * Create a new view. At this point, we are told the table window handle,
 * and nothing else.
 *
 */
VIEW
view_new(HWND hwndTable)
{
        VIEW view;

        if (!bDoneInit) {
                InitializeCriticalSection(&CSView);
                bDoneInit = TRUE;
        }

        /* alloc the view from the heap */
        view = (VIEW) gmem_get(hHeap, sizeof(struct view));

        /* set the default fields */
        view->hwnd = hwndTable;
        view->cl = NULL;
        view->bExpand = FALSE;
        view->ciSelect = NULL;
        view->rows = 0;
        view->pItems = NULL;
        view->pLines = NULL;

        return(view);
}


/***************************************************************************
 * Function: view_setcomplist
 *
 * Purpose:
 *
 * We have to separate view_new and view_setcomplist because we need
 * to give the view handle to the complist and the complist handle to the
 * view. So do a view_new to create a null view; then complist_new() to
 * which you pass a view handle. The complist will then register itself
 * with the view by calling this function. During the build of the complist,
 * it will also update us by calling view_additem, so that we can refresh
 * the display.
 *
 * Here we should initialise an outline view of the complist.
 *
 * We also talk to the status bar using SetNames to set the names of
 * the two items.
 */
BOOL
view_setcomplist(VIEW view, COMPLIST cl)
{
        LPSTR left, right, both;

        if (view == NULL) {
                return(FALSE);
        }

        /* there can be only one call to this per VIEW */
        if (view->cl != NULL) {
                return (FALSE);
        }

        ViewEnter();

        view->cl = cl;

        /* set names on status bar to root names of left and right trees */
        left = complist_getroot_left(cl);
        right = complist_getroot_right(cl);
        both = gmem_get(hHeap, lstrlen(left) + lstrlen(right) +4);
        wsprintf((LPTSTR)both, "%s : %s", left, right);
        ViewLeave();   
        SetNames(both);
        ViewEnter();   
        gmem_free(hHeap, both, lstrlen(both)+1);
        complist_freeroot_left(cl, left);
        complist_freeroot_right(cl, right);

        ViewLeave();

        view_outline(view);
}


/***************************************************************************
 * Function: view_getcomplist
 *
 * Purpose:
 *
 * Return a handle to the complist owned by this view
 */
COMPLIST
view_getcomplist(VIEW view)
{
        if (view == NULL) {
                return(NULL);
        }

        return(view->cl);
}


/***************************************************************************
 * Function: view_close
 *
 * Purpose:
 *
 * Close a view. Notify the table window that this view should be
 * closed. When the table window has finished with it, it will send
 * a TQ_CLOSE notify that should result in view_delete being called
 * and the memory being freed.
 */
void
view_close(VIEW view)
{
        if (view == NULL) {
                return;
        }

        SendMessage(view->hwnd, TM_NEWID, 0, 0);
}


/***************************************************************************
 * Function: view_delete
 *
 * Purpose:
 *
 * Delete a view and all associated data.
 *
 * This function should only be called in response to the table window
 * sending a TQ_CLOSE message. To close the view, call view_close and
 * wait for the TQ_CLOSE before calling this.
 *
 * We delete the associated COMPLIST and all its associated structures.
 */
void
view_delete(VIEW view)
{
        if (view == NULL) {
                return;
        }

        /* we have two arrays that are used for the mapping - an array
         * of compitem handles in outline mode, and an array of
         * VIEWLINE structures in expand mode
         */

        view_freemappings(view);

        complist_delete(view->cl);

        gmem_free(hHeap, (LPSTR) view, sizeof(struct view));
}


/***************************************************************************
 * Function: view_outline
 *
 * Purpose:
 *
 * Build an outline mode mapping where one row represents one COMPITEM in
 * the list. Check the global option flag outline_include to see which items
 * we should include.
 *
 * If we were in expand mode, then set as the selection the row in outline mode
 * that we were expanding. Also remember to free up the expand mode mapping
 * array
 *
 * Once we have built the new mapping, notify the table window to
 * redraw itself.
 */
void
view_outline(VIEW view)
{
        if (view == NULL) {
                return;
        }

        /* all work done by view_outline_opt - this function
         * gives us the option of not updating the display
         */
        view_outline_opt(view, TRUE);
}



/***************************************************************************
 * Function: view_expand
 *
 * Purpose:
 *
 * Switch to expand mode, expanding the given row into a view
 * of the differences in that file.
 *
 * Map the given row nr into a compitem handle, and then
 * call the internal function with that.
 */
BOOL    
view_expand(VIEW view, long row)
{
        COMPITEM ci;
        BOOL bRet;

        ViewEnter();

        if ((view == NULL) || (view->bExpand)) {
                /* no view, or already expanded */
                ViewLeave();
                return(FALSE);
        }

        if (row >= view->rows) {
                /* no such row */
                ViewLeave();
                return FALSE;
        }

        /* remember the compitem we are expanding */
        ci = view->pItems[row];

        bRet = view_expand_item(view, ci);
        // view_expand_item does the...
        // ViewLeave();
        return(bRet);
}


/***************************************************************************
 * Function: view_gettext
 *
 * Purpose:
 *
 * Return the text associated with a given column of a given row.
 * Return a pointer that does not need to be freed after use - ie
 * a pointer into our data somewhere, not a copy
 */
LPSTR
view_gettext(VIEW view, long row, int col)
{
        int line;
        int state;
        LPSTR pstr;


        if (view == NULL) {
                return (NULL);
        }

        ViewEnter();

        if (row >= view->rows) {
                ViewLeave();
                return(NULL);
        }

        if (view->bExpand) {
                /* we are in expand mode */
                
                state = section_getstate(view->pLines[row].section);

                switch(col) {
                case 0:
                        /* row nr */
                                                
                        /* line numbers can be from either original file
                         * this is a menu-selectable option
                         */
                        switch(line_numbers) {
                        case IDM_NONRS:
                                pstr = NULL;
                                break;

                        case IDM_LNRS:
                                line = view->pLines[row].nr_left;
                                if (state == STATE_MOVEDRIGHT) {
                                        line = -line;
                                }
                                break;

                        case IDM_RNRS:
                                line = view->pLines[row].nr_right;
                                if (state == STATE_MOVEDLEFT) {
                                        line = -line;
                                }
                                break;
                        }
                        if (line == 0) {
                                ViewLeave();
                                return(NULL);
                        }

                        if (line < 0) {
                                /* lines that are moved appear twice.
                                 * show the correct-sequence line nr
                                 * for the out-of-seq. copy in brackets.
                                 */
                                wsprintf((LPTSTR)view->nrtext, "(%d)", abs(line));
                        } else  {
                                wsprintf((LPTSTR)view->nrtext, "%d", line);
                        }
                        pstr = view->nrtext;
                        break;

                case 1:
                        /* tag text - represents the state of the line */


                        switch(state) {
                        case STATE_SAME:
                                pstr = "    ";
                                break;

                        case STATE_LEFTONLY:
                                pstr = " <! ";
                                break;

                        case STATE_RIGHTONLY:
                                pstr = " !> ";
                                break;

                        case STATE_MOVEDLEFT:
                                pstr = " <- ";
                                break;

                        case STATE_MOVEDRIGHT:
                                pstr = " -> ";
                                break;
                        }
                        break;

                case 2:
                        /* main text - line */
                        pstr = line_gettext(view->pLines[row].line);
                        break;
                }
        } else {
                /* outline mode */
                switch(col) {
                case 0:
                        /* row number - just the line number */
                        wsprintf((LPTSTR)view->nrtext, "%d", row+1);
                        pstr = view->nrtext;
                        break;

                case 1:
                        /* tag */
                        pstr = compitem_gettext_tag(view->pItems[row]);
                        break;

                case 2:
                        /* result text */
                        pstr = compitem_gettext_result(view->pItems[row]);
                        break;
                }
        }
        ViewLeave();
        return(pstr);
}

/***************************************************************************
 * Function: view_getlinenr_left
 *
 * Purpose:
 *
 * Return the line number that this row had in the original left
 * file. 0 if not in expand mode. 0 if this row was not in the left file.
 * -(linenr) if this row is a MOVED line, and this is the right file
 * copy
 */
int
view_getlinenr_left(VIEW view, long row)
{
        int state, line;

        if ((view == NULL) || (row >= view->rows) || !view->bExpand) {
                return 0;
        }

        ViewEnter();
        state = section_getstate(view->pLines[row].section);
        line = view->pLines[row].nr_left;
        if (state == STATE_MOVEDRIGHT) {
                line = -line;
        }
        ViewLeave();

        return(line);
}

/***************************************************************************
 * Function: view_getlinenr_right
 *
 * Purpose:
 *
 * Return the line number that this row had in the original right
 * file. 0 if not in expand mode. 0 if this row was not in the right file.
 * -(linenr) if this row is a MOVED line, and this is the left file
 * copy
 */
int
view_getlinenr_right(VIEW view, long row)
{
        int state, line;

        if ((view == NULL) || (row > view->rows) || !view->bExpand) {
                return 0;
        }

        ViewEnter();

        state = section_getstate(view->pLines[row].section);
        line = view->pLines[row].nr_right;
        if (state == STATE_MOVEDLEFT) {
                line = -line;
        }
        ViewLeave();

        return(line);
}


/***************************************************************************
 * Function: view_getwidth
 *
 * Purpose:
 *
 * Find the maximum width in characters for the given column 
 */
int
view_getwidth(VIEW view, int col)
{
        if (view == NULL) {
                return(0);
        }

        switch(col) {
        case 0:
                /* line nr column - always 5 characters wide */
                return(5);

        case 1:
                /* this is a proportional font field, so add on a margin
                 * for error
                 */
                return(view->maxtag + (view->maxtag / 20));
        case 2:
                /* this now includes the tab expansion allowance */
                return(view->maxrest);
        default:
                return(0);
        }
}

/***************************************************************************
 * Function: view_getrowcount
 *
 * Purpose:
 *
 * How many rows are there in this view ? 
 */
long
view_getrowcount(VIEW view)
{
        if (view == NULL) {
                return(0);
        }

        return(view->rows);
}

/***************************************************************************
 * Function: view_getstate
 *
 * Purpose:
 *
 * Return the state for the current row. This is used
 * to select the text colour for the row
 *
 * States for sections are obtained from section_getstate (and apply, and
 * to all lines in that section. States for compitems are obtained
 * from compitem_getstate.
 */
int
view_getstate(VIEW view, long row)
{
        int state;

        if (view == NULL) {
                return(0);
        }

        ViewEnter();
        if (row >= view->rows) {
                state = 0;
        } else if (view->bExpand) {
                /* its a line state that's needed */
                state = section_getstate(view->pLines[row].section);
        } else {

                /* its a compitem state */
                state = compitem_getstate(view->pItems[row]);
        }
        ViewLeave();
        return(state);
}

/***************************************************************************
 * Function: view_gethandle
 *
 * Purpose:
 *
 * Return a handle to the current compitem. In expand mode,
 * returns the handle to the compitem we are expanding. In outline
 * mode, returns the handle to the compitem for the given row, if valid,
 * or NULL otherwise. row is only used if not in expand mode.
 */
COMPITEM
view_getitem(VIEW view, long row)
{
        COMPITEM ci;

        if (view == NULL) {
                return(NULL);
        }

        ViewEnter();

        if (!view->bExpand) {
                if ((row >= 0) && (row < view->rows)) {
                        ci = view->pItems[row];
                } else {
                        ci = NULL;
                }
        } else {
                ci = view->ciSelect;
        }

        ViewLeave();
        return(ci);
}

/***************************************************************************
 * Function: view_isexpanded
 *
 * Purpose:
 *
 * Return TRUE if the current mapping is expanded mode
 */
BOOL
view_isexpanded(VIEW view)      
{
        if (view == NULL) {
                return(FALSE);
        }
        return(view->bExpand);
}


/***************************************************************************
 * Function: view_getcurrenttag
 *
 * Purpose:
 *
 * Return a text string describing the view. This is NULL in outline mode,
 * or the tag text for the current compitem in expanded mode
 */
LPSTR
view_getcurrenttag(VIEW view)
{
        LPSTR str;

        if ((view == NULL) || (!view->bExpand)) {
                return(NULL);
        } else {
                ViewEnter();

                str = compitem_gettext_tag(view->ciSelect);

                ViewLeave();
                return(str);

        }
}


/***************************************************************************
 * Function: view_newitem
 *
 * Purpose:
 *
 * Notify that CompItems have been added to the complist.
 *
 * Rebuild the view (if in outline mode), and refresh the table. Use
 * the table message TM_APPEND if possible (if column widths have not
 * change). If we have to do TM_NEWLAYOUT, then ensure we scroll
 * back to the right row afterwards.
 *
 * This causes a Poll() to take place. We return TRUE if an abort is
 * pending - in this case, the caller should abandon the scan loop.
 *
 * Enter the critical section for this function since this can be
 * called from the worker thread while the UI thread is using the
 * view that we are about to change.
 *
 * EXCEPT THAT WE DON'T DARE.  We cannot ever call SendMessage from the
 * worker thread within CSView.  If there is conflict, it will hang.
 */
BOOL
view_newitem(VIEW view)
{
        int maxtag, maxrest;
        long rownr;

        if ((view == NULL) || (view->bExpand)) {
                /* not in outline mode - nothing to do */
                return(Poll());
        }

        /* save some state about the present mapping */
        maxtag = view->maxtag;
        maxrest = view->maxrest;

        /* re-do the outline mapping, but don't tell the table
         * class.
         */
        view_outline_opt(view, FALSE);

        /* have the column widths changed ? */
        if ((maxtag < view->maxtag) || (maxrest < view->maxrest)) {
                /* yes - need complete redraw */

                /* find the row at the top of the window */
                rownr = SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);

                /* switch to new mapping */
                SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (DWORD) view);

                /* return to old row if possible - we know
                 * that row is still there since we have only added
                 * rows, and not changed any of the existing mapping
                 *
                 * Alas this is no longer true.  However the table class
                 * will defend itself against calls for a bogus top row.
                 */
                if (rownr >= 0) {
                        SendMessage(view->hwnd, TM_TOPROW, TRUE, rownr);
                }
        } else {
                /* no - we can just append */

                /*
                 * The mapping may have
                 * changed since we released the critsec. however we are still
                 * safe. The table will not allow us to reduce the number of
                 * rows, so the worst that can happen is that the table will
                 * think there are too many rows, and the table message handler
                 * will handle this correctly (return null for the text).
                 * The only visible effect is therefore that the scrollbar
                 * position is wrong.
                 */

                SendMessage(view->hwnd, TM_APPEND, view->rows, (DWORD) view);
        }


        /* Poll to keep the UI updated on NT. Returns true if abort pending.
         */
        return(Poll());
}

/***************************************************************************
 * Function: view_changeviewoptions
 *
 * Purpose:
 *
 * The view mapping options (eg outline_include, expand_mode) have changed -
 * re-do the mapping and then scroll back to the same position in the window
 * if possible.
 */
void
view_changeviewoptions(VIEW view)
{
        long row;
        int state, number;
        BOOL bRight;

        if (view == NULL) {
                return;
        }

        /* find what row we are currently on. Do this BEFORE we enter CSView */
        row = SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);

        ViewEnter();

        if (!view->bExpand) {

                /* outline mode. maintaining current position is
                 * unimportant
                 */
                view_outline(view);
                ViewLeave();
                return;
        }

        /* expanded mode */
        

        /* save the line number on one side (and remember which side) */
        if (row >= view->rows) {
                number = -1;
        } else {
                state = section_getstate(view->pLines[row].section);
                if ((state == STATE_MOVEDRIGHT) ||
                    (state == STATE_RIGHTONLY)) {
                            bRight = TRUE;
                            number = view->pLines[row].nr_right;
                } else {
                        bRight = FALSE;
                        number = view->pLines[row].nr_left;
                }
        }

        /* make the new mapping */
        view_expand_item(view, view->ciSelect);

        /* find the nearest row in the new view */
        if (number >= 0) {

                ViewEnter();
                row = view_findrow(view, number, bRight);
                ViewLeave();
        
                /* scroll this row to top of window */
                if (row >= 0) {

                        SendMessage(view->hwnd, TM_TOPROW, TRUE, row);
                        return;
                }
        }
}

/***************************************************************************
 * Function: view_changediffoptions
 *
 * Purpose:
 *
 * The compare options have changed - re-do the compare completely
 * and make the new mapping. Retain current position in the file.
 */
void
view_changediffoptions(VIEW view)
{
        int state, number;
        long row;
        BOOL bRight;
        LIST li;
        COMPITEM ci;

        if (view == NULL) {
                return;
        }

        /*
         * get current row before entering critsec.
         */
        row = SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);

        ViewEnter();

        /* find the current line number so we can go back to it
         * (only if we are in expanded mode
         */
        if (view->bExpand) {

                state = section_getstate(view->pLines[row].section);
                if ((state == STATE_MOVEDRIGHT) ||
                    (state == STATE_RIGHTONLY)) {
                            bRight = TRUE;
                            number = view->pLines[row].nr_right;
                } else {
                        bRight = FALSE;
                        number = view->pLines[row].nr_left;
                }
        }

        /* To force a recompare using the new options, we must
         * tell each compitem to discard its current compare result.
         * We need to traverse the list of compitems calling this
         * for each compare.
         */
        li = complist_getitems(view->cl);

        for (ci = (COMPITEM) List_First(li); ci != NULL; ci = (COMPITEM) List_Next(ci)) {
                compitem_discardsections(ci);
        }

        /* if we are in outline mode, we have nothing more to do */
        if (!view->bExpand) {
                ViewLeave();
                return;
        }

        view_expand_item(view, view->ciSelect);

        /* find the nearest row in the new view */
        ViewEnter();
        row = view_findrow(view, number, bRight);
        ViewLeave();

        /* scroll this row to top of window */
        if (row >= 0) {
                SendMessage(view->hwnd, TM_TOPROW, TRUE, row);
        }
}


/***************************************************************************
 * Function: view_findchange
 *
 * Purpose:
 *
 * Find the next changed - ie non-same - row in a given direction.
 * For outline mode we find the next STATE_DIFFER. For expand mode, we
 * find the next section
 */
long
view_findchange(VIEW view, long startrow, BOOL bForward)
{
        long i;

        if (view == NULL) {
                return(0);
        }

        ViewEnter();

        if (bForward) {

                if (startrow >= view->rows) {
                        ViewLeave();
                        return(-1);
                }

                if (!view->bExpand) {

                        /* look for next compitem with an expandable state*/
                        for (i = startrow; i < view->rows; i++) {
                                if (compitem_getstate(view->pItems[i]) == STATE_DIFFER) {
                                        ViewLeave();
                                        return(i);
                                }
                        }
                        /* none found */
                        ViewLeave();
                        return(-1);
                } else {
                        /*
                         * find the next line that matches, then go on to the
                         * next line that does not match
                         *
                         */
                        for (i= startrow; i < view->rows; i++) {
                                if (section_getstate(view->pLines[i].section)
                                        == STATE_SAME) {
                                                break;
                                }
                        }
                        for ( ; i < view->rows; i++) {
                                if (section_getstate(view->pLines[i].section)
                                        != STATE_SAME) {
                                                ViewLeave();
                                                return(i);
                                }
                        }

                        ViewLeave();

                        return(-1);
                }
        } else {
                /* same search backwards */
                if (startrow <= 0) {
                        ViewLeave();
                        return(-1);
                }
                if (view->bExpand) {
                        /* search backwards for first row that is not
                         * changed (has state SAME). then carry on for
                         * the next changed row.
                         */
                        for (i = startrow; i >= 0; i--) {
                                if (section_getstate(view->pLines[i].section)
                                        == STATE_SAME) {
                                                break;
                                }
                        }
                        for ( ; i >= 0; i--) {
                                if (section_getstate(view->pLines[i].section)
                                        != STATE_SAME) {
                                                ViewLeave();
                                                return(i);
                                }
                        }
                        ViewLeave();
                        return(-1);
                } else {
                        for (i = startrow; i >= 0; i--) {
                                if(compitem_getstate(view->pItems[i]) == STATE_DIFFER) {
                                        ViewLeave();
                                        return(i);
                                }
                        }
                        ViewLeave();
                        return(-1);
                }
        }
}



/***************************************************************************
 * Function: view_findrow
 *
 * Purpose:
 *
 * Find the new row number for the line numbered 'number'
 * or the nearest line if possible. If bRight is true, number is
 * a right file number; otherwise it is a left file number.
 *
 * We must be in expand mode
 */
int     
view_findrow(VIEW view, int number, BOOL bRight)
{
        int i;

        if (!view->bExpand) {   
                return(0);
        }

        for (i = 0; i < view->rows; i++) {

                if (bRight) {
                        if (view->pLines[i].nr_right == number) {

                                /* found the exact number */
                                return(i);

                        } else if (view->pLines[i].nr_right > number) {

                                /* passed our line -stop here */
                                return(i);
                        }
                } else {
                        if (view->pLines[i].nr_left == number) {

                                /* found the exact number */
                                return(i);

                        } else if (view->pLines[i].nr_left > number) {

                                /* passed our line -stop here */
                                return(i);
                        }
                }
        }
        return(-1);
}

/***************************************************************************
 * Function: view_freemappings
 *
 * Purpose:
 *
 * Free memory associated with the expand mode or outline mode mappings
 * called whenever we rebuild the mapping, and on deletion
 */
void
view_freemappings(VIEW view)
{

        if (view->pLines) {
                gmem_free(hHeap, (LPSTR) view->pLines,
                        view->rows * sizeof(VIEWLINE));
                view->pLines = NULL;
        } else if (view->pItems) {

                /* previous outline mapping array is still there - free it
                 * before we build a new one
                 */

                gmem_free(hHeap, (LPSTR) view->pItems,
                        view->rows * sizeof(COMPLIST));
                view->pItems = NULL;
        }
}

/***************************************************************************
 * Function: view_outline_opt
 *
 * Purpose:
 *
 * Build a view outline to map one row to a COMPITEM handle by traversing
 * the list of COMPITEMs obtained from our complist.
 * Optionally tell the table class to redraw (if bRedraw), and if so,
 * scroll the new table to select the row that represents the
 * file we were expanding, if possible
 */
void
view_outline_opt(VIEW view, BOOL bRedraw)
{
        int prev_row = -1;      /* the row nr of the previously-expanded row*/
        int i;                  /* nr of includable items */
        LIST li;
        COMPITEM ci;
        int state;
        TableSelection select;

        /*
         * check that view_setcomplist has already been called. if not,
         * nothing to do
         */
        if (view->cl == NULL) {
                return;
        }

        ViewEnter();

        /* clear the mode flag and free up memory associated with expand mode */
        view->bExpand = FALSE;
        view_freemappings(view);

        /* traverse the list of compitems counting up the number of
         * includable items
         */
        li = complist_getitems(view->cl);

        ci = (COMPITEM) List_First(li);
        for (i = 0; ci != NULL; ci = (COMPITEM) List_Next(ci)) {

                state = compitem_getstate(ci);

                if (((outline_include & INCLUDE_SAME) && (state == STATE_SAME)) ||
                    ((outline_include & INCLUDE_DIFFER) && (state == STATE_DIFFER)) ||
                    ((outline_include & INCLUDE_LEFTONLY) && (state == STATE_FILELEFTONLY)) ||
                    ((outline_include & INCLUDE_RIGHTONLY) && (state == STATE_FILERIGHTONLY))) {
                        i++;
                }
        }


        /* allocate an array big enough for all of these */
        view->pItems = (COMPITEM FAR *) gmem_get(hHeap, i * sizeof(COMPITEM));
        view->rows = i;

        /* keep track of the column widths */
        view->maxtag = 0;
        view->maxrest = 0;

        /* loop through again filling the array, and at the same time looking
         * out for the handle of the previously expanded item
         */
        ci = (COMPITEM) List_First(li);
        for (i = 0; ci != NULL; ci = (COMPITEM) List_Next(ci)) {

                state = compitem_getstate(ci);

                if (((outline_include & INCLUDE_SAME) && (state == STATE_SAME)) ||
                    ((outline_include & INCLUDE_DIFFER) && (state == STATE_DIFFER)) ||
                    ((outline_include & INCLUDE_LEFTONLY) && (state == STATE_FILELEFTONLY)) ||
                    ((outline_include & INCLUDE_RIGHTONLY) && (state == STATE_FILERIGHTONLY))) {

                        view->pItems[i] = ci;

                        if (ci == view->ciSelect) {
                                prev_row = i;
                        }

                        /* check the column widths in characters */
                        view->maxtag = max(view->maxtag,
                                           lstrlen(compitem_gettext_tag(ci)));
                        view->maxrest = max(view->maxrest,
                                            lstrlen(compitem_gettext_result(ci)));


                        i++;

                }
        }
        ViewLeave();

        /* inform table of new layout of table - force refresh */       
        if (bRedraw) {
                SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (DWORD) view);
        
                /* scroll to and highlight the row that represents the file
                 * we were previously expanding
                 */
                if (prev_row != -1) {
                        select.startrow = prev_row;
                        select.startcell = 0;
                        select.nrows = 1;
                        select.ncells = 1;
                        SendMessage(view->hwnd, TM_SELECT, 0,
                                (DWORD) (LPSTR) &select);
                }
        }
}


/***************************************************************************
 * Function: view_expand_item
 *
 * Purpose:
 *
 * Expand a view - given the handle to the compitem to expand.
 *
 * Called from view_expand, and also to re-do an expanded view
 * after options change in view_changediffoptions and _changeviewoptions
 *
 * We get the composite section list from the compitem,
 * and pick out all the sections that are includable (according
 * to the global option expand_mode: we include all sections, or
 * just those in one side left or right). Once we know the count of rows,
 * allocate the mapping array: in each element of the array we keep
 * a handle to the section for that row (to get the state and hence the
 * tag text), and a handle to the line within that section (for the line text).
 *
 * We no longer insist on only expanding text files that differ - if the
 * compitem can give us a composite section list, we will map it.
 *
 * We need to be able to give a line number for a line, in either of
 * the original files according to which option is in force. Each section
 * can give us its base line number (number of first line in section) in
 * each of the two files or 0 if not present, and we track these here.
 *
 * MUST BE INSIDE CSView BEFORE CALLING HERE.
 */
BOOL
view_expand_item(VIEW view, COMPITEM ci)
{
        LIST li;
        SECTION sh;
        LINE line1, line2;
        int i, base_left, base_right, state;

        /* remember the compitem we are expanding */
        view->ciSelect = ci;

        /* get the composite section list */
        li = compitem_getcomposite(view->ciSelect);
        if (li == NULL) {
                ViewLeave();
                return FALSE;
        }

        /* switch modes and free the current mapping
         *
         * NOTE: must do this AFTER the compitem_getcomposite,
         * since that can fail: if it fails it could put up a
         * message box, and that could cause a queued paint message
         * to be processed, which would cause us to use these mappings
         * and gpfault if they had been cleared first.
         */
        view->bExpand = TRUE;
        view_freemappings(view);


        /* loop through totalling the lines in sections
         * that we should include
         */
        view->rows = 0;
        for (sh = (SECTION) List_First(li); sh != NULL;
            sh = (SECTION) List_Next(sh)) {
                
                state = section_getstate(sh);
                
                if (expand_mode == IDM_RONLY) {
                        if ((state == STATE_LEFTONLY) ||
                            (state == STATE_MOVEDLEFT)) {
                                    continue;
                        }
                } else if (expand_mode == IDM_LONLY) {
                        if ((state == STATE_RIGHTONLY) ||
                            (state == STATE_MOVEDRIGHT)) {
                                    continue;
                        }
                }

                /* include all lines in this section */
                view->rows += section_getlinecount(sh);
        }
        
        /* allocate the memory for the mapping array */
        view->pLines = (PVIEWLINE) gmem_get(hHeap, view->rows * sizeof(VIEWLINE));
        
        /* loop through the sections again filling in the mapping array */
        i = 0;
        view->maxtag = 5;
        view->maxrest = 0;
        for (sh = (SECTION) List_First(li); sh != NULL;
            sh = (SECTION) List_Next(sh)) {
                
                state = section_getstate(sh);
                
                if (expand_mode == IDM_RONLY) {
                        if ((state == STATE_LEFTONLY) ||
                            (state == STATE_MOVEDLEFT)) {
                                    continue;
                        }
                } else if (expand_mode == IDM_LONLY) {
                        if ((state == STATE_RIGHTONLY) ||
                            (state == STATE_MOVEDRIGHT)) {
                                    continue;
                        }
                }

                /* find the base line number in each file */
                base_left = section_getleftbasenr(sh);
                base_right = section_getrightbasenr(sh);

                /* add each line in section to the view. section_getfirst()
                 * returns us to a handle that is in a list. We can
                 * call List_Next and will eventually get to the
                 * line returned by section_getlast(). Sections always have
                 * at least one line
                 */
                line1 = section_getfirstline(sh);
                line2 = section_getlastline(sh);

                for (; line1 != NULL; line1 = (LINE) List_Next(line1)) {

                        view->pLines[i].line = line1;
                        view->pLines[i].section = sh;

                        /* calculate the line number for this line by
                         * incrementing the base nr for this section
                         */
                
                        view->pLines[i].nr_left = base_left;
                        if (base_left != 0) {
                                base_left++;
                        }

                        view->pLines[i].nr_right = base_right;
                        if (base_right != 0) {
                                base_right++;
                        }

                        /* increment index into view */
                        i++;

                        /* check the column widths */
                        view->maxrest = max(view->maxrest,
                                            (line_gettabbedlength(line1, 8)));

                        /* end of section ? */
                        if (line1 == line2) {
                                break;
                        }
                }
        }

        /* We must NOT hold a critical section here as SendMessage may hang */
        ViewLeave();

        /*inform table window of revised mapping */
        SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (DWORD) view);

        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\windiff.v2\utils.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************** Module Header *******************************
* Module Name: UTILS.C
*
* standard file-reading utilities.
*
* Functions:
*
* readfile_new()
* readfile_next()
* readfile_delete()
* utils_CompPath()
* has_string()
* utils_isblank()
* StringInput()
* dodlg_stringin()
*
* Comments:
*
****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include "gutils.h"
#include "gutilsrc.h"


/*
 * we need an instance handle. this should be the dll instance
 */
extern HANDLE hLibInst;



/*
 * -- forward declaration of procedures -----------------------------------
 */
int FAR PASCAL dodlg_stringin(HWND hDlg, UINT message, UINT wParam, LONG lParam);




/*-- readfile: buffered line input ------------------------------*/

/*
 * set of functions to read a line at a time from a file, using
 * a buffer to read a block at a time from the file
 *
 */

/*
 * a FILEBUFFER handle is a pointer to a struct filebuffer
 */
struct filebuffer {
        int fh;         /* open file handle */
        PSTR start;     /* offset within buffer of next character */
        PSTR last;      /* offset within buffer of last valid char read in */

        char buffer[512];
};

/***************************************************************************
 * Function: readfile_new
 *
 * Purpose:
 *
 * Initialise a filebuffer and return a handle to it
 */
FILEBUFFER APIENTRY
readfile_new(int fh)
{
        FILEBUFFER fbuf;

        fbuf = (FILEBUFFER) LocalLock(LocalAlloc(LHND, sizeof(struct filebuffer)));
        if (fbuf == NULL) {
                return(NULL);
        }

        fbuf->fh = fh;
        fbuf->start = fbuf->buffer;
        fbuf->last = fbuf->buffer;
        /* return file pointer to beginning of file */
        _llseek(fh, 0, 0);

        return(fbuf);
}

/***************************************************************************
 * Function: readfile_next
 *
 * Purpose:
 *
 * Get the next line from a file. Returns a pointer to the line
 * in the buffer - so copy it before changing it.
 *
 * The line is *not* null-terminated. *plen is set to the length of the
 * line.
 */
LPSTR APIENTRY
readfile_next(FILEBUFFER fbuf, int FAR * plen)
{
        PSTR cstart;

        /* look for an end of line in the buffer we have*/
        for (cstart = fbuf->start; cstart < fbuf->last; cstart++) {

                if (*cstart == '\n') {
                        *plen = (cstart - fbuf->start) + 1;
                        cstart = fbuf->start;
                        fbuf->start += *plen;
                        return(cstart);
                }

        }

        /* no cr in this buffer - this buffer contains a partial line.
         * copy the partial up to the beginning of the buffer, and
         * adjust the pointers to reflect this move
         */
        strncpy(fbuf->buffer, fbuf->start, fbuf->last - fbuf->start);
        fbuf->last = &fbuf->buffer[fbuf->last - fbuf->start];
        fbuf->start = fbuf->buffer;

        /* read in to fill the block */
        fbuf->last += _lread(fbuf->fh, fbuf->last,
                        &fbuf->buffer[sizeof(fbuf->buffer)] - fbuf->last);

        /* look for an end of line in the newly filled buffer */
        for (cstart = fbuf->start; cstart < fbuf->last; cstart++) {

                if (*cstart == '\n') {
                        *plen = (cstart - fbuf->start) + 1;
                        cstart = fbuf->start;
                        fbuf->start += *plen;
                        return(cstart);
                }
        }


        /* still no end of line. either the buffer is empty -
         * because of end of file - or the line is longer than
         * the buffer. in either case, return all that we have
         */
        *plen = fbuf->last - fbuf->start;
        cstart = fbuf->start;
        fbuf->start += *plen;
        if (*plen == 0) {
                return(NULL);
        } else {
                return(cstart);
        }
}


/***************************************************************************
 * Function: readfile_delete
 *
 * Purpose:
 *
 * Delete a FILEBUFFER - close the file handle and free the buffer
 */
void APIENTRY
readfile_delete(FILEBUFFER fbuf)
{
        _lclose(fbuf->fh);

        LocalUnlock(LocalHandle( (PSTR) fbuf));
        LocalFree(LocalHandle( (PSTR) fbuf));
}


/* ----------- things for strings-------------------------------------*/


/*
 * Compare two pathnames, and if not equal, decide which should come first.
 * Both path names should be lower cased by AnsiLowerBuff before calling.
 *
 * Returns 0 if the same, -1 if left is first, and +1 if right is first.
 *
 * The comparison is such that all filenames in a directory come before any
 * file in a subdirectory of that directory.
 *
 * Given direct\thisfile v. direct\subdir\thatfile, we take
 * thisfile < thatfile   even though it is second alphabetically.
 * We do this by picking out the shorter path
 * (fewer path elements), and comparing them up till the last element of that
 * path (in the example: compare the 'dir\' in both cases.)
 * If they are the same, then the name with more path elements is
 * in a subdirectory, and should come second.
 *
 * We have had trouble with apparently multiple collating sequences and
 * the position of \ in the sequence.  To eliminate this trouble
 * a. EVERYTHING is mapped to lower case first (actually this is done
 *    before calling this routine).
 * b. All comparison is done by using lstrcmpi with two special cases.
 *    1. Subdirs come after parents as noted above
 *    2. \ must compare low so that fred2\x > fred\x in the same way
 *       that fred2 < fred.  Unfortunately in ANSI '2' < '\\'
 *
 */
int APIENTRY
utils_CompPath(LPSTR left, LPSTR right)
{
        int compval;            // provisional value of comparison

        if (left==NULL) return -1;        // empty is less than anything else
        else if (right==NULL) return 1;  // anything is greater than empty

        for (; ; ) {
                if (*left=='\0' && *right=='\0') return 0;
                if (*left=='\0')  return -1;
                if (*right=='\0')  return 1;
                if (*right==*left)  {++left; ++right; continue;}
                if (*left=='\\') {compval = -1; break;}
                if (*right=='\\') {compval = 1; break;}
                compval = (*left - *right);
                break;
        }

        /* We have detected a difference.  If the rest of one
           of the strings (including the current character) contains
           some \ characters, but the other one does not, then all
           elements up to the last element of the one with the fewer
           elements are equal and so the other one lies in a subdir
           and so compares greater i.e. x\y\f > x\f
           Otherwise compval tells the truth.
        */

        left = strchr(left, '\\');
        right = strchr(right, '\\');
        if (left && !right) return 1;
        if (right && !left) return -1;

        return compval;

} /* utils_CompPath */


/***************************************************************************
 * Function: hash_string
 *
 * Purpose:
 *
 * Generate a hashcode for a null-terminated ascii string.
 *
 * If bIgnoreBlanks is set, then ignore all spaces and tabs in calculating
 * the hashcode.
 *
 * Multiply each character by a function of its position and sum these.
 * The function chosen is to multiply the position by successive
 * powers of a large number.
 * The large multiple ensures that anagrams generate different hash
 * codes.
 */
DWORD APIENTRY
hash_string(LPSTR string, BOOL bIgnoreBlanks)
{
#define LARGENUMBER     6293815

        DWORD sum = 0;
        DWORD multiple = LARGENUMBER;
        int index = 1;

        while (*string != '\0') {

                if (bIgnoreBlanks) {
                        while ( (*string == ' ') || (*string == '\t')) {
                                string++;
                        }
                }

                sum += multiple * index++ * (*string++);
                multiple *= LARGENUMBER;
        }
        return(sum);
}


/***************************************************************************
 * Function: utils_isblank
 *
 * Purpose:
 *
 * Return TRUE iff the string is blank.  Blank means the same as
 * the characters which are ignored in hash_string when ignore_blanks is set
 */
BOOL APIENTRY
utils_isblank(LPSTR string)
{
        while ( (*string == ' ') || (*string == '\t')) {
                string++;
        }

        /* having skipped all the blanks, do we see the end delimiter? */
        return (*string == '\0' || *string == '\r' || *string == '\n');
}



/* --- simple string input -------------------------------------- */

/*
 * static variables for communication between function and dialog
 */
LPSTR dlg_result;
int dlg_size;
LPSTR dlg_prompt, dlg_default, dlg_caption;

/***************************************************************************
 * Function: StringInput
 *
 * Purpose:
 *
 * Input of a single text string, using a simple dialog.
 *
 * Returns TRUE if ok, or FALSE if error or user canceled. If TRUE,
 * puts the string entered into result (up to resultsize characters).
 *
 * Prompt is used as the prompt string, caption as the dialog caption and
 * default as the default input. All of these can be null.
 */

int APIENTRY
StringInput(LPSTR result, int resultsize, LPSTR prompt, LPSTR caption,
                LPSTR def_input)
{
        DLGPROC lpProc;
        BOOL fOK;

        /* copy args to static variable so that winproc can see them */

        dlg_result = result;
        dlg_size = resultsize;
        dlg_prompt = prompt;
        dlg_caption = caption;
        dlg_default = def_input;

        lpProc = (DLGPROC)MakeProcInstance((WNDPROC)dodlg_stringin, hLibInst);
        fOK = DialogBox(hLibInst, "StringInput", GetFocus(), lpProc);
        FreeProcInstance((WNDPROC)lpProc);

        return(fOK);
}

/***************************************************************************
 * Function: dodlg_stringin
 *
 */
int FAR PASCAL
dodlg_stringin(HWND hDlg, UINT message, UINT wParam, LONG lParam)
{
        switch(message) {

        case WM_INITDIALOG:
                if (dlg_caption != NULL) {
                        SendMessage(hDlg, WM_SETTEXT, 0, (LONG) dlg_caption);
                }
                if (dlg_prompt != NULL) {
                        SetDlgItemText(hDlg, IDD_LABEL, dlg_prompt);
                }
                if (dlg_default) {
                        SetDlgItemText(hDlg, IDD_FILE, dlg_default);
                }
                return(TRUE);

        case WM_COMMAND:
                switch(GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDCANCEL:
                        EndDialog(hDlg, FALSE);
                        return(TRUE);

                case IDOK:
                        GetDlgItemText(hDlg, IDD_FILE, dlg_result, dlg_size);
                        EndDialog(hDlg, TRUE);
                        return(TRUE);
                }
        }
        return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\difcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	DIFCASES.H
//
//	Created by :			Date :
//		WayneBr				10/4/94
//
//	Description :
//		Declaration of the CWinDiffCases class
//

#ifndef __DIFCASES_H__
#define __DIFCASES_H__

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	BOOL CWinDiffCases:: class

class CWinDiffCases : public CPerformanceCases 
{
	DECLARE_TEST(CWinDiffCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);
	void		Initialize_WinDiff();
};


#endif // DIFCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\difcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DIFCASES.CPP
//
//	Created by :			Date :
//		WayneBr				9/28/94
//					  
//	Description :
//		Portable Edit'n Go performance sniff tests

#include "stdafx.h"
#include "percases.h"
#include "difcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

Project_Info  proj_windiff;
Project_Info  *pProj_WinDiff=&proj_windiff;

IMPLEMENT_TEST(CWinDiffCases, CPerformanceCases, "Med.  C:       V2 WinDiff", -1, CSniffDriver)

void CWinDiffCases::Run(void)
{
	//initialization for all tests goes here
	Initialize_WinDiff();
	pProj_WinDiff->Time_Start_IDE = GetSubSuite()->GetIDE()->m_dwLaunchTime;

	CPerformanceCases::Run(pProj_WinDiff);
};

void CWinDiffCases::Initialize_WinDiff() {
	pProj_WinDiff->Project=		"V2 WinDiff sample";
	pProj_WinDiff->SrcProjDir=	"windiff.v2";
	pProj_WinDiff->ProjDir=		"windiff";
	pProj_WinDiff->Makefile=	"windiff\\windiff.mak";
	pProj_WinDiff->Dep_Make=	"windiff\\gutils.mak";
	pProj_WinDiff->Target=		"target"; 
	pProj_WinDiff->AddFcn=		FCN;
	pProj_WinDiff->AddFcn_File=	"windiff.c";
	pProj_WinDiff->AddFcn_Line=	770;
	pProj_WinDiff->AddDef=		"~void Pretend_Dump{(}{)};~";
	pProj_WinDiff->AddDef_File=	"windiff.c";
	pProj_WinDiff->AddDef_Line=	318;								   
	pProj_WinDiff->AddRef=		"~Pretend_Dump{(}{)};~";
	pProj_WinDiff->AddRef_File=	"windiff.c";
	pProj_WinDiff->AddRef_Line=	381;								   
	pProj_WinDiff->ModCode=		MOD;
	pProj_WinDiff->Disk_Before=	0;
	pProj_WinDiff->Disk_After=	0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\debugger.h ===
///////////////////////////////////////////////////////////////////////////////
//	Debugger.H
//
//	Created by :			Date :
//		Waynebr					2/18/94
//
//	Description :
//		Debugger tests helpers
//

#ifndef __DEBUGGER_H__
#define __DEBUGGER_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
//	Debugging helpers

extern int ReturnCode;
extern bp  * ReturnBP;
extern void LogResult(int result,LPCSTR szoperation, int code=0);
extern LPCSTR HomeDir(void);
extern LPCSTR FullPath(LPCSTR szAddPath);

#define EXPECT_TRUE(f)    ((f)?LogResult(TRUE,#f):LogResult(FALSE,#f));
#define EXPECT_FALSE(f)   ((f)?LogResult(FALSE,#f):LogResult(TRUE,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(TRUE,#f):LogResult(FALSE,#f,ReturnCode));
#define EXPECT_VALIDBP(f) (((ReturnBP=(f))!=NULL)?LogResult(TRUE,#f):LogResult(FALSE,#f));


#if defined(LEGO) // Lego meeds minimal case only comment out logging.
	#define WRITELOG(bool, text)	// 
	#define VCOMMENT(text,val)		// 
	#define COMMENT(text)			// 
#else
	// VCOMMENT is a comment with a single value
	#define VCOMMENT(text,val)	m_pLog->Comment(text,val);
	#define COMMENT(text)		m_pLog->Comment(text);
	// General use Writelog Macro
	#define Writelog(bool,text) if(bool) m_pLog->RecordInfo(text); else m_pLog->RecordFailure(text);			
	// Returns on Failure used in Editgo
	#define WRITELOG(bool,text) if(bool) m_pLog->RecordInfo(text); else {m_pLog->RecordFailure(text); return FALSE;}			
#endif  // LEGO


#endif //__DEBUGGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\mpdcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	MPDCASES.H
//
//	Created by :			Date :
//		WayneBr				10/4/94
//
//	Description :
//		Declaration of the CMultipadCases class
//

#ifndef __MPDCASES_H__
#define __MPDCASES_H__

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	BOOL CMultipadCases:: class

class CMultipadCases : public CPerformanceCases 
{
	DECLARE_TEST(CMultipadCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);
	void		Initialize_Multipad();

};


#endif // MPDCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\percases.h ===
///////////////////////////////////////////////////////////////////////////////
//	PERCASES.H
//
//	Created by :			Date :
//		WayneBr				10/3/94
//
//	Description :
//		Declaration of the CSysTestCases class
//

#ifndef __PERCASES_H__
#define __PERCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

typedef struct Project_Info {
		CString	Project;
		CString SrcProjDir;
		CString ProjDir;
		CString Makefile;
		CString	Dep_Make;
		CString Target;
		CString	AddFcn;
		CString AddFcn_File;
		DWORD	AddFcn_Line;
		CString AddDef;
		CString	AddDef_File;
		DWORD	AddDef_Line;
		CString AddRef;
		CString	AddRef_File;
		DWORD	AddRef_Line;
		CString ModCode;
		DWORD	Time_Start_IDE;
		DWORD	Time_Start_Debug;
		DWORD	Time_Restart_Debug;
		DWORD	Time_Full_Build;
		DWORD	Time_Major_Build;
		DWORD	Time_Minor_Build;
		_int64 	Disk_Before;
		_int64 	Disk_After;

		} Project_Info;


#define MAX_SRC		3
#define DBG_START	1
#define DBG_RESTART	2

///////////////////////////////////////////////////////////////////////////////
//	BOOL CPerformanceCases:: class

class CPerformanceCases : public CTest
{
	DECLARE_TEST(CPerformanceCases, CSniffDriver)

// ctor because this class is a base class for tests
	CPerformanceCases(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(Project_Info* pProjInfo);

// Data
protected:
	CString FCN;
	CString MOD;

	CODebug m_dbg;
	COBrowse m_brz;
	COProject m_prj;
	COProject m_prj_dep;
	COResScript m_res;
	COBreakpoints m_bp;
	COExpEval m_cxx;
	COSource m_src[MAX_SRC];
	
// Test Cases		    
protected:
	BOOL Setup(Project_Info* );
	BOOL Shutdown(Project_Info* , BOOL);
	BOOL CleanBuild(Project_Info *);
	BOOL MajorChange(Project_Info *);
	BOOL MinorChange(Project_Info *);
	BOOL LogData(Project_Info *);


// Utilities
protected:
	void RemoveTree(  CString strRootDir );
	void MeasureTree( CString strRootDir, _int64 *pDirSize );

	
	COSource *OpenSource(LPCSTR filename);
	void CloseALLSources();

	CString ConvertTime(unsigned long Time);
	DWORD   GetBuildTime();
	DWORD   GetDBGTime(int DBG_Type = DBG_START);

	inline BOOL MyWaitForBreak(HWND hwnd);
};

#endif // PERCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\mpdcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	MPDCASES.CPP
//
//	Created by :			Date :
//		WayneBr				9/28/94
//					  
//	Description :
//		Portable Edit'n Go performance sniff tests

#include "stdafx.h"
#include "percases.h"
#include "mpdcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

Project_Info  proj_multipad;
Project_Info  *pProj_Multipad=&proj_multipad;

IMPLEMENT_TEST(CMultipadCases, CPerformanceCases, "Small C:       V2 Multipad", -1, CSniffDriver)

void CMultipadCases::Run(void)
{
	//initialization for all tests goes here
	Initialize_Multipad();
	pProj_Multipad->Time_Start_IDE = GetSubSuite()->GetIDE()->m_dwLaunchTime;

	CPerformanceCases::Run(pProj_Multipad);
};

void CMultipadCases::Initialize_Multipad() {
	pProj_Multipad->Project=	"V2 Multipad sample";
	pProj_Multipad->SrcProjDir=	"multipad.v2";
	pProj_Multipad->ProjDir=	"multipad";
	pProj_Multipad->Makefile=	"multipad\\multipad.mak";
	pProj_Multipad->Dep_Make=	"";	// None
	pProj_Multipad->Target=		"target"; 
	pProj_Multipad->AddFcn=		FCN;
	pProj_Multipad->AddFcn_File="multipad.c";
	pProj_Multipad->AddFcn_Line=984;
	pProj_Multipad->AddDef=		"~extern void Pretend_Dump{(}{)};~";
	pProj_Multipad->AddDef_File="multipad.h";
	pProj_Multipad->AddDef_Line=204;								   
	pProj_Multipad->AddRef=		"~Pretend_Dump{(}{)};~";
	pProj_Multipad->AddRef_File="multipad.c";
	pProj_Multipad->AddRef_Line=107;								   
	pProj_Multipad->ModCode=	MOD;
	pProj_Multipad->Disk_Before=0;
	pProj_Multipad->Disk_After=	0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\percases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      PERCASES.CPP
//
//      Created by :                    Date :
//              WayneBr                         9/28/94
//                                      
//      Description :
//              Portable Edit'n Go performance sniff tests

#include "stdafx.h"
#include "fstream.h"
#include "percases.h"
#include "debugger.h"
//
// Daytona only api handling
//
#include "DllApi.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// OS hack function
CString GetOSDescription(void);  // e.g. "Windows NT 3.5, build 807"

inline BOOL MyWaitForBreak (HWND hwnd);
inline void FlushMem(void);

// Timer Globals
DWORD dwStartTime;
DWORD dwEndTime;
DWORD dwElapsedTime;
DWORD dwSleep;

// Switch Globals
BOOL fFlush;
BOOL fCleanUp;
DWORD   FullWait;
DWORD   FullDepWait;
DWORD   MajorWait;
DWORD   MinorWait;
DWORD   StartDBGWait;
DWORD   RestartWait;
CString ProductVersion;
CString OSVersion;

// Globals for MyWaitForBreak
HWND    hwnd;
char    Buffer[128];

// Source file pointers / allocation map
COSource *pSrcFCN, *pSrcDef, *pSrcRef;
BOOL bSRC_USED[MAX_SRC]= {FALSE, FALSE, FALSE};

#if defined(LEGO)    // Lego meeds minimal case, ie no timing info needed
#define GetTickCount()  0
#endif

IMPLEMENT_TEST(CPerformanceCases, CTest, "Performance Tests", -1, CSniffDriver)

CPerformanceCases::CPerformanceCases(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: CTest(pSubSuite, szName, nExpectedCompares, szListFilename)
{
	// Function to add and Modifications to function for later
	FCN="~void Pretend_Dump{(}{)} {{}{TAB}//New fuction to test incremental builds~{TAB}int x=1; //Delete_This_Later~int y;~int z; //Delete_This_Later~~y=2;~z=3.7;~z=y/z;~OutputDebugString{(}\"Pretend dump\"{)};~+{TAB}{}};~";
	MOD="float z; ~char *sz=\"Sample String\";~~";
}

void CPerformanceCases::PreRun(void)
{
	#define ALLBUILDTIME_FLAG       " /Y3"
	#define DEBUGTIME_FLAG			" /DBGLOG"
	
	CSettings       *pSettings=             GetSubSuite()->GetIDE()->GetSettings();
	CString         strCommandLine= pSettings->GetTextValue(settingCmdLine);
	strCommandLine = strCommandLine + ALLBUILDTIME_FLAG + DEBUGTIME_FLAG;
	pSettings->SetTextValue(settingCmdLine,strCommandLine);
	FlushMem();  // Flush working set on NT iff -Flush flag is set
	CTest::PreRun();
}

BOOL CPerformanceCases::Setup(Project_Info* PI)
{

#if defined(LEGO) // Lego meeds minimal case, no setup (do in batch file before running)
	return TRUE;
#endif
	BOOL bResult=TRUE;
	CString s,DBG_Wait,BLD_Wait;
	CString SrcProjDir_FullPath= FullPath(PI->SrcProjDir);
	CString ProjDir_FullPath= FullPath(PI->ProjDir);

	// Initialize Switch Globals            
		fFlush=(CMDLINE->GetBooleanValue("flush",FALSE) ? TRUE:FALSE);
		fCleanUp=(CMDLINE->GetBooleanValue("cleanup",TRUE) ? TRUE:FALSE);
		
		//  -Build_Wait:"60,60,20,20"   multiply by 1000 to convert seconds to ms
		BLD_Wait=(CMDLINE->GetTextValue("Build_Wait"));
		if (! BLD_Wait.IsEmpty())
		{
			s=BLD_Wait;
			FullWait=       1000 * atoi(s.Left(     s.Find(',')));
			s=s.Mid((s.Find(',')+1));
			FullDepWait=1000 * atoi(s.Left( s.Find(',')));
			s=s.Mid((s.Find(',')+1));
			MajorWait=      1000 * atoi(s.Left(     s.Find(',')));
			MinorWait=      1000 * atoi(s.Mid((s.Find(',')+1)));
		} else {
			FullWait=        1000 ;
			FullDepWait= 1000 ;
			MajorWait=       1000 ;
			MinorWait=       1000 ;
		};
	
		//  -DBG_Wait:"20,5"                    multiply by 1000 to convert seconds to ms
		DBG_Wait=(CMDLINE->GetTextValue("DBG_Wait"));
		if (! DBG_Wait.IsEmpty())
		{
			StartDBGWait=1000 * atoi(DBG_Wait.Left( DBG_Wait.Find(',')));
			RestartWait= 1000 * atoi(DBG_Wait.Mid((DBG_Wait.Find(',')+1)));
		} else {
			StartDBGWait= 1000;
			RestartWait=  1000;
		};


		ProductVersion=(CMDLINE->GetTextValue("VC_VER"));
		OSVersion=(CMDLINE->GetTextValue("OS_VER"));

		WRITELOG(TRUE,"=======================  Prepare for Testing  ========================");                        
		WRITELOG(TRUE,"Copy appwiz.v2 tree to appwiz directory" );
		KillAllFiles( ProjDir_FullPath);
		CreateDirectory(ProjDir_FullPath, NULL);
		//Copy appwiz.v2 tree to a working directory
		CopyTree ( SrcProjDir_FullPath, ProjDir_FullPath);
		// save diskfootprint
		MeasureTree(PI->ProjDir,&(PI->Disk_Before));
		WRITELOG(TRUE,"Measured initial disk footprint");
	return bResult;
};



BOOL CPerformanceCases::Shutdown(Project_Info* pProjInfo, BOOL bResult)
{
	// Close project and files
	WRITELOG(TRUE,"=======================  Clean up after Testing  ========================");                     
	CloseALLSources();
	m_prj.Close();
	UIWB.CloseAllWindows();  // incase any other windows are open (winmain.cpp etc..)
	WRITELOG(bResult,"Close project, files, windows");

#if defined(LEGO) // Lego meeds minimal case only no cleanup 
	m_pLog->RecordInfo(pProjInfo->Project+" Testing Completed");
	return bResult;
#endif

	// save diskfootprint
	MeasureTree(pProjInfo->ProjDir,&(pProjInfo->Disk_After));               
	WRITELOG(bResult,"Measured final disk footprint");

	// Clean up files if tests passed.
	if ((bResult) && (fCleanUp)) {
		KillAllFiles( FullPath(pProjInfo->ProjDir));
		WRITELOG(TRUE,"Clean project after all tests PASS");                    
	};
	// Log result to data file and CAFE Log 
	if (bResult) {
		bResult=bResult && LogData( pProjInfo );        // Log result to datfile and CAFE Log
		WRITELOG(TRUE,"Log result to data file and CAFE Log");                  
	}
	// Testing Done
	m_pLog->RecordInfo(pProjInfo->Project+" Testing Completed");

	return bResult;
};


void CPerformanceCases::Run(Project_Info* pProjInfo)
{

	BOOL bResult=Setup( pProjInfo );
	// Users Scenarios
	if (bResult)
		bResult=bResult && CleanBuild ( pProjInfo );    // Clean build User scenario
	if (bResult)
		bResult=bResult && MajorChange( pProjInfo );    // Major change ie adding function(s) User scenario
	if (bResult)
		bResult=bResult && MinorChange( pProjInfo );    // Minor change ie changes within function User scenario
	Shutdown( pProjInfo, bResult);
	
};


BOOL CPerformanceCases::CleanBuild(Project_Info * PI) {

		BOOL bResult=TRUE;
		WRITELOG(TRUE,"====================  Full Clean Build Scenario  ====================");                 

// **** If dependant make file run that first *****     
		if (PI->Dep_Make != "") {
	// open project
			m_prj_dep.Open(FullPath(PI->Dep_Make));
	// clean full build
			dwSleep=FullDepWait;
			FlushMem();  // Flush working set on NT iff -Flush flag is set
			m_prj_dep.RebuildAll(FullDepWait);			
			FlushMem();  // Flush working set on NT iff -Flush flag is set
			// save build timing info
			PI->Time_Full_Build=GetBuildTime();
			VCOMMENT("Time required to for clean full build of dependant stuff (milliseconds): %d", PI->Time_Full_Build);
			BOOL bBuilt= (m_prj_dep.VerifyBuild() == ERROR_SUCCESS);
			bResult=bResult && bBuilt;
			WRITELOG(bBuilt,"Clean Full Depandant Build");
	// close project
	//              m_prj_dep.Close();
		}
		else
		{
	// clear timing info
			PI->Time_Full_Build=0;
		}

// **** Main makefile/project *****     
	// open project
		m_prj.Open(FullPath(PI->Makefile));
	// get/set? target and options if needed
		PI->Target=( (CString)(m_prj.GetTarget()) );
	// clean full build
		dwSleep=FullWait;
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		m_prj.RebuildAll(FullDepWait);			
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		DWORD dwTempTime=GetBuildTime();
		// save build timing info
		PI->Time_Full_Build=PI->Time_Full_Build+dwTempTime;
		VCOMMENT("Time required to for complete clean full build (in milliseconds): %d", PI->Time_Full_Build);
		BOOL bBuilt= (m_prj.VerifyBuild() == ERROR_SUCCESS);
		bResult=bResult && bBuilt;
		WRITELOG(bBuilt,"Clean Full Build");
	// Start debugging (F8)
		dwSleep=StartDBGWait;
		hwnd=MST.WGetActWnd(0);
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		// Measure Start time
		UIWB.DoCommand(IDM_RUN_STEPOVER, DC_MESSAGE);
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		::Sleep(dwSleep);
		BOOL bStarted=MyWaitForBreak(hwnd);
		dwElapsedTime=GetDBGTime(DBG_START);
		PI->Time_Start_Debug=dwElapsedTime;
		VCOMMENT("Time required to start debugging (in milliseconds): %d", dwElapsedTime);
		bResult=bResult && bStarted;
		WRITELOG(bStarted,"Start debugging via F8");
	// Stop debugging
		UIWB.WaitForBreak();  // add to compensate for use of MyWaitForBreak when start debugging
		bResult=bResult && m_dbg.StopDebugging( ASSUME_NORMAL_TERMINATION );
		WRITELOG(bResult, "Stop debugging the TEST app" );
		return bResult;
}

BOOL CPerformanceCases::MajorChange(Project_Info * PI) {

		BOOL bResult=TRUE;
		WRITELOG(TRUE,"====================  Major Change Scenario  ====================");                     
	// ADD definition
		pSrcDef=OpenSource(FullPath(PI->ProjDir+"\\"+PI->AddDef_File));
		pSrcDef->InsertText(PI->AddDef, PI->AddDef_Line, 1);
	// ADD refernece
		pSrcRef=OpenSource(FullPath(PI->ProjDir+"\\"+PI->AddRef_File));
		pSrcRef->InsertText(PI->AddRef, PI->AddRef_Line, 1);            
	// ADD function
		pSrcFCN=OpenSource(FullPath(PI->ProjDir+"\\"+PI->AddFcn_File));
		pSrcFCN->InsertText(PI->AddFcn, PI->AddFcn_Line, 1);    
			
		WRITELOG(TRUE, "Add function (Major Change)");
	// verify navigation via. no compile browser
		// ********** TODO enable when browser feature is on-line ************
		//bResult=Result && m_brz.GotoNthDefinition( 1, "Pretend_Dump" );
		//WRITELOG(bResult, "Go to the definition of \"Pretend_Dump\"" );
	// incremental build
		dwSleep=MajorWait;
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		m_prj.Build(MajorWait);			
		FlushMem();  // Flush working set on NT iff -Flush flag is set
	// save build timing info
		PI->Time_Major_Build=GetBuildTime();
		VCOMMENT("Time required to for incremental build (in milliseconds): %d",PI->Time_Major_Build);
		BOOL bBuilt= (m_prj.VerifyBuild() == ERROR_SUCCESS);
		bResult=bResult && bBuilt;
		WRITELOG(bBuilt,"Incremental Build after adding a function");
	// Start debugging (F8)
		dwSleep=StartDBGWait;
		hwnd=MST.WGetActWnd(0);
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		// Measure Start time
		UIWB.DoCommand(IDM_RUN_STEPOVER, DC_MESSAGE);
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		::Sleep(dwSleep);
		BOOL bStarted=MyWaitForBreak(hwnd);
		dwElapsedTime=GetDBGTime(DBG_START);
		// save start debugging info
		PI->Time_Start_Debug+=dwElapsedTime;
		VCOMMENT("Time required to start debugging (in milliseconds): %d", dwElapsedTime);
		bResult=bResult && bStarted;
		WRITELOG(bStarted,"Start debugging via F8");
	// Stop debugging
		UIWB.WaitForBreak();  // add to compensate for use of MyWaitForBreak when start debugging
		bResult=bResult && m_dbg.StopDebugging( ASSUME_NORMAL_TERMINATION );
		WRITELOG(bResult, "Stop debugging the TEST app" );
		return bResult;
};

BOOL CPerformanceCases::MinorChange(Project_Info * PI) {
	BOOL bResult=TRUE;
	WRITELOG(TRUE,"====================  Minor Change Scenario  ====================");                     
	// Add changes
		//m_src.Open(FullPath(PI->AddFcn_File));
		//m_src->Open(FullPath(PI->ProjDir+"\\"+PI->AddFcn_File));
		COFile file;
		file.Open(FullPath(PI->ProjDir+"\\"+PI->AddFcn_File));
#if !defined(LEGO)  // LEGO needs minimal case not searches
		pSrcFCN->Find("int x=1; //Delete_This_Later");
		pSrcFCN->TypeTextAtCursor("////");
#endif  // LEGO
		pSrcFCN->Find("int z; //Delete_This_Later");
		pSrcFCN->TypeTextAtCursor(PI->ModCode);
		WRITELOG(TRUE, "Modify function (Minor Change)");                       
	// set BP on function
#if !defined(LEGO)  // LEGO needs minimal case not extra debugging
#if defined(_M_MRX000) || defined(_M_ALPHA)
		bResult=bResult && (BOOL)m_bp.SetBreakpoint(PI->AddFcn_Line+5);
#else
		bResult=bResult && (BOOL)m_bp.SetBreakpoint(PI->AddFcn_Line+1);
#endif
#endif  // LEGO
		WRITELOG( bResult,"Set a breakpoint on \"Pretend_Dump\"" );
	// incremental build
		dwSleep=MinorWait;
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		m_prj.Build(dwSleep);			
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		// save build timing info                                  
		PI->Time_Minor_Build=GetBuildTime();
		VCOMMENT("Time required to for incremental build (in milliseconds): %d", PI->Time_Minor_Build);
		BOOL bBuilt= (m_prj.VerifyBuild() == ERROR_SUCCESS);
		bResult=bResult && bBuilt;
		WRITELOG(bBuilt,"Incremental Build editing within a function");
	// Start debugging (F8)
		dwSleep=StartDBGWait;
		hwnd=MST.WGetActWnd(0);
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		// Measure Start time
		UIWB.DoCommand(IDM_RUN_STEPOVER, DC_MESSAGE);  // message is low overhead/faster dokeys is blocking
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		::Sleep(dwSleep);
		BOOL bStarted=MyWaitForBreak(hwnd);
		dwElapsedTime=GetDBGTime(DBG_START);
		// save start debugging info
		PI->Time_Start_Debug+=dwElapsedTime;
		VCOMMENT("Time required to start debugging (in milliseconds): %d", dwElapsedTime);
		bResult=bResult && bStarted;
		WRITELOG(bStarted,"Start debugging via F8");
#if !defined(LEGO) // LEGO needs minimal case not extra debugging
	// Go to BP
		UIWB.WaitForBreak();  // add to compensate for use of MyWaitForBreak when start debugging
		bResult=bResult && m_dbg.Go( NULL, NULL, "Pretend_Dump" );
		WRITELOG(bResult,,"Run until the breakpoint is hit" );
	// Step to right place
		BOOL bLineInfo=TRUE;
#if !defined(_M_MRX000) && !defined(_M_ALPHA)
		bLineInfo=bLineInfo && m_dbg.StepInto(1,NULL,"Sample String",NULL);
#endif
		bLineInfo=bLineInfo && m_dbg.StepInto(1,NULL,"y=2",NULL);
		bLineInfo=bLineInfo && m_dbg.StepInto(1,NULL,"z=3.7",NULL);
		bLineInfo=bLineInfo && m_dbg.StepInto(1,NULL,"z=y/z",NULL);
		bResult=bResult && bLineInfo;
		WRITELOG(bLineInfo,"Verify Line Number via Four Stepinto's");
	// verify debug info
	 //             note can't use EXPECT_TRUE( macro if \"  in string!!!
	 //             note add home to deselect
		//TODO: set bResult for EE stuff below
		MST.DoKeys("{HOME}");
		LogResult(m_cxx.ExpressionErrorIs("x",GetLocString(IDSS_ERR_CHECK_CXX0017)), "ExpressionErrorIs(\"x\",\"CXX0017: Error: symbol \"x\" not found\")");        // x was removed
		EXPECT_TRUE(m_cxx.ExpressionValueIs("y",2));    // y was unchanged
		EXPECT_TRUE(m_cxx.ExpressionValueIs("z",3.7));  // z changed type from int to float
		LogResult(m_cxx.ExpressionValueIs("sz,s" , "\"Sample String\"" ),"ExpressionValueIs(\"sz,s\",\"Sample String\")");      // added new variable
#endif  // LEGO

	// Restart
		dwSleep=RestartWait;
		hwnd=MST.WGetActWnd(0);
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		// Measure restart time
		UIWB.DoCommand(IDM_RUN_RESTART, DC_MESSAGE);  // message is low overhead/faster dokeys is blocking
		FlushMem();  // Flush working set on NT iff -Flush flag is set
		::Sleep(dwSleep);
		bStarted=MyWaitForBreak(hwnd);
		dwElapsedTime=GetDBGTime(DBG_RESTART);
		// save restart debugging timing info
		PI->Time_Restart_Debug=dwElapsedTime;
		VCOMMENT("Time required to restart debugging (in milliseconds): %d", dwElapsedTime);
		bResult=bResult && bStarted;
		WRITELOG(bStarted,"Restart the TEST app" );
	// Stop debugging
		UIWB.WaitForBreak();  // add to compensate for use of MyWaitForBreak when start debugging
		bResult=bResult && m_dbg.StopDebugging( ASSUME_NORMAL_TERMINATION );
		WRITELOG(bResult, "Stop debugging the TEST app" );
	
		return bResult;
};

BOOL CPerformanceCases::LogData(Project_Info * PI) {
		// Create Record        
		CString DataRecord1;
		CTime Time;
		Time=Time.GetCurrentTime();

		if (ProductVersion=="") ProductVersion=(CString)GetSubSuite()->GetIDE()->GetVersion();
		if (OSVersion=="") OSVersion=(CString)GetOSDescription();

		DataRecord1=(CString) Time.Format( "%x" )               +","+
					(CString) Time.Format( "%X" )           +","+
					(CString) OSVersion                                     +","+
					(CString) ProductVersion            +","+
					(CString)PI->Project                            +","+
					(CString)PI->Target                                     +","+
					ConvertTime(PI->Time_Start_IDE)         +","+
					ConvertTime(PI->Time_Start_Debug/3)     +","+
					ConvertTime(PI->Time_Restart_Debug)     +","+
					ConvertTime(PI->Time_Full_Build)        +","+
					ConvertTime(PI->Time_Major_Build)       +","+
					ConvertTime(PI->Time_Minor_Build)       +","+
					ConvertTime((unsigned long)((PI->Disk_After) - (PI->Disk_Before)));
												
		// LOG DATA TO VIEWPORT
		COMMENT(("Data:"+DataRecord1));
	
		// LOG DATA TO FILE
		ofstream DataFile("VC_Data.Dat", ios::app);
		DataFile << DataRecord1<<endl;
		DataFile.close();
		
		// Write Build Record   
		ofstream DataFile2("VCbldLog.txt", ios::app);
		DataFile2 << DataRecord1 << endl;
		DataFile2.close();

		// Write Build Record   
		ofstream DataFile3("VCdisk.txt", ios::app);
		DataFile3 << DataRecord1 << endl;
		DataFile3.close();

		return TRUE;
};

///////////////////////////////////////////////////////////////////////////////
//      Test Utilities

void CPerformanceCases::RemoveTree( CString strRootDir )
{
	if ( strRootDir.Right( 1 ) != '\\' )
		strRootDir += '\\';

	WIN32_FIND_DATA findData;
	HANDLE hSearch = FindFirstFile( strRootDir + "*.*", &findData );
	if ( hSearch != INVALID_HANDLE_VALUE )
	{
		do
		{
			if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
			{
				if ( findData.cFileName[0] != '.' )
				{
					CString strSubDir = strRootDir + findData.cFileName;
					RemoveTree( strSubDir + '\\' );
				}
			}
			else
				DeleteFile( strRootDir + findData.cFileName );
		}
	    while ( FindNextFile( hSearch, &findData ) );

		FindClose( hSearch );
		// Don't need to remove directory too.
		//RemoveDirectory( strRootDir );
	}
}

void CPerformanceCases::MeasureTree( CString strRootDir, _int64 *pDirSize)              
{
	// Open data file 
	ofstream DataFile("VCdisk.txt", ios::app);

	if ( strRootDir.Right( 1 ) != '\\' )
		strRootDir += '\\';

	WIN32_FIND_DATA findData;
	HANDLE hSearch = FindFirstFile( strRootDir + "*.*", &findData );
	if ( hSearch != INVALID_HANDLE_VALUE )
	{
		do
		{
			if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
			{
				if ( findData.cFileName[0] != '.' )
				{
					CString strSubDir = strRootDir + findData.cFileName;
					MeasureTree( strSubDir + '\\', pDirSize);
				}
			}
			else
			{
				// TODO replace 0 with max of DWORD
				_int64 FileSize = ((findData.nFileSizeHigh * 0) + findData.nFileSizeLow);
				*pDirSize = *pDirSize + FileSize;
				if ( !(findData.dwFileAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY)) )
					 DataFile << findData.cFileName << "\t" << ConvertTime((unsigned long)(FileSize)) << endl;
			}
		}
	    while ( FindNextFile( hSearch, &findData ) );
		FindClose( hSearch );
	}
	// Close Data File
	DataFile.close();
}

CString CPerformanceCases::ConvertTime(unsigned long Time){
	char buffer[255];
	char *pBuf=buffer;
	pBuf=ultoa(Time,pBuf,10);
	return (CString)(pBuf);

};


COSource *CPerformanceCases::OpenSource(LPCSTR filename) {
	int count = 0;
	while  ( bSRC_USED[count] && count < MAX_SRC ) {
		if ( ((CString)(m_src[count].GetFileName())).Find((CString)filename) !=-1 ){
			return &m_src[count];
		}
		count++;
	}
	if (count < MAX_SRC) {
		m_src[count].Open(filename);
		bSRC_USED[count]=TRUE;
		return &m_src[count];
	}

	CString msg = "OpenSource: Ran out of resources";
	COMMENT((const char *) msg) ;
	return NULL;
};

void CPerformanceCases::CloseALLSources() {
	int count = 0;
	while  ( bSRC_USED[count] && count < MAX_SRC)  {
		m_src[count].Close();
		bSRC_USED[count]=FALSE;
		count++;
	}
};
	

DWORD   CPerformanceCases::GetBuildTime() {

#if defined(LEGO) // LEGO needs minimal case not timing info needed
	return 0;
#endif

	CString BuildRecord;
	CString str;
	
	// Get build data
	UIWB.DoCommand(IDM_WINDOW_ERRORS,DC_MNEMONIC);  // goto output window
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(BuildRecord);       // get text from clipboard
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+{up}");			// select last line 
	MST.DoKeys("^c");				// copy it
	GetClipText(str);               // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window

	// Write Build Record   
	ofstream DataFile("VCbldLog.txt", ios::app);
	DataFile << BuildRecord << endl;
	DataFile.close();

	// Look for the NEW time instrumented output
	//Build Time 0:18.5      
	if(str.Find("Build Time") >= 0) {		// TODO: Needs to be localized???
		// get time
		long Tenths =atol(str.Mid(str.ReverseFind('.')+1));
		long Seconds=atol(str.Mid(str.ReverseFind(':')+1,2));
		CString temp=str.Mid(0,str.ReverseFind(':')+1);
		long Minutes=atol(temp.Mid(temp.ReverseFind(' ')+1));
		DWORD Time= (Minutes*60*1000) + (Seconds*1000) + (Tenths*100);
		//VCOMMENT("Build Time (milliseconds): %s (%s)", str, ConvertTime(Time));
		return Time;
	}
	// couldn't find "Build Time"
	return 0;
};

DWORD   CPerformanceCases::GetDBGTime(int DBG_Type /* DBG_START */) {

#if defined(LEGO) // LEGO needs minimal case not timing info needed
	return 0;
#endif

	CString DBG_record;
	CString str, fnd_str;
	
	// Get output data
	UIWB.DoCommand(IDM_WINDOW_ERRORS,DC_MNEMONIC);  // goto output window
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(DBG_record);		// get text from clipboard
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+{up}");			// select last line 
	MST.DoKeys("^c");				// copy it
	GetClipText(str);               // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window

	// Write Debugger Record   
	ofstream DataFile("VCdbgLog.txt", ios::app);
	DataFile << DBG_record << endl;
	DataFile.close();

	// Look for the NEW time instrumented output
	// Debug start time: 0:10:6
	// Debug restart time: 0:02:4
	if (DBG_Type == DBG_RESTART)
		fnd_str="Debug restart time";		// TODO: Needs to be localized???
	else 
		fnd_str="Debug start time";			// TODO: Needs to be localized???
	if(str.Find(fnd_str) >= 0) {
		// get time
		long Tenths =atol(str.Mid(str.ReverseFind(':')+1));
		CString temp=str.Mid(0,str.ReverseFind(':'));
		long Seconds=atol(temp.Mid(temp.ReverseFind(':')+1,2));
		temp=temp.Mid(0,temp.ReverseFind(':'));
		long Minutes=atol(temp.Mid(temp.ReverseFind(' ')+1));
		DWORD Time= (Minutes*60*1000) + (Seconds*1000) + (Tenths*100);
		//VCOMMENT("Debug start/restart Time (ms): %s (%s)", str, ConvertTime(Time));
		return Time;
	}
	// couldn't find Debug Time string
	return 0;
};



// from log.cpp remove when this function is added to new OS class 
CString GetOSDescription(void)  // e.g. "Windows NT 3.5, build 807"
{
  static LPCSTR szErr = "[Error calling GetVersionEx()]";

  OSVERSIONINFO osvi;

  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);  // required before calling GetVersionEx()

  if (!GetVersionEx(&osvi))
    return szErr;

  CString strD;

  switch (osvi.dwPlatformId)  // find the name of the OS
  {
    case VER_PLATFORM_WIN32_NT:
    {
      strD = "Windows NT";
      break;
    }
    case 1 /*VER_PLATFORM_WIN32_WINDOWS*/:  // see Olympus bug 3496; I'm guessing that this will be 1.
    {
      strD = "Windows";
      break;
    }
    case VER_PLATFORM_WIN32s:
    {
      strD = "Win32s";
      break;
    }
    default:
    {
      return szErr;
    }
  }

  strD += ' ';  // add a space after the name

  CString strV;

  strV.Format("%u.%u build %u", osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);

  return strD + strV;
};


CDllApi::CDllApi ( const _TCHAR * szDll, MPSZPFN * mpszpfn ) {
    _mpszpfn = mpszpfn;
	_tcscpy ( _szDll, szDll );
	_fRoutinesOK = FALSE;
	_cRoutines = 0;

	HINSTANCE       hInstance = LoadLibrary ( szDll );

	if ( hInstance ) {
		
		_hInstance = hInstance;

		MPSZPFN *       pmpszpfn;
		BOOL            fRoutinesOK = TRUE;

		for ( pmpszpfn = _mpszpfn; pmpszpfn->szRoutine; pmpszpfn++ ) {
			fRoutinesOK = 
				fRoutinesOK && 
				(pmpszpfn->pfn = GetProcAddress ( hInstance, pmpszpfn->szRoutine ));
			_cRoutines++;
			}
		_fRoutinesOK = fRoutinesOK;
		}
	
    }
CDllApi::~CDllApi() {
	if ( _hInstance ) {
		FreeLibrary ( _hInstance );
		}
	_hInstance = 0;
	_fRoutinesOK = FALSE;
	}


BEGIN_MPSZPFN(Daytona)
MPSZPFN_FCN(SetProcessWorkingSetSize)
MPSZPFN_FCN(GetProcessWorkingSetSize)
END_MPSZPFN(Daytona)

#define ipfnSetWSSize  0
#define cbTrimWorkingSet        0xffffffff


typedef BOOL (WINAPI * PfnSetWSSize)(HANDLE, DWORD, DWORD);

#define cbTrimWorkingSet        0xffffffff

DECLARE_DLLAPI(dllApiDaytona, Daytona, kernel32.dll);

inline BOOL
SetWorkingSetSize ( DWORD cbMinWS, DWORD cbMaxWS ) {
	if ( dllApiDaytona.FRoutinesLoaded() ) {
		return PfnSetWSSize( dllApiDaytona ( ipfnSetWSSize ) ) (
			GetCurrentProcess(),
			cbMinWS,
			cbMaxWS
			);
		}
	return FALSE;
	}


inline void FlushMem(void) {
#if !defined(LEGO)  // LEGO needs minimal case not searches
	if (fFlush) SetWorkingSetSize(cbTrimWorkingSet,cbTrimWorkingSet);
#endif  // LEGO
};

inline BOOL CPerformanceCases::MyWaitForBreak(HWND hwnd) {
	CString lpzTitleBreak= "["+GetLocString(IDSS_DBG_BREAK)+"]";
	DWORD count=0;
	COMMENT("Waiting for '"+lpzTitleBreak+"' in title bar.");
	while( count<10 )  //1 minute limit -- WinslowF Add two morw zeros to handle the slownes on NT
	{
		//((GetText().Find(strTitleBreak) < 0 ) ? Sleep(500) : ct++);
		::Sleep(6000);
		GetWindowText(hwnd, Buffer, 128);
		if ( strstr(Buffer, lpzTitleBreak) )
			return TRUE;
		else
		{
			count+=1;
			COMMENT("MyWaitForBreak: Still looking for '"+lpzTitleBreak+"' in Title Bar");
		}
	};
	COMMENT("MyWaitForBreak: Time out after 1 min, found '"+(CString)Buffer+"' looking for '"+(CString)lpzTitleBreak+"'");
	return FALSE;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"
#include "percases.h"
#include "wizcases.h"
#include "spycases.h"
#include "mpdcases.h"
#include "difcases.h"

//extern BOOL GetBooleanSwitch(LPCSTR);

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////		(CMDLINE->GetTextValue.Find)!=x))
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "Edit 'n Go Sniff Test", "ThuyT X32270")

BEGIN_TESTLIST(CSniffDriver)
	TEST(CDefAppWizCases,((CMDLINE->GetTextValue("Test","")=="") || (CMDLINE->GetTextValue("Test","").Find("APPWIZ")!=(-1))) || (CMDLINE->GetBooleanValue("runall"))? RUN : DONTRUN)
#if !defined(LEGO) // Lego meeds appwiz case only 
	TEST(CSpyCases,     ((((CMDLINE->GetTextValue("Test")).Find("SPY"))!=(-1))      || CMDLINE->GetBooleanValue("runall")) && (GetUserTargetPlatforms() != PLATFORM_MAC_68K && GetUserTargetPlatforms() != PLATFORM_MAC_PPC)? RUN : DONTRUN)
	TEST(CMultipadCases,((((CMDLINE->GetTextValue("Test")).Find("MULTIPAD"))!=(-1)) || CMDLINE->GetBooleanValue("runall")) && (GetUserTargetPlatforms() != PLATFORM_MAC_68K && GetUserTargetPlatforms() != PLATFORM_MAC_PPC)? RUN : DONTRUN)
	TEST(CWinDiffCases, ((((CMDLINE->GetTextValue("Test")).Find("WINDIFF"))!=(-1))  || CMDLINE->GetBooleanValue("runall")) && (GetUserTargetPlatforms() != PLATFORM_MAC_68K && GetUserTargetPlatforms() != PLATFORM_MAC_PPC)? RUN : DONTRUN)
#endif
END_TESTLIST()

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\DllApi.h ===
#if !(defined (_dllapi_h))
#define _dllapi_h	1

#include <tchar.h>
//#include <stdlib.h>
//#include <windows.h>

// prototype struct for name->pfn mapping
struct MPSZPFN {
	_TCHAR *		szRoutine;
	FARPROC			pfn;
	};

#define DECLARE_DLLAPI(var, map, dll)	CDllApi	var(#dll, g_mpszpfn##map)
#define BEGIN_MPSZPFN(var)				MPSZPFN	g_mpszpfn##var[] = {
#define MPSZPFN_FCN(name)				{#name, 0},
#define END_MPSZPFN(var)				{0,0}};

class CDllApi {
			CDllApi () { }			// private default ctor--have to use the real one below

	BOOL		_fRoutinesOK;			// all routines loaded successfully
	UINT		_cRoutines; 			// count of routines in list
	HINSTANCE	_hInstance;				// handle to the dll
	MPSZPFN	*	_mpszpfn;				// mapping from name to pfn
	_TCHAR		_szDll[ _MAX_PATH ];	// dll name


public:
			CDllApi ( const _TCHAR * szDll, MPSZPFN *  );
			~CDllApi ();
	BOOL	FLoaded () const { 
				return _hInstance != 0;
				}
	BOOL	FRoutinesLoaded () const {
				return _fRoutinesOK;
				}
	FARPROC operator() ( UINT iRoutine ) {
				return _mpszpfn[ iRoutine ].pfn;
				}
	};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\spycases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SPYCASES.CPP
//
//	Created by :			Date :
//		WayneBr				9/28/94
//					  
//	Description :
//		Portable Edit'n Go performance sniff tests

#include "stdafx.h"
#include "percases.h"
#include "spycases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

Project_Info  proj_spy;
Project_Info  *pProj_Spy=&proj_spy;

IMPLEMENT_TEST(CSpyCases, CPerformanceCases, "Med.  C++/MFC: V4 Spy++", -1, CSniffDriver)

void CSpyCases::Run(void)
{
	// Function to add 
	FCN="~void CMsgDoc::Pretend_Dump{(}{)} {{}{TAB}//New fuction to test incremental builds~{TAB}int x=1; //Delete_This_Later~int y;~int z; //Delete_This_Later~~y=2;~z=3.7;~z=y/z;~OutputDebugString{(}\"Pretend dump\"{)};~+{TAB}{}};~";

	//initialization for all tests goes here
	Initialize_Spy();
	pProj_Spy->Time_Start_IDE = GetSubSuite()->GetIDE()->m_dwLaunchTime;

	CPerformanceCases::Run(pProj_Spy);
};


void CSpyCases::Initialize_Spy() {
	pProj_Spy->Project=		"V4 Spy++";
	pProj_Spy->SrcProjDir=	"spyxx.v4";
	pProj_Spy->ProjDir=		"spyxx";
	pProj_Spy->Makefile=	"spyxx\\spyxx2.mak";
	pProj_Spy->Dep_Make=	"spyxx\\spyxxhk2.mak";	
	pProj_Spy->Target=		"target"; 
	pProj_Spy->AddFcn=		FCN;
	pProj_Spy->AddFcn_File=	"msgdoc.cpp";
	pProj_Spy->AddFcn_Line=	1450;
	pProj_Spy->AddDef=		"~void Pretend_Dump{(}{)};~";
	pProj_Spy->AddDef_File=	"msgdoc.h";
	pProj_Spy->AddDef_Line=	99;								   
	pProj_Spy->AddRef=		"~Pretend_Dump{(}{)};~";
	pProj_Spy->AddRef_File=	"msgdoc.cpp";
	pProj_Spy->AddRef_Line=	37;								   
	pProj_Spy->ModCode=		MOD;
	pProj_Spy->Disk_Before=	0;
	pProj_Spy->Disk_After=	0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		TomWh					11/1/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST();

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\foo.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\dll.cpp ===
#include "..\hello1.h"

__declspec(dllexport) void dll_func(void)
{
	shared_func();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\dll.h ===
void dll_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\spycases.h ===
///////////////////////////////////////////////////////////////////////////////
//	SPYCASES.H
//
//	Created by :			Date :
//		WayneBr				10/4/94
//
//	Description :
//		Declaration of the CSpyCases class
//

#ifndef __SPYCASES_H__
#define __SPYCASES_H__

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	BOOL CSpyCases:: class

class CSpyCases : public CPerformanceCases 
{
	DECLARE_TEST(CSpyCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);
	void		Initialize_Spy();

// Data
protected:
	CString 	FCN;

};


#endif // SPYCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\hello1.cpp ===
#include <stdio.h>
#include "hello1.h"
void shared_func(void)
{
   printf("Hello World!");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\wizcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	WIZCASES.H
//
//	Created by :			Date :
//		WayneBr				10/4/94
//
//	Description :
//		Declaration of the CDefAppWizCases class
//

#ifndef __WIZCASES_H__
#define __WIZCASES_H__

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	BOOL CDefAppWizCases:: class

class CDefAppWizCases : public CPerformanceCases 
{
	DECLARE_TEST(CDefAppWizCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);
	void		Initialize_Def_Appwiz();

// Data
protected:
	CString 	FCN;

};


#endif // WIZCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\foo.cpp ===
#include "foo.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by hello.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\hello1.h ===
void shared_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Src\wizcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	WIZCASES.CPP
//
//	Created by :			Date :
//		WayneBr				9/28/94
//					  
//	Description :
//		Portable Edit'n Go performance sniff tests

#include "stdafx.h"
#include "percases.h"
#include "wizcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

Project_Info  proj_def_appwiz;
Project_Info  *pProj_Def_Appwiz=&proj_def_appwiz;

IMPLEMENT_TEST(CDefAppWizCases, CPerformanceCases, "Small C++/MFC: V2 DefAppWiz", -1, CSniffDriver)

void CDefAppWizCases::Run(void)
{
	// Function to add 
	FCN="~void CDefApp::Pretend_Dump{(}{)} {{}{TAB}//New fuction to test incremental builds~{TAB}int x=1; //Delete_This_Later~int y;~int z; //Delete_This_Later~~y=2;~z=3.7;~z=y/z;~OutputDebugString{(}\"Pretend dump\"{)};~+{TAB}{}};~";

	//initialization for all tests goes here
	Initialize_Def_Appwiz();
	pProj_Def_Appwiz->Time_Start_IDE = GetSubSuite()->GetIDE()->m_dwLaunchTime;

	CPerformanceCases::Run(pProj_Def_Appwiz);
};
	

void CDefAppWizCases::Initialize_Def_Appwiz() {
	pProj_Def_Appwiz->Project=		"V2 Default Appwizard";
	pProj_Def_Appwiz->SrcProjDir=	"appwiz.v2";
	pProj_Def_Appwiz->ProjDir=		"appwiz";
	pProj_Def_Appwiz->Makefile=		"appwiz\\def.mak";
	pProj_Def_Appwiz->Dep_Make=		"";	// None
	pProj_Def_Appwiz->Target=		"target"; 
	pProj_Def_Appwiz->AddFcn=		FCN;
	pProj_Def_Appwiz->AddFcn_File=	"def.cpp";
//	pProj_Def_Appwiz->AddFcn_Old=	"defcpp.old";
	pProj_Def_Appwiz->AddFcn_Line=	153;
	pProj_Def_Appwiz->AddDef=		"~void Pretend_Dump{(}{)};~";
	pProj_Def_Appwiz->AddDef_File=	"def.h";
//	pProj_Def_Appwiz->AddDef_Old=	"defh.old";
	pProj_Def_Appwiz->AddDef_Line=	19;								   
	pProj_Def_Appwiz->AddRef=		"~Pretend_Dump{(}{)};~";
	pProj_Def_Appwiz->AddRef_File=	"def.cpp";
//	pProj_Def_Appwiz->AddRef_Old=	"defcpp.old";
	pProj_Def_Appwiz->AddRef_Line=	57;								   
	pProj_Def_Appwiz->ModCode=		MOD;
	pProj_Def_Appwiz->Disk_Before=	0;
	pProj_Def_Appwiz->Disk_After=	0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\Hello.v4\shared.cpp ===
#include <stdio.h>
#include "shared.h"
void shared_func(void)
{
   printf("Hello World!");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\Hello.v4\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by hello.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\Hello.v4\shared.h ===
void shared_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\foo1.cpp ===
#include "foo.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\Hello.v4\dll\dll.h ===
void dll_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\hello.cpp ===
#include <windows.h>
#include "hello1.h"

int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
//        dll_func();
	shared_func();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\Hello.v4\dll\dll.cpp ===
#include "..\shared.h"

__declspec(dllexport) void dll_func(void)
{
	shared_func();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Bin\ProjBld\src\Hello.v4\hello.cpp ===
#include <windows.h>
#include "shared.h"

int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
//        dll_func();
	shared_func();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\bldopts.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BLDOPTS.CPP
//
//	Created by :			Date :
//		ThuyT					01/22/96
//
//	Description :
//		Implementation of the CPrjBuildSettingsTest class

#include "stdafx.h"
#include "prjcases.h"
#include "bldopts.h"
#include <io.h>
 

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPrjBuildSettingsTest, CTest, "Verify Build Setting Options", -1, CSniffDriver)

////////////////////////////////////////////////////////////////////
//	CPrjBuildSettingsTest

void CPrjBuildSettingsTest::Run(void)
{

	XSAFETY;

	//CPrjUtil	PrjUtil;
	szDummyLibrary		 = "DLL\\Release\\DLL.lib";

	szBuildOutputFile	 = m_strCWD + PROJNAME + "\\" + BUILDRES;

	m_pLog->RecordInfo("Verifying build setting options...");
	EXPECT( OpenProject() );
	m_pLog->RecordInfo("Set intermediate directory.");
	SetIntermediateDir();
	m_pLog->RecordInfo("Set output directory.");
	SetOutDir(); 
	m_pLog->RecordInfo("Add additional library.");
	AddLibrary();
	m_pLog->RecordInfo("Build the project...");
	BuildProject();
	m_pLog->RecordInfo("Verify the results...");
	VerifyIntermediateDirectory();
	VerifyOutDirectory();
	VerifyLinkerLibrary();
	EXPECT( CloseProject() );
	m_pLog->RecordInfo("Successfully verify build setting options.");
}

BOOL CPrjBuildSettingsTest::AddLibrary( void )
{
	if (!VERIFY_TEST_SUCCESS( prj.SetProjProperty(CT_LINKER, OPTNLINK_IDC_LIBS, szDummyLibrary))) {
		m_pLog->RecordFailure("Add a library to link");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjBuildSettingsTest::SetIntermediateDir( void )
{
	if (!VERIFY_TEST_SUCCESS( prj.SetProjProperty(CT_GENERAL,VPROJ_IDC_OUTDIRS_INT, NEWEXEINTDIR))) {
		m_pLog->RecordFailure("Change the build intermediate directory from the default");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjBuildSettingsTest::SetOutDir( void )
{
	if (!VERIFY_TEST_SUCCESS( prj.SetProjProperty(CT_GENERAL,VPROJ_IDC_OUTDIRS_TRG, NEWEXEOUTDIR))) {
		m_pLog->RecordFailure("Change the build target directory from the default");
		return FALSE;
	}
	return TRUE;
}


BOOL CPrjBuildSettingsTest::VerifyIntermediateDirectory(void)
{
	//	Check to see if the output directory was created
	CString strPath;

	strPath.Format("%s%s\\*.*", prj.GetDir(), NEWEXEINTDIR);

	WIN32_FIND_DATA fdTemp;
	HANDLE hdFile = FindFirstFile(strPath, &fdTemp);

	if (hdFile == INVALID_HANDLE_VALUE)
	{
		m_pLog->RecordFailure("Intermediate directory %s was not passed to the build tools", strPath);
		return FALSE;
	}
	FindClose(hdFile);
	return TRUE;

}

BOOL CPrjBuildSettingsTest::VerifyOutDirectory(void)
{
	CString strPath;

	strPath.Format("%s%s\\*.*", prj.GetDir(), NEWEXEOUTDIR);

	WIN32_FIND_DATA fdTemp;
	HANDLE hdFile = FindFirstFile(strPath, &fdTemp);

	if (hdFile == INVALID_HANDLE_VALUE)
	{
		m_pLog->RecordFailure("Target directory %s was not passed to the build tools", strPath);
		return FALSE;
	}
	FindClose(hdFile);
	return TRUE;

}

BOOL CPrjBuildSettingsTest::VerifyLinkerLibrary(void)
{
	CString strTemp = prj.GetProjProperty(CT_LINKER, OPTNLINK_IDC_LIBS);
	// Lets check to see if the data was saved during the whole process. 
	if (szDummyLibrary == strTemp)
	{
		return TRUE;
	}
	else
	{
		m_pLog->RecordFailure("Library options was not saved in Project Settings");
		return FALSE;
	}
}

BOOL CPrjBuildSettingsTest::OpenProject( void  )
{
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strCWD + PROJNAME + "\\" + PROJNAME)))
	{
		m_pLog->RecordFailure("Open the project");
		return FALSE;
	}
	// in some cases the damm Source Safe connect dialog will come up
	// lets get rid of it. 
	//if(MST.WButtonExists(GetLabel(IDCANCEL)))
	//	MST.WButtonClick(GetLabel(IDCANCEL));

	return TRUE;
}

BOOL CPrjBuildSettingsTest::BuildProject( void )
{
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	
	if (!VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild))) {
		m_pLog->RecordFailure("Build Project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjBuildSettingsTest::CloseProject( void )
{
	BOOL bSaveProjBeforeClose = TRUE; 
	
	if (!VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose))) {
		m_pLog->RecordFailure("Close the project");
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\cmdlinebld.h ===
// cmdlinebld.h: interface for the CPrjCommandLineBldTest class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CMDLINEBLD_H__611D08C2_8065_11D1_9EE4_00C04FAC5A7C__INCLUDED_)
#define AFX_CMDLINEBLD_H__611D08C2_8065_11D1_9EE4_00C04FAC5A7C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "sniff.h"

class CPrjCommandLineBldTest : public CTest  
{
	DECLARE_TEST(CPrjCommandLineBldTest, CSniffDriver)
public:
	CPrjCommandLineBldTest();
	virtual ~CPrjCommandLineBldTest();
	virtual void Run(void);
	// test methods
	void TestCleanOption(void);

private:
	CString		m_strMSDEVPath;
	COProject	m_prj;
	BOOL SpawnConsoleApp(CString cpEXE, CString cpCmdLine);
	void DoGetLastMessageDlg(char *strFile, int iLineNum);

};

#endif // !defined(AFX_CMDLINEBLD_H__611D08C2_8065_11D1_9EE4_00C04FAC5A7C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\convert.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CONVERT.CPP
//
//	Created by :			Date :
//              ThuyT                           07/05/96
//
//	Description :
//		Implementation of the CPrjConversionTest class
#include "stdafx.h"
#include "prjcases.h"
#include "convert.h"
#include <io.h>
 

#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPrjConversionTest, CTest, "V4.x Makefile Conversion", -1, CSniffDriver)
					   
////////////////////////////////////////////////////////////////////
//	CPrjConversionTest


void CPrjConversionTest::Run(void)
{
	CPrjUtil PrjUtil;
	CString szProjSRCLoc = m_strCWD + "src" + "\\Hello.V4";
	szProjEXELoc		 = m_strCWD + V4PROJDIR + "\\";

	m_pLog->RecordInfo("Verify V4.x Makefile Conversion...");

	//	added by dverma 6/20/2000
	m_pLog->RecordInfo("V4.x Makefile Conversion Test disabled due to postponed VS98 bug 49148.");
	return;

	PrjUtil.RemoveTestFiles( szProjEXELoc );
	if(!CreateDirectory(szProjEXELoc, NULL))
	{
		_TCHAR szMsg[256+_MAX_PATH];
		wsprintf(szMsg, "Can't create directory %s.", szProjEXELoc);
		m_pLog->RecordFailure(szMsg);
		return;
	}

	//Copy v4.x project to a working directory
	{
		_TCHAR szSourceDir[_MAX_PATH];
		lstrcpy(szSourceDir, szProjSRCLoc);
		int iLen = lstrlen(szSourceDir);
		ASSERT(iLen);
		_TCHAR* pszEnd = &szSourceDir[iLen];
		ASSERT(!*pszEnd);
		pszEnd = _tcsdec(szSourceDir, pszEnd);
		if(_tcsncmp(pszEnd, _T("\\"), 1))
			lstrcat(pszEnd, _T("\\"));
		lstrcat(szSourceDir, "*.*");

		WIN32_FIND_DATA ffdImgFile;
		HANDLE hFile = FindFirstFile(szSourceDir, &ffdImgFile);
		if( hFile == INVALID_HANDLE_VALUE )
		{
			_TCHAR szMsg[256+_MAX_PATH];
			wsprintf(szMsg, "Can't find files to copy from %s", szProjSRCLoc);
			m_pLog->RecordFailure(szMsg);
			return;
		}

	}
	if(!CopyTree ( szProjSRCLoc, szProjEXELoc))
	{
		_TCHAR szMsg[256 + 2*_MAX_PATH];
		wsprintf("Can't CopyTree() from %s to %s", szProjSRCLoc, szProjEXELoc);
		m_pLog->RecordFailure(szMsg);
		return;
	}

	// load v4.x makefile into Orion workspace
	m_pLog->RecordInfo("Open v4.x makefile...");
	EXPECT( OpenProject( PROJNAME) );
	//Bug #13391: conversion - set active project doesn't get restored correctly
	//Thus we need to set active configuration manually to workaround this problem
	//If this bug is fixed in the later version we can comment this line out.
    m_pLog->RecordInfo("Set active project/configuration to Hello Win32 Release");
	prj.SetTarget(EXERELEASETARGET);
	m_pLog->RecordInfo("Build Hello project...");
	BuildProject();
	m_pLog->RecordInfo("Verify build....");
	VerifyBuild( TRUE);
	m_pLog->RecordInfo("Close the project...");
	EXPECT ( CloseProject() );
	m_pLog->RecordInfo("Verify conversion of .dsp, .dsw, and .mak files");
	VerifyConversion();
	
	m_pLog->RecordInfo("Reopen the project to make sure it is loadable after the conversion...");
	EXPECT( OpenProject( PROJNAME) );
	m_pLog->RecordInfo("Build the project.  Don't expect any re-compiling or re-linking since nothing change...");
	BuildProject();
	VerifyBuild( FALSE);
	EXPECT ( CloseProject() );
	m_pLog->RecordInfo("Close the project");
	m_pLog->RecordInfo("Verify makefile conversion is complete.");
}


BOOL CPrjConversionTest::VerifyBuild( BOOL iBuild)
{
	CPrjUtil	PrjUtil;
	CString		szDLLProj = "dll";
	// Get the output window contents
	CString szBldLog = PrjUtil.GetBldLog();
	CString exe = "Hello - Win32 Release" ;
	CString dll = "Dll - Win32 Release" ;
	dll.MakeLower();
	exe.MakeLower();

	// For some reason the output window text is always lower case when extracted.
	int iFoundDLLLibrary = szBldLog.Find(dll);
	int iFoundEXEBinary = szBldLog.Find(exe);

	// Get the output window contents
//	CString szBldLog = PrjUtil.GetBldLog();
//	int iFoundDLLLibrary = szBldLog.Find("configuration: " + szDLLProj);
//	int iFoundEXEBinary = szBldLog.Find("configuration: hello");

//	int iFoundDLLLibrary = PrjUtil.Find(dll);
//	int iFoundEXEBinary = PrjUtil.Find(exe);



	if ( iBuild ) {
		if ( iFoundDLLLibrary < 0 ) {
			m_pLog->RecordFailure("DLL subproject didn't get built.");
			return FALSE;
		}
		if ( iFoundEXEBinary < 0 ) {
			m_pLog->RecordFailure("Hello EXE didn't get built.");
			return FALSE;
		}

		if ( iFoundDLLLibrary > iFoundEXEBinary ) {
			m_pLog->RecordFailure("DLL subproject should be built first.");
			return FALSE;
		}
	}
	else {
		int iFoundCPP = szBldLog.Find (".cpp");
		if ( iFoundCPP > 0 ) {
			m_pLog->RecordFailure("Nothing change, the project shouldn't be rebuilt.");
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CPrjConversionTest::VerifyBLD( CString szFileName )
{
	//Check existant of .dsp files : 
	//Also make sure no dependency list included in the file.
	if (GetFileAttributes(szFileName) == -1 ) {
		m_pLog->RecordFailure("Can't find %s", szFileName);
		return FALSE;
	}
	else if (FindStrInFile(szFileName, "DEP_") > 0 ) { //found it
		m_pLog->RecordFailure("Found 'DEP_' list in %s file", szFileName);
		return FALSE;
	}
    return TRUE;
}
BOOL CPrjConversionTest::VerifyConversion( void )
{
	//Check .dsp files : expect to have Hello.dsp and Dll.dsp files
	VerifyBLD(szProjEXELoc + "Hello" + PRJEXTENSION);
	VerifyBLD(szProjEXELoc + "DLL\\DLL" + PRJEXTENSION);
	
	//Check DSW file
	if (FindStrInFile(szProjEXELoc + "Hello" + WSPEXTENSION, "Dll" ) == 0)  {
		m_pLog->RecordFailure("DLL project is not included in file %s", szProjEXELoc + "Hello" + WSPEXTENSION);
	}

	//Check .mak file: NYI
	return TRUE;
}


BOOL CPrjConversionTest::OpenProject( CString szProjectName  )
{
	if (!VERIFY_TEST_SUCCESS( prj.Open(szProjEXELoc + szProjectName))) {
		m_pLog->RecordFailure("Open project %s", szProjectName);
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjConversionTest::BuildProject( void )
{
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	
	if (!VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild))) {
		m_pLog->RecordFailure("Build Project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjConversionTest::CloseProject( void )
{
	BOOL bSaveProjBeforeClose = TRUE; 
	
	if (!VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose))) {
		m_pLog->RecordFailure("Close the project");
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\convert.h ===
///////////////////////////////////////////////////////////////////////////////
//	SUBPRJS.H
//
//	Created by :			Date :
//              ThuyT                                   07/05/96
//
//	Description :
//		Declaration of the CPrjAppTest class
//

#ifndef __CONVERT_H__
#define __CONVERT_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"
///////////////////////////////////////////////////////////////////////////////
//	CPrjConversionTest class

class CPrjConversionTest : public CTest
{
	DECLARE_TEST(CPrjConversionTest, CSniffDriver)

// Operations
public:
	virtual void Run(void);

protected:
	CString szProjEXELoc;
	COProject prj;

	BOOL VerifyBuild( BOOL Build );
	BOOL CloseProject( void );
	BOOL OpenProject( CString ProjectName );
	BOOL BuildProject( void );
	BOOL VerifyBLD ( CString szFileName);
	BOOL VerifyConversion( void );
};

#endif  //__CONVERT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\bldopts.h ===
///////////////////////////////////////////////////////////////////////////////
//	BLDOPTS.H
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Declaration of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//

#ifndef __BLDOPTS_H__
#define __BLDOPTS_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"
///////////////////////////////////////////////////////////////////////////////
//	CPrjBuildSettingsTest class

class CPrjBuildSettingsTest : public CTest
{
	DECLARE_TEST(CPrjBuildSettingsTest, CSniffDriver)

// Operations
public:
	virtual void Run(void);

protected:
	CString szDummyLibrary;
	COProject prj;
	CString szBuildOutputFile;

	BOOL AddLibrary( void );
	BOOL SetIntermediateDir( void );
	BOOL SetOutDir( void );
	BOOL VerifyIntermediateDirectory( void );
	BOOL VerifyOutDirectory( void );
	BOOL VerifyLinkerLibrary( void );
	BOOL CloseProject( void );
	BOOL OpenProject( void  );
	BOOL BuildProject( void );
};
#endif //__BLDOPTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\custbld.h ===
///////////////////////////////////////////////////////////////////////////////
//	CUSTBLD.H
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Declaration of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//

#ifndef __CUSTBLD_H__
#define __CUSTBLD_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	CPrjCustomBuildTest class

class CPrjCustomBuildTest : public CTest
{
	DECLARE_TEST(CPrjCustomBuildTest, CSniffDriver)

// Operations
public:
	virtual void Run(void);

protected:
	COProject prj;
	CString szProjEXELoc;

	BOOL SetCustomBuild( void);
	BOOL VerifyCustomBuild( void );
	BOOL CloseProject( void );
	BOOL OpenProject( void  );
	BOOL BuildProject( void );
};

#endif //__CUSTBLD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\custbld.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CUSTBLD.CPP
//
//	Created by :			Date :
//		ThuyT				02/06/96
//
//	Description :
//		Implementation of the CPrjCustomBuildTest class

#include "stdafx.h"
#include "prjcases.h"
#include "custbld.h"
 
#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPrjCustomBuildTest, CTest, "Verify Custom Build Rules", -1, CSniffDriver)
////////////////////////////////////////////////////////////////////
//	CPrjCustomBuildTest

void CPrjCustomBuildTest::Run(void)
{
	szProjEXELoc = m_strCWD + PROJNAME + "\\";
	m_pLog->RecordInfo("Verify custom build rules...");
	EXPECT( OpenProject() );
	prj.SetTarget(EXERELEASETARGET);
	prj.SetProjProperty(CT_GENERAL,VPROJ_IDC_OUTDIRS_TRG, NEWEXEOUTDIR);
	m_pLog->RecordInfo("Set custom build rules.");
	SetCustomBuild();
	m_pLog->RecordInfo("Build the project....");
	BuildProject();
	m_pLog->RecordInfo("Verify the resutls...");
	VerifyCustomBuild();
	EXPECT( CloseProject() );
	// Reload the project. Make sure Multi custom build rules are read back properly.
 	m_pLog->RecordInfo("Reload the project to make sure multi custom build rules are read back properly....");
	KillFile(szProjEXELoc + NEWEXEOUTDIR,"echo1.out");
	KillFile(szProjEXELoc + NEWEXEOUTDIR,"echo2.out");
	Sleep(250);
	EXPECT( OpenProject() );    
	m_pLog->RecordInfo("Build the project....");
	BuildProject();
	m_pLog->RecordInfo("Verify the resutls...");
	VerifyCustomBuild();
	EXPECT( CloseProject() );

	m_pLog->RecordInfo("Successfully set and run custom build rules.");
}

BOOL CPrjCustomBuildTest::SetCustomBuild( void )
{
	CString desc = "Generate echo1.out and echo2.out files...";
	CStringArray bld_cmds;
	bld_cmds.Add("echo \"ProjDir=$(ProjDir)\" > .\\$(OutDir)\\echo1.out");
	bld_cmds.Add("echo \"TargetName=$(TargetName)\" > .\\$(OutDir)\\echo2.out");
	CStringArray output_files;
	output_files.Add("$(OutDir)\\echo1.out");
	output_files.Add("$(OutDir)\\echo2.out");
	ConfigStrArray configs;
	configs.Add(PROJNAME, PLATFORM_WIN32_X86, BUILD_RELEASE );

	if ( !VERIFY_TEST_SUCCESS(prj.SetCustomBuildOptions(desc, bld_cmds, output_files, configs )))
	{
		m_pLog->RecordFailure("Change custom build options.");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjCustomBuildTest::VerifyCustomBuild( void )
{
// Make sure the outfile is generated.
	CFileStatus status;
	CString szOutName1 = szProjEXELoc + NEWEXEOUTDIR + "\\echo1.out";
	CString szOutName2 = szProjEXELoc + NEWEXEOUTDIR + "\\echo2.out";
	if (!CFile::GetStatus(szOutName1, status))  {
		m_pLog->RecordFailure("Custom build failed: %s file not found", szOutName1);
		return FALSE;
	}

	if (!CFile::GetStatus(szOutName2, status))  {
		m_pLog->RecordFailure("Custom build failed: %s file not found", szOutName2);
		return FALSE;
	}
return TRUE;

}

BOOL CPrjCustomBuildTest::OpenProject( void  )
{
	if (!VERIFY_TEST_SUCCESS( prj.Open(szProjEXELoc + PROJNAME))) {
		m_pLog->RecordFailure("Open the project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjCustomBuildTest::BuildProject( void )
{
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	
	if (!VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild))) {
		m_pLog->RecordFailure("Build Project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjCustomBuildTest::CloseProject( void )
{
	BOOL bSaveProjBeforeClose = TRUE; 
	
	if (!VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose))) {
		m_pLog->RecordFailure("Close the project");
		return FALSE;
	}
//	m_pLog->RecordInfo("Closing the project successfully");
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\cmdlinebld.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CMDLINEBLD.CPP
//
//	Created by :			Date :
//		BrickB					12/29/97
//
//	Description :
//		Implementation of the CPrjCommandLineBldTest class
//		This test will take a close look at msdev.com - the command line build
//		When launched it should build a project file the same as the full IDE would
//		Without bringing up the UI. 
//
//		TestCleanOption:				Do a /CLEAN option only

#include "stdafx.h"
#include "cmdlinebld.h"
#include "prjcases.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IMPLEMENT_TEST(CPrjCommandLineBldTest, CTest, "Verify Command Line Build", -1, CSniffDriver)

CPrjCommandLineBldTest::CPrjCommandLineBldTest()
{

}

CPrjCommandLineBldTest::~CPrjCommandLineBldTest()
{

}

void CPrjCommandLineBldTest::Run(void)
{
	//COProject prj;
	LPTSTR lpszJunk;

	// TODO: This need to know if to use the debug instead. Need more hooks into CAFE.
	// 
	CString strMSDEV = "msdev.com";

	// need to hunt down where the BIN directory is using the CAFE "Executable Path"
	CIDESubSuite* pSubSuite=(CIDESubSuite*)GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only
	// get the toolset environment settings.
	CSettings *settingsToolsetEnv = pSubSuite->GetToolset()->GetEnvSettings();
	// get the PATH string
	CString cstrPathEnv = settingsToolsetEnv->GetTextValue(settingPathEnv);

	m_pLog->RecordInfo("Search Path = %s", cstrPathEnv);

	CString strTemp;
		
	SearchPath(cstrPathEnv, strMSDEV, NULL, MAX_PATH, strTemp.GetBuffer(MAX_PATH), &lpszJunk);
	
	if (strTemp == "")
	{
		m_pLog->RecordFailure("%s - file not found in search path.", strMSDEV);
		return;
	}
	// lets work with short paths.
	::GetShortPathName(strTemp, m_strMSDEVPath.GetBuffer(MAX_PATH), MAX_PATH), 

	m_pLog->RecordInfo("Tool: MSDEV.com");
	m_pLog->RecordInfo("  MSDEV.com path: %s", m_strMSDEVPath);

	TestCleanOption();

}

// TEST /CLEAN
// this will build the Hello project and make note of the files in the output folder
// it will then attempt to delete these files using the command line build tool 
// with the /CLEAN option
void CPrjCommandLineBldTest::TestCleanOption(void)
{
	
	m_pLog->RecordInfo("Command Line Build Test with /CLEAN Option...");

	// Open a standard project
	if (!VERIFY_TEST_SUCCESS( m_prj.Open(m_strCWD + PROJNAME + "\\" + PROJNAME)))
	{
		m_pLog->RecordFailure("CPrjCommandLineBldTest::TestCleanOption - Open the project");
		return;
	}
	CString strTarget = PROJNAME;
	strTarget += " - Win32 Debug";
	// set the Debug build
	if (!VERIFY_TEST_SUCCESS( m_prj.SetTarget(strTarget)))
	{
		m_pLog->RecordFailure("CPrjCommandLineBldTest::TestCleanOption - Set Target");
		return;
	}

	// lets build the Debug version
	if (!VERIFY_TEST_SUCCESS( m_prj.Build(4))) 
	{
		m_pLog->RecordFailure("CPrjCommandLineBldTest::TestCleanOption - Build Project");
		return;
	}

	// Check to see if there are output files like Obj's and an EXE
	CString strOutFile = m_prj.GetOutputFile();

	// lets make sure the output file is there
	WIN32_FIND_DATA fdTemp;
	HANDLE hdFile = FindFirstFile(strOutFile, &fdTemp);
	m_pLog->RecordInfo("Check to see if %s was built", strOutFile);
	if (hdFile == INVALID_HANDLE_VALUE)
	{
		m_pLog->RecordFailure("CPrjCommandLineBldTest::TestCleanOption - Output file %s not found", strOutFile);
		return;
	}
	FindClose(hdFile);

	// Now lets run the Command Line Build deal with the /CLEAN Option

	char drive[_MAX_DRIVE];   char dir[_MAX_DIR];
	char fname[_MAX_FNAME];   char ext[_MAX_EXT];

	_splitpath( strOutFile, drive, dir, fname, ext );

	CString strCommandLine;
	
	strCommandLine.Format("\"%s\" /MAKE \"%s\" /CLEAN", m_prj.GetFullPath(), strTarget);

	m_pLog->RecordInfo("Command Line for msdev.com: %s %s", m_strMSDEVPath, strCommandLine);

	if (!SpawnConsoleApp(m_strMSDEVPath, strCommandLine)) 
	{
		m_pLog->RecordFailure("CPrjCommandLineBldTest::TestCleanOption - Could not start msdev.com");
		return;
	}

	// The Output files should be gone now
	// lets look in the output directory to see what is there. 
	// guess what? The Itermidate Dir can be different than the OutputFile.
	// first look for the Output File
	m_pLog->RecordInfo("Checking for EXE files in %s", strOutFile);
	hdFile = FindFirstFile(strOutFile, &fdTemp);
	if (hdFile != INVALID_HANDLE_VALUE)
	{
		m_pLog->RecordFailure("CPrjCommandLineBldTest::TestCleanOption - Output file %s was not CLEANed", strOutFile);
		FindClose(hdFile);
		return;
	}
	
	// now there should be no OBJ files in this folder
	strOutFile.Format("%s\\%s\\*.obj", m_prj.GetDir(), m_prj.GetIntermediateDir());
	m_pLog->RecordInfo("Checking for OBJ files in %s", strOutFile);

	hdFile = FindFirstFile(strOutFile, &fdTemp);
	if (hdFile != INVALID_HANDLE_VALUE)
	{
		m_pLog->RecordFailure("CPrjCommandLineBldTest::TestCleanOption - Output file %s was not CLEANed - Still contains OBJ Files", strOutFile);
		FindClose(hdFile);
		return;
	}

	// if we made it here, all is good for this test.

	m_pLog->RecordSuccess("Command Line Build CPrjCommandLineBldTest::TestCleanOption -- Passed");

	return;
}


// a Standard way to spawn the msdev.com file since it as a console app. 
BOOL CPrjCommandLineBldTest::SpawnConsoleApp(CString strEXE, CString strCmdLine)
{

	BOOL bSuccess = FALSE;

	STARTUPINFO si;  /* for CreateProcess call */
	PROCESS_INFORMATION pi;  /* for CreateProcess call */

	/* Set up the STARTUPINFO structure for the CreateProcess() call */
	memset(&si, 0, sizeof(si));
	si.cb = sizeof(si);

	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_NORMAL;

	/* Now create the child process */
	char cstrTempEXE[MAX_PATH];
	char cstrTempCMDLine[MAX_PATH*2];

	strcpy(cstrTempEXE, strEXE);
	// DOS applications need to have program and command line tack together
	strcpy(cstrTempCMDLine, cstrTempEXE);
	strcat(cstrTempCMDLine, " ");
	strcat(cstrTempCMDLine, strCmdLine);

	bSuccess = CreateProcess(cstrTempEXE,  /* filename */
			cstrTempCMDLine,  /* full command line for child */
			NULL,  /* process security descriptor */
			NULL,  /* thread security descriptor */
			FALSE,  /* inherit handles? Also use if STARTF_USESTDHANDLES */
			NORMAL_PRIORITY_CLASS,  /* creation flags */
			NULL,  /* inherited environment address */
			NULL,  /* startup dir; NULL = start in current */
			&si,  /* pointer to startup info (input) */
			&pi);  /* pointer to process info (output) */

	if (bSuccess == 0)
		DoGetLastMessageDlg(__FILE__, __LINE__);

	DWORD dw = WaitForSingleObject(pi.hProcess, 60000);

	if (WAIT_OBJECT_0 != dw)
	{
		DoGetLastMessageDlg(__FILE__, __LINE__);
		return FALSE;
	}
	
	DWORD dwExitCode;

	if (!GetExitCodeProcess(pi.hProcess, &dwExitCode))
	{
		return FALSE;
	}

	bSuccess = CloseHandle(pi.hThread);
	bSuccess &= CloseHandle(pi.hProcess);

	return bSuccess;
}

// just a way to get at the system error to help track down why we have a failure
void CPrjCommandLineBldTest::DoGetLastMessageDlg(char *strFile, int iLineNum)
{
	LPVOID lpMsgBuf;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL );// Process any inserts in lpMsgBuf.
	// ...// Display the string.

	char strTemp[_MAX_PATH];

	sprintf(strTemp, "%s, %i, %s", strFile, iLineNum, (char *)lpMsgBuf);

#ifdef _DEBUG
	::MessageBox( NULL, strTemp, "Error", MB_OK | MB_ICONINFORMATION );
#endif
	
	m_pLog->RecordFailure(strTemp);

	// Free the buffer.
	LocalFree( lpMsgBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\extmak.h ===
///////////////////////////////////////////////////////////////////////////////
//	EXTMAK.H
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Declaration of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//

#ifndef __EXTMAK_H__
#define __EXTMAK_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"
///////////////////////////////////////////////////////////////////////////////
//	CPrjExternalMAKTest class

class CPrjExternalMAKTest : public CTest
{
	DECLARE_TEST(CPrjExternalMAKTest, CSniffDriver)

// Operations
public:
	virtual void Run(void);

protected:
	CString szExternalProject;
	CString szNewExternalProject;
	COProject prj;

	BOOL PrepareExtProject( void );
	BOOL OpenExtProject( void );
	BOOL SetExtDebugOption( void );
	BOOL SetExtBuildCmdLine( void );
	BOOL CloseProject( void );
	BOOL BuildProject( void );
};

#endif __EXTMAK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\prjcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	PRJCASES.H
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Declaration of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//

#ifndef __PRJCASES_H__
#define __PRJCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

// Global variables
extern CString cstrRelease ;// =  GetLocString(IDSS_BUILD_RELEASE);
extern CString EXERELEASETARGET; //= "Hello - Win32 " + cstrRelease;
extern CString DLLRELEASETARGET; //= "DLL - Win32 " + cstrRelease;





///////////////////////////////////////////////////////////////////////////////
//	CPrjAppTest class

class CPrjAppTest : public CTest
{
	DECLARE_TEST(CPrjAppTest, CSniffDriver)

// Operations
public:
	virtual BOOL RunAsDependent(void);
	virtual void PreRun(void);
	virtual void Run(void);
	BOOL CloseProject( void );

public:
	CString m_strCurDir;
	CString szBuildToolsLoc;
	CString szProjEXELoc;	
 		
// Test Cases
protected:
	COProject prj;

	BOOL CreateNewProject( void );
	BOOL AddFilesToEXEProject( void );
	BOOL SaveProject( void );

};

///////////////////////////////////////////////////////////////////////////////
//	CPrjUtil class
class CPrjUtil
{
//		DECLARE_TEST(CPrjUtil, CSniffDriver)
public:

	void RemoveTestFiles( CString szProjLoc );
	BOOL TouchFile( CString szFileName );
	time_t GetFileTime( CString szFileName );
	BOOL SetToolsDir( CString szToolsLoc );
	BOOL RemoveToolsDir( CString szToolsLoc );
	CString GetBldLog();
};

#endif //__PRJCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\extmak.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EXTMAK.CPP
//
//	Created by :			Date :
//		ThuyT				02/06/96
//
//	Description :
//		Implementation of the CPrjExternalMAKTest class
#include "stdafx.h"
#include "prjcases.h"
#include "extmak.h" 

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPrjExternalMAKTest, CTest, "Loading External MAK", -1, CSniffDriver)
////////////////////////////////////////////////////////////////////
//	CPrjExternalMAKTest

void CPrjExternalMAKTest::Run(void)
{
	XSAFETY;

	CPrjUtil	PrjUtil;
	szExternalProject	 = m_strCWD + PROJNAME + "\\extern.mak";
	szNewExternalProject = m_strCWD + PROJNAME + "\\newextrn.mak";

	m_pLog->RecordInfo("Loading an external makefile...");
	EXPECT( PrepareExtProject() );
	EXPECT( OpenExtProject() );
	m_pLog->RecordInfo("Changing external debug option.");
	SetExtDebugOption();
	m_pLog->RecordInfo("Changing external build command line.");
	SetExtBuildCmdLine();
	PrjUtil.SetToolsDir(m_strCWD + TOOLSDIR);
	m_pLog->RecordInfo("Build the project...");
	BuildProject();
	PrjUtil.RemoveToolsDir(m_strCWD + TOOLSDIR);
	EXPECT( CloseProject() );
	m_pLog->RecordInfo("Successfully loading an external makefile.");
}

BOOL CPrjExternalMAKTest::OpenExtProject( void )
{
	int ret = TRUE;

	if (!VERIFY_TEST_SUCCESS( prj.Open(szNewExternalProject))) {
		m_pLog->RecordFailure("Open external makefile");
		ret = FALSE;
	}
	return ret;
}	

BOOL CPrjExternalMAKTest::CloseProject( void )
{
	BOOL bSaveProjBeforeClose = FALSE; 
	
	if (!VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose))) {
		m_pLog->RecordFailure("Close the project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjExternalMAKTest::BuildProject( void )
{
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	
	if (!VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild))) {
		m_pLog->RecordFailure("Build Project");
		return FALSE;
	}
	return TRUE;
}
	

BOOL CPrjExternalMAKTest::SetExtDebugOption( void )
{
	CString szNewDebugTarget	 = "testing.exe";

	if (!VERIFY_TEST_SUCCESS( prj.SetProjProperty(CT_EXT_DBGOPTS, VPROJ_IDC_EXTOPTS_TARGET, szNewDebugTarget))) {
		m_pLog->RecordFailure("Change the debug target name");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjExternalMAKTest::SetExtBuildCmdLine( void )
{
	CString	szDummyBuildTool	= m_strCWD + TOOLSDIR + "\\cl.exe";

	if (!VERIFY_TEST_SUCCESS(prj.SetBuildCommand( szDummyBuildTool ))) {
		m_pLog->RecordFailure("Change the build command line to use dummy tools");
		return FALSE;
	}
	return TRUE;
}			

BOOL CPrjExternalMAKTest::PrepareExtProject(void)
{
//	Copy sample makefile to a new name so that we don't use the one 
//	enlisted in the project. 
	if (!CopyFile(szExternalProject, szNewExternalProject, FALSE) )
	{
		m_pLog->RecordFailure("The external makefile copy did not execute correctly.");
		return FALSE;
	}                
	else 
	{	//	Make sure that new file is not marked read-only. If so, make it 
		//	read/write so that it can be modified
		SetFileAttributes(szNewExternalProject, FILE_ATTRIBUTE_NORMAL);
		return TRUE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\scandep.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SCANDEP.CPP
//
//	Created by :			Date :
//              ThuyT                   02/09/96
//
//	Description :
//              Implementation of the CPrjScanDepTest class
#include "stdafx.h"
#include "prjcases.h"
#include "scandep.h"
#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h>
#include <errno.h>
 

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPrjScanDepTest, CTest, "Verify Scan Dependencies", -1, CSniffDriver)
////////////////////////////////////////////////////////////////////
//	CPrjScanDepTest

void CPrjScanDepTest::Run(void)
{
	CPrjUtil	PrjUtil;
	szProjEXELoc = m_strCWD + PROJNAME + "\\";
	
	// Open the project
	m_pLog->RecordInfo("Verify file dependencies...");
	EXPECT( OpenProject() );

	// Initial the test case
	prj.SetTarget(EXERELEASETARGET);	
	prj.SetProjProperty(CT_GENERAL,VPROJ_IDC_OUTDIRS_INT, NEWEXEINTDIR);
	PrjUtil.RemoveToolsDir(m_strCWD + TOOLSDIR);

	// Build the project.  Expect Hello.cpp to compile.
	m_pLog->RecordInfo("Touch hello1.h");
	PrjUtil.TouchFile( szProjEXELoc + "Hello1.h" );
	m_pLog->RecordInfo("Build the project...");
	BuildProject();
	m_pLog->RecordInfo("Verify results...");
	VerifyResults( "hello1.cpp" );

	// Add Foo.cpp file to project
	m_pLog->RecordInfo("Add foo.cpp to the project.");
	prj.AddFiles( "foo.cpp", PROJNAME );

	// Build the project
	m_pLog->RecordInfo("Build the project...");
	BuildProject();

	// Build the project.  Expect Foo.cpp to compile.
	Sleep(1001); // Pause to let the time increase enough to be noticed
	m_pLog->RecordInfo("Touch foo.h");
	PrjUtil.TouchFile( szProjEXELoc + "foo.h" );
	m_pLog->RecordInfo("Build the project...");
	Sleep(1001); // Pause before build to let the touch take
	BuildProject();
	m_pLog->RecordInfo("Verify results...");
	VerifyResults( "foo.cpp" );

}


BOOL CPrjScanDepTest::VerifyResults( CString szSourceName )
{
	CPrjUtil	PrjUtil;

	// Get the output window contents
	CString szBldLog = PrjUtil.GetBldLog();
	if (szBldLog.Find(szSourceName) < 0 ) {
		m_pLog->RecordFailure("File %s didn't get compiled", szSourceName);
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjScanDepTest::OpenProject( void  )
{
	if (!VERIFY_TEST_SUCCESS( prj.Open(szProjEXELoc + PROJNAME))) {
		m_pLog->RecordFailure("Open the project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjScanDepTest::BuildProject( void )
{
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	
	if (!VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild))) {
		m_pLog->RecordFailure("Build Project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjScanDepTest::CloseProject( void )
{
	BOOL bSaveProjBeforeClose = TRUE; 
	
	if (!VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose))) {
		m_pLog->RecordFailure("Close the project");
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\prjcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	PRJCASES.CPP
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Implementation of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//		DorianG - Seized control and made fixes for V3 UI changes - 10/1/94
//		ThuyT - Splitted test cases into trival subsuites.  2/06/96.

#include "stdafx.h"
#include "prjcases.h"
#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPrjAppTest, CTest, "Creating Application Project", -1, CSniffDriver)

// Global variables
CString cstrRelease  =  GetLocString(IDSS_BUILD_RELEASE);
CString EXERELEASETARGET = "Hello - Win32 " + cstrRelease;
CString DLLRELEASETARGET = "DLL - Win32 " + cstrRelease;

BOOL CPrjAppTest::RunAsDependent(void)
{
	// name of the project file
	CString strProjFile = m_strCWD + PROJNAME + "\\" + PROJMAKFILE;

	// if the project file exists, there's no need to run this test as a dependency
	if (_access(strProjFile, 0) != -1) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

void CPrjAppTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
	szProjEXELoc		 = m_strCWD + PROJNAME + "\\";

}

////////////////////////////////////////////////////////////////////
//	CPrjAppTest

void CPrjAppTest::Run(void)
{	 
	XSAFETY;

	CPrjUtil PrjUtil;


 	m_pLog->RecordInfo("Creating an Application project...");
	PrjUtil.RemoveTestFiles( szProjEXELoc );
	EXPECT( CreateNewProject() );
	m_pLog->RecordInfo("Insert files to the project.");
	EXPECT( AddFilesToEXEProject() );
	m_pLog->RecordInfo("Save the project.");
	EXPECT( SaveProject() );
	EXPECT( CloseProject() );
	m_pLog->RecordInfo("Successfully creating an Application project.");
}

BOOL CPrjAppTest::CreateNewProject( void )
{
	if (!VERIFY_TEST_SUCCESS( prj.NewProject( EXE, PROJNAME, szProjEXELoc, PLATFORMS))) {
 		m_pLog->RecordFailure("Create an Application project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjAppTest::AddFilesToEXEProject( void )
{
	CString szEXECPPFiles	= szProjEXELoc + "Hello*.cpp";
	CString szEXECPPFile_1	= szProjEXELoc + "Hello1.cpp";
	CString szEXECPPFile_2	= szProjEXELoc + "Hello.cpp";
	CString szEXERCFiles	= szProjEXELoc + "Hello.rc";
	CString szSRCFileLoc	= m_strCWD + "src\\";
	CString szPattern		= szSRCFileLoc + "*.*";
	
	// Copy Hello.cpp Hello1.cpp and Hello.rc files to "Hello" directory
	WIN32_FIND_DATA ffdImgFile;
    HANDLE hFile = FindFirstFile(szPattern, &ffdImgFile);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
			CopyFile( szSRCFileLoc + ffdImgFile.cFileName, szProjEXELoc + ffdImgFile.cFileName, FALSE );
			SetFileAttributes(szProjEXELoc + ffdImgFile.cFileName, FILE_ATTRIBUTE_NORMAL ); 
		}
        while( FindNextFile(hFile, &ffdImgFile) );
        EXPECT( GetLastError() == ERROR_NO_MORE_FILES );
    }

	// Add Hello.cpp Hello1.cpp and Hello.rc files
	// can't do a multi add file on NT5. It's causing an Exception in the Dialog when Cafe
	// is hooked msdev as the debugger. This is a hack since this problem never exists
	// when doing manual a manaul test pass.
	if(GetSystem() & SYSTEM_NT_5)
	{
		if (!VERIFY_TEST_SUCCESS( prj.AddFiles( szEXECPPFile_1, PROJNAME )))
		{
			m_pLog->RecordFailure("Couldn't add CPP files to EXE project");
			return FALSE;
		}
		if (!VERIFY_TEST_SUCCESS( prj.AddFiles( szEXECPPFile_2, PROJNAME )))
		{
			m_pLog->RecordFailure("Couldn't add CPP files to EXE project");
			return FALSE;
		}
	}
	else   // do a multi add for all else
	{
		if (!VERIFY_TEST_SUCCESS( prj.AddFiles( szEXECPPFiles, PROJNAME )))
		{
			m_pLog->RecordFailure("Couldn't add CPP files to EXE project");
			return FALSE;
		}
	}
	
	if (!VERIFY_TEST_SUCCESS( prj.AddFiles( szEXERCFiles, PROJNAME ))) {
		m_pLog->RecordFailure("Couldn't add RC files to EXE project");
		return FALSE;
	}
	return TRUE;
}	

BOOL CPrjAppTest::SaveProject( void )
{
	if (!VERIFY_TEST_SUCCESS( prj.Save())) {
		m_pLog->RecordFailure("Save the project");
		return FALSE;
	}
	return TRUE;
}	

BOOL CPrjAppTest::CloseProject( void )
{
	BOOL bSaveProjBeforeClose = FALSE; 
	
	if (!VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose))) {
		m_pLog->RecordFailure("Close the project");
		return FALSE;
	}
	return TRUE;
}	


///////////////////////////////////////////////////////////
// CPrjUtil
///////////////////////////////////////////////////////////
void CPrjUtil::RemoveTestFiles( CString szProjLoc )
{
	KillAllFiles( szProjLoc );
}
	
BOOL CPrjUtil::TouchFile( CString szFileName )
{
	if (GetSystem() & SYSTEM_WIN)
		Sleep(3000);

	if ( _utime( szFileName, NULL ) == -1 ) {
		return FALSE;
	}
	// Because Win95 has some silly file commit thing that will cause this touch
	// not to commit before another process reads the file
	// we will let this process take a nap for a moment.
	if (GetSystem() & SYSTEM_WIN)
		Sleep(3000);

	return TRUE;
}

time_t CPrjUtil::GetFileTime( CString szFileName )
{
	struct _stat buf;
	int result = _stat( szFileName, &buf );
	return( buf.st_mtime );
}

BOOL CPrjUtil::SetToolsDir(CString szToolsLoc)
{
//	Set build tools directory to point to dummy build tools (which
//	must be provided by us)

	COEnvironment OptionsDirectories;
	
	if ( !VERIFY_TEST_SUCCESS( OptionsDirectories.PrependDirectory(szToolsLoc, DIR_TYPE_EXE, PLATFORM_WIN32_X86)) )
	{
		return FALSE;
	}

	return TRUE;
}

BOOL CPrjUtil::RemoveToolsDir(CString szToolsLoc)
{
	COEnvironment OptionsDirectories;
	
	if ( !VERIFY_TEST_SUCCESS( OptionsDirectories.RemoveDirectory(szToolsLoc, DIR_TYPE_EXE, PLATFORM_WIN32_X86)) )
	{
		return FALSE;
	}

	return TRUE;
}

CString   CPrjUtil::GetBldLog() {


	CString BuildRecord;
	CString str;
	
	// Get build data
	UIWB.DoCommand(IDM_WINDOW_ERRORS,DC_ACCEL);  // goto output window
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(BuildRecord);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	BuildRecord.MakeLower();
	return (BuildRecord);
	
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST()

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
private:
	void DeleteFileByWildCard(CString strWildCard);
	void CleanUpVSSDroppings();
};

// Global variables
#define WSPEXTENSION	".DSW"
#define PRJEXTENSION	".DSP"
#define NEWEXEINTDIR	"EXEInt"
#define NEWEXEOUTDIR	"EXEOut"
#define BUILDRES		"buildres.out"
#define PROJNAME		"Hello"
#define PROJMAKFILE		"Hello.DSP"
#define PLATFORMS		PLATFORM_WIN32_X86 + PLATFORM_MAC_68K + PLATFORM_MAC_PPC
// #define EXERELEASETARGET	"Hello - Win32 Release"
#define V4PROJDIR		"Hello.V4"

#if defined(_MIPS_)
#define TOOLSDIR "tools\\mips"
#elif defined(_ALPHA_)
#define TOOLSDIR "tools\\alpha"
#else
#define TOOLSDIR "tools\\x86"
#endif


#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\scandep.h ===
///////////////////////////////////////////////////////////////////////////////
//	SCANDEP.H
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Declaration of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//

#ifndef __SCANDEP_H__
#define __SCANDEP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"
///////////////////////////////////////////////////////////////////////////////
//	CPrjScanDepTest class

class CPrjScanDepTest : public CTest
{
	DECLARE_TEST(CPrjScanDepTest, CSniffDriver)

// Operations
public:
	virtual void Run(void);

protected:
	COProject prj;
	CString szProjEXELoc; 

	BOOL VerifyResults( CString szFileName );	
	BOOL CloseProject( void );
	BOOL OpenProject( void  );
	BOOL BuildProject( void );
};

#endif //__SCANDEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\subprjs.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SUBPRJS.CPP
//
//	Created by :			Date :
//		ThuyT				02/06/96
//
//	Description :
//		Implementation of the CPrjSubPrjTest class
#include "stdafx.h"
#include "prjcases.h"
#include "subprjs.h"
#include <io.h>
 

#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPrjSubPrjTest, CTest, "Verify Subproject", -1, CSniffDriver)
					   
////////////////////////////////////////////////////////////////////
//	CPrjSubPrjTest


void CPrjSubPrjTest::Run(void)
{
	CPrjUtil	PrjUtil;
	
	szProjEXELoc		 = m_strCWD + PROJNAME + "\\";
	szDLLProj			 = "DLL";
	szProjDLLLoc		 = szProjEXELoc + szDLLProj + "\\";
	szDLLCPPFiles		 = szProjDLLLoc + "*.cpp";

	m_pLog->RecordInfo("Verifying building sub-projects...");
	m_pLog->RecordInfo("Open an existing project.");
	EXPECT( OpenProject() );

	// Check to see if DLL subproject is already created yet.  ( REVIEW thuyt)
	if ( prj.SetTarget( DLLRELEASETARGET) == ERROR_ERROR ) {
		m_pLog->RecordInfo("Insert a DLL as a sub-project.");
		EXPECT( InsertProject() );
		m_pLog->RecordInfo("Add files to the sub-project.");
		EXPECT( AddFilesToDLLProject() );
		prj.SetProjProperty(CT_GENERAL,VPROJ_IDC_OUTDIRS_TRG, "Release");
		prj.SetProjProperty(CT_GENERAL,VPROJ_IDC_OUTDIRS_INT, "Release");
		}
	else {
			PrjUtil.TouchFile( szProjEXELoc + "Hello1.h" );
	}
	m_pLog->RecordInfo("EXERELEASETARGET is %s", EXERELEASETARGET);
	m_pLog->RecordInfo("DLLRELEASETARGET is %s", DLLRELEASETARGET);

	prj.SetTarget(EXERELEASETARGET);
	PrjUtil.RemoveToolsDir(m_strCWD + TOOLSDIR);
	m_pLog->RecordInfo("Build the project...");
	BuildProject();
	VerifySubproject();
	UIWB.SaveAll();
	//prj.ExportMakefile();
	EXPECT( CloseProject() );
	VerifyBLDs();
	m_pLog->RecordInfo("Successfully build sub-projects in the expected order.");

}

BOOL CPrjSubPrjTest::InsertProject(void)
{
	if (!VERIFY_TEST_SUCCESS( prj.InsertProject( DLL, szDLLProj, PLATFORMS, SUB_PROJ, PROJNAME))) {
		m_pLog->RecordFailure("Insert a DLL as a subproject");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjSubPrjTest::AddFilesToDLLProject(void)
{
	CString szSRCFileLoc = m_strCWD + "src\\";
	CString szSharedFiles = szProjEXELoc + "Hello1.cpp";

	CopyFile(szSRCFileLoc + "DLL.cpp", szProjDLLLoc + "DLL.cpp", FALSE);
	CopyFile(szSRCFileLoc + "DLL.h", szProjDLLLoc + "DLL.h", FALSE);
	
	if (!VERIFY_TEST_SUCCESS( prj.AddFiles( szDLLCPPFiles , szDLLProj ))) {
		m_pLog->RecordFailure("Couldn't add CPP files to DLL project");
		return FALSE;
	}

	if (!VERIFY_TEST_SUCCESS( prj.AddFiles( szSharedFiles, szDLLProj ))) {
		m_pLog->RecordFailure("Couldn't add shared CPP files DLL to project");
		return FALSE;
	}
	return TRUE;
}	

BOOL CPrjSubPrjTest::VerifySubproject(void)
{
	CPrjUtil	PrjUtil;

	// Get the output window contents
	CString szBldLog = PrjUtil.GetBldLog();
	CString exe =EXERELEASETARGET ;
	CString dll = DLLRELEASETARGET ;
	dll.MakeLower();
	exe.MakeLower();

	// For some reason the output window text is always lower case when extracted.
	int iFoundDLLLibrary = szBldLog.Find(dll);
	int iFoundEXEBinary = szBldLog.Find(exe);

	if ( iFoundDLLLibrary < 0 ) {
		m_pLog->RecordFailure("DLL subproject didn't get built. Expected : %s", DLLRELEASETARGET);
		return FALSE;
	}
	if ( iFoundEXEBinary < 0 ) {
		m_pLog->RecordFailure("Hello EXE didn't get built. Expected : %s", EXERELEASETARGET);
		return FALSE;
	}

	if ( iFoundDLLLibrary > iFoundEXEBinary ) {
		m_pLog->RecordFailure("DLL subproject should be built first.");
		return FALSE;
	}

	// Make sure DLL.idb file is generated for dep. purposes.
	CFileStatus status;
	CString szDLLIDB = szProjDLLLoc + GetLocString(IDSS_BUILD_RELEASE) +"\\vc60.idb";
	if (!CFile::GetStatus(szDLLIDB, status))  {
		m_pLog->RecordFailure("SubProject failed: %s file not found", szDLLIDB);
		m_pLog->RecordFailure("SubProject failed: build system doesn't pass the /FD switch to the compiler.");
		return FALSE;
	}

	return TRUE;
}
BOOL CPrjSubPrjTest::VerifyBLDs( void )
{
// Make BLD files are generate for each project
	CFileStatus status;
	CString szEXEBLD = szProjEXELoc + PROJNAME + PRJEXTENSION;
	CString szDLLBLD = szProjDLLLoc + "DLL" + PRJEXTENSION;
	if (!CFile::GetStatus(szEXEBLD, status))  {
		m_pLog->RecordFailure("Subproject failed: %s file not found", szEXEBLD);
		return FALSE;
	}

	if (!CFile::GetStatus(szDLLBLD, status))  {
		m_pLog->RecordFailure("Subproject failed: %s file not found", szDLLBLD);
		return FALSE;
	}
// Make sure DSW file contains all the projects
	int iFoundEXEProject = FindStrInFile(szProjEXELoc + PROJNAME + WSPEXTENSION, PROJNAME);
	int iFoundDLLProject = FindStrInFile(szProjEXELoc + PROJNAME + WSPEXTENSION, "DLL");

	if (( iFoundEXEProject != 0 ) && ( iFoundDLLProject != 0 ))
		return TRUE;
	else {
		m_pLog->RecordFailure("The DSW file doesn't include all projects.");
		return FALSE;
	}

	return TRUE;

}


BOOL CPrjSubPrjTest::OpenProject( void  )
{
	if (!VERIFY_TEST_SUCCESS( prj.Open(szProjEXELoc + PROJNAME))) {
		m_pLog->RecordFailure("Open the project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjSubPrjTest::BuildProject( void )
{
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	
	if (!VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild))) {
		m_pLog->RecordFailure("Build Project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjSubPrjTest::CloseProject( void )
{
	BOOL bSaveProjBeforeClose = TRUE; 
	
	if (!VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose))) {
		m_pLog->RecordFailure("Close the project");
		return FALSE;
	}
//	m_pLog->RecordInfo("Closing the project successfully");
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SNIFF.CPP
//
//      Created by :                    Date :
//              TomWh                                   10/18/93
//
//      Description :
//              implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "prjcases.h"
#include "bldopts.h"
#include "subprjs.h"
#include "custbld.h"
#include "scandep.h"
#include "extmak.h"
#include "convert.h"
#include "cmdlinebld.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "ProjBld Sniff Test", "brickb x62132")
BEGIN_TESTLIST(CSniffDriver)
	TEST(CPrjAppTest, RUN)
	TEST(CPrjBuildSettingsTest, RUN) DEPENDENCY(CPrjAppTest)
	TEST(CPrjSubPrjTest, RUN)		DEPENDENCY(CPrjAppTest)
	TEST(CPrjScanDepTest, RUN)		DEPENDENCY(CPrjAppTest)
	TEST(CPrjCustomBuildTest, RUN)	DEPENDENCY(CPrjAppTest)
	TEST(CPrjConversionTest, DONTRUN)
	TEST(CPrjExternalMAKTest, RUN)
	TEST(CPrjCommandLineBldTest, RUN) DEPENDENCY(CPrjAppTest)
END_TESTLIST()

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	CleanUpVSSDroppings();
	ExpectedMemLeaks(0);
}

void CSniffDriver::CleanUp(void)
{
	// close all windows
	UIWB.CloseAllWindows();

}


void CSniffDriver::CleanUpVSSDroppings()
{
	// lets make sure there are none of those damm *.scc files in the folders....
	// subdirectory recursion would be better here, didn't have time
	// will get back to this down the road, plus I didn't want to go deleting everything
	// who knows what test this would screw up.
	CString strTemp;
	CString strCWD;

	// wack it from the current directory
	::GetCurrentDirectory(MAX_PATH, strTemp.GetBuffer(MAX_PATH));
	GetShortPathName(strTemp, strCWD.GetBuffer(MAX_PATH), MAX_PATH);

	strTemp.Format("%s\\", strCWD);
	
	DeleteFileByWildCard(strTemp);

	// look in the SRC folder
	strTemp.Format("%s\\src\\", strCWD);
	DeleteFileByWildCard(strTemp);

	// go one more level into the Projdir
	strTemp.Format("%s\\src\\%s\\", strCWD, V4PROJDIR);
	DeleteFileByWildCard(strTemp);

	// one more in the DLL folder
	strTemp.Format("%s\\src\\%s\\%s\\", strCWD, V4PROJDIR, _T("DLL"));
	DeleteFileByWildCard(strTemp);

}


void CSniffDriver::DeleteFileByWildCard(CString strWildCard)
{
	WIN32_FIND_DATA pFFD;
	HANDLE hFileFind;
	CString strTemp = strWildCard + _T("*.scc");

	if ((hFileFind = ::FindFirstFile(strTemp, &pFFD)) != INVALID_HANDLE_VALUE)
	{
		m_pLog->RecordInfo("Doing a little clean up of Source Safe droppings %s", strWildCard);

		DeleteFile(strWildCard + pFFD.cFileName);
		while (FindNextFile(hFileFind, &pFFD))
		{
			::DeleteFile(pFFD.cFileName);
		}
		::FindClose(hFileFind);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\bindcase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//	DATACASE.CPP
//
//	Created by :			Date :
//		ChrisKoz					2/01/96
//
//	Description :
//		Implementation of the CSrcDataCases class
//

#include "stdafx.h"
#include <io.h>
#include "syscases.h"
#include "bindcase.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;




///////////////////////////////////////////////////////////////////////////////
//	CSourceTestCases class
	// shared by NewProject(), InsertProject(), and NewAppWiz().
int OpenSQLDataSource(CDataInfo *pDataInfo);


IMPLEMENT_TEST(CBindBuildTest, CTest, "Build & test dlg", -1, CBindSubSuite)

BOOL CBindBuildTest::RunAsDependent(void)
{
	return FALSE; //bogus code below
	// name of the EXE file
	CString strEXEFile = m_strCWD + PROJDIR + PROJNAME + ".EXE";

	// if the EXE file exists, there's no need to run this test as a dependency
	if (_access(strEXEFile, 0) != -1) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

void CBindBuildTest::Run(void)
{
	OpenProject();
	BuildProject();
	RunTestMode();
}

BOOL CBindBuildTest::OpenProject(void)
{
	BOOL bResult;

	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	// set the project's filename
	CString strProjFile = m_strCWD + PROJDIR + PROJNAME + ".DSW";

	// open the project
	GetLog()->RecordInfo("Opening the project file '%s'...", (LPCSTR)strProjFile);

	// if the project's already open, no need to open it again
	if(GetSubSuite()->m_projOpen)
	{
		GetLog()->RecordSuccess("The project '%s' is already open.", (LPCSTR)(pPrj->GetFullPath()));
		return TRUE;
	}
	else {
		// open the project
		bResult = GetLog()->RecordCompare((pPrj->Open(strProjFile, 0) == ERROR_SUCCESS), "Opening the project file '%s'.", (LPCSTR)strProjFile);
		if (!bResult) {
			throw CTestException("CSysBuildTest::OpenProject: cannot open project; unable to continue.", CTestException::causeOperationFail);
		}
		return bResult;
	}
}

BOOL CBindBuildTest::BuildProject(void)
{
	BOOL bResult;

	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	LOG->RecordInfo("Building project...");

	// build the project
	LOG->RecordCompare(pPrj->Build( 60 ) == ERROR_SUCCESS, "Building project.");


	LOG->RecordInfo("Verifying the build...");

	// verify the build
	bResult = LOG->RecordCompare(pPrj->VerifyBuild() == ERROR_SUCCESS, "Verifying the build.");
	if (!bResult) {
		throw CTestException("CBindBuildTest::BuildProject: cannot build a container project; unable to continue.", CTestException::causeOperationFail);
	}
	return bResult;
}

void CBindBuildTest::RunTestMode(void)
{
//TODO: put this test mode function into Suite
	if(!SetFocusToResSym(m_DialogId /*"IDD_DIALOG1"*/))
		return; //FALSE 
	
	UIWB.DoCommand(IDMY_TEST, DC_MNEMONIC);
	WaitForInputIdle(g_hTargetProc, 50000); //wait for an eventual timeout lor login
	UIDialog uTestDlg;
	uTestDlg.WaitAttachActive(3000);
	char acBuf[256];
	uTestDlg.GetText(acBuf, 255); 
//TODO what to check for while running the test mode?
	MST.DoKeys("{ESC}");
	uTestDlg.WaitUntilGone(3000);
}

///////////////////////////////////////////////////////////////////////////////
//	CPubsTablesTest class
IMPLEMENT_TEST(CPubsTablesTest, CTest, "Bind DBase & test", -1, CBindSubSuite)
void CPubsTablesTest::Run(void)
{
	CDataInfo *pDataInfo=GetSubSuite()->m_DataInfo+0;
	CString strTable,strColumn;

//	GetSubSuite()->PropertySet(controldata[8].ctrlID, //MY_FlexGrid //bug FlexGrid stops RDC from working
//		"DataSource",controldata[2].ctrlID, METHOD_LIST); //MY_RDC
	GetSubSuite()->PropertySet(controldata[7].ctrlID, //MY_DBGrid
		"DataSource",controldata[2].ctrlID, METHOD_LIST); //MY_RDC
	GetSubSuite()->PropertySet(controldata[5].ctrlID, //MY_MASKEDIT
		"DataSource",controldata[2].ctrlID, METHOD_LIST); //MY_RDC
	GetSubSuite()->PropertySet(controldata[6].ctrlID, //MY_RICHEDIT
		"DataSource",controldata[2].ctrlID, METHOD_LIST); //MY_RDC

	POSITION pos = pDataInfo->m_listMembers.GetHeadPosition();
	while(pos != NULL)
	{
		strTable=pDataInfo->m_listMembers.GetAt(pos)->GetName();
		strColumn=pDataInfo->m_listMembers.GetAt(pos)->GetColumn();
		LOG->RecordInfo("Setting the table of control: %s as: %s",
			controldata[2].ctrlID/*MY_RDC*/, strTable);
		SetSource(controldata[2].ctrlID, //MY_RDC
			pDataInfo->m_strConnect,
			pDataInfo->m_strUser,
			pDataInfo->m_strPassWord,
			strTable);
//SetColumns:
		GetSubSuite()->PropertySet(controldata[5].ctrlID, //MY_MASKEDIT
			"DataField",strColumn, METHOD_LIST);
		GetSubSuite()->PropertySet(controldata[6].ctrlID, //MY_RICHEDIT
			"DataField",strColumn, METHOD_LIST);
		//TODO: put this test mode function into Suite
		if(!SetFocusToResSym(m_DialogId /*"IDD_DIALOG1"*/))
			return; //FALSE 
	
		UIWB.DoCommand(IDMY_TEST, DC_MNEMONIC);
		WaitForInputIdle(g_hTargetProc, 50000); //wait for an eventual timeout lor login
		UIDialog uTestDlg;
		uTestDlg.WaitAttachActive(3000);
		char acBuf[256];
		uTestDlg.GetText(acBuf, 255); 
		Sleep(2000);//TODO what to check for while running the test mode?
		MST.DoKeys("{ESC}");
		uTestDlg.WaitUntilGone(3000);
		//////////////////////////////////////////////////////
		
		pDataInfo->m_listMembers.GetNext(pos);
	} //while
}//CPubsTablesTest::Run


/////////////////////////////////////////////////////////////////////////
// Sets the SQL property as "select * from TableName" on RDC control
//
// RdcID:		ID of the RDC
// pDataInfo:	Datasource info
// TableName:	table in question
/////////////////////////////////////////////////////////////////////////
int CPubsTablesTest::SetSource(LPCSTR RdcID,LPCSTR szConnect,LPCSTR szUser,LPCSTR szPWD,
							  LPCSTR TableName)
{

	int bResult;
	MST.DoKeys("%(Vy)",FALSE,5000); //View.Symbols (wait for idle time
	//	if(MST.WListItemExists(cntlrID))
	MST.WListItemClk(GetLabel(0x6814),RdcID); 
	MST.WButtonClick(GetLabel(0x681d)); // View use of the RDC
	
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	if((bResult=prop.IsValid())==FALSE)
	{
		LOG->RecordFailure("Cannot access the property of control: '%s'",RdcID);
	}
	else
	{
		if(prop.GetID()!=RdcID)
		{
			bResult=ERROR_ERROR;
			LOG->RecordFailure("This is not the control: %s",RdcID);
		}
	}
	if(bResult==ERROR_ERROR)
	{
		prop.Close(); //get rid of the properties
		return ERROR_ERROR;
	}
	if(prop.SetAllPage()==FALSE)
		return ERROR_ERROR;
//	prop.putProperty("DataSourceName",pDataInfo->m_strSource,METHOD_LIST);
	prop.putProperty("Connect",szConnect);
	prop.putProperty("UserName",szUser);
	prop.putProperty("Password",szPWD);
	prop.putProperty("SQL",CString("Select * from ")+CString(TableName));
	prop.Close();
	return ERROR_SUCCESS;
} // CAddControlTest::SetSource
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Sniff\Src\subprjs.h ===
///////////////////////////////////////////////////////////////////////////////
//	SUBPRJS.H
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Declaration of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//

#ifndef __SUBPRJS_H__
#define __SUBPRJS_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"
///////////////////////////////////////////////////////////////////////////////
//	CPrjSubPrjTest class

class CPrjSubPrjTest : public CTest
{
	DECLARE_TEST(CPrjSubPrjTest, CSniffDriver)

// Operations
public:
	virtual void Run(void);

protected:
	CString szProjDLLLoc;
	CString szDLLProj;
	CString szDLLCPPFiles;
	CString szProjEXELoc;
	COProject prj;

	BOOL InsertProject( void );
	BOOL AddFilesToDLLProject( void );
	BOOL VerifySubproject( void );
	BOOL VerifyBLDs ( void );
	BOOL CloseProject( void );
	BOOL OpenProject( void  );
	BOOL BuildProject( void );
};

#endif  //__SUBPRJS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\bindcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DATACASE.H
//
//	Created by :			Date :
//		ChrisKoz					2/02/96
//
//	Description :
//		Declaration of classes for DataPane Verification
//

#ifndef __BINDCASE_H__
#define __BINDCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"



///////////////////////////////////////////////////////////////////////////////
//	CDataCases class
///////////////////////////////////////////////////////////////////////////////
// CBindBuildTest: Connect to the SQL server Data Source

class CBindBuildTest: public CTest
{
	DECLARE_TEST(CBindBuildTest, CBindSubSuite)

public:
	virtual void Run(void);
	virtual	BOOL RunAsDependent(void);
	BOOL OpenProject(void);
	BOOL BuildProject(void);
	void RunTestMode(void);
};

///////////////////////////////////////////////////////////////////////////////
// CPubsTablesTest: Check Pubs DB tables on the SQL server

class CPubsTablesTest: public CTest
{
	DECLARE_TEST(CPubsTablesTest, CBindSubSuite)

public:
	virtual void Run(void);
	int SetSource(LPCSTR RdcID,LPCSTR szConnect,LPCSTR szUser,LPCSTR szPWD,
		LPCSTR TableName);
};



#endif //__BINDCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\editcase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//	EDITCASE.CPP
//
//	Created by :			Date :
//		ChrisKoz					2/01/96
//
//	Description :
//		Implementation of the CSrcDataCases class
//

#include "stdafx.h"
#include "editcase.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CEditResTest, CTest, "Drag&Drop Controls", -1, CBindSubSuite)

void CEditResTest::Run(void)
{
	if(!GetSubSuite()->m_projOpen)
	{
		CString strPrjName=m_strCWD + PROJDIR + PROJNAME + ".DSW";
		if(GetSubSuite()->m_prj.Open(strPrjName)!=ERROR_SUCCESS)
			GetLog()->RecordFailure("Coudn't open project - %s",strPrjName);
		else
			GetSubSuite()->m_projOpen=1;
	}
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
	//open the source dialog
	if(!SetFocusToResSym(m_DialogId /*"IDD_DIALOG1"*/))
		return; //FALSE 
	UIDlgEdit m_uDlgEdSrc = UIWB.GetActiveEditor();
	if (!m_uDlgEdSrc.IsValid()) {
		m_pLog->RecordFailure("Unable to create Dialog Resource");
		return; // FALSE;
	}
	m_uDlgEdSrc.OnUpdate(); //validate the m_hwndDialog

	//open the destination dialog
	SetFocusToResSym(/*m_AboutId*/"IDD_ABOUTBOX");
	CString m_AboutId=UIWB.GetProperty(P_ID); //store the ID of the dialog
	MST.DoKeys("+{DOWN 200}"); //resize the dialog
	MST.DoKeys("{TAB}");

	while(UIWB.GetProperty(P_ID)!=m_AboutId)
	{
		if(UIWB.GetProperty(P_ID)!="IDOK")
			MST.DoKeys("{Del}"); //delete all but IDOK controls
		else
			MST.DoKeys("{TAB}"); //skip IDOK control
	}

	UIDlgEdit m_uDlgEdDest = UIWB.GetActiveEditor();
	if (!m_uDlgEdDest.IsValid()) {
		m_pLog->RecordFailure("Unable to create Dialog Resource");
		return; // FALSE;
	}
	m_uDlgEdDest.OnUpdate(); //validate the m_hwndDialog
	MST.DoKeys("%WT"); //Windw.Tile Vertical
//done the resising of about dialog & other preparations
	if(!SetFocusToResSym(controldata[7].ctrlID)) //DBGrid
		return; //FALSE 
	CString strPos;
	strPos = UIWB.GetProperty(P_Position);
	char posbuffer[50];
	RECT current;memset(&current,0, sizeof(current));
	char *pospointer=strtok(strncpy(posbuffer,strPos,50),",");
	current.left=atoi(pospointer);
	if(pospointer!=NULL)pospointer=strtok(NULL,",");
	current.top=atoi(pospointer);
	if(pospointer!=NULL)pospointer=strtok(NULL,",");
	current.right=atoi(pospointer);
	if(pospointer!=NULL)pospointer=strtok(NULL,",");
	current.bottom=atoi(pospointer);
	long centerX=(current.right+current.left)/2;
	long centerY=(current.bottom+current.top)/2;

//	DragMouse(VK_LBUTTON, 
  //  		m_uDlgEdSrc.GetDialog(), centerX, centerY, 
    //		m_uDlgEdDest.GetDialog(), centerX, centerY); //does not work
{
	int nButton=VK_LBUTTON;
	HWND hwnd1=m_uDlgEdSrc.GetDialog();
	int cX1=centerX; int cY1=centerY;
	HWND hwnd2=m_uDlgEdDest.GetDialog(); 
	int cX2=centerX; int cY2=centerY;
	WaitStepInstructions("Mouse from window '0x%X'(%d,%d) to '0x%X'(%d,%d)", 
		hwnd1, cX1, cY1, hwnd2, cX2, cY2);
	// Mouse down at point1    

	CPoint ptFrom(cX1, cY1);
	ASSERT(hwnd1 != NULL);
		ClientToScreen(hwnd1, &ptFrom);

	CPoint ptTo(cX2, cY2);
	ASSERT(hwnd2 != NULL);
		ClientToScreen(hwnd2, &ptTo);

	WaitStepInstructions("Drag mouse from %d,%d to %d,%d", ptFrom.x, ptFrom.y, ptTo.x, ptTo.y);

	MST.QueMouseDn(nButton, ptFrom);
	QueFlush(TRUE);
	Sleep(1000); //safety
	WaitStepInstructions("Clicked mouse down at %d,%d", ptFrom.x, ptFrom.y);

	MST.QueMouseMove(ptTo);
	QueFlush(TRUE);
	Sleep(1000); //safety
	WaitStepInstructions("Dragged mouse to %d,%d", ptTo.x, ptTo.y);

	
	MST.QueMouseUp(nButton,ptTo);
	QueFlush(TRUE);
	WaitStepInstructions("Released the mouse at %d,%d", ptTo.x, ptTo.y);
}

	
	
	//TODO check its properties: it shld not be set to the datasource anymore
	UIWB.DoCommand(ID_EDIT_UNDO, DC_ACCEL);
	if(!SetFocusToResSym(controldata[7].ctrlID)) //DBGrid
		return; //FALSE 
	//TODO check its properties: it shld not be set to the datasource anymore
	UIWB.DoCommand(IDM_FILE_SAVE_ALL, DC_MNEMONIC);
	//TODO test mode
}

IMPLEMENT_TEST(CRandomTest, CTest, "Random Controls", -1, CBindSubSuite)

void CRandomTest::Run(void)
{
	if(!SetFocusToResSym(m_DialogId /*"IDD_DIALOG1"*/))
		return; //FALSE 
	MST.DoKeys("+{F10}");				// Shift+F10 brings up context menu
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(500);
	MST.DoKeys("X"); //insert ActiveX control

	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(1000);
	CString listlabel=GetLabel(0x6ad6)/* OLE_CONTROL_LIST*/;
	int nelem=MST.WListCount(listlabel);
	LOG->RecordInfo("Starting the loop through all %d controls",nelem);
	MST.DoKeys("{ESC}"); //insert ActiveX control

	for(int ielem=1;ielem<=nelem;ielem++)
	{
	if(!SetFocusToResSym(m_DialogId /*"IDD_DIALOG1"*/))
		return; //FALSE 
	MST.DoKeys("+{F10}");				// Shift+F10 brings up context menu
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(500);
	MST.DoKeys("X"); //insert ActiveX control

	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
////////////////////////////////////
		CString strControl;
		MST.WListItemClk (listlabel,ielem);
		MST.WListText (listlabel,strControl);
		LOG->RecordInfo("Clicked the control: '%s'",strControl);
		MST.WButtonClick(GetLabel(IDOK)); //OLE control chosen
		
		if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
		{
			LOG->RecordFailure("ActiveX control hanged...");
			return /* ERROR_ERROR*/;
		}
		Sleep(2000); //bug DBgrid GPFaults if I do not insert the sleep here
	// Popup the property page for the currently active item.
		UIControlProp prop = UIWB.ShowPropPage(TRUE);
		
		prop.SetExpectedTitle(strControl);
		if(prop.IsValid()==FALSE)
		{

			LOG->RecordFailure("Coudn't find the control '%s' properties",strControl);
			MST.DoKeys("{Esc}"); //get rid of the properties
		}
		else
		{
			prop.SetAllPage();
			LOG->RecordSuccess("Inserted ActiveX control: (%s)",prop.GetID());
			prop.Close();
		}
	} //for
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\editcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	EDITCASE.H
//
//	Created by :			Date :
//		ChrisKoz					2/02/96
//
//	Description :
//		Declaration of classes for DataPane Verification
//

#ifndef __EDITCASE_H__
#define __EDITCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"



///////////////////////////////////////////////////////////////////////////////
// CEditResTest: Drag & drop the controls within the resources

class CEditResTest: public CTest
{
	DECLARE_TEST(CEditResTest, CBindSubSuite)

public:
	virtual void Run(void);
};



///////////////////////////////////////////////////////////////////////////////
// CRandomTest: Put all controls onto the dialog randomly
class CRandomTest: public CTest
{
	DECLARE_TEST(CRandomTest, CBindSubSuite)

public:
	virtual void Run(void);
};




#endif //__EDITCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\syscases.h ===
///////////////////////////////////////////////////////////////////////////////
//	SYSCASES.H
//
//	Created by :			Date :
//		RickKr					1/25/94
//
//	Description :
//		Declaration of the CSysTestCases class
//

#ifndef __SYSCASES_H__
#define __SYSCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CComWizTest: Build

class CContTest: public CTest
{
	DECLARE_TEST(CContTest, CBindSubSuite)

// overrides
public:
	virtual void Run(void);

	virtual BOOL RunAsDependent(void);

// support functions
protected:
	BOOL NewProject(void);
	BOOL SaveProject(void);
};

///////////////////////////////////////////////////////////////////////////////
// CBindClassesTest: SYS Verify the project classes

class CAddControlTest: public CTest
{
	DECLARE_TEST(CAddControlTest, CBindSubSuite)

public:
	virtual void Run(void);
	int CreateResource( LPCSTR szResName );
	int AddOleControl(LPCSTR Name,LPCSTR ID_Name,RECT *position=NULL);
};



#endif // SYSCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Bin\dlg_dti.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by dlg_dti.rc
//
#define IDD_DIALOG1                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\syscases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SYSCASES.CPP
//
//      Created by :                    Date :
//              ChrisKoz                                  1/25/96
//
//      Description :
//              Implementation of the creation & classview in Galileo project
//

#include "stdafx.h"
#include <io.h>
#include "syscases.h"
#include "sniff.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;



///////////////////////////////////////////////////////////////////////////////
// CContTest: create the MDI MFC container & save it
IMPLEMENT_TEST(CContTest, CTest, "Create Container App", -1, CBindSubSuite)

BOOL CContTest::RunAsDependent(void)
{
	return FALSE; //bogus code below
	// name of the project file
	CString strProjFile = m_strCWD + PROJDIR + PROJNAME + ".DSW";

	// if the project file exists, there's no need to run this test as a dependency
	if (_access(strProjFile, 0) != -1) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

void CContTest::Run(void)
{
	NewProject();
	SaveProject();
}

BOOL CContTest::NewProject(void)
{
	BOOL bResult;
	
	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	GetLog()->RecordInfo("Creating an AppWizard project named '%s'...", PROJNAME);

	// create a new AppWizard project
	APPWIZ_OPTIONS options;
	options.m_bUseMFCDLL = CMDLINE->GetBooleanValue("MFCDLL", FALSE); 

	// The following command line switch is mapped as follows:
	//	0 - APPWIZ_OPTIONS::AW_OLE_NONE (Default)
	//  1 - APPWIZ_OPTIONS::AW_OLE_CONTAINER
	//  2 - APPWIZ_OPTIONS::AW_OLE_MINISERVER (not supported)
	//  3 - APPWIZ_OPTIONS::AW_OLE_FULLSERVER
	//  4 - APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER
	options.m_OLECompound = (APPWIZ_OPTIONS::OLESupport)CMDLINE->GetIntValue("OLE", 1);
	ASSERT(options.m_OLECompound < 5);

	switch(options.m_OLECompound)
	{
	case APPWIZ_OPTIONS::AW_OLE_NONE:
		GetLog()->RecordInfo("No OLE options selected.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINER:
		GetLog()->RecordInfo("Creating an OLE container application.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_MINISERVER:
		GetLog()->RecordFailure("Creating an OLE mini-server application is not supported by the System sniff.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_FULLSERVER:
		GetLog()->RecordInfo("Creating an OLE full-server application.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER:
		GetLog()->RecordInfo("Creating an OLE container/server application.");
		break;
	default:
		GetLog()->RecordInfo("Invalid OLE option specified: %d  Defaulting to no OLE support", options.m_OLECompound);
		options.m_OLECompound = APPWIZ_OPTIONS::AW_OLE_NONE;
		break;
	}

	bResult = GetLog()->RecordCompare
		(pPrj->NewAppWiz(PROJNAME, GetCWD(), GetUserTargetPlatforms(), &options) 
		== ERROR_SUCCESS, "Creating an AppWizard project named '%s'.", PROJNAME);
	if (!bResult) {
		throw CTestException("CContTest::NewProject: cannot create a new AppWizard project; unable to continue.", CTestException::causeOperationFail);
	}


	// change output file location to same as project file (avoid debug, macdbg, pmcdbg, etc).
//	bResult = LOG->RecordCompare(pPrj->SetOutputFile((CString)PROJNAME + ".Exe") == ERROR_SUCCESS, "Resetting output file location.", PROJNAME);
//	if (!bResult) {
//		throw CTestException("CContTest::NewProject: cannot reset output file location; unable to continue.", CTestException::causeOperationFail);
//	}

	return bResult;
}


BOOL CContTest::SaveProject(void)
{
	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	CString strPrjName = pPrj->GetFullPath();

	GetLog()->RecordInfo("Saving the AppWizard project. Expecting the file '%s' to be written...", strPrjName);

	// save the project
	pPrj->Close(TRUE); GetSubSuite()->m_projOpen=0;
	return 0; // the bogus code below screws up the pPrj state
//	return GetLog()->RecordCompare(
//		pPrj->Save(TRUE, strPrjName) == ERROR_SUCCESS,
//		"Saving the AppWizardProject.");
}

///////////////////////////////////////////////////////////////////////////////
// CAddControlTest: creates the new dialog resource, adds controls to the dialogs
IMPLEMENT_TEST(CAddControlTest, CTest, "Add DBind Controls", -1, CBindSubSuite)


void CAddControlTest::Run(void)
{
	// if(!GetSubSuite()->m_prj.IsOpen())  this does not work
	if(!GetSubSuite()->m_projOpen)
	{
		CString strPrjName=m_strCWD + PROJDIR + PROJNAME + ".DSW";
		if(GetSubSuite()->m_prj.Open(strPrjName)!=ERROR_SUCCESS)
			GetLog()->RecordFailure("Coudn't open project - %s",strPrjName);
		else
			GetSubSuite()->m_projOpen=1;
	}
	int bResult=CreateResource("Dialog");
	if(!LOG->RecordCompare(bResult == ERROR_SUCCESS, 
					"Adding the dialog to the project"))
		throw CTestException("Cannot create the dialog; unable to continue.", 
				CTestException::causeOperationFail);

	for(int i=0;i<sizeof(controldata)/sizeof(*controldata);i++)
	{
		LOG->RecordInfo("Adding the control: %s",controldata[i].ctrlID);
		AddOleControl(controldata[i].ctrlName, controldata[i].ctrlID, &controldata[i].pos);
		LOG->RecordInfo("Bringing All PP of control: %s", controldata[i].ctrlID);
		UIControlProp prop = UIWB.ShowPropPage(TRUE);
		EXPECT_EXEC(prop.IsValid(),"Failed to show property page");
		if(prop.SetAllPage()==FALSE)
			LOG->RecordFailure("Cannot bring the all property page");
		prop.Close();
	}

	GetSubSuite()->PropertySet(controldata[2].ctrlID, //MY_RDC
		"Caption","Myrdc2.0");
	GetSubSuite()->PropertySet(controldata[6].ctrlID, //MY_RICHEDIT
		"Text","MyRich5.0");
	GetSubSuite()->PropertySet(controldata[7].ctrlID, //MY_DBGrid
		"Caption","Hey, Apex is cool!");
	
	UIWB.DoCommand(IDM_FILE_SAVE_ALL, DC_MNEMONIC);
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
	//saving the project
	COProject* pPrj = &(GetSubSuite()->m_prj);

	CString strPrjName = pPrj->GetFullPath();

	GetLog()->RecordInfo("Saving the project...");

	// save the project
	pPrj->Close(TRUE); GetSubSuite()->m_projOpen=0;
	return;

}//CAddControlTest::Run


////////////////////////////////////////////////////////////////////////////
// Creates the new resource of type szResName
// At exit, the resource editor ewindow should be opened
////////////////////////////////////////////////////////////////////////////
int CAddControlTest::CreateResource( LPCSTR szResName )
{
	UIWB.DoCommand(IDM_RESOURCE_NEW, DC_MNEMONIC);
	if( MST.WFndWndWait(GetLocString(IDSS_NEW_RES_TITLE), FW_PART, 2) == 0 )	// make sure the dialog comes up
		return ERROR_ERROR;		
	MST.DoKeys(szResName);				// Type Name of resource .... 
	if (!MST.WButtonEnabled(GetLabel(IDOK)))  // Timeout supposedly defaults to 5 sec.
	{
		LOG->RecordFailure("Timeout waiting for OK button on New Resource Dialog to become enabled.");
		return ERROR_ERROR;
	}

	MST.WButtonClick(GetLabel(IDOK));

	if( MST.WFndWndWait(szResName, FW_PART, 2)  == 0 ) // Wait for the editor to come up and verify the Caption
		return ERROR_ERROR;
	m_DialogId=UIWB.GetProperty(P_ID); //store the ID of the dialog
	MST.DoKeys("+{DOWN 100}"); //resize the dialog
	MST.DoKeys("{TAB}");
	while(UIWB.GetProperty(P_ID)!=m_DialogId)
	{
		MST.DoKeys("{Del}"); //delete all controls
	}
	return ERROR_SUCCESS;
}


//sets the property of the control
// tries to set the property using METHOD_LIST.
// METHOD_EDIT is used if the list isempty
int CBindSubSuite::PropertySet(LPCSTR cntlrID,LPCSTR PropName,LPCSTR Value, int METHOD /*=METHOD_EDIT*/)
{
	LOG->RecordInfo("Setting (%s) control's (%s) property to: (%s)",cntlrID,PropName,Value);
	MST.DoKeys("%(Vy)",FALSE,5000); //View.Symbols (wait for idle time
//	if(MST.WListItemExists(cntlrID))
	MST.WListItemClk(GetLabel(0x6814),cntlrID); 
	MST.WButtonClick(GetLabel(0x681d));
	Sleep(3000); //bug it does not hit the use of DBGrid
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	EXPECT(UIWB.GetProperty(P_ID)==cntlrID);
	EXPECT(prop.IsValid());
	if(prop.putProperty(PropName,Value,METHOD)<0 && METHOD==METHOD_LIST &&
		prop.putProperty(PropName,Value,METHOD_EDIT)==0) //try METHOD_EDIT if METHOD_LIST failed
	{
		LOG->RecordFailure("Set the property (%s) of the control (%s) to '%s'",PropName,cntlrID,Value);
	}
	prop.Close(); //get rid of the properties
	return ERROR_SUCCESS;
}//CAddControlTest::PropertySet()


////////////////////////////////////////////////////////////////////
// Adds the OLE control to the current dialog 
// sets its ID to ID_Name
// Assumes that the dialog is currently opened
// Returns: ERROR_SUCCESS or ERROR_ERROR
////////////////////////////////////////////////////////////////////
int CAddControlTest::AddOleControl(LPCSTR Name,LPCSTR ID_Name,
								   RECT *position /*=NULL*/)
{
	int cnt=100; //never more that 100 controls
	while(cnt-->0)
	{
		if(UIWB.GetProperty(P_ID)==m_DialogId)
			break; //found the dialog ID
		MST.DoKeys("{Tab}");
	}
	if(cnt<=0)
	{
		LOG->RecordFailure("Cannot reach the dialog '%s' context",m_DialogId);
		return ERROR_ERROR;
	}

	MST.DoKeys("+{F10}");				// Shift+F10 brings up context menu
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(500);
	MST.DoKeys("X"); //insert ActiveX control

	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	CString listlabel=GetLabel(0x6ad6)/* OLE_CONTROL_LIST*/;

	Sleep(1000);
	int nelem=MST.WListCount(listlabel);
	LOG->Comment("Found (%d) elements in ActiveX list",nelem);

	if(MST.WListItemExists(listlabel,Name)==0)
	{	
		LOG->RecordFailure("Coudn't find OLE control: %s",Name);
		MST.WButtonClick(GetLabel(IDCANCEL));
		return ERROR_ERROR;
	}
	MST.WListItemClk(listlabel,Name);
	MST.WButtonClick(GetLabel(IDOK)); //OLE control chosen
	if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
	{
		LOG->RecordFailure("ActiveX control hanged...");
		return ERROR_ERROR;
	}
	Sleep(2000); //bug DBgrid GPFaults if I do not insert the sleep here
// Popup the property page for the currently active item.
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	if(prop.IsValid()==FALSE)
	{
		LOG->RecordFailure("Coudn't find the control '%s' properties",Name);
		MST.DoKeys("{Esc}"); //get rid of the properties
		return ERROR_ERROR;
	}
	prop.SetID(ID_Name);
	prop.Close();
	if(position==NULL)
		return ERROR_SUCCESS;

	
		//Move the control
	long sizeHor=position->right-position->left;
	long sizeVer=position->bottom-position->top;
	CString strPos;
	strPos = UIWB.GetProperty(P_Position);
	char posbuffer[50];
	RECT current;

	char *pospointer=strtok(strncpy(posbuffer,strPos,50),",");
	current.left=atoi(pospointer);
	if(pospointer!=NULL)pospointer=strtok(NULL,",");
	current.top=atoi(pospointer);
	if(pospointer!=NULL)pospointer=strtok(NULL,",");
	current.right=atoi(pospointer);
	if(pospointer!=NULL)pospointer=strtok(NULL,",");
	current.bottom=atoi(pospointer);
	long curSizeHor=current.right-current.left;
	long curSizeVer=current.bottom-current.top;

	long moveright,movedown,sizeright,sizedown;
	moveright=position->left - current.left;
	movedown=position->top - current.top;
	sizeright=sizeHor - curSizeHor;
	sizedown=sizeVer - curSizeVer;

	while(moveright!=0 || movedown!=0 || sizeright!=0 || sizedown!=0)
	{
		char dokeys[40];
		if(moveright!=0)
		{
			sprintf(dokeys,(moveright>0?"{RIGHT %d}":"{LEFT %d}"),
				abs(moveright)/2+1);
			MST.DoKeys(dokeys); 
		}
		if(movedown!=0)
		{
			sprintf(dokeys,(movedown>0?"{DOWN %d}":"{UP %d}"),
				abs(movedown)/2+1);
			MST.DoKeys(dokeys); 
		}
		if(sizeright!=0)
		{
			sprintf(dokeys,(sizeright>0?"+{RIGHT %d}":"+{LEFT %d}"),
				abs(sizeright)/2+1);
			MST.DoKeys(dokeys); 
		}
		if(sizedown!=0)
		{
			sprintf(dokeys,(sizedown>0?"+{DOWN %d}":"+{UP %d}"),
				abs(sizedown)/2+1);
			MST.DoKeys(dokeys); 
		}
		
		CString strnextPos=UIWB.GetProperty(P_Position);
		if(strnextPos==strPos)
		{
			TRACE("Dokeys(...) didnt move the control");
			break;
		}
		strPos=strnextPos;
		pospointer=strtok(strncpy(posbuffer,strnextPos,50),",");
		current.left=atoi(pospointer);
		if(pospointer!=NULL)pospointer=strtok(NULL,",");
		current.top=atoi(pospointer);
		if(pospointer!=NULL)pospointer=strtok(NULL,",");
		current.right=atoi(pospointer);
		if(pospointer!=NULL)pospointer=strtok(NULL,",");
		current.bottom=atoi(pospointer);
		curSizeHor=current.right-current.left;
		curSizeVer=current.bottom-current.top;
		
		if(moveright>0 && current.left>=position->left ||
		   moveright<0 && current.left<=position->left)
			moveright=0;
		else
			if(moveright!=0)moveright=position->left - current.left;

		if(movedown>0 && current.top>=position->top ||
		   movedown<0 && current.top<=position->top)
			movedown=0;
		else
			if(movedown!=0)movedown=position->top - current.top;

		if(sizeright>0 && curSizeHor >= sizeHor ||
		   sizeright<0 && curSizeHor <= sizeHor)
			sizeright=0;
		else
			if(sizeright!=0)sizeright=sizeHor - curSizeHor;

		if(sizedown>0 && curSizeVer >= sizeVer ||
		   sizedown<0 && curSizeVer <= sizeVer)
			sizedown=0;
		else
			if(sizedown!=0)sizedown=sizeVer - curSizeVer;
	} //while
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////
// Brings the properties for given control
//	TRUE=General property page
//	FALSE=All property page
// Name
//   if(NULL) - just the property is brought without any check
//   if(!NULL)- the PP is checked if the name is inside
//int CAddControlTest::BringProperties(BOOL General,LPCSTR Name /*=NULL*/)
/*{	
	MST.DoKeys("%({Enter})"); //bring up the properties
	BOOL bReady = FALSE;
	int nSec = 5;
	int ret=ERROR_SUCCESS;
	int otherPage=0;
		int idexist=-10,editexist=-10,comboexist=-10;
	
	while (!bReady && ret == ERROR_SUCCESS)
	{
		// Attempt to open the property page for the Data Source
		
		CString str;
		MST.WGetText(NULL, str);
		if(Name==NULL)
		{ //check the correct property page
			if(General &&  
			(comboexist=MST.WComboExists(GetLabel(0xde))))
			{
				LOG->RecordInfo("Found the Control General properties");
				bReady = TRUE;
			}
			if(General)
			{
				TRACE("ID Combo returnded: %d\n",comboexist);
			}
			if(!General &&
				(editexist=(MST.WComboExists(GetLabel(0x65ea)) || MST.WListExists(GetLabel(0x65e8)))))
			{
				LOG->RecordInfo("Found the Control All properties");
				bReady = TRUE;
			}
			if(!General)
			{
				TRACE("Static in ALL Property returnded: %d\n",idexist);
				TRACE("List in ALL returnded: %d\n",editexist);
				TRACE("Combo in ALL returnded: %d\n",comboexist);
			}
		}
		else
		{	//check the window title only
			if(str.Find("Properties")>=0)
			{
				bReady=TRUE;
				if(str.Find(Name)<0)
					ret = ERROR_ERROR;
			}
		}
		if(!bReady)
		{
			if (--nSec != 0)	// If we still have some waiting time...
			{
 				Sleep(1000);
			}
			else if(otherPage)		// We've timed out.
			{
				LOG->RecordInfo("Didn't find the Control properties");
				ret = ERROR_ERROR;
			}
			else
			{
				MST.DoKeys(!General?"^{PgUp}":"^{PgDn}");
				otherPage=TRUE;
				nSec=5;
			}
		}
	} //while
	return ret;		
} // BringProperties
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		TomWh					11/1/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define PROJNAME "Contain Proj"
#define PROJDIR "Contain Proj\\"

// Stuff needed for DataInfo holding.

// BEGIN_CLASS_HELP
// ClassName: CObjectInfo
// BaseClass: none
// Category: Project
// END_CLASS_HELP
struct CObjectInfo
{
	enum TYPE { TABLE, PROC, VIEW, TRIGGER};

	CString		m_strName;			// Name of the table.
	CString		m_strColumn;		// Return the column name,
									// data type for data.
	TYPE		m_Type; 			// stored proc or table or view?

	~CObjectInfo();

    void ClearAll();

    LPCSTR GetName() const { return (LPCSTR)m_strName; }
	LPCSTR GetColumn() const { return (LPCSTR)m_strColumn; }
	LPCSTR GetType() const {
		if(m_Type==TABLE) return "TABLE";
		if(m_Type==PROC) return "Return Type";
		if(m_Type==VIEW) return "VIEW";
		if(m_Type==TRIGGER) return "TRIGGER";
		return NULL; }

};

// BEGIN_CLASS_HELP
// ClassName: CClassInfo
// BaseClass: none
// Category: Project
// END_CLASS_HELP
struct CDataInfo 
{
    CString m_strConnect;				// Name of datasource.

	CString m_strServer;				// Server name
	CString m_strUser;					// user name
    CString m_strDataB;					// Name of database.
	CString m_strPassWord;				// Password for user
	CTypedPtrList<CPtrList, CObjectInfo*> m_listMembers;
	~CDataInfo();

    void ClearAll();
    LPCSTR GetName() const { return (LPCSTR)m_strDataB; }
};


///////////////////////////////////////////////////////////////////////////////
// CSysSubSuite class

class CBindSubSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CBindSubSuite)

	DECLARE_TESTLIST()

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
	void GetDataInfo(CString &strDataFile);
	int PropertySet(LPCSTR cntlrID,LPCSTR PropName,LPCSTR Value, int METHOD = METHOD_EDIT);
protected:
	BOOL RegisterAll();
// data
public:
	CDataInfo m_DataInfo[2];	//info abpout databases being accessed
	COProject m_prj;			//project being open
	COConnection *m_pconnec;
	BOOL m_projOpen;	//workaround bogus COProject::IsOpen()
//private:
	CString m_DefDialogId; //id of the dialog

};

#define m_DialogId (GetSubSuite()->m_DefDialogId)

BOOL SetFocusToResSym(LPCSTR SymName);

__declspec(selectany)  struct
{
	RECT pos;
	char ctrlName[128];
	char ctrlID[64];
}controldata[]={
	{{5,40,120,70},   "Microsoft DBCombo Control, version 5.0", "MY_COMBO1"},
	{{10,10,130,100}, "Microsoft DBList Control, version 5.0",  "MY_LIST1"},//bug in the DBList control - it does not resize itself
/*2*/{{20,130,150,150},"Microsoft RemoteData Control 2.0",       "MY_RDC"},
	{{160,70,280,100},"Microsoft DBCombo Control, version 5.0", "NEXT_COMBO"},
	{{160,100,280,120},"Microsoft DBCombo Control, version 5.0","LAST_COMBO"},
	{{160,130,270,150},"Microsoft Masked Edit Control, version 5.0","MY_MASKEDIT"},
/*6*/{{50,70,150,110}, "Microsoft RichText Control, version 5.0","MY_RICHEDIT"},
/*7*/{{10,155,300,300},"DBGrid  Control",						"MY_DBGrid"},
/*8*/{{135,5,300,70}, "Microsoft FlexGrid Control, version 5.0",  "MY_FlexGrid"},
};


#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\BindCtrl\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SNIFF.CPP
//
//      Created by :                    Date :
//              RickKr                                  8/30/93
//
//      Description :
//              implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "syscases.h"
#include "bindcase.h"
#include "editcase.h"
#include <process.h>
#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

static char _szDllRegSvr[] = "DllRegisterServer";
static char _szDllUnregSvr[] = "DllUnregisterServer";

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CBindSubSuite, CIDESubSuite, "ResEditor controls", "ChrisKoz")

BEGIN_TESTLIST(CBindSubSuite)
	TEST(CContTest, RUN)
	TEST(CAddControlTest, RUN) //	DEPENDENCY(CContTest)
	TEST(CBindBuildTest, RUN) //	    DEPENDENCY(CContTest)
	TEST(CPubsTablesTest, RUN) //	DEPENDENCY(CBindBuildTest)
	TEST(CEditResTest, RUN) //	DEPENDENCY(CBindBuildTest)
	TEST(CRandomTest, RUN) //	DEPENDENCY(CBindBuildTest)
//	if ((GetSystem() & SYSTEM_DBCS) != 0) { // Only if on a DBC system
//		TEST(CSourceTestCases, DONTRUN)
//	}
END_TESTLIST()

void CBindSubSuite::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
// obsolete call (tries to register the inexistent OLE controls)
//	if(RegisterAll()!=ERROR_SUCCESS)
//		throw CTestException("Can't register the components. Unable to continue", CTestException::causeOperationFail);
	CString strDataFile=m_SuiteParams->GetTextValue("DATASOURCES", "DATASRC.DEF");
	GetDataInfo(strDataFile);
		
	m_projOpen=0; //hack - proj->IsOpen() does not work

}

BOOL CBindSubSuite::RegisterAll()
{
	HRESULT (FAR /*STDAPICALLTYPE*/__stdcall * lpDllEntryPoint)(void);

	BOOL bVisualC = FALSE;
	BOOL bUnregister = FALSE;
	LPSTR pszRegEntryPoint = _szDllRegSvr;
	LPSTR pszUnregEntryPoint = _szDllUnregSvr;
	CString szOCXfiles[]={
		"MSRDC32.OCX",
		"DBLIST32.OCX",
		"MSMASK32.OCX",
		"DBGRID32.OCX"
	};

	CString pLib;
	const int nLibs=4;
	int i;

	for(i=0;i<nLibs;i++)
	{
		pLib=m_strCWD+szOCXfiles[i];
	// Load the library.	
	HINSTANCE hLib = LoadLibrary(pLib);

	if (hLib < (HINSTANCE)HINSTANCE_ERROR)
	{
		TCHAR szError[12];
		wsprintf(szError, _T("0x%08lx"), GetLastError());
		AfxMessageBox("Library load failed - "+pLib);
		return ERROR_ERROR;
	}

	// Find the entry point.		
	(FARPROC&)lpDllEntryPoint = GetProcAddress(hLib, pszRegEntryPoint);

	if (lpDllEntryPoint == NULL)
	{
		AfxMessageBox("Library Register entry not found - "+pLib);
		FreeLibrary(hLib);
		return ERROR_ERROR;
	}

	// Call the entry point.	
	if (FAILED((*lpDllEntryPoint)()))
	{
		AfxMessageBox("Library Register entry failed - "+pLib);
		FreeLibrary(hLib);
		return ERROR_ERROR;		
	}
//	Info(IDS_CALLSUCCEEDED, pszDllEntryPoint, pszDllName);
	FreeLibrary(hLib);
	} //for
	if(_spawnlp( _P_WAIT, "regedit.exe", "regedit.exe", "/s",
		  m_strCWD + "SQL.REG", NULL )==-1)
	{
		AfxMessageBox("REG file registration failed");
		return ERROR_ERROR;		
	}
	return ERROR_SUCCESS;
}



void CBindSubSuite::CleanUp(void)
{
	int i;
	if (m_prj.IsOpen()) {
		m_prj.Close();
	}
	for(i=0;i<2;i++)
	m_DataInfo[i].ClearAll();
	// remove the project directory
	KillAllFiles(m_strCWD + PROJDIR, TRUE);	
	m_projOpen=0;
	// call the base class
	CIDESubSuite::CleanUp();
}



void CBindSubSuite::GetDataInfo(CString &strDataFile)
{
	CStdioFile fileData(m_strCWD + strDataFile,
							CFile::modeRead | CFile::typeText);
  	const int len=100;
	char buf[len];char *ptoken;
	int i=0;
	CString str("");

//	for(i=0;i<2;i++) --right now, only one server
	if(fileData.ReadString(buf, len))
	{
		m_DataInfo[i].m_strConnect=CString(buf);
		ptoken=strtok(buf,";"); //driver name
		ptoken=strtok(NULL,"="); //"SERVER"
			ASSERT(strcmp(ptoken,"SERVER")==0);
		m_DataInfo[i].m_strServer=strtok(NULL,";");
		ptoken=strtok(NULL,"="); //"DATABASE"
			ASSERT(strcmp(ptoken,"DATABASE")==0);
		m_DataInfo[i].m_strDataB=strtok(NULL,";");
		ptoken=strtok(NULL,"="); //"UID"
			ASSERT(strcmp(ptoken,"UID")==0);
		m_DataInfo[i].m_strUser=strtok(NULL,";");
		ptoken=strtok(NULL,"="); //"PWD"
			ASSERT(strcmp(ptoken,"PWD")==0);
		m_DataInfo[i].m_strPassWord=strtok(NULL,"; ");

		TrimString(&m_DataInfo[i].m_strConnect);
		TrimString(&m_DataInfo[i].m_strServer);
		TrimString(&m_DataInfo[i].m_strDataB);
		TrimString(&m_DataInfo[i].m_strUser);
		TrimString(&m_DataInfo[i].m_strPassWord);
//TODO what to do with registry sources?		m_DataInfo[i].m_strSource="Test"+m_DataInfo[i].m_strServer;
//		m_DataInfo[i].GetDataInfo(fileData); -this is developped below

    // Now get rest of information, if any.
    CString strDelimiter("***");
    BOOL bDone = FALSE;

    while (!bDone && fileData.ReadString(buf, len))
    {
        str = buf;
        TrimString(&str);

        if (!str.IsEmpty() && str.GetAt(0) != ';')
        {
            if (str == strDelimiter)
                bDone = TRUE;
			else 
			{
				CObjectInfo* pNew = new CObjectInfo();
				if(str.Find("TABLE") == 0)
				{	pNew->m_Type=CObjectInfo::TABLE;}
				if(str.Find("VIEW") == 0)
				{	pNew->m_Type=CObjectInfo::VIEW;}
				if(str.Find("QUERY") == 0)
				{	pNew->m_Type=CObjectInfo::PROC;}
				strtok(buf, " "); // TABLE or VIEW or PROC or any valid object
				str=strtok(NULL, " ");
				pNew->m_strName	= str;
				TrimString(&pNew->m_strName);

				str=strtok(NULL, " ");
				pNew->m_strColumn	= str;
				TrimString(&pNew->m_strColumn);

				m_DataInfo[i].m_listMembers.AddTail(pNew);
			}
        }
    } //while
	}//if
} //CBindSubSuite::GetDataInfo

CObjectInfo::~CObjectInfo()
{
	ClearAll();
}

CDataInfo::~CDataInfo()
{
	ClearAll();
}

void CDataInfo::ClearAll()
{ 
    m_strDataB.Empty(); 
    
	POSITION pos = m_listMembers.GetHeadPosition();
	while(pos != NULL)
	{
		delete m_listMembers.GetAt(pos);
		m_listMembers.GetNext(pos);
	}

	m_listMembers.RemoveAll();
}

void CObjectInfo::ClearAll()
{ 
    m_strName.Empty(); 
	m_strColumn.Empty();
}

BOOL SetFocusToResSym(LPCSTR SymName)
{
	//////////////////////TODO do it better below
	if(!UIWB.IsCommandEnabled(IDM_EDIT_SYMBOLS))
	{
		LOG->RecordFailure("ResEdit not enabled");
		return FALSE;
	}
	//MST.DoKeys("%(Vy)",FALSE,5000); //View.Symbols (wait for idle time
	UIWB.DoCommand(IDM_EDIT_SYMBOLS, DC_MNEMONIC);
	WaitForInputIdle(g_hTargetProc, 5000);
	//	if(MST.WListItemExists(cntlrID))
	MST.WListItemClk(GetLabel(0x6814),SymName); 
	MST.WButtonClick(GetLabel(0x681d)); // View use of the dialog

	WaitForInputIdle(g_hTargetProc, 5000);
	return TRUE;
}


// EOF - sniff.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Bin\io_base.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by io_tmpsv.rc
//
#define IDS_STRING1                     1
#define IDD_DIALOG1                     101
#define ID_MENU_ITEM                    101
#define IDR_MENU1                       102
#define ID_MENU_CHECKED                 103
#define IDR_ACCELERATOR1                103
#define ID_MENU_POPUP_GRAYED            104
#define IDR_VERSION1                    104
#define IDR_ACCELERATOR2                104
#define ID_MENU_INACTIVE                105
#define ID_ACCEL107                     107
#define ID_ACCEL108                     108
#define ID_ACCEL109                     109

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         110
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Bin\io_open.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by IO_OPEN.RC
//
#define IDS_STRING1                     1
#define IDD_DIALOG1                     101
#define ID_MENU_ITEM                    101
#define IDR_MENU1                       102
#define ID_MENU_CHECKED                 103
#define IDR_ACCELERATOR1                103
#define ID_MENU_POPUP_GRAYED            104
#define IDR_VERSION1                    104
#define IDR_ACCELERATOR2                104
#define ID_MENU_INACTIVE                105
#define ID_ACCEL107                     107
#define ID_ACCEL108                     108
#define ID_ACCEL109                     109

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         110
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Bin\baseln\io_open.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by IO_OPEN.RC
//
#define IDS_STRING1                     1
#define IDD_DIALOG1                     101
#define ID_MENU_ITEM                    101
#define IDR_MENU1                       102
#define ID_MENU_CHECKED                 103
#define IDR_ACCELERATOR1                103
#define ID_MENU_POPUP_GRAYED            104
#define IDR_VERSION1                    104
#define IDR_ACCELERATOR2                104
#define ID_MENU_INACTIVE                105
#define ID_ACCEL107                     107
#define ID_ACCEL108                     108
#define ID_ACCEL109                     109

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         110
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Bin\symbol.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SYMBOL.RC
//
#define idc_foo                         101
#define id_bar                          102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\bincases.h ===
///////////////////////////////////////////////////////////////////////////////
//	BINCASES.H
//
//	Created by :			Date :
//		ChrisSh					8/13/93
//
//	Description :
//		Declaration of the CBinTestCases class
//

#ifndef __BINCASES_H__
#define __BINCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CBinTestCases class

class CBinTestCases : public CTest
{
	DECLARE_TEST(CBinTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Test Cases
protected:
	BOOL CreateBinaryEditor(void);
	BOOL EnterBinaryData(void);
	BOOL SaveOpen(void);
};

#endif //__BINCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\cpicases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CPICASES.CPP
//
//	Created by :			Date :
//		MikePie				2/28/95
//
//	Description :
//		Implementation of the CCpiTestCases class
//

#include "stdafx.h"
#include "Cpicases.h"

// for _stat CRT function
#include "sys\types.h"
#include "sys\stat.h"

// for rmdir CRT function
#include "direct.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CCpiTestCases, CTest, "Code Page Resource Tests", -1, CSniffDriver)

void CCpiTestCases::Run(void)
{
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CCpiTestCases::CpiNewRC(void)
{
	HWND hwndRC;

	if ((hwndRC = UIWB.CreateNewFile(GetLocString(IDSS_NEW_RC))) == NULL)
	{
		m_pLog->RecordFailure("Could not create RC script");
		UIWB.CloseAllWindows();
		return FALSE;
	}
	else
	{
		// Worked
	}
	UIWB.CloseAllWindows();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\acccases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ACCCASES.CPP
//
//	Created by :			Date :
//		ChrisSh					8/13/93
//
//	Modified by :			Date :			Action :
//		ScottSe					8/8/96			Added several tests in NewAccel() section
//
//	Description :
//		Implementation of the CAccCases class
//

#include "stdafx.h"
#include "acccases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CAccTestCases, CTest, "Accelerator Editor Tests", -1, CSniffDriver)

void CAccTestCases::Run(void)
{
	// Delete previous files
	KillAllFiles(m_strCWD + "TESTOUT", FALSE);

	if ( CreateAccelTable() == FALSE )
 	{
		m_pLog->RecordFailure("Accelerator table creation failed, devres.pkg not loaded");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Accelerator table creation passed");

	if ( NewAccel() == FALSE )
 	{
		m_pLog->RecordFailure("Accelerator items creation failed, possible timing issue");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Accelerator items creation passed");

	if ( SaveOpen() == FALSE )
 	{
		m_pLog->RecordFailure("Failed accelerator IO test");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Accelerator IO passed");

	UIWB.CloseAllWindows();
	XSAFETY;
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CAccTestCases::CreateAccelTable(void)
{
	XSAFETY;
	
	COResScript res;

	if (res.CreateResource(IDSS_RT_ACCELERATOR) == ERROR_ERROR)
	{
		m_pLog->RecordFailure("Create new AccelTable");
		return FALSE;
	}
	return TRUE;
}

BOOL CAccTestCases::NewAccel(void)
{
	XSAFETY;

	//Maximize Window
	MST.DoKeys("%-");
	MST.DoKeys("{DOWN 4}~");


	//Add first accelerator
	MST.DoKeys("{INSERT}");
	MST.DoKeys("A");		//ID_ACCEL40001
	MST.DoKeys("~");
	
	//Check to see if it was named properly
	MST.DoKeys("{UP}");
	CString strID = UIWB.GetProperty(P_ID);
	if (strID.Find("ID_ACCEL40001") != 0) {
		m_pLog->RecordFailure("Incorrect ID given to new Accel: %s", strID);
		return FALSE;
	}
	
	//Add more accelerators
	MST.DoKeys("{INSERT}");
	MST.DoKeys("A");		//ID_ACCEL40002
	MST.DoKeys("~");
	MST.DoKeys("{INSERT}");
	MST.DoKeys("b");		//ID_ACCEL40003
	MST.DoKeys("~");
	MST.DoKeys("{INSERT}");
	MST.DoKeys("z");		//ID_ACCEL40004
	MST.DoKeys("~");
	MST.DoKeys("{INSERT}");
	MST.DoKeys("5");		//ID_ACCEL40005
	MST.DoKeys("~");
	
	//Find the Z accelerator
	UIWB.DoCommand(ID_EDIT_FIND_DLG, DC_MNEMONIC);
	MST.DoKeys("z");
	MST.DoKeys("~");

	//Check to see if we found the right one
	strID = UIWB.GetProperty(P_ID);
	if (strID.Find("ID_ACCEL40004") != 0) {
		m_pLog->RecordFailure("Z accelerator not found: %s", strID);
		return FALSE;
	}

	//Multiple selection of all strings
	MST.DoKeys("{HOME}");
	MST.DoKeys("+{END}");
	MST.DoKeys("+{UP}");

	
	//Change accelerator to X
	MST.DoKeys("%{ENTER}");
	MST.DoKeys("x");
	MST.DoKeys("~");

	//Check to see we changed the top one to X
	MST.DoKeys("{HOME}");
	strID = UIWB.GetProperty(P_Key);
	if (strID.Find("X") != 0) {
		m_pLog->RecordFailure("Top accelerator not changed to X: %s", strID);
		return FALSE;
	}

	//Undo the change
	UIWB.DoCommand(ID_EDIT_UNDO, DC_MNEMONIC);
	
	//Check to see we changed the top one back to 5
	MST.DoKeys("{HOME}");
	strID = UIWB.GetProperty(P_Key);
	if (strID.Find("5") != 0) {
		m_pLog->RecordFailure("Top accelerator not undo'd correctly to 5: %s", strID);
		return FALSE;
	}

	return TRUE;
}

BOOL CAccTestCases::SaveOpen(void)
{
	XSAFETY;

	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "testout\\Accel .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "testout\\Accel .rc");
		return FALSE;
	}
	Sleep(1500);

	//close file
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	//reopen file
	HWND hwnd = UIWB.OpenFile(m_strCWD + "testout\\Accel .rc");
	if (hwnd == NULL)
	{
		m_pLog->RecordFailure("File-Open failed on %s", m_strCWD + "testout\\Accel .rc");
		return FALSE;
	}

	//Reopen editor
	MST.DoKeys("{DOWN}~{DOWN}~");

	//Make sure it opened
	MST.DoKeys("{HOME}");
	CString strID = UIWB.GetProperty(P_ID);
	if (strID.Find("ID_ACCEL40005") != 0) {
		m_pLog->RecordFailure("File not opened, returned ID: %s", strID);
		return FALSE;
	}

	//Close it again
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\acccases.h ===
///////////////////////////////////////////////////////////////////////////////
//	ACCCASES.H
//
//	Created by :			Date :
//		ChrisSh					8/13/93
//
//	Description :
//		Declaration of the CAccTestCases class
//

#ifndef __ACCCASES_H__
#define __ACCCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CAccTestCases class

class CAccTestCases : public CTest
{
	DECLARE_TEST(CAccTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:

// Test Cases
protected:
 	BOOL CreateAccelTable(void);
	BOOL NewAccel(void);
	BOOL SaveOpen(void);
};

#endif //__ACCCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\brzcases.h ===
///////////////////////////////////////////////////////////////////////////////
//    BRZCASES.H
//
//    Created by :                    Date :
//            DougT                                   10/13/93
//
//    Description :
//            Declaration of the CBrzTestCases class
//
 
#ifndef __BRZCASES_H__
#define __BRZCASES_H__

#ifndef __STDAFX_H__
      #error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CBrzTestCases class

class CBrzTestCases : public CTest
{
	DECLARE_TEST(CBrzTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Test Cases
protected:
      BOOL BrzEnumRes(void);
	  BOOL BrzCreateRCT(void);
};

#endif //__BRZCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\bincases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BINCASES.CPP
//
//	Created by :			Date :
//		ChrisSh					8/13/93
//
//	Description :
//		Implementation of the CBinTestCases class
//

#include "stdafx.h"
#include "bincases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBinTestCases, CTest, "Binary Editor Tests", -1, CSniffDriver)

void CBinTestCases::Run(void)
{
	// Delete previous files
	KillAllFiles(m_strCWD + "TESTOUT", FALSE);

	//Create new binary resource
	if ( CreateBinaryEditor() == FALSE )
 	{
		m_pLog->RecordFailure("Binary editor not enabled");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Binary editor enabled");

	// Put some data in it
	if ( EnterBinaryData() == FALSE )
 	{
		m_pLog->RecordFailure("Binary data creation failed, possible timing issue");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Binary data entry passed");

	// Save & Open
	if ( SaveOpen() == FALSE )
 	{
		m_pLog->RecordFailure("Failed binary IO test");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Binary IO passed");

	UIWB.CloseAllWindows();
	XSAFETY;
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CBinTestCases::CreateBinaryEditor(void)
{
	XSAFETY;

	COResScript res;

	if (res.CreateResource(IDSS_RT_BINARY) == ERROR_ERROR)
	{
		m_pLog->RecordFailure("Could not create new binary resource");
		return FALSE;
	}
	return TRUE;
}

BOOL CBinTestCases::EnterBinaryData(void)
{
	XSAFETY;

	// Enter some data both in ASCII and HEX
	MST.DoKeys("616263{TAB}def");	
	MST.DoKeys("{HOME}+({END})");	// Highlight entire line
	MST.DoKeys("^({INSERT})");		// Copy text into Clipboard

	//Check to see if string was copied correctly
	CString str;
	GetClipText(str);
	if (str != "abcdef") 
	{
		m_pLog->RecordFailure("Binary Data not copied to clipboard correctly:", str);
		return FALSE;
	}
	
	//Add some international text
	MST.DoKeys("{END}");
	MST.DoKeys("");

	// Search for  character
	MST.DoKeys("%{F3}");
	MST.DoKeys("");
	MST.DoKeys("~");
	
	//Check to see if we found it
 	UIWB.DoCommand( ID_EDIT_COPY, DC_ACCEL );
	GetClipText(str);
	if (str != "") 
	{
		m_pLog->RecordFailure(" character not found correctly:", str);
		return FALSE;
	}

	//Goto specific offset
	UIWB.DoCommand(IDM_GOTO_LINE, DC_MNEMONIC);
	MST.DoKeys("4");	//should be 'e'
	MST.DoKeys("~");
	MST.DoKeys("{ESC}");

	//Check to see if we found it
 	UIWB.DoCommand( ID_EDIT_COPY, DC_ACCEL );
	GetClipText(str);
	if (str != "e") 
	{
		m_pLog->RecordFailure("Goto failed:", str);
		return FALSE;
	}

	return TRUE;
}


BOOL CBinTestCases::SaveOpen(void)
{
	XSAFETY;

	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "testout\\Binary .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "testout\\Binary .rc");
		return FALSE;
	}
	Sleep(500);

	//close file
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	//reopen file
	HWND hwnd = UIWB.OpenFile(m_strCWD + "testout\\Binary .rc");
	if (hwnd == NULL)
	{
		m_pLog->RecordFailure("File-Open failed on %s", m_strCWD + "testout\\Binary .rc");
		return FALSE;
	}

	//Reopen editor
	MST.DoKeys("{DOWN}~{DOWN}~");

	//Make sure it opened
	MST.DoKeys("+{RIGHT}");
 	UIWB.DoCommand( ID_EDIT_COPY, DC_ACCEL );
	CString str;
	GetClipText(str);
	if (str != "a") 
	{
		m_pLog->RecordFailure("File not opened, returned String: %s", str);
		return FALSE;
	}

	//Close it again
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\brzcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BRZCASES.CPP
//
//	Created by :			Date :
//		DougT					10/13/93
//
//	Description :
//		Implementation of the CBrzTestCases class
//

#include "stdafx.h"
#include "brzcases.h"

// for _stat CRT function
#include "sys\types.h"
#include "sys\stat.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBrzTestCases, CTest, "Resource Browser Tests", -1, CSniffDriver)

void CBrzTestCases::Run(void)
{
	
	XSAFETY;
	BrzEnumRes();
	BrzCreateRCT();
	UIWB.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CBrzTestCases::BrzEnumRes(void)
{
	CString strPropTxt;
	
	// Recycle the RC file from the IO_ test. Substitute a perhaps-larger
	// one later that has more interesting cases. But for now, just use
	// this one to come up with a generic Enumeration of Any algorithm
	// That way, all that has to be done is to change the name here.
	HWND hwnd = UIWB.OpenFile(m_strCWD + "io_open.rc");
	
	Sleep(400);
	MST.DoKeys("{DOWN}");  		// Accelerator resource type indicator
	Sleep(400);
	MST.DoKeys("{ENTER}");		// expose accelerator tables
	Sleep(400);
	
	MST.DoKeys("{DOWN}");	// first accelerator table resource
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "IDR_ACCELERATOR1") {
		m_pLog->RecordFailure("strPropTxt != IDR_ACCELERATOR1");
	}
	
	Sleep(500);
	MST.DoKeys("{DOWN}");	// second accelerator table resource
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "IDR_ACCELERATOR2") {
		m_pLog->RecordFailure("strPropTxt != IDR_ACCELERATOR2");
	}
	
	Sleep(500); 
	MST.DoKeys("{DOWN}");	// Dialog resource type indicator
	Sleep(400);
	MST.DoKeys("{ENTER}");		// expose dialog resources
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "Empty Property") {
		m_pLog->RecordFailure("strPropTxt != Empty Property");
	}
	
	Sleep(1000);
	MST.DoKeys("{DOWN}");	// first (and only) dialog resource
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "IDD_DIALOG1") {
		m_pLog->RecordFailure("strPropTxt != IDD_DIALOG1");
	}
	
	Sleep(400);
	MST.DoKeys("{DOWN}");	// Menu resource type indicator
	Sleep(400);
	MST.DoKeys("{ENTER}");		// expose menu resources
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "Empty Property") {
		m_pLog->RecordFailure("strPropTxt != Empty Property");
	}
	
	Sleep(400);
	MST.DoKeys("{DOWN}");	// first menu resource
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "IDR_MENU1") {
		m_pLog->RecordFailure("strPropTxt != IDR_MENU1");
	}
	
	Sleep(400);
	MST.DoKeys("{DOWN}");	// String Table resource type indicator (no symbols)
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "Empty Property") {
		m_pLog->RecordFailure("strPropTxt != Empty Property");
	}
	
	Sleep(400);
	MST.DoKeys("{DOWN}");	// Version resource type indicator
	Sleep(400);
	MST.DoKeys("{ENTER}");		// expose version resource
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "Empty Property") {
		m_pLog->RecordFailure("strPropTxt != Empty Property");
	}
	
	MST.DoKeys("{DOWN}");
	strPropTxt = UIWB.GetProperty(3);
	if (strPropTxt != "IDR_VERSION1") {
		m_pLog->RecordFailure("strPropTxt != IDR_VERSION1");
	}
	
	Sleep(400);
	MST.DoKeys("{ENTER}");		// close version resource display
	MST.DoKeys("{UP 3}");		// move past String Table and prepare to close menu list
	MST.DoKeys("{ENTER}");		// close menu resource display
	MST.DoKeys("{UP 2}");		// move past ID into Dialog
	MST.DoKeys("{ENTER}");		// close dialog resource display
	MST.DoKeys("{UP 3}");		// move past IDs into Accelerator
	MST.DoKeys("{ENTER}");		// close accelerator resource display
	MST.DoKeys("{UP}");			// move to RC hierarchy entry
	MST.DoKeys("{ENTER}");		// close all RC resource type displays

	return TRUE;  
}

BOOL CBrzTestCases::BrzCreateRCT(void)
{
	
	XSAFETY;

	UIWB.DoCommand(ID_FILE_NEW, DC_ACCEL);	
	UIDialog nd(0x64,GL_LISTBOX);
	if( !nd.WaitAttachActive(1000) )
	{
		LOG->RecordInfo("Could not open File/New dialog");
		return NULL;
	}

	MST.DoKeys("{DOWN 3}");
	nd.OK();
	nd.WaitUntilGone(1000);
	
	UIEditor ed = UIWB.GetActiveEditor();

	return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\cpicases.h ===
///////////////////////////////////////////////////////////////////////////////
//    CPICASES.H
//
//    Created by :                    Date :
//            MikePie                 2/28/95
//
//    Description :
//            Declaration of the CCpiTestCases class
//
 
#ifndef __CPICASES_H__
#define __CPICASES_H__

#ifndef __STDAFX_H__
      #error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CCpiTestCases class

class CCpiTestCases : public CTest
{
	DECLARE_TEST(CCpiTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Test Cases
protected:
	BOOL CpiNewRC(void);
};

#endif //__CPICASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\imgcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	IMGCASES.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Implementation of the CImgTestCases class
//
// -------------------------------------------------------
//	Modified by :			Date :			Description:
//		MikePie					04/28/95		Added 48x48 icons and repaired first two tests
//		MikePie					05/04/95		Changed MST keystrokes to reflect menu change
//		ScottSe					06/07/96		Up commands changed to "E" to reflect popup menu change
//		ScottSe					07/02/96        File compare commented out due to many false failures
//		ScottSe					08/07/96		Added {ESC} at end of 48X48 Icon test to dismis properties dialog
//		ScottSe					09/13/96		Major rewrite of the test
//
#include "stdafx.h"
#include "imgcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CImgTestCases, CTest, "Image Editor Tests", -1, CSniffDriver)

void CImgTestCases::Run(void)
{

	// Delete previous img files
	KillFile(m_strCWD + "TESTOUT", "IMG*.*");

	HWND hwndRC;

	XSAFETY;

	if((hwndRC = UIWB.CreateNewFile(GetLocString(IDSS_NEW_RC))) == NULL)
	{
		m_pLog->RecordFailure("Could not create RC script");
		UIWB.CloseAllWindows();
		return;
	}
	else
	{
		if (!TestBitmap())
		{
			m_pLog->RecordFailure("Failed Bitmap Test");
			UIWB.CloseAllWindows();
			return;
		}
		if (!TestIcon())
 		{
			m_pLog->RecordFailure("Failed Icon Test");
			UIWB.CloseAllWindows();
			return;
		}
		if (!TestIconDevices())
 		{
			m_pLog->RecordFailure("Failed Icon Devices Test");
			UIWB.CloseAllWindows();
			return;
		}
		if (!TestCursor())
 		{
			m_pLog->RecordFailure("Failed Cursor Test");
			UIWB.CloseAllWindows();
			return;
		}
		if (!TestGIF_JPEG())
 		{
			m_pLog->RecordFailure("Failed GIF_JPEG Test");
			UIWB.CloseAllWindows();
			return;
		}

	}
	UIWB.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CImgTestCases::TestBitmap(void)
{
	XSAFETY;

	COResScript res;

	//Create new bitmap
	if (res.CreateResource(IDSS_RT_BITMAP) == ERROR_ERROR)
	{
		m_pLog->RecordFailure("Unable to create new bitmap");
		return FALSE;
	}
	Sleep(1500);

    m_uBmpEd = UIWB.GetActiveEditor();

	// Pencil tool
	m_uBmpEd.SetColor(2, VK_LBUTTON);			
	m_uBmpEd.ClickImgTool(GT_PENCIL);			
	m_uBmpEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 5, 5, 10, 40, 6);
	
	// Brush tool
	m_uBmpEd.SetColor(4, VK_LBUTTON);			
	m_uBmpEd.ClickImgTool(GT_BRUSH);			
	m_uBmpEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 5, 2, 40, 10, 6);
	
	// Fillrect tool
	m_uBmpEd.SetColor(5, VK_LBUTTON);			
	m_uBmpEd.ClickImgTool(GT_FILLRECT);			
	m_uBmpEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 3, 20, 13, 30, 6);
	
	// Rect tool
	m_uBmpEd.SetColor(6, VK_LBUTTON);			
	m_uBmpEd.ClickImgTool(GT_RECT);			
	m_uBmpEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 15, 15, 43, 45, 6);

	// Fill tool
	m_uBmpEd.SetColor(7, VK_LBUTTON);			
	m_uBmpEd.ClickImgTool(GT_FILL);			
	m_uBmpEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 25, 25, 26, 26, 6);

	// Filled circle with outline tool
	m_uBmpEd.SetColor(8, VK_LBUTTON);			
	m_uBmpEd.SetColor(9, VK_RBUTTON);			
	m_uBmpEd.ClickImgTool(GT_COMBOROUND);			
	m_uBmpEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 20, 20, 37, 37, 6);

	// Erase tool
	m_uBmpEd.SetColor(10, VK_RBUTTON);			
	m_uBmpEd.ClickImgTool(GT_ERASER);			
	m_uBmpEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 42, 42, 43, 43, 6);

	// Resize Bitmap
	m_uBmpEd.SetColor(11, VK_RBUTTON);			
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	prop.IsValid();
	MST.WEditSetText(prop.GetLabel(VRES_IDC_WIDTH), "60");		// change width
	MST.WEditSetText(prop.GetLabel(VRES_IDC_FILENAME), "TESTOUT\\IMG_BMP1.BMP");		// change name
	UIWB.ShowPropPage(FALSE);	
	
	// Copy to clipboard for icon test
 	UIWB.DoCommand( ID_EDIT_COPY, DC_ACCEL );
	
	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "Icon .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "Bitmap .rc");
		return FALSE;
	}
	Sleep(1500);

	// Compare file with baseline doesn't work, don't know why
	//int nResult = CompareFiles(m_strCWD + "TESTOUT\\IMG_BMP1.BMP", m_strCWD + "BASELN\\IMG_BMP1.BMP", 200);
	//if (nResult != CF_SAME)
	//{
	// 	m_pLog->RecordFailure("New bitmap is different from baseline: result = %d", nResult);
	//	return FALSE;
	//}

	// Close editor	
	MST.DoKeys("^{F4}");
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
		return FALSE;
	}

	// Open new bitmap
	UIImgEdit   img = UIWB.OpenFile(m_strCWD + "TESTOUT\\IMG_BMP1.BMP");
	
	// Make sure it's an editor but not a resource editor.
	UIEditor    ed2 = UIWB.GetActiveEditor();
	UIResEditor ed3 = UIWB.GetActiveEditor();
	if (!ed2.IsValid() || ed3.IsValid())
	{
		m_pLog->RecordFailure("Opened standalone bitmap incorrectly: %s", (LPCSTR)img.GetText());
		return FALSE;
	}

	// Close bitmap
	if (!img.Close() )
	{
		m_pLog->RecordFailure("Could not close standalone bitmap");
		
		return FALSE;
	}

	// Open large 256 color bitmap
	img = UIWB.OpenFile(m_strCWD + "ms01-10.BMP");
	
	// Make sure it's an editor but not a resource editor.
	ed2 = UIWB.GetActiveEditor();
	ed3 = UIWB.GetActiveEditor();
	if (!ed2.IsValid() || ed3.IsValid()) {
		m_pLog->RecordFailure("Opened standalone bitmap: %s", (LPCSTR)img.GetText());
		return FALSE;
	}

	// Turn it to monochrome
	prop = UIWB.ShowPropPage(TRUE);
	prop.IsValid();
	MST.WComboItemClk(prop.GetLabel(VRES_IDC_COLORS), 1);	
	UIWB.ShowPropPage(FALSE);

	//Undo the change
	UIWB.DoCommand( ID_EDIT_UNDO, DC_ACCEL );

	// Make sure it was undone
	CString strID = UIWB.GetProperty(P_Colors);
	if (strID != "2")
	{
		m_pLog->RecordFailure("Color change not undone correctly P_Colors = %s", strID);
		return FALSE;
	}

	// Close bitmap
	if (!img.Close() )
	{
		m_pLog->RecordFailure("Could not close 256 color bitmap");
		return FALSE;
	}

	return TRUE;
}


BOOL CImgTestCases::TestIcon(void)
{
	XSAFETY;

	COResScript res;

	//Create new icon
	if (res.CreateResource(IDSS_RT_ICON) == ERROR_ERROR)
	{
		m_pLog->RecordFailure("Unable to create new icon");
		return FALSE;
	}
	Sleep(1500);

	m_uIcoEd = UIWB.GetActiveEditor();

	// Fill with inverse color using RButton
	m_uIcoEd.SetColor(-1, VK_RBUTTON);
	m_uIcoEd.ClickImgTool(GT_FILL);
	ClickMouse(VK_RBUTTON, m_uIcoEd.HWnd(), 10, 40);
					
	// Erase 
	m_uIcoEd.ClickImgTool(GT_ERASER);
	m_uIcoEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 14, 10, 18, 14, 6);

	// Paste Clipboard contents 
 	UIWB.DoCommand(ID_EDIT_PASTE, DC_MESSAGE);

	// Set icon name
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	prop.IsValid();
	MST.WEditSetText(prop.GetLabel(VRES_IDC_FILENAME), "TESTOUT\\IMG_ICO1.ICO");		// change name
	UIWB.ShowPropPage(FALSE);	

	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "Icon .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "Icon .rc");
		return FALSE;
	}
	Sleep(1500);

	// Compare icon with baseline
	//int nResult = CompareFiles(m_strCWD + "TESTOUT\\IMG_ICO1.ICO", m_strCWD + "BASELN\\IMG_ICO1.ICO", 200);
	//if (nResult != CF_SAME)
	//{
	// 	m_pLog->RecordFailure("New icon is different from baseline: result = %d", nResult);
	//	return FALSE;
	//}

	// Close editor	
	MST.DoKeys("^{F4}");
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
		return FALSE;
	}

	// Open new icon
	UIImgEdit   img = UIWB.OpenFile(m_strCWD + "TESTOUT\\IMG_ICO1.ICO");
	
	// Make sure it's an editor but not a resource editor.
	UIEditor    ed2 = UIWB.GetActiveEditor();
	UIResEditor ed3 = UIWB.GetActiveEditor();
	if (!ed2.IsValid() || ed3.IsValid())
	{
		m_pLog->RecordFailure("Opened standalone icon incorrectly: %s", (LPCSTR)img.GetText());
		return FALSE;
	}

	// Close icon 
	if (!img.Close() )
	{
		m_pLog->RecordFailure("Could not close standalone icon");
		return FALSE;
	}

	return TRUE;
}

BOOL CImgTestCases::TestIconDevices(void)
{
	XSAFETY;

	//Create new icon
	COResScript res;
	if (res.CreateResource(IDSS_RT_ICON) == ERROR_ERROR)
	{
		m_pLog->RecordFailure("Unable to create new icon");
		return FALSE;
	}
	Sleep(1500);

	m_uIcoEd = UIWB.GetActiveEditor();
	
	// Draw on it 
	m_uIcoEd.SetColor(12, VK_LBUTTON);	// blue
	m_uIcoEd.ClickImgTool(GT_BRUSH);
	m_uIcoEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 4, 10, 18, 14, 6);
	
	//Create a new image for every available device
	int nDevices;
	do
	{
		UIWB.DoCommand( IDM_NEWDEVIMG, DC_ACCEL );
		Sleep(500);
		nDevices = MST.WListCount( GetLabel(VRES_ID_LIST) );
		if (nDevices > 0)
		{
			//Select the highlighted item on the list
			MST.DoKeys("~");
			Sleep(500);

			// Draw on it 
			m_uIcoEd.SetColor(12 + nDevices, VK_LBUTTON);	
			m_uIcoEd.ClickImgTool(GT_BRUSH);
			m_uIcoEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 4, 10, 14, 14, 6);
		}
		else if (nDevices == -1)	//not found
		{
			m_pLog->RecordInfo("No icon devices found");
			MST.DoKeys("{ESC}");
		}
		
	} while (nDevices > 1);

	// Set icon name
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	prop.IsValid();
	MST.WEditSetText(prop.GetLabel(VRES_IDC_FILENAME), "TESTOUT\\IMG_ICO2.ICO");		// change name
	UIWB.ShowPropPage(FALSE);	

	// Close Editor
	MST.DoKeys("^({F4})"); 
	
	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "DevicesIcon .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "DevicesIcon .rc");
		return FALSE;
	}
	Sleep(1500);
	
	// Compare icon with baseline
	//int nResult = CompareFiles(m_strCWD + "TESTOUT\\IMG_ICO2.ICO", m_strCWD + "BASELN\\IMG_ICO2.ICO", 200);
	//if (nResult != CF_SAME)
	//{
	// 	m_pLog->RecordFailure("New devices icon is different from baseline: result = %d", nResult);
	//	return FALSE;
	//}

	// Close editor	
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
		return FALSE;
	}

	// Open new icon
	UIImgEdit   img = UIWB.OpenFile(m_strCWD + "TESTOUT\\IMG_ICO2.ICO");
	
	// Make sure it's an editor but not a resource editor.
	UIEditor    ed2 = UIWB.GetActiveEditor();
	UIResEditor ed3 = UIWB.GetActiveEditor();
	if (!ed2.IsValid() || ed3.IsValid())
	{
		m_pLog->RecordFailure("Opened standalone device icon incorrectly: %s", (LPCSTR)img.GetText());
		return FALSE;
	}

	// Close icon 
	if (!img.Close() )
	{
		m_pLog->RecordFailure("Could not close standalone device icon");
		return FALSE;
	}
	
	return TRUE;
}

BOOL CImgTestCases::TestCursor(void)
{
	XSAFETY;

	COResScript res;

	//Create new cursor
	if (res.CreateResource(IDSS_RT_CURSOR) == ERROR_ERROR)
	{
		m_pLog->RecordFailure("Unable to create new cursor");
		return FALSE;
	}
	Sleep(1500);

	m_uIcoEd = UIWB.GetActiveEditor();

	// Draw on it 
	m_uIcoEd.SetColor(1, VK_LBUTTON);	
	m_uIcoEd.ClickImgTool(GT_BRUSH);
	m_uIcoEd.DragMouse(VK_LBUTTON, PANE_RIGHT, 4, 10, 18, 14, 6);

	// Set cursor name
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	prop.IsValid();
	MST.WEditSetText(prop.GetLabel(VRES_IDC_FILENAME), "TESTOUT\\IMG_CUR1.CUR");		// change name
	UIWB.ShowPropPage(FALSE);	

	// Close editor	
	MST.DoKeys("^{F4}");

	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "Cursor .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "Cursor .rc");
		return FALSE;
	}
	Sleep(1500);

	// Compare cursor with baseline
	//int nResult = CompareFiles(m_strCWD + "TESTOUT\\IMG_CUR1.CUR", m_strCWD + "BASELN\\IMG_CUR1.CUR", 200);
	//if (nResult != CF_SAME)
	//{
	// 	m_pLog->RecordFailure("New cursor is different from baseline: result = %d", nResult);
	//	return FALSE;
	//}

	// Close editor	
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
		return FALSE;
	}

	// Open new icon
	UIImgEdit   img = UIWB.OpenFile(m_strCWD + "TESTOUT\\IMG_CUR1.CUR");
	
	// Make sure it's an editor but not a resource editor.
	UIEditor    ed2 = UIWB.GetActiveEditor();
	UIResEditor ed3 = UIWB.GetActiveEditor();
	if (!ed2.IsValid() || ed3.IsValid())
	{
		m_pLog->RecordFailure("Opened standalone cursor incorrectly: %s", (LPCSTR)img.GetText());
		return FALSE;
	}

	// Close cursor 
	if (!img.Close() )
	{
		m_pLog->RecordFailure("Could not close standalone icon");
		return FALSE;
	}

	return TRUE;
}

BOOL CImgTestCases::TestGIF_JPEG(void)
{
	XSAFETY;

	// Open GIF file
	UIImgEdit   img = UIWB.OpenFile(m_strCWD + "ireland.gif");
	
	// Make sure it's an editor but not a resource editor.
	UIEditor    ed2 = UIWB.GetActiveEditor();
	UIResEditor ed3 = UIWB.GetActiveEditor();
	if (!ed2.IsValid() || ed3.IsValid())
	{
		m_pLog->RecordFailure("Opened standalone GIF incorrectly: %s", (LPCSTR)img.GetText());
		return FALSE;
	}

	//Make sure it came in correctly
	CString strID = UIWB.GetProperty(P_Width);
	if (strID != "427")
	{
		m_pLog->RecordFailure("GIF incorrect size P_Width = %s", strID);
		return FALSE;
	}
	strID = UIWB.GetProperty(P_Height);
	if (strID != "291")
	{
		m_pLog->RecordFailure("GIF incorrect size P_Height = %s", strID);
		return FALSE;
	}
	strID = UIWB.GetProperty(P_Colors);
	if (strID != "2")
	{
		m_pLog->RecordFailure("GIF colors not imported correctly P_Colors = %s", strID);
		return FALSE;
	}

	// Save it as a bitmap
	UIWB.DoCommand(ID_FILE_SAVE_AS, DC_MNEMONIC);
	MST.DoKeys( m_strCWD + "TESTOUT\\IMG_GIF.BMP" );
	MST.DoKeys( "~" );

	// Compare with baseline
	//int nResult = CompareFiles(m_strCWD + "TESTOUT\\\\IMG_GIF.BMP", m_strCWD + "BASELN\\\\IMG_GIF.BMP", 200);
	//if (nResult != CF_SAME)
	//{
	// 	m_pLog->RecordFailure("GIF bitmaps is different from baseline: result = %d", nResult);
	//	return FALSE;
	//}

	// Close editor	
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
		return FALSE;
	}

	// Open JPG file
	img = UIWB.OpenFile(m_strCWD + "SKULL.JPG");
	
	// Make sure it's an editor but not a resource editor.
	ed2 = UIWB.GetActiveEditor();
	ed3 = UIWB.GetActiveEditor();
	if (!ed2.IsValid() || ed3.IsValid())
	{
		m_pLog->RecordFailure("Opened standalone JPG incorrectly: %s", (LPCSTR)img.GetText());
		return FALSE;
	}

	//Make sure it came in correctly
	strID = UIWB.GetProperty(P_Width);
	if (strID != "299")
	{
		m_pLog->RecordFailure("JPG incorrect size P_Width = %s", strID);
		return FALSE;
	}
	strID = UIWB.GetProperty(P_Height);
	if (strID != "435")
	{
		m_pLog->RecordFailure("JPG incorrect size P_Height = %s", strID);
		return FALSE;
	}
	strID = UIWB.GetProperty(P_Colors);
	if (strID != "2")
	{
		m_pLog->RecordFailure("JPG colors not imported correctly P_Colors = %s", strID);
		return FALSE;
	}

	// Save it as a bitmap
	UIWB.DoCommand(ID_FILE_SAVE_AS, DC_MNEMONIC);
	MST.DoKeys( m_strCWD + "TESTOUT\\IMG_JPG.BMP" );
	MST.DoKeys( "~" );

	// Compare with baseline
	//nResult = CompareFiles(m_strCWD + "TESTOUT\\\\IMG_JPG.BMP", m_strCWD + "BASELN\\\\IMG_JPG.BMP", 200);
	//if (nResult != CF_SAME)
	//{
	// 	m_pLog->RecordFailure("JPG bitmaps is different from baseline: result = %d", nResult);
	//	return FALSE;
	//}

	// Close editor	
	ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\dlgcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DLGCASES.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Edited By :				Date :
//		ScottSe					8/29/96
//
//	Description :
//		Implementation of the CDlgTestCases class
//

#include "stdafx.h"
#include "dlgcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CDlgTestCases, CTest, "Dialog Editor Tests", -1, CSniffDriver)

void CDlgTestCases::Run(void)
{
	// Delete previous files
	KillAllFiles(m_strCWD + "TESTOUT", FALSE);

	//Create new dialog
	if ( CreateDlgRes() == FALSE )
 	{
		m_pLog->RecordFailure("Dialog creation failed, devres.pkg not loaded");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Dialog creation passed");

	// Put some controls on it
	if ( DropControls() == FALSE )
 	{
		m_pLog->RecordFailure("Dialog items creation failed, possible timing issue");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Dialog items creation passed");

	//Find, copy, paste, etc.
	if ( FindControls() == FALSE )
 	{
		m_pLog->RecordFailure("Dialog edit operations failed, possible timing issue");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Dialog edit operations passed");

	// Save & Open
	if ( SaveOpen() == FALSE )
 	{
		m_pLog->RecordFailure("Failed Dialog IO test");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Dialog IO passed");

	// Test Dialog
	if ( TestDialog() == FALSE )
 	{
		m_pLog->RecordFailure("Failed Dialog test mode");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Dialog test mode passed");

	UIWB.CloseAllWindows();
	XSAFETY;
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CDlgTestCases::CreateDlgRes(void)	  
{
	COResScript res;

	XSAFETY;

	res.CreateResource(IDSS_RT_DIALOG);

	m_uDlgEd = UIWB.GetActiveEditor();
	if (!m_uDlgEd.IsValid()) {
		m_pLog->RecordFailure("Unable to create Dialog Resource");
		return FALSE;
	}

	//Turn off guides
	Sleep(500);
	UIWB.DoCommand(IDM_GRIDSETTINGS,  DC_MNEMONIC);
	Sleep(500);
	MST.WOptionClick( GetLabel(VRES_IDC_GUIDES0) );
	MST.DoKeys("~");

	//Resize dialog height
	MST.DoKeys("+{DOWN 60}");

	//Resize dialog height
	//MST.DoKeys("+{DOWN 165}");

	//Resize dialog width
	//MST.DoKeys("+{RIGHT 40}");

	// Close and reopen dialog
	MST.DoKeys("^{F4}");	
	MST.DoKeys("~");
	m_uDlgEd = UIWB.GetActiveEditor();

	return TRUE;
}

BOOL CDlgTestCases::DropControls(void)
{
	XSAFETY;
	
	//Drop picture control
	m_uDlgEd.DropControl(CT_PICTURE, 10, 10 );
	
	//Drop static text control
	m_uDlgEd.DropControl(CT_TEXT, 10, 55 );
	
	//Drop edit control
	m_uDlgEd.DropControl(CT_EDIT, 10, 80 );
	
	//Drop group box control
	m_uDlgEd.DropControl(CT_GROUP, 120, 10 );
	
	//Drop button control
	m_uDlgEd.DropControl(CT_BUTTON, 230, 80 );
	
	//Drop check box control
	m_uDlgEd.DropControl(CT_CHECK, 125, 30 );

	//Drop radio button control
	m_uDlgEd.DropControl(CT_RADIO, 125, 50 );

	//Drop combo box control
	m_uDlgEd.DropControl(CT_DROPDOWN, 120, 100 );

	//Drop list box control
	m_uDlgEd.DropControl(CT_LIST, 229, 125 );

	//Drop hscroll control
	m_uDlgEd.DropControl(CT_HSCROLL, 10, 105 );
	
	//Drop vscroll control
	m_uDlgEd.DropControl(CT_VSCROLL, 175, 10 );

	//Drop spin control
	m_uDlgEd.DropControl(CT_SPIN, 60, 10 );

	//Drop progress control
	m_uDlgEd.DropControl(CT_PROGRESS, 10, 130 );

	//Drop slider control
	m_uDlgEd.DropControl(CT_SLIDER, 10, 160 );

	//Drop hot key control
	m_uDlgEd.DropControl(CT_HOTKEY, 10, 185 );

	//Drop animate control
	m_uDlgEd.DropControl(CT_ANIMATE, 175, 100 );

	//Drop rich edit control
	m_uDlgEd.DropControl(CT_RICHEDIT, 155, 135 );

	//Drop tab control
	m_uDlgEd.DropControl(CT_TAB, 125, 225 );

	//Drop listctrl control
	m_uDlgEd.DropControl(CT_LISTCTL, 225, 205 );

	//Drop date/time picker control
	//m_uDlgEd.DropControl(CT_DATETIMEPICKER, 10, 275 );

	//Drop calendar control
	//m_uDlgEd.DropControl(CT_MONTHCALENDAR, 240, 340 );

	//Drop IP address control
	//m_uDlgEd.DropControl(CT_IPADDRESS, 10, 305 );

	//Drop custom control
	m_uDlgEd.DropControl(CT_USER, 10, 215 );

	//Check to see that the dialog was created with proper ID
	if ( CheckCreation( "IDD_DIALOG1" ) == FALSE )
		return FALSE;

	//Check to see that the next control is an IDOK
	if ( CheckCreation( "IDOK" ) == FALSE )
		return FALSE;

	//Check to see that the next control is an IDCANCEL
	if ( CheckCreation( "IDCANCEL" ) == FALSE )
		return FALSE;

	//Check to see that the picture control was created with the proper ID
	if ( CheckCreation( "IDC_STATIC" ) == FALSE )
		return FALSE;

	//Check to see that the static text control was created with the proper ID
	if ( CheckCreation( "IDC_STATIC" ) == FALSE )
		return FALSE;

	//Check to see that the edit control was created with the proper ID
	if ( CheckCreation( "IDC_EDIT1" ) == FALSE )
		return FALSE;

	//Check to see that the group box control was created with the proper ID
	if ( CheckCreation( "IDC_STATIC" ) == FALSE )
		return FALSE;

	//Check to see that the button control was created with the proper ID
	if ( CheckCreation( "IDC_BUTTON1" ) == FALSE )
		return FALSE;

	//Check to see that the check box control was created with the proper ID
	if ( CheckCreation( "IDC_CHECK1" ) == FALSE )
		return FALSE;

	//Check to see that the radio control was created with the proper ID
	if ( CheckCreation( "IDC_RADIO1" ) == FALSE )
		return FALSE;

	//Check to see that the combo control was created with the proper ID
	if ( CheckCreation( "IDC_COMBO1" ) == FALSE )
		return FALSE;

	//Check to see that the list control was created with the proper ID
	if ( CheckCreation( "IDC_LIST1" ) == FALSE )
		return FALSE;

	//Check to see that the horizontal scrollbar control was created with the proper ID
	if ( CheckCreation( "IDC_SCROLLBAR1" ) == FALSE )
		return FALSE;

	//Check to see that the vertical scrollbar control was created with the proper ID
	if ( CheckCreation( "IDC_SCROLLBAR2" ) == FALSE )
		return FALSE;

	//Check to see that the spin control was created with the proper ID
	if ( CheckCreation( "IDC_SPIN1" ) == FALSE )
		return FALSE;

	//Check to see that the progress control was created with the proper ID
	if ( CheckCreation( "IDC_PROGRESS1" ) == FALSE )
		return FALSE;

	//Check to see that the slider control was created with the proper ID
	if ( CheckCreation( "IDC_SLIDER1" ) == FALSE )
		return FALSE;

	//Check to see that the hot key control was created with the proper ID
	if ( CheckCreation( "IDC_HOTKEY1" ) == FALSE )
		return FALSE;

	//Check to see that the animate control was created with the proper ID
	if ( CheckCreation( "IDC_ANIMATE1" ) == FALSE )
		return FALSE;

	//Check to see that the rich edit control was created with the proper ID
	if ( CheckCreation( "IDC_RICHEDIT1" ) == FALSE )
		return FALSE;

	//Check to see that the tab control was created with the proper ID
	if ( CheckCreation( "IDC_TAB1" ) == FALSE )
		return FALSE;

	//Check to see that the listctrl control was created with the proper ID
	if ( CheckCreation( "IDC_LIST2" ) == FALSE )
		return FALSE;

	//Check to see that the date/time picker control was created with the proper ID
	//if ( CheckCreation( "IDC_DATETIMEPICKER1" ) == FALSE )
	//	return FALSE;

	//Check to see that the calendar control was created with the proper ID
	//if ( CheckCreation( "IDC_MONTHCALENDAR1" ) == FALSE )
	//	return FALSE;

	//Check to see that the IP address control was created with the proper ID
	//if ( CheckCreation( "IDC_IPADDRESS1" ) == FALSE )
	//	return FALSE;

	//Check to see that the custom control was created with the proper ID
	if ( CheckCreation( "IDC_CUSTOM1" ) == FALSE )
		return FALSE;
	
	return TRUE;
}

BOOL CDlgTestCases::FindControls(void)
{
	XSAFETY;

	//Search for progress control
	UIWB.DoCommand(ID_EDIT_FIND_DLG, DC_MNEMONIC);
	MST.DoKeys("prog");
	MST.DoKeys("~");

	//Check to see that we found it
	MST.DoKeys("+{TAB}");
	if ( CheckCreation( "IDC_PROGRESS1" ) == FALSE )
		return FALSE;

	//Search for button
	UIWB.DoCommand(ID_EDIT_FIND_DLG, DC_MNEMONIC);
	MST.DoKeys("button");
	MST.DoKeys("~");

	//Check to see that we found it
	MST.DoKeys("+{TAB}");
	if ( CheckCreation( "IDC_BUTTON1" ) == FALSE )
		return FALSE;

	//Change the caption
	MST.DoKeys("Scott's Button");
	MST.DoKeys("~");

	//Check to see we changed it correctly
	CString strCap = UIWB.GetProperty(P_Caption);
	if ( strCap != "Scott's Button") 
	{
		m_pLog->RecordFailure("Button caption not changed to Scott's Button: %s", strCap);
		return FALSE;
	}

	//Undo the change
	UIWB.DoCommand(ID_EDIT_UNDO, DC_MNEMONIC);
	
	//Check to see we changed it back to Button1
	strCap = UIWB.GetProperty(P_Caption);
	if ( strCap != "Button1") 
	{
		m_pLog->RecordFailure("Button caption not undo'd correctly to Button1: %s", strCap);
		return FALSE;
	}
	
	return TRUE;
}

BOOL CDlgTestCases::TestDialog(void)
{
	XSAFETY;
	
	// Initiate test mode
	UIWB.DoCommand(IDMY_TEST, DC_MNEMONIC);
	UIDialog uTestDlg;
	uTestDlg.WaitAttachActive(3000);
	char acBuf[256];
	uTestDlg.GetText(acBuf, 255); 

	//Test controls
	MST.DoKeys("{TAB 2}");
	MST.DoKeys("Hi there");		//Editbox
	MST.DoKeys("{TAB 2}");
	MST.DoKeys("{SPACE}");		//Check box
	MST.DoKeys("{TAB}");
	MST.DoKeys("Hi again");		//Combo box
	MST.DoKeys("{TAB}");
	MST.DoKeys("s");			//List box
	MST.DoKeys("{TAB}");
	MST.DoKeys("{RIGHT 3}");	//Slider
	MST.DoKeys("{TAB}");
	MST.DoKeys("F");			//Hotkey
	MST.DoKeys("{TAB 2}");
	MST.DoKeys("Rich");			//Rich Edit box
	MST.DoKeys("{TAB}");
	MST.DoKeys("m");			//Listctrl
	//MST.DoKeys("{TAB}");
	//MST.DoKeys("{DOWN 3}");		//Date/Time Picker
	//MST.DoKeys("{TAB}");
	//MST.DoKeys("{PGDN 3}");		//Calendar
	//MST.DoKeys("{TAB}");
	//MST.DoKeys("123123123123");	//IP Address edit control
	MST.DoKeys("~");	// Hit return to exit from test mode

	// see if we got the right window
	//HWND hwnd = MST.WFndWnd("Dialog .rc - IDD_DIALOG1 (Dialog)",  FW_DEFAULT);
	//m_pLog->Comment("Dialog .rc wnd handle %d", hwnd);
	bool result = !uTestDlg.IsValid();
	m_pLog->Comment("uTestDlg not valid %d", result);
	result = m_uDlgEd.IsValid();
	m_pLog->Comment("m_uDlgEd is valid %d", result);
	if(!m_uDlgEd.IsValid() || uTestDlg.IsValid())
		m_pLog->Comment("Test mode should pass");

	//hwnd = m_uDlgEd.GetDialog();
	//m_pLog->Comment("m_uDlgEd wnd handle %d", result);

	//test we got back ok
	if ((strcmp(acBuf, GetLocString(IDSS_DIALOG)) != 0) ||
		!m_uDlgEd.IsValid() || uTestDlg.IsValid())
	{
		m_pLog->RecordFailure("Dialog Test mode failed");
		m_pLog->Comment("Active Wnd %s = %x",acBuf, uTestDlg);
		return FALSE;
	}
	
	//close file
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	return TRUE;
}

BOOL CDlgTestCases::CheckCreation(CString CtrlID)
{
	//Test the ID of the control next in tab order

	//Send tab & wait
	MST.DoKeys("{TAB}");
	Sleep(500);

	//Get ID of selected control
	CString strID = UIWB.GetProperty(P_ID);
	
	//Test with expected value
	if (strID != CtrlID)
	{
		m_pLog->RecordFailure("Incorrect ID given to new control: %s expected %s", strID, CtrlID);
		return FALSE;
	}

	return TRUE;

}

BOOL CDlgTestCases::SaveOpen(void)
{
	XSAFETY;

	//save file
	if ( UIWB.SaveFileAs(m_strCWD + "testout\\Dialog .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "testout\\Dialog .rc");
		return FALSE;
	}

	//close file
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	//reopen file
	HWND hwnd = UIWB.OpenFile(m_strCWD + "testout\\Dialog .rc");
	if (hwnd == NULL)
	{
		m_pLog->RecordFailure("File-Open: hwnd == %x", hwnd);
		return FALSE;
	}

	//Reopen editor
	MST.DoKeys("{DOWN}~{DOWN}~");

	// Get the active dialog editor
	m_uDlgEd = UIWB.GetActiveEditor();

	//Make sure it opened
	if ( CheckCreation( "IDOK" ) == FALSE )
	{
		m_pLog->RecordFailure("File not opened");
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\imgcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	IMGCASES.H
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Declaration of the CImgTestCases class
//

#ifndef __IMGCASES_H__
#define __IMGCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CImgTestCases class

class CImgTestCases : public CTest
{
	DECLARE_TEST(CImgTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:
	UIImgEdit	m_uBmpEd;	// REVIEW(davidga): if the utils needed for these
	UIImgEdit	m_uIcoEd;	// someday differ, derive UBmpEdit and UIcoEdit

// Test Cases
protected:
	BOOL TestBitmap(void);
	BOOL TestIcon(void);
	BOOL TestIconDevices(void);
	BOOL TestCursor(void);
	BOOL TestGIF_JPEG(void);
};

#endif //__IMGCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\dlgcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	DLGCASES.H
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Edited By :				Date :
//		ScottSe					8/29/96
//
//	Description :
//		Declaration of the CDlgTestCases class
//

#ifndef __DLGCASES_H__
#define __DLGCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CDlgTestCases class

class CDlgTestCases : public CTest
{
	DECLARE_TEST(CDlgTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:
	UIDlgEdit m_uDlgEd;
//	CWnd*	m_pDlgEd;	 // Pointers to the common dlg editor
//	CWnd*	m_pDlg;

// Test Cases
protected:
	BOOL CreateDlgRes(void);
	BOOL DropControls(void);
	BOOL TestDialog(void);
	BOOL FindControls(void);
	BOOL CheckCreation(CString CtrlID);
	BOOL SaveOpen(void);
};

#endif //__DLGCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\io_cases.h ===
///////////////////////////////////////////////////////////////////////////////
//    IO_CASES.H
//
//    Created by :                    Date :
//            DougT                                   8/13/93
//
//    Description :
//            Declaration of the CIO_TestCases class
//
 
#ifndef __IO_CASES_H__
#define __IO_CASES_H__

#ifndef __STDAFX_H__
      #error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CIO_TestCases class

class CIO_TestCases : public CTest
{
	DECLARE_TEST(CIO_TestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Test Cases
protected:
	BOOL IO_OpenRC(void);
	BOOL IO_SaveAsRC(void);
	BOOL IO_CompareRCFile(void);
	BOOL IO_CompareHFile(void);
	BOOL IO_CloseRC(void);
	BOOL IO_DirtyRC(void);
};

#endif //__IO_CASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\intcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	INTCASES.CPP
//
//	Created by :			Date :
//		DougT					8/13/93
//
//	Description :
//		Implementation of the CIntTestCases class
//

#include "stdafx.h"
#include "intcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CIntTestCases, CTest, "Integration Tests", -1, CSniffDriver)

void CIntTestCases::Run(void)
{
	KillFile(m_strCWD, "INT*.APS");
	
	IntOpenErrorLadenRC();
	UIWB.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CIntTestCases::IntOpenErrorLadenRC(void)
{
	HWND hwnd = UIWB.OpenFile(m_strCWD + "intopen.rc");

// REVIEW(davidga): Bug #535 used to assert here
	
	UIDialog rcerr(VRES_IDC_EDITCODE, GL_BUTTON);
	if( !rcerr.WaitAttachActive(3000) )
	{
		m_pLog->RecordFailure("(1) Error-laden RC did not cause error message");
		return FALSE;
	}
	else if( rcerr.GetDlgItem(VRES_IDC_EDITCODE) == NULL )
	{
		m_pLog->RecordFailure("(1) Expected 'Edit Code' button not found");
		return FALSE;
	}

	MST.WButtonClick(GetLabel(VRES_IDC_EDITCODE));

	hwnd = UIWB.GetActiveEditor();
	
	CString str = GetText(hwnd);
	str.MakeUpper();

	if(str.Find("INTOPEN.RC") < 0)		// if INTOPEN.RC not anywhere in titlebar
	{							 
		m_pLog->RecordFailure("(1) Resource script code window: Found %s active.", (LPCSTR)str);
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\intcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	INTCASES.H
//
//	Created by :			Date :
//		DougT					8/13/93
//
//	Description :
//		Declaration of the CIntTestCases class
//

#ifndef __INTCASES_H__
#define __INTCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CIntTestCases class

class CIntTestCases : public CTest
{
	DECLARE_TEST(CIntTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Test Cases
protected:
	BOOL IntOpenErrorLadenRC(void);
};

#endif //__INTCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		Precompiled header for the VRes Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\io_cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	IO_CASES.CPP
//
//	Created by :			Date :
//		DougT				8/13/93
//		RonPih				7/4/97		-Fixed reliance on RO file attribute
//										 for io_open.h
//
//	Description :
//		Implementation of the CIO_TestCases class
//
//		Assumes io_open.rc & io_open.h are in the baseln subdirectory.
//

#include "stdafx.h"
#include "io_cases.h"

// for _stat CRT function
#include "sys\types.h"
#include "sys\stat.h"

// for rmdir CRT function
#include "direct.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CIO_TestCases, CTest, "Resource I/O Tests", -1, CSniffDriver)

void CIO_TestCases::Run(void)
{
	//Delete all io_ sniff files from any previous test
	DeleteFile(m_strCWD + "IO_TMPSV.RC");
	DeleteFile(m_strCWD + "IO_OPEN.APS");
	SetFileAttributes(m_strCWD + "IO_OPEN.RC",FILE_ATTRIBUTE_NORMAL);
	DeleteFile(m_strCWD + "IO_OPEN.RC");
	SetFileAttributes(m_strCWD + "IO_OPEN.H",FILE_ATTRIBUTE_NORMAL);
	DeleteFile(m_strCWD + "IO_OPEN.H");
	DeleteFile(m_strCWD + "INC\\IO_TMPSV.H");
	RemoveDirectory(m_strCWD + "INC");

	// copy io_open.* from baseln subdirectory
	if (!CopyFile(m_strCWD + "baseln\\io_open.h",m_strCWD + "io_open.h",FALSE) ||
		!CopyFile(m_strCWD + "baseln\\io_open.rc",m_strCWD + "io_open.rc",FALSE))
	{
		m_pLog->RecordFailure("Copy io_open.* to working directory failed.  Subsequent tests may also fail.");
		UIWB.CloseAllWindows();
		return;
	}

	XSAFETY;
	IO_OpenRC();
	XSAFETY;
	IO_SaveAsRC();
	XSAFETY;
	IO_CompareHFile();
	IO_CompareRCFile();
	XSAFETY;
	IO_CloseRC();
	XSAFETY;

	// copy io_open.* from baseln subdirectory
	// (HACK: until all other vres tests assume io_open.* starts in baseln subdirectory)
	SetFileAttributes(m_strCWD + "IO_OPEN.RC",FILE_ATTRIBUTE_NORMAL);
	SetFileAttributes(m_strCWD + "IO_OPEN.H",FILE_ATTRIBUTE_NORMAL);
	if (!CopyFile(m_strCWD + "baseln\\io_open.h",m_strCWD + "io_open.h",FALSE) ||
		!CopyFile(m_strCWD + "baseln\\io_open.rc",m_strCWD + "io_open.rc",FALSE))
	{
		m_pLog->RecordInfo("Copy io_open.* to working directory failed.  Subsequent tests may fail.");
		UIWB.CloseAllWindows();
		return;
	}
	UIWB.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CIO_TestCases::IO_OpenRC(void)
{
	HWND hwnd = UIWB.OpenFile(m_strCWD + "io_open.rc");
	if (hwnd == NULL) {
		m_pLog->RecordFailure("File-Open: hwnd == %x", hwnd);
		return FALSE;
	}
	return TRUE;
}

BOOL CIO_TestCases::IO_SaveAsRC(void)
{
	UIWB.DoCommand(IDM_FILE_SETINCLUDES, DC_MNEMONIC);
	MST.DoKeys("io_tmpsv.h");
	MST.DoKeys("{ENTER}");

  	BOOL bSaveResult;
	bSaveResult = UIWB.SaveFileAs(m_strCWD + "io_tmpsv.rc", TRUE /* Overwrite? */);
//	Sleep(500);
	UIWB.WaitAttachActive(15000);

	if (bSaveResult == NULL) {
		m_pLog->RecordFailure("File-Save As: bSaveResult == %i", bSaveResult);
		return FALSE;
	}
	return TRUE;
}

BOOL CIO_TestCases::IO_CompareRCFile(void)
{
	m_pLog->Comment("Attempting compare of RC files.");

	int nCompareRCResult = CompareFiles(m_strCWD + "io_tmpsv.rc", m_strCWD + "io_base.rc", 0);
	switch(nCompareRCResult)
	{
		case CF_SAME:
			m_pLog->RecordInfo("io_tmpsv.rc and io_base.rc compare fine");
			break;
		case CF_DUPNAME:
			ASSERT(FALSE);		// how could this happen?
			break;
		case CF_CANTOPEN1:
			m_pLog->RecordFailure("can't open io_tmpsv.rc");
			break;
		case CF_CANTOPEN2:
			m_pLog->RecordFailure("can't open io_base.rc");
			break;
/*		case CF_DIFFSIZE:
			m_pLog->RecordFailure("io_tmpsv.rc and io_base.rc are different sizes"); // REVIEW(enriquep): fix special NT J case
			break;	  */
		case CF_NOTSAME:
			m_pLog->RecordFailure("io_tmpsv.rc and io_base.rc are different at the byte level");
			break;
		default:
			m_pLog->RecordInfo("io_tmpsv.rc and io_base.rc compare fine");	 // REVIEW(enriquep): fix special NT J case
			break;

	}

	return TRUE;
}

BOOL CIO_TestCases::IO_CompareHFile(void)	
{
	m_pLog->Comment("Attempting compare of H files.");

	int nCompareHResult  = CompareFiles(m_strCWD + "io_tmpsv.h", m_strCWD + "io_base.h", 0);

	switch(nCompareHResult)
	{
		case CF_SAME:
			m_pLog->RecordInfo("io_tmpsv.h and io_base.h compare fine");
			break;
		case CF_DUPNAME:
			ASSERT(FALSE);		// how could this happen?
			break;
		case CF_CANTOPEN1:
			m_pLog->RecordFailure("can't open io_tmpsv.h");
			break;
		case CF_CANTOPEN2:
			m_pLog->RecordFailure("can't open io_base.h");
			break;
		case CF_DIFFSIZE:
			m_pLog->RecordFailure("io_tmpsv.h and io_base.h are different sizes");
			break;
		case CF_NOTSAME:
		default:
			m_pLog->RecordFailure("io_tmpsv.h and io_base.h are different at the byte level");
			break;
	}

	UIWB.DoCommand(IDM_FILE_SETINCLUDES, DC_MNEMONIC);

	MST.DoKeys(m_strCWD + "INC\\io_tmpsv.h");
	MST.DoKeys("{ENTER}");

	struct _stat buf;
	int statresult;
	char buffer[] = "A line to output";

	int bSaveAlteredHResult;
	bSaveAlteredHResult = UIWB.SaveFileAs(m_strCWD + "io_tmpsv.rc", TRUE /* Overwrite? */);
	Sleep(500);
	if (bSaveAlteredHResult == NULL) {
		m_pLog->RecordFailure("File-Save As: bSaveAlteredHResult == %i", bSaveAlteredHResult);
	}

	// Get data associated with "INC\io_tmpsv.h"
	statresult = _stat(m_strCWD + "INC\\io_tmpsv.h", &buf );

	// Check if statistics are valid: */
	if( statresult != 0 )
	{
		m_pLog->RecordFailure(m_strCWD + "INC\\io_tmpsv.h does not exist.");
	}

	return TRUE;
}

BOOL CIO_TestCases::IO_CloseRC(void)
{
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
	}
	return TRUE;
}

BOOL CIO_TestCases::IO_DirtyRC(void)
{
	HWND hwnd = UIWB.OpenFile(m_strCWD + "io_open.rc");

	if (hwnd == NULL) {
		m_pLog->RecordFailure("File-Open: hwnd == %x", hwnd);
	}

//REVIEW(dougt): Convert constants to variable-driven commands

	MST.DoKeys("{DOWN 3}{TAB}");				// locate a string table
	MST.DoKeys(" {ENTER}");						// select it, open the string table
	MST.DoKeys("{DOWN 2}");						// go to the end of the string table
	MST.DoKeys("%{ENTER}");						// open a prop page
	MST.DoKeys("{TAB}This is a test.");			// enter a caption for the new string table entry

  	BOOL bSaveDirtyRCResult;
	bSaveDirtyRCResult = UIWB.SaveFileAs(m_strCWD + "io_tmpdt.rc", TRUE /* Overwrite? */);
	if (bSaveDirtyRCResult == NULL) {
		m_pLog->RecordFailure("Dirty RC -- File-Save As: bSaveDirtyRCResult == %i", bSaveDirtyRCResult);
	}

	MST.DoKeys("{DEL}");						// delete the new entry

	BOOL bSaveRestoredRCResult;
	bSaveRestoredRCResult = UIWB.SaveFileAs(m_strCWD + "io_tmpdt.rc", TRUE /* Overwrite? */);
	if (bSaveRestoredRCResult == NULL) {
		m_pLog->RecordFailure("Restored RC -- File-Save As: bSaveRestoredRCResult == %i", bSaveRestoredRCResult);
	}

	m_pLog->Comment("Attempting compare of original and dirtied RC files.");
	int nCompareDirtyResult  = CompareFiles(m_strCWD + "io_open.rc", m_strCWD + "io_tmpdt.rc", 0);
	switch(nCompareDirtyResult)
	{
		case CF_SAME:
			m_pLog->RecordInfo("io_open.rc and io_tmpdt.rc compare fine");
			break;
		case CF_DUPNAME:
			ASSERT(FALSE);		// how could this happen?
			break;
		case CF_CANTOPEN1:
			m_pLog->RecordFailure("can't open io_open.rc");
			break;
		case CF_CANTOPEN2:
			m_pLog->RecordFailure("can't open io_tmpdt.rc");
			break;
		case CF_DIFFSIZE:
			m_pLog->RecordFailure("io_open.rc and io_tmpdt.rc are different sizes");
			break;
		case CF_NOTSAME:
		default:
			m_pLog->RecordFailure("io_open.rc and io_tmpdt.rc are different at the byte level");
			break;
	}

	HWND hwnd2 = UIWB.OpenFile(m_strCWD + "io_tmpdt.rc");

	if (hwnd2 == NULL) {
		m_pLog->RecordFailure("File-Open: hwnd == %x", hwnd2);
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SNIFF.CPP
//
//      Created by :                    Date :
//              DavidGa                                 8/30/93
//
//      Description :
//              implementation of the CSniffTest class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "acccases.h"
#include "strcases.h"
#include "bincases.h"
#include "dlgcases.h"
#include "mencases.h"
#include "imgcases.h"
#include "vercases.h"
#include "io_cases.h"
#include "intcases.h"
#include "symcases.h"
#include "brzcases.h"
#include "cpicases.h"
#include "tbrcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "VRes Sniff Test", "EHarding X34536")

BEGIN_TESTLIST(CSniffDriver)
	TEST(CAccTestCases, RUN)
	TEST(CStrTestCases, RUN)
	TEST(CBinTestCases, RUN)
	TEST(CDlgTestCases, RUN)
	TEST(CMenTestCases, RUN)
        TEST(CImgTestCases, RUN)
	TEST(CVerTestCases, RUN)
	TEST(CIO_TestCases, RUN)
	TEST(CIntTestCases, RUN)
	TEST(CSymTestCases, RUN)
	TEST(CBrzTestCases, RUN)
	TEST(CCpiTestCases, RUN)
	TEST(CTbrTestCases, RUN)
END_TESTLIST()

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}

void CSniffDriver::CleanUp(void)
{
	// close all open windows
	UIWB.CloseAllWindows();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\mencases.h ===
///////////////////////////////////////////////////////////////////////////////
//	MENCASES.H
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Modified by :			Date :			Action :
//		ScottSe					9/4/96			Major rewrite of entire test
//
//	Description :
//		Declaration of the CMenTestCases class
//

#ifndef __MENCASES_H__
#define __MENCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CMenTestCases class
 
class CMenTestCases : public CTest
{
	DECLARE_TEST(CMenTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
//protected:
//	BOOL m_bSafeIDs;
//	CString m_strID1;
//	CString m_strID2;

// Test Cases
protected:
	BOOL CreateMenuRes(void);
	BOOL SaveOpen(void);
	BOOL EnterMenuItems(void);
	BOOL CopyAndPaste(void);
	BOOL CheckCreation(CString, int);

};

#endif //__MENCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		ChrisSh					8/12/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST()

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\strcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	STRCASES.H
//
//	Created by :			Date :
//		ChrisSh					8/13/93
//
//	Description :
//		Declaration of the CStrTestCases class
//

#ifndef __STRCASES_H__
#define __STRCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CStrTestCases class

class CStrTestCases : public CTest
{
	DECLARE_TEST(CStrTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:

// Test Cases
protected:
	BOOL CreateStringTable(void);
	BOOL NewString(void);
	BOOL SaveOpen(void);
};

#endif //__STRCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\symcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	SYMCASES.H
//
//	Created by :			Date :
//		DavidGa					9/20/93
//
//	Description :
//		Declaration of the CSymTestCases class
//

#ifndef __SYMCASES_H__
#define __SYMCASES_H__

#ifndef __AFXWIN_H__
	#error include 'cafe.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	CSymTestCases class

class CSymTestCases : public CTest
{
	DECLARE_TEST(CSymTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Test Cases
protected:
	BOOL CheckSymbolCounts();
	BOOL CreateDefaultSymbol();
	BOOL QuotedStringID();
	BOOL SymbolDropDown();
	BOOL UsedByList();
	BOOL ViewUse();
	BOOL CreatSymbol();
	BOOL ChangeUnusedSymbol();
	BOOL ChangeInUseSymbol();
	BOOL ChangeUsingIDProp();
	BOOL DeleteUnusedSymbol();
	BOOL DeleteInUseSymbol();

// Utilities
protected:
	int CountSymbols(BOOL bReadOnly, int nExpected = 0);
};

#define SYMBOL_RC	"symbol.rc"

#endif //__SYMCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\symcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SYMCASES.CPP
//
//      Created by :                    Date :
//              DavidGa                                 9/20/93
//
//      Description :
//              Implemtation of the CSymTestCases class
//

#include "stdafx.h"
#include "symcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//      CTestSet overrides

IMPLEMENT_TEST(CSymTestCases, CTest, "Symbol Browser Tests", -1, CSniffDriver)

void CSymTestCases::Run(void)
{
	UIEditor ed = UIWB.OpenFile(m_strCWD + SYMBOL_RC);
	EXPECT( ed.IsValid() );

	XSAFETY;
	CheckSymbolCounts();
	XSAFETY;
	CreateDefaultSymbol();
	XSAFETY;
	QuotedStringID();
	XSAFETY;
	SymbolDropDown();
	XSAFETY;
	UsedByList();
	XSAFETY;
	ViewUse();
	XSAFETY;
	CreatSymbol();
	XSAFETY;
	ChangeUnusedSymbol();
	XSAFETY;
	ChangeInUseSymbol();
	XSAFETY;
	ChangeUsingIDProp();
	XSAFETY;
	DeleteUnusedSymbol();
	XSAFETY;
	DeleteInUseSymbol();
	XSAFETY;
	UIWB.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//      Test Cases

BOOL CSymTestCases::CheckSymbolCounts()
{
// REVIEW(briancr): moved the code from UWBFrame::BrowseSymbols to here because
// we can't support this function in UWBFrame anymore.
// Find a better place for this function.
	UISymbolBrowser sb;
    UIWB.DoCommand(IDM_EDIT_SYMBOLS, DC_MNEMONIC);
    sb.WaitAttachActive(15000);
	Sleep(2000);
	int nSymbols = sb.CountSymbols(FALSE);  // count normal symbols
	if (nSymbols != 2) {
		m_pLog->RecordFailure("CheckSymbolCounts: Found %d normal symbols (expected %d)", nSymbols, 2);
	}

	nSymbols = sb.CountSymbols(TRUE) - nSymbols;    // count all symbols, and subtract normal ones
	if (nSymbols != 12) {
		m_pLog->RecordFailure("CheckSymbolCounts: Found %d read-only symbols (expected %d)", nSymbols, 12);
	}

	MST.DoKeys("{esc}");    // close the symbol browser
	return TRUE;
}

BOOL CSymTestCases::CreateDefaultSymbol()
{
	COResScript res;

	res.CreateResource(IDSS_RT_DIALOG);

// REVIEW(briancr): not supported in UIWB
//      UIEditor ed = UIWB.CreateNewResource(GetLocString(IDSS_RT_DIALOG));

	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	int nSymDiff = CountSymbols(FALSE, 3);
	if (nSymDiff != 0) {
		m_pLog->RecordFailure("CreateDefaultSymbol: Found %d symbols after creating dialog (expected %d)", 3 + nSymDiff, 3);
		return FALSE;
	}
	return TRUE;
}

BOOL CSymTestCases::QuotedStringID()
{
	MST.DoKeys("%({ENTER})");          // Bring up Property page REVIEW we should have a WB util to set the ID...
	MST.DoKeys("%i\"quoted_string_id");	// Set ID to "quoted_string_id"
	MST.DoKeys("~");

	int nSymDiff = CountSymbols(FALSE, 2);
	if (nSymDiff != 0) {
		m_pLog->RecordFailure("QuotedStringID: Found %d symbols after giving dialog a quoted-string ID (expected %d)", 2 + nSymDiff, 2);
		return FALSE;
	}
	return TRUE;
}

BOOL CSymTestCases::SymbolDropDown()
{
	return TRUE;
}

BOOL CSymTestCases::UsedByList()
{
	return TRUE;
}

BOOL CSymTestCases::ViewUse()
{
	return TRUE;
}

BOOL CSymTestCases::CreatSymbol()
{
	return TRUE;
}

BOOL CSymTestCases::ChangeUnusedSymbol()
{
	return TRUE;
}

BOOL CSymTestCases::ChangeInUseSymbol()
{
	return TRUE;
}

BOOL CSymTestCases::ChangeUsingIDProp()
{
	return TRUE;
}

BOOL CSymTestCases::DeleteUnusedSymbol()
{
	return TRUE;
}

BOOL CSymTestCases::DeleteInUseSymbol()
{
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//      Utilities

int CSymTestCases::CountSymbols(BOOL bReadOnly, int nExpected /*=0*/)
{
// REVIEW(briancr): moved the code from UWBFrame::BrowseSymbols to here because
// we can't support this function in UWBFrame anymore.
// Find a better place for this function.
	UISymbolBrowser sb;
    UIWB.DoCommand(IDM_EDIT_SYMBOLS, DC_MNEMONIC);
    sb.WaitAttachActive(1000);
//      UISymbolBrowser sb = UIWB.BrowseSymbols();
	int count = sb.CountSymbols(bReadOnly);
	MST.DoKeys("{esc}");
	return  count - nExpected;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\mencases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	MENCASES.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Modified by :			Date :			Action :
//		ScottSe					9/4/96			Major rewrite of entire test
//
//	Description :
//		Implementation of the CMenTestCases class
//

#include "stdafx.h"
#include "mencases.h"

#define new DEBUG_NEW

//Delay to resolve timing issues
#define WAIT 500

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CMenTestCases, CTest, "Menu Editor Tests", -1, CSniffDriver)

void CMenTestCases::Run(void)
{
	// Delete previous files
	KillAllFiles(m_strCWD + "TESTOUT", FALSE);

	//Create new resource
	if ( CreateMenuRes() == FALSE )
 	{
		m_pLog->RecordFailure("Menu creation failed, devres.pkg not loaded");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Menu creation passed");

	//Enter a bunch of items
	if ( EnterMenuItems() == FALSE )
 	{
		m_pLog->RecordFailure("Menu items creation failed, possible timing issue");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Menu items creation passed");

	//Do copy, paste etc.
	if ( CopyAndPaste() == FALSE )
 	{
		m_pLog->RecordFailure("Failed Menu copy/paste test");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Menu copy/paste passed");

	// File IO
	if ( SaveOpen() == FALSE )
 	{
		m_pLog->RecordFailure("Failed Menu IO test");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("Menu IO passed");

	UIWB.CloseAllWindows();
	XSAFETY;
}
 
///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CMenTestCases::CreateMenuRes(void)
{
	XSAFETY;

	//create a new menu
	COResScript res;
	res.CreateResource(IDSS_RT_MENU);

	//Make sure it is active
	Sleep(WAIT);
	UIMenEdit uMenu = UIWB.GetActiveEditor();
	if (!uMenu.IsValid())
	{
		m_pLog->RecordFailure("Unable to create Menu Resource.  Found %s active.", (LPCSTR)uMenu.GetText());
		return FALSE;
	}

	//Make sure it has the right title
	CString str = uMenu.GetTitle();
	if( str.Find("IDR_MENU") < 0 )
	{		// expect "Script1 - IDR_MENU1 (Menu)"
		m_pLog->RecordFailure("Unable to create Menu Resource.  Found %s active.", (LPCSTR)str);
		return FALSE;
	}
	return TRUE;
}

BOOL CMenTestCases::EnterMenuItems(void)
{
	XSAFETY;
	
	//Create first Menu Item
	MST.DoKeys("&Pop up1");
	MST.DoKeys("~");
	MST.DoKeys("{LEFT}{DOWN}");
	Sleep(WAIT);
	CString strCaption = UIWB.GetProperty(P_Caption);
	CString strPopUp = UIWB.GetProperty(P_Popup);	
	
	//Check to see if we created it correctly
	if ((strCaption != "&Pop up1") || (strPopUp != "1"))
	{
		m_pLog->Comment("Caption = %s, Pop up = %s", (LPCSTR)strCaption, (LPCSTR)strPopUp);
		m_pLog->RecordFailure("Failed to create pop up menu");
		return FALSE;
	}

	//Enter a checked item
	MST.DoKeys("{DOWN}");
	MST.DoKeys("&One");
	Sleep(WAIT);
	MST.WCheckCheck( GetLabel(VRES_IDC_CHECKED) );
	MST.DoKeys("~");
	
	//Enter a grayed item
	MST.DoKeys("&Two");
	Sleep(WAIT);
	MST.WCheckCheck( GetLabel(VRES_IDC_GRAYED) );
	MST.DoKeys("~");

	//Enter a seperator
	MST.DoKeys("Seperate");
	Sleep(WAIT);
	MST.WCheckCheck( GetLabel(VRES_IDC_SEPARATOR) );
	MST.DoKeys("~");

	//Enter an inactive item
	MST.DoKeys("T&hree");
	Sleep(WAIT);
	MST.WCheckCheck( GetLabel(VRES_IDC_INACTIVE) );
	MST.DoKeys("~");

	//Enter a help enabled item
	MST.DoKeys("&Four");
	Sleep(WAIT);
	MST.WCheckCheck( GetLabel(VRES_IDC_HELPMENU) );
	MST.DoKeys("~");

	//Enter an item with a prompt
	MST.DoKeys("F&ive");
	Sleep(WAIT);
	MST.WEditSetText( GetLabel(VRES_IDC_CMDMESSAGE), "Here is a prompt" );
	MST.DoKeys("~");

	//Enter a popup item
	MST.DoKeys("&Six");
	Sleep(WAIT);
	MST.WCheckCheck( GetLabel(VRES_IDC_POPUP) );
	MST.DoKeys("~");

	//Enter an item for the popup 
	MST.DoKeys("Si&x One");
	Sleep(WAIT);
	MST.WCheckCheck( GetLabel(VRES_IDC_GRAYED) );
	MST.DoKeys("~");

	//Enter an item back on main
	MST.DoKeys("{LEFT}");
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	MST.DoKeys("");
	Sleep(WAIT);
	MST.WCheckCheck( GetLabel(VRES_IDC_CHECKED) );
	MST.DoKeys("~");

	//Check to see if main menu was entered correctly
	MST.DoKeys("{LEFT}");
	Sleep(WAIT);
	if (!CheckCreation("IDR_MENU1",0) ) return FALSE;

	//Check top popup menu
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("&Pop up1",3) ) return FALSE;

	//Check item 1
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("&One",2) ) return FALSE;
	
	//Check item 2
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("&Two",4) ) return FALSE;
	
	//Check seperator
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("Seperator",1) ) return FALSE;

	//Check item 3
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("T&hree",5) ) return FALSE;
	
	//Check item 4
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("&Four",6) ) return FALSE;
	
	//Check item 5
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("F&ive",7) ) return FALSE;
	
	//Check item 6
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("&Six",3) ) return FALSE;
	
	//Check item 6.1
	MST.DoKeys("{RIGHT}");
	Sleep(WAIT);
	if (!CheckCreation("Si&x One",4) ) return FALSE;

	//Check item 7
	MST.DoKeys("{LEFT}");
	MST.DoKeys("{DOWN}");
	Sleep(WAIT);
	if (!CheckCreation("",2) ) return FALSE;

	return TRUE;
}


BOOL CMenTestCases::CopyAndPaste(void)
{
	XSAFETY;
	
	//Find item "Four"
	UIWB.DoCommand(ID_EDIT_FIND_DLG, DC_MNEMONIC);
	MST.DoKeys("Four");
	MST.DoKeys("~");

	//See if we found it
	Sleep(WAIT);
	if (!CheckCreation("&Four",6) ) return FALSE;

	//Multiple select next 3 items and change caption to "FooBar"
	MST.DoKeys("+{DOWN 3}");
	Sleep(WAIT);
	MST.DoKeys("FooBar");
	MST.DoKeys("~");

	//See if we changed it on the last item
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{UP}");
	Sleep(WAIT);
	if (!CheckCreation("FooBar",2) ) return FALSE;

	//Undo the change
	UIWB.DoCommand(ID_EDIT_UNDO, DC_ACCEL);

	//Check to see it got changed back
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{UP}");
	Sleep(WAIT);
	if (!CheckCreation("",2) ) return FALSE;

	return TRUE;
}
	
BOOL CMenTestCases::SaveOpen(void)
{
	XSAFETY;

	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "testout\\Menu .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "testout\\Menu .rc");
		return FALSE;
	}
	Sleep(1000);

	//close file
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	//reopen file
	HWND hwnd = UIWB.OpenFile(m_strCWD + "testout\\Menu .rc");
	if (hwnd == NULL)
	{
		m_pLog->RecordFailure("File-Open failed on %s", m_strCWD + "testout\\Menu .rc");
		return FALSE;
	}

	//Reopen editor
	MST.DoKeys("{DOWN}~{DOWN}~");

	//Make sure it opened
	MST.DoKeys("{HOME}");
	Sleep(WAIT);
	if (!CheckCreation("IDR_MENU1",0) )
	{
		m_pLog->RecordFailure("File not opened correctly");
		return FALSE;
	}

	//Close the editor
	MST.DoKeys("^{F4}");

	//Open string table
	MST.DoKeys("{DOWN}~{DOWN}~");

	//Make sure it opened
	MST.DoKeys("{HOME}");
	CString strID = UIWB.GetProperty(136);	//136 == P_String
	if (strID != "Here is a prompt") 
	{
		m_pLog->RecordFailure("Prompt not saved correctly, returned string: %s", strID);
		return FALSE;
	}

	//Close it again
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	return TRUE;

}

BOOL CMenTestCases::CheckCreation(CString CtrlID, int nState)
{
	CString strID = "Null";
	if ( nState == 0 ) //Top menu has no caption
	{
		//Get ID of selected menu item
		strID = UIWB.GetProperty(P_ID);
		
		//Test with expected value
		if (strID != CtrlID)
		{
			m_pLog->RecordFailure("Incorrect ID given to new menu item: %s expected %s", strID, CtrlID);
			return FALSE;
		}
	}
	else if ( nState != 1 ) //Skip seperator
	{
		//Get caption of selected menu item
		strID = UIWB.GetProperty(P_Caption);
		
		//Test with expected value
		if (strID != CtrlID)
		{
			m_pLog->RecordFailure("Incorrect caption given to new menu item: %s expected %s", strID, CtrlID);
			return FALSE;
		}
	}


	//Check for proper checkmark
	CString strProp = "1";
	CString Prop = "Null";
	switch (nState)
	{
	case 1:		//Separator
		Prop = "Separator";
		strProp = UIWB.GetProperty(P_Separator);
		break;
	case 2:		//Checked
		Prop = "Checked";
		strProp = UIWB.GetProperty(P_Checked);
		break;
	case 3:		//Popup
		Prop = "Popup";
		strProp = UIWB.GetProperty(P_Popup);
		break;
	case 4:		//Grayed
		Prop = "Grayed";
		strProp = UIWB.GetProperty(P_Grayed);
		break;
	case 5:		//Inactive
		Prop = "Inactive";
		strProp = UIWB.GetProperty(P_Inactive);
		break;
	case 6:		//Help
		Prop = "Help";
		strProp = UIWB.GetProperty(P_Help);
		break;
	case 7:		//Prompt
		strProp = UIWB.GetProperty(P_CmdMessage);
		if (strProp != "Here is a prompt")
		{
			m_pLog->RecordFailure("Menu item %s did not create prompt correctly", strID);
			return FALSE;
		}
		strProp = "1";
		break;
	}
	
	if (strProp != "1")
	{
		m_pLog->RecordFailure("Menu item %s not %s", strID, Prop);
		return FALSE;
	}
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\strcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STRCASES.CPP
//
//	Created by :			Date :
//		ChrisSh					8/13/93
//
//	Modified by:			Date:			Changes:
//		ScottSe					8/15/96			Added several tests to NewString()
//
//	Description :
//		Implementation of the CStrTestCases class
//

#include "stdafx.h"
#include "strcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CStrTestCases, CTest, "String Editor Tests", -1, CSniffDriver)

void CStrTestCases::Run(void)
{
	// Delete previous files
	KillAllFiles(m_strCWD + "TESTOUT", FALSE);

	if ( CreateStringTable() == FALSE )
 	{
		m_pLog->RecordFailure("String table creation failed, devres.pkg not loaded");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("String table creation passed");

	if ( NewString() == FALSE )
 	{
		m_pLog->RecordFailure("String items creation failed, possible timing issue");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("String items creation passed");

	if ( SaveOpen() == FALSE )
 	{
		m_pLog->RecordFailure("Failed String IO test");
		UIWB.CloseAllWindows();
		return;
	}
	m_pLog->RecordInfo("String IO passed");

	UIWB.CloseAllWindows();
	XSAFETY;
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CStrTestCases::CreateStringTable(void)
{
	XSAFETY;

	COResScript res;

	if (res.CreateResource(IDSS_RT_STRING_TABLE) == ERROR_ERROR)
	{
		m_pLog->RecordFailure("Could not create new StringTable");
		return FALSE;
	}
	return TRUE;
}

BOOL CStrTestCases::NewString(void)
{
	XSAFETY;

	// Add first string
	MST.DoKeys("This is the first string.");	// Type a new string
	MST.DoKeys("~");							// IDS_STRING1
	MST.DoKeys("{UP}");							// Highlight the new string again
	
	// Check for proper ID
	CString strID = UIWB.GetProperty(P_ID);
	if (strID != "IDS_STRING1")
	{
		m_pLog->RecordFailure("(3) Incorrect ID given to new string: %s", strID);
		return FALSE;
	}
	
	//Add more strings
	MST.DoKeys("{INSERT}");
	MST.DoKeys("This is the second string.");		//IDS_STRING2
	MST.DoKeys("~");
	MST.DoKeys("{INSERT}");
	MST.DoKeys("This is the third string.");		//IDS_STRING3
	MST.DoKeys("~");
	MST.DoKeys("{INSERT}");
	MST.DoKeys("This is the fourth string.");		//IDS_STRING4
	MST.DoKeys("~");
	MST.DoKeys("{INSERT}");
	MST.DoKeys("This is the fifth string.");		//IDS_STRING5
	MST.DoKeys("~");

	//Find the third string
	MST.DoKeys("%{F3}");
	MST.DoKeys("third");
	MST.DoKeys("~");

	//Check to see if we found the right one
	strID = UIWB.GetProperty(P_ID);
	if (strID != "IDS_STRING3") 
	{
		m_pLog->RecordFailure("Third string not found: %s", strID);
		return FALSE;
	}

	//Multiple selection of all strings
	MST.DoKeys("{HOME}");
	MST.DoKeys("+{END}");
	MST.DoKeys("+{UP}");

	
	//Change strings to FooBar
	MST.DoKeys("%{ENTER}");
	MST.DoKeys("FooBar");
	MST.DoKeys("~");

	//Check to see we changed the top one to FooBar
	MST.DoKeys("{HOME}");
	strID = UIWB.GetProperty(136);	//136 == P_String
	if (strID != "FooBar") 
	{
		m_pLog->RecordFailure("Top string not changed to FooBar: %s", strID);
		return FALSE;
	}

	//Undo the change
	MST.DoKeys("^z");

	//Check to see we changed the top one back to normal
	MST.DoKeys("{HOME}");
	strID = UIWB.GetProperty(136);	//136 == P_String
	if (strID != "This is the first string.") 
	{
		m_pLog->RecordFailure("Top string not undo'd correctly: %s", strID);
		return FALSE;
	}

	// Add international string
	MST.DoKeys("{INSERT}");
	MST.DoKeys("");	
	MST.DoKeys("~");				// IDS_STRING6

	//Check to see it was added correctly
	MST.DoKeys("{UP}");
	strID = UIWB.GetProperty(136);	//136 == P_String
	if (strID != "") 
	{
		m_pLog->RecordFailure(" String not added correctly: %s", strID);
		return FALSE;
	}

	return TRUE;
}

BOOL CStrTestCases::SaveOpen(void)
{
	XSAFETY;

	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "testout\\String .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "testout\\String .rc");
		return FALSE;
	}
	Sleep(1500);

	//close file
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	//reopen file
	HWND hwnd = UIWB.OpenFile(m_strCWD + "testout\\String .rc");
	if (hwnd == NULL)
	{
		m_pLog->RecordFailure("File-Open failed on %s", m_strCWD + "testout\\String .rc");
		return FALSE;
	}

	//Reopen editor
	MST.DoKeys("{DOWN}~{DOWN}~");

	//Make sure it opened
	MST.DoKeys("{HOME}");
	CString strID = UIWB.GetProperty(136);	//136 == P_String
	if (strID != "This is the first string.") 
	{
		m_pLog->RecordFailure("File not opened, returned string: %s", strID);
		return FALSE;
	}

	//Close it again
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	return TRUE;
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\vercases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	VERCASES.CPP
//
//	Created by :			Date :
//		Enriquep					8/27/93
//
//	Modifies by :			Date :
//		ScottSe						9/13/96		Major rewrite of the entire test
//
//	Description :
//		Implementation of the CVerTestCases class
//

#include "stdafx.h"
#include "vercases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CVerTestCases, CTest, "Version editor tests", -1, CSniffDriver)

void CVerTestCases::Run(void)
{
	HWND hwndRC;

	XSAFETY;

	//Create new resource script
	if ((hwndRC = UIWB.CreateNewFile(GetLocString(IDSS_NEW_RC))) == NULL)
	{
		m_pLog->RecordFailure("Could not create RC script");
		UIWB.CloseAllWindows();
	}
	else
	{
		if (!CreateVersionRes())
		{
			m_pLog->RecordFailure("Failed version creation test");
			UIWB.CloseAllWindows();
			return;
		}
		if (!EditCommentsField())
		{
			m_pLog->RecordFailure("Failed editing contents");
			UIWB.CloseAllWindows();
			return;
		}
		if (!CopyPaste())
		{
			m_pLog->RecordFailure("Failed copy paste test");
			UIWB.CloseAllWindows();
			return;
		}
		if (!NewStringBlock())
		{
			m_pLog->RecordFailure("Failed NewStringBlock test");
			UIWB.CloseAllWindows();
			return;
		}
		if (!DeleteStringBlock())
		{
			m_pLog->RecordFailure("Failed DeleteStringBlocktest");
			UIWB.CloseAllWindows();
			return;
		}
		if (!ChangeToStringID())
		{
			m_pLog->RecordFailure("Failed ChangeToStringID test");
			UIWB.CloseAllWindows();
			return;
		}
		if (!SaveOpen())
		{
			m_pLog->RecordFailure("Failed SaveOpen test");
			UIWB.CloseAllWindows();
			return;
		}
	}
	UIWB.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases


BOOL CVerTestCases::CreateVersionRes(void)
{
	XSAFETY;

	COResScript res;

	//Create new version
	if (res.CreateResource(IDSS_RT_VERSION) == ERROR_ERROR)
	{
		m_pLog->RecordFailure("Unable to create new version resource");
		return FALSE;
	}
	Sleep(1500);

	m_uVerEd = UIWB.GetActiveEditor();

	return TRUE;
}


BOOL CVerTestCases::EditCommentsField(void)
{
	XSAFETY;

	CString cstrEditText;

	//Add file version
	MST.DoKeys("{DOWN}");
	MST.DoKeys("1,2,3,4");
	MST.DoKeys("~");

	//Add product version
	MST.DoKeys("{DOWN}");
	MST.DoKeys("5,6,7,8");
	MST.DoKeys("~");

	//Add file flags
	MST.DoKeys("{DOWN 2}");
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	prop.IsValid();
	MST.WCheckCheck( GetLabel(VRES_IDC_VS_FF_PRERELEASE) );
	UIWB.ShowPropPage(FALSE);	

	//Add file OS
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{ENTER}{HOME}");
	MST.DoKeys("~");

	//Add file type
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{ENTER}{HOME}");
	MST.DoKeys("~");

	//Add comments
	MST.DoKeys("{DOWN 3}");
	MST.DoKeys("This is a comment");
	MST.DoKeys("~");

	//Add company name
	MST.DoKeys("{DOWN}");
	MST.DoKeys("This is my company");
	MST.DoKeys("~");

	//Add file description
	MST.DoKeys("{DOWN}");
	MST.DoKeys("This is the file description");
	MST.DoKeys("~");

	//Add file version
	MST.DoKeys("{DOWN}");
	MST.DoKeys("1.3.5");
	MST.DoKeys("~");

	//Add internal name
	MST.DoKeys("{DOWN}");
	MST.DoKeys("Sniff test '96");
	MST.DoKeys("~");

	//Add copyright
	MST.DoKeys("{DOWN}");
	MST.DoKeys("Copyright ");
	MST.DoKeys("~");

	//Add legal tm's
	MST.DoKeys("{DOWN}");
	MST.DoKeys("Trademark ");
	MST.DoKeys("~");

	//Add original file name
	MST.DoKeys("{DOWN}");
	MST.DoKeys("Vres sniff");
	MST.DoKeys("~");

	//Add private build
	MST.DoKeys("{DOWN}");
	MST.DoKeys("This is a private build");
	MST.DoKeys("~");

	//Add product name
	MST.DoKeys("{DOWN}");
	MST.DoKeys("Cafe sniff test");
	MST.DoKeys("~");

	//Add product version
	MST.DoKeys("{DOWN}");
	MST.DoKeys("3.5.6");
	MST.DoKeys("~");

	//Add special build
	MST.DoKeys("{DOWN}");
	MST.DoKeys("This is a special build");
	MST.DoKeys("~");

	// Check if everything got entered correctly
	MST.DoKeys("{HOME}");

	//File version
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "1, 2, 3, 4")
	{
		m_pLog->RecordFailure("Incorrect file version: %s", cstrEditText);
		return FALSE;
	}

	//Product version
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "5, 6, 7, 8")
	{
		m_pLog->RecordFailure("Incorrect product version: %s", cstrEditText);
		return FALSE;
	}

	//Comments
	MST.DoKeys("{DOWN 7}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "This is a comment")
	{
		m_pLog->RecordFailure("Incorrect comment: %s", cstrEditText);
		return FALSE;
	}

	//Company name
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "This is my company")
	{
		m_pLog->RecordFailure("Incorrect company name: %s", cstrEditText);
		return FALSE;
	}

	//File description
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "This is the file description")
	{
		m_pLog->RecordFailure("Incorrect file description: %s", cstrEditText);
		return FALSE;
	}

	//File version
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "1.3.5")
	{
		m_pLog->RecordFailure("Incorrect file version: %s", cstrEditText);
		return FALSE;
	}

	//Internal name
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "Sniff test '96")
	{
		m_pLog->RecordFailure("Incorrect internal name: %s", cstrEditText);
		return FALSE;
	}

	//Copyright
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "Copyright ")
	{
		m_pLog->RecordFailure("Incorrect copyright: %s", cstrEditText);
		return FALSE;
	}

	//Legal tm's
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "Trademark ")
	{
		m_pLog->RecordFailure("Incorrect legal tm's: %s", cstrEditText);
		return FALSE;
	}

	//Original file name
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "Vres sniff")
	{
		m_pLog->RecordFailure("Incorrect original file name: %s", cstrEditText);
		return FALSE;
	}

	//Private build
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "This is a private build")
	{
		m_pLog->RecordFailure("Incorrect private build: %s", cstrEditText);
		return FALSE;
	}

	//Product name
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "Cafe sniff test")
	{
		m_pLog->RecordFailure("Incorrect product name: %s", cstrEditText);
		return FALSE;
	}

	//Product version
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "3.5.6")
	{
		m_pLog->RecordFailure("Incorrect product version: %s", cstrEditText);
		return FALSE;
	}

	//Special build
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "This is a special build")
	{
		m_pLog->RecordFailure("Incorrect special build: %s", cstrEditText);
		return FALSE;
	}

	return TRUE;
}	

BOOL CVerTestCases::CopyPaste(void)
{
	XSAFETY;

	CString cstrEditText;

	//Copy the last command
	MST.DoKeys("{END}");
	MST.DoKeys("{TAB}");
	UIWB.DoCommand( ID_EDIT_COPY, DC_ACCEL );
	MST.DoKeys("{ENTER}");


	//Paste it two up
	MST.DoKeys("{UP 2}");
	MST.DoKeys("{TAB}");
	UIWB.DoCommand( ID_EDIT_PASTE, DC_ACCEL );
	MST.DoKeys("{ENTER}");

	//Check it
	MST.DoKeys("{END}");
	MST.DoKeys("{UP 2}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "This is a special build")
	{
		m_pLog->RecordFailure("Paste failed: %s", cstrEditText);
		return FALSE;
	}

	//Undo the change
	UIWB.DoCommand(ID_EDIT_UNDO, DC_ACCEL);

	//Check it again
	MST.DoKeys("{END}");
	MST.DoKeys("{UP 2}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "Cafe sniff test")
	{
		m_pLog->RecordFailure("Undo failed: %s", cstrEditText);
		return FALSE;
	}

	//Find comments
	UIWB.DoCommand(ID_EDIT_FIND_DLG, DC_MNEMONIC);
	MST.DoKeys("This is a comment");
	MST.DoKeys("~");

	//Check that we found it
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "This is my company")
	{
		m_pLog->RecordFailure("Find failed: %s", cstrEditText);
		return FALSE;
	}

	return TRUE;
}

BOOL CVerTestCases::NewStringBlock(void)
{
	XSAFETY;

	//Create a new string block
	UIWB.DoCommand(IDM_NEW_STRINGBLOCK, DC_MNEMONIC);
	
	//Test it
	UIWB.ShowPropPage(TRUE);								// check props for new block
	CString cstrLangID = UIWB.GetProperty(P_LangID);		
	CString cstrCodePg = UIWB.GetProperty(P_CharSet);	
	UIWB.ShowPropPage(FALSE);		


//  Default changed: DougT, 02/08/95
//	if (cstrLangID != "1025")	   // 0 means 1st item in Language ID dropdown	(Arabic)
//	Default is now Lang Neutral ('0') 

	if (cstrLangID != "0")
	{
		m_pLog->Comment("New String block's LangID should be Lang Neutral");
		m_pLog->Comment("cstrLangID = %s", cstrLangID);
		return FALSE;
	}

	if (cstrCodePg != "1200")	  // 5th item in Code Page dropdown	 (Unicode)
	{
		m_pLog->Comment("New String block's Code Page should be Unicode");
		m_pLog->Comment("cstrCodePg = %s", cstrCodePg);
		return FALSE;
	}

	return TRUE;
}


BOOL CVerTestCases::DeleteStringBlock(void)
{
	XSAFETY;

	//Delete the block
	UIWB.DoCommand(IDM_DELETE_STRINGBLOCK, DC_MNEMONIC);
	MST.DoKeys("{ENTER}");  	// Confirm Delete alert
	
	//Select the block
	MST.DoKeys("{END}");
	
	//Check it
	UIWB.ShowPropPage(TRUE);	
	CString cstrLangID = UIWB.GetProperty(P_LangID);		// check props of current block
	CString cstrCodePg = UIWB.GetProperty(P_CharSet);	
	UIWB.ShowPropPage(FALSE);			//Hide Prop page if it is up


	if (cstrLangID == "0")	   // 0 means 1st item in Language ID dropdown	(Arabic)
	{
		m_pLog->Comment("Current String block's LangID should not be Arabic: %s", cstrLangID );
		return FALSE;
	}

	if (cstrCodePg != "1200")	  // 5th item in Code Page dropdown	 (Unicode)
	{
		m_pLog->Comment("Current String block's Code Page should be Unicode: %s", cstrCodePg);
		return FALSE;
	}

	return TRUE;
}

BOOL CVerTestCases::ChangeToStringID(void)
{
	XSAFETY;

	// Close editor
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
		return FALSE;
	}

	// Change ID
	UIWB.ShowPropPage(TRUE);			
	MST.DoKeys("Cool_Version{ENTER}");				// Close Version editor
	
	//Check it
	CString cstrID = UIWB.GetProperty(P_ID);	
	if(cstrID != "Cool_Version")
	{
		m_pLog->RecordFailure("Change to String ID failed");
		return FALSE;
	}

	UIWB.ShowPropPage(FALSE);

	return TRUE;
}		

BOOL CVerTestCases::SaveOpen(void)
{
	XSAFETY;

	CString cstrEditText;

	// Save resource 
	if ( UIWB.SaveFileAs(m_strCWD + "Version .rc", TRUE) == FALSE )
	{
		m_pLog->RecordFailure("File save failed %s", m_strCWD + "Version .rc");
		return FALSE;
	}
	Sleep(1500);

	// Close editor
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close editor");
		return FALSE;
	}

	//reopen file
	HWND hwnd = UIWB.OpenFile(m_strCWD + "Version .rc");
	if (hwnd == NULL)
	{
		m_pLog->RecordFailure("File-Open: hwnd == %x", hwnd);
		return FALSE;
	}

	//Reopen editor
	MST.DoKeys("{DOWN}~{DOWN}~");

	// Check if everything got entered correctly
	MST.DoKeys("{HOME}");

	//File version
	MST.DoKeys("{TAB}");
	MST.WEditText("", cstrEditText);
	MST.DoKeys("{ENTER}");
	if (cstrEditText != "1, 2, 3, 4")
	{
		m_pLog->RecordFailure("File not opened correctly: %s", cstrEditText);
		return FALSE;
	}

	//Close it again
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\dlgwalk.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Generic.CPP
//
//	Created by :					Date : 
//		DougMan							1/7/97
//					  
//	Description :
//		InfoViewer's DialogWalk Sniff Tests
//		This test verifies that all IV5 dialogs are accessable
//


#include "stdafx.h"
//#include "wbutil.h"					//GetLocString function to grab Text from the string table
//#include "testutil.h"
#include "mstwrap.h"
//#include "umainfrm.h"
//#include "..\eds\ufindrep.h"
//#include "..\eds\COSource.h"
#include "sniff.h"
#include "DlgWalk.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


IMPLEMENT_TEST(CDlgWalk, CTest, "InfoViewer DialogWalk", -1, CSniffDriver)

void CDlgWalk::Run(void)
{

	int		iCount=0;
	CASES	sTestCases[TOTALDIALOGS];


	m_pLog->Comment("Begin DialogWalk Test - Maintained by DougMan");

//  Setup Initial Conditions for the Test
	iCount=0;
	// Initalize the sTestCases array
	InitalCases((struct CASES*) &sTestCases);

	
//  CDlgWalk main routine starts here.

	for( int i = 0; i < TOTALDIALOGS; ++i )
		iCount=iCount + FindDialog(sTestCases[i].PreTest, sTestCases[i].iDlg_Mnemonic, sTestCases[i].iVerification, sTestCases[i].aAdditionalKey, sTestCases[i].PostTest);

	if(iCount>0){
//	strReturn = iCount + " out of " + TOTALDIALOGS + " failed to appear./n See Comments in log file for missing dialogs.";
	m_pLog->RecordFailure("One or more dialogs/windows failed to appear./n See Comments in log file for missing dialogs");
	}

	m_pLog->Comment("Comment Printed in the Cafe Log - End of DialogWalk Test");

};	// End Run()


int CDlgWalk::FindDialog(CString strPreCase, UINT iMnemonic, UINT iVerify, CString strAddKeys, CString strPostCase)
{
	LPCSTR		aTitle = "";
	CString		aString = "";
	HWND		hWindow = NULL;
	int			iCounter=0;


	if(strPreCase != "") {
		MST.DoKeys(strPreCase);
	}

	if (iMnemonic != 0){
		UIWB.DoCommand(iMnemonic, DC_MNEMONIC);	// Activate requested dialog/window based on Mnemonic
	}

	if(strAddKeys != "") {
		MST.DoKeys(strAddKeys);
	}

	aString = GetLocString(iVerify,CAFE_LANG_ENGLISH);		// used to get strings from wb.rc file
//	aString.LoadString(iVerify);  // used to get strings from projects rc file
	aTitle = aString;
	hWindow = MST.WFndWndWait(aTitle, FW_ALL | FW_DIALOGOK, SHORTWAIT);  // verify that requested dialog/window appeared
//m_pLog->Comment("The Window Title:  " + aString); // DEBUGGING LINE
	if (hWindow == NULL) {
		m_pLog->Comment("Did NOT Find " + aString + "!");
		iCounter=1;
	}

	if(strPostCase != "") {
		MST.DoKeys(strPostCase);
	}

	return(iCounter);
};  // End FindDialog()
 

void CDlgWalk::InitalCases(struct CASES *ptTestCases)
{

//	struct CASES {
//	UINT	iDlg_Mnemonic;
//	UINT	iVerification;
//	CString	aAdditionalKey;	
//}; // End TestCases Structure

//  Initialization of the Test Case Array
	//  iDlg_Mnemonic

	ptTestCases[0].iDlg_Mnemonic  = IDM_OPTIONS;	//second one for Tabs on the dialog
	ptTestCases[1].iDlg_Mnemonic  = IDM_CUSTOMIZE;	//second one for Tabs on the dialog
	ptTestCases[2].iDlg_Mnemonic  = IDM_VIEW_WORKSPACE;
	ptTestCases[3].iDlg_Mnemonic  = IDM_VIEW_RESULTS;
	ptTestCases[4].iDlg_Mnemonic  = IDM_VIEW_RESULTS;
	ptTestCases[5].iDlg_Mnemonic  = IDM_VIEW_TOPIC;
	ptTestCases[6].iDlg_Mnemonic  = 0;
	ptTestCases[7].iDlg_Mnemonic  = IDM_HELP_IVBOOKMARKS;
	ptTestCases[8].iDlg_Mnemonic  = IDM_HELP_IVBOOKMARKS;
	ptTestCases[9].iDlg_Mnemonic  = IDM_HELP_IVBOOKMARKS;
	ptTestCases[10].iDlg_Mnemonic  = ID_FILE_PRINT;
	ptTestCases[11].iDlg_Mnemonic = ID_FILE_PAGE_SETUP;
	ptTestCases[12].iDlg_Mnemonic = ID_EDIT_FIND_DLG;
	ptTestCases[13].iDlg_Mnemonic = ID_FILE_OPEN;
	ptTestCases[14].iDlg_Mnemonic = IDM_GOTO_LINE;
	ptTestCases[15].iDlg_Mnemonic = IDM_HELP_SEARCH; //second one for Tabs on the dialog
	ptTestCases[16].iDlg_Mnemonic = IDM_HELP_DEFINESUBSETS;
	ptTestCases[17].iDlg_Mnemonic = IDM_HELP_SELECTSUBSETS;
//	ptTestCases[18].iDlg_Mnemonic = ;

	//  iVerification
	ptTestCases[0].iVerification  = IDSS_OD_TITLE;
	ptTestCases[1].iVerification  = IDSS_CUSTOMIZE_TITLE;
	ptTestCases[2].iVerification  = IDSS_WORKSPACE_TITLE;
	ptTestCases[3].iVerification  = IDSS_RESULTS_TITLE;
	ptTestCases[4].iVerification  = IDSS_RESULTSPROPS_TITLE;
	ptTestCases[5].iVerification  = IDSS_IVTOPIC_TITLE;
	ptTestCases[6].iVerification  = IDS_IV_TOPICWND_TITLE;
	ptTestCases[7].iVerification  = IDSS_IVBOOKMARKS_TITLE;
	ptTestCases[8].iVerification  = IDSS_ADDIVBOOKMARK_TITLE;
	ptTestCases[9].iVerification  = IDSS_EDITIVBOOKMARK_TITLE;
	ptTestCases[10].iVerification  = IDSS_FP_TITLE;
	ptTestCases[11].iVerification = IDSS_FU_TITLE;
	ptTestCases[12].iVerification = IDSS_FIND_TITLE;
	ptTestCases[13].iVerification = IDSS_FO_TITLE;
	ptTestCases[14].iVerification = IDSS_GOTO_TITLE;
	ptTestCases[15].iVerification = IDSS_SEARCH_TITLE;
	ptTestCases[16].iVerification = IDSS_DEFINESUBSETS_TITLE;
	ptTestCases[17].iVerification = IDSS_SELECTSUBSETS_TITLE;
//	ptTestCases[18].iVerification = ;

	//  aAdditionalKeys
	ptTestCases[0].aAdditionalKey  = "";
	ptTestCases[1].aAdditionalKey  = "";
	ptTestCases[2].aAdditionalKey  = "";
	ptTestCases[3].aAdditionalKey  = "";
	ptTestCases[4].aAdditionalKey  = "%{ENTER}";	
	ptTestCases[5].aAdditionalKey  = "";
	ptTestCases[6].aAdditionalKey  = "";
	ptTestCases[7].aAdditionalKey  = "";
	ptTestCases[8].aAdditionalKey  = "%A";
	ptTestCases[9].aAdditionalKey  = "%E";
	ptTestCases[10].aAdditionalKey  = "";
	ptTestCases[11].aAdditionalKey = "";
	ptTestCases[12].aAdditionalKey = "";
	ptTestCases[13].aAdditionalKey = "";
	ptTestCases[14].aAdditionalKey = "";
	ptTestCases[15].aAdditionalKey = "";
	ptTestCases[16].aAdditionalKey = "";
	ptTestCases[17].aAdditionalKey = "";
//	ptTestCases[18].aAdditionalKey = "";

	ptTestCases[0].PreTest  = "";
	ptTestCases[1].PreTest  = "";
	ptTestCases[2].PreTest  = "%0%WD^{F4}";
	ptTestCases[3].PreTest  = "";
	ptTestCases[4].PreTest  = "";
	ptTestCases[5].PreTest  = "";
	ptTestCases[6].PreTest  = "";
	ptTestCases[7].PreTest  = "";
	ptTestCases[8].PreTest  = "";
	ptTestCases[9].PreTest  = "";
	ptTestCases[10].PreTest  = "";
	ptTestCases[11].PreTest = "";
	ptTestCases[12].PreTest = "";
	ptTestCases[13].PreTest = "";
	ptTestCases[14].PreTest = "";
	ptTestCases[15].PreTest = "";
	ptTestCases[16].PreTest = "";
	ptTestCases[17].PreTest = "";
//	ptTestCases[18].PreTest = "";

	ptTestCases[0].PostTest  = "{ESC}";
	ptTestCases[1].PostTest  = "{ESC}";
	ptTestCases[2].PostTest  = "%WD";
	ptTestCases[3].PostTest  = "";
	ptTestCases[4].PostTest  = "{ESC}";
	ptTestCases[5].PostTest  = "";
	ptTestCases[6].PostTest  = "";
	ptTestCases[7].PostTest  = "";
	ptTestCases[8].PostTest  = "{ENTER}";
	ptTestCases[9].PostTest  = "{ESC}%D{ESC}";
	ptTestCases[10].PostTest  = "{ESC}";
	ptTestCases[11].PostTest = "{ESC}";
	ptTestCases[12].PostTest = "{ESC}";
	ptTestCases[13].PostTest = "{ESC}";
	ptTestCases[14].PostTest = "{ESC}";
	ptTestCases[15].PostTest = "{ESC}";
	ptTestCases[16].PostTest = "{ESC}";
	ptTestCases[17].PostTest = "{ESC}";
//	ptTestCases[18].PostTest = "";


//  When adding/removing test cases remember to increase/decrease the TOTALDIALOGS constent in the dlgwalk.h file

//	ArryID#	iDlg_Mnemonic,				iVerification,				aAdditionalKeys,	Initial Conditions
//	0		{IDM_VIEW_WORKSPACE,		IDSS_WORKSPACE_TITLE, 		NULL},				// Workspace window should be closed (INITIALIZE)
//
//	1		{IDM_VIEW_RESULTS,			IDSS_RESULTS_TITLE,			NULL},				// Results List window should be closed (INITIALIZE)
//	2		{IDM_VIEW_RESULTS,			IDSS_RESULTSPROPS_TITLE,	"%{ENTER}"},		// Results List window must be selected
//
//	3		{IDM_VIEW_TOPIC,			IDSS_IVTOPIC_TITLE,			NULL},				// InfoViewer Topic window should be closed (INITIALIZE)
//	4		{IDM_HELP_IVBOOKMARKS,		IDSS_IVBOOKMARKS_TITLE,		NULL},				// None, except ADD Bookmark requires some content window must be selected(Topic Window)
//	5		{IDM_HELP_IVBOOKMARKS,		IDSS_ADDIVBOOKMARK_TITLE,	"%A"},				// Some content window must be selected(Topic Window)
//	6		{IDM_HELP_IVBOOKMARKS,		IDSS_EDITIVBOOKMARK_TITLE,	"%E"},	//***		// A bookmark must exist, Add Bookmark
//	7		{ID_FILE_PRINT,				IDSS_FP_TITLE,				NULL},				// Some content window must be selected(Topic Window)
//	8		{ID_FILE_PAGE_SETUP,		IDSS_FU_TITLE,				NULL},				// Some content window must be selected(Topic Window)
//	9		{ID_EDIT_FIND_DLG,			IDSS_FIND_TITLE,			NULL},				// Some content window must be selected(Topic Window)
//
//	10		{ID_FILE_OPEN,				IDSS_FO_TITLE,				NULL},				// None
//	11		{IDM_GOTO_LINE,				IDSS_GOTO_TITLE,			NULL},				// None
//	12		{IDM_HELP_SEARCH,			IDSS_SEARCH_TITLE,			NULL},				// None (2 Tabs on this dialog)
//		//	{IDM_HELP_SEARCH,			IDSS_SEARCH_TITLE,			"+{TAB}{RIGHT}"},	// None (2 Tabs on this dialog)
//	13		{IDM_HELP_DEFINESUBSETS,	IDSS_DEFINESUBSETS_TITLE,	NULL},				// None
//	14		{IDM_HELP_SELECTSUBSETS,	IDSS_SELECTSUBSETS_TITLE,	NULL},				// None
//	15		{IDM_CUSTOMIZE,				IDSS_CUSTOMIZE_TITLE,		NULL},				// None (5 Tabs on this dialog)
//		//	{IDM_CUSTOMIZE,				IDSS_CUSTOMIZE_TITLE,		"+{TAB}{RIGHT}"},	// None (5 Tabs on this dialog)
//	16		{IDM_OPTIONS,				IDSS_OD_TITLE,				NULL}				// None (14 Tabs on this dialog)
//		//	{IDM_OPTIONS,				IDSS_OD_TITLE,				"+{TAB}{RIGHT}"}	// None (14 Tabs on this dialog)
//		
//		//	To emable test to detect the various tabs of a dialog a better iVerication needs to be used, and more inital conditions will apply to dialogs with multiple tabs???

};	// End InitCases();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\tbrcases.h ===
///////////////////////////////////////////////////////////////////////////////
//    TBRCASES.H
//
//    Created by :                    Date :
//            MikePie                 2/28/95
//
//    Description :
//            Declaration of the CTbrTestCases class
//
 
#ifndef __TBRCASES_H__
#define __TBRCASES_H__

#ifndef __STDAFX_H__
      #error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CTbrTestCases class

class CTbrTestCases : public CTest
{
	DECLARE_TEST(CTbrTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Test Cases
protected:
	BOOL NewToolbar(void);
	BOOL ModifyToolbar(void);
	BOOL CheckWidth(void);
	BOOL CheckHeight(void);
	BOOL CloseToolbar(void);
};

#endif //__TBRCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\vercases.h ===
///////////////////////////////////////////////////////////////////////////////
//	VERCASES.H
//
//	Created by :			Date :
//		Enriquep					8/27/93
//
//	Modifies by :			Date :
//		ScottSe						9/13/96		Major rewrite of the entire test
//
//	Description :
//		Declaration of the CVerTestCases class
//

#ifndef __VERCASES_H__
#define __VERCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CVerTestCases class

class CVerTestCases : public CTest
{
	DECLARE_TEST(CVerTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:
	UIVerEdit m_uVerEd;

// Test Cases
protected:
	BOOL CreateVersionRes(void);
	BOOL EditCommentsField(void);
	BOOL CopyPaste(void);
	BOOL NewStringBlock(void);
	BOOL ChangeToStringID(void);
	BOOL DeleteStringBlock(void);
	BOOL SaveOpen(void);
};

#endif //__VERCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ResEdit\Sniff\Src\tbrcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	TBRCASES.CPP
//
//	Created by :			Date :
//		MikePie				3/27/95
//
//	Description :
//		Implementation of the CTbrTestCases class
//
//	7/7/95		M.Pietraszak	Used to change focus (F6), now closes (F4)
//	8/13/96		ScottSe			Separated %(MT) & %(MI) 
//

#include "stdafx.h"
#include "Tbrcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CTbrTestCases, CTest, "Toolbar Editor Tests", -1, CSniffDriver)

void CTbrTestCases::Run(void)
{
	HWND hwndRC;

	if ((hwndRC = UIWB.CreateNewFile(GetLocString(IDSS_NEW_RC))) == NULL)
	{
		m_pLog->RecordFailure("Could not create RC script");
		UIWB.CloseAllWindows();
		return;
	}
	else
	{
		m_pLog->RecordInfo("Created RC script");
		NewToolbar();		// Create a bitmap resource	
		ModifyToolbar();	// Change the toolbar
		CheckWidth();		// Checks the toolbar button size
		CheckHeight();		// Checks the toolbar button size
 		CloseToolbar();			
	}
	UIWB.CloseAllWindows();
	return;
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CTbrTestCases::NewToolbar(void)
{
	COResScript res;

	Sleep(1000);
	if (res.CreateResource(IDSS_RT_BITMAP) == ERROR_ERROR) 
 	{
		m_pLog->RecordFailure("Could not create new Bitmap.");
		return FALSE;
	}
	else
	{
		m_pLog->RecordInfo("Created new Bitmap."); 
		return TRUE;
	}

}

BOOL CTbrTestCases::ModifyToolbar(void)
{
	m_pLog->RecordInfo("Converting Bitmap into Toolbar...");

	Sleep(6000);
 	UIWB.DoCommand( IDM_INVERTCOLORS, DC_MNEMONIC );     // I(m)age.(I)nvert colors
	Sleep(1000);

 	UIWB.DoCommand( IDM_TOOLBAR_WIZARD, DC_MNEMONIC );     // I(m)age.(T)oolbar editor
	Sleep(2000);
	MST.DoKeys("24");			// Width = 24
	MST.DoKeys("{TAB}");		// Go to height...
	Sleep(500);
	MST.DoKeys("23");			// Height = 23
	MST.DoKeys("{TAB}");		// Go to OK button
	Sleep(500);
	MST.DoKeys("{ENTER}");		// Click on OK
	Sleep(800);
	MST.DoKeys("{ENTER}");		// Image will be converted - OK
	Sleep(2000);
	MST.DoKeys("^({F4})");		// Ctrl+F4 will close the toolbar editor
	Sleep(1000);
	MST.DoKeys("{UP}");			// Move up to the toolbar folder
	MST.DoKeys("{ENTER}");		// Close the toolbar folder
	MST.DoKeys("{ENTER}");		// Open the toolbar folder
	Sleep(2000);
	MST.DoKeys("{DOWN}");		// Move from the toolbar folder to a specific resource
	Sleep(800);
	MST.DoKeys("{ENTER}");		// Will open the toolbar editor again
	Sleep(800);
	MST.DoKeys("{RIGHT}");		// Select the second toolbar button
	Sleep(400);
	MST.DoKeys("%({ENTER})");	// Check out the properties of the second button

	// This was bombing out on a faster machine.
	Sleep(2000);
	CString cstrButtonId = UIWB.GetProperty(P_ID);	

	if (cstrButtonId != "ID_BUTTON40002")
	{
		m_pLog->RecordFailure("Button ID not correct. Expected ID_BUTTON40002, but");
		m_pLog->RecordFailure("got id = %s instead.",cstrButtonId);
		m_pLog->RecordFailure("----------------------------------");
		m_pLog->RecordFailure("Failure due to Olympus 13073 bug. ");
		m_pLog->RecordFailure("----------------------------------");
		return FALSE;
	}
	else
	{
		m_pLog->RecordInfo("Got id = %s as expected.",cstrButtonId);
		return TRUE;
	}
	

}

BOOL CTbrTestCases::CheckWidth(void)
{
	m_pLog->RecordInfo("Checking Toolbar button width...");

	Sleep(2000);
	CString cstrButtonWidth = UIWB.GetProperty(P_Width);

	if (cstrButtonWidth != "24")
	{
		m_pLog->RecordFailure("Button width is not correct. Expected 24, but");
		m_pLog->RecordFailure("got width = %s instead.",cstrButtonWidth);
		m_pLog->RecordFailure("----------------------------------");
		m_pLog->RecordFailure("Failure due to Olympus 13073 bug. ");
		m_pLog->RecordFailure("----------------------------------");
		return FALSE;
	}
	else
	{
		m_pLog->RecordInfo("Got width = %s as expected.",cstrButtonWidth);
		return TRUE;
	}
	

}

BOOL CTbrTestCases::CheckHeight(void)
{
	m_pLog->RecordInfo("Checking Toolbar button height...");

	Sleep(2000);
	CString cstrButtonHeight = UIWB.GetProperty(P_Height);	

	if (cstrButtonHeight != "23")
	{
		m_pLog->RecordFailure("Button height is not correct. Expected 23, but");
		m_pLog->RecordFailure("got height = %s instead.",cstrButtonHeight);
		m_pLog->RecordFailure("----------------------------------");
		m_pLog->RecordFailure("Failure due to Olympus 13073 bug. ");
		m_pLog->RecordFailure("----------------------------------");
		return FALSE;
	}
	else
	{
		m_pLog->RecordInfo("Got height = %s as expected.",cstrButtonHeight);
		return TRUE;
	}
	

}




BOOL CTbrTestCases::CloseToolbar(void)
{
	MST.DoKeys("{ESC}");		// Close properties
	MST.DoKeys("^({F4})");		// Close editor	 

	Sleep(2000);
	UIEditor ed = UIWB.GetActiveEditor();
	EXPECT( ed.IsValid() );
	if( !ed.Close() )
	{
		m_pLog->RecordFailure("Could not close Toolbar editor.");
		m_pLog->RecordFailure("----------------------------------");
		m_pLog->RecordFailure("Failure due to Olympus 13073 bug. ");
		m_pLog->RecordFailure("----------------------------------");
		return FALSE;
	}
	else
	{
		m_pLog->RecordInfo("Closed Toolbar editor.");
		return TRUE;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\f1lookup.h ===
///////////////////////////////////////////////////////////////////////////////
//	F1Lookup.H
//
//	Created by :					Date :
//		MarcI							9/3/94
//
//	Description :
//		Declaration of the IV's F1Lookup class
//

#ifndef __F1LOOKUP_H__
#define __F1LOOKUP_H__

#include "sniff.h"
#include "resource.h"
#include "ivutil.h"
///////////////////////////////////////////////////////////////////////////////
//	BOOL CF1Lookup:: class

class CF1Lookup : public CTest 
{
	DECLARE_TEST(CF1Lookup, CSniffDriver)

// Operations
public:
	virtual void Run(void);
	void		Initialize_F1();
	void		Lookup(UINT uiID);

// Data
protected:
	CString 	FCN;
private:
	void	FindText(LPCSTR szFind, BOOL bMatchWord, BOOL bMatchCase, BOOL bRegExpr);

};


#endif // __F1LOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\dlgwalk.h ===
///////////////////////////////////////////////////////////////////////////////
//	DlgWalk.H
//
//	Created by :					Date :
//		DougMan							1/7/97
//
//	Description :
//		Declaration of a DlgWalk class
//		This test verifies that all the IV5 dialogs are accessable
//

#ifndef __DLGWALK_H__
#define __DLGWALK_H__

#include "sniff.h"
#include "ivutil.h"
#include "resource.h"

// Used by DLGWALK
const int TOTALDIALOGS = 18;

struct CASES {
	UINT	iDlg_Mnemonic;
	UINT	iVerification;
	CString	aAdditionalKey;
	CString PreTest;
	CString PostTest;
}; // End TestCases Structure


///////////////////////////////////////////////////////////////////////////////
//	BOOL CGeneric:: class

class CDlgWalk : public CTest 
{
	DECLARE_TEST(CDlgWalk, CSniffDriver)

public:
// Overrides
	virtual void Run(void);
// Operations
	
// Data

protected:
	
private:
int CDlgWalk::FindDialog(CString strPreCase, UINT iMnemonic, UINT iVerify, CString strAddKeys, CString strPostCase);
void CDlgWalk::InitalCases(CASES *ptTestCases);
};


#endif // __DLGWALK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\f1lookup.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	F1Lookup.CPP
//
//	Created by :					Date :
//		MarcI							8/20/96
//					  
//	Description :
//		InfoViewer's F1 Lookup Sniff Tests


#include "stdafx.h"
#include "mstwrap.h"
#include "F1Lookup.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

COSource	sourceFile;
COSource	*pSourceFile=&sourceFile;

IMPLEMENT_TEST(CF1Lookup, CTest, "InfoViewer F1Lookup", -1, CSniffDriver)

void CF1Lookup::Run(void)
{
	LPCSTR		aTitle	=	"";
	CString		aString =	"";
	CString&	raString =	aString;
	HWND		hSourceWnd = NULL;
	HWND		hTopicWindow = NULL;
	int			iCount = 0;

	//initialization for all tests goes here
	Initialize_F1();

//	DoCommand
	hSourceWnd = MST.WGetActWnd(0);

  m_pLog->Comment("Looking up a topic that will generate no hits");
	Lookup(IDS_F1LOOKUP_NOHITS);
	aString = GetLocString(IDSS_WORKBENCH_TITLEBAR, CAFE_LANG_ENGLISH);		// used to get strings from wb.rc file
//	aString.LoadString(IDS_TITLE_NOTOPICSFOUND);
	aTitle = aString;
	hTopicWindow = MST.WFndWndWait(aTitle, FW_ACTIVE_ONLY | FW_DIALOG, 90);
	if (hTopicWindow == NULL) {
		iCount = iCount+1;
		m_pLog->Comment("Did NOT Find the NoTopicsFound error message.");
	}
	
	ASSERT(hTopicWindow != NULL);
	MST.DoKeys("{ESC}");
	UIWB.DoCommand(ID_EDIT_SELECT_ALL, DC_MNEMONIC);
	MST.DoKeys("{DEL}");

  m_pLog->Comment("Looking up a topic that will generate only one hit");
	Lookup(IDS_F1LOOKUP_ONEHIT);
	aString = GetLocString(IDS_IV_TOPICWND_TITLE, CAFE_LANG_ENGLISH);		// used to get strings from wb.rc file
//	aString.LoadString(IDS_TITLE_TopicWindow);
	aTitle = aString;
	hTopicWindow = MST.WFndWndWait(aTitle, FW_ACTIVE | FW_PART | FW_FOCUS | FW_RESTOREICON, MAXWAIT);
	if (hTopicWindow == NULL) {
		 iCount = iCount+1;
		m_pLog->Comment("Did NOT Find the Topic Window.");
	}
	ASSERT(hTopicWindow != NULL);
	MST.WSetActWnd(hSourceWnd);
	UIWB.DoCommand(ID_EDIT_SELECT_ALL, DC_MNEMONIC);
	MST.DoKeys("{DEL}");

  m_pLog->Comment("Looking up a topic that will generate more than one hit");
	Lookup(IDS_F1LOOKUP_SOMEHITS);
	MST.DoKeys ("{DOWN}");					//arrow down to force the topic list dock to have focus
	MST.DoKeys("{ENTER}");					//load the Topic in the IV Window
	aString = GetLocString(IDS_IV_TOPICWND_TITLE, CAFE_LANG_ENGLISH);		// used to get strings from wb.rc file
//	aString.LoadString(IDS_TITLE_TopicWindow);
	aTitle = aString;
	hTopicWindow = MST.WFndWndWait(aTitle, FW_ACTIVE | FW_PART | FW_FOCUS | FW_RESTOREICON, MAXWAIT);
	if (hTopicWindow == NULL) {
		iCount = iCount+1;
		m_pLog->Comment("Did NOT Find the Topic Window.");
	}
	MST.WSetActWnd(hSourceWnd);
	UIWB.DoCommand(ID_EDIT_SELECT_ALL, DC_MNEMONIC);
	DoKeysSlow("{DEL}",SHORTWAIT*100);

	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);
	MST.DoKeys("{TAB}");								// select the "No" Button
	MST.DoKeys("{ENTER}");								// select the "No" Button

	if(iCount>0){
		m_pLog->RecordFailure("One or more dialogs/windows failed to appear. See Comments in log file for missing dialogs");
	}
};


void CF1Lookup::Initialize_F1() {
	pSourceFile->Create();

};


void CF1Lookup::Lookup(UINT uiID) {
	CString		preText;
	CString		targetText;
	CString		postText;

// Type a string with the target word from uiID
	preText.LoadString(IDS_SURROUND_TEXT1);
	targetText.LoadString(uiID);
	postText.LoadString(IDS_SURROUND_TEXT2);
	pSourceFile->TypeTextAtCursor(preText + targetText + postText);

	MST.DoKeys("^{HOME}");							//start at the beginning of the source file
	FindText(targetText, TRUE, FALSE, FALSE);		//Edit:Find
	MST.DoKeys ("{F1}",FALSE,5);
}


void CF1Lookup::FindText(LPCSTR szFind, BOOL bMatchWord, BOOL bMatchCase, BOOL bRegExpr) {

	UIFindDlg uiFind;

	uiFind.Activate();
	// set the find string
	uiFind.SetFindString(szFind);
	// set match word
	uiFind.SetMatchWord(bMatchWord);
	// set match case
	uiFind.SetMatchCase(bMatchCase);
	// set regular expression
	uiFind.SetRegularExpression(bRegExpr);
	// set find direction
	uiFind.SetDirection(UIFindDlg::FD_DOWN);

	// do the find
	MST.WButtonClick(GetLabel(VSHELL_IDC_FIND_NEXT));

//	return uiFind.FindNext();  // GAC original
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\generic.h ===
///////////////////////////////////////////////////////////////////////////////
//	Generic.H
//
//	Created by :					Date :
//		DougMan							1/6/97
//
//	Description :
//		Declaration of a Generic class
//		A Starting Point

#ifndef __GENERIC_H__
#define __GENERIC_H__

#include "sniff.h"
#include "ivutil.h"
#include "resource.h"

///////////////////////////////////////////////////////////////////////////////
//	BOOL CGeneric:: class

class CGeneric : public CTest 
{
	DECLARE_TEST(CGeneric, CSniffDriver)

public:
// Overrides
	virtual void Run(void);
// Operations
	
// Data

protected:
	
private:
	
};


#endif // __GENERIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\fts.h ===
///////////////////////////////////////////////////////////////////////////////
//	FST.H
//
//	Created by :					Date :
//		DougMan							1/14/97
//
//	Description :
//		Declaration of a FST class
//		This test verifies that basic Full Text Search(FTS) works in IV5
//

#ifndef __FTS_H__
#define __FTS_H__

#include "sniff.h"
#include "ivutil.h"
#include "resource.h"

// Used by FTS
const int FTS_TC = 7;  // Used by FTS sniff test, it is the total number of testcase to be run

struct FTS_CASES {
	UINT	iSearchString;
	UINT	iVerificationString;
}; // End TestCases Structure


///////////////////////////////////////////////////////////////////////////////
//	BOOL CGeneric:: class

class CFTS : public CTest 
{
	DECLARE_TEST(CFTS, CSniffDriver)

public:
// Overrides
	virtual void Run(void);
// Operations
	
// Data

protected:
	
private:
int CFTS::VerifySearch(UINT iSearch, UINT iVerify);
void CFTS::InitalCases(FTS_CASES *ptTestCases);
};


#endif // __FTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\ivutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	IVUTIL.CPP
//
//	Created by :			Date :
//		MarcI					9/2/96
//
//	Description :
//		Implementation of IV Sniff utilities
//

#include "stdafx.h"



void	InitIV (void)
{
	COWorkSpace		theWorkSpace;

	if(!theWorkSpace.IsDockWindowVisible(IDDW_IVRESULTS)) {
		theWorkSpace.ShowToolbar(IDDW_IVRESULTS,TRUE);
	}
	ASSERT(theWorkSpace.IsDockWindowVisible(IDDW_IVRESULTS));


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\ivutil.h ===
///////////////////////////////////////////////////////////////////////////////
//	IVUTIL.H
//
//	Created by :					Date :
//		MarcI							9/2/96
//
//	Description :
//		Declaration of the IV Constants
//

#ifndef __IV_H__
#define __IV_H__


const MAXWAIT = 25;
const LONGWAIT = 15;
const SHORTWAIT = 5;
const MINWAIT = 1;

void	InitIV (void);
#endif // __IV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\generic.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Generic.CPP
//
//	Created by :					Date : 
//		DougMan							1/6/97
//					  
//	Description :
//		InfoViewer's Generic Sniff Tests
//		A Starting Point


#include "stdafx.h"
//#include "wbutil.h"					//GetLocString function to grab Text from the string table
//#include "testutil.h"
//#include "mstwrap.h"
//#include "umainfrm.h"
//#include "..\eds\ufindrep.h"
//#include "..\eds\COSource.h"
#include "sniff.h"
#include "Generic.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CGeneric, CTest, "InfoViewer Generic", -1, CSniffDriver)

void CGeneric::Run(void)
{
  
	//initialization for all tests goes here

	m_pLog->Comment("Comment Printed in the Cafe Log - End of Generic Test");

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\fts.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	FST.CPP
//
//	Created by :					Date : 
//		DougMan							1/14/97
//					  
//	Description :
//		InfoViewer's Full Text Search(FTS) Sniff Tests
//		This test verifies that basic Full Text Search(FTS) works in IV5
//


#include "stdafx.h"
#include "mstwrap.h"
#include "sniff.h"
#include "FTS.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


IMPLEMENT_TEST(CFTS, CTest, "InfoViewer Full Text Search(FTS)", -1, CSniffDriver)

void CFTS::Run(void)
{
	COSource	sourceFile_FTS;
	COSource	*pSourceFile_FTS=&sourceFile_FTS;
	int iCount;
	FTS_CASES	sTestCases[FTS_TC];
	
	
	m_pLog->Comment("Begin Full Text Search(FTS) Test - Maintained by DougMan");

//  Setup Initial Conditions for the Test
	iCount=0;
	// Initalize the sTestCases array
	InitalCases((struct FTS_CASES*) &sTestCases);
	// Setting up Visual Studio with a blank page.
	pSourceFile_FTS->Create();
	DoKeys("%-x");	// Maximize Text Windows.
	DoKeys("%0");	// Give TOC windows focus - In Cafe ONLY Ctrl+Shift+F will not work if Text window has focus.
		

//  FTS Main routine
	for( int i = 0; i < FTS_TC; ++i )
		iCount=iCount + VerifySearch(sTestCases[i].iSearchString, sTestCases[i].iVerificationString);

	if(iCount>0){
	m_pLog->RecordFailure("One or more Searchs failed./n See Comments in log file for missing dialogs");
	}

//  Post Test Cleanup
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	m_pLog->Comment("Comment Printed in the Cafe Log - End of DialogWalk Test");

};	// End Run()



int CFTS::VerifySearch(UINT iSearch, UINT iVerify)
{
	LPCSTR		aTitle  = "";
	CString		aString = "";
	CString		aVerify = "";
	CString		aError	= "";
	HWND		hWindow = NULL;
	int			iCounter=0;
	BOOL		bTest=FALSE;


//  Start Search
//	UIWB.DoCommand(IDM_HELP_SEARCH, DC_MNEMONIC);	// Activate the Search dialog based on its Mnemonic
	MST.DoKeys("^(+F)");  // *** NEED TO SETUP GLOBAL MNEMONIC IN CAFE FOR THIS Dialog. ***
	aString.LoadString(iSearch);  // used to get the search strings from projects rc file
	MST.DoKeys(aString);
	MST.DoKeys("{ENTER}");


//	hWindow=MST.WFndWndWait("Searching...", FW_NOEXIST,2);
//	hWindow = MST.WFndWndWait("Searching...", FW_NOEXIST & FW_DIALOG, 2);  //*****WHAT DOES THIS COMMAND RETURN IF IT TIMED OUT, IT WAS SUCCESSFUL??? *****
//	if(hWindow != NULL ){
//		m_pLog->Comment("Searching... has finished successfully.");  //***** DEBUG  *****
//	}


//  Verify Search

	aVerify = GetLocString(IDSS_WORKBENCH_TITLEBAR,CAFE_LANG_ENGLISH);		// used to get strings from wb.rc file
//	aVerify.LoadString(IDS_FTS_ERRORTITLE);
	aTitle = aVerify;
	hWindow = MST.WFndWndWait(aTitle, FW_ACTIVE_ONLY , SHORTWAIT);  //FW_EXIST & FW_DIALOG
	if (hWindow != NULL) {
		// Either the "Search Failed" or "No Topics Found" warning dialog has appeared.
		aError = GetLocString(IDS_SEARCHFAILED, CAFE_LANG_ENGLISH);		// used to get strings from wb.rc file
//		aError.LoadString(IDS_FTS_SEARCHFAILED);
		aTitle = aError;
		bTest=MST.WStaticExists(aTitle);
	//	CString		strTest="";				//*****Declaration for variable in next line.*****
	//	MST.WStaticText(aTitle, strTest);	//*****This does work.*****
	//	if((MST.WStaticExists(aTitle))==TRUE){  // *****THIS SHOULD WORK!!!!*****
		if(bTest==TRUE){
			// "The search failed." warning dialog has appeared.  This TestCase Failed.
			iCounter=1;
			m_pLog->Comment("Search for '" + aString + "' Failed!!");
			DoKeys("{ENTER}");  //  Clear the "Search Failed." warning dialog.
			DoKeys("{ESC}");	//	Clear the "Search" dialog.
		}
		else{
			// "No Topic Found." warning dialog has appeared.
			// Verify that this is expected behavior.
			if(iVerify==0){
				//  This is not expected behavior.  This TestCase Failed..
				iCounter=1;
				m_pLog->Comment("Search for '" + aString + "' resulted in an unexpected 'No Topic Found.' warning dialog!!");
			}
			DoKeys("{ENTER}");  //  Clear the "No Topic Found." warning dialog.
			DoKeys("{ESC}");	//	Clear the "Search" dialog.
		}

	}

	return(iCounter);
};  // End VerifySearch()
 

void CFTS::InitalCases(struct FTS_CASES *ptTestCases)
{

ptTestCases[0].iSearchString  = IDS_FTS_SEARCH1;
ptTestCases[1].iSearchString  = IDS_FTS_SEARCH2;
ptTestCases[2].iSearchString  = IDS_FTS_SEARCH3;
ptTestCases[3].iSearchString  = IDS_FTS_SEARCH4;
ptTestCases[4].iSearchString  = IDS_FTS_SEARCH5;
ptTestCases[5].iSearchString  = IDS_FTS_SEARCH6;
ptTestCases[6].iSearchString  = IDS_FTS_SEARCH7;

ptTestCases[0].iVerificationString  = 0;
ptTestCases[1].iVerificationString  = 0;
ptTestCases[2].iVerificationString  = 1;	// 1 means that this search should not find any topic.
ptTestCases[3].iVerificationString  = 0;
ptTestCases[4].iVerificationString  = 0;
ptTestCases[5].iVerificationString  = 0;
ptTestCases[6].iVerificationString  = 1;	// 1 means that this search should not find any topic.


};	// End InitalCases();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  SNIFF.CPP
//
//  Created by :                    Date :
//		MarcI & DougMan					1/1/97
//
//  Description :
//      Implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"
#include "f1lookup.h"
#include "dlgwalk.h"
#include "FTS.h"

#include "Generic.h"


#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "InfoViewer Sniff Test", "DougMan x39440, MarcI x36051")

BEGIN_TESTLIST(CSniffDriver)
//	TEST(CF1Lookup,((CMDLINE->GetTextValue("Test","")=="") || (CMDLINE->GetTextValue("Test","").Find("APPWIZ")!=(-1))) || (CMDLINE->GetBooleanValue("runall"))? RUN : DONTRUN)
	TEST(CDlgWalk, RUN)
	TEST(CFTS, RUN)
	TEST(CF1Lookup, RUN)

//	TEST(CGeneric, RUN)
END_TESTLIST()

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}

void CSniffDriver::CleanUp(void)
{
	// close all windows
	UIWB.CloseAllWindows();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\menutest\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ivrsc.rc
//
#define IDS_F1LOOKUP_SOMEHITS           1
#define IDS_SURROUND_TEXT1              9
#define IDS_SURROUND_TEXT2              10
#define IDS_F1LOOKUP_NOHITS             11
#define IDS_F1LOOKUP_ONEHIT             12
#define IDS_FTS_SEARCH1                 15
#define IDS_FTS_SEARCH2                 16
#define IDS_FTS_SEARCH3                 17
#define IDS_FTS_SEARCH4                 18
#define IDS_FTS_SEARCH5                 19
#define IDS_FTS_SEARCH6                 20
#define IDS_FTS_SEARCH7                 21

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\menutest\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\InfoView\src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//  Created by :                    Date :
//		MarcI & DougMan					1/1/97
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST()

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\menutest\Src\menusub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Menucase.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CMenuTesterSubSuite class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "Menusub.h"

#include "Menucase.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// The CMenuTesterSubSuite object

IMPLEMENT_SUBSUITE(CMenuTesterSubSuite, CIDESubSuite, "OpenClose & Menus sniff", "ChrisKoz")

BEGIN_TESTLIST(CMenuTesterSubSuite)
	brunmenus=m_SuiteParams->GetBooleanValue("RUNMENUS", TRUE);
	TEST(CMenuTesterIDETest, RUN)
		pTest->SetName(brunmenus?"Test Menus":"Empty");
END_TESTLIST()


void CMenuTesterSubSuite::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\menutest\Src\menusub.h ===
///////////////////////////////////////////////////////////////////////////////
//	Menusub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CMenuTesterSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__
			 
#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CMenuTesterSubSuite class

class CMenuTesterSubSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CMenuTesterSubSuite)

	DECLARE_TESTLIST();

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	BOOL brunmenus;
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\menutest\Src\menucase.h ===
///////////////////////////////////////////////////////////////////////////////
//	Menucase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CMenuTesterIDETest Class
//

#ifndef __MENCASES_H__
#define __MENCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#include "Menusub.h"

///////////////////////////////////////////////////////////////////////////////
//	CMenuTesterIDETest class

class CMenuTesterIDETest : public CTest
{
    DECLARE_TEST(CMenuTesterIDETest, CMenuTesterSubSuite)

// Operations
public:
	virtual void Run(void);

// Data
protected:

// Test Cases
protected:
  	void TestCase1( );

};

#endif //__MENCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Bin\projects\x86\layout.c ===
#include "conio.h"


void main()
{
	int c = 1;
	c = _getch();
	c = 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\grdcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	GRDCASES.H
//
//	Created by :			Date :
//		MikePie					4/13/95
//
//	Description :
//		Declaration of the CGrdTestCases class
//

#ifndef __GRDCASES_H__
#define __GRDCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CGrdTestCases class

class CGrdTestCases : public CTest
{
	DECLARE_TEST(CGrdTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:

// Test Cases
protected:
	BOOL AddToGrid(void);
	BOOL ReorderGrid(void);
	BOOL ReopenGrid(void);
	BOOL CheckMBC(void);
	BOOL CloseGrid(void);
};

#endif //__GRDCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\menutest\Src\menucase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Menucase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		Cycles Through Menus		 

#include "stdafx.h"
#include "Menucase.h"					 	 
											   
#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CMenuTesterIDETest, CTest, NULL, -1, CMenuTesterSubSuite)
												 
#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

void CMenuTesterIDETest::Run(void)
{

TestCase1( );

}


void CMenuTesterIDETest::TestCase1( )
{

	if(GetSubSuite()->brunmenus==FALSE)
	{
		m_pLog->RecordInfo("No menu exercises");
		return;
	}
	m_pLog->RecordInfo("Starting menu exerciser");

	//Put focus on menu
	MST.DoKeys("%F{ESC}");

	//Drop down first menu
	MST.DoKeys("{DOWN}");

	//Cycle through 13 menus 20 times 
	for (int nCycle = 0; nCycle < 260; nCycle++)
		MST.DoKeys("{RIGHT}");

	//Take focus off menu
	MST.DoKeys("{ALT}");

	m_pLog->RecordInfo("Done with menu exerciser");

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\grdcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      GRDCASES.CPP
//
//      Created by :                Date :
//              MikePie               4/13/95
//
//      Description :
//              Implementation of the CGrdTestCases class
//
//              Repaired / Modified by:         Date:                   Description:
//                              MikePie                           5/01/95                  Fixed non-graceful exit of last munged test
//
//              Repaired / Modified by:         Date:                   Description:
//                              ejugovic                          5/29/96                  Fixed compare to CWD while adding entries
///////////////////////////////////////////////////////////////////////////////
//
#include "stdafx.h"
#include "grdcases.h"
#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// CString MBCEntry = "GRIDTESTA`\";
CString MBCEntry = "GRIDTEST_MBC_Disabled";

IMPLEMENT_TEST(CGrdTestCases, CTest, "Grid Control Tests", -1, CSniffDriver)

void CGrdTestCases::Run(void)
{
	XSAFETY;
	Sleep(2000);
	EXPECT(AddToGrid());
	EXPECT(ReorderGrid());
	EXPECT(ReopenGrid());
	EXPECT(CheckMBC());
	EXPECT(CloseGrid());
}


///////////////////////////////////////////////////////////////////////////////
//      Test Cases
///////////////////////////////////////////////////////////////////////////////
//
BOOL CGrdTestCases::AddToGrid(void)
{
	m_pLog->RecordInfo("Opening grid control in Tools.Options.Directories...");
	UIOptionsTabDlg uioptdlg;
	uioptdlg.Display();

	uioptdlg.AddDirectory("GRIDTEST1");
	MST.DoKeys("{DOWN}");
	Sleep(500);

	DWORD sysinfo = (DWORD) GetSystem();
	if ((sysinfo & SYSTEM_DBCS) || (sysinfo & SYSTEM_JAPAN))
	{
		m_pLog->RecordInfo("Adding false direcory (%s) to grid...",MBCEntry);
		uioptdlg.AddDirectory(MBCEntry);
	}
	else
	{
		m_pLog->RecordInfo("Adding false direcory (GRIDTEST2) to grid...");
		uioptdlg.AddDirectory("GRIDTEST1" ) ;
	}
	MST.DoKeys("{ENTER}");  // Hit Enter
	Sleep(500);
	MST.DoKeys("{TAB}");    // Tab to yes
	MST.DoKeys("{ENTER}");
	Sleep(800);
	MST.DoKeys("{DOWN}");
	Sleep(500); 

	CString GridEntry;      
	m_pLog->RecordInfo("Adding currrent directory (%s) to grid...",m_strCWD);
    MST.DoKeys(m_strCWD);       // Enter the current working directory
	MST.DoKeys("{ENTER}");  // Hit Enter
	Sleep(600);
	MST.DoKeys("{UP}");             // Go back up to the new entry
	EmptyClip();                    // Empty the clipboard--we're going to do a compare...

	m_pLog->RecordInfo("Copying grid entry text to clipboard...");
//	MST.DoKeys("^(C)");             // Ctrl-C:Copy the new entry into clipboard     
	UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);
	Sleep(600);
	MST.DoKeys("{ESC}");    // Get out of edit mode
	Sleep(600);

	m_pLog->RecordInfo("Getting clipped text from clipboard...");
	GetClipText(GridEntry); // Get the grid entry out of the clipboard

// workaround for grid control problem in retail IDE (06/07/96)
	if (GridEntry[GridEntry.GetLength() - 1] != '\\')	// check for existing backslash
		GridEntry += "\\";								// need to append backslash to match CWD

	if (GridEntry == m_strCWD)
	{
		m_pLog->RecordInfo("Got current directory from grid...");
		return TRUE;
	}
	else
	{
		m_pLog->RecordInfo("Expected (%s), got (%s).",m_strCWD,GridEntry);
		return FALSE;
	}                               
}

 
BOOL CGrdTestCases::ReorderGrid(void)
{
	m_pLog->RecordInfo("Moving last entry to top...");
	MST.DoKeys("{END}");    // Move to bottom of list
	MST.DoKeys("{UP}");             // Move up one - this should be CWD
//	MST.DoKeys("^(X)");             // Ctrl-X:Get the last entry and put it in clipboard
	UIWB.DoCommand(ID_EDIT_CUT, DC_ACCEL);
	Sleep(600);
	MST.DoKeys("{ESC}");
//	MST.DoKeys("{DEL}");
	UIWB.DoCommand(ID_EDIT_CLEAR, DC_ACCEL);
	Sleep(600);

	m_pLog->RecordInfo("Moving to top of grid...");
	MST.DoKeys("{HOME}");   // Go to top of list
	Sleep(600);
//	MST.DoKeys("^(V)");             // Ctrl-V:Paste
	UIWB.DoCommand(ID_EDIT_PASTE, DC_ACCEL);
	MST.DoKeys("{ENTER}");

	CString GridEntry;
	EmptyClip();                    // Empty clipboard
//	MST.DoKeys("^(C)");
	UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);
	MST.DoKeys("{ENTER}");
	GetClipText(GridEntry);

// workaround for grid control problem in retail IDE (06/07/96)
	if (GridEntry[GridEntry.GetLength() - 1] != '\\')	// check for existing backslash
		GridEntry += "\\";								// need to append backslash to match CWD

	if (GridEntry == m_strCWD)
	{
		m_pLog->RecordInfo("Reorder successful.");
		return TRUE;
	}
	else
	{
		m_pLog->RecordInfo("Got (%s), but expected (%s).",GridEntry,m_strCWD);
		return FALSE;
	}
}


BOOL CGrdTestCases::ReopenGrid(void)
{
	m_pLog->RecordInfo("Closing grid...");
	MST.DoKeys("{ENTER}");
	Sleep(1000);

	m_pLog->RecordInfo("Opening grid control...");
	UIOptionsTabDlg uioptdlg;
	uioptdlg.ShowDirectoryTab();
/*
	MST.DoKeys("%(TO)");			// Tools.Options
	Sleep(1000);					// Wait for dialog to open

//	REVIEW: This no longer works with the new focus 
//	(there's a better way to do it anyway) CHRISSH
	MST.DoKeys("C");				// Go to Compatibility tab before
	Sleep(200);                     // going to Directories tab. This is the only
	MST.DoKeys("D");                // way we can be sure we are getting the Directories
	Sleep(200);						// tab and not the Debug tab.
	MST.DoKeys("%(D)");             // Tab to Directories 
	Sleep(200);
*/
	MST.DoKeys("{HOME}");			// Go to top of grid                    
	Sleep(200);

	CString GridEntry;
	EmptyClip();                    // Empty clipboard
//	MST.DoKeys("^(C)");
	UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);
	MST.DoKeys("{ENTER}");
	Sleep(600);
	GetClipText(GridEntry);

// workaround for grid control problem in retail IDE (06/07/96)
	if (GridEntry[GridEntry.GetLength() - 1] != '\\')	// check for existing backslash
		GridEntry += "\\";              // need to append backslash to match CWD

	if (GridEntry == m_strCWD)
	{
		m_pLog->RecordInfo("Reopen successful.");
		return TRUE;
	}
	else
	{
		m_pLog->RecordInfo("Got (%s), but expected (%s).",GridEntry,m_strCWD);
		return FALSE;
	}

}


BOOL CGrdTestCases::CheckMBC(void)
{

	DWORD sysinfo = (DWORD) GetSystem();

	if ((sysinfo & SYSTEM_DBCS) || (sysinfo & SYSTEM_JAPAN))
	{
		MST.DoKeys("{END}");
		MST.DoKeys("{UP}");

		CString GridEntry;
		EmptyClip();                    // Empty clipboard
//		MST.DoKeys("^(C)");             //
		UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);
		MST.DoKeys("{ESC}");    //
		Sleep(1000);
		GetClipText(GridEntry);
		GridEntry.MakeUpper();
		MBCEntry = m_strCWD + MBCEntry;
		MBCEntry.MakeUpper();
		if (GridEntry == MBCEntry)
		{
			m_pLog->RecordInfo("Got MBC entry expected.");
			return TRUE;
		}
		else
		{
			MST.DoKeys("{ESC}");
//			MST.DoKeys("^({F4})");
			UIWB.DoCommand(ID_FILE_CLOSE, DC_ACCEL);
			m_pLog->RecordInfo("Expected (%s), but got (%s) instead.",MBCEntry,GridEntry);
			return FALSE;
		}
	}
	else
	{
		m_pLog->RecordInfo("Not an MBC system. Continuing test...");
		return TRUE;
	}
}

BOOL CGrdTestCases::CloseGrid(void)
{
	MST.DoKeys("{END}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("{ENTER}");
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\lfncases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      LFNCASES.CPP
//
//      Created by :                    Date :
//              MikePie                                 3/29/95
//
//      Description :
//              Implementation of the CTBTestCases class
///////////////////////////////////////////////////////////////////////////////
//
#include "stdafx.h"
#include "lfncases.h"


#define new DEBUG_NEW
#undef THIS_FILE


static char BASED_CODE THIS_FILE[] = __FILE__;
CString testfile;
CString testfileMST;
CString delfile;


IMPLEMENT_TEST(CLfnTestCases, CTest, "Long Filename Tests", -1, CSniffDriver)


void CLfnTestCases::Run(void)
{
	XSAFETY;
	DetectLanguage();
	DeleteOldFile();
	CreateLongFilename();
	OpenLongFilename();  
	DeleteNewFile();
}


///////////////////////////////////////////////////////////////////////////////
//      Test Cases
///////////////////////////////////////////////////////////////////////////////
//
BOOL CLfnTestCases::DetectLanguage(void)
{
	DWORD sysinfo = (DWORD) GetSystem();

	testfile = "LfnTest!&().EXT";
	testfileMST = "LfnTest!&{(}{)}.EXT";
	delfile = testfile;
/*
	if (sysinfo & SYSTEM_NT)
	{
		m_pLog->RecordInfo("According to GetSystem, this is NT.");
		testfile = "LfnTest!&().EXT";
		testfileMST = "LfnTest!&{(}{)}.EXT";
		delfile = testfile;
	}
	if (sysinfo & SYSTEM_CHICAGO)
	{
		m_pLog->RecordInfo("According to GetSystem, this is Windows95");
		testfile = "Lfn Test!&().EXT";
		testfileMST = "Lfn Test!&{(}{)}.EXT";
		delfile=testfile;
	}
	if (sysinfo & SYSTEM_DBCS)
	{
		m_pLog->RecordInfo("According to GetSystem, this is multibyte-enabled.");
		testfile = "Lfn Test!&A.extZ";
		testfileMST = "Lfn Test!&(A)().ext(Z)";
		delfile = testfile;
	}
	if (sysinfo & SYSTEM_JAPAN)
	{
		m_pLog->RecordInfo("According to GetSystem, this is Japanese.");
		testfile = "Lfn Test!&A.extZ";
		testfileMST = "Lfn Test!&(A)().ext(Z)";
		delfile = testfile;
	}
*/		 
		return TRUE;
}


BOOL CLfnTestCases::DeleteOldFile(void)
{
	m_pLog->RecordInfo("Clearing out existing instance of file, if any...");
	m_pLog->RecordInfo("   Trying to use path %s...",m_strCWD);
	m_pLog->RecordInfo("   Trying to remove file %s...",testfile);
	KillFile(m_strCWD,delfile);

	return TRUE;
}


BOOL CLfnTestCases::CreateLongFilename(void)
{
	COSource sourc;
	m_pLog->RecordInfo("Creating long filename...");
    
	sourc.Create(); // New source file.
	MST.DoKeys("{ENTER}");          
	MST.DoKeys("This is a test file.");
//	MST.DoKeys("%(FA)");
	UIWB.DoCommand(ID_FILE_SAVE_AS, DC_MNEMONIC);
	MST.DoKeys(m_strCWD + testfileMST);
	MST.DoKeys("{ENTER}");
//	MST.DoKeys("%(FC)");
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	return TRUE;
}


BOOL CLfnTestCases::OpenLongFilename(void)
{
	COSource sourc;
	m_pLog->RecordInfo("Opening long filename...");

	if (sourc.Open(m_strCWD + testfile))
	{
//		MST.DoKeys("%(FC)");
		UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


BOOL CLfnTestCases::DeleteNewFile(void)
{
	m_pLog->RecordInfo("Cleaning up...");
	m_pLog->RecordInfo("   Trying to use path %s...",m_strCWD);
	m_pLog->RecordInfo("   Trying to remove file %s...",testfile);
	KillFile(m_strCWD,delfile);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\lfncases.h ===
///////////////////////////////////////////////////////////////////////////////
//	LFNCASES.H
//
//	Created by :			Date :
//		MikePie					3/29/95
//
//	Description :
//		Declaration of the CTBTestCases class
//

#ifndef __LFNCASES_H__
#define __LFNCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CLfnTestCases class

class CLfnTestCases : public CTest
{
	DECLARE_TEST(CLfnTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:

// Test Cases
protected:
	BOOL DetectLanguage(void);
	BOOL DeleteOldFile(void);
	BOOL CreateLongFilename(void);  
	BOOL OpenLongFilename(void);  
	BOOL DeleteNewFile(void);
};

#endif //__LFNCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\lytcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	LYTCASES.H
//
//	Created by :			Date :
//		Enriquep					10/25/93
//
//	Description :
//		Declaration of the CLytTestCases class
//

#ifndef __LYTCASES_H__
#define __LYTCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CCusTestCases class

class CLytTestCases : public CTest
{
	DECLARE_TEST(CLytTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:
	CString m_strCWD;		// the test's current working directory

// Test Cases
protected:
	BOOL DesignModeLyt(void);
	BOOL DebugModeLyt(void);
};


///////////////////////////////////////////////////////////////////////////////
// CTabTestCases class

class CTabTestCases : public CTest
{
	DECLARE_TEST(CTabTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);
};

#endif //__LYTCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		RickKr					8/27/93
//
//	Description :
//		implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "grdcases.h"
#include "lfncases.h"
#include "lytcases.h"
#include "tb_cases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "VShell sniff test", "Ernest Jugovic x31522")

BEGIN_TESTLIST(CSniffDriver)
//	TEST(CLytTestCases, RUN)
    TEST(CLfnTestCases, RUN)
	TEST(CTabTestCases, RUN)
	TEST(CTBTestCases, RUN)
	TEST(CGrdTestCases, DONTRUN)
END_TESTLIST()

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\lytcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	LYTCASES.CPP
//
//	Created by :			Date :
//		Enriquep					10/25/93
//
//	Description :
//		Dockable views and toolbars layout tests (Design and Debug Modes)
//

#include "stdafx.h"
#include "lytcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CLytTestCases, CTest, "Layout Tests", -1, CSniffDriver)

void CLytTestCases::Run(void)
{
	// get the current working directory for this test
	::GetCurrentDirectory(MAX_PATH, m_strCWD.GetBuffer(MAX_PATH));
	m_strCWD.ReleaseBuffer();
	m_strCWD += '\\';

	XSAFETY;
	DesignModeLyt();
	DebugModeLyt();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CLytTestCases::DesignModeLyt(void)
{
	BOOL bResult = TRUE;   // Flag used to indicate if test passed. TRUE == PASSED

	COProject proj;

	// Open an internal makefile according to platform being tested

#ifdef _X86_
        proj.Open(m_strCWD + "projects\\x86\\layout.mak");
#else
#ifdef _MIPS_
		proj.Open(m_strCWD + "projects\\mips\\layout.mak");
#endif
#endif

	//Check Standard toolbar is docked on upper border
	if( !WS.IsToolbarDocked(IDTB_SUSHI_STANDARD, DW_TOP) )
	{
		m_pLog->Comment("(1) Standard Toolbar should be docked on upper border");	
		bResult = FALSE;
	}


	// Check Resource Toolbar isn't docked
    if ( !WS.IsToolbarVisible(IDTB_VRES_RESOURCE) )
	{
        m_pLog->Comment("(1) Resource Toolbar is not visible");
		bResult = FALSE;
	}			
	if( WS.IsToolbarDocked(IDTB_VRES_RESOURCE, DW_DONT_CARE) )
	{
		m_pLog->Comment("(1) Resource Toolbar should not be docked");	
		bResult = FALSE;
	}

	// Check Output Window
	if (!WS.IsDockWindowVisible(IDW_OUTPUT_WIN) )
	{
        m_pLog->Comment("(1) Output Window is not visible");
		bResult = FALSE;
	}	 
	if( WS.IsWindowDocked(IDW_OUTPUT_WIN, DW_DONT_CARE) )
	{
		m_pLog->Comment("(1) Output Window should not be docked");	
		bResult = FALSE;
	}


	if (bResult == FALSE)
	{
		m_pLog->RecordFailure("(1) Initial Design Mode Layout");
		return FALSE;
	}	
    
    m_pLog->RecordInfo("(1) Initial Design Mode Layout passed");

	return TRUE;
}


BOOL CLytTestCases::DebugModeLyt(void)
{
	UIWB.StepInto(3000);

	UIWBMessageBox mbAlert;
	while( mbAlert.WaitAttachActive(1000) )	// dismiss any alerts that comes up
	{
		if (mbAlert.ButtonExists(MSG_NO))
			mbAlert.ButtonClick(MSG_NO);
		else
			mbAlert.ButtonClick();	
	}					


	// Verify Design mode toolbars aren't visible when in Debug mode. Output Window is still visible.

	int nSleep = 0;
	while ( ((WS.IsToolbarVisible(IDTB_VRES_RESOURCE)) || 
			(!WS.IsDockWindowVisible(IDW_OUTPUT_WIN))) &&
			(nSleep++ < 30) )
		Sleep(1000);

	if ( (WS.IsToolbarVisible(IDTB_VRES_RESOURCE)) || (!WS.IsDockWindowVisible(IDW_OUTPUT_WIN)) )
	{
		m_pLog->RecordFailure("(1) Initial Debug Mode Layout:Design Mode toolbars are still visible");

		UIWB.StopDebugging();	  // Exit Debug mode
		
		return FALSE;
	}

	// Check Debug windows are present

	BOOL bResult = TRUE;	 		// Flag used to indicate pass or failure of test. TRUE == PASS
	
	//  **** Check Debug Toolbar
	if(!WS.IsToolbarVisible(IDTB_VCPP_DEBUG))
	{
		m_pLog->Comment("(2) Debug Toolbar is not visible");
		bResult = FALSE;
	}

	if ( !WS.IsWindowDocked(IDTB_VCPP_DEBUG, DW_RIGHT) )
	{
        m_pLog->Comment("(2) Debug Toolbar should be docked on right border");
		bResult = FALSE;
	}

	//  **** Check Watch window
	if(!WS.IsDockWindowVisible(IDW_WATCH_WIN))
	{
		m_pLog->Comment("(2) Watch window is not visible");
		bResult = FALSE;
	}

	if ( WS.IsWindowDocked(IDW_WATCH_WIN, DW_DONT_CARE) )
	{
        m_pLog->Comment("(2) Watch window should not be docked");
		bResult = FALSE;
	}
	
	//  **** Check Memory window
	if(!WS.IsDockWindowVisible(IDW_MEMORY_WIN))
	{
		m_pLog->Comment("(2) Memory window is not visible");
		bResult = FALSE;
	}
	
	if ( WS.IsWindowDocked(IDW_MEMORY_WIN, DW_DONT_CARE) )
	{
        m_pLog->Comment("(2) Memory window should not be docked");
		bResult = FALSE;
	}
	
	//  **** Check Locals window
	if(!WS.IsDockWindowVisible(IDW_LOCALS_WIN))
	{
		m_pLog->Comment("(2) Locals window is not visible");
		bResult = FALSE;
	}

	if ( !WS.IsWindowDocked(IDW_LOCALS_WIN, DW_BOTTOM) )
	{
        m_pLog->Comment("(2) Locals window should be docked on bottom");
		bResult = FALSE;
	}

	//  **** Check Registers window
	if(!WS.IsDockWindowVisible(IDW_CPU_WIN))
	{
		m_pLog->Comment("(2) Registers window is not visible");
		bResult = FALSE;
	}

	if ( !WS.IsWindowDocked(IDW_CPU_WIN, DW_BOTTOM) )
	{
        m_pLog->Comment("(2) Registers window should be docked on bottom");
		bResult = FALSE;
	}


	//  **** Check Call Stack window
	if(!WS.IsDockWindowVisible(IDW_CALLS_WIN))
	{
		m_pLog->Comment("(2) Call Stack window is not visible");
		bResult = FALSE;
	}

	if ( !WS.IsWindowDocked(IDW_CALLS_WIN, DW_BOTTOM) )
	{
        m_pLog->Comment("(2) Call Stack window should be docked on bottom");
		bResult = FALSE;
	}

	if (bResult == FALSE)
	{
		m_pLog->RecordFailure("(2) Initial Debug Mode Layout");
		UIWB.StopDebugging();	  // Exit Debug mode
	}	

	m_pLog->RecordInfo("(2) Initial Debug Mode Layout passed");

	UIWB.StopDebugging();	  // Exit Debug mode
	
	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CTabTestCases class

IMPLEMENT_TEST(CTabTestCases, CTest, "Tab Dialog Tests", -1, CSniffDriver)

void CTabTestCases::Run(void)
{
	UIOptionsTabDlg uiOptDlg;
	uiOptDlg.Display();		   
	uiOptDlg.ShowPage(TAB_WORKSPACE, 8);
	int k = 0;
	for (int i=1; i < 8; i++)
	{
		if (i % 2 == 0)
		{
			for(k = 1; k <= i; k++)
			{
				uiOptDlg.ActivateNextPage();
			}
		}
		else
		{
			for(k = 1; k <= i; k++)
			{
				uiOptDlg.ActivateNextPage(FALSE);
			}
		}
		
	}  	

	MST.WButtonClick(GetLabel(IDOK) );		 //Close Dialog	  REVIEW(Enriquep): Use uiOptDlg.OK() function

	m_pLog->RecordInfo("(3) Tabbed thru Options Dialog without problems");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		RickKr					8/27/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST()

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\tb_cases.h ===
///////////////////////////////////////////////////////////////////////////////
//	TB_CASES.H
//
//	Created by :			Date :
//		Enriquep					9/3/93
//
//	Description :
//		Declaration of the CTBTestCases class
//

#ifndef __TB_CASES_H__
#define __TB_CASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CTBTestCases class

class CTBTestCases : public CTest
{
	DECLARE_TEST(CTBTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:

// Test Cases
protected:
	BOOL ViewToolbars(void);
	BOOL HideToolbar(void);
	BOOL ShowToolbar(void);
	BOOL NewToolbar(void);
	BOOL AddButton(void);
	BOOL NewTB(void);
};

#endif //__TB_CASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/27/93
//
//	Description :
//		Precompiled header for the Shell Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>
#include "..\..\..\..\src\support\guitools\ide\sym\reg.h"

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\ActiveXControlInDialog\ActiveXControlInDialogCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	ActiveXControlInDialogCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CActiveXControlInDialogCase class

#ifndef __ActiveXControlInDialogCase_H__
#define __ActiveXControlInDialogCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "ActiveXControlInDialogSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CActiveXControlInDialogCase class

class CActiveXControlInDialogCase : public CSystemTestSet
{
	DECLARE_TEST(CActiveXControlInDialogCase, CActiveXControlInDialogSubsuite)

// Operations
public:
	void OpenMainProject(void);
	void AddControlFromGallery(void);
	void DropControlsToDialog(void);
	void BuildProject(void);
	void DebugProject(void);
//overides
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__ActiveXControlInDialogCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Shell\Sniff\Src\tb_cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	TB_CASES.CPP
//
//	Created by :			Date :
//		Enriquep					9/3/93
//
//	Description :
//		Implementation of the CTBTestCases class
//

#include "stdafx.h"
#include "tb_cases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CTBTestCases, CTest, "Toolbar Tests", -1, CSniffDriver)

void CTBTestCases::Run(void)
{
	XSAFETY;
	ViewToolbars();
	HideToolbar();
	ShowToolbar();
	NewToolbar();
	AddButton();
	NewTB();  

	// Close the toolbars and any open text windows
	WS.ShowToolbar(IDTB_VCPP_DEBUG, FALSE);

	// Select the last item in the list
	int nCount = MST.WListCount(GetLabel(0x5018));
	MST.WListItemClk(GetLabel(0x5018), nCount);
	Sleep(1000);
	
	if (MST.WButtonEnabled(GetLabel(0x5019))) {
		// Click the Delete button twice to remove the custom toolbars we created
		MST.WButtonClick(GetLabel(0x5019));
		MST.WButtonClick(GetLabel(0x5019));
	}
	else {
		m_pLog->RecordFailure("Delete button not enabled on Toolbar dialog.");
	}

	// Click the Close button on the Customize dialog
	MST.WButtonClick(GetLabel(1));

	WS.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

BOOL CTBTestCases::ViewToolbars(void)
{
	UIToolbar uTB;

	if (!uTB.DisplayTBDlg())
	{
		m_pLog->RecordFailure("(1) View toolbars");
		return FALSE;
	} 
	return TRUE;
}


BOOL CTBTestCases::HideToolbar(void)
{
	if (!WS.ShowToolbar(IDTB_SUSHI_STANDARD, FALSE) )
	{
		m_pLog->RecordFailure("(2) Hide Toolbar");
		return FALSE;
	} 
	return TRUE;
}


BOOL CTBTestCases::ShowToolbar(void)
{
	if (!WS.ShowToolbar(IDTB_VCPP_DEBUG, TRUE) )
	{
		m_pLog->RecordFailure("(3) Show Toolbar");
		return FALSE;
	}
	return TRUE;
}

BOOL CTBTestCases::NewToolbar(void)
{
	UIToolbar uTB;

	uTB.DisplayTBDlg();
		
	MST.WButtonClick(GetLabel(VSHELL_IDC_NEW));

#ifdef _M_ALPHA
    Sleep(1000); // Slow it down so the dlg has a chance to appear
#endif

	EXPECT(MST.WFndWndWait(GetLocString(IDSS_NEW_TB_TITLE), FW_PART, 1) != 0);	// Wait for New Toolbar Dialog
   
	MST.DoKeys("Cool TB");						// Name new toolbar
	MST.WButtonClick(GetLabel(IDOK));
	
	EXPECT(MST.WFndWndWait(GetLocString(IDSS_CUSTOMIZE_TITLE), FW_PART, 1) != 0);	// Wait for Customize Dialog
		
	HWND hTB = UIWB.GetToolbar(IDTB_CUSTOM_BASE + 1,PACKAGE_SUSHI);
	EXPECT(hTB != NULL);
   
	if (!IsWindowVisible(hTB))
	{
		m_pLog->RecordFailure("(4) New Toolbar");
		return FALSE;
	}

	return TRUE;
}

BOOL CTBTestCases::AddButton(void)
{
	UICustomizeTabDlg uiCustDlg;
	uiCustDlg.Display();
	HWND hTB = UIWB.GetToolbar(IDTB_CUSTOM_BASE + 1,PACKAGE_SUSHI);
	EXPECT( hTB != NULL );
	
	uiCustDlg.AddTBButton(1, hTB);	 // REVIEW: first parameter is ignored
	MST.WButtonClick(GetLabel(IDOK)); 		// Close dialog
	ClickMouse(VK_LBUTTON, hTB, 10, 10);		// Click on toolbar button
	
	if (MST.WFndWndWait(GetLocString(IDSS_NEW_TITLE), FW_PART, 10) == 0)
	{
		m_pLog->RecordFailure("(5) Add Button");
		return FALSE;
	}
	MST.WButtonClick(GetLabel(IDCANCEL));

	return TRUE;					 
}


BOOL CTBTestCases::NewTB(void)
{
	UICustomizeTabDlg uiCustDlg;
	uiCustDlg.Display();
	uiCustDlg.AddTBButton(1);	 // REVIEW: first parameter is ignored

	HWND hTB = UIWB.GetToolbar(IDTB_CUSTOM_BASE + 2,PACKAGE_SUSHI);
	MST.WButtonClick(GetLabel(IDOK)); 		// Close Toolbar dialog
	EXPECT( hTB != NULL );

	if (!IsWindowVisible(hTB))
	{
		m_pLog->RecordFailure("(6) New Toolbar via Customize Dlg");
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\ActiveXControlInDialog\ActiveXControlInDialogSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ActiveXControlInDialogSubSuitee.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CActiveXControlInDialogSubSuitee class
//

#include "stdafx.h"
#include "ActiveXControlInDialogSubSuite.h"
#include "afxdllx.h"

#include "ActiveXControlInDialogCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CActiveXControlInDialogSubsuite, CIDESubSuite, "ActiveX Control In Dialog", "VCQA")

BEGIN_TESTLIST(CActiveXControlInDialogSubsuite)
	TEST(CActiveXControlInDialogCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\sysset.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SYSSET.CPP
//
//	Created by :			Date :
//		YefimS					5/19/97
//
//	Description :
//		Definition of base class containing common data and methods for all
//		System Test Sets.

#include "stdafx.h"
#include "SYSSET.h"
#include "guitarg.h"
//#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

IMPLEMENT_DYNAMIC(CSystemTestSet, CTest)

int ReturnCode =0;

CSystemTestSet::CSystemTestSet(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: CTest(pSubSuite, szName, nExpectedCompares, szListFilename)
{
	if(GetSystem() & SYSTEM_DBCS)
	{//REVIEW(chriskoz): note doubled character '\' - compiler treats it as ESC sequence
		// TODO(michma - 12/9/97): all disabled mbcs names are due to bug 2116.
		m_strWorkspaceName = "[\\]^{|}Aa`@~ AppWiz App";
		m_strAppProjName = m_strWorkspaceName;
		m_strAppClassName = "CMyAppWizAppApp";	 // not sure it is correct
		m_strMenuName = "[\\]^{|}Aa`@~ Test";
		m_strMenuItemName = "[\\]^{|}Aa`@~ TestDialog";
		m_strAppResourceID = "IDR_APPWIZTYPE";
		m_strHTMLPageName = "[\\]^{|}Aa`@~ HTML Page.htm";
		// TODO(michma): what is this for japanese?
		//m_strActiveXControlProjName = "[\\]^{|}Aa`@~ ActiveX Control";
		m_strActiveXControlProjName = "ActiveX Control";
		m_strActiveXControlName = "ActiveXControl";
		// TODO(michma): what is this for japanese?
		m_strActiveXControlViewClass = "";
		//m_strATLCOMServerProjName = "[\\]^{|}Aa`@~ ATL COM Server";
		m_strATLCOMServerProjName = "ATL COM Server";
		// are any of these allowed to contain mbcs characters?
		m_strATLCOMServerInterface = "ATLCOMServerInterface";
		m_strATLCOMServerClsID = "CLSID_ATLCOMServerInterface";
		m_strATLCOMServerIID = "IID_IATLCOMServerInterface";
	}
	else
	{ //REVIEW(chriskoz) do we want to have some upper ASCII on german system
		m_strWorkspaceName = "AppWiz App";
		m_strAppProjName = m_strWorkspaceName;
		m_strAppClassName = "CAppWizAppApp";
		m_strMenuName = "Test";
		m_strMenuItemName = "TestDialog";
		m_strAppResourceID = "IDR_APPWIZTYPE";
		m_strHTMLPageName = "HTML Page.htm";
		m_strActiveXControlProjName = "ActiveX Control";
		m_strActiveXControlName = "ActiveXControl";
		m_strActiveXControlViewClass = "CActiveXControlCtrl";
		m_strATLCOMServerProjName = "ATL COM Server";
		m_strATLCOMServerInterface = "ATLCOMServerInterface";
		m_strATLCOMServerClsID = "CLSID_ATLCOMServerInterface";
		m_strATLCOMServerIID = "IID_IATLCOMServerInterface";
	}

	// REIVEW(michma): do we want a localized name for "apps" too?
	m_strAppsRoot = "apps";
	m_strWorkspaceLoc = m_strAppsRoot + "\\" + m_strWorkspaceName + "\\";
	m_strHTMLPageRelPath = m_strWorkspaceLoc + m_strActiveXControlProjName + "\\" + m_strHTMLPageName;
}

void CSystemTestSet::RemoveTestFiles( CString szProjLoc )
{
	KillAllFiles( szProjLoc );
}
	
BOOL CSystemTestSet::TouchFile( CString szFileName )
{
	if ( _utime( szFileName, NULL ) == -1 ) {
		return FALSE;
	}
	return TRUE;
}

time_t CSystemTestSet::GetFileTime( CString szFileName )
{
	struct _stat buf;
	int result = _stat( szFileName, &buf );
	return( buf.st_mtime );
}

BOOL CSystemTestSet::SetToolsDir(CString szToolsLoc)
{
//	Set build tools directory to point to dummy build tools (which
//	must be provided by us)

	COEnvironment OptionsDirectories;
	
	if ( !VERIFY_TEST_SUCCESS( OptionsDirectories.PrependDirectory(szToolsLoc, DIR_TYPE_EXE, PLATFORM_WIN32_X86)) )
	{
		return FALSE;
	}

	return TRUE;
}

BOOL CSystemTestSet::RemoveToolsDir(CString szToolsLoc)
{
	COEnvironment OptionsDirectories;
	
	if ( !VERIFY_TEST_SUCCESS( OptionsDirectories.RemoveDirectory(szToolsLoc, DIR_TYPE_EXE, PLATFORM_WIN32_X86)) )
	{
		return FALSE;
	}

	return TRUE;
}

CString CSystemTestSet::GetBldLog()
{
	CString BuildRecord;
	CString str;
	
	// Get build data
	UIWB.DoCommand(IDM_WINDOW_ERRORS,DC_ACCEL);  // goto output window
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(BuildRecord);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	BuildRecord.MakeLower();
	return (BuildRecord);
	
};

void CSystemTestSet::LogTestHeader(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("TEST: %s", test_desc_str);
}

void CSystemTestSet::LogSubTestHeader(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("SubTest: %s", test_desc_str);
}


void CSystemTestSet::LogResult(int line, int result,LPCSTR szoperation, int code /* 0 */, LPCSTR szComment /* "" */)
{
	CString szOpCom = (CString)szoperation + "  " + szComment;
	if(result == PASSED)
		m_pLog->RecordSuccess("%s", szOpCom);
	else
	{
		CString szextra;
		char chbuf[24];
		szextra = szextra + "Error Code = " + itoa(code, chbuf, 10);
		m_pLog->RecordFailure("LINE %d %s", line, szextra + szOpCom);
	}
}

BOOL CSystemTestSet::VerifyBuildOccured( BOOL iBuild )
{
	// iBuild == TRUE  -  project should be rebuilt
	// iBuild == FALSE  -  project should not be rebuilt

	// Get the output window contents
	CString szBldLog = GetBldLog();
	if (szBldLog == "")
	{
		m_pLog->RecordFailure("Incorrect build: Output window is empty");
		return FALSE;
	}

	// TODO(michma - 12/8/97): the "compiling" and "linking" need to be localized for this 
	// to pass on japanese and german.
/*
	int iFoundCompiling = szBldLog.Find ("compiling");	// International ?
	int iFoundLinking = szBldLog.Find ("linking");		// International ?

	if( iBuild )
	{
		if( (iFoundCompiling < 0) && (iFoundLinking < 0) )
		{
			m_pLog->RecordFailure("Incorrect build: can't find 'Compiling' or 'Linking");
			return FALSE;
		}
	}
	else
	{
		if ( (iFoundCompiling > 0) || (iFoundLinking > 0) )
		{
			m_pLog->RecordFailure("Nothing change, the project shouldn't be rebuilt.");
			return FALSE;
		}
	}
*/
	return TRUE;
}

int CSystemTestSet::VerifyBuildString( LPCSTR verifyString, BOOL fExist /* TRUE */ )
{
	int iFoundString;

	// Get the output window contents
	CString szBldLog = GetBldLog();
	CString testString = verifyString;

	// For some reason the output window text is always lower case when extracted.

	testString.MakeLower();
	iFoundString = szBldLog.Find(testString);

	if ( (iFoundString < 0) && fExist )
	{
		m_pLog->RecordFailure("Can't find %s", verifyString);
	}
	
	if ( (iFoundString >= 0) && !fExist )
	{
		m_pLog->RecordFailure("Found %s : it should not be there", verifyString);
	}

	return iFoundString;
}

BOOL CSystemTestSet::CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc )
{
	CString szPattern		= (CString)szSRCFileLoc + "*.*";

	// Copy sources to the project directory
	WIN32_FIND_DATA ffdImgFile;
    HANDLE hFile = FindFirstFile(szPattern, &ffdImgFile);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
			CopyFile( (CString)szSRCFileLoc + ffdImgFile.cFileName, (CString)szProjLoc + ffdImgFile.cFileName, FALSE );
			SetFileAttributes((CString)szProjLoc + ffdImgFile.cFileName, FILE_ATTRIBUTE_NORMAL );
		}
        while( FindNextFile(hFile, &ffdImgFile) );
        EXPECT( GetLastError() == ERROR_NO_MORE_FILES );
		return TRUE;
    }
	else
	{
		m_pLog->RecordFailure("Could not copy sources from %s to %s", szSRCFileLoc, szProjLoc);
		return FALSE;
	}
}

BOOL CSystemTestSet::UpdateBuildVerify( LPCSTR szCurrentFile, LPCSTR szNewFile, LPCSTR szFileString )
{
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete

	CopyFile(szNewFile, szCurrentFile, FALSE);
	SetFileAttributes(szCurrentFile, FILE_ATTRIBUTE_NORMAL ); 
	TouchFile( szCurrentFile );
	if (!VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)))
	{
		m_pLog->RecordFailure("Could not build the Project");
		return FALSE;
	}
	VerifyBuildOccured( TRUE );
	if( VerifyBuildString( szFileString ) <= 0 )
	{
		m_pLog->RecordFailure("Could not find string in the build output");
		return FALSE;
	}

	return TRUE;
}

void CSystemTestSet::FillExprInfo(EXPR_INFO &expr_info, 
								 int state, LPCSTR type, LPCSTR name, LPCSTR value)

	{
	expr_info.state = state;
	expr_info.type = type;
	expr_info.name = name;
	expr_info.value = value;
	}


BOOL CSystemTestSet::ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
							   int total_rows /* 1 */)
	
	{
	for(int i = 0; i < total_rows; i++)

		{
		if(expr_info_actual[i].state != expr_info_expected[i].state)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): state is %d instead of %d", 
								  expr_info_actual[i].state, expr_info_expected[i].state);

			return FALSE;
			}

		if(expr_info_actual[i].type != expr_info_expected[i].type)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): type is %s instead of %s", 
								  expr_info_actual[i].type, expr_info_expected[i].type);

			return FALSE;
			}

		if(expr_info_actual[i].name != expr_info_expected[i].name)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): name is %s instead of %s", 
								  expr_info_actual[i].name, expr_info_expected[i].name);

			return FALSE;
			}

		if(expr_info_expected[i].value.Mid(0, 7) != "UNKNOWN") 

			{
			BOOL value_tests_passed;

			if(expr_info_expected[i].value.Mid(0, 7) == "ADDRESS")
				
				{
				value_tests_passed = ValueIsAddress(expr_info_actual[i].value);

				// is extra data besides address expected? (ex. peek at string)
				if(expr_info_expected[i].value != "ADDRESS")
				
					{
					// user must supply extra data to avoid CString assert.
					EXPECT(expr_info_expected[i].value.GetLength() > 8);

					// make sure actual string is long enough so we avoid CString assert.
					if(expr_info_actual[i].value.GetLength() > 10)
					{
						// verify extra data is correct.
						if(expr_info_actual[i].value.Mid(10) == (" " + expr_info_expected[i].value.Mid(8)))
							value_tests_passed = TRUE;
					}
					else
						// actual string wasn't long enough to contain extra data.
						value_tests_passed = FALSE;
					}
				}	 
	
			else	
				value_tests_passed = expr_info_actual[i].value == expr_info_expected[i].value;

			if(!value_tests_passed)
				
				{
				m_pLog->RecordFailure("ERROR in ExprInfoIs(): value is %s instead of %s", 
									  expr_info_actual[i].value, expr_info_expected[i].value);

				return FALSE;
				}
			}
		}

	return TRUE;
	}


BOOL CSystemTestSet::ValueIsAddress(CString str)
	{
	return (str.Mid(0, 2) == "0x") && 
		   (str.Mid(2).SpanIncluding("0123456789abcdef").GetLength() == 8);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\sysset.h ===
///////////////////////////////////////////////////////////////////////////////
//	SYSSET.H
//
//	Created by :			Date :
//		YefimS					5/19/97
//
//	Description :
//		Declaration of base class containing common data and methods for all
//		System Test Sets.

#ifndef __SYSSET_H__
#define __SYSSET_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

extern int ReturnCode;

#define EXPECT_TRUE(f)    ((f)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f,ReturnCode));
#define EXPECT_TRUE_COMMENT(f,comment) ((f)?LogResult(__LINE__, PASSED,#f,0,#comment):LogResult(__LINE__, FAILED,#f,0,#comment));
#define RestoreFocusToSrcWnd() MST.DoKeys("{ESC}")

// Global variables
#define WSPEXTENSION	".DSW"
#define PRJEXTENSION	".DSP"
#define NEWEXEINTDIR	"EXEInt"
#define NEWEXEOUTDIR	"EXEOut"
#define BUILDRES		"buildres.out"
#define PLATFORMS		PLATFORM_WIN32_X86 + PLATFORM_MAC_68K + PLATFORM_MAC_PPC

#if defined(_MIPS_)
#define TOOLSDIR "tools\\mips"
#elif defined(_ALPHA_)
#define TOOLSDIR "tools\\alpha"
#else
#define TOOLSDIR "tools\\x86"
#endif

extern CString cstrRelease ;// =  GetLocString(IDSS_BUILD_RELEASE);
extern CString cstrDebug ;// =  GetLocString(IDSS_BUILD_DEBUG);
extern CString RELEASETARGET; // = " - Win32 " + cstrRelease;
extern CString DEBUGTARGET; // = " - Win32 " + cstrDebug;

///////////////////////////////////////////////////////////////////////////////
//	class CSystemTestSet used as base for project tests

class CSystemTestSet : public CTest
{
//	DECLARE_TEST(CSystemTestSet, CIDESubSuite /*CCORESubSuite*/)
	DECLARE_DYNAMIC(CSystemTestSet)
public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CSystemTestSet(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

protected: // data
	CString	m_strProjName;
	CString	m_szErrorText;
	int m_platform;
	CString m_szBuildToolsLoc;
	CString m_strProjLoc;	

	// locale-independent names of projects and other items used by the sys snap test.
	CString m_strWorkspaceName;
	CString m_strWorkspaceLoc;
	CString m_strAppProjName;
	CString m_strAppClassName;
	CString m_strMenuName;
	CString m_strMenuItemName;
	CString m_strAppResourceID;
	CString m_strHTMLPageName;
	CString m_strActiveXControlProjName;
	CString m_strActiveXControlName;
	CString m_strActiveXControlViewClass;
	CString m_strAppsRoot;
	CString m_strHTMLPageRelPath;
	CString m_strATLCOMServerProjName;
	CString m_strATLCOMServerInterface;
	CString m_strATLCOMServerClsID;
	CString m_strATLCOMServerIID;

	COSource src;
	COProject prj;
 	COWorkSpace ws;
	CODebug dbg;
	COBrowse browse;
	COFile file;
	COResScript res;
	COHTML html;
	UIClassWizard uiclswiz;

	COExpEval cxx;
	COBreakpoints bp;
	COStack stk;
	UIMemory uimem;
	COMemory mem;
	UIVariables uivar;
	UIWatch uiwatch;
	UIQuickWatch uiqw;

//	typedef enum {PROJECT_EXE, PROJECT_DLL} PROJECT_TYPE;
//?	typedef enum {fDefault, fBuildOnly} PROJECT_FLAGS;

	void LogResult(int line, int result,LPCSTR szoperation, int code=0, LPCSTR szComment="");
	LPCSTR HomeDir(void);
	LPCSTR FullPath(LPCSTR szAddPath);
	void LogTestHeader(LPCSTR test_desc_str);
	void LogSubTestHeader(LPCSTR test_desc_str);

	void RemoveTestFiles( CString szProjLoc );
	BOOL TouchFile( CString szFileName );
	time_t GetFileTime( CString szFileName );
	BOOL SetToolsDir( CString szToolsLoc );
	BOOL RemoveToolsDir( CString szToolsLoc );
	CString GetBldLog();
	BOOL VerifyBuildOccured( BOOL iBuild );
	int VerifyBuildString( LPCSTR verifyString, BOOL fExist = TRUE );
	BOOL CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc );
	BOOL UpdateBuildVerify( LPCSTR szCurrentFile, LPCSTR szNewFile, LPCSTR szFileString );

	// shorthand method of filling EXPR_INFO object.
	void FillExprInfo(EXPR_INFO &expr_info, int state, LPCSTR type, LPCSTR name, LPCSTR value);

	// compares two EXPR_INFO objects
	BOOL ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
					int total_rows = 1);
	
	// tells whether string represents an address as displayed in an ee window.
	// for example: 0x1234abcd "xyz"
	// support function for ExprInfoIs()
	BOOL ValueIsAddress(CString str);

	void VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);
	BOOL LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);


};

#endif //__SYSSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\ActiveXControlInDialog\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\ActiveXControlInDialog\ActiveXControlInDialogCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ActiveXControlInDialogCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CActiveXControlInDialogCase class

#include "stdafx.h"
#include "ActiveXControlInDialogCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CActiveXControlInDialogCase, CSystemTestSet, "Insert and Debug ActiveX Control in Dialog", -1, CActiveXControlInDialogSubsuite)

void CActiveXControlInDialogCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CActiveXControlInDialogCase::Run(void)
{	 
	OpenMainProject();
	XSAFETY;
	AddControlFromGallery();
	XSAFETY;
	DropControlsToDialog();
	XSAFETY;
	BuildProject();
	XSAFETY;
	DebugProject();
	prj.Close(TRUE);
}

void CActiveXControlInDialogCase::OpenMainProject(void)
{
	UIWorkspaceWindow wksp;
	prj.Open(GetCWD() + m_strWorkspaceLoc + m_strWorkspaceName + ".DSW");
	LOG->RecordCompare(wksp.SetActiveProject(m_strAppProjName)!=FALSE,"selected main project");
} //OpenMainProject

CString strActiveXName;

void CActiveXControlInDialogCase::AddControlFromGallery(void)
{
	CString strActiveXLoc = GetLocString(IDSS_GALLERY_CONTROL_FOLDER);
	LOG->RecordInfo("");
	LOG->RecordCompare(prj.EnableComponents(strActiveXLoc), "*** Enabling ActiveX controls. ***");

	LOG->RecordInfo("");
	strActiveXName = m_strActiveXControlName + " Control";
	LOG->RecordInfo("*** Adding %s control. ***", strActiveXName); 
	
	// create the ActiveX control that we want to add.
	COComponent* pComponent= new CActiveXControl(strActiveXName);

	// add the component to the project.
	LOG->RecordCompare(prj.AddComponent(pComponent,strActiveXLoc), "Adding %s control.", strActiveXName);		
	delete pComponent;

	// puts ide back into state it was in before prj.EnableComponents was called.
	LOG->RecordInfo("");
	LOG->RecordCompare(prj.DisableComponents(), "*** Disabling galery. ***");

} //AddControlFromGallery



void CActiveXControlInDialogCase::DropControlsToDialog(void)
{
	UIWorkspaceWindow uwksp;
	UIDlgEdit m_uDlgEd;
	EXPECT_TRUE(uwksp.SelectResource("Dialog", "IDD_TESTDIALOG")==SUCCESS); //TODO change to the name of the dialog Yefim will provide
	MST.DoKeys("{ENTER}", FALSE, 5000);
	m_uDlgEd = UIWB.GetActiveEditor();
//drop the control just added to the project
	m_uDlgEd.DropControl(CT_USER+2, 20, 20); //TODO very likely CT_USER+2 to change when layout of control pallette chnage

	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	BOOL bvalid=prop.IsValid();
	
	CString controlID=prop.GetID();
	LOG->RecordInfo("ID of control dropped: '%s'",controlID);
	prop.SetAllPage();
	prop.Close();
//TODO open the file from class view and add the code to invoke the TestDialog
//	UIWorkspaceWindow WorkSpaceWnd; //create project workspace window object
	//if project workspace activates properly
//	if (WorkSpaceWnd.Activate())  
//	{
//		//if classview activates properly
//		if (WorkSpaceWnd.ActivateClassPane())
//		{
//			int ClassSelected = WorkSpaceWnd.SelectClass(/*m_strViewClassName*/, m_strAppProjName); //TODO provide ViewClassName
//		}
//		else
//		{
//			LOG->RecordFailure("Could not activate ClassView.");
//			return FALSE;
//		}
//	}
//	else
//	{
//		LOG->RecordFailure("Could not activate project workspace window.");
//		return FALSE;
//	}
// return; //TODO do enable this return (do not set this code) when you know how to pass keystrokes to the app
	UIWB.OpenFile( m_strProjLoc + /*m_strViewName*/"AppWiz AppView" + ".cpp" ); //TODO provide the view name
/*
Add 
	AfxGetApp()->m_pMainWnd->PostMessage(WM_COMMAND, ID_Test_TestDialog  );
to CView::OnInitialUpdate() to invoke the dialog TestDialog without UI interraction
*/
	src.Find( "CView::OnInitialUpdate();" );
//	int nLine = src.GetCurrentLine();
//	src.InsertText("AfxGetApp()->m_pMainWnd->PostMessage(WM_COMMAND, ID_Test_TestDialog  );");  //Doesn't work
	MST.DoKeys("{Down}{Home}");
	MST.DoKeys("AfxGetApp()->m_pMainWnd->PostMessage(WM_COMMAND, ID_Test_TestDialog  );",TRUE);
	MST.DoKeys("{Enter}");	
	
	UIWB.DoCommand(IDM_FILE_SAVE_ALL, DC_MNEMONIC); //the only way to save the resources
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
	//TODO drop another control (ATL) this time from the right click
} //DropControlsToDialog

void CActiveXControlInDialogCase::BuildProject(void)
{
		// build the project
	LOG->RecordCompare(prj.Build( 60 ) == ERROR_SUCCESS, "Building project.");


	LOG->RecordInfo("Verifying the build...");

	// verify the build
	BOOL bResult = LOG->RecordCompare(prj.VerifyBuild() == ERROR_SUCCESS, "Verifying the build.");
	if (!bResult) {
		throw CTestException("CBindBuildTest::BuildProject: cannot build a container project; unable to continue.", CTestException::causeOperationFail);
	}

} //BuildProject

void CActiveXControlInDialogCase::DebugProject(void)
{
	COBreakpoints bp;

	CString strActiveXControlProjRoot = GetCWD() + m_strWorkspaceLoc + m_strActiveXControlProjName + "\\";
	int ret=prj.SetAdditionalDLLs(strActiveXControlProjRoot + "Debug\\" + m_strActiveXControlProjName + ".ocx");

// set a bp in the InitInstance function of the ActiveX control.
	UIWB.OpenFile(strActiveXControlProjRoot + m_strActiveXControlProjName + ".cpp"); 
	/*EXPECT_TRUE*/( src.Find("BOOL bInit = COleControlModule::InitInstance();" ) ); //it's not true
	MST.DoKeys("{F9}"); //set the BP
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
	
	// TODO(michma 2/9/98): this is just in here to nail that stupid build problem where it asks to build
	// when it shouldn't.
	//LOG->RecordCompare(dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN), "Start debugging the app");
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	Sleep(1000);

	if(MST.WButtonExists("@1"))
	{
		CString str;
		MST.WStaticText("@2", str);
		m_pLog->RecordFailure("Got a button when we shouldn't have. The message text is \"%s\".", str);
		return;
	}


	HWND hwndapp=0;
	hwndapp=MST.WFndWndWait(m_strAppProjName + " - AppWiz1", FW_PART /*| FW_FOCUS | FW_CHILDNOTOK | FW_HIDDENNOTOK*/, 10); //wait 10 seconds for the window to come up
//	EXPECT_TRUE(hwndapp!=NULL); //does not work is always NULL
	::WaitStepInstructions("Invoke the Test Dialog");
	DWORD appThreadId=0;if(hwndapp!=NULL)appThreadId=::GetWindowThreadProcessId(hwndapp, NULL);
	DWORD IDEThreadId=::GetWindowThreadProcessId(UIWB, NULL);
	LOG->Comment("Found the handle of window: (0x%X),its thread:(%d), IDE thread: (%d)",hwndapp,appThreadId,IDEThreadId);
/*this message journal does not work, I withheld it to later
and enabled invoking the dialog
//	MST.DoKeyshWnd(hwndapp,"%TT"); //brings  TestDialog even this DOES HANG the debugger
	::WaitStepInstructions("alt-TT for thread: %d", appThreadId);
	::PostThreadMessage(appThreadId,WM_SYSKEYDOWN, VK_MENU,0x20380001);
	::PostThreadMessage(appThreadId,WM_SYSKEYDOWN, 0x54,   0x20140001);
	::PostThreadMessage(appThreadId,WM_SYSKEYUP,   0x54,   0xF0140001);
	::PostThreadMessage(appThreadId,WM_KEYUP,      VK_MENU,0xD0380001);
	::PostThreadMessage(appThreadId,WM_KEYDOWN,    0x54,   0x10140001);
	::PostThreadMessage(appThreadId,WM_KEYUP,      0x54,   0xC0140001);
*/
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK) );
	EXPECT_TRUE(dbg.CurrentLineIs("BOOL bInit = COleControlModule::InitInstance();" ) );
//	bp.DisableAllBreakpoints(); //does not work; Clear instead
	bp.ClearAllBreakpoints();
	
	CString strOnDraw = m_strActiveXControlViewClass + "::OnDraw";
		LOG->RecordCompare(bp.SetBreakpoint(strOnDraw) != NULL,
		"Set a breakpoint in the OnDraw function of the ActiveX control.");
// hit the bp.
//post key messages to IDE thread directly as DoKeys hang the IDE
		::WaitStepInstructions("F5 Key message to IDE thread");
		Sleep(1000);
		::PostThreadMessage(IDEThreadId,WM_KEYDOWN,VK_F5,0);
		::PostThreadMessage(IDEThreadId,WM_KEYUP,VK_F5,0);
		Sleep(2000);
	LOG->RecordCompare(dbg.AtSymbol(strOnDraw), 
		"Hit the bp in the OnDraw function of the ActiveX control.");
	bp.ClearAllBreakpoints();
//post key messages to IDE thread directly as DoKeys hang the IDE
		::WaitStepInstructions("F5 Key message to IDE thread");
		Sleep(1000);
		::PostThreadMessage(IDEThreadId,WM_KEYDOWN,VK_F5,0);
		::PostThreadMessage(IDEThreadId,WM_KEYUP,VK_F5,0);
		Sleep(2000);
	LOG->RecordCompare(dbg.Wait(WAIT_FOR_RUN), "Continue debugging the app");
/*
// set a bp in the ExitInstance function of the ActiveX control.
	CString strOnExit = "CActiveXControlApp::ExitInstance";
	LOG->RecordCompare(bp.SetBreakpoint(strOnExit) != NULL,
	"Set a breakpoint in the strOnExit function of the ActiveX control.");
*/
//switch to the app & terminate it
	HWND hnext=MST.WFndWndWait(m_strAppProjName + " - AppWiz1", FW_PART | FW_CHILDNOTOK | FW_HIDDENNOTOK, 10); //wait 10 seconds for the window to come up
	LOG->Comment("'0x%X' app window found the second time",hnext);
//	EXPECT_TRUE(hwndapp==hnext); //does not work because the window cannot be found the first time
	if(hwndapp==NULL)hwndapp=hnext;
	if(appThreadId==0)appThreadId=::GetWindowThreadProcessId(hwndapp, NULL);
	LOG->Comment("Second time handle wnd: (0x%X),its thread:(%d)",hwndapp,appThreadId);

//*this message journal does not work
//but it's not critical to the pass state
//post key messages to app thread directly as DoKeys hang the IDE
	::WaitStepInstructions("ENTER Key message to the app");
	::PostThreadMessage(appThreadId,WM_KEYDOWN,VK_RETURN, 0x001C0001);
	::PostThreadMessage(appThreadId,WM_KEYUP,  VK_RETURN, 0xC01C0001);
	Sleep(5000);
//*/
	::WaitStepInstructions("MW_CLOSE message to the app");
	::PostMessage(hwndapp, WM_CLOSE, 0, 0);

/*
//we shld hiot the ExitInstance bp
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK) );
	EXPECT_TRUE(dbg.AtSymbol(strOnExit);
//dbg.Go()
	TODO F5
*/
	LOG->RecordCompare(dbg.Wait(WAIT_FOR_TERMINATION), "Terminate the app.");
} //DebugProject

/*
//	MST.DoKeyshWnd(UIWB,"{F5}");
//		HWND IDEhandle=GetSubSuite()->GetIDE()->m_hWnd;
	DWORD IDEThreadId=::GetWindowThreadProcessId(UIWB, NULL);

		::WaitStepInstructions("F5 Key down Flush up");
		::PostThreadMessage(IDEThreadId,WM_KEYDOWN,VK_F5,0);
		::PostThreadMessage(IDEThreadId,WM_KEYUP,VK_F5,0);
 
	Sleep(20000);
	EXPECT_TRUE(dbg.CurrentLineIs("BOOL bInit = COleControlModule::InitInstance();" ) );
	::WaitStepInstructions("F5 Key down Flush up");
	::PostThreadMessage(IDEThreadId,WM_KEYDOWN,VK_F5,0);
	::PostThreadMessage(IDEThreadId,WM_KEYUP,VK_F5,0);
	Sleep(1000);
	EXPECT_TRUE(dbg.CurrentLineIs("return bInit;"));
for(int i=0;i<20;i++)
{	
	::WaitStepInstructions("F5 Key down Flush up");
	::PostThreadMessage(IDEThreadId,WM_KEYDOWN,VK_F5,0);
	::PostThreadMessage(IDEThreadId,WM_KEYUP,VK_F5,0);
	EXPECT_TRUE(dbg.CurrentLineIs(strOnDraw)); 
	Sleep(1000);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildActiveXControlProject\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\ActiveXControlInDialog\ActiveXControlInDialogSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	ActiveXControlInDialog Subsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CActiveXControlInDialogSubSuitee class
//

#ifndef __ActiveXControlInDialogSubsuite_H__
#define __ActiveXControlInDialogSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CActiveXControlInDialogSubSuitee class

class CActiveXControlInDialogSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CActiveXControlInDialogSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__ActiveXControlInDialogSubSuitee_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\ActiveXControlInDialog\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildActiveXControlProject\BuildActiveXControlProjectSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	BuildActiveXControlProjectSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CBuildActiveXControlProjectSubsuite class
//

#ifndef __BuildActiveXControlProjectSubsuite_H__
#define __BuildActiveXControlProjectSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CBuildActiveXControlProjectSubsuite class

class CBuildActiveXControlProjectSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CBuildActiveXControlProjectSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__BuildActiveXControlProjectSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildActiveXControlProject\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildActiveXControlProject\BuildActiveXControlProjectCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	BuildActiveXControlProjectCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CBuildActiveXControlProjectCase class

#ifndef __BuildActiveXControlProjectCase_H__
#define __BuildActiveXControlProjectCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "BuildActiveXControlProjectSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CBuildActiveXControlProjectCase class

class CBuildActiveXControlProjectCase : public CSystemTestSet
{
	DECLARE_TEST(CBuildActiveXControlProjectCase, CBuildActiveXControlProjectSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__BuildActiveXControlProjectCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildATLCOMServerProject\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildATLCOMServerProject\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildActiveXControlProject\BuildActiveXControlProjectSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BuildActiveXControlProjectSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CBuildActiveXControlProjectSubsuite class
//

#include "stdafx.h"
#include "BuildActiveXControlProjectSubsuite.h"
#include "afxdllx.h"

#include "BuildActiveXControlProjectCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CBuildActiveXControlProjectSubsuite, CIDESubSuite, "Build ActiveX Control Project", "VCQA")

BEGIN_TESTLIST(CBuildActiveXControlProjectSubsuite)
	TEST(CBuildActiveXControlProjectCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildATLCOMServerProject\BuildATLCOMServerProjectCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	BuildATLCOMServerProjectCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CBuildATLCOMServerProjectCase class

#ifndef __BuildATLCOMServerProjectCase_H__
#define __BuildATLCOMServerProjectCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "BuildATLCOMServerProjectSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CBuildATLCOMServerProjectCase class

class CBuildATLCOMServerProjectCase : public CSystemTestSet
{
	DECLARE_TEST(CBuildATLCOMServerProjectCase, CBuildATLCOMServerProjectSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__BuildATLCOMServerProjectCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildATLCOMServerProject\BuildATLCOMServerProjectCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BuildATLCOMServerProjectCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CBuildATLCOMServerProjectCase class

#include "stdafx.h"
#include "BuildATLCOMServerProjectCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBuildATLCOMServerProjectCase, CSystemTestSet, "Build ATL COM Server Project", -1, CBuildATLCOMServerProjectSubsuite)

void CBuildATLCOMServerProjectCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CBuildATLCOMServerProjectCase::Run(void)
{	 
	// need to do this because each subsuite has its own COProject object.
	prj.Attach();

	// select the ATL COM Server project so we can build it.
	prj.SetTarget((CString)m_strATLCOMServerProjName + " - " + 
					GetLocString(IDSS_PLATFORM_WIN32) + " " +
					GetLocString(IDSS_BUILD_DEBUG));

	// build the project.
	LOG->RecordCompare(prj.Build() == ERROR_SUCCESS, "Build '%s' project.", m_strATLCOMServerProjName);
	
	// verify no errors or warnings were generated.
	int iErr, iWarn;
	LOG->RecordCompare(prj.VerifyBuild(TRUE, &iErr, &iWarn, TRUE) == ERROR_SUCCESS,
		"Verify build of '%s' project", m_strATLCOMServerProjName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildActiveXControlProject\BuildActiveXControlProjectCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BuildActiveXControlProjectCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CBuildActiveXControlProjectCase class

#include "stdafx.h"
#include "BuildActiveXControlProjectCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBuildActiveXControlProjectCase, CSystemTestSet, "Build ActiveX Control Project", -1, CBuildActiveXControlProjectSubsuite)

void CBuildActiveXControlProjectCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CBuildActiveXControlProjectCase::Run(void)
{	 

	// need to do this because each subsuite has its own COProject object.
	prj.Attach();

	// select the ActiveX Control project so we can build it.
	prj.SetTarget((CString)m_strActiveXControlProjName + " - " + 
					GetLocString(IDSS_PLATFORM_WIN32) + " " +
					GetLocString(IDSS_BUILD_DEBUG));

	// build the project.
	LOG->RecordCompare(prj.Build() == ERROR_SUCCESS, "Build '%s' project.", m_strActiveXControlProjName);
	
	// verify no errors or warnings were generated.
	int iErr, iWarn;
	LOG->RecordCompare(prj.VerifyBuild(TRUE, &iErr, &iWarn, TRUE) == ERROR_SUCCESS,
		"Verify build of '%s' project", m_strActiveXControlProjName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateActiveXControlProject\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateActiveXControlProject\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildATLCOMServerProject\BuildATLCOMServerProjectSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BuildATLCOMServerProjectSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CBuildATLCOMServerProjectSubsuite class
//

#include "stdafx.h"
#include "BuildATLCOMServerProjectSubsuite.h"
#include "afxdllx.h"

#include "BuildATLCOMServerProjectCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CBuildATLCOMServerProjectSubsuite, CIDESubSuite, "Build ATL COM Server Project", "VCQA")

BEGIN_TESTLIST(CBuildATLCOMServerProjectSubsuite)
	TEST(CBuildATLCOMServerProjectCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\BuildATLCOMServerProject\BuildATLCOMServerProjectSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	BuildATLCOMServerProjectSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CBuildATLCOMServerProjectSubsuite class
//

#ifndef __BuildATLCOMServerProjectSubsuite_H__
#define __BuildATLCOMServerProjectSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CBuildATLCOMServerProjectSubsuite class

class CBuildATLCOMServerProjectSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CBuildATLCOMServerProjectSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__BuildATLCOMServerProjectSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateActiveXControlProject\CreateActiveXControlProjectCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	CreateActiveXControlProjectCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CCreateActiveXControlProjectCase class

#ifndef __CreateActiveXControlProjectCase_H__
#define __CreateActiveXControlProjectCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "CreateActiveXControlProjectSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CCreateActiveXControlProjectCase class

class CCreateActiveXControlProjectCase : public CSystemTestSet
{
	DECLARE_TEST(CCreateActiveXControlProjectCase, CCreateActiveXControlProjectSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__CreateActiveXControlProjectCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateActiveXControlProject\CreateActiveXControlProjectSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CreateActiveXControlProjectSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CCreateActiveXControlProjectSubsuite class
//

#include "stdafx.h"
#include "CreateActiveXControlProjectSubsuite.h"
#include "afxdllx.h"

#include "CreateActiveXControlProjectCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CCreateActiveXControlProjectSubsuite, CIDESubSuite, "Create ActiveX Control Project", "VCQA")

BEGIN_TESTLIST(CCreateActiveXControlProjectSubsuite)
	TEST(CCreateActiveXControlProjectCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateActiveXControlProject\CreateActiveXControlProjectCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CreateActiveXControlProjectCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CCreateActiveXControlProjectCase class

#include "stdafx.h"
#include "CreateActiveXControlProjectCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CCreateActiveXControlProjectCase, CSystemTestSet, "Create ActiveX Control Project", -1, CCreateActiveXControlProjectSubsuite)

void CCreateActiveXControlProjectCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CCreateActiveXControlProjectCase::Run(void)
{	 
	// set the name and location of the activex control project. we also want the project to be added to
	// the current workspace, and made a subproject of the main app project.
	CProjWizOptions *pCtrlWizOpt = new(CControlWizOptions);
	pCtrlWizOpt->m_strLocation = GetCWD() + m_strWorkspaceLoc;
	pCtrlWizOpt->m_strName = m_strActiveXControlProjName;	
	pCtrlWizOpt->m_pwWorkspace = ADD_TO_CURRENT_WORKSPACE;
	pCtrlWizOpt->m_phHierarchy = SUB_PROJ;
	pCtrlWizOpt->m_strParent = m_strAppProjName; 
	
	// create the activex control project.
	LOG->RecordCompare(prj.New(pCtrlWizOpt) == ERROR_SUCCESS, 
		"Create ActiveX control project named: %s", pCtrlWizOpt->m_strName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateActiveXControlProject\CreateActiveXControlProjectSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	CreateActiveXControlProjectSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CCreateActiveXControlProjectSubsuite class
//

#ifndef __CreateActiveXControlProjectSubsuite_H__
#define __CreateActiveXControlProjectSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CCreateActiveXControlProjectSubsuite class

class CCreateActiveXControlProjectSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CCreateActiveXControlProjectSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__CreateActiveXControlProjectSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateATLCOMServerProject\CreateATLCOMServerProjectSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CreateATLCOMServerProjectSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CCreateATLCOMServerProjectSubsuite class
//

#include "stdafx.h"
#include "CreateATLCOMServerProjectSubsuite.h"
#include "afxdllx.h"

#include "CreateATLCOMServerProjectCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CCreateATLCOMServerProjectSubsuite, CIDESubSuite, "Create ATL COM Server Project", "VCQA")

BEGIN_TESTLIST(CCreateATLCOMServerProjectSubsuite)
	TEST(CCreateATLCOMServerProjectCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateATLCOMServerProject\CreateATLCOMServerProjectCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CreateATLCOMServerProjectCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CCreateATLCOMServerProjectCase class

#include "stdafx.h"
#include "CreateATLCOMServerProjectCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CCreateATLCOMServerProjectCase, CSystemTestSet, "Create ATL COM Server Project", -1, CCreateATLCOMServerProjectSubsuite)

void CCreateATLCOMServerProjectCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CCreateATLCOMServerProjectCase::Run(void)
{	 
	// set the name and location of the atl com server project. we also want the project to be added to
	// the current workspace, and made a subproject of the main app project.
	CProjWizOptions *pATLCOMWizOpt = new(CATLCOMWizOptions);
	pATLCOMWizOpt->m_strLocation = GetCWD() + m_strWorkspaceLoc;
	pATLCOMWizOpt->m_strName = m_strATLCOMServerProjName;	
	pATLCOMWizOpt->m_pwWorkspace = ADD_TO_CURRENT_WORKSPACE;
	pATLCOMWizOpt->m_phHierarchy = SUB_PROJ;
	pATLCOMWizOpt->m_strParent = m_strAppProjName; 
	
	// create the activex control project.
	LOG->RecordCompare(prj.New(pATLCOMWizOpt) == ERROR_SUCCESS, 
		"Create ATL COM Server project named: %s", pATLCOMWizOpt->m_strName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateATLCOMServerProject\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateATLCOMServerProject\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateATLCOMServerProject\CreateATLCOMServerProjectSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	CreateATLCOMServerProjectSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CCreateATLCOMServerProjectSubsuite class
//

#ifndef __CreateATLCOMServerProjectSubsuite_H__
#define __CreateATLCOMServerProjectSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CCreateATLCOMServerProjectSubsuite class

class CCreateATLCOMServerProjectSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CCreateATLCOMServerProjectSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__CreateATLCOMServerProjectSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateHTMLPage\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateATLCOMServerProject\CreateATLCOMServerProjectCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	CreateATLCOMServerProjectCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CCreateATLCOMServerProjectCase class

#ifndef __CreateATLCOMServerProjectCase_H__
#define __CreateATLCOMServerProjectCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "CreateATLCOMServerProjectSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CCreateATLCOMServerProjectCase class

class CCreateATLCOMServerProjectCase : public CSystemTestSet
{
	DECLARE_TEST(CCreateATLCOMServerProjectCase, CCreateATLCOMServerProjectSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__CreateATLCOMServerProjectCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateHTMLPage\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateHTMLPage\CreateHTMLPageCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	CreateHTMLPageCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CCreateHTMLPageCase class

#ifndef __CreateHTMLPageCase_H__
#define __CreateHTMLPageCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "CreateHTMLPageSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CCreateHTMLPageCase class

class CCreateHTMLPageCase : public CSystemTestSet
{
	DECLARE_TEST(CCreateHTMLPageCase, CCreateHTMLPageSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__CreateHTMLPageCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateHTMLPage\CreateHTMLPageSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	CreateHTMLPageSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CCreateHTMLPageSubsuite class
//

#ifndef __CreateHTMLPageSubsuite_H__
#define __CreateHTMLPageSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CCreateHTMLPageSubsuite class

class CCreateHTMLPageSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CCreateHTMLPageSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__CreateHTMLPageSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateHTMLPage\CreateHTMLPageSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CreateHTMLPageSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CCreateHTMLPageSubsuite class
//

#include "stdafx.h"
#include "CreateHTMLPageSubsuite.h"
#include "afxdllx.h"

#include "CreateHTMLPageCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CCreateHTMLPageSubsuite, CIDESubSuite, "Create HTML Page", "VCQA")

BEGIN_TESTLIST(CCreateHTMLPageSubsuite)
	TEST(CCreateHTMLPageCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\CreateHTMLPage\CreateHTMLPageCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CreateHTMLPageCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CCreateHTMLPageCase class

#include "stdafx.h"
#include "CreateHTMLPageCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CCreateHTMLPageCase, CSystemTestSet, "Create HTML Page", -1, CCreateHTMLPageSubsuite)

void CCreateHTMLPageCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CCreateHTMLPageCase::Run(void)
{
	LOG->RecordCompare(html.Create(m_strHTMLPageName, m_strActiveXControlProjName) == ERROR_SUCCESS, 
		"Create HTML page named: %s", m_strHTMLPageName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugActiveXControlInHTMLPage\DebugActiveXControlInHTMLPageSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DebugActiveXControlInHTMLPageSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CDebugActiveXControlInHTMLPageSubsuite class
//

#include "stdafx.h"
#include "DebugActiveXControlInHTMLPageSubsuite.h"
#include "afxdllx.h"

#include "DebugActiveXControlInHTMLPageCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CDebugActiveXControlInHTMLPageSubsuite, CIDESubSuite, "Debug ActiveX Control In HTML Page", "VCQA")

BEGIN_TESTLIST(CDebugActiveXControlInHTMLPageSubsuite)
	TEST(CDebugActiveXControlInHTMLPageCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugActiveXControlInHTMLPage\DebugActiveXControlInHTMLPageSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	DebugActiveXControlInHTMLPageSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CDebugActiveXControlInHTMLPageSubsuite class
//

#ifndef __DebugActiveXControlInHTMLPageSubsuite_H__
#define __DebugActiveXControlInHTMLPageSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDebugActiveXControlInHTMLPageSubsuite class

class CDebugActiveXControlInHTMLPageSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CDebugActiveXControlInHTMLPageSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__DebugActiveXControlInHTMLPageSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugActiveXControlInHTMLPage\DebugActiveXControlInHTMLPageCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DebugActiveXControlInHTMLPageCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CDebugActiveXControlInHTMLPageCase class

#include "stdafx.h"
#include "DebugActiveXControlInHTMLPageCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CDebugActiveXControlInHTMLPageCase, CSystemTestSet, "Debug ActiveX Control In HTML Page", -1, CDebugActiveXControlInHTMLPageSubsuite)

void CDebugActiveXControlInHTMLPageCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CDebugActiveXControlInHTMLPageCase::Run(void)
{	 	
	// need to do this because each subsuite has its own COProject object.
	prj.Attach();

	// select the ActiveX Control project so we can debug it.
	prj.SetTarget((CString)m_strActiveXControlProjName + " - " + 
					GetLocString(IDSS_PLATFORM_WIN32) + " " +
					GetLocString(IDSS_BUILD_DEBUG));

	// set the executable for debug session for the ActiveX control project to the default browser.
	LOG->RecordCompare(prj.SetExeForDebugSession(NULL, m_strActiveXControlProjName, DEFAULT_DBG_EXE_BROWSER) == ERROR_SUCCESS, 
		"Set executable for the ActiveX control's debug session to the default browser.");

	// set the program arguements for the ActiveX control project to the html page.

	LOG->RecordCompare(prj.SetProgramArguments(GetCWD() + m_strHTMLPageRelPath, m_strActiveXControlProjName) == ERROR_SUCCESS, 
		"Set program arguments for ActiveX control's debug session to the HTML page.");

	// set a bp in the OnDraw function of the ActiveX control.
	CString strOnDraw = m_strActiveXControlViewClass + "::OnDraw";
	LOG->RecordCompare(bp.SetBreakpoint(strOnDraw) != NULL,
		"Set a breakpoint in the OnDraw function of the ActiveX control.");

	// hit the bp.
	LOG->RecordCompare(dbg.Go(strOnDraw), "Hit the bp in the OnDraw function of the ActiveX control.");
	// stop debugging.
	LOG->RecordCompare(dbg.StopDebugging(), "Stop debugging the ActiveX control.");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugActiveXControlInHTMLPage\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugActiveXControlInHTMLPage\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugATLCOMServer\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugATLCOMServer\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugActiveXControlInHTMLPage\DebugActiveXControlInHTMLPageCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DebugActiveXControlInHTMLPageCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CDebugActiveXControlInHTMLPageCase class

#ifndef __DebugActiveXControlInHTMLPageCase_H__
#define __DebugActiveXControlInHTMLPageCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "DebugActiveXControlInHTMLPageSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CDebugActiveXControlInHTMLPageCase class

class CDebugActiveXControlInHTMLPageCase : public CSystemTestSet
{
	DECLARE_TEST(CDebugActiveXControlInHTMLPageCase, CDebugActiveXControlInHTMLPageSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__DebugActiveXControlInHTMLPageCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugATLCOMServer\DebugATLCOMServerSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	DebugATLCOMServerSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CDebugATLCOMServerSubsuite class
//

#ifndef __DebugATLCOMServerSubsuite_H__
#define __DebugATLCOMServerSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDebugATLCOMServerSubsuite class

class CDebugATLCOMServerSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CDebugATLCOMServerSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__DebugATLCOMServerSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugATLCOMServer\DebugATLCOMServerSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DebugATLCOMServerSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CDebugATLCOMServerSubsuite class
//

#include "stdafx.h"
#include "DebugATLCOMServerSubsuite.h"
#include "afxdllx.h"

#include "DebugATLCOMServerCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CDebugATLCOMServerSubsuite, CIDESubSuite, "Debug ATL COM Server", "VCQA")

BEGIN_TESTLIST(CDebugATLCOMServerSubsuite)
	TEST(CDebugATLCOMServerCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugATLCOMServer\DebugATLCOMServerCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DebugATLCOMServerCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CDebugATLCOMServerCase class

#ifndef __DebugATLCOMServerCase_H__
#define __DebugATLCOMServerCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "DebugATLCOMServerSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CDebugATLCOMServerCase class

class CDebugATLCOMServerCase : public CSystemTestSet
{
	DECLARE_TEST(CDebugATLCOMServerCase, CDebugATLCOMServerSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__DebugATLCOMServerCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\DebugATLCOMServer\DebugATLCOMServerCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DebugATLCOMServerCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CDebugATLCOMServerCase class

#include "stdafx.h"
#include "DebugATLCOMServerCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CDebugATLCOMServerCase, CSystemTestSet, "Debug ATL COM Server", -1, CDebugATLCOMServerSubsuite)

void CDebugATLCOMServerCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CDebugATLCOMServerCase::Run(void)

{
	// need to do this because each subsuite has its own COProject object.
	prj.Attach();

	// select the AppWiz App project so we can debug it.
	prj.SetTarget((CString)m_strAppProjName + " - " + 
					GetLocString(IDSS_PLATFORM_WIN32) + " " +
					GetLocString(IDSS_BUILD_DEBUG));

	CString strATLCOMServerBinaryFullPath =
		GetCWD() +
		m_strWorkspaceLoc + 
		m_strATLCOMServerProjName + "\\" +
		GetLocString(IDSS_BUILD_DEBUG) + "\\" + 
		m_strATLCOMServerProjName + ".DLL";

	// add the atl com server to the additional dlls list so we can set a bp in it.
	LOG->RecordCompare(prj.SetAdditionalDLLs(strATLCOMServerBinaryFullPath) == ERROR_SUCCESS,
		"Adding ATL COM Server DLL to additional DLLs list for project '%s'", m_strAppProjName);

	// set a bp in the DllMain of the atl com server. 
	LOG->RecordCompare(bp.SetBreakpoint("DllMain") != NULL,
		"Set a breakpoint in the DllMain function of the ATL COM server.");

	// hit the bp.
	LOG->RecordCompare(dbg.Go("DllMain"), "Hit the bp in the DllMain function of the ATL COM server.");
	// stop debugging.
	LOG->RecordCompare(dbg.StopDebugging(), "Stop debugging the ATL COM Server");
	// clear the breakpoint at DllMain. 
	LOG->RecordCompare(bp.ClearAllBreakpoints(),"Clear thebp in the DllMain function of the ATL COM Server.");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertActiveXControlIntoHTMLPage\InsertActiveXControlIntoHTMLPageCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	InsertActiveXControlIntoHTMLPageCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CInsertActiveXControlIntoHTMLPageCase class

#include "stdafx.h"
#include "InsertActiveXControlIntoHTMLPageCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CInsertActiveXControlIntoHTMLPageCase, CSystemTestSet, "Insert ActiveX Control Into HTML Page", -1, CInsertActiveXControlIntoHTMLPageSubsuite)

void CInsertActiveXControlIntoHTMLPageCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CInsertActiveXControlIntoHTMLPageCase::Run(void)
{	 	
	// TODO(michma): need to activate html page and navigate to correct line.
	
	// need to do this so the html object will have a valid editor associated with it,
	// which is required when we save it later.
	html.AttachActive();
	
	// insert the activex control into the html page.
	LOG->RecordCompare(html.InsertActiveXControl(m_strActiveXControlName) == ERROR_SUCCESS, 
		"Insert ActiveX control '%s' into HTML page '%s'", m_strActiveXControlName,  m_strHTMLPageName);

	// close the file for the control that was inserted. this is required for the html to be written to the html file.
	COFile fileCtrl;
	fileCtrl.AttachActive();
	fileCtrl.Close();
	
	// save the change.
	html.Save();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertActiveXControlIntoHTMLPage\InsertActiveXControlIntoHTMLPageSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	InsertActiveXControlIntoHTMLPageSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CInsertActiveXControlIntoHTMLPageSubsuite class
//

#include "stdafx.h"
#include "InsertActiveXControlIntoHTMLPageSubsuite.h"
#include "afxdllx.h"

#include "InsertActiveXControlIntoHTMLPageCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CInsertActiveXControlIntoHTMLPageSubsuite, CIDESubSuite, "Insert ActiveX Control Into HTML Page", "VCQA")

BEGIN_TESTLIST(CInsertActiveXControlIntoHTMLPageSubsuite)
	TEST(CInsertActiveXControlIntoHTMLPageCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertActiveXControlIntoHTMLPage\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertActiveXControlIntoHTMLPage\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertActiveXControlIntoHTMLPage\InsertActiveXControlIntoHTMLPageSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	InsertActiveXControlIntoHTMLPageSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CInsertActiveXControlIntoHTMLPageSubsuite class
//

#ifndef __InsertActiveXControlIntoHTMLPageSubsuite_H__
#define __InsertActiveXControlIntoHTMLPageSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CInsertActiveXControlIntoHTMLPageSubsuite class

class CInsertActiveXControlIntoHTMLPageSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CInsertActiveXControlIntoHTMLPageSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__InsertActiveXControlIntoHTMLPageSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertActiveXControlIntoHTMLPage\InsertActiveXControlIntoHTMLPageCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	InsertActiveXControlIntoHTMLPageCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CInsertActiveXControlIntoHTMLPageCase class

#ifndef __InsertActiveXControlIntoHTMLPageCase_H__
#define __InsertActiveXControlIntoHTMLPageCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "InsertActiveXControlIntoHTMLPageSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CInsertActiveXControlIntoHTMLPageCase class

class CInsertActiveXControlIntoHTMLPageCase : public CSystemTestSet
{
	DECLARE_TEST(CInsertActiveXControlIntoHTMLPageCase, CInsertActiveXControlIntoHTMLPageSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__InsertActiveXControlIntoHTMLPageCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertCallToATLCOMServerInApp\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertCallToATLCOMServerInApp\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertCallToATLCOMServerInApp\InsertCallToATLCOMServerInAppSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	InsertCallToATLCOMServerInAppSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CInsertCallToATLCOMServerInAppSubsuite class
//

#ifndef __InsertCallToATLCOMServerInAppSubsuite_H__
#define __InsertCallToATLCOMServerInAppSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CInsertCallToATLCOMServerInAppSubsuite class

class CInsertCallToATLCOMServerInAppSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CInsertCallToATLCOMServerInAppSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__InsertCallToATLCOMServerInAppSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertCallToATLCOMServerInApp\InsertCallToATLCOMServerInAppCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	InsertCallToATLCOMServerInAppCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CInsertCallToATLCOMServerInAppCase class

#ifndef __InsertCallToATLCOMServerInAppCase_H__
#define __InsertCallToATLCOMServerInAppCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "InsertCallToATLCOMServerInAppSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CInsertCallToATLCOMServerInAppCase class

class CInsertCallToATLCOMServerInAppCase : public CSystemTestSet
{
	DECLARE_TEST(CInsertCallToATLCOMServerInAppCase, CInsertCallToATLCOMServerInAppSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__InsertCallToATLCOMServerInAppCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertCallToATLCOMServerInApp\InsertCallToATLCOMServerInAppCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	InsertCallToATLCOMServerInAppCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CInsertCallToATLCOMServerInAppCase class

#include "stdafx.h"
#include "InsertCallToATLCOMServerInAppCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CInsertCallToATLCOMServerInAppCase, CSystemTestSet, "Insert Call To ATL COM Server In App", -1, CInsertCallToATLCOMServerInAppSubsuite)

void CInsertCallToATLCOMServerInAppCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CInsertCallToATLCOMServerInAppCase::Run(void)

{	 	
	// open the AppWiz App's main source file.
	LOG->RecordCompare(src.Open(GetCWD() + m_strWorkspaceLoc + m_strAppProjName + ".CPP") == ERROR_SUCCESS, 
		"Open file '%s' for editing", m_strAppProjName + ".CPP");
	
	// find the line where we are supposed to add construction code.
	LOG->RecordCompare(src.Find(GetLocString(IDSS_ADD_CONSTRUCT_CODE_HERE)),
		"Search file '%s' for place to add call to ATL COM server", m_strAppProjName + ".CPP");
	
	// insert the includes for the ATL COM server.
	src.TypeTextAtCursor("{UP 2}{HOME}");
	src.TypeTextAtCursor("#include \"ATL COM Server\\ATL COM Server.h\"{ENTER}");
	src.TypeTextAtCursor("#include \"ATL COM Server\\ATL COM Server_i.c\"{ENTER}");
	
	// insert the CoInitialize and CoCreateInstance calls.
	src.TypeTextAtCursor("{ENTER}{DOWN 2}{TAB}");
	src.TypeTextAtCursor("CoInitialize(NULL);", TRUE);
	src.TypeTextAtCursor("{ENTER}IUnknown *pIUnknown;{ENTER}");

	CString strCoCreateInstanceCall[] = 
	{
		"HRESULT hr = CoCreateInstance(",
		m_strATLCOMServerClsID + ",", 
		"NULL,", 
		"CLSCTX_INPROC_SERVER,", 
		m_strATLCOMServerIID + ",",
		"(void**)&pIUnknown);"
	};

	for(int i = 0; i < 6; i++)
	{
		src.TypeTextAtCursor("{ENTER}");
		src.TypeTextAtCursor(strCoCreateInstanceCall[i], TRUE);
	}

	src.TypeTextAtCursor("{ENTER 2}");
	src.TypeTextAtCursor("ASSERT(SUCCEEDED(hr));", TRUE);
	src.TypeTextAtCursor("{ENTER 2}");

	// need to do this because each subsuite has its own COProject object.
	prj.Attach();

	// select the AppWiz App project so we can rebuild with the changes.
	prj.SetTarget((CString)m_strAppProjName + " - " + 
					GetLocString(IDSS_PLATFORM_WIN32) + " " +
					GetLocString(IDSS_BUILD_DEBUG));

	// build the project.
	LOG->RecordCompare(prj.Build() == ERROR_SUCCESS, 
		"Build '%s' project with call to ATL COM server.", m_strAppProjName);
	
	// verify no errors or warnings were generated.
	int iErr, iWarn;
	LOG->RecordCompare(prj.VerifyBuild(TRUE, &iErr, &iWarn, TRUE) == ERROR_SUCCESS,
		"Verify build of '%s' project with call to ATL COM server", m_strAppProjName);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertInterfaceIntoATLCOMServer\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertInterfaceIntoATLCOMServer\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertCallToATLCOMServerInApp\InsertCallToATLCOMServerInAppSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	InsertCallToATLCOMServerInAppSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CInsertCallToATLCOMServerInAppSubsuite class
//

#include "stdafx.h"
#include "InsertCallToATLCOMServerInAppSubsuite.h"
#include "afxdllx.h"

#include "InsertCallToATLCOMServerInAppCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CInsertCallToATLCOMServerInAppSubsuite, CIDESubSuite, "Insert Call To ATL COM Server In App", "VCQA")

BEGIN_TESTLIST(CInsertCallToATLCOMServerInAppSubsuite)
	TEST(CInsertCallToATLCOMServerInAppCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertInterfaceIntoATLCOMServer\InsertInterfaceIntoATLCOMServerCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	InsertInterfaceIntoATLCOMServerCase.H
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Declaration of the CInsertInterfaceIntoATLCOMServerCase class

#ifndef __InsertInterfaceIntoATLCOMServerCase_H__
#define __InsertInterfaceIntoATLCOMServerCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "InsertInterfaceIntoATLCOMServerSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CInsertInterfaceIntoATLCOMServerCase class

class CInsertInterfaceIntoATLCOMServerCase : public CSystemTestSet
{
	DECLARE_TEST(CInsertInterfaceIntoATLCOMServerCase, CInsertInterfaceIntoATLCOMServerSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__InsertInterfaceIntoATLCOMServerCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertInterfaceIntoATLCOMServer\InsertInterfaceIntoATLCOMServerSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	InsertInterfaceIntoATLCOMServerSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					5/21/97
//
//	Description :
//		implementation of the CInsertInterfaceIntoATLCOMServerSubsuite class
//

#include "stdafx.h"
#include "InsertInterfaceIntoATLCOMServerSubsuite.h"
#include "afxdllx.h"

#include "InsertInterfaceIntoATLCOMServerCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CInsertInterfaceIntoATLCOMServerSubsuite, CIDESubSuite, "Insert Interface Into ATL COM Server", "VCQA")

BEGIN_TESTLIST(CInsertInterfaceIntoATLCOMServerSubsuite)
	TEST(CInsertInterfaceIntoATLCOMServerCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertInterfaceIntoATLCOMServer\InsertInterfaceIntoATLCOMServerSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	InsertInterfaceIntoATLCOMServerSubsuite.h
//
//	Created by :		Date:			
//		MichMa				5/21/97
//
//	Description :
//		Declaration of the CInsertInterfaceIntoATLCOMServerSubsuite class
//

#ifndef __InsertInterfaceIntoATLCOMServerSubsuite_H__
#define __InsertInterfaceIntoATLCOMServerSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CInsertInterfaceIntoATLCOMServerSubsuite class

class CInsertInterfaceIntoATLCOMServerSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CInsertInterfaceIntoATLCOMServerSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__InsertInterfaceIntoATLCOMServerSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\InsertInterfaceIntoATLCOMServer\InsertInterfaceIntoATLCOMServerCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	InsertInterfaceIntoATLCOMServerCase.CPP
//
//	Created by :			Date :
//		MichMa					5/21/97
//
//	Description :
//		Implementation of the CInsertInterfaceIntoATLCOMServerCase class

#include "stdafx.h"
#include "InsertInterfaceIntoATLCOMServerCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CInsertInterfaceIntoATLCOMServerCase, CSystemTestSet, "Insert Interface Into ATL COM Server", -1, CInsertInterfaceIntoATLCOMServerSubsuite)

void CInsertInterfaceIntoATLCOMServerCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CInsertInterfaceIntoATLCOMServerCase::Run(void)
{

	// need to do this because each subsuite has its own COProject object.
	prj.Attach();

	// select the ATL COM Server project so we can add a new object to it.
	prj.SetTarget((CString)m_strATLCOMServerProjName + " - " + 
					GetLocString(IDSS_PLATFORM_WIN32) + " " +
					GetLocString(IDSS_BUILD_DEBUG));

	LOG->RecordCompare(prj.InsertNewATLObject(m_strATLCOMServerInterface) == ERROR_SUCCESS, 
		"Insert new ATL object into '%s' project.", m_strATLCOMServerProjName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn01\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn01\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn01\scn01sub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	scn01sub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CCreateBuildDebugAppWizAppSubSuite class
//

#include "stdafx.h"
#include "scn01sub.h"
#include "afxdllx.h"

#include "scn01.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CCreateBuildDebugAppWizAppSubSuite

IMPLEMENT_SUBSUITE(CCreateBuildDebugAppWizAppSubSuite, CIDESubSuite, "Scenario01", "VCQA")

BEGIN_TESTLIST(CCreateBuildDebugAppWizAppSubSuite)
	TEST(CCreateAppWizAppTest, RUN)
	TEST(CAddDialogTest, RUN)
//	TEST(CAddMenuItemTest, RUN)
//	TEST(CBuildTest, RUN)
//	TEST(CSmallDebugTest, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn01\scn01sub.h ===
///////////////////////////////////////////////////////////////////////////////
//	scn01sub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CCreateBuildDebugAppWizAppSubSuite class
//

#ifndef __scn01sub_H__
#define __scn01sub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CCreateBuildDebugAppWizAppSubSuite class

class CCreateBuildDebugAppWizAppSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CCreateBuildDebugAppWizAppSubSuite)

	DECLARE_TESTLIST()

public:
	COProject m_prj;
	COResScript m_res;
/*	COConnection *m_pconnec;
	CODebug m_dbg;
	COBrowse m_brz;
	COBreakpoints m_bp;
*/
protected:
};

#endif //__scn01sub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn02\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn01\scn01.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	scn01.CPP
//
//	Created by :			Date :
//		YefimS					5/19/97
//
//	Description :
//		Implementation of the CSystemScenario01Test class

#include "stdafx.h"
#include "scn01.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CCreateAppWizAppTest, CSystemTestSet, "CreateAppWizApp", -1, CCreateBuildDebugAppWizAppSubSuite)

void CCreateAppWizAppTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CCreateAppWizAppTest

void CCreateAppWizAppTest::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( CreateAppWizApp() );
	XSAFETY;

}


BOOL CCreateAppWizAppTest::CreateAppWizApp( void )
{
	LogTestHeader("Create AppWiz App with OLE and Context sensitive Help");

	m_strProjLoc  = m_strCWD + m_strAppsRoot + "\\" + m_strWorkspaceName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strAppProjName + "\\";

	RemoveTestFiles( m_strProjLoc );

/*	if (!VERIFY_TEST_SUCCESS( prj.NewAppWiz( m_strAppProjName, m_strProjLoc, PLATFORMS)))
	{
 		m_pLog->RecordFailure("Could not create an Application project");
		return FALSE;
	}
*/

	BOOL bResult;
	
	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	// create a new AppWizard project
	APPWIZ_OPTIONS options;
//	options.m_bUseMFCDLL = CMDLINE->GetBooleanValue("MFCDLL", TRUE); 
	options.m_bUseMFCDLL = TRUE; 

	// The following command line switch is mapped as follows:
	//	0 - APPWIZ_OPTIONS::AW_OLE_NONE (Default)
	//  1 - APPWIZ_OPTIONS::AW_OLE_CONTAINER
	//  2 - APPWIZ_OPTIONS::AW_OLE_MINISERVER (not supported)
	//  3 - APPWIZ_OPTIONS::AW_OLE_FULLSERVER
	//  4 - APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER
	options.m_OLECompound = (APPWIZ_OPTIONS::OLESupport)4;
//	options.m_OLECompound = (APPWIZ_OPTIONS::OLESupport)CMDLINE->GetIntValue("OLE", 4);
//	ASSERT(options.m_OLECompound < 5);

	switch(options.m_OLECompound)
	{
	case APPWIZ_OPTIONS::AW_OLE_NONE:
		GetLog()->RecordInfo("No OLE options selected.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINER:
		GetLog()->RecordInfo("Creating an OLE container application.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_MINISERVER:
		GetLog()->RecordFailure("Creating an OLE mini-server application is not supported by the System sniff.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_FULLSERVER:
		GetLog()->RecordInfo("Creating an OLE full-server application.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER:
		GetLog()->RecordInfo("Creating an OLE container/server application.");
		break;
	default:
		GetLog()->RecordInfo("Invalid OLE option specified: %d  Defaulting to no OLE support", options.m_OLECompound);
		options.m_OLECompound = APPWIZ_OPTIONS::AW_OLE_NONE;
		break;
	}

	options.m_bUseMFCDLL = TRUE; 
	options.m_OLEAuto = 1; 
	options.m_Help = 1; 
	
	::CreateDirectory(m_strCWD + m_strAppsRoot, NULL); //create just in case it does not exist

	bResult = GetLog()->RecordCompare(pPrj->NewAppWiz(m_strAppProjName, m_strCWD + m_strAppsRoot + "\\", PLATFORMS, &options) == ERROR_SUCCESS, "Creating an AppWizard project named '%s'.", m_strAppProjName);
	if (!bResult) {
		throw CTestException("CCreateAppWizAppTest::CreateAppWizApp: cannot create a new AppWizard project; unable to continue.", CTestException::causeOperationFail);
	}

	// turn on browse info file (bsc) generation (off by default).
	bResult = GetLog()->RecordCompare(pPrj->ToggleBSCGeneration(TOGGLE_ON) == ERROR_SUCCESS, "Turning on BSC Generation.", m_strAppProjName);
	if (!bResult) {
		throw CTestException("CCreateAppWizAppTest::CreateAppWizApp: cannot turn on BSC generation; unable to continue.", CTestException::causeOperationFail);
	}

	// change output file location to same as project file (avoid debug, macdbg, pmcdbg, etc).
	bResult = GetLog()->RecordCompare(pPrj->SetOutputFile((CString)m_strAppProjName + ".Exe") == ERROR_SUCCESS, "Resetting output file location.", m_strAppProjName);
	if (!bResult) {
		throw CTestException("CCreateAppWizAppTest::CreateAppWizApp: cannot reset output file location; unable to continue.", CTestException::causeOperationFail);
	}

//	This is a workaround for a known CAFE problem: another workaround is to do Build in a test from a different class (this is used by sys and vproj sniffs).
	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strAppProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}
// end of workaround

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	return TRUE;
}



IMPLEMENT_TEST(CAddDialogTest, CSystemTestSet, "AddDialog", -1, CCreateBuildDebugAppWizAppSubSuite)

void CAddDialogTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CAddDialogTest

void CAddDialogTest::Run(void)
{	// ToDo: strings should be replaced by member variables 
	XSAFETY;
	EXPECT_TRUE( AddMenu("Test", "TestDialog") );
	XSAFETY;
	EXPECT_TRUE( CreateMenuItemMsgHandler("Test", "TestDialog") );
	XSAFETY;
	EXPECT_TRUE( AddDialog("TestDialog", "IDD_TESTDIALOG") );
	XSAFETY;
	EXPECT_TRUE( CreateTestDialogClass("TestDialog") );
	XSAFETY;
	EXPECT_TRUE( ModifyCodeForDialog("TestDialog") );
	XSAFETY;
	EXPECT_TRUE( Build() );
	XSAFETY;

}


BOOL CAddDialogTest::AddDialog( LPCSTR szDialogCaption, LPCSTR szDialogID, LPCSTR szDefaultDialogID /* IDD_DIALOG1 */)
{
	LogTestHeader("Create a Dialog resource, specify the Caption and ID");

	// create a dialog resource
	if (!VERIFY_TEST_SUCCESS( res.CreateResource(IDSS_RT_DIALOG) ))
	{
		m_pLog->RecordFailure("Could not create a dialog resource.");
		return FALSE;
	}
	LogSubTestHeader("SUCCESS: res.CreateResource(IDSS_RT_DIALOG)");

	UIResEditor resEditor;

	if (!VERIFY_TEST_SUCCESS( res.OpenResource(IDSS_RT_DIALOG, szDefaultDialogID, resEditor)))
	{
		m_pLog->RecordFailure("Could not open the dialog resource");
		return FALSE;
	}
	LogSubTestHeader("SUCCESS: res.OpenResource(IDSS_RT_DIALOG, szDefaultDialogID, resEditor)");

	if (!VERIFY_TEST_SUCCESS( res.ChangeDialogCaption( szDialogCaption, resEditor)))
	{
		m_pLog->RecordFailure("Could not change the dialog caption");
		return FALSE;
	}
	LogSubTestHeader("SUCCESS: res.ChangeDialogCaption( szDialogCaption, resEditor)");

	if (!VERIFY_TEST_SUCCESS( res.ChangeDialogID( szDialogID, szDefaultDialogID)))
	{
		m_pLog->RecordFailure("Could not change the dialog caption");
		return FALSE;
	}
	LogSubTestHeader("SUCCESS: res.ChangeDialogID( szDialogID, szDefaultDialogID)");

	UIWorkspaceWindow wnd;
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( res.OpenResource(IDSS_RT_DIALOG, szDialogID, resEditor)));
	EXPECT_TRUE( UIWB.SaveFileAs(m_strAppProjName + ".rc") );
	resEditor.Close();

	return TRUE;
}

BOOL CAddDialogTest::AddMenu( LPCSTR szMenuName, LPCSTR szMenuItem )
{
	LogTestHeader("Add a Menu and a menu item");

//	m_strProjName = APPNAME; // "appwizapp" //ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + m_strAppsRoot + "\\" + m_strAppProjName + "\\";
//	m_strMenuName = MENUNAME;
//	m_strMenuItem = MENUITEM;

	CString strMenuRes = (CString)"IDR_APPWIZTYPE" ;   //ToDo: will replace by m_strAppResourceID
	UIResEditor resEditor;

	if (!VERIFY_TEST_SUCCESS( res.OpenResource(IDSS_RT_MENU, strMenuRes, resEditor)))
	{
		m_pLog->RecordFailure("Could not open the menu resource");
		return FALSE;
	}

	if (!VERIFY_TEST_SUCCESS( res.AddMenu( szMenuName, szMenuItem, resEditor)))
	{
		m_pLog->RecordFailure("Could not add menu");
		return FALSE;
	}

	EXPECT_TRUE( UIWB.SaveFileAs(m_strAppProjName + ".rc") );
	resEditor.Close();

	return TRUE;
}

BOOL CAddDialogTest::CreateMenuItemMsgHandler( LPCSTR szMenuName, LPCSTR szMenuItem )
{
	LogTestHeader("CreateMenuItemMsgHandler");

// Open appwizapp.cpp
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
// Open res editor: it should be opened and frontmost in order to get all IDs in ClassWizard dialog
	CString strMenuRes = (CString)"IDR_APPWIZTYPE" ;   //ToDo: will replace by m_strAppResourceID
	UIResEditor resEditor;

	if (!VERIFY_TEST_SUCCESS( res.OpenResource(IDSS_RT_MENU, strMenuRes, resEditor)))
	{
		m_pLog->RecordFailure("Could not open the menu resource");
		return FALSE;
	}

// Add function for ID_TEST_TESTDIALOG, command
	if (!VERIFY_TEST_SUCCESS( uiclswiz.AddFunction(2,1,"ID_Test_TestDialog")))
	{
		m_pLog->RecordFailure("Could not add a function to class");
		return FALSE;
	}

// Click EditCode
	if (!VERIFY_TEST_SUCCESS( uiclswiz.EditCode()))
	{
		m_pLog->RecordFailure("Could not edit code");
		return FALSE;
	}

	return TRUE;
}

BOOL CAddDialogTest::CreateTestDialogClass( LPCSTR szDialogName )
{
	LogTestHeader("CreateTestDialogClass");

// Create CTestDialog Class	derived from CDialog
	if (!VERIFY_TEST_SUCCESS( uiclswiz.AddClass2
		("CDialog", szDialogName)))
	{
		m_pLog->RecordFailure("Could not add a dialog class");
		return FALSE;
	}
	UIWB.OpenFile( m_strProjLoc + szDialogName + ".cpp" );

	return TRUE;
}

BOOL CAddDialogTest::ModifyCodeForDialog( LPCSTR szDialogName )
{
	LogTestHeader("ModifyCodeForDialog");

// Open appwizapp.cpp
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
// Add #include "testdialog.h"
	src.Find( m_strAppProjName + "View.h" );
	int nLine = src.GetCurrentLine();
//	src.InsertText("#include \"testdialog.h\"", nLine+1, 1);  //Doesn't work
//	src.SetCursor(nLine+1, 1);	//Doesn't work
	MST.DoKeys("{Down}{Home}");
	MST.DoKeys("#include \"testdialog.h\"{Enter}", FALSE);

// Add code to OnTestDialog in appwizapp.cpp
	src.Find( "::OnTestTestDialog" );
	nLine = src.GetCurrentLine();
//	src.InsertText("TestDialog testDlg;\\n     testDlg.DoModal();\\n", nLine+3, 5);	  //Doesn't work
	MST.DoKeys("{Down 3}{Home}");
	MST.DoKeys("    TestDialog testDlg;{Enter}testDlg.DoModal{(}{)};{Enter}", FALSE);

	return TRUE;
}


BOOL CAddDialogTest::Build( void )
{
	LogTestHeader("Build the project");

//	This is a workaround for a known CAFE problem: another workaround is to do Build in a test from a different class (this is used by sys and vproj sniffs).
	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strAppProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}
// end of workaround

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn01\scn01.h ===
///////////////////////////////////////////////////////////////////////////////
//	scn01.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Cscn01Test class

#ifndef __scn01_H__
#define __scn01_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "scn01sub.h"

///////////////////////////////////////////////////////////////////////////////
//	CCreateAppWizAppTest class

class CCreateAppWizAppTest : public CSystemTestSet
{
	DECLARE_TEST(CCreateAppWizAppTest, CCreateBuildDebugAppWizAppSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL CreateAppWizApp();
//	BOOL AddMoreOptions();

// Utilities

};

///////////////////////////////////////////////////////////////////////////////
//	CAddDialogTest class

class CAddDialogTest : public CSystemTestSet
{
	DECLARE_TEST(CAddDialogTest, CCreateBuildDebugAppWizAppSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL AddDialog( LPCSTR szDialogCaption, LPCSTR szDialogID, LPCSTR szDefaultDialogID = "IDD_DIALOG1");
	BOOL AddMenu( LPCSTR szMenuName, LPCSTR szMenuItem );
	BOOL CreateMenuItemMsgHandler(LPCSTR szMenuName, LPCSTR szMenuItem);
	BOOL CreateTestDialogClass(LPCSTR szDialogName);
	BOOL ModifyCodeForDialog(LPCSTR szDialogName);
	BOOL Build( void );

// Utilities

};

#endif //__scn01_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn02\scn02sub.h ===
///////////////////////////////////////////////////////////////////////////////
//	scn02sub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDebugAppWizAppSubSuite class
//

#ifndef __scn02sub_H__
#define __scn02sub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDebugAppWizAppSubSuite class

class CDebugAppWizAppSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CDebugAppWizAppSubSuite)

	DECLARE_TESTLIST()

public:
	COProject m_prj;
	COResScript m_res;

protected:
};

#endif //__scn02sub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn02\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\SQL\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn02\scn02.h ===
///////////////////////////////////////////////////////////////////////////////
//	scn02.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the CDebugAppWizAppSubSuite Test classes

#ifndef __scn02_H__
#define __scn02_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "scn02sub.h"

///////////////////////////////////////////////////////////////////////////////
//	CEditBuildTest class

class CEditBuildTest : public CSystemTestSet
{
	DECLARE_TEST(CEditBuildTest, CDebugAppWizAppSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL AddMemberVar(void);
	BOOL Build(void);
	BOOL EditCode(void);
	BOOL ReBuild(void);

// Utilities

};

///////////////////////////////////////////////////////////////////////////////
//	CDebugTest class

class CDebugTest : public CSystemTestSet
{
	DECLARE_TEST(CDebugTest, CDebugAppWizAppSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL BreakStep(void);
	BOOL LocalsAndWatch(void);
	BOOL CallStack(void);
	BOOL EditAndGo(void);
	BOOL Memory(void);
	BOOL DAM(void);
	BOOL Threads( void );

// Utilities

};

#endif //__scn02_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn02\scn02sub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	scn02sub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDebugAppWizAppSubSuite class
//

#include "stdafx.h"
#include "scn02sub.h"
#include "afxdllx.h"

#include "scn02.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDebugAppWizAppSubSuite

IMPLEMENT_SUBSUITE(CDebugAppWizAppSubSuite, CIDESubSuite, "Scenario02", "VCQA")

BEGIN_TESTLIST(CDebugAppWizAppSubSuite)
	TEST(CEditBuildTest, RUN)
	TEST(CDebugTest, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\SQL\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\scn02\scn02.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	scn02.CPP
//
//	Created by :			Date :
//		YefimS					5/19/97
//
//	Description :
//		Implementation of the CSystemScenario01Test class

#include "stdafx.h"
#include "scn02.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CEditBuildTest, CSystemTestSet, "AddCodeEditBuild", -1, CDebugAppWizAppSubSuite)

void CEditBuildTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CEditBuildTest

void CEditBuildTest::Run(void)
{	 
//	m_strAppProjName = APPNAME; // "appwizapp" //ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strAppProjName + "\\";

	XSAFETY;
	EXPECT_TRUE( AddMemberVar() );
	XSAFETY;
	EXPECT_TRUE( Build() );
	XSAFETY;
	EXPECT_TRUE( EditCode() );
	XSAFETY;
	EXPECT_TRUE( ReBuild() );
	XSAFETY;

}


BOOL CEditBuildTest::AddMemberVar( void )
{
	LogTestHeader("Add a member variable");

	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strAppProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	// Select the appnameApp class
	UIWorkspaceWindow WorkSpaceWnd; //create project workspace window object
	//if project workspace activates properly
	if (WorkSpaceWnd.Activate())  
	{
		//if classview activates properly
		if (WorkSpaceWnd.ActivateClassPane())
		{
//			int ClassSelected = WorkSpaceWnd.SelectClass((CString)"C" + m_strAppProjName + "App", m_strAppProjName);
			int ClassSelected = WorkSpaceWnd.SelectClass(m_strAppClassName, m_strAppProjName);
			if (ClassSelected == 0)  //0 = successful
			{
				LOG->Comment("Class selected properly");
			}
		}
		else
		{
			LOG->RecordFailure("Could not activate ClassView.");
			return FALSE;
		}
	}
	else
	{
		LOG->RecordFailure("Could not activate project workspace window.");
		return FALSE;
	}

	// Next code should be replaced by some support layer call when it is created
	// open the Add Member Variable Dialog and type in the Type and Name
	MST.DoKeys( "+{F10}" );
	MST.DoKeys( "{Down 3}{Enter}" );
	MST.DoKeys( "int{Tab}");
	MST.DoKeys( "m_IntVar{Enter}" );
	// end of replacable code

	// Add assignment code
	// Open appwizapp.cpp
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
// Add m_IntVar = 5 + 6;
	src.Find( "LoadStdProfileSettings" );
//	int nLine = src.GetCurrentLine();
//	src.InsertText("m_IntVar = 5 + 6;", nLine+1, 1);  //Doesn't work
	MST.DoKeys("{Down}{Home}");
	MST.DoKeys("    m_IntVar = 5 {+} 6;{Enter}", FALSE);

	return TRUE;
}

BOOL CEditBuildTest::Build( void )
{
	LogTestHeader("Build the project");

//	This is a workaround for a known CAFE problem: another workaround is to do Build in a test from a different class (this is used by sys and vproj sniffs).
	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strAppProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}
// end of workaround

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.VerifyBuild()));

	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	return TRUE;
}

BOOL CEditBuildTest::EditCode( void )
{
	LogTestHeader("Edit code");

	// Edit assignment code	and add more
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
	src.Find( "m_IntVar = 5 + 6;" );
	MST.DoKeys("{Down}{Home}");
	MST.DoKeys("    for{(} int ii = 0; ii < 20; ii{+}{+}{)}{Enter}", FALSE);
	MST.DoKeys("{{}{Enter}", FALSE);
	MST.DoKeys("m_IntVar = ii;{Enter}", FALSE);
	MST.DoKeys("{}}{Enter}", FALSE);

	return TRUE;
}

BOOL CEditBuildTest::ReBuild( void )
{
	LogTestHeader("Rebuild the project");

//	This is a workaround for a known CAFE problem: another workaround is to do Build in a test from a different class (this is used by sys and vproj sniffs).
	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strAppProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}
// end of workaround

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.VerifyBuild()));

	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	return TRUE;
}



IMPLEMENT_TEST(CDebugTest, CSystemTestSet, "Debug", -1, CDebugAppWizAppSubSuite)

void CDebugTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CDebugTest

void CDebugTest::Run(void)
{
	// ToDo: strings should be replaced by member variables 
//	m_strAppProjName = APPNAME; // "appwizapp" //ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + m_strAppsRoot + "\\" + m_strAppProjName + "\\";

	XSAFETY;
	EXPECT_TRUE( BreakStep() );
	XSAFETY;
	EXPECT_TRUE( LocalsAndWatch() );
	XSAFETY;
	EXPECT_TRUE( CallStack() );
	XSAFETY;
	EXPECT_TRUE( EditAndGo() );
	XSAFETY;
	EXPECT_TRUE( Memory() );
	XSAFETY;
	EXPECT_TRUE( DAM() );
	XSAFETY;
	EXPECT_TRUE( Threads() );
	XSAFETY;

}


BOOL CDebugTest::BreakStep( void )
{
	LogTestHeader("Set a conditional BP, execute to break and step");

	bp.ClearAllBreakpoints();
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
	EXPECT_TRUE( src.Find( "m_IntVar = ii;" ) );

	// TODO(michma 2/9/98): this is just in here to nail that stupid build problem where it asks to build
	// when it shouldn't.
	//EXPECT_TRUE( dbg.StepToCursor(0, NULL, "m_IntVar = ii;") );
	EXPECT_TRUE(dbg.StepToCursor(NULL, NULL, NULL, NULL, NOWAIT));
	Sleep(1000);

	if(MST.WButtonExists("@1"))
	{
		CString str;
		MST.WStaticText("@2", str);
		m_pLog->RecordFailure("Got a button when we shouldn't have. The message text is \"%s\".", str);
		return FALSE;
	}

	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("m_IntVar = ii;"));

	EXPECT_TRUE( bp.SetBreakOnExpr((CString)"{" + m_strAppClassName + "::InitInstance," + m_strProjLoc + m_strAppProjName + ".cpp," + m_strProjLoc + m_strAppProjName + ".exe}(m_IntVar==6)", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.Go(NULL,NULL,NULL,0);
	if( WaitMsgBoxText("m_IntVar==6", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break ... when 'm_IntVar==6'\" was found as expected" );
		MST.WButtonClick( "OK" ); 
		EXPECT_TRUE_COMMENT( TRUE, "BreakAtLocationWithConditionExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break ... when 'm_IntVar==6'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "}" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==6",1) );

	// do some stepping
	EXPECT_TRUE( dbg.StepInto(1, NULL, "for(") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, "m_IntVar = ii;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "m_IntVar = ii;") );
//	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==7",1) );
	EXPECT_TRUE( dbg.StepInto(1, NULL, "}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==8",1) );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "for(") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "m_IntVar = ii;") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==9",1) );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==10",1) );

	return TRUE;
}

BOOL CDebugTest::LocalsAndWatch( void )
{
	LogTestHeader("Watch a local and modify");

	EXPR_INFO watch_info_actual[10], watch_info_expected[10];

	// Put the var in the Watch window and verify the value
	uiwatch.Activate();
	EXPECT_SUCCESS(uiwatch.SetName("m_IntVar"));
	EXPECT_SUCCESS(uiwatch.GetAllFields(watch_info_actual, 1, ROW_ALL));
	FillExprInfo(watch_info_expected[0], NOT_EXPANDABLE, "int", "m_IntVar", "10");
	EXPECT_TRUE(ExprInfoIs(watch_info_actual, watch_info_expected, 1));

	// Change value of the local m_IntVar
	EXPECT_SUCCESS(uiwatch.SetValue("5", 1));
	RestoreFocusToSrcWnd();
	EXPECT_TRUE( dbg.StepOver(1, NULL, "for(") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==5",1) );

	LogSubTestHeader("VerifyLocalVarUpdate");
	EXPECT_TRUE(dbg.StepOver(2));
	uivar.Activate();

	if(!uivar.SetPane(PANE_AUTO) == ERROR_SUCCESS)
	{
		m_pLog->RecordInfo("ERROR: could not activate Auto pane");
		return FALSE;
	}
	
	EXPECT_SUCCESS(uivar.GetAllFields(watch_info_actual, 2, ROW_ALL));
	FillExprInfo(watch_info_expected[0], NOT_EXPANDABLE, "int", "m_IntVar", "11");
	EXPECT_TRUE(ExprInfoIs(watch_info_actual, watch_info_expected, 1));
	RestoreFocusToSrcWnd();

	return TRUE;
}

BOOL CDebugTest::CallStack( void )
{
	LogTestHeader("CallStack: Navigate");

	CString fnName;
	CString szTitle;
	UIEditor editor;

	bp.ClearAllBreakpoints();

	LogSubTestHeader( "Navigate to AfxWinMain" );
	EXPECT_TRUE( stk.NavigateStack( "AfxWinMain" )>0 );
	MST.WFndWndWait("Winmain.cpp", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle.Find("Winmain.cpp") );

 	LogTestHeader( "Navigate to WinMain" );
	EXPECT_TRUE( stk.NavigateStack( "WinMain" )>0 );
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle.Find("Appmodul.cpp") );

 	LogTestHeader( "Navigate back to InitInstance" );
	EXPECT_TRUE( stk.NavigateStack( "InitInstance" )>0 );
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle.Find(m_strAppProjName + ".cpp") );
	EXPECT_TRUE( editor.Close() );

	return TRUE;
}

BOOL CDebugTest::EditAndGo( void )
{
	LogTestHeader("Edit code, build, execute the modified code");

	dbg.StopDebugging();

	LogSubTestHeader("EditCode");
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
	src.Find( "ii < 20" );
	MST.DoKeys("ii < 5", FALSE);
	src.Find( "m_IntVar = ii;" );
	MST.DoKeys("m_IntVar {+}= ii;{Enter}", FALSE);
	MST.DoKeys("m_IntVar *= 2;", FALSE);

	LogSubTestHeader("BuildProjectAndVerify");
//	This is a workaround for a known CAFE problem: another workaround is to do Build in a test from a different class (this is used by sys and vproj sniffs).
	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strAppProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}
// end of workaround
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.VerifyBuild()));

	LogSubTestHeader("Execute");
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
	src.Find( "m_IntVar += ii;" );

	// TODO(michma 2/9/98): this is just in here to nail that stupid build problem where it asks to build
	// when it shouldn't.
	//EXPECT_TRUE( dbg.StepToCursor(0, NULL, "m_IntVar += ii;") );
	EXPECT_TRUE(dbg.StepToCursor(NULL, NULL, NULL, NULL, NOWAIT));
	Sleep(1000);

	if(MST.WButtonExists("@1"))
	{
		CString str;
		MST.WStaticText("@2", str);
		m_pLog->RecordFailure("Got a button when we shouldn't have. The message text is \"%s\".", str);
		return FALSE;
	}

	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("m_IntVar += ii;"));
	
	EXPECT_TRUE( dbg.StepInto(2, NULL, "}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==22",1) );
	EXPECT_TRUE( dbg.StepOver(8, NULL, "}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==96",1) );

	dbg.Restart();
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
	src.Find( "m_IntVar += ii;" );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "m_IntVar += ii;") );
	EXPECT_TRUE( dbg.StepInto(18, NULL, "}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_IntVar==404",1) );
	EXPECT_TRUE( dbg.StepOver(2) );

	return TRUE;
}

BOOL CDebugTest::Memory( void )
{
	LogTestHeader("Memory window: go to symbol and modify");

	bp.ClearAllBreakpoints();
	dbg.Restart();
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
	src.Find( "m_IntVar += ii;" );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "m_IntVar += ii;") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, "}") );
	UIWB.SetMemoryFormat(MEM_FORMAT_BYTE);                                                // verify endian (white-box test)
	uimem = UIDebug::ShowDockWindow(IDW_MEMORY_WIN);
	uimem.GoToAddress("m_IntVar");
	CString Bytes = uimem.GetCurrentData(4);
	EXPECT_TRUE(Bytes == "16 00 00 00 ");

	return TRUE;
}

BOOL CDebugTest::DAM( void )
{
	LogTestHeader("Disassembly: do some stepping and toggle DAM/SRC");

	dbg.Restart();
	UIWB.OpenFile( m_strProjLoc + m_strAppProjName + ".cpp" );
	src.Find( "m_IntVar += ii;" );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "m_IntVar += ii;") );

	dbg.SetSteppingMode(ASM);

	EXPECT_TRUE( dbg.StepInto(4) );
	EXPECT_TRUE( dbg.StepOver(2) );

	//trace 
	while ( !cxx.ExpressionValueIs("m_IntVar==96",1))
	{
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( cxx.ExpressionValueIs("m_IntVar==96",1) );

	dbg.SetSteppingMode(SRC);

	src.Find( "m_IntVar *= 2;" );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "m_IntVar *= 2;") );

	dbg.SetSteppingMode(ASM);
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "AfxWinMain") );
	dbg.StopDebugging();

	return TRUE;
}

BOOL CDebugTest::Threads( void )
{
	LogTestHeader("Threads dialog check out");

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\SQL\SQLDebugSuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	SQLDebugSuite.h
//
//	Created by :		Date:			
//		CHRISKO				5/21/97
//
//	Description :
//		Declaration of the CSQLDebugSuite class
//

#ifndef __SQLDebugSuite_H__
#define __SQLDebugSuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSQLDebugSuite class

class CSQLDebugSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CSQLDebugSuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__SQLDebugSuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\SQL\SQLDebugSuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SQLDebugSuite.CPP
//
//	Created by :			Date :			
//		CHRISKO					5/21/97
//
//	Description :
//		implementation of the CSQLDebugSuite class
//

#include "stdafx.h"
#include "SQLDebugSuite.h"
#include "afxdllx.h"

#include "SQLDebugCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSystemSubSuite

IMPLEMENT_SUBSUITE(CSQLDebugSuite, CIDESubSuite, "SQL debugging", "VCQA")

BEGIN_TESTLIST(CSQLDebugSuite)
	char buff[1024];
TEST(CSQLDebugCase, (GetLang()==CAFE_LANG_ENGLISH?RUN:DONTRUN))
	strcpy(buff,"SVR- ");
	strcat(buff,m_SuiteParams->GetTextValue("SERVER", "GALSQL1"));
	strcat(buff,"; DB- ");
	strcat(buff,m_SuiteParams->GetTextValue("DATABASE", "pubs"));
	strcat(buff,"; USER- ");
	strcat(buff,m_SuiteParams->GetTextValue("USER", "sa"));
	strcat(buff,"; PWD- ");
	strcat(buff,m_SuiteParams->GetTextValue("PWD"));
	pTest->SetName(buff);
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\SQL\SQLDebugCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	SQLDebugCase.H
//
//	Created by :			Date :
//		CHRISKOZ					5/21/97
//
//	Description :
//		Declaration of the CSQLDebugCase class

#ifndef __SQLDebugCase_H__
#define __SQLDebugCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\sysset.h"
#include "SQLDebugSuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CSQLDebugCase class

class CSQLDebugCase : public CSystemTestSet
{
	DECLARE_TEST(CSQLDebugCase, CSQLDebugSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
	
	void CreateFileDSN(LPCSTR DSN,LPCSTR ServerName, LPCSTR DBName, LPCSTR User, LPCSTR Pwd);
	void CreateDBProjectInCurrentWksp(LPCSTR ServerName,LPCSTR DBName, LPCSTR User, LPCSTR Pwd);
	void InsertStoredProcs(LPCSTR ServerName,LPCSTR DBName, LPCSTR User, LPCSTR Pwd);
	void DebugSP(LPCSTR Server,LPCSTR strDBName, LPCSTR User, LPCSTR Pwd);
	void CopySQLFile(CString &m_Source,CString &m_Dest, LPCSTR User, LPCSTR FName);
	BOOL StoredProcParam(LPCSTR Params =NULL);

private:
	COProject m_prj;
	CString m_SQLProjectName;
	CString m_DSN;
	CString m_User;
	CString m_Pwd;
	CString m_Computername;
};

#endif //__SQLDebugCase_H__

//utility functions
void CopySQLFile(CString &m_Source,CString &m_Dest,LPCSTR FName);
void NewSP(LPCSTR filename);


void CollapseObjects();
void ExpandTable(LPCSTR Server,LPCSTR DBName,LPCSTR strTableName);
BOOL SelectDatabase(LPCSTR Server,LPCSTR strDBName);
int ExpandDatabase(LPCSTR Server,LPCSTR strDBName);
void ExpandProcedureNode(LPCSTR Server,LPCSTR strDBName);
void ExpandTableNode(LPCSTR Server,LPCSTR strDBName);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Snap\SQL\SQLDebugCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SQLDebugCase.CPP
//
//	Created by :			Date :
//		CHRISKOZ					5/21/97
//
//	Description :
//		Implementation of the CSQLDebugCase class

#include "stdafx.h"
#include "SQLDebugCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CSQLDebugCase, CSystemTestSet, NULL, -1, CSQLDebugSuite)

void CSQLDebugCase::PreRun(void)
{
	if(GetSystem() & SYSTEM_DBCS)//REVIEW(chriskoz): note doubled character '\' - compiler treats it as ESC sequence
		m_SQLProjectName = "[\\]^{|}Aa`@~ SQL Project";
	else
		m_SQLProjectName ="SQL Project";

	// call the base class
	CTest::PreRun();
}

void CSQLDebugCase::Run(void)
{
	if(GetLang()!=CAFE_LANG_ENGLISH)
		return;
//	XSAFETY;
	CString m_Server;
	CString m_DataBase;
	m_Server=GetSubSuite()->m_SuiteParams->GetTextValue("SERVER", "DLAB1");
	m_DataBase=GetSubSuite()->m_SuiteParams->GetTextValue("DATABASE", "pubs");
	m_User=GetSubSuite()->m_SuiteParams->GetTextValue("USER", "sa");
	m_Pwd=GetSubSuite()->m_SuiteParams->GetTextValue("PWD");

	prj.Open(GetCWD() + m_strWorkspaceLoc + m_strWorkspaceName + ".DSW");

	CreateDBProjectInCurrentWksp(m_Server,m_DataBase,m_User,m_Pwd);
	InsertStoredProcs(m_Server, m_DataBase,m_User,m_Pwd);
	DebugSP(m_Server, m_DataBase,m_User,m_Pwd);
}


void CSQLDebugCase::CreateFileDSN(LPCSTR DSN,LPCSTR ServerName, LPCSTR DBName,LPCSTR User, LPCSTR Pwd)
{
	CStdioFile fileDSN(DSN, CFile::modeCreate | CFile::modeWrite | CFile::typeText);
		
	fileDSN.WriteString("[ODBC]\nDRIVER=SQL Server\nUID=");
	fileDSN.WriteString("sa");
		
	fileDSN.WriteString("\nDATABASE=");
	fileDSN.WriteString(DBName);
		
	fileDSN.WriteString("\nWSID=");
	DWORD length = MAX_COMPUTERNAME_LENGTH+1;
	char lpszNetName[MAX_COMPUTERNAME_LENGTH+1];
	if (!GetComputerName(lpszNetName, &length))
		strcpy(lpszNetName, "[ErrorComputerName]");
	m_Computername=lpszNetName;
	fileDSN.WriteString(lpszNetName);
		
	fileDSN.WriteString("\nAPP=");
	CString str;
	str.Format("%s - Owner: %s", (LPCSTR)GetSubSuite()->GetName(), (LPCSTR)GetSubSuite()->GetOwner());
	fileDSN.WriteString(str);
	
	fileDSN.WriteString("\nSERVER=");
	fileDSN.WriteString(ServerName);
	fileDSN.WriteString("\n");
} //CreateFileDSN()


void CSQLDebugCase::CreateDBProjectInCurrentWksp(LPCSTR ServerName,LPCSTR DBName,LPCSTR User, LPCSTR Pwd)
{
//	sprintf(m_DSN,
	KillAllFiles(GetCWD() + m_SQLProjectName);
	m_DSN=GetCWD() + m_SQLProjectName + "\\" + ServerName + ".DSN"; //name of file datasource
	::CreateDirectory(GetCWD() + m_SQLProjectName, NULL);

	CreateFileDSN(m_DSN, ServerName, DBName,User,Pwd);

	BOOL bResult=m_prj.NewProject(DATABASE_PROJECT,
		m_SQLProjectName,GetCWD()+m_SQLProjectName,
		GetUserTargetPlatforms(),TRUE);
	if(!LOG->RecordCompare(bResult == ERROR_SUCCESS,"Creating the DB projecct"))
			throw CTestException("Cannot create DB project; unable to continue.\n", 
					CTestException::causeOperationFail);   
	bResult=m_prj.AddSQLDataSource(m_DSN,CString(User),CString(Pwd),DBName);
	if(!LOG->RecordCompare(bResult == ERROR_SUCCESS, 
			"Opening the SQL Server '%s' database %s.",
			ServerName,
			DBName))
			throw CTestException("Cannot establish the connection; unable to continue.\n", 
					CTestException::causeOperationFail);
} //CreateDBProjectInCurrentWksp()


void CSQLDebugCase::InsertStoredProcs(LPCSTR ServerName,LPCSTR DBName,LPCSTR User, LPCSTR Pwd)
{
	CString m_Source=GetCWD();
	CString m_Dest=GetCWD() + m_SQLProjectName + "\\";
	CopySQLFile(m_Source, m_Dest, User, "DELETE.SQL");
	CopySQLFile(m_Source, m_Dest, User, "inner_upd.SQL");
	CopySQLFile(m_Source, m_Dest, User, "Cursor_emp.SQL");
	
	if(ExpandDatabase(ServerName,DBName)!=ERROR_SUCCESS)
		LOG->RecordFailure("Didn't expand database");
	UIWB.OpenFile( m_Dest + "DELETE.SQL");
	UIWB.DoCommand(IDM_TOOLS_RUNMENU, DC_MNEMONIC); //&Tools.&Run
	Sleep(3000); //no other way to determine if it's finished
	
	ExpandProcedureNode(ServerName,DBName);
	NewSP(m_Dest + "inner_upd.SQL");

	ExpandProcedureNode(ServerName,DBName);
	NewSP(m_Dest + "Cursor_emp.SQL");
	
	UIWB.DoCommand(IDM_FILE_SAVE_ALL, DC_MNEMONIC);
	WaitForInputIdle(g_hTargetProc, 5000);
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
	WaitForInputIdle(g_hTargetProc, 5000);

	XSAFETY;
} //InsertStoredProcs()


void CSQLDebugCase::CopySQLFile(CString &m_Source,CString &m_Dest, LPCSTR User, LPCSTR FName)
{
	CStdioFile fileDest(m_Dest + FName, CFile::modeCreate | CFile::modeWrite | CFile::typeText);
	CStdioFile fileSource(m_Source + FName, 	CFile::modeRead | CFile::typeText);

	CString strUser;
	
	if(strcmp(User,"sa")==0)
		strUser="dbo";
	else
		strUser=CString(User);

    CString str;
    const int len=255;
    char buf[len],dest[len];
	char *pservername,*prestline;

	BOOL done=FALSE;
	while(fileSource.ReadString(buf, len))
	{
		while((pservername=strstr(buf,"$(MACHINE)"))!=NULL)
		{
			prestline=pservername+strlen("$(MACHINE)");
			pservername[0]=0; //cut the "$(MACHINE)"
			strcat(strcat(strcpy(dest,buf),m_Computername),prestline);
			strcpy(buf,dest);
		}
		while((pservername=strstr(buf,"$(USER)"))!=NULL)
		{
			prestline=pservername+strlen("$(USER)");
			pservername[0]=0; //cut the "$(USER)"
			strcat(strcat(strcpy(dest,buf),strUser),prestline);
			strcpy(buf,dest);
		}
		fileDest.WriteString(buf);	
//		fileDest.WriteString("\n");  //looks like the CRLF is included in "buf" string
	}	
} //CopySQLFile()


BOOL StepInUntilFrameAdded( CString addframe );


void CSQLDebugCase::DebugSP(LPCSTR Server,LPCSTR strDBName,LPCSTR User, LPCSTR Pwd)
{
	CString strOutterproc(CString("Cursor_emp")+m_Computername);
	CString strInnerproc(CString("inner_upd")+m_Computername);
	CString strTrigger("employee_insupd");
	CString strUserPrefix;
	
	if(strcmp(User,"sa")==0)
		strUserPrefix="dbo.";
	else
		strUserPrefix=CString(User) + '.';
	ExpandProcedureNode(Server,strDBName);
	MST.DoKeys(strOutterproc,TRUE,1000);
	Sleep(1000); //extra safety
	MST.DoKeys("+{F10}");
	Sleep(1000);
	MST.DoKeys("b"); //debug

	BOOL bPass = TRUE;
	CODebug dbg;
	COStack stk;
	COBreakpoints bp1;

	bPass=StoredProcParam("2"); //waits for parameters dialog and suply it with "2"

	// we expect sql debugging to fail on pro and learning edition.
	DWORD dwProductType = GetProductType();

	if(!bPass && ((dwProductType == VC_PRO) || (dwProductType == VC_LRN)))
		return;

	if(!LOG->RecordCompare(bPass == TRUE, 
			"Starting debugging stored procedure'%s'",
			strOutterproc))
			throw CTestException("Cannot establish the connection; unable to continue.\n", 
					CTestException::causeOperationFail);
	
	COSource src;
	src.AttachActiveEditor();

	EXPECT_TRUE( src.Find("execute inner_upd") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "execute inner_upd") );

	CString empid;
	CString fname;
	CString lname;
	COExpEval ee;

//check the @fname & @lname & store them
	ee.GetExpressionValue("@empid",empid);
	LOG->RecordInfo("Got the value for @empid:'%s'", empid);
	ee.GetExpressionValue("@fname",fname);
	LOG->RecordInfo("Got the value for @fname:'%s'", fname);
	ee.GetExpressionValue("@lname",lname);
	LOG->RecordInfo("Got the value for @lname:'%s'", lname);
	EXPECT_TRUE( !empid.IsEmpty() && !fname.IsEmpty() && !lname.IsEmpty() );
	
	EXPECT_TRUE( dbg.StepInto(1, NULL, "if(@id=NULL)") );
	EXPECT_TRUE(StepInUntilFrameAdded("dbo." + strTrigger) ); //this trigger is always owned by dbo

	EXPECT_TRUE( stk.NavigateStack( strUserPrefix +  strOutterproc + "(int 2)")>0 ); //suplied param - "2"
	EXPECT_TRUE( src.Find("exec inner_upd") );

	bp1.SetBreakpoint(); //put a BP at the second invocation of inner_upd

	EXPECT_TRUE( stk.NavigateStack( strUserPrefix +  strInnerproc)>0 );
	EXPECT_TRUE( stk.NavigateStack( "dbo." +  strTrigger)>0 ); //this trigger is always owned by dbo
	src.AttachActiveEditor();

	EXPECT_TRUE( src.Find( "IF (@job_id = 1) and (@emp_lvl <> 10)" ) );

	bp1.SetBreakpoint(); //put a BP in the trigger
	EXPECT_TRUE( dbg.Go( NULL, "IF (@job_id = 1) and (@emp_lvl <> 10)") );

 //change the @job_id value in watches & check if expression changed
		char job_id[30];
		CString strjobid;
		EXPECT_TRUE(ee.GetExpressionValue("@job_id", strjobid) );
		strncpy(job_id, strjobid, 30);
		UIWatch watch;
		watch.Activate();
		watch.SetName("@job_id", 1);
		watch.SetValue(_itoa(atoi(job_id)+1,job_id,10), 1);
		EXPECT_TRUE( ee.ExpressionValueIs("@job_id",job_id) );

		EXPECT_TRUE(MST.WFndWndWait(strTrigger, FW_FOCUS | FW_PART, 2) ); //UIWatch steals the focus
		src.AttachActiveEditor(); 

	EXPECT_TRUE( dbg.Go( NULL, "exec inner_upd") ); //must've hit the second invocation
//check if @Fname & @lname are the same as stored but switched
		EXPECT_TRUE( ee.ExpressionValueIs("@empid",empid) );
#pragma message (__LOC__ "change COMMENT to FAIL below when VC98#3725 is fixed")
		EXPECT_TRUE_COMMENT( ee.ExpressionValueIs("@fname",lname), "fname test:");
		EXPECT_TRUE_COMMENT( ee.ExpressionValueIs("@lname",fname), "lname test:");
//change the string value in the EE
		EXPECT_TRUE( ee.SetExpressionValue("@pchMsg","'Message changed in debugger'") );

//change the SQL param & expect it to change in the Stack
		watch.Activate();
		watch.SetName("@NumbeR", 2); //SQL server case insensitive
		watch.SetValue("3", 2); //change the param to "3"
#pragma message (__LOC__ "change \"int 2\" to \"int 3\" below when VC98#3722 is fixed")
		EXPECT_TRUE(stk.Index(strUserPrefix +  strOutterproc + "(int 2)")==0); //param changed to 1
		EXPECT_TRUE(MST.WFndWndWait(strTrigger, FW_FOCUS | FW_PART, 2) ); //UIWatch steals the focus
		src.AttachActiveEditor(); 
		

	EXPECT_TRUE( dbg.StepOver(1, NULL, "IF (@job_id = 1) and (@emp_lvl <> 10)") ); //stepover the BP which shld be hit

#pragma message (__LOC__ "change COMMENT to FAIL below when VC98#3614 is fixed")
	EXPECT_TRUE_COMMENT( dbg.Go( NULL, NULL, NULL, ASSUME_NORMAL_TERMINATION), "Terminated:");
#pragma message ("Add to execute sth in another database when Azeem checks in VC98#1984 fix in SDI50.dll")
} //DebugSP()

BOOL StepInUntilFrameAdded( CString addframe )
{
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line
	framelist0.CreateFromText( stk.GetAllFunctions() );
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		current.CreateFromText( stk.GetAllFunctions() );

		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					LOG->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ){
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					LOG->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				LOG->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					LOG->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() + 1 ) {
			// Test new top frame
			bResult = Frame( current[0] ).Test( addframe );

			// Only check function name or image name for 2nd frame since the line number
			// may change.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					LOG->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					LOG->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else {
				// Bad format
				LOG->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame+1];
				if( !bResult ) {
					LOG->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[iFrame+1], (LPCTSTR)framelist0[iFrame] );
				}
			}
			break;	// Get out of loop

		}
		else {
			// Unexpected number of frames
			LOG->RecordInfo( "StepInUntilFrameAdded - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}



////////////////////////////////////////////////////////////////////////////
// utility functions
//waits up to 60 seconds to STored Procedure params dialog to come up
BOOL ExecSPParam(LPCSTR Params /*=NULL*/)
{
	int nSec=2;
	CString str;
	int ret=ERROR_SUCCESS;
	BOOL bExecuting=FALSE;
	while (nSec>0)
	{
		MST.WGetText(NULL, str);
		if(Params!=NULL &&
			str.Find(GetLocString(IDSS_RUN_STOREDPROC)) >=0)
		{
			LPCSTR pparam=strtok((char*)Params," \t\n");
			while(pparam!=NULL)
			{
				MST.DoKeys(pparam, TRUE, 1000); //suply next param
				MST.DoKeys("{Down}", FALSE, 1000); //go to the next row in a grid
				pparam=strtok(NULL," \t\n");
			}
			MST.WButtonClick(GetLabel(IDOK)); // accept params
			bExecuting=TRUE;
			Sleep(2000);
			break;
		}
		if (nSec > 0) // If we still have some waiting time...
		{
			LOG->RecordInfo("Current wnd title: %s",str);
			LOG->RecordInfo("Waiting up to %d more second(s) for SP to execute",nSec);
			nSec--;
			Sleep(1000);
		}
	} //while */
	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())// If we can attach, an error must've occurred.
	{
		ret = ERROR_ERROR;
		wndMsgBox.ButtonClick();
	}
//TODO: maybe wait for the message about the execution finished
	return ret;
} //ExecSPParam


BOOL CSQLDebugCase::StoredProcParam(LPCSTR Params /*=NULL*/)
{
	int nSec=60;
	BOOL bFound=FALSE;
	while (nSec>0)
	{
		CString str;
		CString szTitleBreak  = "[";
		szTitleBreak+=GetLocString(IDSS_DBG_BREAK);
		szTitleBreak+="]";
		MST.WGetText(NULL, str); //should be ServerName - APPNAME"
		nSec--;
		if(str.Find(GetLocString(IDSS_WORKBENCH_TITLEBAR))>=0 &&
			str.Find(szTitleBreak)>=0)
		{
			LOG->RecordSuccess("Found the break in the window title");
			Sleep(1000); //break in window title is up, but XTRA safety required!
			bFound = TRUE;
			break;
		}
		else if(str.Find(GetLocString(IDSS_RUN_STOREDPROC)) >=0)
		{	// the SQL param dlg popped up
			BOOL bResult=ExecSPParam(Params); //enter the params
			
			if(bResult==ERROR_ERROR)
				break; //SP params didn't pass so return FALSE
		}
		else
		
		{	
			if (nSec > 0) // If we still have some waiting time...
			{
				LOG->RecordInfo("Current wnd title: %s",str);
				LOG->RecordInfo("Expected wnd title: %s %s", GetLocString(IDSS_WORKBENCH_TITLEBAR),szTitleBreak);
				LOG->RecordInfo("Waiting up to %d more second(s) for an expected window",nSec);
				Sleep(1000);
			}

			else
			
			{
				// we expect sql debugging to fail against pro and learning edition.
				DWORD dwProductType = GetProductType();

				if((dwProductType == VC_PRO) || (dwProductType == VC_LRN))
					LOG->RecordSuccess("SQL debugging failed on non-Enterprise product.");
				else
					// We've timed out.
					LOG->RecordFailure("Timeout waiting for the Devstudio window");
			}
		}
	} //while */
	return bFound;
}



void NewSP(LPCSTR filename)
{	
	MST.DoKeyshWnd(UIWB.HWnd(), "+{F10}");
	Sleep(1000); //xtra safety
	MST.DoKeyshWnd(UIWB.HWnd(), "{Home}");
	MST.WMenu("Ne&w Stored Procedure");

	COSource srcFile;

	srcFile.AttachActiveEditor();
	UIWB.DoCommand(ID_EDIT_SELECT_ALL, DC_MNEMONIC); //select all
	CStdioFile fileSource(filename,	CFile::modeRead | CFile::typeText);
    const int len=255;
    char buf[len];
	while(fileSource.ReadString(buf, len))
	{
		srcFile.TypeTextAtCursor(buf,TRUE);
		srcFile.TypeTextAtCursor("{ENTER}{HOME}",FALSE);
	}
} //NewSP



void CollapseObjects()
{
	MST.DoKeys("{Left}"); // goto the table
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{NUMPAD-}");// collapse table tree
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{Left}"); // goto the parent node
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{NUMPAD-}"); // collapse the expanded object
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{Left}"); // goto the parent node
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{NUMPAD-}");// collapse objects' tree
}


void ExpandTable(LPCSTR Server,LPCSTR DBName,LPCSTR strTableName)
{
	ExpandDatabase(Server,DBName);
	ExpandTableNode(Server,DBName);
	MST.DoKeys(strTableName);
	Sleep(2000); 			// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");
	Sleep(500); 			// Xtra Wait
}



BOOL SelectDatabase(LPCSTR Server,LPCSTR strDBName)
{
	UIWorkspaceWindow wnd;
 	int ret=ERROR_SUCCESS;
	Sleep(1000); //Xtra safety
	wnd.ActivateDataPane();

	MST.DoKeys("^{HOME}");				// Go to top of tree
	MST.DoKeys("{NUMPAD-}");
	Sleep(500);
	MST.DoKeys("{NUMPAD+}");	// deploy the first level
	Sleep(500);
	//TODO this sequence can be changed
	MST.DoKeys(strDBName,TRUE);
	MST.DoKeys(" (",TRUE);
	MST.DoKeys(Server,TRUE);
	
	MST.DoKeys("%({Enter})"); //bring up the properties
	BOOL bReady = FALSE;
	int nSec = 5;
	while (!bReady && ret == ERROR_SUCCESS)
	{
			// Attempt to open the property page for the Data Source
			

			CString str;
			MST.WGetText(NULL, str);
	//		if(str.Find(GetLocString(IDSS_PROP_TITLE))>0)
	//			nSec=2; //properties window is up, but XTRA safety required!
			if (MST.WStaticExists(Server) && MST.WStaticExists(strDBName))
			{
				LOG->RecordSuccess("Found the DataSource properties");
				bReady = TRUE;
			}
			else
			{
				if (--nSec > 0)	// If we still have some waiting time...
				{
//					LOG->RecordInfo("Waiting up to %d more second(s) for datasource properties...", nSec);
					Sleep(1000);
				}
				else				// We've timed out.
				{
					LOG->RecordInfo("Didn't find the Datasource properties");
					ret = ERROR_ERROR;
				}
			}
	} //while
	MST.DoKeys("{Escape}");
	Sleep(2001); //timing problem hit when switched to mstest4.0
	return ret;		
}


int ExpandDatabase(LPCSTR Server,LPCSTR strDBName)
{
	if (SelectDatabase(Server,strDBName)!=ERROR_SUCCESS) 
	{
		return ERROR_ERROR;
	}
	MST.DoKeys("{NUMPAD-}");
	Sleep(500);
	MST.DoKeys("{NUMPAD+}");
	Sleep(500);
	return ERROR_SUCCESS;
}


void ExpandProcedureNode(LPCSTR Server,LPCSTR strDBName)
{
	ExpandDatabase(Server,strDBName);
	MST.DoKeys(GetLocString(IDSS_STOREDPROC)); //"Stored Procedures"
	Sleep(2000);						// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");			// Expand the procedure node
	Sleep(500); 			// Xtra Wait
}


void ExpandTableNode(LPCSTR Server,LPCSTR strDBName)
{
	ExpandDatabase(Server,strDBName);
	MST.DoKeys(GetLocString(IDSS_TABLE)); // "Table"
	Sleep(2000);						// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");			// Expand the Table node
	Sleep(500); 			// Xtra Wait
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Bin\test\appmodul.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// export WinMain to force linkage to this module

extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow);

#ifdef _MAC
extern "C" int PASCAL
#else
extern "C" int WINAPI
#endif
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow)
{
	// call shared/exported WinMain 
	return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
}

/////////////////////////////////////////////////////////////////////////////
// initialize app state such that it points to this module's core state

BOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion)
{
	AFX_MODULE_STATE* pState = AfxGetModuleState();
	pState->m_bDLL = (BYTE)bDLL;
	ASSERT(dwVersion <= _MFC_VER);
	UNUSED(dwVersion);	// not used in release build
#ifdef _AFXDLL
	pState->m_dwVersion = dwVersion;
#endif
#ifndef _MAC
#ifdef _MBCS
	// set correct multi-byte code-page for Win32 apps
	if (!bDLL)
		_setmbcp(_MB_CP_ANSI);
#endif //_MBCS
#endif //!_MAC
	return TRUE;
}

class _AFX_TERM_APP_STATE
{
public:
	_AFX_TERM_APP_STATE();
#ifndef _AFXDLL
	~_AFX_TERM_APP_STATE();
#endif
};

_AFX_TERM_APP_STATE::_AFX_TERM_APP_STATE()
{
	// initialize this module as an application
	AfxInitialize(FALSE, _MFC_VER);
}

#ifndef _AFXDLL
_AFX_TERM_APP_STATE::~_AFX_TERM_APP_STATE()
{
	AfxTermLocalData(NULL);
}
#endif

// force initialization early
#pragma warning(disable: 4074)
#pragma init_seg(lib)

_AFX_TERM_APP_STATE _afxTermAppState;

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SNIFF.CPP
//
//      Created by :                    Date :
//              RickKr                                  8/30/93
//
//      Description :
//              implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "syscases.h"
#include "srccases.h"
#include "rescases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

int ImeInit = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSysSubSuite, CIDESubSuite, "Sys sniff test", "MichMa")
PLATFORM_TYPE target_platform = (PLATFORM_TYPE)GetUserTargetPlatforms();

BEGIN_TESTLIST(CSysSubSuite)
	TEST(CSysAppWizTest, RUN)
	TEST(CSysClassesTest, RUN)  DEPENDENCY(CSysAppWizTest)
	TEST(CSysResTest, RUN)		DEPENDENCY(CSysAppWizTest)
	TEST(CSysBuildTest, RUN)	DEPENDENCY(CSysAppWizTest)
	TEST(CSysDebugPrjTest, RUN)	DEPENDENCY(CSysBuildTest)
	TEST(CSysDebugExeTest, RUN)	DEPENDENCY(CSysBuildTest)
END_TESTLIST()

void CSysSubSuite::SetUp(BOOL bCleanUp)
{
	// remove the project directory
	KillAllFiles(m_strCWD + PROJDIR, TRUE);

	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(2);
}

void CSysSubSuite::CleanUp(void)
{
	// call the base class
	CIDESubSuite::CleanUp();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Bin\test\winmain.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
// Standard WinMain implementation
//  Can be replaced as long as 'AfxWinInit' is called first

int AFXAPI AfxWinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow)
{
	ASSERT(hPrevInstance == NULL);

	int nReturnCode = -1;
	CWinApp* pApp = AfxGetApp();

	// AFX internal initialization
	if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))
		goto InitFailure;

	// App global initializations (rare)
	ASSERT_VALID(pApp);
	if (!pApp->InitApplication())
		goto InitFailure;
	ASSERT_VALID(pApp);

	// Perform specific initializations
	if (!pApp->InitInstance())
	{
		if (pApp->m_pMainWnd != NULL)
		{
			TRACE0("Warning: Destroying non-NULL m_pMainWnd\n");
			pApp->m_pMainWnd->DestroyWindow();
		}
		nReturnCode = pApp->ExitInstance();
		goto InitFailure;
	}
	ASSERT_VALID(pApp);

	nReturnCode = pApp->Run();
	ASSERT_VALID(pApp);

InitFailure:
	AfxWinTerm();
	return nReturnCode;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		TomWh					11/1/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define PROJNAME "Sys Test"
#define PROJDIR "Sys Test\\"

///////////////////////////////////////////////////////////////////////////////
// CSysSubSuite class

class CSysSubSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSysSubSuite)

	DECLARE_TESTLIST()

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);

// data
public:
	COProject m_prj;
	COResScript m_res;
	CODebug m_dbg;
	COBrowse m_brz;
	COBreakpoints m_bp;
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Bin\test\docmulti.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef AFX_CORE2_SEG
#pragma code_seg(AFX_CORE2_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate construction/destruction

CMultiDocTemplate::CMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
	CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass)
		: CDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass)
{
	ASSERT(m_docList.IsEmpty());

	HINSTANCE hInst = AfxFindResourceHandle(
		MAKEINTRESOURCE(nIDResource), RT_MENU);
	m_hMenuShared = ::LoadMenu(hInst, MAKEINTRESOURCE(nIDResource));
	m_hAccelTable = ::LoadAccelerators(hInst, MAKEINTRESOURCE(nIDResource));
	m_nUntitledCount = 0;   // start at 1

#ifdef _DEBUG
	// warnings about missing components (don't bother with accelerators)
	if (m_hMenuShared == NULL)
		TRACE1("Warning: no shared menu for document template #%d.\n",
			nIDResource);
#endif //_DEBUG
}

CMultiDocTemplate::~CMultiDocTemplate()
{
#ifdef _DEBUG
	if (!m_docList.IsEmpty())
		TRACE1("Warning: destroying CMultiDocTemplate with %d documents alive.\n",
			m_docList.GetCount());
#endif
	// delete shared components
	if (m_hMenuShared != NULL)
		::DestroyMenu(m_hMenuShared);
	if (m_hAccelTable != NULL)
		::FreeResource((HGLOBAL)m_hAccelTable);
}

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate attributes

POSITION CMultiDocTemplate::GetFirstDocPosition() const
{
	return m_docList.GetHeadPosition();
}

CDocument* CMultiDocTemplate::GetNextDoc(POSITION& rPos) const
{
	return (CDocument*)m_docList.GetNext(rPos);
}

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate document management (a list of currently open documents)

void CMultiDocTemplate::AddDocument(CDocument* pDoc)
{
	ASSERT_VALID(pDoc);

	CDocTemplate::AddDocument(pDoc);
	ASSERT(m_docList.Find(pDoc, NULL) == NULL); // must not be in list
	m_docList.AddTail(pDoc);
}


void CMultiDocTemplate::RemoveDocument(CDocument* pDoc)
{
	ASSERT_VALID(pDoc);

	CDocTemplate::RemoveDocument(pDoc);
	m_docList.RemoveAt(m_docList.Find(pDoc));
}

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate commands

CDocument* CMultiDocTemplate::OpenDocumentFile(LPCTSTR lpszPathName,
	BOOL bMakeVisible)
{
	CDocument* pDocument = CreateNewDocument();
	if (pDocument == NULL)
	{
		TRACE0("CDocTemplate::CreateNewDocument returned NULL.\n");
		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
		return NULL;
	}
	ASSERT_VALID(pDocument);

	BOOL bAutoDelete = pDocument->m_bAutoDelete;
	pDocument->m_bAutoDelete = FALSE;   // don't destroy if something goes wrong
	CFrameWnd* pFrame = CreateNewFrame(pDocument, NULL);
	pDocument->m_bAutoDelete = bAutoDelete;
	if (pFrame == NULL)
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
		delete pDocument;       // explicit delete on error
		return NULL;
	}
	ASSERT_VALID(pFrame);

	if (lpszPathName == NULL)
	{
		// create a new document - with default document name
		SetDefaultTitle(pDocument);

		// avoid creating temporary compound file when starting up invisible
		if (!bMakeVisible)
			pDocument->m_bEmbedded = TRUE;

		if (!pDocument->OnNewDocument())
		{
			// user has be alerted to what failed in OnNewDocument
			TRACE0("CDocument::OnNewDocument returned FALSE.\n");
			pFrame->DestroyWindow();
			return NULL;
		}

		// it worked, now bump untitled count
		m_nUntitledCount++;
	}
	else
	{
		// open an existing document
		CWaitCursor wait;
		if (!pDocument->OnOpenDocument(lpszPathName))
		{
			// user has be alerted to what failed in OnOpenDocument
			TRACE0("CDocument::OnOpenDocument returned FALSE.\n");
			pFrame->DestroyWindow();
			return NULL;
		}
#ifdef _MAC
		// if the document is dirty, we must have opened a stationery pad
		//  - don't change the pathname because we want to treat the document
		//  as untitled
		if (!pDocument->IsModified())
#endif
			pDocument->SetPathName(lpszPathName);
	}

	InitialUpdateFrame(pFrame, pDocument, bMakeVisible);
	return pDocument;
}

void CMultiDocTemplate::SetDefaultTitle(CDocument* pDocument)
{
	CString strDocName;
	if (GetDocString(strDocName, CDocTemplate::docName) &&
		!strDocName.IsEmpty())
	{
		TCHAR szNum[8];
#ifndef _MAC
		wsprintf(szNum, _T("%d"), m_nUntitledCount+1);
#else
		wsprintf(szNum, _T(" %d"), m_nUntitledCount+1);
#endif
		strDocName += szNum;
	}
	else
	{
		// use generic 'untitled' - ignore untitled count
		VERIFY(strDocName.LoadString(AFX_IDS_UNTITLED));
	}
	pDocument->SetTitle(strDocName);
}

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate diagnostics

#ifdef _DEBUG
void CMultiDocTemplate::Dump(CDumpContext& dc) const
{
	CDocTemplate::Dump(dc);

	dc << "m_hMenuShared = " << (UINT)m_hMenuShared;
	dc << "\nm_hAccelTable = " << (UINT)m_hAccelTable;
	dc << "\nm_nUntitledCount = " << m_nUntitledCount;
	dc << "\nwith " << m_docList.GetCount() << " open documents";
	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		dc << "\nwith document " << (void*)pDoc;
	}

	dc << "\n";
}

void CMultiDocTemplate::AssertValid() const
{
	CDocTemplate::AssertValid();

	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		ASSERT_VALID(pDoc);
	}
}
#endif //_DEBUG

#undef new
#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CMultiDocTemplate, CDocTemplate)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\rescases.h ===
///////////////////////////////////////////////////////////////////////////////
//	RESCASES.H
//
//	Created by :			Date :
//		DavidGa					2/23/94
//
//	Description :
//		Declaration of the DBCS Resource testcase classes
//

#ifndef __RESCASES_H__
#define __RESCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	CStringTestCases class

class CStringTestCases : public CTest
{
	DECLARE_TEST(CStringTestCases, CSysSubSuite)

// Operations
public:
	virtual void Run(void);
};

///////////////////////////////////////////////////////////////////////////////
//	CAccelTestCases class

class CAccelTestCases : public CTest
{
	DECLARE_TEST(CAccelTestCases, CSysSubSuite)

// Operations
public:
	virtual void Run(void);
};

///////////////////////////////////////////////////////////////////////////////
//	CImageTestCases class

class CImageTestCases : public CTest
{
	DECLARE_TEST(CImageTestCases, CSysSubSuite)

// Operations
public:
	virtual void Run(void);
};

///////////////////////////////////////////////////////////////////////////////
//	CMenuTestCases class

class CMenuTestCases : public CTest
{
	DECLARE_TEST(CMenuTestCases, CSysSubSuite)

// Operations
public:
	virtual void Run(void);
};

#endif //__RESCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Stress\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Stress\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\rescases.cpp ===
//////////////////////////////////////////////////////////////////////////////
//	RESCASES.CPP
//
//	Created by :			Date :
//		DavidGa					2/23/94
//
//	Description :
//		Implementation of the DBCS Resource testcase classes
//

#include "stdafx.h"
#include "rescases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

extern ImeInit;

#define OPEN_IME \
	IME.Open(); \
	Sleep(500); \
	(ImeInit == FALSE ? (IME.SetConversionMode(3),ImeInit=TRUE):0) ; \
/*
	IME.Open(); IME.Enable(); \
	if( !IME.IsOpen() || !IME.IsEnabled() ) \
	{	WriteWarning("Unable to activate IME"); return EndTestSet(); }
*/
#define CLOSE_IME \
	IME.Open(FALSE); Sleep(500)

///////////////////////////////////////////////////////////////////////////////
//	CStringTestCases class

IMPLEMENT_TEST(CStringTestCases, CTest, "DBCS String Editor Tests", -1, CSysSubSuite)

void CStringTestCases::Run(void)
{
	COResScript res;

	// create a new string table resource
	GetLog()->RecordInfo("Creating a new string table resource...");
	if (!(GetLog()->RecordCompare(res.CreateResource(IDSS_RT_STRING_TABLE) == ERROR_SUCCESS, "Creating a new string table resource."))) {
		throw CTestException("CStringTestCases::Run: cannot create string resource; unable to continue.", CTestException::causeOperationFail);
	}

	UIStrEdit ed = UIWB.GetActiveEditor();

	CString strStr, strID;

	UIWB.ShowPropPage(TRUE);    // Bring up an IME able window
	MST.DoKeys("{TAB}");
	OPEN_IME;

	GetLog()->RecordInfo("Entering DBC string in the string editor...");

	IME.SetMode(CIME::KATAKANA, 2);		// DBC-Katakana
	int n1 = ed.AddString("");	// zoso
	ed.SelectLine(n1);
	strStr = ed.GetString();
//	strID = ed.GetId();
	GetLog()->RecordCompare(strStr == "", "Entering DBC string in the string editor. Expected the string '%s' to be entered; found '%s'.", "]\n", (LPCSTR)strStr);

	GetLog()->RecordInfo("Overwriting DBC string in the string editor...");

	// WM_CHAR forwarding -- bug #9877
	IME.SetMode(CIME::KATAKANA, 2);		// DBC-Katakana
	DoKeysSlow("katakana", 20);		// speed bug #10642, postponed
	int n2 = ed.GetCurLine();
	UIWB.ShowPropPage(FALSE);
	ed.SelectLine(n2);
	strStr = ed.GetString();
	GetLog()->RecordCompare(strStr == "J^Ji", "Overwriting DBC string in the string editor. Expected the string '%s' to be entered; found '%s'.", "J^Ji", (LPCSTR)strStr);

	CLOSE_IME;
	ed.Close();
}

///////////////////////////////////////////////////////////////////////////////
//	CAccelTestCases class

IMPLEMENT_TEST(CAccelTestCases, CTest, "DBCS Accelerator Editor Tests", -1, CSysSubSuite)

void CAccelTestCases::Run(void)
{
	COResScript res;

	// create a new accelerator editor resource
	GetLog()->RecordInfo("Creating a new accelerator editor resource...");
	if (!(GetLog()->RecordCompare(res.CreateResource(IDSS_RT_ACCELERATOR) == ERROR_SUCCESS, "Creating a new accelerator editor resource."))) {
		throw CTestException("CStringTestCases::Run: cannot create accelerator resource; unable to continue.", CTestException::causeOperationFail);
	}

	UIAccEdit ed = UIWB.GetActiveEditor();

	CString strKey, strID;
	DWORD dwKeyMods;

	OPEN_IME;

	GetLog()->RecordInfo("Adding an SBC katakana accelerator...");
	IME.SetMode(CIME::KATAKANA, 1);		// SBC-Alpha (so the IME doesn't screw up entry)
	int n1 = ed.AddAccel("ka");			// ka
	ed.SelectLine(n1);
	strKey = ed.GetKey();
//	strID = ed.GetId();
	dwKeyMods = ed.GetKeyMods();
//	WriteLog( strKey == "182", "SBC-katakana accelerators work");
	GetLog()->RecordCompare(strKey == "", "Adding an SBC katakana accelerator. Expected the key '%s'; found '%s'.", "", strKey);

	CLOSE_IME;
	ed.Close();
}

///////////////////////////////////////////////////////////////////////////////
//	CImageTestCases class

IMPLEMENT_TEST(CImageTestCases, CTest, "DBCS Image Editor Tests", -1, CSysSubSuite)

void CImageTestCases::Run(void)
{
	COResScript res;

	// create a new bitmap editor resource
	GetLog()->RecordInfo("Creating a new bitmap editor resource...");
	if (!(GetLog()->RecordCompare(res.CreateResource(IDSS_RT_BITMAP) == ERROR_SUCCESS, "Creating a new bitmap editor resource."))) {
		throw CTestException("CStringTestCases::Run: cannot create bitmap resource; unable to continue.", CTestException::causeOperationFail);
	}

	UIImgEdit ed = UIWB.GetActiveEditor();

	ed.SetColor(6, VK_LBUTTON);
	ed.ClickImgTool(GT_TEXT);

	GetLog()->RecordInfo("Entering DBC text in the image editor...");
	OPEN_IME;
	IME.SetMode(CIME::HIRAGANA, 2);		// DBC-Hiragana
	DoKeysSlow("sushi", 10);	// 
	ed.SetFont("lr SVbN", 18, FONT_NORMAL);		// MS-??, 18 pt
	//ed.ClickImgTool(GT_SELECT);					// Commits selection and enables Copy command			
	MST.DoKeys("{ESC}") ; //commit changes.
//	IME.SetMode(CIME::ALPHA, 1);
	CLOSE_IME;
	GetLog()->RecordSuccess("Entering DBC text in the image editor.");

// REVIEW(briancr): we can't successfully compare bitmap files on Win95
// apparently the padding is different between different saves on Win95
/*
	GetLog()->RecordInfo("Exporting image and comparing with baseline...");
	UIWB.ExportResource(m_strCWD + "TESTOUT\\1.BMP", TRUE);
	int iresult = CompareFiles(m_strCWD + "TESTOUT\\1.BMP", m_strCWD + "BASELN\\sushi1.BMP", 100);
	GetLog()->RecordCompare(iresult == CF_SAME, "Exporting image and comparing with baseline. Compared '%s' with '%s'; result of compare: %d.", "TESTOUT\\1.BMP", "BASELN\\sushi1.BMP", iresult);
	// don't close
*/

	GetLog()->RecordInfo("Setting filename property to DBC filename...");
	UIWB.ShowPropPage(TRUE);
//	IME.SetMode(CIME::ALPHA, 1);
	MST.DoKeys("\"i");	// overtype all but first character
	OPEN_IME;
	IME.SetMode(CIME::HIRAGANA, 2);		// DBC-Hiragana
	MST.DoKeys("{END}");
	MST.DoKeys("sashimi8");	// iW
	UIWB.ShowPropPage(FALSE);
	CString strExpectedFile = "I.BMP";
	CString strActualFile = UIWB.GetProperty(P_FileName);
	strActualFile.MakeUpper();
	GetLog()->RecordCompare(strActualFile.Find(strExpectedFile) >= 0, "Setting filename property to DBC filename. Expected filename '%s'; found '%s'.", (LPCSTR)strExpectedFile, (LPCSTR)strActualFile);
	CLOSE_IME;
	ed.Close();
}

///////////////////////////////////////////////////////////////////////////////
//	CMenuTestCases class

IMPLEMENT_TEST(CMenuTestCases, CTest, "DBCS Menu Editor Tests", -1, CSysSubSuite)

void CMenuTestCases::Run(void)
{
	COResScript res;

	// create a new menu editor resource
	GetLog()->RecordInfo("Creating a new menu editor resource...");
	if (!(GetLog()->RecordCompare(res.CreateResource(IDSS_RT_MENU) == ERROR_SUCCESS, "Creating a new menu editor resource."))) {
		throw CTestException("CStringTestCases::Run: cannot create menu resource; unable to continue.", CTestException::causeOperationFail);
	}

	UIImgEdit ed = UIWB.GetActiveEditor();

	MST.DoKeys("{right}");	// select menu bar

	GetLog()->RecordInfo("Entering DBC menu id (this should be illegal)...");
	OPEN_IME;
	IME.SetMode(CIME::KATAKANA, 2);
	UIControlProp upp = UIWB.ShowPropPage(TRUE);		// crash - bug #9876
	MST.WComboSetText(upp.GetLabel(SHRDRES_IDC_ID), "ni");	// illegal id: j
	UIWBMessageBox mb;
	upp.Close();
	if (GetLog()->RecordCompare(mb.WaitAttachActive(500) != NULL, "Entering DBC menu id. Expecting message box.")) {
		mb.ButtonClick();
	}

	GetLog()->RecordInfo("Entering SBC katakana menu id (this should be illegal)...");
	IME.SetMode(CIME::KATAKANA, 1);
	MST.DoKeys("ichi");		// illegal id: 
	upp.Close();
	if (GetLog()->RecordCompare(mb.WaitAttachActive(500) != NULL, "Entering SBC katakana menu id. Expecting message box.")) {
		mb.ButtonClick();
	}
	MST.DoKeys("{escape}");
	MST.DoKeys("{left}");		// move selection back to new item

	GetLog()->RecordInfo("Adding menu item with DBC and verifying legal ID is generated...");
	IME.SetMode(CIME::KATAKANA, 2);
	UIWB.ShowPropPage(TRUE);	// bug #9877
	MST.WEditSetText(upp.GetLabel(SHRDRES_IDC_CAPTION), "tHI");	// foo
	UIWB.ShowPropPage(FALSE);
	DoKeysSlow("baro", 10);		// o
	UIWB.ShowPropPage(FALSE);
	MST.DoKeys("{up}");

	CString strID = UIWB.GetProperty(P_ID);
	GetLog()->RecordCompare(strID.Find("IDM_MENUITEM4000"), "Adding menu item with DBC and verifying legal ID is generated. Expected menu ID to include '%s'; found '%s'.", "IDM_MENUITEM4000", (LPCSTR)strID);

	CLOSE_IME;
	ed.Close();
/*
	MST.DoKeys("%fc"); // File close resource browser
	MST.DoKeys("n");   // No, to "Save changes?"
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\srccases.h ===
///////////////////////////////////////////////////////////////////////////////
//	SRCCASES.H
//
//	Created by :			Date :
//		DavidGa					4/11/94
//
//	Description :
//		Declaration of the CSrcTestCases class
//

#ifndef __SRCCASES_H__
#define __SRCCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	CSourceTestCases class

class CSourceTestCases : public CTest
{
	DECLARE_TEST(CSourceTestCases, CSysSubSuite)

// Data
public:
	COSource m_src;

// Operations
public:
	virtual void Run(void);

// Test Cases
public:
	void Typing(void);
	void Cursor(void);
};

///////////////////////////////////////////////////////////////////////////////
//	CSearchTestCases class

class CSearchTestCases : public CTest
{
	DECLARE_TEST(CSearchTestCases, CSysSubSuite)

// Operations
public:
	virtual void Run(void);

// Test Cases
public:
	void Text(void);
	void Expression(void);
	void InFiles(void);
};

#endif //__SRCCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\srccases.cpp ===
//////////////////////////////////////////////////////////////////////////////
//	SRCCASES.CPP
//
//	Created by :			Date :
//		DavidGa					4/11/94
//
//	Description :
//		Implementation of the CSrcTestCases class
//

#include "stdafx.h"
#include "srccases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

extern ImeInit;

#define OPEN_IME \
	IME.Open(); Sleep(500); IME.Enable(); \
	Sleep(500); \
	(ImeInit == FALSE ? (IME.SetConversionMode(3),ImeInit=TRUE):0) ; \

/*
	IME.Open(); IME.Enable(); \
	if( !IME.IsOpen() || !IME.IsEnabled() ) \
	{	WriteWarning("Unable to activate IME"); return; }
*/

#define CLOSE_IME \
	IME.Enable(FALSE); Sleep(500); IME.Open(FALSE); Sleep(500);

///////////////////////////////////////////////////////////////////////////////
//	Helper functions

BOOL VerifyCursorPosition(COSource& src, int line, int col)
{
	return (src.GetCurrentLine() == line) && (src.GetCurrentColumn() == col);
}


///////////////////////////////////////////////////////////////////////////////
//	CSourceTestCases class

IMPLEMENT_TEST(CSourceTestCases, CTest, "DBCS Source Tests", -1, CSysSubSuite)

void CSourceTestCases::Run(void)
{
	// create a new source file
	m_src.Create();

	Typing();
	Cursor();

	m_src.Close();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

void CSourceTestCases::Typing(void)
{
	GetLog()->RecordInfo("Typing various single byte/double byte strings into the source editor.");

	m_src.TypeTextAtCursor("single byte alpha~");
	OPEN_IME;
	IME.SetMode(CIME::KATAKANA, 1);
	DoKeysSlow("ichi bite katakana~", 20);
	IME.SetMode(CIME::KATAKANA, 2);
	DoKeysSlow("ni bite katakana~", 10);
	IME.SetMode(CIME::HIRAGANA, 2);
	DoKeysSlow("ni bite hiragana~", 10);
	IME.SetMode(CIME::ALPHA, 2);
	DoKeysSlow("double byte alpha~", 10);
	IME.SetMode(CIME::ALPHA, 1);
	DoKeysSlow("single byte alpha~", 10);
	CLOSE_IME;

	GetLog()->RecordInfo("Successfully typed various single byte/double byte strings into the source editor.");

	m_src.SelectText(1,1,1,0);
	GetLog()->RecordCompare(m_src.GetSelectedText() == "single byte alpha", "Typing SBC-Alpha without IME. Typed text '%s'.", m_src.GetSelectedText());

	m_src.SelectText(2,1,2,0);
	GetLog()->RecordCompare(m_src.GetSelectedText() == "  ", "Typing SBC-Katakana. Typed text '%s'.", m_src.GetSelectedText());

	m_src.SelectText(3,1,3,0);
	GetLog()->RecordCompare(m_src.GetSelectedText() == "j re J^Ji", "Typing DBC-Katakana. Typed text '%s'.", m_src.GetSelectedText());

	m_src.SelectText(4,1,4,0);
	GetLog()->RecordCompare(m_src.GetSelectedText() == "  ", "Typing DBC-Hiragana. Typed text '%s'.", m_src.GetSelectedText());

	m_src.SelectText(5,1,5,0);
	GetLog()->RecordCompare(m_src.GetSelectedText() == "  ", "Typing DBC-alpha. Typed text '%s'.", m_src.GetSelectedText());

	m_src.SelectText(6,1,6,0);
	GetLog()->RecordCompare(m_src.GetSelectedText() == "single byte alpha", "Typing SBC-alpha with IME. Typed text '%s'.", m_src.GetSelectedText());
}

void CSourceTestCases::Cursor(void)
{
	int nExpectedCol;
	int nActualCol;

	GetLog()->RecordInfo("Moving caret right 4 times in SBC-Katakana...");
	m_src.SetCursor(2,1);
	DoKeysSlow("{right 4}", 10);
	nExpectedCol = 5;
	nActualCol = m_src.GetCurrentColumn();
	GetLog()->RecordCompare(nActualCol == nExpectedCol, "Moving caret right 3 times in SBC-Katakana. Expected column %d, navigated to column %d.", nExpectedCol, nActualCol);

	GetLog()->RecordInfo("Moving caret down into the middle of a DBC...");
	DoKeysSlow("{down}", 10);
	nExpectedCol = 4;
	nActualCol = m_src.GetCurrentColumn();
	GetLog()->RecordCompare(nActualCol == nExpectedCol, "Moving caret down into the middle of a DBC. Expected column %d, navigated to column %d.", nExpectedCol, nActualCol);

	GetLog()->RecordInfo("Moving caret right 2 words and 1 space in DBC-Katakana...");
	DoKeysSlow("^{right 2}{right}", 10);
	nExpectedCol = 11;
	nActualCol = m_src.GetCurrentColumn();
	GetLog()->RecordCompare(nActualCol == nExpectedCol, "Moving caret right 2 words and 1 space in DBC-Katakana. Expected column %d, navigated to column %d.", nExpectedCol, nActualCol);

	GetLog()->RecordInfo("Overtyping DBC with SBC...");
	DoKeysSlow("{down}{insert}a{end}b", 10);	// REVIEW: make sure Insert is off initially (SUSHI.KEY)
	nExpectedCol = 17;
	nActualCol = m_src.GetCurrentColumn();
	GetLog()->RecordCompare(nActualCol == nExpectedCol, "Overtyping DBC with SBC. Expected column %d, navigated to column %d.", nExpectedCol, nActualCol);

	GetLog()->RecordInfo("Moving caret down through the middle of a DBC...");
	DoKeysSlow("{down 2}", 10);
	nExpectedCol = 17;
	nActualCol = m_src.GetCurrentColumn();
	GetLog()->RecordCompare(nActualCol == nExpectedCol, "Moving caret down through the middle of a DBC. Expected column %d, navigated to column %d.", nExpectedCol, nActualCol);

	GetLog()->RecordInfo("Overtyping SBC with DBC...");
	OPEN_IME;
	IME.SetMode(CIME::ALPHA, 2);
	DoKeysSlow("abet{insert}", 10);		// overtype still on, turn it back off
	nExpectedCol = 25;
	nActualCol = m_src.GetCurrentColumn();
	GetLog()->RecordCompare(nActualCol == nExpectedCol, "Overtyping SBC with DBC. Expected column %d, navigated to column %d.", nExpectedCol, nActualCol);
	CLOSE_IME;
}

///////////////////////////////////////////////////////////////////////////////
//	CSearchTestCases class

IMPLEMENT_TEST(CSearchTestCases, CTest, "DBCS Search tests", -1, CSysSubSuite)

void CSearchTestCases::Run(void)
{
	GetLog()->RecordInfo("Copying 'dbcs.txt' to 'J^Ji.cpp'...");
	SetFileAttributes(m_strCWD + "J^Ji.cpp", FILE_ATTRIBUTE_NORMAL);	// who cares if it doesn't exist
	if (GetLog()->RecordCompare(::CopyFile(m_strCWD + "dbcs.txt", m_strCWD + "J^Ji.cpp", FALSE), "Copying 'dbcs.txt' to 'J^Ji.cpp'.")) {
		SetFileAttributes(m_strCWD + "J^Ji.cpp", FILE_ATTRIBUTE_NORMAL);	// must remove read-only flag
	}
	else {
		throw CTestException("Unable to set the test up correctly to run.", CTestException::causeOperationFail);
	}

	Text();
	Expression();
	InFiles();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

void CSearchTestCases::Text(void)
{
	COSource src;

	int nExpectedLine, nExpectedCol;
	int nActualLine, nActualCol;

	// open the source file
	src.Open(m_strCWD + "J^Ji.cpp");

	// navigate to the beginning of the file
	MST.DoKeys("^{home}");
	
	// find the first backslash
	GetLog()->RecordInfo("Finding the first '\\'...");
	src.Find("\\");
	nExpectedLine = 9;
	nExpectedCol = 51;
	nActualLine = src.GetCurrentLine();
	nActualCol = src.GetCurrentColumn();
	GetLog()->RecordCompare(VerifyCursorPosition(src, nExpectedLine, nExpectedCol), "Finding the first '\\'. Expected cursor at (%d, %d); navigated to (%d, %d).", nExpectedLine, nExpectedCol, nActualLine, nActualCol);

	// find the second backslash
	GetLog()->RecordInfo("Finding the second '\\'...");
	src.Find("\\");
	nExpectedLine = 10;
	nExpectedCol = 2;
	nActualLine = src.GetCurrentLine();
	nActualCol = src.GetCurrentColumn();
	GetLog()->RecordCompare(VerifyCursorPosition(src, nExpectedLine, nExpectedCol), "Finding the second '\\'. Expected cursor at (%d, %d); navigated to (%d, %d).", nExpectedLine, nExpectedCol, nActualLine, nActualCol);

	// find the first 
	GetLog()->RecordInfo("Finding the first ''...");
	src.Find("");
	nExpectedLine = 6;
	nExpectedCol = 3;
	nActualLine = src.GetCurrentLine();
	nActualCol = src.GetCurrentColumn();
	GetLog()->RecordCompare(VerifyCursorPosition(src, nExpectedLine, nExpectedCol), "Finding the first ''. Expected cursor at (%d, %d); navigated to (%d, %d).", nExpectedLine, nExpectedCol, nActualLine, nActualCol);

	// find the second 
	GetLog()->RecordInfo("Finding the second ''...");
	src.Find("");
	nExpectedLine = 7;
	nExpectedCol = 3;
	nActualLine = src.GetCurrentLine();
	nActualCol = src.GetCurrentColumn();
	GetLog()->RecordCompare(VerifyCursorPosition(src, nExpectedLine, nExpectedCol), "Finding the second ''. Expected cursor at (%d, %d); navigated to (%d, %d).", nExpectedLine, nExpectedCol, nActualLine, nActualCol);

	// replace a DBC string with an SBC string
	GetLog()->RecordInfo("Replacing a DBC string ('') with an SBC string ('123')...");
	int nExpectedReplaces = 2;
	int nActualReplaces = src.Replace("", "123", FALSE, FALSE, FALSE, COSource::RS_WHOLEFILE, TRUE);
	GetLog()->RecordCompare(nActualReplaces == nExpectedReplaces, "Replacing a DBC string ('') with an SBC string ('123'). Expected %d replaces; detected %d replaces.", nExpectedReplaces, nActualReplaces);

	src.Close();
}

void CSearchTestCases::Expression(void)
{
}

void CSearchTestCases::InFiles(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\syscases.h ===
///////////////////////////////////////////////////////////////////////////////
//	SYSCASES.H
//
//	Created by :			Date :
//		RickKr					1/25/94
//
//	Description :
//		Declaration of the CSysTestCases class
//

#ifndef __SYSCASES_H__
#define __SYSCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CSysAppWizTest: SYS AppWizard test

class CSysAppWizTest: public CTest
{
	DECLARE_TEST(CSysAppWizTest, CSysSubSuite)

// overrides
public:
	virtual void Run(void);

	virtual BOOL RunAsDependent(void);

// support functions
protected:
	BOOL NewProject(void);
	BOOL SaveProject(void);
};

///////////////////////////////////////////////////////////////////////////////
// CSysClassesTest: SYS Verify Classes

class CSysClassesTest: public CTest
{
	DECLARE_TEST(CSysClassesTest, CSysSubSuite)

public:
	virtual void Run(void);
};

///////////////////////////////////////////////////////////////////////////////
// CSysEditTest: SYS Edit test

class CSysEditTest: public CTest
{
	DECLARE_TEST(CSysEditTest, CSysSubSuite)

public:
	virtual void Run(void);
// support functions
protected:
	BOOL OpenSource(void);
	BOOL SearchSource(void);
	void EditSourceAndContinue(void);
// ide support
private:
	COSource m_src;
};

///////////////////////////////////////////////////////////////////////////////
// CSysResTest: SYS resource test

class CSysResTest: public CTest
{
	DECLARE_TEST(CSysResTest, CSysSubSuite)

// overrides
public:
	virtual void Run(void);

// support functions
protected:
	BOOL OpenResScript(void);
	BOOL AddDialog(void);
};

///////////////////////////////////////////////////////////////////////////////
// CSysBuildTest: SYS build test

class CSysBuildTest: public CTest
{
	DECLARE_TEST(CSysBuildTest, CSysSubSuite)

// overrides
public:
	virtual void Run(void);

	virtual BOOL RunAsDependent(void);

// support functions
protected:
	BOOL OpenProject(void);
	BOOL BuildProject(void);
};

///////////////////////////////////////////////////////////////////////////////
// CSysDebugPrjTest

class CSysDebugPrjTest: public CTest
{
	DECLARE_TEST(CSysDebugPrjTest, CSysSubSuite)

// overrides
public:
	virtual void Run(void);

// support functions
protected:
	BOOL ENCCases(void);
	void VerifyENCRelink(void);
	BOOL OpenProject(void);
	BOOL SetBreakpoint(void);
	BOOL RunToBreakpoint(void);
	BOOL StepOut(void);
	BOOL GoToDefinition(void);
	BOOL StepToCursor(void);
	BOOL StepOver(void);
	BOOL Restart(void);
	BOOL StepIntoMFC(void);
	BOOL StopDebugging(void);
	BOOL ClearAllBreakpoints(void);
};

///////////////////////////////////////////////////////////////////////////////
// CSysDebugExeTest

class CSysDebugExeTest: public CTest
{
	DECLARE_TEST(CSysDebugExeTest, CSysSubSuite)

// overrides
public:
	virtual void Run(void);
};

#endif // SYSCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Stress\StressSubSuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	StressSubsuite.CPP
//
//	Created by :			Date :			
//		MichMa					1/28/98
//
//	Description :
//		implementation of the CSysStressSubsuite class
//

#include "stdafx.h"
#include "StressSubsuite.h"
#include "afxdllx.h"

#include "StressCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSysStressSubsuite

IMPLEMENT_SUBSUITE(CSysStressSubsuite, CIDESubSuite, "System Stress", "MichMa")

BEGIN_TESTLIST(CSysStressSubsuite)
	TEST(CSysStressCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Stress\StressCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	StressCase.H
//
//	Created by :			Date :
//		MichMa					1/28/98
//
//	Description :
//		Declaration of the CSysStressCase class

#ifndef __StressCase_H__
#define __StressCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "StressSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CSysStressCase class

class CSysStressCase : public CTest

{
	DECLARE_TEST(CSysStressCase, CSysStressSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Utils
private:
	void InitiateWeb(void);
	void UpdateWeb(void);

// Data
private:
	// the root directory of the stress website.
	CString m_strStressRoot;
	// used as the name of the folder containing an html page showing the runs on that date and the logs.
	CString m_strCurrentDate;
	// used to track how many iterations the test has performed. 
	int m_intIterations;
};

#endif //__StressCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\ATLWiz\src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Sniff\Src\syscases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SYSCASES.CPP
//
//      Created by :                    Date :
//              RickKr                                  1/25/94
//		History:
//				BrianCr		12/12/94	Ported to CAFE v3
//
//      Description :
//              Implementation of the CSysTestCases class
//

#include "stdafx.h"
#include <io.h>
#include "syscases.h"
#include "sniff.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
// CSysAppWizTest: SYS AppWizard test

IMPLEMENT_TEST(CSysAppWizTest, CTest, "Create AppWizard Project", 4, CSysSubSuite)

BOOL CSysAppWizTest::RunAsDependent(void)
{
	// name of the project file
	CString strProjFile = m_strCWD + PROJDIR + PROJNAME + ".DSP";

	// if the project file exists, there's no need to run this test as a dependency
	if (_access(strProjFile, 0) != -1) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

void CSysAppWizTest::Run(void)
{
	NewProject();
	SaveProject();
}

BOOL CSysAppWizTest::NewProject(void)
{
	BOOL bResult;
	
	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	GetLog()->RecordInfo("Creating an AppWizard project named '%s'...", PROJNAME);

	// create a new AppWizard project
	APPWIZ_OPTIONS options;
	options.m_bUseMFCDLL = CMDLINE->GetBooleanValue("MFCDLL", TRUE); 

	// The following command line switch is mapped as follows:
	//	0 - APPWIZ_OPTIONS::AW_OLE_NONE (Default)
	//  1 - APPWIZ_OPTIONS::AW_OLE_CONTAINER
	//  2 - APPWIZ_OPTIONS::AW_OLE_MINISERVER (not supported)
	//  3 - APPWIZ_OPTIONS::AW_OLE_FULLSERVER
	//  4 - APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER
	options.m_OLECompound = (APPWIZ_OPTIONS::OLESupport)CMDLINE->GetIntValue("OLE", 4);
	ASSERT(options.m_OLECompound < 5);

	switch(options.m_OLECompound)
	{
	case APPWIZ_OPTIONS::AW_OLE_NONE:
		GetLog()->RecordInfo("No OLE options selected.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINER:
		GetLog()->RecordInfo("Creating an OLE container application.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_MINISERVER:
		GetLog()->RecordFailure("Creating an OLE mini-server application is not supported by the System sniff.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_FULLSERVER:
		GetLog()->RecordInfo("Creating an OLE full-server application.");
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER:
		GetLog()->RecordInfo("Creating an OLE container/server application.");
		break;
	default:
		GetLog()->RecordInfo("Invalid OLE option specified: %d  Defaulting to no OLE support", options.m_OLECompound);
		options.m_OLECompound = APPWIZ_OPTIONS::AW_OLE_NONE;
		break;
	}

	bResult = GetLog()->RecordCompare(pPrj->NewAppWiz(PROJNAME, GetCWD(), GetUserTargetPlatforms(), &options) == ERROR_SUCCESS, "Creating an AppWizard project named '%s'.", PROJNAME);
	if (!bResult) {
		throw CTestException("CSysAppWizTest::NewProject: cannot create a new AppWizard project; unable to continue.", CTestException::causeOperationFail);
	}

	// turn on browse info file (bsc) generation (off by default).
	bResult = GetLog()->RecordCompare(pPrj->ToggleBSCGeneration(TOGGLE_ON) == ERROR_SUCCESS, "Turning on BSC Generation.", PROJNAME);
	if (!bResult) {
		throw CTestException("CSysAppWizTest::NewProject: cannot turn on BSC generation; unable to continue.", CTestException::causeOperationFail);
	}

	// change output file location to same as project file (avoid debug, macdbg, pmcdbg, etc).
	bResult = GetLog()->RecordCompare(pPrj->SetOutputFile((CString)PROJNAME + ".Exe") == ERROR_SUCCESS, "Resetting output file location.", PROJNAME);
	if (!bResult) {
		throw CTestException("CSysAppWizTest::NewProject: cannot reset output file location; unable to continue.", CTestException::causeOperationFail);
	}

	return bResult;
}

BOOL CSysAppWizTest::SaveProject(void)
{
	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	CString strPrjName = pPrj->GetFullPath();

	GetLog()->RecordInfo("Saving the AppWizard project. Expecting the file '%s' to be written...", strPrjName);

	// save the project
	return GetLog()->RecordCompare(pPrj->Save(TRUE, strPrjName) == ERROR_SUCCESS, "Saving the AppWizardProject.");
}

///////////////////////////////////////////////////////////////////////////////
// CSysClassesTest: SYS Verify Class test

IMPLEMENT_TEST(CSysClassesTest, CTest, "Verify AppWizard Classes", -1, CSysSubSuite)

void CSysClassesTest::Run(void)
{
	GetLog()->RecordInfo("Verifying ClassView functionality for a small subset of classes");

	// First check the classes that appear in every case...
	CString strBaseLineFileName = m_strCWD + '\\' + "stdclass.bas";
	GetSubSuite()->m_prj.VerifyClasses(strBaseLineFileName);

	
	// Now verify additional OLE oriented classes

	// The following command line switch is mapped as follows:
	//	0 - APPWIZ_OPTIONS::AW_OLE_NONE (Default)
	//  1 - APPWIZ_OPTIONS::AW_OLE_CONTAINER
	//  2 - APPWIZ_OPTIONS::AW_OLE_MINISERVER (not supported)
	//  3 - APPWIZ_OPTIONS::AW_OLE_FULLSERVER
	//  4 - APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER
	APPWIZ_OPTIONS::OLESupport ole_choice = (APPWIZ_OPTIONS::OLESupport)CMDLINE->GetIntValue("OLE", 4);

	switch(ole_choice)
	{
	case APPWIZ_OPTIONS::AW_OLE_NONE:
		strBaseLineFileName = m_strCWD + '\\' + "no_ole.bas";
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINER:
		strBaseLineFileName = m_strCWD + '\\' + "olecont.bas";
		break;
	case APPWIZ_OPTIONS::AW_OLE_FULLSERVER:
		strBaseLineFileName = m_strCWD + '\\' + "oleserv.bas";
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER:
		strBaseLineFileName = m_strCWD + '\\' + "olec-s.bas";
		break;
	default:
		GetLog()->RecordFailure("Unsupported OLE option detected in CSysClassesTest::Run");
		break;
	}

	GetSubSuite()->m_prj.VerifyClasses(strBaseLineFileName);
}


#ifdef __EDIT__NO__
///////////////////////////////////////////////////////////////////////////////
// CSysEditTest: SYS Edit & Continue test

IMPLEMENT_TEST(CSysEditTest, CTest, "Edit AppWiz project", 2, CSysSubSuite)

void CSysEditTest::Run(void)
{
	if(OpenSource())
	{
		int currentLine=-1;
		if((currentLine=SearchSource()) >0)
		{
			//assume the EXE is open as a project
			EditSourceAndContinue();
		}
	}
}	

BOOL CSysEditTest::OpenSource(void)
{
	CString strSourceFile = CString(PROJNAME) + ".CPP"; 
	return GetLog()->RecordCompare(m_src.Open(strSourceFile, m_strCWD + PROJDIR) == ERROR_SUCCESS, "Opening the source file '%s'.", (LPCSTR)strSourceFile);
}

//returns the current line in the source file if found, -1 otherwise
int CSysEditTest::SearchSource(void)
{
	CString strSearchText = GetLocString(IDSS_ADD_CONSTRUCT_CODE_HERE); 
	GetLog()->RecordCompare(m_src.Find(strSearchText), "Searching for text '%s' in the source file.", (LPCSTR)strSearchText);
		//return -1;
	//else
		return m_src.GetCurrentLine();
}

void CSysEditTest::EditSourceAndContinue(void)
{
	//	TODO : dverma : this test fails due to bug 66005
	if (GetSystem() == SYSTEM_NT_51)
		return;

	GetLog()->RecordInfo("Debugging & editing the source file.");
	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);
	// get the debugger component from the subsuite
	CODebug* pDebugger = &(GetSubSuite()->m_dbg);
	// get the breakpoint component from the subsuite
	COBreakpoints* pBP = &(GetSubSuite()->m_bp);

	// this function will be inserted immediately before the constructor.
	CString strFuncName="func";
	CString strFunc = "void " + strFuncName + "(void){}";
	// a call to the function will be inserted within the constructor. 
	CString strFuncCall = strFuncName + "();";

	//m_src.SetCurrentLine(currentline-1);
	MST.DoKeys("{UP}"); //to set the BP at the previous line which is the entry point to the current constructor
	pBP->SetBreakpoint();

	int CurrentLine = m_src.GetCurrentLine();
	CString strline; strline.Format("@%d", CurrentLine);

	GetLog()->RecordCompare(pDebugger->Go()==TRUE && pDebugger->CurrentLineIs(strline)==TRUE,
		"Break at line: %s in EnC test", strline);

	// insert the function.
	m_src.InsertText(strFunc, CurrentLine - 2, 1, TRUE);
	m_src.TypeTextAtCursor("{ENTER}");
	// insert the function call.
	m_src.InsertText("{ENTER}", CurrentLine + 3, 0);
	m_src.TypeTextAtCursor(strFuncCall, TRUE);

	GetLog()->RecordCompare(pDebugger->StepOver(1, NULL, strFuncCall)==TRUE, "Start EnC steping");
	GetLog()->RecordCompare(pDebugger->StepInto(1, strFuncName, strFunc)==TRUE, "Step into new function");
	 //stepout to the last line of ctor (it was empty by default)
	GetLog()->RecordCompare(pDebugger->StepOut(1, NULL, /*line*/"}")==TRUE, "Step out of new function");
	
	pBP->ClearAllBreakpoints();
	pDebugger->StopDebugging();
	//verify the automatic relink of the changes in the project is correct
	pPrj->WaitUntilBuildDone(1); //1 min waiting for relink
	GetLog()->RecordCompare(pPrj->VerifyBuild(TRUE, NULL, NULL, TRUE) == ERROR_SUCCESS, "Verifying the EnC relink.");
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CSysResTest: SYS resource test

IMPLEMENT_TEST(CSysResTest, CTest, "Add Resource to AppWizard Project", 2, CSysSubSuite)

void CSysResTest::Run(void)
{
	OpenResScript();
	AddDialog();
}

BOOL CSysResTest::OpenResScript(void)
{
	BOOL bResult;

	// get the resource script from the subsuite
	COResScript* pRes = &(GetSubSuite()->m_res);

	// set the name of the resource file
	CString strResFile = m_strCWD + PROJDIR + PROJNAME + ".RC";

	GetLog()->RecordInfo("Opening the resource file '%s' for this project...", (LPCSTR)strResFile);

	// open the resource file
	bResult = GetLog()->RecordCompare(pRes->Open(CString(PROJNAME) + ".RC", m_strCWD + PROJDIR) == ERROR_SUCCESS, "Opening the resource file '%s' for this project.", (LPCSTR)strResFile);
	if (!bResult) {
		throw CTestException("CSysResTest::OpenResScript: cannot open resource script; unable to continue.", CTestException::causeOperationFail);
	}
	return bResult;
}

BOOL CSysResTest::AddDialog(void)
{
	// get the resource script from the subsuite
	COResScript* pRes = &(GetSubSuite()->m_res);

	GetLog()->RecordInfo("Creating a dialog resource...");

	// create a dialog resource
	return GetLog()->RecordCompare(pRes->CreateResource(IDSS_RT_DIALOG) == ERROR_SUCCESS, "Creating a dialog resource.");
}

///////////////////////////////////////////////////////////////////////////////
// CSysBuildTest: SYS build test

IMPLEMENT_TEST(CSysBuildTest, CTest, "Build AppWizard project", 3, CSysSubSuite)

BOOL CSysBuildTest::RunAsDependent(void)
{
	// name of the EXE file
	CString strEXEFile = m_strCWD + PROJDIR + PROJNAME + ".EXE";

	// if the EXE file exists, there's no need to run this test as a dependency
	if (_access(strEXEFile, 0) != -1) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

void CSysBuildTest::Run(void)
{
	OpenProject();
	BuildProject();
}

BOOL CSysBuildTest::OpenProject(void)
{
	BOOL bResult;

	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	// set the project's filename
	CString strProjFile = m_strCWD + PROJDIR + PROJNAME + ".DSP";

	// open the project
	GetLog()->RecordInfo("Opening the project file '%s'...", (LPCSTR)strProjFile);

	// if the project's already open, no need to open it again
	if (pPrj->IsOpen()) {
		GetLog()->RecordSuccess("The project '%s' is already open.", (LPCSTR)(pPrj->GetFullPath()));
		return TRUE;
	}
	else {
		// open the project
		bResult = GetLog()->RecordCompare((pPrj->Open(strProjFile, 0) == ERROR_SUCCESS), "Opening the project file '%s'.", (LPCSTR)strProjFile);
		if (!bResult) {
			throw CTestException("CSysBuildTest::OpenProject: cannot open project; unable to continue.", CTestException::causeOperationFail);
		}
		return bResult;
	}
}

BOOL CSysBuildTest::BuildProject(void)
{
	BOOL bResult;

	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	COConnection* pConnec;

	GetLog()->RecordInfo("Setting the debug connection for the project...");

	// set the debug connection
	pConnec = GetSubSuite()->GetIDE()->GetConnectionInfo();
	GetLog()->RecordCompare(pConnec->SetAll() == ERROR_SUCCESS, "Setting the debug connection for the project.");

	GetLog()->RecordInfo("Setting the remote path for the project...");
	if (pConnec->GetUserConnections() != CONNECTION_LOCAL ) {
		// set the remote path
		GetLog()->RecordCompare(pPrj->SetRemotePath((CString)PROJNAME + ".Exe") == ERROR_SUCCESS, "Setting the remote path for the project.");
	}
	else {
		GetLog()->RecordSuccess("The project is being built locally; no need to set the remote path.");
	}

	GetLog()->RecordInfo("Building project...");

	// build the project
	GetLog()->RecordCompare(pPrj->Build( 60 ) == ERROR_SUCCESS, "Building project.");

	GetLog()->RecordInfo("Copying the EXE to the remote machine...");
	if ( (GetUserTargetPlatforms() == PLATFORM_WIN32S_X86) ||
		 ((GetUserTargetPlatforms() == PLATFORM_WIN32_X86) &&
		  (pConnec->GetUserConnections() != CONNECTION_LOCAL)) ) {

		// figure out the name of the EXE file
		char acFilename[_MAX_FNAME];
		_splitpath(pPrj->GetFullPath(), NULL, NULL, acFilename, NULL);

		CString strEXEFile = CString(pPrj->GetDir()) + acFilename + ".EXE";

		// copy the EXE
		GetLog()->RecordCompare(pPrj->UpdateRemoteFile(strEXEFile) == ERROR_SUCCESS, "Copying the EXE '%s' to the remote Win32 or Win32s machine.", strEXEFile);
	}
	else {
		GetLog()->RecordSuccess("The EXE is either local or copied by the build process; no need to copy to the remote machine.");
	}

	GetLog()->RecordInfo("Verifying the build...");

	// verify the build
	bResult = GetLog()->RecordCompare(pPrj->VerifyBuild(TRUE, NULL, NULL, TRUE) == ERROR_SUCCESS, "Verifying the build.");
	if (!bResult) {
		throw CTestException("CSysBuildTest::BuildProject: cannot build an AppWizard project; unable to continue.", CTestException::causeOperationFail);
	}
	return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// CSysDebugPrjTest: SYS debug test

IMPLEMENT_TEST(CSysDebugPrjTest, CTest, "Debug (and E&C) AppWizard Project", 9, CSysSubSuite)

void CSysDebugPrjTest::Run(void)
{
	OpenProject();
/* ENCCases() might go here
	but link step is broken right now
	so we pushed it down for a while		
end of ENC test*/
	SetBreakpoint();
	RunToBreakpoint();
	StepOut();
	GoToDefinition();
	// TODO (MICHMA): THIS IS THE IDE TIMING PROBLEM
	// StepToCursor();
	// StepOver();
	Restart();
	//VerifyENCRelink() shld go here if ENCCases() above?
	StepIntoMFC();
	StopDebugging();

	// e&c not supported on alpha.
    #if defined(_ALPHA_)
		ClearAllBreakpoints();
	#else
		ENCCases();//TODO move it above
		StopDebugging();
		VerifyENCRelink();//TODO move it above
		ClearAllBreakpoints();
		//must build browse info which was altered but not built by ENC
		GetSubSuite()->m_prj.Build( 60 );
		VerifyENCRelink();
	#endif
}

BOOL CSysDebugPrjTest::OpenProject(void)
{
	BOOL bResult;

	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	// set the project's filename
	CString strProjFile = m_strCWD + PROJDIR + PROJNAME + ".DSP";

	// open the project
	GetLog()->RecordInfo("Opening the project file '%s'...", (LPCSTR)strProjFile);

	// if the project's already open, no need to open it again
	if (pPrj->IsOpen()) {
		GetLog()->RecordSuccess("The project '%s' is already open.", (LPCSTR)(pPrj->GetFullPath()));
		return TRUE;
	}
	else {
		// open the project
		bResult = GetLog()->RecordCompare((pPrj->Open(strProjFile, 0) == ERROR_SUCCESS), "Opening the project file '%s'.", (LPCSTR)strProjFile);
		if (!bResult) {
			throw CTestException("CSysDebugPrjTest::OpenProject: cannot open project; unable to continue.", CTestException::causeOperationFail);
		}
		return bResult;
	}
}

BOOL CSysDebugPrjTest::SetBreakpoint(void)
{
	BOOL bResult;

	// get the breakpoint component from the subsuite
	COBreakpoints* pBP = &(GetSubSuite()->m_bp);

	// store the breakpoint location
	CString strBPLoc = "CSysTestDoc::CSysTestDoc";

	GetLog()->RecordInfo("Setting a breakpoint on '%s'...", strBPLoc);

	// set the breakpoint
	bResult = GetLog()->RecordCompare(pBP->SetBreakpoint(strBPLoc) != NULL, "Setting a breakpoint on '%s'.", strBPLoc);
	if (!bResult) {
		throw CTestException("CSysDebugPrjTest::SetBreakpoint: cannot set the breakpoint; unable to continue.", CTestException::causeOperationFail);
	}
	return bResult;
}

BOOL CSysDebugPrjTest::RunToBreakpoint(void)
{
	BOOL bResult;

	// get the debugger component from the subsuite
	CODebug* pDebugger = &(GetSubSuite()->m_dbg);

	// store the expected break location
	CString strBreakLoc = "CSysTestDoc::CSysTestDoc";

	GetLog()->RecordInfo("Running until breakpoint at '%s' is hit...", strBreakLoc);

	// run
	bResult = GetLog()->RecordCompare(pDebugger->Go(NULL, NULL, strBreakLoc), "Running until breakpoint at '%s' is hit.", strBreakLoc);
	if (!bResult) {
		throw CTestException("CSysDebugPrjTest::RunToBreakpoint: cannot run to the breakpoint; unable to continue.", CTestException::causeOperationFail);
	}
	return bResult;
}

BOOL CSysDebugPrjTest::StepOut(void)
{
	// get the debugger component from the subsuite
	CODebug* pDebugger = &(GetSubSuite()->m_dbg);

	// store the expected break location
	CString strBreakLoc;
	
	// The following command line switch is mapped as follows:
	//	0 - APPWIZ_OPTIONS::AW_OLE_NONE (Default)
	//  1 - APPWIZ_OPTIONS::AW_OLE_CONTAINER
	//  2 - APPWIZ_OPTIONS::AW_OLE_MINISERVER
	//  3 - APPWIZ_OPTIONS::AW_OLE_FULLSERVER
	//  4 - APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER
	APPWIZ_OPTIONS::OLESupport ole_choice = (APPWIZ_OPTIONS::OLESupport)CMDLINE->GetIntValue("OLE", 4);

	switch(ole_choice)
	{
	case APPWIZ_OPTIONS::AW_OLE_NONE:
		strBreakLoc = "IMPLEMENT_DYNCREATE(CSysTestDoc, CDocument)";
		break;
	case APPWIZ_OPTIONS::AW_OLE_CONTAINER:
		strBreakLoc = "IMPLEMENT_DYNCREATE(CSysTestDoc, COleDocument)";
		break;
	case APPWIZ_OPTIONS::AW_OLE_FULLSERVER:
	case APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER:
		strBreakLoc = "IMPLEMENT_DYNCREATE(CSysTestDoc, COleServerDoc)";
		break;
	default:
		GetLog()->RecordFailure("Unsupported OLE option detected in CSysDebugPrjTest::StepOut");
		break;
	}

	if (!strBreakLoc.IsEmpty())
	{
		GetLog()->RecordInfo("Stepping out to '%s'.", strBreakLoc);

		// step out
		return GetLog()->RecordCompare(pDebugger->StepOut( 1, NULL, strBreakLoc), "Stepping out to '%s'.", strBreakLoc);
	}
	else
		return FALSE;
}

BOOL CSysDebugPrjTest::GoToDefinition(void)
{
	BOOL bResult;

	// get the browser from the subsuite
	COBrowse* pBrowser = &(GetSubSuite()->m_brz);

	// store the symbol to browse to
	CString strSymbol = "CSysTestView::OnDraw";

	GetLog()->RecordInfo("Going to the definition of '%s'.", strSymbol);

	// navigate
	bResult = GetLog()->RecordCompare(pBrowser->GotoNthDefinition(1, strSymbol), "Going to the definition of '%s'.", strSymbol);
	if (!bResult) {
		throw CTestException("CSysDebugPrjTest::GoToDefinition: cannot browse to definition; unable to continue.", CTestException::causeOperationFail);
	}
	return bResult;
}

BOOL CSysDebugPrjTest::StepToCursor(void)
{
	// get the debugger component from the subsuite
	CODebug* pDebugger = &(GetSubSuite()->m_dbg);

	GetLog()->RecordInfo("Stepping to the cursor location...");

	// TODO (michma): due to a timing problem in the ide we can't use run-to-cursor.
	// we've decided not to fix the timing problem so we need to figure out how to
	// properly slow-down the test at this point. set bp and go is a work-around.
	COBreakpoints bp;
	bp.SetBreakpoint();
	pDebugger->Go();
	return TRUE;

	// step to cursor
	//return GetLog()->RecordCompare(pDebugger->StepToCursor(), "Stepping to the cursor location.");
}

BOOL CSysDebugPrjTest::StepOver(void)
{
	// get the debugger component from the subsuite
	CODebug* pDebugger = &(GetSubSuite()->m_dbg);

	// store the expected step location
	CString strStepLine = "CSysTestDoc* pDoc = GetDocument();";

	GetLog()->RecordInfo("Stepping (over) until reaching line '%s'.", strStepLine);

	// step over until line
	if (!GetLog()->RecordCompare(pDebugger->StepOverUntilLine(strStepLine), "Stepping (over) until reaching line '%s'.", strStepLine)) {
		return FALSE;
	}

	// store the expected step location
	strStepLine = "ASSERT_VALID(pDoc);";

	GetLog()->RecordInfo("Stepping (over) one line to '%s'.", strStepLine);

	// step over
	return GetLog()->RecordCompare(pDebugger->StepOver(1, NULL, strStepLine), "Stepping (over) one line to '%s'.", strStepLine);
}

BOOL CSysDebugPrjTest::Restart(void)
{
	// get the debugger component from the subsuite
	CODebug* pDebugger = &(GetSubSuite()->m_dbg);

	GetLog()->RecordInfo("Restarting the debug session...");

	// restart
	return GetLog()->RecordCompare(pDebugger->Restart(), "Restarting the debug session.");
}

BOOL CSysDebugPrjTest::StepIntoMFC(void)
{
	// get the debugger component from the subsuite
	CODebug* pDebugger = &(GetSubSuite()->m_dbg);

	GetLog()->RecordInfo("Stepping into MFC...");

	// step into AfxWinMain and verify callstack.
	return GetLog()->RecordCompare(pDebugger->StepIntoUntilFunc("AfxWinMain"), "Stepping into MFC.");
}

BOOL CSysDebugPrjTest::StopDebugging(void)
{
	// get the debugger component from the subsuite
	CODebug* pDebugger = &(GetSubSuite()->m_dbg);

	GetLog()->RecordInfo("Stop debugging the project...");

	// stop debugging
	return GetLog()->RecordCompare(pDebugger->StopDebugging(ASSUME_NORMAL_TERMINATION), "Stop debugging the project.");
}

BOOL CSysDebugPrjTest::ClearAllBreakpoints(void)
{
	// get the breakpoint component from the subsuite
	COBreakpoints* pBP = &(GetSubSuite()->m_bp);

	GetLog()->RecordInfo("Clearing all breakpoints in the project...");

	// clear all breakpoints
	return GetLog()->RecordCompare(pBP->ClearAllBreakpoints(), "Clearing all breakpoints in the project.");
}

BOOL CSysDebugPrjTest::ENCCases(void)
{
	CString strSourceFile = CString(PROJNAME) + ".CPP"; 
	COSource m_src;

	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC); //must close cause "OK" button in Resedit dialog hampers execution of src.Find()
	if(GetLog()->RecordCompare(m_src.Open(strSourceFile, m_strCWD + PROJDIR) == ERROR_SUCCESS, "Opening the source file '%s'.", (LPCSTR)strSourceFile))
	{
		CString strSearchText = GetLocString(IDSS_ADD_CONSTRUCT_CODE_HERE);
		if(GetLog()->RecordCompare(m_src.Find(strSearchText), "Searching for text '%s' in the source file.", (LPCSTR)strSearchText))
		{
			GetLog()->RecordInfo("Debugging & editing the source file.");
			// get the project from the subsuite
			COProject* pPrj = &(GetSubSuite()->m_prj);
			// get the debugger component from the subsuite
			CODebug* pDebugger = &(GetSubSuite()->m_dbg);
			// get the breakpoint component from the subsuite
			COBreakpoints* pBP = &(GetSubSuite()->m_bp);

			// this function will be inserted immediately before the constructor.
			CString strFuncName="func";
			CString strFunc = "void " + strFuncName + "(void){}";
			// a call to the function will be inserted within the constructor. 
			CString strFuncCall = strFuncName + "();";

			//m_src.SetCurrentLine(currentline-1);
			MST.DoKeyshWnd(UIWB.HWnd(),"{UP}"); //to set the BP at the previous line which is the entry point to the current constructor
			pBP->SetBreakpoint();

			int CurrentLine = m_src.GetCurrentLine();
			CString strline; strline.Format("@%d", CurrentLine);

			GetLog()->RecordCompare(pDebugger->Go()==TRUE && pDebugger->CurrentLineIs(strline)==TRUE,
				"Break at line: %s in EnC test", strline);

			// insert the function.
			m_src.InsertText(strFunc, CurrentLine - 2, 1, TRUE);
			m_src.TypeTextAtCursor("{ENTER}");
			// insert the function call.
			m_src.InsertText("{ENTER}", CurrentLine + 3, 0);
			m_src.TypeTextAtCursor(strFuncCall, TRUE);

			GetLog()->RecordCompare(pDebugger->StepOver(1, NULL, strFuncCall)==TRUE, "Start EnC steping");
			GetLog()->RecordCompare(pDebugger->StepInto(1, strFuncName, strFunc)==TRUE, "Step into new function");
			 //stepout to the last line of ctor (it was empty by default)
			GetLog()->RecordCompare(pDebugger->StepOut(1, NULL, /*line*/"}")==TRUE, "Step out of new function");
	
		}
		else 
			return FALSE;
	}
	else
		return FALSE;
	return TRUE;
}

void CSysDebugPrjTest::VerifyENCRelink(void)
{
	//verify the automatic relink of the changes in the project is correct
	(&GetSubSuite()->m_prj)/*pPrj*/->WaitUntilBuildDone(1); //1 min waiting for relink
	GetLog()->RecordCompare(
		(&GetSubSuite()->m_prj)/*pPrj*/->VerifyBuild(TRUE, NULL, NULL, TRUE) == ERROR_SUCCESS,
		"Verifying the EnC relink.");
}


///////////////////////////////////////////////////////////////////////////////
// CSysDebugExeTest: SYS EXE debug test

IMPLEMENT_TEST(CSysDebugExeTest, CTest, "Debug AppWizard Executable", -1, CSysSubSuite)


void CSysDebugExeTest::Run(void)

{
	// TODO(michma - 4/22/98): 
	// there's some weird timing/focus bug on nt5 where the Debug.Break doesn't get sent to the ide.
	if(GetSystem() & SYSTEM_NT_5)
		return;

	// the support layer objects we will need for this test.
	COProject prj;
	CODebug dbg;
	COBreakpoints bps;
	COStack stk;
	COApplication app;
	COConnection *pConnect = GetSubSuite()->GetIDE()->GetConnectionInfo();

	// we don't support this test over a remote connection yet.
	if(pConnect->GetUserConnections() != CONNECTION_LOCAL)
		return;

	// attach our COProject object to the currently open project. 
	if(!LOG->RecordCompare(prj.Attach() == ERROR_SUCCESS, "attaching a COProject object to project '%s'.", PROJNAME))
		return;

	// execute the project's application.
	if(!LOG->RecordCompare(prj.Execute() == ERROR_SUCCESS, "launching the project's application."))
		return;

	// wait up to 30 seconds for the application to come up. SysTes1 is the name of the default document.
	// we need to look for the document name because the other part of the app title is the same as that used
	// in the ide's title when the project is loaded.
	if(!LOG->RecordCompare(app.Attach("SysTes1", 30), "attaching the debugger to the application."))
		return;

	// attach the debugger to the application's process.
	if(!LOG->RecordCompare(dbg.AttachToProcess(PROJNAME), "attaching the debugger to the application."))
		return;
	
	// break into the process
	if(!LOG->RecordCompare(dbg.Break(), "breaking into the process."))
		return;

	// restart the process.
	if(!LOG->RecordCompare(dbg.Restart(), "restarting the process."))
		return;

	// set a breakpoint on the project's document constructor.
	if(!LOG->RecordCompare(bps.SetBreakpoint("CSysTestDoc::CSysTestDoc") != NULL, "setting a bp on doc constructor."))
		return;

	// run to the breakpoint.
	if(!LOG->RecordCompare(dbg.Go(), "running to the bp."))
		return;

	// verify that the debugger landed in the correct function.
	if(!LOG->RecordCompare(stk.CurrentFunctionIs("CSysTestDoc::CSysTestDoc"), 
		"verifying current function is CSysTestDoc::CSysTestDoc."))
		return;

	// stop the debugger.
	if(!LOG->RecordCompare(dbg.StopDebugging(), "stopping debugging."))
		return;

	// clear all breakpoints.
	if(!LOG->RecordCompare(bps.ClearAllBreakpoints(), "clearing all breakpoints."))
		return;

	// close the project (required if we are looping).
	if(!LOG->RecordCompare(prj.Close() == ERROR_SUCCESS, "closing the project"))
		return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Stress\StressSubSuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	StressSubsuite.h
//
//	Created by :		Date:			
//		MichMa				1/28/98
//
//	Description :
//		Declaration of the CSysStressSubsuite class
//

#ifndef __StressSubsuite_H__
#define __StressSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSysStressSubsuite class

class CSysStressSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CSysStressSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__StressSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\ATLWiz\src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\System\Stress\StressCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	StressCase.CPP
//
//	Created by :			Date :
//		MichMa					1/28/98
//
//	Description :
//		Implementation of the CSysStressCase class

#include "stdafx.h"
#include "StressCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CSysStressCase, CTest, "System Stress", -1, CSysStressSubsuite)


void CSysStressCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
	// some required initialization.
	//m_strStressRoot = "\\\\msvc\\vcqa\\stress\\";
	m_strStressRoot = "e:\\cafe6\\tests\\system\\stress\\";
	m_intIterations = 0;
}


void CSysStressCase::Run(void)

{	 
	COProject prj;
	COSource src;
	CODebug dbg;
	COBreakpoints bp;
	CString strProjName;

	// initialize the web that will publish results for this stress run.
	InitiateWeb();

	// internationalize the project name.
	if(GetSystem() & SYSTEM_JAPAN)
		strProjName = "[\\]^{|}Aa`@~ AppWizard Project";
	// TODO (michma - 2/11/98): cafe needs to support SYSTEM_GERMAN.
	//else if(GetSystem() & SYSTEM_GERMAN)
	//	strProjName = " AppWizard Project";
	else
		strProjName = "AppWizard Project";
		
	// setup the options for the AppWizard project.
	APPWIZ_OPTIONS options;
	options.m_bUseMFCDLL = TRUE;
	options.m_OLECompound = APPWIZ_OPTIONS::AW_OLE_CONTAINERSERVER;

	// create a new AppWizard project
	if(!LOG->RecordCompare(prj.NewAppWiz(strProjName, GetCWD(), GetUserTargetPlatforms(), &options) == ERROR_SUCCESS,
		"Creating an AppWizard project named '%s'.", strProjName))
		return;

	// open the AppWizard project's main source file.
	if(!LOG->RecordCompare(src.Open(GetCWD() + strProjName + "\\" + strProjName + ".CPP") == ERROR_SUCCESS, 
		"Opening file '%s.CPP' for editing.", strProjName))
		return;
		
	// find the line where we are supposed to add construction code.
	if(!LOG->RecordCompare(src.Find(GetLocString(IDSS_ADD_CONSTRUCT_CODE_HERE)),
		"Searching file '%s.CPP' for place to insert code", strProjName))
		return;

	// we append a counter to each line added to distinguish them.
	char szLine[12];
	
	// add code, build, and debug in a loop forever.
	while(1)

	{
		// create a string version of the line counter.
		m_intIterations++;
		sprintf(szLine, "%d", m_intIterations);
		
		// insert a line of code.
		src.TypeTextAtCursor("{END}{ENTER}");
		src.TypeTextAtCursor("while(0); // line #" + (CString)szLine, TRUE);
		if(!LOG->RecordCompare(TRUE, "Adding a line of code to file '%s.CPP'.", strProjName))
			break;

		// set a bp on the new line.
		if(!LOG->RecordCompare(bp.SetBreakpoint() != NULL, "Setting a breakpoint on the new line."))
			break;

		// build the project.
		if(!LOG->RecordCompare(prj.Build() == ERROR_SUCCESS, "Building '%s' project.", strProjName))
			break;

		// verify no errors or warnings were generated.
		int iErr, iWarn;
		if(!LOG->RecordCompare(prj.VerifyBuild(TRUE, &iErr, &iWarn, TRUE) == ERROR_SUCCESS,
			"Verifying build of '%s' project.", strProjName))
			break;

		// run the debugger until the breakpoint.
		if(!LOG->RecordCompare(dbg.Go(), "Running the debugger until the new line."))
			break;

		// verify that the current line.
		if(!LOG->RecordCompare(dbg.CurrentLineIs("while(0); // line #" + (CString)szLine), "Verifying the current line."))
			break;

		// toggle the breakpoint off the new line.
		if(!LOG->RecordCompare(bp.SetBreakpoint() != NULL, "Toggle breakpoint off the new line."))
			break;

		// stop debugging.
		if(!LOG->RecordCompare(dbg.StopDebugging(), "Stop the debugger."))
			break;

		// update the web that publishes results for this stress run with an updated iteration count and running time.
		UpdateWeb();
	}
}


void CSysStressCase::InitiateWeb(void)

{
	// create a date string for the current date.
	time_t time_tCurrent = time(NULL);
	tm *pTMCurrent = localtime(&time_tCurrent);
	m_strCurrentDate.Format("%.2d-%.2d-%.2d", pTMCurrent->tm_mon, pTMCurrent->tm_mday, pTMCurrent->tm_year);

	// create a folder and webpage for this date if one doesn't exist already.
	// TODO(michma) what's the crt/win32 api func for that?

	//{
		CreateDirectory(m_strStressRoot + m_strCurrentDate, NULL);
		
		FILE *pfWebPage = fopen(m_strStressRoot + m_strCurrentDate + "\\" + m_strCurrentDate + ".htm", "w");
		fprintf(pfWebPage, "<body bgcolor=#FFFFFF>\n");
		fprintf(pfWebPage, "<hr>\n\n");
		fprintf(pfWebPage, "<table width=100%%>\n\n");
		fprintf(pfWebPage, "<tr>\n");
		fprintf(pfWebPage, "<td><u><b>MACHINE</b></u></td>\n");
		fprintf(pfWebPage, "<td><u><b>BUILD</b></u></td>\n");
		fprintf(pfWebPage, "<td><u><b>ITERATIONS</b></u></td>\n");
		fprintf(pfWebPage, "<td><u><b>TIME</b></u></td>\n");
		fprintf(pfWebPage, "<td><u><b>LOG</b></u></td>\n");
		fprintf(pfWebPage, "</tr>\n\n");
		fprintf(pfWebPage, "<comment>add entries here</comment>\n\n");
		fprintf(pfWebPage, "</table>\n");
		fclose(pfWebPage);


	//}

	// create a web p
}


void CSysStressCase::UpdateWeb(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\ATLWiz\src\ATLWizCase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ATLWizCase.CPP
//
//	Created by :			Date :
//		ChrisKoz					1/28/98
//
//	Description :
//		Implementation of the CSysATLWizCase class

#include "stdafx.h"
#include "ATLWizCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CSysATLWizCase, CTest, "System ATLWiz", -1, CSysATLWizSubsuite)




void CSysATLWizCase::LogResult(int line, int result,LPCSTR szoperation, int code /* 0 */, LPCSTR szComment /* "" */)
{
	CString szOpCom = (CString)szoperation + "  " + szComment;
	if(result == PASSED)
		m_pLog->RecordSuccess("%s", szOpCom);
	else
	{
		CString szextra;
		char chbuf[24];
		szextra = szextra + "Error Code = " + itoa(code, chbuf, 10);
		m_pLog->RecordFailure("LINE %d %s", line, szextra + szOpCom);
	}
}
#define EXPECT_TRUE(f)    ((f)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f,ReturnCode));
#define EXPECT_TRUE_COMMENT(f,comment) ((f)?LogResult(__LINE__, PASSED,#f,0,#comment):LogResult(__LINE__, FAILED,#f,0,#comment));



void CSysATLWizCase::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

//TODO: later move it ot coprjct.cpp
int CSysATLWizCase::InsertDialogATLObject(LPCSTR szObjectName)
{
	// TODO(michma): the ATL Object Wizard needs its own UI class with full functionality. 
	UIWB.DoCommand(IDM_NEW_ATL_OBJECT, DC_MNEMONIC);

 	// wait up to 3 seconds for the wizard dlg to come up. 
	if(!MST.WFndWndWait(GetLocString(IDSS_ATL_OBJ_WIZ_TITLE), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! COProject::InsertDialogATLObject - ATL Object Wizard dlg not found");
		return ERROR_ERROR;
	}

//select category
	MST.WListItemClk("@1", "Miscellaneous");
	WaitForInputIdle(g_hTargetProc, 5000); //the ListView to the right must update
//select the object type
	if(MST.WViewItemExists("@1", "Dialog")==FALSE)
	{
		LOG->RecordInfo("ERROR! COProject::InsertDialogATLObject - Dialog item not found in the list");
		return ERROR_ERROR;
	}
	MST.WViewItemClk("@1", "Dialog");
	// simply hit ENTER for next button for now.
	MST.DoKeys("{ENTER}");
	
	
	// wait up to 3 seconds for the wizard properties dlg to come up. 
	if(!MST.WFndWndWait(GetLocString(IDSS_ATL_OBJ_WIZ_PROP_TITLE), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! COProject::InsertDialogATLObject - ATL Object Wizard Properties dlg not found");
		return ERROR_ERROR;
	}
	
	// simply enter the shortname of the object for now.
	MST.DoKeys(szObjectName);
	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait around a few seconds in case we need to confirm using an existing class id.
	if(MST.WFndWndWaitC(GetLocString(IDSS_USE_EXISTING_CLASS_ID), "Static", FW_PART, 5))
		MST.DoKeys("{ENTER}");

 	// wait up to 10 seconds for the wizard properties dlg to go away. 
	if(!MST.WFndWndWait(GetLocString(IDSS_ATL_OBJ_WIZ_PROP_TITLE), FW_NOEXIST | FW_PART, 10))
	{
		LOG->RecordInfo("ERROR! COProject::InsertDialogATLObject - ATL Object Wizard Properties dlg didn't go away");
		return ERROR_ERROR;
	}

	return ERROR_SUCCESS;
}



#define IDSS_MEMBER_FUNCTION	"Add Member Function"
#define IDSS_ATL_MESSAGES_TITLE "New Windows Message and Event Handlers for class "
int CSysATLWizCase::InsertATLMessageHandler(LPCSTR szMessageName, LPCSTR szClasName, LPCSTR szProjectName /*=NULL*/)
{
	UIWorkspaceWindow wnd;

	int ret=ERROR_SUCCESS;
	wnd.ActivateClassPane();
	if(wnd.SelectClass(szClasName, szProjectName)!=SUCCESS)
		return FALSE;
	
	MST.DoKeyshWnd(UIWB.HWnd(), "+{F10}");
	Sleep(1000); //xtra safety
	MST.DoKeyshWnd(UIWB.HWnd(), "{Home}");
	
	MST.WMenu("&" + GetLocString(IDSS_WIZBAR_HANDLER));
	WaitForInputIdle(g_hTargetProc, 5000); //the dialog comes up slowly
	EXPECT_TRUE(MST.WFndWndWait(IDSS_ATL_MESSAGES_TITLE, FW_FOCUS | FW_PART, 5) );

	MST.WListItemClk("@3", szClasName);
	MST.WListItemClk("@1",szMessageName);
	MST.WButtonClick(GetLabel(0x639F)); //"Add and Exit"

	EXPECT_TRUE(MST.WFndWndWait(IDSS_MEMBER_FUNCTION, FW_NOEXIST, 10));
	EXPECT_TRUE(MST.WFndWndWait(IDSS_ATL_MESSAGES_TITLE, FW_NOEXIST | FW_PART, 10) );

	WaitForInputIdle(g_hTargetProc, 10000); //the dialog goes away slowly
	return ERROR_SUCCESS;
}


//GetLocString(IDSS_ATL_MESSAGES_TITLE)
int CSysATLWizCase::InsertATLEventHandler(LPCSTR szMessageName, LPCSTR szClasName, LPCSTR szObjectName, LPCSTR szProjectName /*=NULL*/)
{
	UIWorkspaceWindow wnd;

	int ret=ERROR_SUCCESS;
	wnd.ActivateClassPane();
	if(wnd.SelectClass(szClasName, szProjectName)!=SUCCESS)
		return FALSE;
	
	MST.DoKeyshWnd(UIWB.HWnd(), "+{F10}");
	Sleep(1000); //xtra safety
	MST.DoKeyshWnd(UIWB.HWnd(), "{Home}");
	
	MST.WMenu("&" + GetLocString(IDSS_WIZBAR_HANDLER));
	WaitForInputIdle(g_hTargetProc, 5000); //the dialog comes up slowly
	EXPECT_TRUE(MST.WFndWndWait(IDSS_ATL_MESSAGES_TITLE, FW_FOCUS | FW_PART, 5) );
	
	MST.WListItemClk("@3", szObjectName);
	MST.WListItemClk("@1",szMessageName);
	MST.WButtonClick(GetLabel(0x639F)); //"Add and Exit"
	
	EXPECT_TRUE(MST.WFndWndWait(IDSS_MEMBER_FUNCTION, FW_FOCUS, 5) );
	EXPECT_TRUE(MST.WStaticExists(szObjectName) );
	MST.WButtonClick(GetLabel(IDOK));
 	// wait up to 10 seconds for the Messages dlg to go away. 
	EXPECT_TRUE(MST.WFndWndWait(IDSS_MEMBER_FUNCTION, FW_NOEXIST, 10));
	EXPECT_TRUE(MST.WFndWndWait(IDSS_ATL_MESSAGES_TITLE, FW_NOEXIST | FW_PART, 10) );

	WaitForInputIdle(g_hTargetProc, 10000); //the dialog goes away slowly
	return ERROR_SUCCESS;
}


void CSysATLWizCase::Run(void)
{	 
	COProject prj;
	COSource src;

	// TODO(ChrisKoz): internationalize the project name.
	CString strProjName = "ATLWizard Project";
	CString strObjectName = "DlgObject";
	
	KillAllFiles(GetCWD() + strProjName, TRUE);//It does not need to be in CSubSuite::Cleanup()
//create the ATL project
	// set the name and location of the atl com server project. we also want the project to be added to
	// the current workspace.
	CATLCOMWizOptions *pATLCOMWizOpt = new(CATLCOMWizOptions);
	pATLCOMWizOpt->m_acstServerType = CATLCOMWizOptions::ATL_COM_SERVER_EXE;
	pATLCOMWizOpt->m_bSupportMFC = TRUE;//just for the heck of it
	pATLCOMWizOpt->m_strLocation = GetCWD();
	pATLCOMWizOpt->m_strName = strProjName;	
	pATLCOMWizOpt->m_pwWorkspace = ADD_TO_CURRENT_WORKSPACE;
//	pATLCOMWizOpt->m_phHierarchy = SUB_PROJ;
//	pATLCOMWizOpt->m_strParent = m_strAppProjName; 
	
	// create the activex control project.
	LOG->RecordCompare(prj.New(pATLCOMWizOpt) == ERROR_SUCCESS, 
		"Create ATL COM Server project named: %s", pATLCOMWizOpt->m_strName);


// select the ATL project so we can add a new object to it.
	prj.SetTarget((CString)strProjName + " - " + 
					GetLocString(IDSS_PLATFORM_WIN32) + " " +
					GetLocString(IDSS_BUILD_DEBUG));

//add the Dialog ATL object
	LOG->RecordCompare(InsertDialogATLObject(strObjectName) == ERROR_SUCCESS, 
		"Insert Dlg object '%s' into '%s' project.", strObjectName, strProjName);

//add the ActiveX control to the dialog here, as we don't know the name of a dialog, so it's hard to navigate the reesource pane to see it
//select the name 'szCtrlName' in porperties		
	CString strCtrlName = "DBGrid  Control";
	CString strCtrlID = "IDC_DBgrid";
	
	LOG->RecordInfo("Inserting '%s' ActiveX control into the dialog", strCtrlName);
	MST.DoKeys("+{F10}");				// Shift+F10 brings up context menu
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(500);
	MST.DoKeys("X"); //insert ActiveX control

	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(1000);
	CString listlabel=GetLabel(0x6ad6)/* OLE_CONTROL_LIST*/;
	int nelem=MST.WListCount(listlabel);
	if(MST.WListItemExists(listlabel,strCtrlName))
		MST.WListItemClk (listlabel,strCtrlName);
	else
	{
		LOG->RecordFailure("'%s' item does not exist in list '%s'. Clicked the first one", strCtrlName, listlabel);
		MST.WListItemClk (listlabel,1);
	}
	MST.WButtonClick(GetLabel(IDOK)); //OLE control chosen
		
	if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
	{
		LOG->RecordFailure("ActiveX control hanged...");
		return /* ERROR_ERROR*/;
	}
	Sleep(2000); //bug DBgrid GPFaults if I do not insert the sleep here

//bring the property of inserted control & set it to desired text
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	BOOL bResult;
	if((bResult=prop.IsValid())==FALSE)
	{
		LOG->RecordFailure("Cannot access the property of control: '%s'",strCtrlName);
	}
	prop.SetID(strCtrlID);
	prop.Close();	
	
	
	LOG->RecordCompare(InsertATLEventHandler("Click", "C" + strObjectName, strCtrlID)==ERROR_SUCCESS,
		"Insert event handler");

	
	LOG->RecordCompare(InsertATLMessageHandler("WM_PAINT", "C" + strObjectName)==ERROR_SUCCESS,
		"Insert message handler");

	// build the project.
	LOG->RecordCompare(prj.Build() == ERROR_SUCCESS, "Building '%s' project.", strProjName);
	
	// verify no errors or warnings were generated.
	int iErr, iWarn;
	LOG->RecordCompare(prj.VerifyBuild(TRUE, &iErr, &iWarn, TRUE) == ERROR_SUCCESS,
		"Verifying build of '%s' project.", strProjName);


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\ATLWiz\src\ATLWizSuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ATLWizSubsuite.CPP
//
//	Created by :			Date :			
//		ChrisKoz					1/28/98
//
//	Description :
//		implementation of the CSysATLWizSubsuite class
//

#include "stdafx.h"
#include "ATLWizSuite.h"
#include "afxdllx.h"

#include "ATLWizCase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSysATLWizSubsuite

IMPLEMENT_SUBSUITE(CSysATLWizSubsuite, CIDESubSuite, "System ATLWiz", "MichMa")

BEGIN_TESTLIST(CSysATLWizSubsuite)
	TEST(CSysATLWizCase, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\ATLWiz\src\ATLWizSuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	ATLWizsuite.h
//
//	Created by :		Date:			
//		ChrisKoz				1/28/98
//
//	Description :
//		Declaration of the CSysATLWizSubsuite class
//

#ifndef __ATLWizSubsuite_H__
#define __ATLWizSubsuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSysATLWizSubsuite class

class CSysATLWizSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CSysATLWizSubsuite)
	DECLARE_TESTLIST()
protected:
};

#endif //__ATLWizSubsuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\ATLWiz\src\ATLWizCase.h ===
///////////////////////////////////////////////////////////////////////////////
//	ATLWizCase.H
//
//	Created by :			Date :
//		ChrisKoz					1/28/98
//
//	Description :
//		Declaration of the CSysATLWizCase class

#ifndef __ATLWizCase_H__
#define __ATLWizCase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "ATLWizSuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CSysATLWizCase class

class CSysATLWizCase : public CTest
{
	DECLARE_TEST(CSysATLWizCase, CSysATLWizSubsuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
private:
	int InsertATLEventHandler(LPCSTR szMessageName, LPCSTR szClasName, LPCSTR szObjectName, LPCSTR szProjectName=NULL);
	int InsertATLMessageHandler(LPCSTR szMessageName, LPCSTR szClasName, LPCSTR szProjectName=NULL);
	int InsertDialogATLObject(LPCSTR szObjectName);
void LogResult(int line, int result,LPCSTR szoperation, int code = 0 , LPCSTR szComment = "" );

};

#endif //__ATLWizCase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\bin\src\browse.cpp ===
//
//	Simple applications used for testing browser
//

#include "browse.h"
#include "capp.h"
#include "ctest.h"
#include "cpptest.h"

CApp theApp;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR szCmdLine, int nCmdShow ) {
	
	if( theApp.InitApplication( hInstance, hPrevInstance, szCmdLine, nCmdShow ) ) {
		if( theApp.InitInstance() ) {
			return theApp.Run();
		}
	}
	ctest();
	cpptest();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\bin\src\browse.h ===
//
//	Include browse.h as first #include in every source file 
//

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\bin\src\capp.h ===
//
// class CApp 
//

class CApp {
public:
	BOOL InitApplication( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR szCmdLine, int nCmdShow );
	BOOL InitInstance();
	int Run();

private:
	HINSTANCE m_hInstance;
	HINSTANCE m_hPrevInstance;
	LPTSTR m_szCmdLine;
	int m_nCmdShow ;
	HWND m_hWnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\bin\src\capp.cpp ===
#include "browse.h"
#include "capp.h"

const LPCSTR szClassName = "BrowseApp";
const LPCSTR szAppName = "Browser Test";

LRESULT WINAPI WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) {
	switch( uMsg ) {
		case WM_DESTROY:
			PostQuitMessage( 0 );
			break;

		default:
			return DefWindowProc( hWnd, uMsg, wParam, lParam );
	}
	return 0;
}

BOOL CApp::InitApplication( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR szCmdLine, int nCmdShow ) {
	m_hInstance = hInstance;
	m_hPrevInstance = hPrevInstance;
	m_szCmdLine = szCmdLine;
	m_nCmdShow = nCmdShow ;

	// register class
	WNDCLASS wndClass;

	wndClass.style = CS_BYTEALIGNCLIENT|CS_BYTEALIGNWINDOW;
	wndClass.lpfnWndProc = WndProc;
	wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 0;
	wndClass.hInstance = m_hInstance;
	wndClass.hIcon = LoadIcon(m_hInstance, IDI_APPLICATION); // blank
	wndClass.hCursor = LoadCursor( m_hInstance, IDC_ARROW );
	wndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	wndClass.lpszMenuName = NULL;
	wndClass.lpszClassName = szClassName;

	return !!::RegisterClass( &wndClass );
}


BOOL CApp::InitInstance() {
	// create and show window
	HWND hWnd = CreateWindow( szClassName, 
		szAppName,
		WS_OVERLAPPEDWINDOW, 
		CW_USEDEFAULT,
		0,
		CW_USEDEFAULT,
		0,
		0,
		0,
		m_hInstance,
		0 );

	m_hWnd = hWnd;

	if( hWnd ) {
		ShowWindow( hWnd, m_nCmdShow );
		UpdateWindow( hWnd );
		return TRUE;
	}

	return FALSE;
}


int CApp::Run() {
	MSG msg;
	while( GetMessage( &msg, NULL, 0, 0 ) ) {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	}
	return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\bin\src\cpptest.h ===
//
//	cpptest.h
//

typedef int FOOTYPE;

class A {
public:
	virtual ~A();
	virtual void vfoo1();
	virtual void vfoo2();

private:
	int m_i;
};

class B {
public:
	virtual ~B();
	virtual void vfoo2();
	virtual void vfoo3();

private:
	int m_i;
};

class MI : public A, public B {
public:
	virtual void vfoo2();
	int InlineFoo() { return m_i; }
	static FOOTYPE StaticFoo(MI,MI);

private:
	int m_i;
	static m_si;
};

void cpptest();
void Afoos( A& );

#define FOOMAX(a,b) ( ((a)>(b))?(a):(b) )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\bin\src\cpptest.cpp ===
//
//	cpptest.cpp
//

#include "browse.h"
#include "cpptest.h"

static void Bfoos( B& b );

int MI::m_si = 0;

A::~A() {
}

void A::vfoo1() {
}

void A::vfoo2() {
}

B::~B() {
}

void B::vfoo2() {
}

void B::vfoo3() {
}

void MI::vfoo2() {
}

void cpptest() {
	MI mi;
	Afoos( mi );
	Bfoos( mi );
}

void Afoos( A& a ) {
	a.vfoo1();
	a.vfoo2();
}

static void Bfoos( B& b ) {
	b.vfoo2();
	b.vfoo3();
}

FOOTYPE MI::StaticFoo( MI a, MI b ) {
	m_si++;
	int ai = a.InlineFoo();
	int bi = b.InlineFoo();
	return FOOMAX(ai,bi);
}

// Add another definition for m_i to spice up ambiguity testing
static int m_i = 0;

void cpp_refto_mi() { int i = m_i; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\bin\src\ctest.h ===
/*
**	ctest.h
**		common "C" declarations
*/

#if defined( __cplusplus ) 
extern "C" {
#endif

typedef union holdtype_ {
	char c;
	short s;
	int i;
	long l;
	float f;
	double d;
} HOLDTYPE;

enum {
	TYPE_CHAR = 1,
	TYPE_SHORT,
	TYPE_INT,
	TYPE_LONG,
	TYPE_FLOAT,
	TYPE_DOUBLE,
};

typedef struct bitfield_ {
	int bit1 : 1;
	int bit2to4 : 3;
} BITFIELD;

typedef struct cstruct_ {
	BITFIELD type;
	HOLDTYPE data;
	struct cstruct_ *next;
} CSTRUCT;

#define MAX_ITEMS 10

extern int global_array[];

void ctest();
CSTRUCT* adddata( CSTRUCT* head, int type, void* data );

#if defined( __cplusplus ) 
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\bin\src\ctest.c ===
/*
**	ctest.c
**		c code
*/

#include "browse.h"
#include "ctest.h"
#include "malloc.h"

int global_array[MAX_ITEMS];

static CSTRUCT static_array[MAX_ITEMS];

static CSTRUCT* addtail();
static void setdata( CSTRUCT* ptr, int type, void* data );

void ctest() {
	CSTRUCT c;
	c.type.bit2to4 = TYPE_FLOAT;
	c.data.f = 5.123f;

	static_array[1] = c;
}

CSTRUCT* adddata( CSTRUCT* head, int type, void* data )
{
	CSTRUCT *p;
	p = malloc( sizeof( CSTRUCT ) );
	if( p )
	{
		setdata( p, type, data );
		return addtail( head, p );
	}
	else
		return NULL;
}

static CSTRUCT* addtail( head, data )

CSTRUCT *head, *data;

{
	if( head == NULL )
	{
		data->next = NULL;
		return data;
	}
	else if( head->next == NULL )
	{
		data->next = NULL;
		head->next = data;
		return data;
	}
	else
	{
		return addtail( head->next, data );
	}
}

static void setdata( CSTRUCT* ptr, int type, void* data )
{
	switch( type )
	{
		case TYPE_CHAR:
			ptr->data.c = *((char*)data);
			ptr->type.bit2to4 = TYPE_CHAR;
			break;

		case TYPE_SHORT:
			ptr->data.s = *((short*)data);
			ptr->type.bit2to4 = TYPE_SHORT;
			break;

		case TYPE_INT:
			ptr->data.i = *((int*)data);
			ptr->type.bit2to4 = TYPE_INT;
			break;

		case TYPE_LONG:
			ptr->data.l = *((long*)data);
			ptr->type.bit2to4 = TYPE_LONG;
			break;

		case TYPE_FLOAT:
			ptr->data.f = *((float*)data);
			ptr->type.bit2to4 = TYPE_FLOAT;
			break;

		case TYPE_DOUBLE:
			ptr->data.d = *((double*)data);
			ptr->type.bit2to4 = TYPE_DOUBLE;
			break;

	}
}

// Add another definition for m_i to spice up ambiguity testing
static int m_i = 0;

void c_refto_mi() { int i = m_i; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\filters.h ===
///////////////////////////////////////////////////////////////////////////////
//	FILTERS.H
//
//	Created by :			Date :
//		TomSe					1/31/94
//
//	Description :
//		Declaration of the CFilters class
//

#ifndef __FILTERS_H__
#define __FILTERS_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "queries.h"

class CFilters : public CQueries
{
	DECLARE_TEST(CFilters, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:
	COFile   file;
	COBrowse brz;
	COSource src;
};

#endif //__FILTERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\filters.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	FILTERS.CPP
//
//	Created by :			Date :
//		TomSe					1/31/94
//
//	Description :
//		Implementation of the CFilters class
//

#include "stdafx.h"
#include "sniff.h"
#include "filters.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// full info
static char* cppOutline[] = {
	"A (class)",
	"B (class)",
	"FOOMAX (macro)",
	"FOOTYPE (typedef)",
	"MI::InlineFoo(void)",
	"A::m_i",
	"B::m_i",
	"MI::m_i",
	"int  MI::m_si",	// Why are two spaces generated?
	"MI (class)",
	NULL,
};

static char* cppClasses[] = {
	"A (class)",
	"B (class)",
	"MI (class)",
	NULL,
};

static char* cppFunctions[] = {
	"MI::InlineFoo(void)",
	NULL,
};

static char* cppData[] = {
	"A::m_i",
	"B::m_i",
	"MI::m_i",
	"int  MI::m_si",	// Why are two spaces generated?
	NULL,
};

static char* cppMacros[] = {
	"FOOMAX (macro)",
	NULL,
};

static char* cppTypes[] = {
	"FOOTYPE (typedef)",
	NULL,
};

static char* MIMatches[] = {
	"MI (class)",
	NULL,
};

static char* MIBranches[] = {
	"A (class)",
	"B (class)",
	NULL,
};

static char* MINoBranches[] = {
	NULL,
};

// full info
static char* MIMembers[] = {
	"MI::InlineFoo(void)",
	"MI::StaticFoo(class MI,class MI)",
	"MI::vfoo2(void)",
	"MI::m_i",
	"int  MI::m_si",
	NULL,
};

static char* MIAllFun[] = {
	"MI::InlineFoo(void)",
	"MI::StaticFoo(class MI,class MI)",
	"MI::vfoo2(void)",
	NULL,
};

static char* MIVirtualFn[] = {
	"MI::vfoo2(void)",
	NULL,
};

static char* MIStaticFn[] = {
	"MI::StaticFoo(class MI,class MI)",
	NULL,
};

static char* MINonStatNonVirtFn[] = {
	"MI::InlineFoo(void)",
	NULL,
};

static char* MINonVirtFn[] = {
	"MI::InlineFoo(void)",
	"MI::StaticFoo(class MI,class MI)",
	NULL,
};

static char* MINonStatFn[] = {
	"MI::InlineFoo(void)",
	"MI::vfoo2(void)",
	NULL,
};

static char* MINone[] = {
	NULL,
};

static char* MIAllData[] = {
	"MI::m_i",
	"int  MI::m_si",
	NULL,
};

static char* MIStaticData[] = {
	"int  MI::m_si",
	NULL,
};

static char* MINonStatData[] = {
	"MI::m_i",
	NULL,
};

static LPCSTR szTestName = "Filters";

static QueryInfo qryTests[] = {
	{	szTestName, "FileOutline w/all symbols", FileOutline, "cpptest.h", cppOutline, NULL, NULL },
	{	szTestName, "FileOutline w/Classes", FileOutline, "cpptest.h", cppClasses, NULL, NULL, CLASSES },
	{	szTestName, "FileOutline w/Functions", FileOutline, "cpptest.h", cppFunctions, NULL, NULL, FUNCTIONS },
	{	szTestName, "FileOutline w/Data", FileOutline, "cpptest.h", cppData, NULL, NULL, DATA },
	{	szTestName, "FileOutline w/Macros", FileOutline, "cpptest.h", cppMacros, NULL, NULL, MACROS },
	{	szTestName, "FileOutline w/Types", FileOutline, "cpptest.h", cppTypes, NULL, NULL, TYPES },
	{	szTestName, "Base Class: All", BaseClass,	"MI", MIMatches, MIBranches, MIMembers, AllFNCs|AllData },
	{	szTestName, "Base Class: All Functions", BaseClass,	"MI", MIMatches, MIBranches, MIAllFun, AllFNCs|NoData },
	{	szTestName, "Base Class: Virtual Functions", BaseClass,	"MI", MIMatches, MIBranches, MIVirtualFn, Virtual|NoData },
	{	szTestName, "Base Class: Static Functions", BaseClass,	"MI", MIMatches, MIBranches, MIStaticFn, Static|NoData },
	{	szTestName, "Base Class: Non-virtual Functions", BaseClass,	"MI", MIMatches, MIBranches, MINonVirtFn, NonVirtual|NoData },
	{	szTestName, "Base Class: Non-static Functions", BaseClass,	"MI", MIMatches, MIBranches, MINonStatFn, NonStatic|NoData },
	{	szTestName, "Base Class: Non-virtual Non-static Functions", BaseClass,	"MI", MIMatches, MIBranches, MINonStatNonVirtFn, NSNV|NoData },
	{	szTestName, "Base Class: No Functions, No Data", BaseClass,	"MI", MIMatches, MIBranches, MINone, NoFCNs|NoData },
	{	szTestName, "Base Class: All Data", BaseClass,	"MI", MIMatches, MIBranches, MIAllData, NoFCNs|AllData },
	{	szTestName, "Base Class: Static Data", BaseClass,	"MI", MIMatches, MIBranches, MIStaticData, NoFCNs|StaticData },
	{	szTestName, "Base Class: Non-static Data", BaseClass,	"MI", MIMatches, MIBranches, MINonStatData, NoFCNs|NonStaticData },
#if 0	// Assume that derived tests work if base class work
	{	szTestName, "Derived Class: All", DerivedClass,	"MI", MIMatches, MINoBranches, MIMembers, AllFNCs|AllData },
	{	szTestName, "Derived Class: All Functions", DerivedClass,	"MI", MIMatches, MINoBranches, MIAllFun, AllFNCs|NoData },
	{	szTestName, "Derived Class: Virtual Functions"", DerivedClass,	"MI", MIMatches, MINoBranches, MIVirtualFn, Virtual|NoData },
	{	szTestName, "Derived Class: Static Functions", DerivedClass,	"MI", MIMatches, MINoBranches, MIStaticFn, Static|NoData },
	{	szTestName, "Derived Class: Non-virtual Functions"", DerivedClass,	"MI", MIMatches, MINoBranches, MINonVirtFn, NonVirtual|NoData },
	{	szTestName, "Derived Class: Non-static Functions", DerivedClass,	"MI", MIMatches, MINoBranches, MINonStatFn, NonStatic|NoData },
	{	szTestName, "Derived Class: Non-virtual Non-static Functions", DerivedClass,	"MI", MIMatches, MINoBranches, MINonStatNonVirtFn, NSNV|NoData },
	{	szTestName, "Derived Class: No Functions, No Data", DerivedClass,	"MI", MIMatches, MINoBranches, MINone, NoFCNs|NoData },
	{	szTestName, "Derived Class: All Data", DerivedClass,	"MI", MIMatches, MINoBranches, MIAllData, NoFCNs|AllData },
	{	szTestName, "Derived Class: Static Data", DerivedClass,	"MI", MIMatches, MINoBranches, MIStaticData, NoFCNs|StaticData },
	{	szTestName, "Derived Class: Non-static Data", DerivedClass,	"MI", MIMatches, MINoBranches, MINonStatData, NoFCNs|NonStaticData },
#endif
};

const int numTests = ( sizeof( qryTests ) ) / sizeof( QueryInfo );

IMPLEMENT_TEST(CFilters, CQueries, "Filters Tests", -1, CSniffDriver)

void CFilters::Run(void)
{
	if(GetSubSuite()->InitProject() == ERROR_SUCCESS)
		{
		for( int i = 0; i < numTests; i++ )
			TestQuery( qryTests[i] );
		}
	else
		m_pLog->RecordFailure("src\\browse.mak failed to open or build");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\queries.h ===
///////////////////////////////////////////////////////////////////////////////
//	QUERIES.H
//
//	Created by :			Date :
//		TomSe					1/31/94
//
//	Description :
//		Declaration of the CQueries class
//

#ifndef __QUERIES_H__
#define __QUERIES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

struct QueryInfo {
	LPCSTR name;
	LPCSTR desc;
	QueryType type;
	LPCSTR	symbolname;
	char** matches;
	char** branches;	// Only 1st level for class or function trees.
	char** members;	// Only for class queries.
	int filters;
	int amb;
};

///////////////////////////////////////////////////////////////////////////////
//	BrzTestOutln class

class CQueries : public CTest
{
	DECLARE_TEST(CQueries, CSniffDriver)

// ctor needed since this class also operates as a base class
public:
	CQueries(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

// Operations
public:
	virtual void Run(void);

// Data
protected:
	COFile   file;
	COBrowse brz;
	COSource src;


// Test Outln
protected:
	BOOL TestQuery(const QueryInfo&);
};

#endif //__QUERIES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\navig.h ===
///////////////////////////////////////////////////////////////////////////////
//	NAVIG.H
//
//	Created by :			Date :
//		TomSe					1/31/94
//
//	Description :
//		Declaration of the CBrzTestGoto class
//

#ifndef __NAVIG_H__
#define __NAVIG_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

//
//	Foward decl for SymbolInfo needed for CBrzTestGoto::GotoSingleDef() decl.
//	Definition is in BrzGoto.cpp.
//
struct SymbolInfo;

///////////////////////////////////////////////////////////////////////////////
//	BrzTestGoto class

enum GotoType;

class CNavigate : public CTest
{
	DECLARE_TEST(CNavigate, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:
	COFile   file;
	COBrowse brz;
	COSource src;


// Test Goto
protected:
	BOOL GotoTest( const SymbolInfo&);
};

#endif //__NAVIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\queries.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BRZOutln.CPP
//
//	Created by :			Date :
//		TomSe					1/31/94
//
//	Description :
//		Implementation of the CQueries class
//

#include "stdafx.h"
#include "sniff.h"
#include "queries.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

static char* m_iDefRef[] = {
	"m_i (variable)",
	"A::m_i",
	"B::m_i",
	"MI::m_i",
	NULL,
};

static char* cppOutline[] = {
	"A (class)",
	"B (class)",
	"FOOMAX (macro)",
	"FOOTYPE (typedef)",
	"MI::InlineFoo(void)",
	"A::m_i",
	"B::m_i",
	"MI::m_i",
	"int  MI::m_si",	// Why are two spaces generated?
	"MI (class)",
	NULL,
};

static char* MIMatches[] = {
	"MI (class)",
	NULL,
};

static char* MIBranches[] = {
	"A (class)",
	"B (class)",
	NULL,
};

static char* MIMembers[] = {
	"MI::InlineFoo(void)",
	"MI::StaticFoo(class MI,class MI)",
	"MI::vfoo2(void)",
	"MI::m_i",
	"int  MI::m_si",
	NULL,
};

static char* AMatches[] = {
	"A (class)",
	NULL,
};

static char* ABranches[] = {
	"MI (class)",
	NULL,
};

static char* AMembers[] = {
	"A::~A(void)",
	"A::vfoo1(void)",
	"A::vfoo2(void)",
	"A::m_i",
	NULL,
};

static char* vfoo2Matches1[] = {
	"A::vfoo2(void)",
	"B::vfoo2(void)",
	"MI::vfoo2(void)",
	NULL,
};

static char* vfoo2Branches1[] = {
	NULL,
};

static char* vfoo2Matches2[] = {
	"A::vfoo2(void)",
	"B::vfoo2(void)",
	"MI::vfoo2(void)",
	NULL,
};

static char* vfoo2Branches2[] = {
	"Bfoos(class B &)",
	NULL,
};

static char* cpptestMatches[] = {
	"cpptest(void)",
	NULL,
};

static char* cpptestBranches[] = {
	"Afoos(class A &)",
	"Bfoos(class B &)",
	NULL,
};

static char* addtailMatches[] = {
	"addtail (function)",
	NULL,
};

static char* addtailBranches[] = {
	"adddata (function)",
	"addtail (function)",
	NULL
};

static LPCSTR szTestName = "Queries";

static QueryInfo qryTests[] = {
	{	szTestName, "Definitions and References", DefRef, "m_i", m_iDefRef, NULL, NULL },
	{	szTestName, "File Outline", FileOutline, "cpptest.h", cppOutline, NULL, NULL },
	{	szTestName, "Base Class and Members", BaseClass,	"MI", MIMatches, MIBranches, MIMembers },
	{	szTestName, "Derived Class and Members", DerivedClass,	"A", AMatches, ABranches, AMembers },
	{	szTestName, "Call Graph w/ambiguity", CallGraph,	"vfoo2", vfoo2Matches1, vfoo2Branches1, NULL, 0, 2 },	// Should be B::vfoo2
	{	szTestName, "Caller Graph w/ambiguity", CallerGraph,	"vfoo2", vfoo2Matches2, vfoo2Branches2, NULL, 0, 2 },	// Should be B::vfoo2
	{	szTestName, "Call Graph", CallGraph,	"cpptest", cpptestMatches, cpptestBranches, NULL },
	{	szTestName, "Caller Graph w/recursive function", CallerGraph,	"addtail", addtailMatches, addtailBranches, NULL },	// Recursion
};

const int numTests = ( sizeof( qryTests ) ) / sizeof( QueryInfo );

IMPLEMENT_TEST(CQueries, CTest, "Query Tests", -1, CSniffDriver)

// since this class can also be used as a base class for tests, we need to
// provide the appropriate ctor for the derived class to call
CQueries::CQueries(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: CTest(pSubSuite, szName, nExpectedCompares, szListFilename)
{
}

void CQueries::Run(void)
{
	COWorkSpace ws;
	if(GetSubSuite()->InitProject() == ERROR_SUCCESS)
		{
		for( int i = 0; i < numTests; i++ )
			TestQuery( qryTests[i] );
		}
	else
		m_pLog->RecordFailure("src\\browse.mak failed to open or build");
    ws.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Outln

//
//
BOOL CQueries::TestQuery( const QueryInfo& test) {
	BOOL allpass = TRUE;
	BOOL result;
	CStringArray strings;
	int index;

	result = brz.GetMatches( strings, test.symbolname, test.type, test.filters );
	for( index=0; index < strings.GetSize() && result; index++ ) {
		if( test.matches[index] == NULL ) {
			m_pLog->RecordInfo( "CQueries::TestQuery - test.matches[%d] == NULL", index );
			result = FALSE;
			break;
		}
		else {
			if( strings[index] != test.matches[index] ) {
				m_pLog->RecordInfo( "CQueries::TestQuery - %s != %s",(LPCTSTR)strings[index], test.matches[index]  );
				result = FALSE;
				break;
			}
		}
	}
	if( result && test.matches[ strings.GetSize() ] != NULL ) {
		m_pLog->RecordInfo( "CQueries::TestQuery - test.matches has more data that wasn't compared" );
		result = FALSE;
	}

	allpass = allpass && result;

	if( test.type != FileOutline && test.type != DefRef ) {
		EXPECT( test.branches );
		result = brz.GetFirstLevelBranches( strings, test.symbolname, test.type, test.filters, test.amb-1 );

		for( index=0; index < strings.GetSize() && result; index++ ) {
			if( test.branches[index] == NULL ) {
				m_pLog->RecordInfo( "CQueries::TestQuery - test.branches[%d] == NULL", index );
				result = FALSE;
				break;
			}
			else {
				if( strings[index] != test.branches[index] ) {
					m_pLog->RecordInfo( "CQueries::TestQuery - %s != %s",(LPCTSTR)strings[index], test.branches[index]  );
					result = FALSE;
					break;
				}
			}
		}
		if( result && test.branches[ strings.GetSize() ] != NULL ) {
			m_pLog->RecordInfo( "CQueries::TestQuery - test.branches has more data that wasn't compared" );
			result = FALSE;
		}

		allpass = allpass && result;
	}
	
	if( test.type == BaseClass || test.type == DerivedClass ) {
		EXPECT( test.members );
		result = brz.GetMembers( strings, test.symbolname, test.type, test.filters, test.amb-1 );
		for( index=0; index < strings.GetSize() && result; index++ ) {
			if( test.members[index] == NULL ) {
				m_pLog->RecordInfo( "CQueries::TestQuery - test.members[%d] == NULL", index );
				result = FALSE;
				break;
			}
			else {
				if( strings[index] != test.members[index] ) {
					m_pLog->RecordInfo( "CQueries::TestQuery - %s != %s",(LPCTSTR)strings[index], test.members[index]  );
					result = FALSE;
					break;
				}
			}
		}
		if( result && test.members[ strings.GetSize() ] != NULL ) {
			m_pLog->RecordInfo( "CQueries::TestQuery - test.members has more data that wasn't compared" );
			result = FALSE;
		}

		allpass = allpass && result;
	}

	if (!allpass) {
		m_pLog->RecordFailure(test.desc);
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "navig.h"
#include "queries.h"
#include "filters.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

static CString szBackslash	= "\\";
static CString szSrcDir		= "src";
static CString szProjName	= "browse";

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "Browser Sniff Test", "Scot Forbes x64054")

BEGIN_TESTLIST(CSniffDriver)
	TEST(CNavigate, RUN)
	TEST(CQueries, RUN)
	TEST(CFilters, DONTRUN)
END_TESTLIST()

COWorkSpace ws;

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	fProjReady = FALSE;
	CString szSourceDir(GetCWD() + szSrcDir);
	CString szOrigWorkspace(szSourceDir + szBackslash + "original" + WSPEXTENSION);
	CString szNewWorkspace(szSourceDir + szBackslash + szProjName + WSPEXTENSION);
	CString szOrigBuildfile(szSourceDir + szBackslash + "original" + PRJEXTENSION);
	CString szNewBuildfile(szSourceDir + szBackslash + szProjName + PRJEXTENSION);
	
	CSubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);

	::CopyFile( szOrigWorkspace,  szNewWorkspace, FALSE );
	::SetFileAttributes( szNewWorkspace , FILE_ATTRIBUTE_NORMAL );	// Remove RO flag
	::CopyFile( szOrigBuildfile,  szNewBuildfile, FALSE );
	::SetFileAttributes( szNewBuildfile , FILE_ATTRIBUTE_NORMAL );	// Remove RO flag

}

void CSniffDriver::CleanUp(void)
{
	KillFile("src", "browse.ncb");
	KillFile("src", "browse.plg");
	KillFile("src", "browse.mak");
	KillFile("src", "browse.opt");
	KillFile("src", "browse.dsp");
	KillFile("src", "browse.dsw");
	KillAllFiles("src\\Debug");
	ws.CloseAllWindows();
}

int CSniffDriver::InitProject(void)
	
	{
	if(!fProjReady)
		
		{
		COProject prj;
		
		if(prj.Open(GetCWD() + szSrcDir + szBackslash + szProjName + PRJEXTENSION) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("SNIFF ERROR: could not open browse.dsp");
			return ERROR_ERROR;
			}

		if(prj.ToggleBSCGeneration(TOGGLE_ON) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("SNIFF ERROR: could not toggle on BSC generation");
			return ERROR_ERROR;
			}

		if(prj.Build(5) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("SNIFF ERROR: could not build project");
			return ERROR_ERROR;
			}

		//fProjReady = TRUE;
		}

	// REVIEW (michma): stupid work-around to make sure case sensitivity is on for navigations.
	UIBrowse uibrowse;
	uibrowse.Query(DefRef, "WinMain");
	uibrowse.CloseBrowser();

	return ERROR_SUCCESS;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define WSPEXTENSION	".DSW"
#define PRJEXTENSION	".DSP"


///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)
	
	BOOL fProjReady;

public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
	
	int InitProject(void);

	DECLARE_TESTLIST()
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\BrowserSniff\src\navig.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	NAVIG.CPP
//
//	Created by :			Date :
//		TomSe					1/31/94
//
//	Description :
//		Implementation of the CNavigate class
//

#include "stdafx.h"
#include "sniff.h"
#include "navig.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

enum GotoType {
	GotoDef,
	GotoRef,
};

struct SymbolInfo {
	GotoType type;
	LPCSTR	symbolname;
	LPCSTR	file_line;
	int amb;
};


static SymbolInfo gotoSymbols[] = {
	{	GotoDef, "WinMain",	"browse.cpp(12)" },
	{	GotoDef, "theApp",	"browse.cpp(10)" },
	{	GotoRef, "theApp",	"browse.cpp(14)" },
	{	GotoRef, "ctest",	"ctest.h(43)" },
	{	GotoDef, "ctest",	"ctest.c(17)" },
	{	GotoDef, "m_i",		"cpptest.h(34)", 4 },	//	Should be MI::m_i
	{	GotoDef, "MI",		"cpptest.h(27)" },
};


const int numTests = sizeof( gotoSymbols ) / sizeof( SymbolInfo ) + 6;

IMPLEMENT_TEST(CNavigate, CTest, "Navigation Tests", -1, CSniffDriver)

void CNavigate::Run(void)

	{
	COWorkSpace ws;
	int result;

	if(GetSubSuite()->InitProject() == ERROR_SUCCESS)

		{
		//
		//	Goto definition for different types.
		//
		GotoTest( gotoSymbols[0] );
		GotoTest( gotoSymbols[1] );
		GotoTest( gotoSymbols[2] );	// First reference for theApp

		result = brz.NextReference();
		result = result && brz.VerifyNavigation( "browse.cpp(15)" );
		if (!result) {
			m_pLog->RecordFailure("NextReference: theApp");
		}

		result = brz.NextReference();
		result = result && brz.VerifyNavigation( "browse.cpp(16)" );
		if (!result) {
			m_pLog->RecordFailure("NextReference: theApp");
		}

		result = brz.PrevReference();
		result = result && brz.VerifyNavigation( "browse.cpp(15)" );
		if (!result) {
			m_pLog->RecordFailure("PrevReference: theApp");
		}

		GotoTest( gotoSymbols[3] );

		result = brz.PopContext();
		result = result && brz.VerifyNavigation( "browse.cpp(15)" );
		if (!result) {
			m_pLog->RecordFailure("PopContext: Goto Reference of ctest");
		}

		result = brz.PopContext();
		result = result && brz.VerifyNavigation( "browse.cpp(10)" );
		if (!result) {
			m_pLog->RecordFailure("PopContext: Goto Reference of theApp");
		}

		result = brz.PopContext();
		result = result && brz.VerifyNavigation( "browse.cpp(12)" );
		if (!result) {
			m_pLog->RecordFailure("PopContext: Goto Definition of theApp");
		}

		GotoTest( gotoSymbols[4] );
		GotoTest( gotoSymbols[5] );
		GotoTest( gotoSymbols[6] );
		}

	else
		m_pLog->RecordFailure("src\\browse.mak failed to open or build");
    ws.CloseAllWindows();
	}

///////////////////////////////////////////////////////////////////////////////
//	Test Goto

//
//		Goto location of symbol and verify
//		that correct location is hit.
//
BOOL CNavigate::GotoTest( const SymbolInfo& symdef) {
	//
	//		Need to have GotoNthDefinition that takes a symbol name
	//		as the 2nd parameter.
	//
	int amb = symdef.amb;
	if( amb == 0 )
		amb = NoAmbiguity;
	else
		amb--;

	int result;
	CString strGotoDef( "Goto definition" );
	CString strGotoRef( "Goto reference" );
	CString strAmb( " with Ambiguity" );
	CString strResult;

	switch ( symdef.type ) {
		case GotoDef:
			result = brz.GotoNthDefinition( 1, symdef.symbolname, amb );
			strResult = strGotoDef;
			break;

		case GotoRef:
			result = brz.GotoNthReference( 1, symdef.symbolname, amb );
			strResult = strGotoRef;
			break;

	}
	if( amb != NoAmbiguity )
			strResult += strAmb;

	result = ( result && brz.VerifyNavigation( symdef.file_line )) ? TRUE : FALSE;
	if (!result) {
		m_pLog->RecordFailure("%s: %s", (LPCSTR)strResult, symdef.symbolname );
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\runtime\afxtempl.cpp ===
#include "afxtempl.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		JimGries			4/3/95
//
//	Description :
//		implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "ClassVw.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CClassViewSubSuite, CIDESubSuite, "ClassView Subsuite", "JimGries")

BEGIN_TESTLIST(CClassViewSubSuite)
	TEST(CComprehensiveTest, RUN)
END_TESTLIST()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		JimGries			4/4/95
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CClassViewSubSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CClassViewSubSuite)

	DECLARE_TESTLIST()
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\runtime\manyclas.cpp ===
#include "manyclas.h"

easyclass::priv_func()
{
	return priv_x = 1;
}

easyclass::prot_func()
{
	return prot_x = 2;
}

easyclass::pub_func()
{
	return pub_x = 3;
}

easyclass::priv2_func()
{
	return priv2_x = 4;
}

newclass::priv_func()
{
	return priv_x = 1;
}

newclass::prot_func()
{
	return prot_x = 2;
}

newclass::pub_func()
{
	return pub_x = 3;
}

newclass::priv2_func()
{
	return priv2_x = 4;
}

vbase::priv_vfunc()
{
	return 0;
}

vbase::prot_vfunc()
{
	return 1;
}

vbase::pub_vfunc()
{
	return 2;
}

newvclass::priv_vfunc()
{
	vbase::priv_vfunc();
}

newvclass::prot_vfunc()
{
	vbase::prot_vfunc();
}

newvclass::pub_vfunc()
{
	vbase::pub_vfunc();
}

class1::vfunc()
{
	return 0;
}

class2::def_func(int y)
{
	return y;
}

class3::def_func(CObject* pObj)
{
	return 0;
}

class4::outer_func()
{
	return outer_x;
}

class4::nested_class::nested_func()
{
	return nested_x;
}

class7::abstract_func(int x)	// Def of abstract function! 
{
	return 0;
}

class8& class8::operator+(int x)
{
	return this;
}

class11* class11::func(class11* pObj)
{
	return pObj;
}

const class13* const class13::func(int x) const
{
	return this;
}

const class13* const class14::func(int y) const	// Definition of abstract func!
{
	return (class13*)this;
}

int class15::sfunc()
{
	return 0;
}

int class15::sfunc2(int x)
{
	return x;
}

int class15::func(int (*pf)(const char *))
{
	return class15::sfunc;
}

int class15::func(char*, int (*pf)(int x))
{
	return class15::sfunc2;
}

int class16::func(int)
{
	return 0;
}

int class16::func(BOOL)
{
	return 0;
}

int class16::func(char)
{
	return 0;
}

int class16::func(unsigned)
{
	return 0;
}

int class16::func(unsigned char)
{
	return 0;
}

void class19::func()
{
	return;
}

int class23::func()
{
	return 0;
}

int class23::func() const
{
	return 0;
}

int class27::func(
				  char,
				  int,
				  long
				  )
{
	return 0;
}

int errorclass1::func()
{
	return 0;
}

int invalid::func()
{
	return 0;
}

int C_Func(int)
{
	return 0;
}

int C_Func1(int)
{
}

int C_Func2()
{
}

COLEClass::c_nTypeID = 77777;
COLEClass::c_lpGallery = (LPCOMPONENTGALLERY)0x999999;
STDMETHODIMP COLEClass::XType::OnRegister(UINT nTypeID, LPCOMPONENTGALLERY lpcg)
{
	return NOERROR;
}

STDMETHODIMP COLEClass::XType::OnInitialRegister()
{
	return NOERROR;
}

STDMETHODIMP COLEClass::XType::BltTypeGlyph(HDC hDC, int x, int y)
{
	return NOERROR;
}

STDMETHODIMP_(ULONG) COLEClass::XType::AddRef()
{
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COLEClass::XType::Release()
{
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COLEClass::XType::QueryInterface(
	REFIID iid, LPVOID far * ppvObj)
{
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\classvw.h ===
///////////////////////////////////////////////////////////////////////////////
//	CLASSVW.H
//
//	Created by :			Date :
//		JimGries			6/29/95
//
//	Description :
//		Declaration of the CComprehensiveTest and related
//

#ifndef __CLASSVW_H__
#define __CLASSVW_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	CComprehensiveTest class

class CComprehensiveTest : public CTest
{
	DECLARE_TEST(CComprehensiveTest, CClassViewSubSuite)

private:
	COProject m_proj;				// Project to add file to.
	CString m_strProjBaseName;		// Just the base name of the project.
    CString m_strHFile;				// Name of header file that is a dependency of the following.
    CString m_strCPPFile;			// Name of the cpp that contains "interesting" classes.
    CString m_strBaseLineFile;		// File containing parsed information that should appear in
									// the class view.  See the file header for format details.
// Operations
public:
    virtual void PreRun(CRawListString &);
	virtual void Run(CRawListString&);
	virtual void PostRun(CRawListString &);

};

#endif //__CLASSVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\runtime\afxtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
	#include <afxplex_.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _DEBUG
static char _szAfxTempl[] = "afxtempl.h";
#undef THIS_FILE
#define THIS_FILE _szAfxTempl
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)

template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

	// default is bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
	pElements;  // not used
	nCount; // not used

	// default does nothing
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, nCount * sizeof(TYPE)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, nCount * sizeof(TYPE)));

	// default is bit-wise copy
	memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE>
void AFXAPI SerializeElements(CArchive& ar, TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

	// default is bit-wise read/write
	if (ar.IsStoring())
		ar.Write((void*)pElements, nCount * sizeof(TYPE));
	else
		ar.Read((void*)pElements, nCount * sizeof(TYPE));
}

#ifdef _DEBUG
template<class TYPE>
void AFXAPI DumpElements(CDumpContext& dc, const TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
	&dc; // not used
	pElements;  // not used
	nCount; // not used

	// default does nothing
}
#endif

//REVIEW: building inproc results in strange new warning...
#pragma warning(disable: 4114)

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE)));
	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE)));

	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return ((UINT)(void*)(DWORD)key) >> 4;
}

// special versions for CString
void AFXAPI ConstructElements(CString* pElements, int nCount);
void AFXAPI DestructElements(CString* pElements, int nCount);
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
void AFXAPI SerializeElements(CArchive& ar, CString* pElements, int nCount);
UINT AFXAPI HashKey(LPCTSTR key);

// forward declarations
class COleVariant;
struct tagVARIANT;

// special versions for COleVariant
void AFXAPI ConstructElements(COleVariant* pElements, int nCount);
void AFXAPI DestructElements(COleVariant* pElements, int nCount);
void AFXAPI CopyElements(COleVariant* pDest, const COleVariant* pSrc, int nCount);
void AFXAPI SerializeElements(CArchive& ar, COleVariant* pElements, int nCount);
void AFXAPI DumpElements(CDumpContext& dc, COleVariant* pElements, int nCount);//REVIEW: implement?
UINT AFXAPI HashKey(const struct tagVARIANT& var);

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray : public CObject
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	ASSERT_VALID(this);

	if (m_pData != NULL)
	{
		DestructElements(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determe growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = min(1024, max(4, m_nSize / 8));
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);
		ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);	// cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);	// cannot append to itself

	SetSize(src.m_nSize);
	CopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	ASSERT(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);
	if (ar.IsStoring())
	{
		ar.WriteCount(m_nSize);
	}
	else
	{
		DWORD nOldSize = ar.ReadCount();
		SetSize(nOldSize, -1);
	}
	SerializeElements(ar, m_pData, m_nSize);
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		dc << "\n";
		DumpElements(dc, m_pData, m_nSize);
	}

	dc << "\n";
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow

	ConstructElements(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CList::CNode* pNode)
{
	DestructElements(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);	// make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		{
			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
			SerializeElements(ar, &pNode->data, 1);
		}
	}
	else
	{
		DWORD nNewCount = ar.ReadCount();
		TYPE newData;
		while (nNewCount--)
		{
			SerializeElements(ar, &newData, 1);
			AddTail(newData);
		}
	}
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nCount << " elements";
	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetHeadPosition();
		while (pos != NULL)
		{
			dc << "\n";
			DumpElements(dc, &((CList*)this)->GetNext(pos), 1);
		}
	}

	dc << "\n";
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap : public CObject
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements(&pAssoc->value, 1);
				DestructElements(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	ConstructElements(&pAssoc->key, 1);
	ConstructElements(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CMap::CAssoc* pAssoc)
{
	DestructElements(&pAssoc->value, 1);
	DestructElements(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);	// make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		if (m_nCount == 0)
			return;  // nothing more to do

		ASSERT(m_pHashTable != NULL);
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				SerializeElements(ar, &pAssoc->key, 1);
				SerializeElements(ar, &pAssoc->value, 1);
			}
		}
	}
	else
	{
		DWORD nNewCount = ar.ReadCount();
		KEY newKey;
		VALUE newValue;
		while (nNewCount--)
		{
			SerializeElements(ar, &newKey, 1);
			SerializeElements(ar, &newValue, 1);
			SetAt(newKey, newValue);
		}
	}
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nCount << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		KEY key;
		VALUE val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[";
			DumpElements(dc, &key, 1);
			dc << "] = ";
			DumpElements(dc, &val, 1);
		}
	}

	dc << "\n";
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:
	// Lookup
	BOOL Lookup(BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#undef THIS_FILE
#define THIS_FILE __FILE__

#undef new

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\classvw.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  CLASSVW.CPP
//
//  Created by: Jim Griesmer    Date: 6/29/95
//
//  Description:  Implementation of CComprehensiveTest.
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "ClassVw.h"
#include "rawstrng.h"
#include "support.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_LISTTEST(CComprehensiveTest, CTest, "Comprehensive Class Verification", "comprhsv.lst", CClassViewSubSuite)

void CComprehensiveTest::PreRun(CRawListString &strRaw)
{
    CTest::PreRun(strRaw);

    CString strProjectName;

    // Parse out the raw line into component variables.
    strRaw >> strProjectName >> m_strHFile >> m_strCPPFile >> m_strBaseLineFile;

    LOG->RecordInfo("Project: %s", (LPCSTR)strProjectName);
    LOG->RecordInfo("Header: %s", (LPCSTR)m_strHFile);
    LOG->RecordInfo("CPP: %s", (LPCSTR)m_strCPPFile);
    LOG->RecordInfo("BaseLine: %s", (LPCSTR)m_strBaseLineFile);
	
	//Kill all files in the current directory
	KillAllFiles(m_strCWD + strProjectName);
    // Create a new project.
    //m_proj.New(strProjectName,              // Project Name
    m_proj.NewProject(UIAW_PT_APP,			// Project Type
            strProjectName,					// Project Name
            m_strCWD + strProjectName,		// Project Directory
            NULL);							// Platforms
//			NULL,							// New Subdirectory
//          CNP_ADD_FILES_MYSELF,          // Which files added?
//			NULL,                          // ???? Don't know
//			NULL,                          // ????
//			NULL);                         // ????

	m_strProjBaseName = m_proj.GetName();
	m_strProjBaseName = m_strProjBaseName.Left(m_strProjBaseName.Find('.'));

	CString strDestFile = m_strCWD + '\\' + strProjectName + '\\' + m_strHFile;

	if (!CopyFile(m_strCWD + m_strHFile, strDestFile, FALSE))
		LOG->RecordFailure("Couldn't make copy of %s", m_strHFile);

	if (!SetFileAttributes(strDestFile, FILE_ATTRIBUTE_NORMAL))
		LOG->RecordFailure("Couldn't set the attributes of %s", strDestFile);

	strDestFile = m_strCWD + '\\' + strProjectName + '\\' + m_strCPPFile;

	if (!CopyFile(m_strCWD + m_strCPPFile, strDestFile, FALSE))
		LOG->RecordFailure("Couldn't make copy of %s", m_strCPPFile);

	if (!SetFileAttributes(strDestFile, FILE_ATTRIBUTE_NORMAL))
		LOG->RecordFailure("Couldn't set the attributes of %s", strDestFile);
}

void CComprehensiveTest::Run(CRawListString& strRaw)
{    
    CTest::Run(strRaw);

    // Test for activation and readiness of IDE.
    GetSubSuite()->GetIDE()->IsActive();

    // Add the CPP file to the project.
    m_proj.AddFiles(m_strCPPFile);
    m_proj.AddFiles(m_strHFile);

    // Verify existence of classes in the class view.
    m_proj.VerifyClasses(m_strBaseLineFile);

    m_proj.Close();
}

void CComprehensiveTest::PostRun(CRawListString &strRaw)
{
    CTest::PostRun(strRaw);

    // Do all this just to set the current directory for the IDE session...
    UIFileOpenDlg dlgFileOpen;
    dlgFileOpen.Display();
    dlgFileOpen.SetPath(m_strCWD);
    dlgFileOpen.Cancel();

    // Delete the project directory.
    KillAllFiles(m_proj.GetDir());
}

#ifdef DONT_KNOW_EXACTLY_WHERE_THIS_CAME_FROM
CString CComprehensiveTest::GetSelectedItemName()
{

// DOES NOT WORK YET!!!
    MST.DoKeys("%0");   // Activate Workspace window

    CString str = "Empty";

    UINT msg = RegisterWindowMessage("GetItemProp");


    int i = 0;
    ATOM atom;

    do
    {
        MST.DoKeys("{Down}");
        i++;
        atom = (ATOM)SendMessage( GetSubSuite()->GetIDE()->m_hWnd, msg, P_ProjItemName, 0);
        if (atom != 0)
        {
            UINT ret = GlobalGetAtomName( atom, str.GetBufferSetLength(512), 512 );
            ret = GlobalDeleteAtom(atom);   // this atom created by the Workbench
            str.ReleaseBuffer(-1);

            TRACE("STRING = %s\n", (LPCSTR)str);
        }
    }
    while (atom != 0 && i < 10);

    return str;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\components\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\components\AddnBuildCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	AddnBuildCases.H
//
//	Description :
//		Declaration of the CAddnBuildCases class
//

#ifndef __AddnBuildCases_H__
#define __AddnBuildCases_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "ComponentsSuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CAddnBuildCases class

class CAddnBuildCases : public CTest

	{
	DECLARE_TEST(CAddnBuildCases, CComponentsSuite)
	
	// Operations
	public:
		virtual void Run(void);
	};

#endif //__AddnBuildCases_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\components\ComponentsSuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ComponentsSuite.Cpp
//
//	Description :
//		Implementation of the CComponentsSuite class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "ComponentsSuite.h"

// ADD INCLUDES FOR CASES HERE
#include "AddnBuildCases.h"
// EXAMPLE: #include "Feature1Cases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CComponentsSuite

IMPLEMENT_SUBSUITE(CComponentsSuite, CIDESubSuite, "Components", "")

BEGIN_TESTLIST(CComponentsSuite)
// ADD "TEST" ENTRY FOR CASES HERE
	TEST(CAddnBuildCases, RUN)
// EXAMPLE: TEST(CFeature1Cases, RUN)
END_TESTLIST()

void CComponentsSuite::SetUp(BOOL bCleanUp)
{
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}

void CComponentsSuite::CleanUp(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\components\ComponentsSuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	ComponentsSuite.H
//
//	Description :
//		Declaration of the CComponentsSuite class
//

#ifndef __ComponentsSuite_H__
#define __ComponentsSuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CComponentsSuite class

class CComponentsSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CComponentsSuite)

	DECLARE_TESTLIST();

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
};

#endif //__ComponentsSuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\components\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Description :
//		Precompiled header for a CAFE Test
//
//		Includes core CAFE headers for the target of the test.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\components\AddnBuildCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      AddnBuildCases.CPP
//
//      Description :
//              Implementation of CAddnBuildCases

#include "stdafx.h"
#include "AddnBuildCases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CAddnBuildCases, CTest, "AddnBuild", -1, CComponentsSuite)


////////////////////////////////////////////////////////////////////////
// each function creates a different component. 
// add new functions to the end of the list.

COComponent* CreateActiveXControlContainment(void)
{
	return new(ActiveXControlContainmentComponent);
}

COComponent* CreateClipboardAssistant(void)
{
	return new(ClipboardAssistantComponent);
}

COComponent* CreateDialogBar(void)
{
	return new(DialogBarComponent);
}

COComponent* CreateDocumentRegistration(void)
{
	return new(DocumentRegistrationComponent);
}

COComponent* CreateIdleTimeProcessing(void)
{
	return new(IdleTimeProcessingComponent);
}

COComponent* CreateMAPI(void)
{
	return new(MAPIComponent);
}

COComponent* CreateOwnerDrawControls(void)
{
	return new(OwnerDrawControlsComponent);
}

COComponent* CreatePalette(void)
{
	return new(PaletteComponent);
}

COComponent* CreatePopUpMenu(void)
{
	return new(PopUpMenuComponent);
}

COComponent* CreateProgressDialog(void)
{
	return new(ProgressDialogComponent);
}

COComponent* CreateSplashScreen(void)
{
	return new(SplashScreenComponent);
}

COComponent* CreateSplitBars(void)
{
	return new(SplitBarsComponent);
}

COComponent* CreateStatusBar(void)
{
	return new(StatusBarComponent);
}

COComponent* CreateSystemInfo(void)
{
	return new(SystemInfoComponent);
}

COComponent* CreateTipOfTheDay(void)
{
	return new(TipOfTheDayComponent);
}

COComponent* CreateToolTips(void)
{
	return new(ToolTipsComponent);
}

COComponent* CreateWindowsMultiMedia(void)
{
	return new(WindowsMultiMediaComponent);
}

COComponent* CreateWindowsSockets(void)
{
	return new(WindowsSocketsComponent);
}


// each function that inserts a component has this prototype.
typedef COComponent* (*PTR_CREATE_COMPONENT_FUNC)(void); 

// holds the info we need to add each component and log the result.
struct ComponentInfo
{
	LPCSTR						szName;
	PTR_CREATE_COMPONENT_FUNC	pCreateFunc;
};

// we randomly pick out of the following list of components and add them.
// insert information about new components to the end of the list.
ComponentInfo components[] = {
	"ActiveX Control Containment",	CreateActiveXControlContainment,
	"Clipboard Assistant",			CreateClipboardAssistant,
	"Dialog Bar",					CreateDialogBar,
	"Document Registration",		CreateDocumentRegistration,
	"Idle Time Processing",			CreateIdleTimeProcessing,
	"MAPI",							CreateMAPI,
	"Owner Draw Controls",			CreateOwnerDrawControls,
	"Palette",						CreatePalette,
	"Pop-up Menu",					CreatePopUpMenu,
	"Progress Dialog",				CreateProgressDialog,
	"Splash Screen",				CreateSplashScreen,
	"Split Bars",					CreateSplitBars,
	"Status Bar",					CreateStatusBar,
	"System Info",					CreateSystemInfo,
	"Tip of the Day",				CreateTipOfTheDay,
	"ToolTips",						CreateToolTips,
	"Windows MultiMedia",			CreateWindowsMultiMedia,
	"Windows Sockets",				CreateWindowsSockets

/* TODO(michma): still need to support:

1.	ATL Proxy Generator		requires ATL project
2.	Custom Appwizard Tools	requires custom appwizard project
3.	GUID Generator			requires post-addition source editing
4.	Property Sheets			waiting on fix for vc98:2506

#1 and #2 should probably each be in separate testsets.

#3 could be added to this testset, it would just require special actions
(editing source) prior to building.

#4 can be added as soon as the bug is fixed.

*/
};


void CAddnBuildCases::Run(void)
	
{
	// access to the IDE's project system.
	COProject prj;
	// the name of the project to which we will add components.
	CString strProjectName;
	
	// we use a project name specific to the language of the os we are running on.
	switch(GetSystem())
	{
	case SYSTEM_JAPAN:
#pragma warning (disable : 4129)
		strProjectName = "[\]^{|}Aa`@~";
#pragma warning (default : 4129)
		break;
	default:
		strProjectName = "MFC AppWiz Project";
	}
	
	// can't create a new mfc appwiz project over an old one.
	KillAllFiles(strProjectName);
	// create the default appwiz project to which we will add components.
	prj.NewAppWiz(strProjectName, GetCWD(), GetUserTargetPlatforms());
	
	// enable adding of components to the project (this is just a shortcut so we don't have to keep
	// closing and re-opening the same initial windows before adding each component).
	LOG->RecordInfo("");
	LOG->RecordCompare(prj.EnableComponents(), "*** Enabling components. ***");
					   
	// seed the random number generator (components are added in random order).
	srand(time(NULL));
	// we only want to randomly add each component once.
	RandomNumberCheckList rncl(sizeof(components) / (sizeof(PTR_CREATE_COMPONENT_FUNC) + sizeof(LPCSTR)));
	// indexes into the array containing information about the components we are trying to add.
	int i;
	// points to the actual component object that we are trying to add.
	COComponent *pComponent;
	
	// randomly add each component once.
	while((i = rncl.GetNext()) != -1)
	
	{
		// log a standard, spaced, header.
		LOG->RecordInfo("");
		LOG->RecordInfo("*** Adding %s component. ***", components[i].szName);
		// create the next component that we want to add.
		pComponent = (*components[i].pCreateFunc)();

		// add the component to the project.
		LOG->RecordCompare(prj.AddComponent(pComponent), "Adding %s component.", components[i].szName);
		
		// delete the component so we can use the same pointer for the next one.
		delete pComponent;
	}

	// puts ide back into state it was in before prj.EnableComponents was called.
	LOG->RecordInfo("");
	LOG->RecordCompare(prj.DisableComponents(), "*** Disabling components. ***");

	// build the project.
	LOG->RecordInfo("");
	LOG->RecordCompare(prj.Build() == ERROR_SUCCESS, "*** Building. ***");

	// verify no errors or warnings were generated.
	int iErr, iWarn;
	LOG->RecordInfo("");
	LOG->RecordCompare(prj.VerifyBuild(TRUE, &iErr, &iWarn, TRUE) == ERROR_SUCCESS, "*** Verifying build. ***");

	// even though cafe will do this, it's safer to clean up after yourself.
	prj.Close();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\classvw\runtime\manyclas.h ===
// For each class defined in this file check the following in the class view:
// Base class
// member functions
//		return values
//		const'ness
//		default params
//		virtual'ness
//		static'ness
#include <afx.h>

// Empty class.
class empty
{
};

// Publicly derived class
class pubclass : public base_class
{
};

// Protectedly derived class
class protclass : protected base_class
{
};

// Privately derived class
class privclass : private base_class
{
};

// Class to test scoping.
class easyclass 
{
	int priv_x;
	priv_func();

protected:
	int prot_x;
	prot_func();

public:
	int pub_x;
	pub_func();

private:
	int priv2_x;
	int priv2_func();
};

// Class to test overrides of easyclass
class newclass : public easyclass
{
	int priv_x;
	priv_func();

protected:
	int prot_x;
	prot_func();

public:
	int pub_x;
	pub_func();

private:
	int priv2_x;
	int priv2_func();
};

// Class that declares virtual functions.
class vbase
{
	virtual priv_vfunc();

protected:
	virtual prot_vfunc();

public:
    virtual ~vbase();
	virtual pub_vfunc();


};

// Class that overrides virtuals in vbase.
class newvclass : public vbase
{
	priv_vfunc();

protected:
	prot_vfunc();

public:
	pub_vfunc();
};

// Virtual class.
class virtclass : virtual public base_class
{
};

// Multiply inherited class.
class mclass: public base1, virtual private base2
{
};

// Easy member function test.
class class1
{
public:
    class1() {};
    ~class1() {};

	virtual int vfunc();
};

// Test default paramter in member function.
class class2
{
	int def_func(int i = 0);
};

// More complicated default parameter.  No variable name.
class class3
{
	int def_func(CObject* = 0);
};

// Nested class.
class class4
{
	int outer_x;

	class nested_class
	{
		int nexted_x;
	public:
		int nested_func();
	};

	int outer_func();
};

// Nested class with a var of same name as outer class.
class class5
{
	int x;
	class nested_class
	{
		int x;
	};
};

// Inline function.
class class6
{
	int m_x;

	int inline_func(int i) { m_x = i; }
};

// Abstract function, with default paramter.
class class7
{
public:
	virtual int abstract_func(int x = 0) = 0;
};

// Operator overrides.
class class8
{
public:
	class8& operator=(int) {};
	class8& operator+(int) {};
	class8& operator-(int) {};
	class8& operator>>(istream&) {};
	class8& operator<<(istream&) {};
	int operator==(class8&) {};
	char operator[](int index)const {}
	int operator()() {}

	operator char*() const {}
	operator const char&() const {}
	operator LPCTSTR() const {}
	operator const LPSTR() {}
	operator int() {};
};

// Friend class declaration.
class class9
{
	friend class class8;
};

// Operator override as friend function.
class class10
{
	friend class10& operator<<(int y);
};

// Pointer parameter and pointer return.
class class11
{
	class11 * func(class11 *);
};

// Consts everywhere.
class class13
{
	const class13* const func(int x) const;
};

// Const'd abstract function with default paramter.
class class14
{
	virtual const class13* const func(int = 0) const = 0;
};

// Static functions and pointers to functions as arguments.
class class15
{
	static sfunc();
	static sfunc2(int);
	int func(int (*pf)(const char *));
	virtual int func(char*, int (*pf)(int x)) = 0;
};

// Overloaded functions.
class class16
{
	int func(int);
	int func(BOOL);         
	int func(char);
	int func(unsigned);
	int func(unsigned char);
};

// Declare instances of classes after defining class.
class class17
{
public:
	int func() {}
} instance1, instance2;

// Array member.
class class18
{
	int* x[10][20][30];
};

// Test function that accepts a void paramter with an implementation
// that does not spell out the "void".  See the cpp file.  This is 
// a navigation only test.
class class19
{
	void func(void);
};

// Test something valid that comes between class keyword and class name.
class __declspec(dllimport) class20
{
};

// Test a pointer to function members.
class class21
{
	int (*m_pfunc)(int x, int y);
	int (*m_apfunc[10][20])(int x);
};

// Test a class with bit fields.
class class22
{
	WORD bOn:1;
	WORD bSys:1;
	WORD bSrc:1;
	WORD bRev:1;
	WORD bUpd:1;
	WORD index:5;
};

// Test const/non-const overload.
class class23
{
	int func() const;
	int func();
};

// Test a template declaration.
template<class T>
inline T& MAX(T& a, T& b)
{ return a > b? a : b; }


// Another template test.
template<class T, int size>
class Buffer1
{
private:
	T buffer[size];
};

template<class T>
class Buffer2 : public Buffer<T, 10>
{
private:
	T GetItem() {};
};

// Instaniated template test.
class class24
{
	Buffer<char, 5> m_CharBuf;
	Buffer<class23*, 100> m_Class23Buf;	// Buffer of class23 pointers.
	Buffer<int(*)(int), 5> m_pFuncBuf;	// Buffer of function pointers to functions that take and int and return an int.
	Buffer<(1>2),2> m_boolBuf;			// Buffer of booleans.
	CArray<Buffer, Buffer> m_BufArray;		// MFC defined template.
	Buffer<CArray<Buffer, Buffer>, 100> m_ArrayBuf;		// Buffer of CArray<Buffer>s
	Buffer<CArray<Buffer, Buffer>*, 100> m_ArrayPtrBuf;	// Buffer of CArray<Buffer> pointers.

	int m_x;
};

typedef struct mystruct mystruct;
class myclass;
typedef union myunion myunion;

// Test extraneous struct/class/union specifiers.
class class25
{
	foo(mystruct* p) {};
	foo(myclass& c) {};
	foo(myunion* * pp) {};

	struct mystruct m_struct;
	class myclass m_class;
	union myunion m_union;
};

// Check a class that is missing a trailing ';' 
class invalid
{
	int func();
}

// Declare a global function that unmangled naming.
extern "C" int C_Func(int);

// Declare a block of global functions that use unmangled naming.
extern "C" 
{
	int C_Func1(int);
	int C_Func2();
}

// Declare a global function that has no implementation yet.  Should not appear.
int prototype_only(int, char);

// Declare a Globals class to intentionally attempt to break the class view/parser.
class Globals
{
	int m_x;
	int foo() {};
};

// Try some wierd characters.  These break Symantec.
class Wierd$Name
{
	int m_$x;
};

// Try a class defined within a name space.	 Should not appear.
namespace NewSpace 
{
	class NamespacedClass
	{
		int foo();
		int m_x;
	};
}

// Try a class with forward declarations.
class class26
{
	class forward_class;
};

// Define a class to try out odd member definitions
class class27
{
	int func(char, int, long);
};

//;DO ALL BY REPLACING class WITH struct.  They should all work.
//;
//;ERRONEOUS CLASS DECLARATIONS
//;
class errorclass1
{
	int x
	func()
};

class errorclass2
{
}

// Try a class that has an internal unnamed union.
#define X LONG
#define Y LONG
#define DX LONG
#define DY LONG

struct PT { X x; Y y; };

struct RC
{
	union 
	{
		struct 
		{
			X xLeft;
			Y yTop;
			X xRight;
			Y yBot;
		};
		struct
		{
			PT ptTopLeft;
			PT ptBotRight;
		};
	};
		PT rgpt[2];
		RECT rect;

		DX width(void)	const {return xRight-xLeft;}
		DY height(void) const {return yBot-yTop;}
};

// How bout some good ol' OLE.
class COLEClass : public CCmdTarget
{
	DECLARE_DYNCREATE(COLEClass)
	COLEClass() {};

// Attributes
public:
	static UINT c_nTypeID;
	static LPCOMPONENTGALLERY c_lpGallery;
	static HRESULT AddComponent(CRuntimeClass* pClass) {}

// Implementation
protected:
	virtual ~COLEClass() {};

	DECLARE_OLECREATE_EX(CCawUtilType)

	// Interface for Component Gallery to use
	BEGIN_INTERFACE_PART(Type, IComponentType)
		INIT_INTERFACE_PART(CCawUtilType, Type)
		STDMETHOD(OnRegister)(THIS_ UINT nTypeID, LPCOMPONENTGALLERY lpcg);
		STDMETHOD(OnInitialRegister)(THIS);
		STDMETHOD(BltTypeGlyph)(THIS_ HDC hDC, int x, int y);
	END_INTERFACE_PART(Type)
	DECLARE_INTERFACE_MAP()

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\bin\aw_base\editdlg.h ===
#if !defined(EDITDLG_H__0F42D4C7_284D_11D0_8BFE_00A0C903A030__INCLUDED_)
#define EDITDLG_H__0F42D4C7_284D_11D0_8BFE_00A0C903A030__INCLUDED_

// EditDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditDlg dialog

class CEditDlg : public CDialog
{
// Construction
public:
	CEditDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CEditDlg)
	enum { IDD = IDD_EDIT_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CEditDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(EDITDLG_H__0F42D4C7_284D_11D0_8BFE_00A0C903A030__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\bin\aw_base\edit.h ===
#if !defined(EDIT_H__0F42D4C5_284D_11D0_8BFE_00A0C903A030__INCLUDED_)
#define EDIT_H__0F42D4C5_284D_11D0_8BFE_00A0C903A030__INCLUDED_

// Edit.h : main header file for the EDIT application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CEditApp:
// See Edit.cpp for the implementation of this class
//

class CEditApp : public CWinApp
{
public:
	CEditApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CEditApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(EDIT_H__0F42D4C5_284D_11D0_8BFE_00A0C903A030__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\bin\aw_base\edit.cpp ===
// Edit.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Edit.h"
#include "EditDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditApp

BEGIN_MESSAGE_MAP(CEditApp, CWinApp)
	//{{AFX_MSG_MAP(CEditApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditApp construction

CEditApp::CEditApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEditApp object

CEditApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEditApp initialization

BOOL CEditApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CEditDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\bin\aw_base\editdlg.cpp ===
// EditDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Edit.h"
#include "EditDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditDlg dialog

CEditDlg::CEditDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEditDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CEditDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CEditDlg, CDialog)
	//{{AFX_MSG_MAP(CEditDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditDlg message handlers

BOOL CEditDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CEditDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CEditDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CEditDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\bin\aw_base\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by EDIT.RC
//
#define IDR_MAINFRAME					128
#define IDM_ABOUTBOX					0x0010
#define IDD_ABOUTBOX					100
#define IDS_ABOUTBOX					101
#define IDD_EDIT_DIALOG				102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\bin\aw_base\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Edit.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\appcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	APPCASES.H
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		Declaration of the CAppTestCases class
//

#ifndef __APPCASES_H__
#define __APPCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AppTestCases class

class CAppTestCases : public CTest
{
	DECLARE_TEST(CAppTestCases, CSniffDriver)

// Attributes
	int iteration ;
	int LangDlls ;

public:
	// Data members
	CString  szDir ; 
	CString szDirRes ;
	CString ProjName ;
	CString ProjDir ;
	CString CurrDir ;// ('\0',256) ;
// Operations
public:
	virtual void Run(void);

// Data
protected:
	COProject m_prj;
	UIAppWizard m_uaw;
	UIProjectWizard m_prjwiz;

// Test Cases
protected:
	void NewProject(void);
	void MDIApp(void);
	void Classes(void);
	void ChangeAppType(void);
	void NoAbout(void);
	void JumpConfirm(void);
	void CreateProject(void);
	void VerifyFiles(void);
};

#endif //__APPCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\ATLCOMCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ATLCOMCases.cpp
//
//	Created by :			Date :
//		MichMa					2/13/98
//
//	Description :
//		Implementation of the CATLCOMCases class

#include "stdafx.h"
#include "ATLCOMCases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CATLCOMCases, CTest, "ATL COM AppWizard", -1, CSniffDriver)


void CATLCOMCases::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CATLCOMCases::Run(void)

{	 
	// the support layer objects we will need for this test.
	COProject prj;

	// the name of the atl com project we will create.
	CString strATLCOMProjName;

	// use a localized name.
	if(GetSystem() & SYSTEM_DBCS)
		strATLCOMProjName = "[\\]^{|}Aa`@~ ATL COM Project";
	else
		strATLCOMProjName = "ATL COM Project";
	
	// clean-up from a previous run if necessary.
	KillAllFiles(GetCWD() + strATLCOMProjName);

	// set the options for the atl com project (default is to create a top-level project in a new workspace).
	CProjWizOptions *pATLCOMWizOpt = new(CATLCOMWizOptions);
	pATLCOMWizOpt->m_strLocation = GetCWD();
	pATLCOMWizOpt->m_strName = strATLCOMProjName;	
	
	// create the atl com project.
	if(!(LOG->RecordCompare(prj.New(pATLCOMWizOpt) == ERROR_SUCCESS,
		"Create ATL COM project named: %s", pATLCOMWizOpt->m_strName)))
		return;

	// insert a new atl object into the project.
	if(!(LOG->RecordCompare(prj.InsertNewATLObject("ATLCOMInterface") == ERROR_SUCCESS, 
		"Insert new ATL object 'ATLCOMInterface' into '%s' project.", strATLCOMProjName)))
		return;

	// build the project.
	if(!(LOG->RecordCompare(prj.Build() == ERROR_SUCCESS, "Build '%s' project.", strATLCOMProjName)))
		return;
	
	// verify no errors or warnings were generated.
	int iErr, iWarn;
	if(!(LOG->RecordCompare(prj.VerifyBuild(TRUE, &iErr, &iWarn, TRUE) == ERROR_SUCCESS,
		"Verify build of '%s' project", strATLCOMProjName)))
		return;

	// close the project.
	if(!(LOG->RecordCompare(prj.Close() == ERROR_SUCCESS, "Close '%s' project.", strATLCOMProjName)))
		return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\bin\aw_base\stdafx.h ===
#if !defined(STDAFX_H__0F42D4C9_284D_11D0_8BFE_00A0C903A030__INCLUDED_)
#define STDAFX_H__0F42D4C9_284D_11D0_8BFE_00A0C903A030__INCLUDED_

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(STDAFX_H__0F42D4C9_284D_11D0_8BFE_00A0C903A030__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\appcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      APPCASES.CPP
//
//      Created by :                    Date :
//              DavidGa                                 10/27/93 
// 
//      Description :
//              Implementation of the CAppTestCases class
//
 
#include "stdafx.h"
#include "appcases.h"
//#include "..\..\support\guitools\testutil.h"

#define new DEBUG_NEW

#undef THIS_FILE  
static char BASED_CODE THIS_FILE[] = __FILE__;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

// flag to indicate to class wizard whether app wizard was successful or not
extern BOOL gbAppWiz;

CString msg = "Building proj with " ;
CString LangDllName = "                                            " ;

IMPLEMENT_TEST(CAppTestCases, CTest, "AppWizard Tests", -1, CSniffDriver)

void CAppTestCases::Run(void)
{
	COWorkSpace ws;
	int nFails = 0;
	szDirRes.LoadString(IDS_RESDIRNAME) ; //
	szDir.LoadString(IDS_AWDIRNAME) ;
	ProjDir = szDir ;
	ProjName.LoadString(IDS_PROJNAME) ;
	//HWND hSubWnd ;
 
	iteration = 1 ;
	LangDlls = 0 ;

    //do  //loop for >1 languange dll was causing problems - should eventually fix this instead
	//of just removing it - AG.
	//{
//		COProject cop ; 
//		cop.DeleteFromProjectDir(ProjDir) ;
		//DeleteFromProjectDir uses wrong dir when ran more than once
		//m_prj.DeleteFromProjectDir(ProjDir) ;
		KillAllFiles(ProjDir);
	    NewProject();
		MDIApp();
		if (1 == iteration)
		{  // Flush the stings first.
			CurrDir.Empty() ;
			LangDllName.Empty() ;

			GetCurrentDirectory(256,CurrDir.GetBuffer(256));
			CurrDir.ReleaseBuffer() ;
			CurrDir+="\\" ;
			CurrDir+= szDir ;
			ProjDir = CurrDir ;
			//szDir = ProjDir ;
			Classes();
			ChangeAppType();
			NoAbout();
		}
	
		JumpConfirm();
		CreateProject();
		iteration++ ;
		if (nFails) // If we have had a failure aready, just exist don't build
			return ;
		m_prj.Build(15) ;
		if (!VERIFY_TEST_SUCCESS(m_prj.VerifyBuild())) {
			m_pLog->RecordFailure(msg + LangDllName + "  resources.");
			nFails++;
		}
		
		// Clean up for the next iteration.
		{
			CString num;
			num.Format("%d",iteration) ;
			ProjName +=num ;
			//m_prj.DeleteFromProjectDir(ProjName); //clean up from before
			
		}

	//}
	//while(LangDlls +1 > iteration) ;
	VerifyFiles();

	// indicate appwizard was successful
	gbAppWiz = (nFails == 0);
	ws.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//      Test Cases

void CAppTestCases::NewProject(void)
{
//	COProject prj;

// REVIEW(briancr): we can't support AppWizard at the UWBFrame level--it's in COProject
//      m_uaw = UIWB.AppWizard();
//	m_uaw = prj.AppWizard();
	m_uaw = m_prj.AppWizard();
	m_prjwiz.SetProjType(GetLocString(UIAW_PT_APPWIZ));
	if( !m_uaw.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch App Wizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Need App Wiz to test anymore");     // no sense continuing
	}
	m_uaw.SetDir(m_strCWD) ;
	if (m_strCWD.Find(szDir) == -1)
	{
		CreateDirectory(m_strCWD+szDir, NULL);
		m_uaw.SetSubDir(szDir);
	}
	m_uaw.SetName(ProjName);
	m_uaw.Create();
	if (m_uaw.GetPage() != UIAW_APPTYPE) {
		m_pLog->RecordFailure("Invoke App Wizard from New Project dialog");
	}
}

void CAppTestCases::MDIApp(void)
{

    // Get the number of lang DLL
//      LangDlls = ((LangDlls =MST.WListCount(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG))) >1) ? LangDlls + 1: LangDlls ;
	LangDlls = ((LangDlls =MST.WComboCount(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG))) >1) ? 2: LangDlls ;

//      CListBox langLst ;
	CString tmpName('\0',40) ;

	EXPECT( m_uaw.GetPage() == UIAW_APPTYPE );
	m_uaw.SetAppType(UIAW_APP_MDI);

	//MST.WComboItemClk(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),iteration) ;
	//langLst.Attach(GetDlgItem(ControlOnPropPage(APPWZ_IDC_RSC_LANG),APPWZ_IDC_RSC_LANG)) ; //MST.WFndWndWaitC( m_uaw.GetLabel(APPWZ_IDC_RSC_LANG), "", FW_CASE, 5));

	// Turn on the checkboxes for all language DLLs items except one.
	// NO MULTI-LANGUAGE SUPPORT FOR V3
/*      for (int i = 0; i < LangDlls; i++) 
	{
		if(iteration == i+1)
			langLst.SetItemData(i,0) ;      
		else
		{
			MST.WListItemText(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),i+1,tmpName) ;
			LangDllName = LangDllName + ", "+ tmpName ;
			langLst.SetItemData(i,1) ;
		}
	}  

	if(LangDlls == 1) // If there is only one language DLL, select it.
	{
		langLst.SetItemData(iteration -1, 1) ;
		MST.WListItemText(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),iteration,tmpName) ;
	}
	langLst.SetCurSel(iteration -1) ;
	langLst.Detach() ; */

	if (1 == iteration)
	{
		EXPECT_EXEC( m_uaw.NextPage() == UIAW_DBOPTIONS, "Page after App Type was not Database Options" );
		m_uaw.SetDBOptions(UIAW_DB_HEADER);
	
		EXPECT_EXEC( m_uaw.NextPage() == UIAW_OLEOPTIONS, "Page after Database Options was not OLE Options" );
		m_uaw.SetOLEOptions(UIAW_OLE_MINI_SERVER);
		m_uaw.SetOLEOptions(UIAW_OLE_YES_AUTO);
	
		m_uaw.GoToPage(APPWZ_IDC_DB_RADIO); 
		m_uaw.GoToPage(APPWZ_IDC_RSC_LANG);
		m_uaw.GoToPage(APPWZ_IDC_PONOTDLL);     
	
		m_uaw.GoToPage(APPWZ_IDC_OUTPUT);
		m_uaw.GoToPage(APPWZ_IDC_NO_INPLACE) ; 
		m_uaw.GoToPage(APPWZ_IDCD_POPRINT) ;
		m_uaw.GoToPage(APPWZ_IDC_RSC_LANG);
		m_uaw.GoToPage(APPWZ_IDC_CLASS_LIST); 
 
		if (m_uaw.GetPage() != UIAW_CLASSES)
		{
			m_pLog->RecordFailure("App Wizard MDI pages work" );
		}
    }
}

void CAppTestCases::Classes()
{
	EXPECT( m_uaw.GetPage() == UIAW_CLASSES );

    if (m_uaw.OleInstalled) {
		if (MST.WListCount(NULL) != 6) {
			m_pLog->RecordFailure("All Classes accounted for" );    // 7 if use Recordset
		}
	}
	else {
		if (MST.WListCount(NULL) != 4) {
			m_pLog->RecordFailure( "All Classes accounted for" );   //
		}
	}
			
	CString strView;
	MST.WListItemText("", 1, strView);
	CString ClassName;
	ClassName.LoadString(IDS_CLASSNAME) ;
	m_pLog->RecordInfo("Classname is %s",ClassName);
	m_pLog->RecordInfo("strView is %s",strView);
	if (strView != ClassName) {
		m_pLog->RecordFailure( "View class has illegal name." );
	}

	ClassName.LoadString(IDS_MAINFRAME_CLASS) ;
	m_uaw.SelectClass(ClassName);
	CString strBase = m_uaw.GetBaseClass();
}

void CAppTestCases::ChangeAppType()
{
	m_uaw.GoToPage(APPWZ_IDC_DB_RADIO); // DB Options
	EXPECT_EXEC( m_uaw.PrevPage() == UIAW_APPTYPE, "Couldn't get back to App Type page");

	m_uaw.SetAppType(UIAW_APP_FORM);
	if (m_uaw.NextPage() != UIAW_DLGOPTIONS) {
		m_pLog->RecordFailure("Form-based app uses different steps");
	}
}

void CAppTestCases::NoAbout()
{
	EXPECT( m_uaw.GetPage() == UIAW_DLGOPTIONS );
//      m_uaw.SetDlgOptions(UIAW_DLG_NOABOUT);
}

void CAppTestCases::JumpConfirm(void)
{
	if (m_uaw.Finish() != UIAW_CONFIRM) {
		m_pLog->RecordFailure("Finish jumped to confirmation dialog");
	}
}

void CAppTestCases::CreateProject(void)
{
	BOOL bCreated = m_uaw.ConfirmCreate();
	if( bCreated == FALSE )
		m_pLog->RecordFailure("Problem creating EDIT project, or opening it in the IDE");
	else
	{
		CString acTitle ;
		::GetText(GetSubSuite()->GetIDE()->m_hWnd, acTitle.GetBuffer(63),63);
		acTitle.ReleaseBuffer() ;
		acTitle.MakeUpper() ;
		ProjName.MakeUpper() ;
		if( acTitle.Find(ProjName)!= -1 ) {
			m_prj.Attach();
			m_pLog->RecordInfo("Created EDIT project, and opened it in the IDE");
		}
		else
			m_pLog->RecordFailure("Problem creating EDIT project, or opening it in the IDE.  Found '%s'", acTitle);
	}
}

void CAppTestCases::VerifyFiles(void)
{
// REVIEW(briancr): we can't support CloseEditor at the UIWB level, so I've
// moved the code here for now
	UIEditor ued = UIWB.GetActiveEditor();

	if( !ued.IsValid() )
		ued.AttachActive();
	else if( !ued.IsActive() )
		UIWB.SetActiveEditor(ued);
	ued.Close();
	m_pLog->RecordInfo("closing project");
   m_prj.Close() ; // This creates the MDP file wich is needed for the next test.
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\awxcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      AWXCASES.CPP
//
//      Created by :                    Date :
//              Ivanl                           10/17/94
//
//      Description :
//              Implementation of the CAwxTestCases class
//
															   
#include "stdafx.h"
#include "awxcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

extern char* szRes ;
extern CString LangDllName ;
extern CString msg ;
extern HWND hSubWnd ;
  
IMPLEMENT_TEST(CAwxTestCases, CTest, "Custom Wizard test", -1, CSniffDriver)

void CAwxTestCases::Run(void)
{
	COWorkSpace ws;
	iteration = 1 ;
	LangDlls = 0 ;
  // Flush the strings first
	LangDllName.Empty() ;
	CurrDir.Empty() ;
	msg.Empty() ;
	ProjDir.Empty() ;
	LangDllName =" " ;            

	szDir.LoadString(IDS_AWXDIRNAME) ; 
	ProjName.LoadString(IDS_PROJNAME) ;
	ProjDir = szDir ;             
	
	COProject cop ; 
	cop.DeleteFromProjectDir(ProjDir) ;
	NewProject() ;
	ChooseZapper() ;
	ChooseCustom() ;
	ChooseApwSequence() ;
	ws.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//      Test Cases

// Create extension project
void CAwxTestCases::NewProject(void)
{
	COProject prj;
	prj.ActivateProjWnd() ;
// REVIEW(briancr): we can't support AppWizard at the UWBFrame level--it's in COProject
//      m_extwiz = UIWB.AppWizard();
	m_extwiz = prj.AppWizard(TRUE);
	if( !m_extwiz.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch Custom AppWizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Need App Wiz to test anymore");     // no sense continuing
	}
	m_extwiz.SetDir(m_strCWD) ;
	CreateDirectory(m_strCWD+szDir, NULL);
	m_extwiz.SetSubDir(szDir);
	m_extwiz.SetName(ProjName);
	m_extwiz.Create();                              
}

void CAwxTestCases::ChooseZapper()
{
	m_extwiz.SetExtType(IDC_ZAP) ;
	m_extwiz.NextPage();
	m_extwiz.PrevPage();
}

//Select the Custom Option
void CAwxTestCases::ChooseCustom()
{
	m_extwiz.SetExtType(IDC_CUSTOM) ;
	m_extwiz.SetNumPages(4) ;
	m_extwiz.NextPage();
	m_extwiz.Cancel();
}

	//Select the AppWizard based option
void CAwxTestCases::ChooseApwSequence()
{
	m_extwiz.SetExtType(IDC_SEQUENCE) ;
	m_extwiz.NextPage() ;
	m_extwiz.SetDllExeType(IDC_APWZ_SEQ) ;
	m_extwiz.NextPage();
	if(!m_extwiz.ConfirmCreate())
	{
		m_pLog->RecordFailure(" Problem creating Extension project, or opening it in the IDE");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\ATLCOMCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	ATLCOMCases.h
//
//	Created by:	MichMa		Date:	2/13/98
//
//	Description:
//		Declaration of the CATLCOMCases class

#ifndef __ATLCOMCases_h__
#define __ATLCOMCases_h__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"


///////////////////////////////////////////////////////////////////////////////
//	CATLCOMCases class

class CATLCOMCases : public CTest
{
	DECLARE_TEST(CATLCOMCases, CSniffDriver)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
};

#endif //__ATLCOMCases_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\awxcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	AWXCASES.H
//
//	Created by :			Date :
//		Ivanl					10/17/94
//
//	Description :
//		Declaration of the CAwxTestCases class
//

#ifndef __AWXCASES_H__
#define __AWXCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AwxTestCases class

class CAwxTestCases : public CTest
{
	DECLARE_TEST(CAwxTestCases, CSniffDriver)

// Attributes
	int iteration ;
	int LangDlls ;

public:
// Operations
// Data members
	CString  szDir ; 
	CString szDirRes ;
	CString ProjName ;
	CString ProjDir ;
	CString CurrDir ;// ('\0',256) ;

public:
	virtual void Run(void);

// Data
protected:
	UIExtWizard m_extwiz;

// Test Cases
protected:
	void NewProject(void);
	void ChooseZapper(void);
	void ChooseCustom(void);
	void ChooseApwSequence(void);
};

#endif //__AWXCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\ctrcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	CTRCASES.H
//
//	Created by :			Date :
//		Ivanl					3/17/94
//
//	Description :
//		Declaration of the CCtrlWizardCases class
//

#ifndef __CTRCASES_H__
#define __CTRCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AwxTestCases class

class CCtrlWizardCases : public CTest
{
	DECLARE_TEST(CCtrlWizardCases, CSniffDriver)

// Attributes
	int iteration ;
	int LangDlls ;
	COProject prj;
public:
// Operations
// Data members
	CString  szDir ; 
	CString szDirRes ;
	CString ProjName ;
	CString ProjDir ;
	CString CurrDir ;// ('\0',256) ;

public:
	virtual void Run(void);

// Data
protected:
	UICtrlWizard m_ctrlwiz;

// Test Cases
protected:
	void NewProject(void);
	void SetProjOptions(void);
	void SetCtrlOptions(void);
	void GenerateProject(void) ;
	void AddControlMethods(void) ;
};

#endif //__CTRCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\ctrcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      CTRCASES.CPP
//
//      Created by :                    Date :
//              ivanl                                   3/17/95
//
//      Description :
//              Implementation of the CCtrlWizardCases class
//

#include "stdafx.h"
#include "ctrcases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

extern char* szRes ;
extern CString LangDllName ;
extern CString msg ;
extern HWND hSubWnd ;
  
IMPLEMENT_TEST(CCtrlWizardCases, CTest, "Control Wizard Test", -1, CSniffDriver)

void CCtrlWizardCases::Run(void)
{
	COWorkSpace ws;
	iteration = 1 ;
	LangDlls = 0 ;
  // Flush the strings first
	LangDllName.Empty() ;
	CurrDir.Empty() ;
	msg.Empty() ;
	ProjDir.Empty() ;
	LangDllName =" " ;            

	szDir.LoadString(IDS_CTRWIZDIR) ; 
	ProjName.LoadString(IDS_CTRWIZNAME) ;
	ProjDir = szDir ;             
	
	//prj.DeleteFromProjectDir(ProjDir) ;
	KillAllFiles(ProjDir);
	NewProject() ;
	SetProjOptions() ;
	SetCtrlOptions() ;
	GenerateProject() ;
	AddControlMethods() ;
	ws.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//      Test Cases

// Create extension project
void CCtrlWizardCases::NewProject(void)
{

// REVIEW(briancr): we can't support AppWizard at the UWBFrame level--it's in COProject
//      m_ctrlwiz = UIWB.AppWizard();
	prj.ActivateProjWnd(); // We need this up otherwise we can't tell if a project was created or not.
	m_ctrlwiz = prj.AppWizard(TRUE);
	if( !m_ctrlwiz.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch Control AppWizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Need Custom Appwizar to test anymore");     // no sense continuing
	}
	m_ctrlwiz.SetDir(m_strCWD) ;
	CreateDirectory(m_strCWD+szDir, NULL);
	m_ctrlwiz.SetSubDir(szDir);
	m_ctrlwiz.SetName(ProjName);
	m_ctrlwiz.Create();                             
}

void CCtrlWizardCases::SetProjOptions()
{
	m_ctrlwiz.SetCount(3) ;
	m_ctrlwiz.SetLicenceOpt(1);
	m_ctrlwiz.NextPage();
}

//Select the Custom Option
void CCtrlWizardCases::SetCtrlOptions()
{
	CString Name = "Control_" ;

	for(int i = 1; i < 4; i++)
	{
		CString cnt;
		cnt.Format("%d",i) ;
		m_ctrlwiz.SetActive(i) ;
		m_ctrlwiz.SubClassCtrl(i) ;
		m_ctrlwiz.SummaryInfo() ;

		m_ctrlwiz.SumDlg.SetShortName(Name+cnt);
		m_ctrlwiz.SumDlg.Close() ;
	}
}

void CCtrlWizardCases::GenerateProject()
{       
	m_ctrlwiz.NextPage() ;
	if(!m_ctrlwiz.ConfirmCreate())
	{
		m_pLog->RecordFailure(" Problem creating a control project, or opening it in the IDE");
	}
}
void CCtrlWizardCases::AddControlMethods() 
{
	UIClassWizard	ClsWiz ;
/*	ClsWiz.AddStockMethod(1) ;
	ClsWiz.AddCustomMethod(2) ;
    ClsWiz.AddUserMethod(1) ;
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\og_cases.h ===
///////////////////////////////////////////////////////////////////////////////
//	og_cases.h
//
//	Created by :			
//		Anita George - modified version of og_cases.h
//
//	Description :
//		Declaration of the CObjGalTestCases Class
//

#ifndef __OGCASES_H__
#define __OGCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	Symbols used in test

#define	OG_PROJNAME1			"og_proj1"
#define	OG_PROJNAME2			"og_proj2"
#define OG_NEW_CLASSNAME		"CNewOGX"
#define OG_CBUTTON				1
#define OG_OGX_FULLNAME			"New OGX.ogx"
#define OG_OGX_NAME				"New OGX"
#define OG_THIRD_COMPONENT		2


///////////////////////////////////////////////////////////////////////////////
//	CObjGalTestCases class

class CObjGalTestCases : public CTest
{
	DECLARE_TEST(CObjGalTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:
		UIProjectWizard m_prjwiz;

// Test Cases
protected:

	BOOL CreateNewOGX(void);
	BOOL CreateNewProj(void);
	BOOL ApplyOglet(void);
	void BuildOglet(void);

};

#endif //__OGCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizards.rc
//
#define IDS_RANGE_WIZARDS               2000
#define IDS_AWDIRNAME                   2001
#define IDS_RESDIRNAME                  2002
#define IDS_PROJNAME                    2003
#define IDS_AWXDIRNAME                  2004
#define IDS_CLWDIRNAME                  2005
#define IDS_RESCWRESDIR                 2006
#define IDS_CLWBASEDIR                  2008
#define IDS_CTRWIZDIR                   2009
#define IDS_CTRWIZNAME                  2010
#define IDS_CLASS_DEFINITION            2011
#define IDS_MAINFRAME_CLASS             2012
#define IDS_WIZBAR_PROJECT              2013
#define IDS_WIZBDIRNAME                 2014
#define IDS_CLASSNAME                   2015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\og_cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	og_cases.CPP
//											 
//	Created by :			
//		Anita George - modified version of og_cases.cpp		
//
//	Description :								 
//		Gallery Sniff test	(new file-open like dialog) 

#include "stdafx.h"
#include "og_cases.h"					 	 
											   
#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// flag to indicate to class wizard whether app wizard was successful or not
extern BOOL gbAppWiz;

UIOGalleryDlg ogDlg;

IMPLEMENT_TEST(CObjGalTestCases, CTest, "Gallery tests", -1, CSniffDriver)

void CObjGalTestCases::Run(void)
{
	// Remove files created by previous test run
	KillAllFiles(OG_PROJNAME1);	
	KillAllFiles(OG_PROJNAME2);	

	CString strIDEDir = GetSubSuite()->GetIDE()->GetPath();
	CString strGalleryDir = ogDlg.GetGalleryDir(strIDEDir);
	CString strOldGal = strGalleryDir + CString("gallery.old");

	if (CreateNewProj())
	{
		if (ogDlg.DeleteFileInGallery(OG_PROJNAME1,OG_OGX_FULLNAME, OG_OGX_NAME))
		{
			if (CreateNewOGX())
			{
				if (ApplyOglet())
				{
					BuildOglet();
				}
			}
		}
	}

	// Restore gallery database
	ogDlg.DeleteOGDatabase(strGalleryDir);
	ogDlg.RenameOGDatabase(strGalleryDir, CString("gallery.old"), ROGD_RESTORE);

}


///////////////////////////////////////////////////////////////////////////////
//	Test Cases

 
COProject proj2;

BOOL CObjGalTestCases::CreateNewProj()
{
	COProject proj1;
	
	UIAppWizard uaw = proj1.AppWizard();
	m_prjwiz.SetProjType(GetLocString(UIAW_PT_APPWIZ));
	if( !uaw.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch App Wizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Can't continue with Gallery sniff");	// no sense continuing
		return FALSE;
	}
	uaw.SetName(OG_PROJNAME1);
	uaw.SetDir(m_strCWD);
	uaw.Create();
	EXPECT( uaw.GetPage() == UIAW_APPTYPE );
	uaw.SetAppType(UIAW_APP_SDI);
	if (uaw.Finish() != UIAW_CONFIRM) 
	{
		m_pLog->Comment("Problem in confirmation dialog");
	}

	BOOL bCreated = uaw.ConfirmCreate();
	if( bCreated == NULL )
	{
		m_pLog->RecordFailure("Problem creating project, or opening it in the IDE");
		return FALSE;
	}
	else
	{
		m_pLog->Comment("Successfully created project.");
		return TRUE;
	}
}

BOOL CObjGalTestCases::CreateNewOGX()
{
	// Bring up Class Wiz and add a class
	UIClassWizard cw;
	cw.Display();

	UIAddClassDlg acd;
	if (acd.Show())
	{
		acd.SetName(OG_NEW_CLASSNAME);
		acd.SetType(OG_CBUTTON);
		acd.Create();
		acd.WaitUntilGone(30000);	// REVIEW: Create takes a long time !
		MST.WButtonClick(GetLabel(IDOK));		  //  Use suggested location

		//verify that ogx doesn't appear in gallery yet
		//successfully found ogx in Gallery but shouldn't be there yet
		if (ogDlg.Display() != NULL)
		{
			if (ogDlg.FindFileInGallery(OG_PROJNAME1, OG_OGX_FULLNAME) == 1) 
			{
				m_pLog->RecordFailure("Ogx in Gallery and shouldn't be");
				ogDlg.Close();
				return FALSE;
			}
			else
			{
				//if cannot find the new class in classview, we error
				if (!(ogDlg.FindClassInClassView(OG_PROJNAME1, OG_NEW_CLASSNAME)))
				{
					m_pLog->RecordFailure("Cannot find class in ClassView");
					return FALSE;
				}
				else
				{
					ogDlg.AddToGallery();
					//if found ogx in gallery
					if (ogDlg.FindFileInGallery(OG_PROJNAME1, OG_OGX_FULLNAME) == 1)
					{
						m_pLog->RecordInfo("Successfully created Custom OGX");
						return TRUE;

					}
					else
					{
						m_pLog->RecordFailure("Cannot find ogx in Gallery.");
						return FALSE;
					}
				}
			}
		}
		else
		{
			m_pLog->RecordFailure("Gallery didn't display properly");
			return FALSE;
		}
	}
	else
	{
		m_pLog->RecordFailure("Couldn't add new class.");
		DoKeys("{ESCAPE 2}");
		return FALSE;
	}
}

UIAppWizard uaw2;

BOOL CObjGalTestCases::ApplyOglet()
{
	BOOL bResult = FALSE;

	// Create target project where OGX will be applied
	uaw2 = proj2.AppWizard();
	m_prjwiz.SetProjType(GetLocString(UIAW_PT_APPWIZ));
	if( !uaw2.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch App Wizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Can't continue with Gallery sniff");	// no sense continuing
	}
	uaw2.SetName(OG_PROJNAME2);
	uaw2.SetDir(m_strCWD);
	uaw2.Create();
	EXPECT( uaw2.GetPage() == UIAW_APPTYPE );
	uaw2.SetAppType(UIAW_APP_SDI);
	if (uaw2.Finish() != UIAW_CONFIRM) 
	{
		m_pLog->Comment("Problem in confirmation dialog");
	}

	BOOL bCreated = uaw2.ConfirmCreate();	// Returns proj window handle
	if( bCreated == NULL )
		m_pLog->RecordFailure("Problem creating target project, or opening it in the IDE");
	else
	{
		ogDlg.AddToProject(OG_PROJNAME1, OG_OGX_NAME, OG_OGX_FULLNAME);	

		// possible test enhancement:
		// verify proper files got added to fileview and resources to resourceview

		if (!(ogDlg.FindClassInClassView(OG_PROJNAME2, OG_NEW_CLASSNAME)))
		{
			m_pLog->RecordFailure("Cannot find class in ClassView");
		}
		else
		{
			m_pLog->RecordInfo("Successfully Applied Custom OGX");
			bResult = TRUE;
		}

	}
	return bResult;
}	  

void CObjGalTestCases::BuildOglet(void)
{
	proj2.Attach();
	proj2.Build(4);
	if (proj2.VerifyBuild() != ERROR_SUCCESS)
	{
		m_pLog->RecordFailure("Build Oglet: Could not build Project with oglet");
		return;
	}
	proj2.Close();
	m_pLog->RecordInfo("Successfully built project with Custom OGX");
	

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\clscases.h ===
///////////////////////////////////////////////////////////////////////////////
//	CLSCASES.H
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		Declaration of the CClsTestCases class
//

#ifndef __CLSCASES_H__
#define __CLSCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AppTestCases class

class CClsTestCases : public CTest
{
	DECLARE_TEST(CClsTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
public:
	// Data members
	CString  szDir ; 
	CString szDirRes ;
	CString ProjName ;
	CString ProjDir ;
	CString CurrDir ;// ('\0',256) ;
	CString strAWBase ;
	CString szAWproj ;

protected:
	CString m_strCWD;		// the test's current working directory

// Test Cases
protected:
	void OpenProject(void);
	void WizardOnProject(void);
	void TabThroughPages(void);
	void AddClassesAndMessages(void) ;
};

#endif //__CLSCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\clscases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      CLSCASES.CPP
//
//      Created by :                    Date :
//              DavidGa                                 10/27/93
//
//      Description :
//              Implementation of the CClsTestCases class
//

#include "stdafx.h"
#include "clscases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// flag to indicate to class wizard whether app wizard was successful or not
extern BOOL gbAppWiz;

//static char szAWTest[] = "AW_Test";

IMPLEMENT_TEST(CClsTestCases, CTest, "ClassWizard tests", -1, CSniffDriver)

void CClsTestCases::Run(void)
{
	// get the current working directory for this test
	::GetCurrentDirectory(MAX_PATH, m_strCWD.GetBuffer(MAX_PATH));
	m_strCWD.ReleaseBuffer();
	m_strCWD += '\\';
	
	strAWBase.LoadString(IDS_CLWBASEDIR) ;  //AW_base
	szDir.LoadString(IDS_CLWDIRNAME) ; //CW_Test
	szAWproj.LoadString(IDS_AWDIRNAME) ; //AW Test
	ProjName.LoadString(IDS_PROJNAME) ; //Edit Test
	KillAllFiles(szDir);//(m_strCWD + szDir); //.....\idesniff\wizards\CW_Test
	// don't know what to do for SECURITY_ATTRIBUTES
	CreateDirectory(m_strCWD + szDir, NULL);        

	if(gbAppWiz) 
		//copy ...\idesniff\wizards\AW Test\Edit Test to ...\idesniff\wizards\CW_Test
		CopyTree(m_strCWD + szAWproj+"\\"+ProjName, m_strCWD + szDir);
	else
	{
		m_pLog->RecordInfo("running from aw_base");
		//copy ...\idesniff\wizards\AW_base to ...\idesniff\wizards\CW_Test
		CopyTree(m_strCWD + strAWBase, m_strCWD + szDir);
		ProjName = "Edit" ;
	}
	szDir+="\\" ;

	OpenProject();
	AddClassesAndMessages() ;
	WizardOnProject();
	TabThroughPages();
}

///////////////////////////////////////////////////////////////////////////////
//      Test Cases

void CClsTestCases::OpenProject(void)
{
	COProject prj;

	// open the project
	if (prj.Open(m_strCWD + szDir + ProjName+ ".DSW") != ERROR_SUCCESS) {
		m_pLog->RecordFailure("Unable to open project (%s).", ProjName+ ".dsw");
		return;
	}

	CString str ;
    ::GetText(GetSubSuite()->GetIDE()->m_hWnd, str.GetBuffer(63),63);
    str.ReleaseBuffer() ;
	ProjName.MakeUpper() ;
	str.MakeUpper();
	if (str.Find(ProjName) == -1) {
		m_pLog->RecordFailure("Opened project window '%s'", (LPCSTR)str );
	}
}

void CClsTestCases::WizardOnProject(void)
{
	if( UIWB.ClassWizard() == NULL )
		EXPECT_EXEC(FALSE, "Could not launch Class Wizard from menu.  Is it available?");
	else
		m_pLog->RecordInfo("Launched Class Wizard");
}

void CClsTestCases::TabThroughPages(void)
{
	for( int n = 0; n < 6; n++)
	{
		MST.DoKeys ("^({TAB})") ;  // walk through each tab, to at least verify they don't crash

		Sleep(500);
	}
	MST.DoKeys("{escape}");         // dismiss Class Wizard
	if (!UIWB.IsActive()) {
		m_pLog->RecordFailure("Dismissed Class Wizard, and returned focus to MSVC");
	}
	// REVIEW replace with a function in the shell.
	UIWB.SaveAll(3000) ;
	//MST.DoKeys("%f") ;
	//MST.DoKeys("l") ; 
	UIWB.CloseAllWindows();
	//MST.DoKeys("%w") ;
	//MST.DoKeys("l") ;

}

void CClsTestCases::AddClassesAndMessages(void)
{
 int i, j, k ;
 UIClassWizard  ClsWiz ;
 COProject cop ;

 
 COResScript coRes ;
 
  //MST.DoKeys("%(Fl)") ; 
  UIWB.SaveAll(3000) ;
  for (i = 0; i < 2; i++)
  {
	coRes.CreateResource(  IDSS_RT_DIALOG /*"Dialog" */);
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
  }
  i = 0;
 
 //MST.DoKeys("%Wl") ;
 //MST.DoKeys("(^{F4 2})");
 //UIWB.CloseAllWindows();
 //MST.DoKeys("{ENTER}") ;
 Sleep(3000);
 ClsWiz.Display() ;
 if (ClsWiz.AddClass(1) == ERROR_SUCCESS)
 {
  // Add a couple new classes ;
  for (k = 2; k < 5 ; k++)
		ClsWiz.AddClass(k) ;
	  ClsWiz.EditCode() ;

   // Add several messages to the classes ;
	for (k = 1; k < 3; k++)
	   for (j = 1; j < 2; j++) 
			for (i = 1; i < 2 ; i++)
			ClsWiz.AddFunction(k,i,j) ;
	 ClsWiz.AddFunction(1,2,2) ; // Add one handler which is not virtual.
	 ClsWiz.EditCode() ;

	 // Add several messages using the wizardbar
	/* HWND hnd = MST.WGetActWnd(0) ;
	 CString strhnd ;
	 strhnd.Format("%d",hnd) ;
	
	 AfxMessageBox("Testing the active handle >>> " + strhnd) ;
	 hnd = GetParent(hnd) ;

     strhnd.Format("%d",hnd) ;
	 AfxMessageBox("Testing the active parent >>> " + strhnd) ;

	 UIWizardBar WizBar ;
	 for(i =1 ; k < 6; k++)
	 {
		WizBar.SelectClass(i) ;
		WizBar.HandleMessage(k) ;
	 } 
	 */
 }
 else
 {
	 m_pLog->RecordFailure("Couldn't add new class.");
	 DoKeys("{ESCAPE 2}");
 }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST();

	virtual void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"
#include "resource.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		implementation of the Wizards' CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "appcases.h"
#include "clscases.h"
#include "awxcases.h"
#include "ctrcases.h"
#include "og_cases.h"
#include "wzbcases.h"
#include "ATLCOMCases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "Wizards Sniff Test", "Anita George x68862")

BEGIN_TESTLIST(CSniffDriver)
	TEST(CObjGalTestCases, RUN)
	TEST(CAppTestCases, RUN)
	TEST(CClsTestCases, RUN)
	TEST(CWzbTestCases, RUN)
	TEST(CAwxTestCases, RUN)
	TEST(CCtrlWizardCases, RUN)
	TEST(CATLCOMCases, RUN)
END_TESTLIST()

// flag to indicate to class wizard whether app wizard was successful or not
BOOL gbAppWiz;

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);

	gbAppWiz = FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\appcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	APPCASES.H
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		Declaration of the CAppTestCases class
//

#ifndef __APPCASES_H__
#define __APPCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AppTestCases class

class CAppTestCases : public CTest
{
	DECLARE_TEST(CAppTestCases, CSniffDriver)

// Attributes
	int iteration ;
	int LangDlls ;

// Operations
public:
	virtual void Run(void);

// Data
protected:
	UIAppWizard m_uaw;

// Test Cases
protected:
	void NewProject(void);
	void MDIApp(void);
	void Classes(void);
	void ChangeAppType(void);
	void NoAbout(void);
	void JumpConfirm(void);
	void CreateProject(void);
	void VerifyFiles(void);
};

#endif //__APPCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\wzbcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      wzbcases.CPP
//
//      Created by :                    Date :
//              Anita George         9/3/96		copied from clscases.cpp & modified
//
//      Description :
//              Implementation of the CWzbTestCases class
//

#include "stdafx.h"
#include "wzbcases.h"
#include "support.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// flag to indicate to class wizard whether app wizard was successful or not
extern BOOL gbAppWiz;

static char szAWTest[] = "AW_Test";

IMPLEMENT_TEST(CWzbTestCases, CTest, "WizardBar tests", -1, CSniffDriver)

void CWzbTestCases::Run(void)
{
	COWorkSpace ws;
	// get the current working directory for this test
	::GetCurrentDirectory(MAX_PATH, m_strCWD.GetBuffer(MAX_PATH));
	m_strCWD.ReleaseBuffer();
	m_strCWD += '\\';
	
	szWBproj.LoadString(IDS_WIZBDIRNAME) ;
	ProjName.LoadString(IDS_WIZBAR_PROJECT) ;
	KillAllFiles(m_strCWD + szWBproj + "\\" + ProjName + "\\");

	szDir = m_strCWD + szWBproj + "\\";

	//if new project created successfully
	if (CreateProject())
	{
		//if wizard bar gets displayed successfully
		if (ShowWizBar())
		{
			UIWizardBar WizBar;
			ClassName.LoadString(IDS_MAINFRAME_CLASS) ;
			CodeString.LoadString(IDS_CLASS_DEFINITION) ;
			WizBar.GotoClassDefinition(ClassName, NULL, CodeString);
			//AddMsgHandler()
		}

		//AddClassesAndMessages() ;
		//WizardOnProject();
		//TabThroughPages();
	}
	ws.CloseAllWindows();
}

///////////////////////////////////////////////////////////////////////////////
//      Test Cases

BOOL CWzbTestCases::CreateProject()
{
	COProject proj1;
	
	UIAppWizard uaw = proj1.AppWizard();
	m_prjwiz.SetProjType(GetLocString(UIAW_PT_APPWIZ));
	if( !uaw.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch App Wizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Can't continue with WizBar sniff");	// no sense continuing
	}

	uaw.SetDir(szDir);
	uaw.SetName(ProjName);
	uaw.Create();
	EXPECT( uaw.GetPage() == UIAW_APPTYPE );
	uaw.SetAppType(UIAW_APP_MDI);
	if (uaw.Finish() != UIAW_CONFIRM) 
	{
		m_pLog->Comment("Problem in confirmation dialog");
	}

	BOOL bCreated = uaw.ConfirmCreate();
	if( bCreated == NULL )
	{
		m_pLog->RecordFailure("Problem creating project in the IDE");
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}


BOOL CWzbTestCases::ShowWizBar(void)
{
	UIWizardBar WizBar;
	//if can't show wizbar then error
	if (!WS.ShowToolbar(IDTB_CLASSVIEW_WIZBARU, TRUE) )
	{
		m_pLog->RecordFailure("Couldn't Show Wizard bar");
		return FALSE;
	}
	//if wizbar displayed, then set it up correctly
	else
	{
		WizBar.InitializeWizBar();
		m_pLog->RecordInfo("Done setting focus to combo");
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\Sniff\src\wzbcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	wzbcases.H
//
//	Created by :			Date :
//		Anita George		9/3/96		copied from clscases.h & modified
//
//	Description :
//		Declaration of the CWzbTestCases class
//

#ifndef __wzbcases_H__
#define __wzbcases_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AppTestCases class

class CWzbTestCases : public CTest
{
	DECLARE_TEST(CWzbTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
public:
	// Data members
	CString szDir ; 
	CString ProjName ;
	CString ProjDir ;
	CString CurrDir ;// ('\0',256) ;
	CString szWBproj ;
	CString ClassName;
	CString CodeString;

protected:
	CString m_strCWD;		// the test's current working directory
 	UIProjectWizard m_prjwiz;

// Test Cases
protected:
	BOOL CreateProject();
	BOOL ShowWizBar(void);
};

#endif //__wzbcases_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\appcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	APPCASES.CPP
//
//	Created by :			Date :
//		DavidGa					10/27/93 
// 
//	Description :
//		Implementation of the CAppTestCases class
//

#include "stdafx.h"
#include "appcases.h"

#undef THIS_FILE 
static char BASED_CODE THIS_FILE[] = __FILE__;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

// flag to indicate to class wizard whether app wizard was successful or not
extern BOOL gbAppWiz;

CString  szDir = "AW_Test";
char szDirRes[] = "AW_Test\\res";
char* szRes = szDirRes + 8;
CString LangDllName = "                                            " ;
CString CurrDir('\0',256) ;
CString msg = "Building proj with " ;
CString ProjDir = szDir ;
HWND hSubWnd ;

IMPLEMENT_TEST(CAppTestCases, CTest, "AppWizard tests", -1, CSniffDriver)

void CAppTestCases::Run(void)
{
	int nFails = 0;

	iteration = 1 ;
	LangDlls = 0 ;
	ProjDir = szDir = "AW_Test";
	
    do
	{
		COProject cop ; 
		cop.DeleteFromProjectDir(ProjDir) ;
	    NewProject();
		MDIApp();
		if (1 == iteration)
		{  // Flush the stings first.
			CurrDir.Empty() ;
			LangDllName.Empty() ;

			GetCurrentDirectory(256,CurrDir.GetBuffer(256));
			CurrDir.ReleaseBuffer() ;
			CurrDir+="\\" ;
			CurrDir+= szDir ;
			ProjDir = CurrDir ;
			szDir = ProjDir ;
			Classes();
			ChangeAppType();
			NoAbout();
		}
		JumpConfirm();
		CreateProject();
		iteration++ ;
		cop.Build(15) ;
		if (!VERIFY_TEST_SUCCESS(cop.VerifyBuild())) {
			m_pLog->RecordFailure(msg + LangDllName + "  resources.");
			nFails++;
		}
	}
	while(LangDlls +1 > iteration) ;
	VerifyFiles();

	// indicate appwizard was successful
	gbAppWiz = (nFails == 0);
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

void CAppTestCases::NewProject(void)
{
	m_uaw = UIWB.AppWizard();
	if( !m_uaw.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch App Wizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Need App Wiz to test anymore");	// no sense continuing
	}
	m_uaw.SetName("Edit");
	m_uaw.SetSubDir(szDir);
	m_uaw.Create();
	if (m_uaw.GetPage() != UIAW_APPTYPE) {
		m_pLog->RecordFailure("Invoke App Wizard from New Project dialog");
	}
}

void CAppTestCases::MDIApp(void)
{

    // Get the number of lang DLL
// 	LangDlls = ((LangDlls =MST.WListCount(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG))) >1) ? LangDlls + 1: LangDlls ;
 	LangDlls = ((LangDlls =MST.WListCount(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG))) >1) ? 2: LangDlls ;

   	CListBox langLst ;
	CString tmpName('\0',40) ;

	EXPECT( m_uaw.GetPage() == UIAW_APPTYPE );
	m_uaw.SetAppType(UIAW_APP_MDI);

	MST.WListItemClk(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),iteration) ;
	langLst.Attach(GetDlgItem(ControlOnPropPage(APPWZ_IDC_RSC_LANG),APPWZ_IDC_RSC_LANG)) ; //MST.WFndWndWaitC( m_uaw.GetLabel(APPWZ_IDC_RSC_LANG), "", FW_CASE, 5));

	// Turn on the checkboxes for all language DLLs items except one.
	for (int i = 0; i < LangDlls; i++)
	{
	 	if(iteration == i+1)
	 		langLst.SetItemData(i,0) ;	
		else
		{
			MST.WListItemText(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),i+1,tmpName) ;
			LangDllName = LangDllName + ", "+ tmpName ;
			langLst.SetItemData(i,1) ;
		}
	}
	if(LangDlls == 1) // If there is only one language DLL, select it.
	{
		langLst.SetItemData(iteration -1, 1) ;
		MST.WListItemText(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),iteration,tmpName) ;
	}
	langLst.SetCurSel(iteration -1) ;
	langLst.Detach() ;

	if (1 == iteration)
	{
		EXPECT_EXEC( m_uaw.NextPage() == UIAW_DBOPTIONS, "Page after App Type was not Database Options" );
		m_uaw.SetDBOptions(UIAW_DB_HEADER);
	
		EXPECT_EXEC( m_uaw.NextPage() == UIAW_OLEOPTIONS, "Page after Database Options was not OLE Options" );
		m_uaw.SetOLEOptions(UIAW_OLE_MINI_SERVER);
		m_uaw.SetOLEOptions(UIAW_OLE_YES_AUTO);
	
		m_uaw.GoToPage(APPWZ_IDC_DB_RADIO); 
		m_uaw.GoToPage(APPWZ_IDC_RSC_LANG);
		m_uaw.GoToPage(APPWZ_IDC_PONOTDLL);	
	
		m_uaw.GoToPage(APPWZ_IDC_OUTPUT);
		m_uaw.GoToPage(APPWZ_IDC_NO_INPLACE) ; 
		m_uaw.GoToPage(APPWZ_IDCD_POPRINT) ;
		m_uaw.GoToPage(APPWZ_IDC_RSC_LANG);
	 	m_uaw.GoToPage(APPWZ_IDC_CLASS_LIST); 
 
		if (m_uaw.GetPage() != UIAW_CLASSES)
		{
			m_pLog->RecordFailure("App Wizard MDI pages work" );
		}
    }
}

void CAppTestCases::Classes()
{
	EXPECT( m_uaw.GetPage() == UIAW_CLASSES );

    if (m_uaw.OleInstalled) {
		if (MST.WListCount(NULL) != 6) {
			m_pLog->RecordFailure("All Classes accounted for" );	// 7 if use Recordset
		}
	}
	else {
		if (MST.WListCount(NULL) != 4) {
			m_pLog->RecordFailure( "All Classes accounted for" );	//
		}
	}
		 	
	CString strView;
	MST.WListItemText("", 4, strView);
	if (strView != "CMyEditView") {
		m_pLog->RecordFailure( "Catches illegal names" );
	}

	m_uaw.SelectClass("CMainFrame");
	CString strBase = m_uaw.GetBaseClass();
/*
	if (strBase != "CFrameWnd") {
		m_pLog->RecordFailure( "OLE Mini-Server forced SDI");	// Sanchovy bug #1066
	}
*/
}

void CAppTestCases::ChangeAppType()
{
	/*m_uaw.PrevPage();		// Proj Options
	m_uaw.PrevPage();		// Features
	m_uaw.PrevPage();		// OLE Options
	m_uaw.PrevPage();		// DB Options */
	m_uaw.GoToPage(APPWZ_IDC_DB_RADIO); // DB Options
	EXPECT_EXEC( m_uaw.PrevPage() == UIAW_APPTYPE, "Couldn't get back to App Type page");

	m_uaw.SetAppType(UIAW_APP_FORM);
	if (m_uaw.NextPage() != UIAW_DLGOPTIONS) {
		m_pLog->RecordFailure("Form-based app uses different steps");
	}
}

void CAppTestCases::NoAbout()
{
	EXPECT( m_uaw.GetPage() == UIAW_DLGOPTIONS );
//	m_uaw.SetDlgOptions(UIAW_DLG_NOABOUT);
}

void CAppTestCases::JumpConfirm(void)
{
	if (m_uaw.Finish() != UIAW_CONFIRM) {
		m_pLog->RecordFailure("Finish jumped to confirmation dialog");
	}
}

void CAppTestCases::CreateProject(void)
{
	HWND hwnd = m_uaw.ConfirmCreate();
	if( hwnd == NULL )
		m_pLog->RecordFailure("Problem creating EDIT project, or opening it in the IDE");
	else
	{
		//char _acTitle[64];
		CString acTitle ;
		::GetText(hwnd, acTitle.GetBuffer(63),63);
		acTitle.ReleaseBuffer() ;
		acTitle.MakeUpper() ;
		if( acTitle.Find("EDIT")!= -1 )
			m_pLog->RecordInfo("Created EDIT project, and opened it in the IDE");
		else
			m_pLog->RecordFailure("Problem creating EDIT project, or opening it in the IDE.  Found '%s'", acTitle);
	}
}

void CAppTestCases::VerifyFiles(void)
{
	UIWB.CloseEditor();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\appsnap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	APPSNAP.CPP
//
//	Created by :			Date :
//		Ivanl				12/29/94
//
//	Description :
//		Implementation of the CTestAppWizardCases class
//

#include "stdafx.h"
#include "appsnap.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

static CString  szDir = "AWtest";
static char szDirRes[] = "AW_Test\\res";
static char* szRes = szDirRes + 8;
static CString LangDllName =" " ;
static CString InitDir('\0',256) ;
static CString msg = "Building proj with " ;
static CString ProjDir = szDir ;
static CString num ;

static HWND hSubWnd ;

IMPLEMENT_TEST(CTestAppWizardCases, CTest, "AppWizard snap", -1, CSniffDriver)

void CTestAppWizardCases::Run(void)
{
	GetCurrentDirectory(256,InitDir.GetBuffer(256));
	InitDir.ReleaseBuffer() ;
	InitDir+="\\" ;

	iteration = 1 ;
	LangDlls = 0 ;
	LOG->Comment("in appsnap.cpp");
	ProjDir = szDir = "AW_Test";

    do
	{
		iteration++ ;
		num.Format("%d",iteration);

		//ProjDir = szDir +num ;

		COProject cop ; 
		cop.DeleteFromProjectDir(InitDir+ProjDir) ;
		m_pLog->Comment("before NewProject");
	    NewProject();
		m_pLog->Comment("before CreateProject");
		//CreateProject() ;
		cop.Attach();
		/*
		MDIApp();
		if (1 == iteration)
		{
			GetCurrentDirectory(256,InitDir.GetBuffer(256));
			InitDir.ReleaseBuffer() ;
			InitDir+="\\" ;
			InitDir+= szDir ;
			ProjDir = InitDir ;
			szDir = ProjDir ;
			Classes();
			ChangeAppType();
			NoAbout();
		}
		JumpConfirm();
		CreateProject();
		iteration++ ;
		cop.Build(15) ;
	    WriteLog(VERIFY_TEST_SUCCESS(cop.VerifyBuild()),msg + LangDllName + "  resources." ) ;
		LangDllName = " " ;
	}
	while(LangDlls +1 > iteration) ; */
	}
	while(iteration <3) ;

	VerifyFiles();

	return ;
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

void CTestAppWizardCases::NewProject(void)
{
	COProject prj;
	m_utstaw = prj.AppWizard();
	//9/29/97 - the following line was commented out to remove a build error.
	//actually we need to define UIAW_PT_TEST_APPWIZ in order to get the
	//appwizard snap to work.  we aren't currently concerned with this.
	//when we are, we need to add this to a string table.
	//m_utstaw.SetProjType(GetLocString(UIAW_PT_TEST_APPWIZ));
	//m_utstaw.SetProjType(GetLocString(UIAW_PT_APPWIZ));
	//if( !m_utstaw.IsValid() )
	//{
	//	m_pLog->RecordFailure("Did not launch App Wizard from File/New/Project");
	//	EXPECT_EXEC(FALSE, "Need App Wiz to test anymore");	// no sense continuing
	//}
	m_pLog->Comment("in NewProject,before SetDir");
	m_utstaw.SetDir(m_strCWD) ;
	//if (m_strCWD.Find(szDir) == -1)
	//{
	//	CreateDirectory(m_strCWD+szDir, NULL);
	//	m_utstaw.SetSubDir(szDir);
	//}

	m_pLog->Comment("in NewProject,before SetName");
	m_utstaw.SetName(ProjDir);
	//m_pLog->Comment("in NewProject,before SetSubDir");
	//m_utstaw.SetSubDir(ProjDir);
	m_pLog->Comment("in NewProject,before Create");
	m_utstaw.Create();
	m_pLog->Comment("in NewProject,after Create");
	//if (m_utstaw.GetPage() != UIAW_APPTYPE) 
	//{
	//	m_pLog->RecordFailure("Invoke App Wizard from New Project dialog");
	//}

	m_pLog->Comment("in NewProject,before SetIteration");
	//m_utstaw.SetIteration(num) ;
	m_pLog->Comment("in NewProject,before nextpage");
	m_utstaw.NextPage() ;
	m_pLog->Comment("in NewProject,before gotopage");
	m_utstaw.GoToPage(APPWZ_IDC_OUTPUT);
	m_pLog->Comment("in NewProject,before finish");
	m_utstaw.Finish() ;
	m_pLog->Comment("in NewProject,at end of it");
  	//m_utstaw.ConfirmCreate();

					
}

void CTestAppWizardCases::MDIApp(void)
{

    // Get the number of lang DLL
 /*	LangDlls = ((LangDlls =MST.WListCount(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG))) >1) ? LangDlls + 1: LangDlls ;
   	CListBox langLst ;
	CString tmpName('\0',40) ;

	EXPECT( m_uaw.GetPage() == UIAW_APPTYPE );
	m_uaw.SetAppType(UIAW_APP_MDI);

	MST.WListItemClk(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),iteration) ;
	langLst.Attach(GetDlgItem(ControlOnPropPage(APPWZ_IDC_RSC_LANG),APPWZ_IDC_RSC_LANG)) ; //MST.WFndWndWaitC( m_uaw.GetLabel(APPWZ_IDC_RSC_LANG), "", FW_CASE, 5));

	// Turn on the checkboxes for all language DLLs items except one.
	for (int i = 0; i < LangDlls; i++)
	{
	 	if(iteration == i+1)
	 		langLst.SetItemData(i,0) ;	
		else
		{
			MST.WListItemText(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),i+1,tmpName) ;
			LangDllName = LangDllName + ", "+ tmpName ;
			langLst.SetItemData(i,1) ;
		}
	}
	if(LangDlls == 1) // If there is only one language DLL, select it.
	{
		langLst.SetItemData(iteration -1, 1) ;
		MST.WListItemText(m_uaw.GetLabel(APPWZ_IDC_RSC_LANG),iteration,tmpName) ;

	}
	langLst.SetCurSel(iteration -1) ;
	langLst.Detach() ;

	if (1 == iteration)
	{
	EXPECT_EXEC( m_uaw.NextPage() == UIAW_DBOPTIONS, "Page after App Type was not Database Options" );
	m_uaw.SetDBOptions(UIAW_DB_HEADER);

	
	EXPECT_EXEC( m_uaw.NextPage() == UIAW_OLEOPTIONS, "Page after Database Options was not OLE Options" );
	m_uaw.SetOLEOptions(UIAW_OLE_MINI_SERVER);
	m_uaw.SetOLEOptions(UIAW_OLE_YES_AUTO);

	
	m_uaw.NextPage();		// UIAW_FEATURES
	m_uaw.NextPage();		// UIAW_PROJOPTIONS
	m_uaw.NextPage();		// UIAW_CLASSES
	
	WriteLog( m_uaw.GetPage() == UIAW_CLASSES, "App Wizard MDI pages work" );
	} */
}

void CTestAppWizardCases::Classes()
{
/*	EXPECT( m_uaw.GetPage() == UIAW_CLASSES );

    if (m_uaw.OleInstalled)
		WriteLog( WListCount(NULL) == 6, "All Classes accounted for" );	// 7 if use Recordset
	else
		WriteLog( WListCount(NULL) == 4, "All Classes accounted for" );	//
		 	
	CString strView;
	MST.WListItemText("", 4, strView);
	WriteLog( strView == "CMyEditView", "Catches illegal names" );

	m_uaw.SelectClass("CMainFrame");
	CString strBase = m_uaw.GetBaseClass();
//	WriteLog( strBase == "CFrameWnd", "OLE Mini-Server forced SDI");	// Sanchovy bug #1066
*/
}

void CTestAppWizardCases::ChangeAppType()
{
/*	m_uaw.PrevPage();		// Proj Options
	m_uaw.PrevPage();		// Features
	m_uaw.PrevPage();		// OLE Options
	m_uaw.PrevPage();		// DB Options
	EXPECT_EXEC( m_uaw.PrevPage() == UIAW_APPTYPE, "Couldn't get back to App Type page");

	m_uaw.SetAppType(UIAW_APP_FORM);
	WriteLog(m_uaw.NextPage() == UIAW_DLGOPTIONS, "Form-based app uses different steps"); 
	*/
}

void CTestAppWizardCases::NoAbout()
{
//	EXPECT( m_uaw.GetPage() == UIAW_DLGOPTIONS );
//	m_uaw.SetDlgOptions(UIAW_DLG_NOABOUT);
}

void CTestAppWizardCases::JumpConfirm(void)
{
//	WriteLog(m_uaw.Finish() == UIAW_CONFIRM, "Finish jumped to confirmation dialog");
}

void CTestAppWizardCases::CreateProject(void)
{
	if( m_utstaw.ConfirmCreate() == FALSE )
		m_pLog->RecordFailure("Problem creating EDIT project, or opening it in the IDE");
	else
	{
		//char _acTitle[64];
		CString acTitle ;
		::GetText(GetSubSuite()->GetIDE()->m_hWnd, acTitle.GetBuffer(63),63);
		acTitle.ReleaseBuffer() ;
		acTitle.MakeUpper() ;
		ProjDir.MakeUpper() ;
		if( acTitle.Find(ProjDir)!= -1 )
			m_pLog->RecordInfo("Created EDIT project, and opened it in the IDE");
		else
			m_pLog->RecordFailure("Problem creating EDIT project, or opening it in the IDE.  Found '%s'", acTitle + " Expeted  " + ProjDir);
	}
}

void CTestAppWizardCases::VerifyFiles(void)
{
	UIEditor ued = UIWB.GetActiveEditor();

	if( !ued.IsValid() )
		ued.AttachActive();
	else if( !ued.IsActive() )
		UIWB.SetActiveEditor(ued);
	ued.Close();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\appsnap.h ===
///////////////////////////////////////////////////////////////////////////////
//	APPSNAP.H
//
//	Created by :			Date :
//		Ivanl				12/29/94
//
//	Description :
//		Declaration of the CTestAppWizardCases class
//

#ifndef __APPSNAP_H__
#define __APPSNAP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AppTestCases class

class CTestAppWizardCases : public CTest
{
	DECLARE_TEST(CTestAppWizardCases, CSniffDriver)

// Attributes
	int iteration ;
	int LangDlls ;

// Operations
public:
	virtual void Run();

// Data
protected:
	UITestAppWizard m_utstaw;

// Test Cases
protected:
	void NewProject(void);
	void MDIApp(void);
	void Classes(void);
	void ChangeAppType(void);
	void NoAbout(void);
	void JumpConfirm(void);
	void CreateProject(void);
	void VerifyFiles(void);
};

#endif //__APPSNAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\appsnap1.h ===
///////////////////////////////////////////////////////////////////////////////
//	APPSNAP.H
//
//	Created by :			Date :
//		Ivanl				12/29/94
//
//	Description :
//		Declaration of the CTestAppWizardCases class
//

#ifndef __APPSNAP_H__
#define __APPSNAP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
//	AppTestCases class

class CTestAppWizardCases : public CTestSet
{
public:
	CTestAppWizardCases();

// Attributes
	int iteration ;
	int LangDlls ;
public:
	DECLARE_GET_NAME();
//	DECLARE_GET_NUM_TESTS();

// Operations
public:
	virtual int Run(void* pData = NULL);

// Data
protected:
	UITestAppWizard m_utstaw;

// Test Cases
protected:
	void NewProject(void);
	void MDIApp(void);
	void Classes(void);
	void ChangeAppType(void);
	void NoAbout(void);
	void JumpConfirm(void);
	void CreateProject(void);
	void VerifyFiles(void);
};

#endif //__APPSNAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\awxcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	AWXCASES.H
//
//	Created by :			Date :
//		Ivanl					10/17/94
//
//	Description :
//		Declaration of the CAwxTestCases class
//

#ifndef __AWXCASES_H__
#define __AWXCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AwxTestCases class

class CAwxTestCases : public CTest
{
	DECLARE_TEST(CAwxTestCases, CSniffDriver)

// Attributes
	int iteration ;
	int LangDlls ;
public:
// Operations
public:
	virtual void Run(void);

// Data
protected:
	UIExtWizard m_extwiz;

// Test Cases
protected:
	void NewProject(void);
	void ChooseZapper(void);
	void ChooseCustom(void);
	void ChooseApwSequence(void);
};

#endif //__AWXCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\awxcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	AWXCASES.CPP
//
//	Created by :			Date :
//		Ivanl				10/17/94
//
//	Description :
//		Implementation of the CAwxTestCases class
//
															   
#include "stdafx.h"
#include "awxcases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

extern CString  szDir;
extern char szDirRes[];
extern char* szRes ;
extern CString LangDllName ;
extern CString CurrDir ;
extern CString msg ;
extern CString ProjDir;
extern HWND hSubWnd ;
  
IMPLEMENT_TEST(CAwxTestCases, CTest, "AppWizard Extension Tests", -1, CSniffDriver)

void CAwxTestCases::Run(void)
{
	iteration = 1 ;
	LangDlls = 0 ;

  // Flush the strings first
	LangDllName.Empty() ;
	CurrDir.Empty() ;
	msg.Empty() ;
	ProjDir.Empty() ;

 
   	szDir = "AWX_Test";          
   	LangDllName =" " ;            
   	msg = "Building proj with " ; 
   	ProjDir = szDir ;             
   	
	COProject cop ; 
	cop.DeleteFromProjectDir(ProjDir) ;
	NewProject() ;
	ChooseZapper() ;
	ChooseCustom() ;
	ChooseApwSequence() ;
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

// Create extension project
void CAwxTestCases::NewProject(void)
{
   	m_extwiz = UIWB.AppWizard();
	if( !m_extwiz.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch Custtom AppWizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Need App Wiz to test anymore");	// no sense continuing
	}

	m_extwiz.SetName("Edit");
	m_extwiz.SetSubDir(szDir);
	m_extwiz.Create();				
}

void CAwxTestCases::ChooseZapper()
{
	m_extwiz.SetExtType(IDC_ZAP) ;
	m_extwiz.NextPage();
   	m_extwiz.PrevPage();
}

//Select the Custom Option
void CAwxTestCases::ChooseCustom()
{
	m_extwiz.SetExtType(IDC_CUSTOM) ;
	m_extwiz.SetNumPages(4) ;
	m_extwiz.NextPage();
	m_extwiz.Cancel();
}

	//Select the AppWizard based option
void CAwxTestCases::ChooseApwSequence()
{
	m_extwiz.SetExtType(IDC_SEQUENCE) ;
	m_extwiz.NextPage() ;
	m_extwiz.SetDllExeType(IDC_APWZ_SEQ) ;
	m_extwiz.NextPage();
	if(!(BOOL)m_extwiz.ConfirmCreate())
	{
 		m_pLog->RecordFailure(" Problem creating Extension project, or opening it in the IDE");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clscases.h ===
///////////////////////////////////////////////////////////////////////////////
//	CLSCASES.H
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		Declaration of the CClsTestCases class
//

#ifndef __CLSCASES_H__
#define __CLSCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AppTestCases class

class CClsTestCases : public CTest
{
	DECLARE_TEST(CClsTestCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);

// Data
protected:
	CString m_strCWD;		// the test's current working directory

// Test Cases
protected:
	void OpenProject(void);
	void WizardOnProject(void);
	void TabThroughPages(void);
	void AddClassesAndMessages(void) ;
};

#endif //__CLSCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	CLWSNAP.H
//
//	Created by :			Date :
//		Ivanl				4/5/94
//
//	Description :
//		Declaration of the Classwizard cases
//

#ifndef __CLWCASES_H__
#define __CLWCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	ClassWizardTestCases class

class ClassWizardTestCases : public CIDETest
{
	DECLARE_TEST(ClassWizardTestCases, CSniffDriver);

// Attributes
public:
// Operations
public:
	virtual int Run(void);

// Data
protected:

// Test Cases
protected:
	void ClassWizard( );
	void ControlWizard();
};

#endif //__CLWCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clscases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CLSCASES.CPP
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		Implementation of the CClsTestCases class
//

#include "stdafx.h"
#include "clscases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// flag to indicate to class wizard whether app wizard was successful or not
extern BOOL gbAppWiz;

static char szDir[] = "CW_Test";
static char szDirRes[] = "CW_Test\\res";
static char szAWBase[] = "AW_Base";
static char szAWTest[] = "AW_Test";

IMPLEMENT_TEST(CClsTestCases, CTest, "ClassWizard Tests", -1, CSniffDriver)

void CClsTestCases::Run(void)
{
	// get the current working directory for this test
	::GetCurrentDirectory(MAX_PATH, m_strCWD.GetBuffer(MAX_PATH));
	m_strCWD.ReleaseBuffer();
	m_strCWD += '\\';

	KillAllFiles(m_strCWD + szDirRes);
	KillAllFiles(m_strCWD + szDir);
	CreateDirectory(m_strCWD + szDir, NULL);	// don't know what to do for SECURITY_ATTRIBUTES

	if(gbAppWiz)
		CopyTree(m_strCWD + szAWTest, m_strCWD + szDir);
	else
		CopyTree(m_strCWD + szAWBase, m_strCWD + szDir);

	OpenProject();
	AddClassesAndMessages() ;
	WizardOnProject();
	TabThroughPages();
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

void CClsTestCases::OpenProject(void)
{
	COProject prj;

	// open the project
	if (prj.Open(m_strCWD + szDir + "\\EDIT.MAK") != ERROR_SUCCESS) {
		m_pLog->RecordFailure("Unable to open project (%s).", (LPCTSTR)"edit.mak");
		return;
	}

	UIEditor uprj;
	uprj.AttachActive(); 
	CString str = uprj.GetTitle();
	str.MakeUpper();
	if (str.Find("EDIT") == -1) {
		m_pLog->RecordFailure("Opened project window '%s'", (LPCSTR)str );
	}
}

void CClsTestCases::WizardOnProject(void)
{
	if( UIWB.ClassWizard() == NULL )
		EXPECT_EXEC(FALSE, "Could not launch Class Wizard from menu.  Is it available?");
	else
		m_pLog->RecordInfo("Launched Class Wizard");
}

void CClsTestCases::TabThroughPages(void)
{
	for( int n = 0; n < 6; n++)
	{
		MST.DoKeys("{right}");	// walk through each tab, to at least verify they don't crash
		Sleep(500);
	}
	MST.DoKeys("{escape}");		// dismiss Class Wizard
	if (!UIWB.IsActive()) {
		m_pLog->RecordFailure("Dismissed Class Wizard, and returned focus to MSVC");
	}
}

void CClsTestCases::AddClassesAndMessages(void)
{
 int i, j, k ;
 UIClassWizard	ClsWiz ;
 COProject cop ;

 
 COResScript coRes ;
 
  MST.DoKeys("%(Fl)") ; 
 	for (i = 0; i < 2; i++)
	{
		coRes.CreateResource( /* IDSS_RT_DIALOG */ "Dialog" );
	}
	i = 0;

 MST.DoKeys("%(wl)") ;
 MST.DoKeys("{ENTER}") ;
 ClsWiz.Display() ;
  // Add a couple new classes ;
  for (k = 1; k < 5 ; k++)
 		ClsWiz.AddClass(k) ;
	  ClsWiz.EditCode() ;

   // Add several messages to the classes ;
   	for (k = 1; k < 3; k++)
	   for (j = 1; j < 2; j++) 
	  	  	for (i = 1; i < 2 ; i++)
		 	ClsWiz.AddFunction(k,i,j) ;
	 ClsWiz.EditCode() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwsnap.h ===
///////////////////////////////////////////////////////////////////////////////
//	CLWSNAP.H
//
//	Created by :			Date :
//		Ivanl				4/5/94
//
//	Description :
//		Declaration of the Classwizard cases
//

#ifndef __CLWCASES_H__
#define __CLWCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	ClassWizardTestCases class

class ClassWizardTestCases : public CTest
{
	DECLARE_TEST(ClassWizardTestCases, CSniffDriver)

public:
	COProject proj ;
	CString projName ;	
// Attributes
public:
// Operations
public:
	virtual void Run();

// Data
protected:

// Test Cases
protected:
	void ClassWizard( );
	void ControlWizard();
	void DeleteFunctions();
	void AddMemberVars() ;
};

#endif //__CLWCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwsnif.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "clwsnif.h"

#include "clwcases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// The one and only CSniffDriver object

CSniffDriver NEAR theApp;
CWBDebugThread NEAR theDebugThread;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

BEGIN_TESTSET_MAP(CSniffDriver)
	TESTSET(ClassWizardTestCases, TRUE)
END_TESTSET_MAP()

CSniffDriver::CSniffDriver()
{
}

BOOL CSniffDriver::InitializeTest( void )
{
	if( !CWBDriver::InitializeTest() )
		return FALSE;
	//TODO: Replace XXX with name of sniff test (e.g. VPROJ, VRES, etc.)
	//TODO: Replace OWNER with email name of owner
	return m_Log.BeginLog( "ClassWizard BVT", "Ivanl", "BVT", m_bDebug, m_bPost );
}

BOOL CSniffDriver::RunTests()
{
	return RunTestsInOrder() == 0;
}

BOOL CSniffDriver::FinalizeTest( void )
{
	m_Log.EndLog();
	return CWBDriver::FinalizeTest();
}

BEGIN_MESSAGE_MAP(CSniffDriver, CWBDriver)
	//{{AFX_MSG_MAP(CSniffDriver)
	//}}AFX_MSG_MAP
	// Standard file based document commands
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwsnap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	clwsnap.CPP
//											 
//	Created by :			Date :				    
//		Ivan				12/11/93
//
//	Description :								 					   
//		Snap test for the ClassWizard  

#include "stdafx.h"
#include "clwsnap.h"				 	  	 
											   		  
#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS
										 
IMPLEMENT_TEST(ClassWizardTestCases, CTest, "ClassWizard snap", -1, CSniffDriver)
UIClassWizard	ClsWiz ;


void ClassWizardTestCases::Run(void)
{

	ClassWizard() ; //Only ClassWizasrd bvt function.
//	DeleteFunctions () ;
	return ;
}


void ClassWizardTestCases::ClassWizard()				 
{ 	
    HWND hwnd ;
    int i, j, k, exitJ, exitK = -99 ;
	projName = "clwtest" ; 
	ClsWiz.SetDataSourceName(m_strCWD+"NWIND.MDB") ;
	proj.DeleteFromProjectDir("clwtest") ; // Cleanup directory
    // Create an AppWiz app
														   
	UIAppWizard apWiz = proj.AppWizard() ;
	apWiz.SetProjType(GetLocString(UIAW_PT_APPWIZ));
	apWiz.SetDir(m_strCWD) ;
	apWiz.SetName(projName) ;
	apWiz.Create();  
	apWiz.NextPage(); // ODBC page		 
	
	// Setup Database options
//#ifdef ODBC
	apWiz.SetDBOptions(UIAW_DB_VIEWFILE) ;
	MST.WButtonClick(apWiz.GetLabel(APPWZ_IDC_DATA_SOURCE)) ; //belongs in apwiz class
	
	UIDataBaseDlgs DBdlgs ;
	DBdlgs.WaitForLogin() ; // dumb wait.

	DBdlgs.SetDataBasePath(m_strCWD+"NWIND.MDB") ;
	DBdlgs.Sources.SetDAOName(DBdlgs.GetDataBasePath()) ;
	DBdlgs.Sources.Close() ;

	DBdlgs.WaitForTables() ;
	DBdlgs.tables.Name(1) ;
	DBdlgs.tables.Close() ;

//#endif //ODBC
	
//#ifdef OLE
	//Going to the next page will cause an AFXMessageBox to appear.
	//The OK button has ID of 1 so NextPage has been overloaded to be able
	//to pass a specific control ID.  If this message box no longer appears
	//or the control that needs to be pressed changes, this test may break.
	//A-RCahn 9-19-1997
  	apWiz.NextPage(1); // To OLE options	SetActiveWindow


	// Setup OLE options.
	apWiz.SetOLEOptions(UIAW_OLE_CONTAINER_SERVER);
	apWiz.SetOLEOptions(UIAW_OLE_YES_AUTO); 

//#endif //_OLE

	apWiz.Finish(1) ;	//This finish will cause a mesage box to appear
						//and the ID of the OK button is 1
						//so Finish has been overloaded so that the control ID
						//can be passed for clicking on.
						//If this message box is no longer invoked by the finish
						//or it changes somehow, this test step can break
						//A-RCahn 9-19-1997
  	apWiz.ConfirmCreate();
	proj.SetPathMembers() ;
	proj.Attach();

	hwnd = MST.WGetActWnd(0) ;
	// Create several dialog resources
	COResScript coRes ;

	for (i = 0; i < 5; i++)
	{
		coRes.CreateResource( IDSS_RT_DIALOG );
	}
	i = 0;

	// FOR TEST SHOULD NOT BE CALLED HERE.
	proj.Build() ;
	proj.WaitUntilBuildDone(5) ;
	// Close all open windows.
	MST.DoKeys("%(W)") ;
	MST.DoKeys("L") ;								 

	//coRes.Save() ;							  
	// Add new classes to the project
	ClsWiz.Display() ;
	AddMemberVars() ;

	for (k = 1; exitK != ERROR_ERROR; k++)
	{
		m_pLog->RecordInfo("k equals %d",k);
		switch(k)
		{
// Skips over classes with known problems.
//these numbers will change every time a new base class is added
//to the dropdown.
		case 3:
			k = 3; //skips adding CAsyncSocket class
		break ;
		case 5:
			k = 5; //skips adding CCachedDataPathProperty class
		break ;
		case 12:
			k = 12; //skips adding CDataPathProperty class
		break ;
		case 26:  //and 27
			k = 27; //skips adding CHttpFilter & CHttpServer classes
		break ;
		case 31:
			k = 31; //skips adding CListView class
		break ;
		case 44:
			k = 44; //skips adding CRecordView class
		break ;
		case 49:
			k = 49; //skips adding CSocket class
		break ;
		case 57:
			k = 57; //skips adding CTreeView class
		break ;
		default:
		exitK = ClsWiz.AddClass(k) ;
		}
	}

	ClsWiz.EditCode() ;
	proj.Build() ;
	proj.WaitUntilBuildDone(5) ;

// Create the *.PCH file 
	SetForegroundWindow(hwnd) ;
	MST.DoKeys("%(W)") ;
	MST.DoKeys("L") ;								 
	// Add all available messages to all classes
	CString Class = "                                                   "; 
	exitK = !ERROR_ERROR ;
	exitJ = !ERROR_ERROR ;
	ClsWiz.Display() ; 
	for (k = 1; k <= ClsWiz.GetClassCount(); k++)
	{	
		switch (k) // May need to skip over classes with known bugs.
		{
			/*case 7:
			case 12:
			case 38:
			break; */
			default:
			for (j = 1; exitJ != ERROR_ERROR; j++) 
			  {
	  			for (i = 1; ClsWiz.AddFunction(k,i,j) != ERROR_ERROR; i++) ;
				exitJ = ClsWiz.AddFunction(k,1,j+1) ;
			  }

			   Class = ClsWiz.GetActiveClass() ;
			   CString CppFile((char )'/0',255) ;
			   CppFile = ClsWiz.GetClassFile() ;		    
					
			   ClsWiz.EditCode() ; // remove after editcode bug fixed.
		//	   ClsWiz.Close() ;
			   MST.DoKeys("%(B)") ;
			   MST.DoKeys("c") ;
			   proj.WaitUntilBuildDone(5) ;
			//close the window 
			   MST.DoKeys("%(F)");
   			   MST.DoKeys("C") ;
 
			   if(!VERIFY_TEST_SUCCESS(proj.VerifyBuild()))
					m_pLog->RecordFailure( Class + ":  with all its messages was built." ) ;
			   else
					m_pLog->RecordInfo(Class + ": successfully built with all its messages was built." ) ;
			   ClsWiz.Display() ;
			   exitJ = !ERROR_ERROR ;
		}
	}
	ClsWiz.Close() ;
	return; 
}

void ClassWizardTestCases::AddMemberVars() 
{
	UIMemVarDlg * VarDlg ;
	ClsWiz.Display() ;
    
	ClsWiz.AddFunction(1,0,0) ; //Select the first class (About class ).
	int ListCount = 0 ;
	int BeginCount, CtrCount ;
	
	CtrCount = BeginCount = ClsWiz.GetControlCount() ;
	for (int Obcnt = 0; Obcnt < CtrCount; Obcnt++) // For each control ID, add members for each of its categories.
	{
		CString CtrIndex ; // We need this to append to the member variable name.
		CtrIndex.Format("%d",Obcnt+1); 

		VarDlg = ClsWiz.AddMemberVar(ListCount +Obcnt+1) ;
		int CatCount = VarDlg->CategoryCount() ;
		MST.DoKeys("{ESC}") ; // Close the dialog; We just wanted to get the category count.
		for (int j = 1; j <= CatCount; j++)
		{
			VarDlg = ClsWiz.AddMemberVar(ListCount+Obcnt+1) ;
			CString CatName = VarDlg->GetCategory(j) ;
			VarDlg->SetVarName(CatName+CtrIndex) ;
			VarDlg->SetCategory(j) ;
			MST.DoKeys("{ENTER}") ;
		}
		ListCount+=ClsWiz.GetControlCount() -BeginCount ;
		BeginCount = ClsWiz.GetControlCount() ;
	}
}

void ClassWizardTestCases::DeleteFunctions()
{ 	
    int i, j, k, exitJ, exitK = -99 ;
	CString CopyName ="CW_Copy" ;
	COProject projCopy ;						 
	projCopy.DeleteFromProjectDir(m_strCWD+CopyName) ; // Cleanup directory
	CreateDirectory(m_strCWD+CopyName, NULL);	

    // Copy the project we added classes/functions to in the previous test to a new directory.
	CopyTree(proj.GetDir(),m_strCWD+CopyName);
	
	// Open the project files.
	if (projCopy.Open(m_strCWD+CopyName+ "\\"+proj.GetName()) != ERROR_SUCCESS) {
		m_pLog->RecordFailure("Unable to open project (%s).", (LPCTSTR)proj.GetName());
		return;
	}
									   
	// Invoke ClassWizard and delete all mapped functions 
	exitK = !ERROR_ERROR ;
	exitJ = !ERROR_ERROR ;
	ClsWiz.Display() ;
	for (k = 1; exitK != ERROR_ERROR; k++)
	{
	  for (j = 1; exitJ != ERROR_ERROR; j++) 
	  {
		int ret ;
	  	for (i = 1; (ret=ClsWiz.DeleteFunction(k,i,j)) != ERROR_ERROR; i++)
		{
			if ( ID_NODELETE == ret)
				m_pLog->RecordFailure( " Above massage handler was not deleted." ) ;
		}
		exitJ = ClsWiz.DeleteFunction(k,1,j+1) ;
	  }
       ClsWiz.EditCode() ;
	   ClsWiz.Close() ;
	   exitJ = !ERROR_ERROR ;
	   exitK = ClsWiz.AddFunction(k+1,1,1) ;
	}
	ClsWiz.Close() ;
	return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwsnif.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __WBDRV_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CWBDriver
{
public:
	CSniffDriver();

	DECLARE_TESTSET_MAP();

// Event Sequence
public:
 	virtual BOOL InitializeTest( void );
	virtual BOOL RunTests( void );
	virtual BOOL FinalizeTest( void );

// Internal Workings
protected:

// Utility Functions
protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CSniffDriver)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST();

	virtual void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	MyCASES.CPP
//											 
//	Created by :			Date :				    
//		Ivan				12/11/93
//
//	Description :								 					   
//		Sample test for COProject APIs		  

#include "stdafx.h"
#include "clwcases.h"				 	  	 
											   		  
#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS
												 
IMPLEMENT_TEST(ClassWizardTestCases, CTest, "ClassWizard snap", -1, CSniffDriver)

int ClassWizardTestCases::Run(void)
{
BEGIN_TESTSET();

//XSAFETY;
											 
ClassWizard() ; // This is the function which tests out the different APIs

return EndTestSet();	// returns how many failed in this test set
}


BOOL ClassWizardTestCases::ClassWizard()				 
{ 	
    HWND hwnd ;
	DESC( "Test Classwizard templates", "ClassWizard" );
    int i, j, k, exitJ, exitK = -99 ;
	COProject proj ;						 
	UIClassWizard	ClsWiz ; 							 

	proj.DeleteFromProjectDir("clwtest") ; // Cleanup directory
    // Create an AppWiz app
														   
	UIAppWizard apWiz = UIWB.AppWizard() ;		 
	apWiz.SetName("clwtest") ;							    
	apWiz.Create();  
	apWiz.NextPage(); // ODBC page		 
	
	// Setup Database options
#ifdef ODBC
	apWiz.SetDBOptions(UIAW_DB_VIEWFILE) ;
	MST.WButtonClick(apWiz.GetLabel(APPWZ_IDC_DATA_SOURCE)) ; //belongs in apwiz class
	
	UIDataBaseDlgs DBdlgs ;
	DBdlgs.WaitForSources() ;
	DBdlgs.Sources.Name("SL") ;
	DBdlgs.Sources.Close() ;
													 
	DBdlgs.WaitForLogin() ;
	DBdlgs.login.ID("sa") ;
	DBdlgs.login.Pw("") ;
	DBdlgs.login.Close() ;
	
	DBdlgs.WaitForTables() ;
	DBdlgs.tables.Name(1) ;
	DBdlgs.tables.Close() ;
#endif //ODBC
	
#ifdef OLE
  	apWiz.NextPage(); // To OLE options	SetActiveWindow

	// Setup OLE options.
	apWiz.SetOLEOptions(UIAW_OLE_CONTAINER_SERVER);
	apWiz.SetOLEOptions(UIAW_OLE_YES_AUTO); 

#endif //_OLE

	apWiz.Finish() ;
  	apWiz.ConfirmCreate();
	hwnd = MST.WGetActWnd(0) ;
	// Create several dialog resources
	COResScript coRes ;

	for (i = 0; i < 5; i++)
	{
		coRes.CreateResource( IDSS_RT_DIALOG );
	}
	i = 0;
	//coRes.Save() ;							  
	// Add new classes to the project
	ClsWiz.Display() ;
	for (k = 1; exitK != ERROR_ERROR; k++)
	 	exitK = ClsWiz.AddClass(k) ;

	ClsWiz.EditCode() ;

	// Create the *.PCH file 
	SetForegroundWindow(hwnd) ;
	MST.DoKeys("%(W)") ;
	MST.DoKeys("L") ;								 

	proj.SelectFile("stdafx.cpp","Source Files") ;
	MST.DoKeys("%(P)") ;
	MST.DoKeys("c") ;
	proj.WaitUntilBuildDone(5) ;
	// Add all available messages to all classes
	CString Class = "                                                   "; 
	exitK = !ERROR_ERROR ;
	exitJ = !ERROR_ERROR ;
	ClsWiz.Display() ;
	for (k = 1; exitK != ERROR_ERROR; k++)
	{
	  for (j = 1; exitJ != ERROR_ERROR; j++) 
	  {
	  	for (i = 1; ClsWiz.AddFunction(k,i,j) != ERROR_ERROR; i++) ;
		exitJ = ClsWiz.AddFunction(k,1,j+1) ;
	  }

	   Class = ClsWiz.GetActiveClass() ;
	   CString CppFile('/0',255) ;
	   CppFile = ClsWiz.GetClassFile() ;		    
	   ClsWiz.Close() ;
	//   proj.Build(15) ;
	// Build the class implementation file.
		proj.SelectFile(CppFile,"Source Files") ;
		MST.DoKeys("%(P)") ;
		MST.DoKeys("c") ;
		proj.WaitUntilBuildDone(5) ;
	
	   WriteLog(VERIFY_TEST_SUCCESS(proj.VerifyBuild()), Class + ":  with all its messages was built." ) ;
	   ClsWiz.Display() ;
	   exitJ = !ERROR_ERROR ;
	   exitK = ClsWiz.AddFunction(k+1,1,1) ;
	}
	ClsWiz.Close() ;
	return TRUE ; 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		DavidGa					10/27/93
//
//	Description :
//		implementation of the Wizards' CSniffDriver class
//

#include "stdafx.h"
#include "sniff.h"

#include "appsnap.h"
#include "clwsnap.h"
#include "ctrsnap.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "Wizards Snap test", "AnitaG")

BEGIN_TESTLIST(CSniffDriver)
	TEST(CTestAppWizardCases, DONTRUN)	//appsnap.cpp
	TEST(ClassWizardTestCases, RUN)	//clwsnap.cpp
	TEST(CCtrlWizardCases, RUN)	//ctrsnap.cpp
END_TESTLIST()


// flag to indicate to class wizard whether app wizard was successful or not
BOOL gbAppWiz;

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
 
	gbAppWiz = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\ctrsnap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CTRCASES.CPP
//
//	Created by :			Date :
//		ivanl					4/8/95
//
//	Description :
//		Implementation of the CCtrlWizardCases class
//

#include "stdafx.h"
#include "ctrsnap.h"
#include "resource.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

extern char* szRes ;
extern HWND hSubWnd ;
CString LangDllName ;
CString msg ;

IMPLEMENT_TEST(CCtrlWizardCases, CTest, "ControlWizard snap", -1, CSniffDriver)

void CCtrlWizardCases::Run(void)
{
	iteration = 1 ;
	LangDlls = 0 ;
	m_pLog->Comment("in ctrsnap.cpp");

  // Flush the strings first
	LangDllName.Empty() ;
	CurrDir.Empty() ;
	msg.Empty() ;
	ProjDir.Empty() ;
   	LangDllName =" " ;            

	szDir.LoadString(IDS_CTRWIZDIR) ; 
	ProjName.LoadString(IDS_CTRWIZNAME) ;
   	//ProjDir = szDir ;  
	ProjDir = ProjName;
    prj.DeleteFromProjectDir(ProjDir) ;
	NewProject() ;
	SetProjOptions() ;
	SetCtrlOptions() ;
	GenerateProject() ;
	m_pLog->Comment("add methods");
	AddControlMethods() ;
	m_pLog->Comment("add events");
	AddControlEvents() ;
	m_pLog->Comment("add properties");
	AddControlProperty() ;

}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

// Create extension project
void CCtrlWizardCases::NewProject(void)
{

// REVIEW(briancr): we can't support AppWizard at the UWBFrame level--it's in COProject
//	m_ctrlwiz = UIWB.AppWizard();
	m_ctrlwiz = prj.AppWizard(TRUE);
	if( !m_ctrlwiz.IsValid() )
	{
		m_pLog->RecordFailure("Did not launch Control AppWizard from File/New/Project");
		EXPECT_EXEC(FALSE, "Need Custom Appwizar to test anymore");	// no sense continuing
	}
	m_ctrlwiz.SetDir(m_strCWD) ;
	m_ctrlwiz.SetName(ProjName);
	m_ctrlwiz.SetSubDir(szDir);
	Sleep(5000);
	m_ctrlwiz.Create();				

	prj.Attach();
}

void CCtrlWizardCases::SetProjOptions()
{
	m_ctrlwiz.SetCount(1) ;
	m_ctrlwiz.SetLicenceOpt(1);
   	m_ctrlwiz.NextPage();
}

//Select the Custom Option
void CCtrlWizardCases::SetCtrlOptions()
{
	CString Name = "Control_" ;

        for(int i = 1; i < 2; i++)
	{
		CString cnt;
		cnt.Format("%d",i) ;
		m_ctrlwiz.SetActive(i) ;
        m_ctrlwiz.SubClassCtrl(2) ; //button
		m_ctrlwiz.SummaryInfo() ;

		m_ctrlwiz.SumDlg.SetShortName(Name+cnt);
		m_ctrlwiz.SumDlg.Close() ;
	}
}

void CCtrlWizardCases::GenerateProject()
{	
	m_ctrlwiz.NextPage() ;
	if(!m_ctrlwiz.ConfirmCreate())
	{
 		m_pLog->RecordFailure(" Problem creating a control project, or opening it in the IDE");
	}
}

void CCtrlWizardCases::AddControlProperty() 
{
	UIClassWizard	ClsWiz ;
	UIAddProperty * PropDlg = ClsWiz.AddOleProperty() ;

// Loop through and add all the stock properties.
	int StockCnt = PropDlg->GetStockCount() ;
	for(int i = 1 ;i < StockCnt ;i++ )
	{
		PropDlg->SetExtName(i) ;
		PropDlg->SetImplementation(STOCK) ;
		PropDlg->Create() ;
		PropDlg = ClsWiz.AddOleProperty() ;
	}
	MST.DoKeys("{ESC}"); // Close propert dialog.

	// Loop through and create properties for each of the return types. 
	PropDlg = ClsWiz.AddOleProperty() ;
	int TypesCnt = PropDlg->GetRetTypeCount() ;
	
	for(i = 1 ;i <= TypesCnt ;i++ )
	{   
		CString count ;
		count.Format("%d",i);
		PropDlg->SetImplementation(MEMBER_VAR) ;
		PropDlg->SetExtName(PropDlg->SetReturnType(i)+"MemVar" +count);
		PropDlg->Create() ;
		PropDlg = ClsWiz.AddOleProperty() ;
	}
	MST.DoKeys("{ESC}"); // Close propert dialog.

	// Use Get/Set implemantation.
		// Loop through and create properties for each of the return types. 
	PropDlg = ClsWiz.AddOleProperty() ;
	m_pLog->RecordInfo("getting return type count");
	TypesCnt = PropDlg->GetRetTypeCount() ;
	m_pLog->RecordInfo("type count is %d",TypesCnt);
	m_pLog->RecordInfo("setting implementation");
	PropDlg->SetImplementation(GET_SET_MEHOD) ;
	//ParamTypeCount doesn't work so hard-coding parameter count
	//anita george - 10/2/97
	//int ParamCnt = PropDlg->ParamTypeCount() ;
	int ParamCnt = 50;

	int FormalPrm = (ParamCnt / TypesCnt) + 1;
	
// Work around bug # 9930.
    //DoKeys("{ENTER}") ;
	m_pLog->RecordInfo("setting external name");
	PropDlg->SetExtName(PropDlg->SetReturnType(1)+"GetSetTest");
	m_pLog->RecordInfo("creating");
	PropDlg->Create() ;

	for(i = 1 ;i <= TypesCnt ;i++ )
	{  

		m_pLog->RecordInfo("in for loop");
		m_pLog->RecordInfo("i is %d",i);
		m_pLog->RecordInfo("AddOleProperty");
		PropDlg = ClsWiz.AddOleProperty() ;
		m_pLog->RecordInfo("setting implementation");
		PropDlg->SetImplementation(GET_SET_MEHOD) ;
		m_pLog->RecordInfo("SetExtName");
		PropDlg->SetExtName(PropDlg->SetReturnType(i)+"GetSetProp");
		for(int j= 0; j<= FormalPrm; j++ ) 
		{
			m_pLog->RecordInfo("j is %d",j);
			m_pLog->RecordInfo("FormalPrm is %d",FormalPrm);
			m_pLog->RecordInfo("ParamCnt is %d",ParamCnt);

			// Provides a value in range of the available param types. Base = 1.
			int item = (((i-1)* FormalPrm)+j) % (ParamCnt +1) ;
			m_pLog->RecordInfo("item is %d",item);
			if (item == 1)
				item = FormalPrm+1 ; // Don't need the first one since we create one by default.
			m_pLog->RecordInfo("item is %d",item);
			m_pLog->RecordInfo("AddParameter");
			PropDlg->AddParameter(item, "NULL");
		} 
		PropDlg->Create() ;
	}
	ClsWiz.Close() ;
    prj.Build(15) ;
    if (!VERIFY_TEST_SUCCESS(prj.VerifyBuild())) {
          m_pLog->RecordFailure("Building with all Property types and implementations");
     }

}	



void CCtrlWizardCases::AddControlMethods() 
{
	UIClassWizard	ClsWiz ;
	UIAddMethod * MethDlg = ClsWiz.AddOleMethod() ;

	//This will create the DoClick method that is one of the
	//defaults
	m_pLog->Comment("adding DoClick");
	MethDlg->SetExtName(1) ;
	MethDlg->SetImplementation(STOCK) ;
	MethDlg->Create() ;
 
	//This will create the Refresh method that is one of the
	//defaults
	MethDlg = ClsWiz.AddOleMethod();//This opens up the Add Method dialog
	m_pLog->Comment("adding Refresh");
	MethDlg->SetExtName(2) ;
	MethDlg->SetImplementation(STOCK) ;
	MethDlg->Create() ;
 

	MethDlg = ClsWiz.AddOleMethod();//This opens up the Add Method dialog
	int TypesCnt = MethDlg->GetRetTypeCount(); //Will type TEST into external name
											   //so we can get all the return types
	m_pLog->RecordInfo("typescnt is %d", TypesCnt);
	int ParamCnt = MethDlg->ParamTypeCount();	//Get the number of parameter types available
	m_pLog->RecordInfo("paramcnt is %d", ParamCnt);
	int FormalPrm = (ParamCnt / TypesCnt) + 1;	//Will be used below to create "random" param types
	m_pLog->RecordInfo("formalprm is %d", FormalPrm);
	
// Work around bug # 9930.  //Not a VC98 bug number.  A-RCahn 9-19-97
    //DoKeys("{ENTER}") ;
	//MethDlg->SetExtName(MethDlg->SetReturnType(1)+"TestMethod");
	//MethDlg->Create() ;
	CString methodName;
	// Loop through and create methods for each of the return types. 
	for(int i = 1 ;i <= TypesCnt ;i++ )
	{
		MethDlg = ClsWiz.AddOleMethod();//Open the addMethod dialog
										//AddOleMethod will delete old MethDlg
		methodName = MethDlg->SetReturnType(i); //Select the next return type
		methodName += "Method"; //Make a method name name called "<returntype>Method"
		MethDlg->SetExtName(methodName); //Set the external name to "<returntype>Method"
		//WARNING:  Major Hack Alert
		//Because of problems with the Class Wizard's Add Member Dialog
		//We tab three times here to get to the ParameterList prior to 
		//calling AddParameter below.
		//Obviously this hard coding of tabbing is bad and will eventually
		//cause this test to break again.  A-RCahn 9-19-97
		DoKeys("{TAB}");
		DoKeys("{TAB}");
		DoKeys("{TAB}");
		for(int j= 1; j<= FormalPrm; j++ )
		{
			//WARNING:  Because of problems with the Class Wizard's Add Member Dialog
			//The code below has been commented out because the &Parameter list: string
			//is missing from the Parameter listbox.  A-RCahn 9-19-97
			// Provides a value in range of the available param types. Base = 1.
			//int item = (((i-1)* FormalPrm)+j) % (ParamCnt +1) ;
			//if (item == 1)
			//	item = FormalPrm+1 ; // Don't need the first one since we create one by default.
			MethDlg->AddParameter(j, "NULL");
		}

		MethDlg->Create() ; //Hit OK to create the new method
		methodName.Empty(); //Flush the old string for reuse above.

	} //loop to next return type
	ClsWiz.Close() ;//We're done creating methods
	//Now let's build to test for success
    m_pLog->RecordInfo("Building with all method types");
	prj.Build(15) ;
    if (!VERIFY_TEST_SUCCESS(prj.VerifyBuild()))
	{
          m_pLog->RecordFailure("Failure occured building new methods");
    }

}	

void CCtrlWizardCases::AddControlEvents() 
{
	UIClassWizard	ClsWiz ;
	m_pLog->RecordInfo("ready to do AddOleEvent");
	UIAddEvent * EventDlg = ClsWiz.AddOleEvent() ;
	int StockCnt = EventDlg->GetStockCount() ;
	// Create 2 stock events.
	m_pLog->RecordInfo("stock count is %d",StockCnt);
	for(int i = 1; i<= StockCnt; i++)
	{
		m_pLog->RecordInfo("i is %d",i);
		EventDlg->SetExtName(i) ;
		EventDlg->SetImplementation(STOCK) ;
		EventDlg->Create() ;
		EventDlg = ClsWiz.AddOleEvent() ;
	}
	//m_pLog->RecordInfo("done in for loop");
	MST.DoKeys("{ESC}"); // Cancel out of the methods dialog the last time.

	//when we continue the test from here, cafe eventually crashes while creating the
	//event called TestEvent.  I don't have time to investigate now, but
	//I'm leaving my print statements in here for anyone who plans on fixing this.
	//anita george - 9/30/97.
	
	//m_pLog->RecordInfo("Loop through and create Events for each of the return types.");
	// Loop through and create Events for each of the return types. 
	/*EventDlg = ClsWiz.AddOleEvent() ;
	int ParamCnt = EventDlg->ParamTypeCount() ;
	int FormalPrm = 2 ;
	
// Work around bug # 9930.
    DoKeys("{ENTER}") ;
	m_pLog->RecordInfo("ready to setextname to testevent");
	EventDlg->SetExtName("TestEvent") ;
	m_pLog->RecordInfo("create");
	EventDlg->Create() ;
	m_pLog->RecordInfo("ParamCnt is %s",ParamCnt);
	for(i = 1 ;i <= (ParamCnt/2)+1 ;i++ )
	{
		m_pLog->RecordInfo("i is %d",i);
		EventDlg = ClsWiz.AddOleEvent() ;
		CString count ;
		count.Format("%d",i);
		CString EvName = "Event" ;
		EventDlg->SetExtName(EvName+count);
		m_pLog->RecordInfo("FormalPrm is %s",FormalPrm);
		for(int j= 0; j<= FormalPrm; j++ )
		{
			m_pLog->RecordInfo("j is %d",j);
			// Provides a value in range of the available param types. Base = 1.
		//	int item = i +j % (ParamCnt +1) ;
			int item = (((i-1)* FormalPrm)+j) % (ParamCnt +1) ;
			m_pLog->RecordInfo("item is %d",item);
			if (item == 1)
				item = FormalPrm+1 ; // Don't need the first one since we create one by default.
			EventDlg->AddParameter(item, "NULL");
		}
		EventDlg->Create() ;
	}	*/
	ClsWiz.Close() ;
	prj.Build(15) ;
    if (!VERIFY_TEST_SUCCESS(prj.VerifyBuild())) {
          m_pLog->RecordFailure("Building with all event types");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by wizards.rc
//
#define IDS_RANGE_WIZARDS               2000
#define IDS_DIRNAME                     2001
#define IDS_AWDIRNAME                   2001
#define IDS_RESDIRNAME                  2002
#define IDS_PROJNAME                    2003
#define IDS_AWXDIRNAME                  2004
#define IDS_CLWDIRNAME                  2005
#define IDS_RESCWRESDIR                 2006
#define IDS_CLWBASEDIR                  2008
#define IDS_CTRWIZDIR                   2009
#define IDS_CTRWIZNAME                  2010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\ctrsnap.h ===
///////////////////////////////////////////////////////////////////////////////
//	CTRCASES.H
//
//	Created by :			Date :
//		Ivanl					3/17/94
//
//	Description :
//		Declaration of the CCtrlWizardCases class
//

#ifndef __CTRCASES_H__
#define __CTRCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	AwxTestCases class

class CCtrlWizardCases : public CTest
{
	DECLARE_TEST(CCtrlWizardCases, CSniffDriver)

// Attributes
	int iteration ;
	int LangDlls ;
	COProject prj;
public:
// Operations
// Data members
	CString  szDir ; 
	CString szDirRes ;
	CString ProjName ;
	CString ProjDir ;
	CString CurrDir ;// ('\0',256) ;

public:
	virtual void Run(void);

// Data
protected:
	UICtrlWizard m_ctrlwiz;

// Test Cases
protected:
	void NewProject(void);
	void SetProjOptions(void);
	void SetCtrlOptions(void);
	void GenerateProject(void) ;
	void AddControlMethods(void) ;
	void AddControlEvents(void) ;
	void AddControlProperty(void) ;
};

#endif //__CTRCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwizard\clwsnif.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "clwsnif.h"

#include "clwcases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// The one and only CSniffDriver object

CSniffDriver NEAR theApp;
CWBDebugThread NEAR theDebugThread;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

BEGIN_TESTSET_MAP(CSniffDriver)
	TESTSET(ClassWizardTestCases, TRUE)
END_TESTSET_MAP()

CSniffDriver::CSniffDriver()
{
}

BOOL CSniffDriver::InitializeTest( void )
{
	if( !CWBDriver::InitializeTest() )
		return FALSE;
	//TODO: Replace XXX with name of sniff test (e.g. VPROJ, VRES, etc.)
	//TODO: Replace OWNER with email name of owner
	return m_Log.BeginLog( "ClassWizard BVT", "Ivanl", "BVT", m_bDebug, m_bPost );
}

BOOL CSniffDriver::RunTests()
{
	return RunTestsInOrder() == 0;
}

BOOL CSniffDriver::FinalizeTest( void )
{
	m_Log.EndLog();
	return CWBDriver::FinalizeTest();
}

BEGIN_MESSAGE_MAP(CSniffDriver, CWBDriver)
	//{{AFX_MSG_MAP(CSniffDriver)
	//}}AFX_MSG_MAP
	// Standard file based document commands
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwizard\clwsnif.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __WBDRV_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CWBDriver
{
public:
	CSniffDriver();

	DECLARE_TESTSET_MAP();

// Event Sequence
public:
 	virtual BOOL InitializeTest( void );
	virtual BOOL RunTests( void );
	virtual BOOL FinalizeTest( void );

// Internal Workings
protected:

// Utility Functions
protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CSniffDriver)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwizard\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwizard\clwcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	XXXCASES.H
//
//	Created by :			Date :
//		Ivanl				4/5/94
//
//	Description :
//		Declaration of the Classwizard cases
//

#ifndef __CLWCASES_H__
#define __CLWCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
//	XxxTestCases class

class ClassWizardTestCases : public CTestSet
{
public:
	ClassWizardTestCases();

// Attributes
public:
	DECLARE_GET_NAME();
	DECLARE_GET_NUM_TESTS();

// Operations
public:
	virtual int Run(void* pData = NULL);

// Data
protected:

// Test Cases
protected:
	BOOL ClassWizard( PDESCH );
	BOOL ControlWizard( PDESCH );
};

#endif //__CLWCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwizard\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__
#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\apwiztes.h ===
#ifndef __APWIZTES_H__
#define __APWIZTES_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

// TODO: You may add any other custom AppWizard-wide declarations here.


#endif //__APWIZTES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\apwiztes.cpp ===
// apwiztes.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "apwiztes.h"
#include "apwizaw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE apwiztesDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("APWIZTES.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(apwiztesDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(apwiztesDLL);
		//Register the CustomAppwizard with MFCAPWZ.DLL
		SetCustomAppWizClass(&apwiztesaw) ;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("APWIZTES.DLL Terminating!\n");
	}
	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\apwizaw.cpp ===
// apwizaw.cpp : implementation file
//

#include "stdafx.h"
#include "apwiztes.h"
#include "apwizaw.h"
#include "chooser.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// This is called immediately after the custom AppWizard is loaded.  Initialize
//  the state of the custom AppWizard here.
void CApwiztesAppWiz::InitCustomAppWiz()
{
	// Create a new dialog chooser; CDialogChooser's constructor initializes
	//  its internal array with pointers to the steps.
	m_pChooser = new CDialogChooser;

	// At first, we don't know the total number of steps, since there are two
	//  possible "tracks" (MDI/SDI app and dialog-based app).
	SetNumberOfSteps(-1);

	// Inform AppWizard of the languages we support
	SetSupportedLanguages("English [United States] (appwzenu.dll);0x40904e4");

	// TODO: Add any other custom AppWizard-wide initialization here.
}

// This is called just before the custom AppWizard is unloaded.
void CApwiztesAppWiz::ExitCustomAppWiz()
{
	// Deallocate memory used for the dialog chooser
	ASSERT(m_pChooser != NULL);
	delete m_pChooser;
	m_pChooser = NULL;

	// TODO: Add code here to deallocate resources used by the custom AppWizard
}

// This is called when the user clicks "Create..." on the New Project dialog
//  or "Next" on one of the custom AppWizard's steps.
CAppWizStepDlg* CApwiztesAppWiz::Next(CAppWizStepDlg* pDlg)
{
	// Delegate to the dialog chooser
	return m_pChooser->Next(pDlg);
}

// This is called when the user clicks "Back" on one of the custom
//  AppWizard's steps.
CAppWizStepDlg* CApwiztesAppWiz::Back(CAppWizStepDlg* pDlg)
{
	// Delegate to the dialog chooser
	return m_pChooser->Back(pDlg);
}

// Here we define one instance of the CApwiztesAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global apwiztesaw.
CApwiztesAppWiz apwiztesaw;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\clwizard\clwcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	MyCASES.CPP
//											 
//	Created by :			Date :				    
//		Ivan				12/11/93
//
//	Description :								 
//		Sample test for COProject APIs		 

#include "stdafx.h"
#include "clwcases.h"

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS
												 
IMPLEMENT_GET_NAME(ClassWizardTestCases, "Wizard BVT ", NULL)
IMPLEMENT_GET_NUM_TESTS(ClassWizardTestCases, 1, 1)

ClassWizardTestCases::ClassWizardTestCases()
{
}

int ClassWizardTestCases::Run(void* pData /*=NULL*/)
{
BEGIN_TESTSET();

XSAFETY;
											 
ClassWizard() ; // This is the function which tests out the different APIs

return EndTestSet();	// returns how many failed in this test set
}


BOOL ClassWizardTestCases::ClassWizard(PDESC)				 
{ 	
    
	DESC( "Test Classwizard templates", "ClassWizard" );
    int i, j, k, exitJ, exitK = -99 ;
	COProject proj ;						 
	UIClassWizard	ClsWiz ; 

	proj.DeleteFromProjectDir("clwtest") ; // Cleanup directory
    // Create an AppWiz app
														   
	UIAppWizard apWiz = UIWB.AppWizard() ;		 
	apWiz.SetName("clwtest") ;							    
	apWiz.Create();  
	apWiz.NextPage(); // ODBC page		 
	
	// Setup Database options
	apWiz.SetDBOptions(UIAW_DB_VIEWFILE) ;
	MST.WButtonClick(apWiz.GetLabel(APPWZ_IDC_DATA_SOURCE)) ; //belongs in apwiz class
	
	UIDataBaseDlgs DBdlgs ;
	DBdlgs.WaitForSources() ;
	DBdlgs.Sources.Name("SL") ;
	DBdlgs.Sources.Close() ;

	DBdlgs.WaitForLogin() ;
	DBdlgs.login.ID("sa") ;
	DBdlgs.login.Pw("") ;
	DBdlgs.login.Close() ;
	
	DBdlgs.WaitForTables() ;
	DBdlgs.tables.Name(1) ;
	DBdlgs.tables.Close() ;
  	
  	apWiz.NextPage(); // To OLE options

	// Setup OLE options.
	apWiz.SetOLEOptions(UIAW_OLE_CONTAINER_SERVER);
	apWiz.SetOLEOptions(UIAW_OLE_YES_AUTO);
	apWiz.Finish() ;
  	apWiz.ConfirmCreate();

	// Create several dialog resources
	COResScript coRes ;

	for (i = 0; i < 5; i++)
	{
		coRes.CreateResource( IDSS_RT_DIALOG );
	}
	i = 0;
	//coRes.Save() ;							  
	// Add new classes to the project
	ClsWiz.Display() ;
	for (k = 1; exitK != ERROR_ERROR; k++)
	 	exitK = ClsWiz.AddClass(k) ;
	ClsWiz.EditCode() ;

	// Add all available messages to all classes
	CString Class = "                                                   "; 
	exitK = !ERROR_ERROR ;
	exitJ = !ERROR_ERROR ;
	ClsWiz.Display() ;
	for (k = 1; exitK != ERROR_ERROR; k++)
	{
	  for (j = 1; exitJ != ERROR_ERROR; j++) 
	  {
	  	for (i = 1; ClsWiz.AddFunction(k,i,j) != ERROR_ERROR; i++) ;
		exitJ = ClsWiz.AddFunction(k,1,j+1) ;
	  }

	   Class = ClsWiz.GetActiveClass() ;
	   ClsWiz.Close() ;
	   proj.Build(15) ;
	   WriteLog(VERIFY_TEST_SUCCESS(proj.VerifyBuild()), Class + ":  with all its messages was built." ) ;
	   ClsWiz.Display() ;
	   exitJ = !ERROR_ERROR ;
	   exitK = ClsWiz.AddFunction(k+1,1,1) ;
	}
	ClsWiz.Close() ;
	return TRUE ; 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\chooser.h ===
// chooser.h : declaration of the CDialogChooser class
//             This class keeps track of what dialogs to pop up when.

#ifndef __CHOOSER_H__
#define __CHOOSER_H__

#define LAST_DLG 8

class CDialogChooser
{
public:
	CDialogChooser();
	~CDialogChooser();

	// All calls by mfcapwz.dll to CApwiztesAppWiz::Next
	//  & CApwiztesAppWiz::Back are delegated to these member
	//  functions, which keep track of what dialog is up
	//  now, and what to pop up next.
	CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
	CAppWizStepDlg* Back(CAppWizStepDlg* pDlg);

protected:
	// Current step's index into the current track (defined in chooser.cpp).
	int m_nCurrDlg;

	// Internal array of pointers to the steps
	CAppWizStepDlg* m_pDlgs[LAST_DLG + 1];

	// Current track (MDI/SDI app or dialog-based app; see chooser.cpp).
	int m_nTrack;
};

#endif //__CHOOSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\apwizaw.h ===
// apwizaw.h : header file
//

class CDialogChooser;

// All function calls made by mfcapwz.dll to this custom AppWizard (except for
//  GetCustomAppWizClass-- see apwiztes.cpp) are through this class.  You may
//  choose to override more of the CCustomAppWiz virtual functions here to
//  further specialize the behavior of this custom AppWizard.
class CApwiztesAppWiz : public CCustomAppWiz
{
public:
	virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
	virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg);
		
	virtual void InitCustomAppWiz();
	virtual void ExitCustomAppWiz();

protected:
	CDialogChooser* m_pChooser;
};

// This declares the one instance of the CApwiztesAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global Apwiztesaw.  (Its definition is in apwizaw.cpp.)
extern CApwiztesAppWiz apwiztesaw;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\chooser.cpp ===
// chooser.cpp : Implements the CDialogChooser class
//

#include "stdafx.h"
#include "apwiztes.h"
#include "chooser.h"
#include "cstm1dlg.h"
#include "apwizaw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


// On construction, set up internal array with pointers to each page.
CDialogChooser::CDialogChooser()
{
	m_pDlgs[0] = NULL;
	
	m_pDlgs[1] = new CCustom1Dlg;
	m_pDlgs[2] = GetDialog(APWZDLG_APPTYPE);
	m_pDlgs[3] = GetDialog(APWZDLG_DATABASE);
	m_pDlgs[4] = GetDialog(APWZDLG_OLE);
	m_pDlgs[5] = GetDialog(APWZDLG_DOCAPPOPTIONS);
	m_pDlgs[6] = GetDialog(APWZDLG_PROJOPTIONS);
	m_pDlgs[7] = GetDialog(APWZDLG_CLASSES);
	m_pDlgs[8] = GetDialog(APWZDLG_DLGAPPOPTIONS);

	m_nCurrDlg = 0;
	m_nTrack = 0;
}
// Remember where the custom pages begin, so we can delete them in
//  the destructor
#define FIRST_CUSTOM_DLG 1

// Set up arrays of indices to simulate behavior of AppWizard (i.e., to have
//  separate "tracks" for an MDI/SDI app and a dialog-based app).
static int nDocTrack[] = {0,1, 2, 3, 4, 5,6,7};
static int nDlgTrack[] = {0,1, 2, 8, 6, 7};
static int* pnTrack[] = {nDocTrack, nDlgTrack};
static int nLast[] = {7, 5};

// The destructor deletes entries in the internal array corresponding to
//  custom pages.
CDialogChooser::~CDialogChooser()
{
	for (int i = FIRST_CUSTOM_DLG; i <= 1/*LAST_DLG*/; i++)
	{
		ASSERT(m_pDlgs[i] != NULL);
		delete m_pDlgs[i];
	}
}

// Use the internal array to determine the next page.
CAppWizStepDlg* CDialogChooser::Next(CAppWizStepDlg* pDlg)
{
	ASSERT(m_nTrack == 0 || m_nTrack == 1);
	ASSERT(0 <= m_nCurrDlg && m_nCurrDlg < nLast[m_nTrack]);
	ASSERT(pDlg == m_pDlgs[(pnTrack[m_nTrack])[m_nCurrDlg]]);

	// If the current page is the "project type" page, the AppWizard "track" may
	//  have changed.
	if (m_nCurrDlg == 1)
	{
		CString strTemp;
		m_nTrack = apwiztesaw.m_Dictionary.Lookup("PROJTYPE_DLG", strTemp) ? 1 : 0;
		SetNumberOfSteps(nLast[m_nTrack]);
	}

	m_nCurrDlg++;

	// If the new page is the "project type" page, don't display the max number
	//  of steps.
	if (m_nCurrDlg == 1)
		SetNumberOfSteps(-1);

	return m_pDlgs[(pnTrack[m_nTrack])[m_nCurrDlg]];
}

// Use the internal array to determine the previous page.
CAppWizStepDlg* CDialogChooser::Back(CAppWizStepDlg* pDlg)
{
	ASSERT(m_nTrack == 0 || m_nTrack == 1);
	ASSERT(1 <= m_nCurrDlg && m_nCurrDlg <= nLast[m_nTrack]);
	ASSERT(pDlg == m_pDlgs[(pnTrack[m_nTrack])[m_nCurrDlg]]);

	m_nCurrDlg--;

	// If the new page is the "project type" page, don't display the max number
	//  of steps.
	if (m_nCurrDlg == 1)
		SetNumberOfSteps(-1);

	return m_pDlgs[(pnTrack[m_nTrack])[m_nCurrDlg]];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <customaw.h>		// Custom AppWizard interface
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by apwiztes.rc
//
#define IDD_CUSTOM1                     129
#define IDC_ITERATION                   1294

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	again.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\cstm1dlg.h ===
// cstm1dlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCustom1Dlg dialog

class CCustom1Dlg : public CAppWizStepDlg
{
// Construction
public:
	CCustom1Dlg();
	virtual BOOL OnDismiss();

// Dialog Data
	//{{AFX_DATA(CCustom1Dlg)
	enum { IDD = IDD_CUSTOM1 };
	CEdit	m_test;
	int		m_Iteration;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCustom1Dlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCustom1Dlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\diffseg.cpp ===
void diff_seg_func(void)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Wizards\wizardsnap\custwiz\cstm1dlg.cpp ===
// cstm1dlg.cpp : implementation file
//

#include "stdafx.h"
#include "apwiztes.h"
#include "cstm1dlg.h"
#include "apwizaw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static iCount = 0 ;
/////////////////////////////////////////////////////////////////////////////
// CCustom1Dlg dialog


CCustom1Dlg::CCustom1Dlg()
	: CAppWizStepDlg(CCustom1Dlg::IDD)
{
	//{{AFX_DATA_INIT(CCustom1Dlg)
	m_Iteration = 0;
	//}}AFX_DATA_INIT
}


void CCustom1Dlg::DoDataExchange(CDataExchange* pDX)
{
	CAppWizStepDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCustom1Dlg)
	DDX_Control(pDX, IDC_ITERATION, m_test);
	DDX_Text(pDX, IDC_ITERATION, m_Iteration);
	//}}AFX_DATA_MAP
}

// This is called whenever the user presses Next, Back, or Finish with this step
//  present.  Do all validation & data exchange from the dialog in this function.
BOOL CCustom1Dlg::OnDismiss()
{

	if (!UpdateData(TRUE))
		return FALSE;
    
	// TODO: Set template variables based on the dialog's data.
	switch(m_Iteration)
	{
	 // Dialog app with options turned on, 
	 case 0:
	 {

    	apwiztesaw.m_Dictionary.RemoveKey("PROJTYPE_MDI") ;	
		apwiztesaw.m_Dictionary.RemoveKey("PROJTYPE_SDI") ;	

   		apwiztesaw.m_Dictionary.SetAt("PROJTYPE_DLG","1") ;
		apwiztesaw.m_Dictionary.SetAt("HELP","1") ;
		apwiztesaw.m_Dictionary.SetAt("3D","1") ;
		//		apwiztesaw.m_Dictionary.SetAt("",) ; WinSocket
		apwiztesaw.m_Dictionary.SetAt("ABOUT","1") ;
		apwiztesaw.m_Dictionary.SetAt("VERBOSE","1") ;
		apwiztesaw.m_Dictionary.SetAt("MFCDLL","1") ;
		m_Iteration++ ;
	}
	break;

	// Dialog app with options turned off
		 case 1:
	 {
   		apwiztesaw.m_Dictionary.SetAt("PROJTYPE_DLG","1") ;
		apwiztesaw.m_Dictionary.RemoveKey("HELP") ;
		apwiztesaw.m_Dictionary.RemoveKey("3D") ;
		//		apwiztesaw.m_Dictionary.SetAt("",) ; WinSocket
		apwiztesaw.m_Dictionary.RemoveKey("ABOUT") ;
		apwiztesaw.m_Dictionary.RemoveKey("VERBOSE") ;
		apwiztesaw.m_Dictionary.RemoveKey("MFCDLL") ;
		m_Iteration++ ;
	}
	break;

	// SDI app options
	case 2:
	{
		apwiztesaw.m_Dictionary.RemoveKey("PROJTYPE_DLG") ;	
   		apwiztesaw.m_Dictionary.SetAt("PROJTYPE_SDI","1") ;
		apwiztesaw.m_Dictionary.SetAt("DB","1") ; //Database
		//OLE options	
		apwiztesaw.m_Dictionary.SetAt("FULL_SERVER","1") ;
		apwiztesaw.m_Dictionary.SetAt("AUTOMATION","1") ;
		//App features 
		apwiztesaw.m_Dictionary.SetAt("TOOLBAR","1") ;
		apwiztesaw.m_Dictionary.SetAt("STATUSBAR","1") ;
		apwiztesaw.m_Dictionary.SetAt("PRINT","1") ;
		apwiztesaw.m_Dictionary.SetAt("HELP","1") ;
		apwiztesaw.m_Dictionary.SetAt("3D","1") ;
		apwiztesaw.m_Dictionary.SetAt("TOOLBAR","1") ;
		// WinSockets and MAPI support
		/*apwiztesaw.m_Dictionary.SetAt("WINSOCKETS","1") ;
		apwiztesaw.m_Dictionary.SetAt("MAPI","1") ; */
		//MRU list
		apwiztesaw.m_Dictionary.SetAt("HAS_MRU","1") ;
		apwiztesaw.m_Dictionary.SetAt("SIZE_MRU","0") ;


		apwiztesaw.m_Dictionary.RemoveKey("VERBOSE") ;
		apwiztesaw.m_Dictionary.RemoveKey("MFCDLL") ;
		m_Iteration++ ;
	}
	break;
	//SDI app with  most options turned off.
	case 3:
	{
		apwiztesaw.m_Dictionary.RemoveKey("PROJTYPE_DLG") ;	
   		apwiztesaw.m_Dictionary.SetAt("PROJTYPE_SDI","1") ;
		apwiztesaw.m_Dictionary.RemoveKey("DB") ; //Database
		//OLE options
		apwiztesaw.m_Dictionary.SetAt("CONTAINTER","1") ;
		apwiztesaw.m_Dictionary.SetAt("AUTOMATION","1") ;
		//App features 
		apwiztesaw.m_Dictionary.RemoveKey("TOOLBAR") ;
		apwiztesaw.m_Dictionary.RemoveKey("STATUSBAR") ;
		apwiztesaw.m_Dictionary.RemoveKey("PRINT") ;
		apwiztesaw.m_Dictionary.RemoveKey("HELP") ;
		apwiztesaw.m_Dictionary.RemoveKey("3D");
		// WinSockets and MAPI support
		/*apwiztesaw.m_Dictionary.RemoveKey("WINSOCKETS") ;
		apwiztesaw.m_Dictionary.RemoveKey("MAPI") ; */
		//MRU list
		apwiztesaw.m_Dictionary.RemoveKey("HAS_MRU") ;
		apwiztesaw.m_Dictionary.RemoveKey("SIZE_MRU");

		apwiztesaw.m_Dictionary.SetAt("VERBOSE","1") ;
		apwiztesaw.m_Dictionary.SetAt("MFCDLL","1") ;
		m_Iteration++ ;
	}
	break ;
 	case 4:
	{
	apwiztesaw.m_Dictionary.RemoveKey("PROJTYPE_DLG") ;	
	apwiztesaw.m_Dictionary.RemoveKey("PROJTYPE_SDI") ;
	apwiztesaw.m_Dictionary.SetAt("PROJTYPE_MDI","1") ;
	apwiztesaw.m_Dictionary.RemoveKey("DB") ; //Database

	//OLE options
	apwiztesaw.m_Dictionary.SetAt("MINI_SERVER","1") ;
	apwiztesaw.m_Dictionary.SetAt("AUTOMATION","1") ;
	//App features 
	apwiztesaw.m_Dictionary.RemoveKey("TOOLBAR") ;
	apwiztesaw.m_Dictionary.RemoveKey("STATUSBAR") ;
	apwiztesaw.m_Dictionary.RemoveKey("PRINT") ;
	apwiztesaw.m_Dictionary.RemoveKey("HELP") ;
	apwiztesaw.m_Dictionary.RemoveKey("3D");
	// WinSockets and MAPI support
	/*apwiztesaw.m_Dictionary.RemoveKey("WINSOCKETS") ;
	apwiztesaw.m_Dictionary.RemoveKey("MAPI") ; */
	//MRU list
	apwiztesaw.m_Dictionary.RemoveKey("HAS_MRU") ;
	apwiztesaw.m_Dictionary.RemoveKey("SIZE_MRU");
	apwiztesaw.m_Dictionary.SetAt("VERBOSE","1") ;
	apwiztesaw.m_Dictionary.SetAt("MFCDLL","1") ;
	m_Iteration++ ;
	}
  }
return TRUE;	// return FALSE if the dialog shouldn't be dismissed
}


BEGIN_MESSAGE_MAP(CCustom1Dlg, CAppWizStepDlg)
	//{{AFX_MSG_MAP(CCustom1Dlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCustom1Dlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\lineonly.h ===
void line_only_dll_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\nopdb.cpp ===
__declspec(dllexport) void no_pdb_dll_func(void)
	{
	__asm
		{
		int 3
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\nodebug.cpp ===
int empty_func(void);


void no_debug_func(void)
	{
	empty_func();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\nopdb.h ===
void no_pdb_dll_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\test.h ===
void header_func(void){}
void inline inline_func(void){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\wnd.cpp ===
#include <windows.h>

LPARAM CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	
	{ 				// first line of WinMain()
	MSG msg;
	HWND hwnd;

	if(!hinstPrev)

		{
		WNDCLASS wndclass;
	    wndclass.style = 0;
	    wndclass.lpfnWndProc = WndProc;
	    wndclass.cbClsExtra = 0;
	    wndclass.cbWndExtra = 0;
	    wndclass.hInstance = hinst;
	    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	    wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	    wndclass.lpszMenuName = NULL;
	    wndclass.lpszClassName = "Wnd";

	    if(!RegisterClass(&wndclass))
	    	return 0;
		}

	hwnd = CreateWindow("Wnd", "Wnd", WS_OVERLAPPEDWINDOW | 
						WS_VISIBLE, CW_USEDEFAULT, CW_USEDEFAULT, 
						CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hinst, NULL);

	while(GetMessage(&msg, NULL, 0, 0))
		{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
		}

	return msg.wParam;
	}


LPARAM CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
	
	{
	switch(msg)
		{	
		case WM_PAINT:
			{
			PAINTSTRUCT ps;
			BeginPaint(hwnd, &ps);
			EndPaint(hwnd, &ps);
			return 0L;
			}
		case WM_DESTROY:
			{
			PostQuitMessage(0);
			while(1);
			break;
			}
		}

	return DefWindowProc(hwnd, msg, wParam, lParam);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\dbgtestbase.cpp ===
///////////////////////////////////////////////////////////////////////////////
// DbgTestBase.cpp
//
//	Created by:	MichMa
//	Date:		3/30/98
//
//	Description: Definition of base class for all debugger tests.

#include "stdafx.h"
#include "DbgTestBase.h"
#include "guitarg.h"

// emmang@xbox utility functions
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetHkeyFromStr
//
// utility function to map the prefix of a string (either "hklm"
// or "hkcu") to an actual HKEY value
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HKEY GetHkeyFromStr(CString cstr)
{
   cstr.MakeLower();
   if (cstr.Left(4) == "hklm")
	   return HKEY_LOCAL_MACHINE;
   else if (cstr.Left(4) == "hkcr")
	   return HKEY_CLASSES_ROOT;
   else
	   return HKEY_CURRENT_USER;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetStrFromRegistry
//
// utility function; gets a string value from the registry; if the key
// is not present, return the supplied default instead
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetStrFromRegistry(CString cstrSubKey, CString cstrDefault)
{
	UCHAR szBuf[2048];
	LONG retval;
	ULONG lBufSize = 4096;
	CString cstrTemp = cstrSubKey.Mid(5);

	HKEY hKey;
	cstrTemp = cstrSubKey.Left(cstrSubKey.ReverseFind('\\'));
	cstrTemp = cstrTemp.Mid(5);
	retval = RegOpenKey(GetHkeyFromStr(cstrSubKey), cstrTemp, &hKey);
	if (retval != ERROR_SUCCESS)
		return cstrDefault;

	cstrTemp = cstrSubKey.Mid(cstrSubKey.ReverseFind('\\')+1);
	retval = RegQueryValueEx(hKey, cstrTemp, NULL, NULL, szBuf, &lBufSize);
	if ((retval != ERROR_SUCCESS) || !lBufSize)
	{
		RegCloseKey(hKey);
		return cstrDefault;
	}
	return szBuf;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetProgramFilesDir
//
// utility function, returns the Program Files directory
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetProgramFilesDir()
{
	return GetStrFromRegistry(
		"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ProgramFilesDir",
		"C:\\Program Files");
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetVisualCDir
//
// utility function, returns VC directory
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetVisualCDir()
{
	return GetStrFromRegistry(
		"HKLM\\Software\\Microsoft\\VisualStudio\\6.0\\Products\\Microsoft Visual C++\\ProductDir",
		GetProgramFilesDir() + "\\Microsoft Visual Studio\\VC98");
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetVisualStudioCommonDir
//
// utility function, returns Visual Studio's common directory
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetVisualStudioCommonDir()
{
	return GetStrFromRegistry(
		"HKLM\\Software\\Microsoft\\VisualStudio\\6.0\\Setup\\VsCommonDir",
		GetProgramFilesDir() + "\\Microsoft Visual Studio\\Common");
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetXboxSdkDir
//
// utility function, returns the Xbox SDK's base directory
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetXboxSdkDir()
{
	TCHAR szSDKDir[1024];
	szSDKDir[0] = 0;
	GetEnvironmentVariable("XDK", szSDKDir, 1024);
	return CString(szSDKDir);
}


IMPLEMENT_DYNAMIC( CSubTestException, CException );

IMPLEMENT_DYNAMIC(CDbgTestBase, CTest)

#define GetSubSuite() ((CIDESubSuite*)m_pSubSuite)

CDbgTestBase::CDbgTestBase(/*int metricID,*/ CIDESubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: CTest(/*metricID,*/ pSubSuite, szName, nExpectedCompares, szListFilename)
{
}

#define NOSPACES

BOOL CDbgTestBase::SetXboxProject(LPCSTR projName, PROJECT_FLAGS flags /* fDefault */, LPCSTR cfgName /*NULL*/)
{
	const char* const THIS_FUNCTION = "SetXboxProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if (iName < 0)
	{
		m_strProjectDir = FullPath("src");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("src") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}

#ifdef NOSPACES
	m_strProjectName.Replace(" ", "_");
#endif

	// copy stuff to new directory and do work there
	CreateDirectory(TMP_PROJ_DIR, NULL);
	CreateDirectory(TMP_PROJ_DIR "\\" + m_strProjectName, NULL);
	// just in case dir was already there, clean it up
	KillFiles(TMP_PROJ_DIR "\\" + m_strProjectName, "*.*");
	CopyProjectSources(m_strProjectDir + "\\", TMP_PROJ_DIR "\\" + m_strProjectName + "\\");
	m_strProjectDir = TMP_PROJ_DIR "\\" + m_strProjectName;

	CIDESubSuite* pSubSuite=GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only
	// build the path, lib, and include environment strings.

	CString cstrPathEnv, cstrLibEnv, cstrIncludeEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingPathEnv, cstrPathEnv);
	cstrPathEnv = settingPathEnv + CString("=") +
		GetXboxSdkDir() + "\\Xbox\\Bin\\VC7;" +
		GetXboxSdkDir() + "\\Xbox\\Bin;" +
		GetVisualStudioCommonDir() + "\\MsDev98\\Bin;" +
		GetVisualCDir() + "\\Bin;" +
		GetVisualStudioCommonDir() + "\\Tools;" +
		GetVisualStudioCommonDir() + "\\Tools\\WINNT;" +
		cstrPathEnv;
	cstrLibEnv = "LIB=" + GetXboxSdkDir() + "\\Xbox\\Lib";
	cstrIncludeEnv = "INCLUDE=" + GetXboxSdkDir() + "\\Xbox\\Include";

	// get windows and system dir and append to path environment string.
	CString cstrWindowsDir, cstrSystemDir;
	// each dir is prepended with a semi-colon as a separator. 
	char chDirBuf[MAX_PATH] = ";";
 	GetWindowsDirectory(&chDirBuf[1], MAX_PATH);	// &chDirBuf[0] = ';'
	cstrWindowsDir = chDirBuf;
	GetSystemDirectory(&chDirBuf[1], MAX_PATH);		// &chDirBuf[0] = ';'
	cstrSystemDir = chDirBuf;
	cstrPathEnv += cstrWindowsDir + cstrSystemDir;

	// nmake's environment block.
	char chNmakeEnv[1024];
	// pointer to navigate through block.
	char *pchNmakeEnv = chNmakeEnv;

	// put the path, lib, and include environment strings into the block.
	// each string is terminated by null.
	strcpy(pchNmakeEnv, cstrPathEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrLibEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrIncludeEnv);
	// block is terminated by additional null.
	pchNmakeEnv[strlen(pchNmakeEnv) + 1] = 0;
 
	// to find nmake.exe in the toolset path environment, 
	// we'll use cstrPathFrag to search	for and extract directories
	// from cstrPathEnv	(minus first 5 characters which are "PATH=").
	CString cstrPathFrag = cstrPathEnv.Mid(5);
	// stores dir extracted from cstrPathFrag.
	CString cstrDir;
	// stores index of next semi-colon (dir separator) in cstrPathEnv.
	int indexSemi;
	// handle to nmake.exe returned by FindFirstFile().
	HANDLE hNmake;
	// FindFirstFile param.
	WIN32_FIND_DATA fdFindData;

	while(1)
		
		{
		// find the next semi-colon which terminates the next dir to search.
		indexSemi = cstrPathFrag.Find(';');

		// if a semi-colon was found, extract the dir it terminates. otherwise
		// we are at the final dir in the path environment. 
		if(indexSemi != -1)
			cstrDir = cstrPathFrag.Left(indexSemi);
		else
			cstrDir = cstrPathFrag;
			
		// only want to search dirs at least 3 chars long. for example:
		// path  = C:\;
		// index = 0123
		if(cstrDir.GetLength() >= 3)
			hNmake = FindFirstFile(cstrDir + "\\nmake.exe", &fdFindData);
  		
		// stop searching if nmake was found in cstrPathFrag.
		if(hNmake != INVALID_HANDLE_VALUE)
			break;

		// if no semi-colon was found or it was the last char in the path, 
		// then we just searched the final dir in the environment string, 
		// but still haven't found nmake. 
	 	if((indexSemi == -1) || (cstrPathFrag.GetLength() == (indexSemi + 1)))
			{
			m_pLog->RecordInfo("ERROR in %s: could not find nmake.exe in path environment "
							   "specified by CAFE.", THIS_FUNCTION);
			return FALSE;
			}
		else
			// advance to the start of the next dir after the semi-colon.
			cstrPathFrag = cstrPathFrag.Mid(indexSemi + 1);
		}


	// determine the configuration switch that we need to pass to nmake.
	// also set platform member value for easy access by tests.
	if(cfgName==NULL)
		{
            cfgName = "xbox";
            m_platform = PLATFORM_XBOX;
		}

	// project name and configuration switch we will pass to nmake.
	// we enclose the project name in quotes to support names with spaces.
	CString cstrProjAndConfig = (CString)"\"" + m_strProjectName + ".mak\" CFG=" + cfgName;
	if( UIWB.GetPcodeSwitch() )
		cstrProjAndConfig += " PCODE=yes";
	// CreateProcess() params.
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;
	// fully qualified nmake.exe cmd line (cstrDir is directory we found nmake in earlier).
	char chNmakeCmdLine[MAX_PATH];
	strcpy(chNmakeCmdLine, cstrDir + "\\nmake.exe /a /f " + cstrProjAndConfig);

	// before spawning nmake make sure Debugger is not running, so vc50.pdb is released
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// Allocate console to be able to see how the project is built.  If we don't allocate it the window close
	// immediately after build process has finished. *dklem
	WaitStepInstructions("Allocating nmake console");
	AllocConsole();
	SetConsoleTitle(chNmakeCmdLine);

	// spawn nmake in the project dir.
	BOOL bRet = CreateProcess(NULL, chNmakeCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, chNmakeEnv,
							  m_strProjectDir, &siStartInfo, &piProcInfo);
	
	// verify that nmake was successfully spawned.						  
	if(!bRet)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe found but could not be spawned.", THIS_FUNCTION);
		return FALSE;
		}

	// nmake's exit code returned by GetExitCodeProcess().
	DWORD dwNmakeExitCode;

	// wait up to 60 minutes for nmake to terminate.
	for(int i = 0; i < 3600; i++)
		
		{
		Sleep(1000);
		// get nmake's exit code (if it has finished).
		GetExitCodeProcess(piProcInfo.hProcess, &dwNmakeExitCode);
		
		// keep sleeping if nmake is still running.
		if(dwNmakeExitCode != STILL_ACTIVE)
			break;
		}

	// Say good bye to the console
	WaitStepInstructions("Destroying nmake console");
	FreeConsole();

	// verify that nmake finished within the allotted time.
	if(i == 3600)
		{
		m_pLog->RecordInfo("ERROR in %s: after 60 minutes nmake is still running.", THIS_FUNCTION);
		return FALSE;
		}

	// verify that nmake was successful in building the executable.
	if(dwNmakeExitCode != 0)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe returned error code %d.", THIS_FUNCTION, dwNmakeExitCode);
		return FALSE;
		}

	// wait until nmake's window has gone away.
	if(!MST.WFndWndWait(chNmakeCmdLine, FW_NOEXIST, 5))
		{
		m_pLog->RecordInfo("ERROR in %s: after 5 seconds nmake's window still exists.", THIS_FUNCTION);
		return FALSE;
		}

	// stop here if we only want to build.
	if(flags & fBuildOnly)
		return TRUE;

	// project executable
	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + ".xbe";

	// verify that file exists
	FILE *f = fopen(m_strProjectDir + "\\" + cstrProjectExe, "r");
	if (!f)
	{
		m_pLog->RecordInfo("ERROR in %s: Target file not built: \"%s\".", THIS_FUNCTION, 
				m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
	}
	fclose(f);

	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(prj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
	{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
				m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
	}

	// set up connection
	if (!XboxSetTarget(REMOTE_XBOX_IP))
	{
		m_pLog->RecordInfo("ERROR in %s: could not set target machine to \"%s\".", THIS_FUNCTION, 
				REMOTE_XBOX_IP);
		return FALSE;
	}
	if (!(XboxCopyToTarget(m_strProjectDir + "\\" + cstrProjectExe)))
	{
		m_pLog->RecordInfo("ERROR in %s: could not copy xbe to target machine \"%s\".", THIS_FUNCTION, 
				REMOTE_XBOX_IP);
		return FALSE;
	}
	if (prj.SetRemotePath(REMOTE_XBOX_FILE) != ERROR_SUCCESS)
	{
		m_pLog->RecordInfo("ERROR in %s: could not set remote path to \"%s\".", THIS_FUNCTION, 
				REMOTE_XBOX_FILE);
		return FALSE;
	}
	prj.SetLocateOtherDLLs(TOGGLE_OFF);
		
	return TRUE;
}


BOOL CDbgTestBase::CreateXboxProjectFromSource(LPCSTR strProjBase, LPCSTR strSrcDir, LPCSTR strSrcFile, LPCSTR strSrcFile2)
{
	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjectName = "eXg" + CString(strProjBase) + " xbe";
	else
		m_strProjectName = CString(strProjBase) + " xbe";

#ifdef NOSPACES
	m_strProjectName.Replace(" ", "_");
#endif

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + strSrcDir;
	// the location of the xbe project, and the localized source(s), that we will use for this test.
	m_strProjectDir = CString(TMP_PROJ_DIR) + "\\" + m_strProjectName;

	CreateDirectory(TMP_PROJ_DIR, NULL);

	// clean-up the exe project from the last run.
	KillFiles(m_strProjectDir + "\\Debug\\", "*.*");
	KillFiles(m_strProjectDir + "\\Release\\", "*.*");
	RemoveDirectory(m_strProjectDir + "\\Debug");
	RemoveDirectory(m_strProjectDir + "\\Release");
	KillFiles(m_strProjectDir + "\\", "*.*");
	RemoveDirectory(m_strProjectDir);

	// set the options for the exe project we are building for this test.
	CXboxGameOptions *pXboxGameOpt = new(CXboxGameOptions);
	pXboxGameOpt->m_strLocation = TMP_PROJ_DIR;
	pXboxGameOpt->m_strName = m_strProjectName;
	
	// create the exe project.
	EXPECT_SUCCESS(prj.New(pXboxGameOpt));
	// create a new localized exe source file in the project dir from the unlocalized exe source file.
	CopyFile(m_strSrcDir + "\\" + strSrcFile, m_strProjectDir + "\\" + m_strProjectName + ".cpp", FALSE);
	// make it writable so it can be cleaned up later.
	SetFileAttributes(m_strProjectDir + "\\" + m_strProjectName + ".cpp", FILE_ATTRIBUTE_NORMAL);
	// add the source to the project.

	if (strSrcFile2)
	{
		CopyFile(m_strSrcDir + "\\" + strSrcFile2, m_strProjectDir + "\\" + strSrcFile2, FALSE);
		SetFileAttributes(m_strProjectDir + "\\" + strSrcFile2, FILE_ATTRIBUTE_NORMAL);
	}

	EXPECT_SUCCESS(prj.AddFiles(m_strProjectName + ".cpp"));
	if (ReturnCode)
	{
		LOG->Comment("prj.AddFiles(\"%s\") failed", m_strProjectName + ".cpp");
		return FALSE;
	}
	
	if (strSrcFile2)
	{
		EXPECT_SUCCESS(prj.AddFiles(strSrcFile2));
		if (ReturnCode)
		{
			LOG->Comment("prj.AddFiles(\"%s\") failed", strSrcFile2);
			return FALSE;
		}
	}

	// set the remote path first, so autocopy won't pop up a query
	EXPECT_SUCCESS(prj.SetRemotePath(REMOTE_XBOX_FILE));
	{
		if (ReturnCode)
			return FALSE;
	}

	// build the project.
	EXPECT_SUCCESS(prj.Build());
	
	if (!XboxSetTarget(REMOTE_XBOX_IP))
		return FALSE;

	// no longer needed due to autocopy
	// if (!XboxCopyToTarget())
	//	return FALSE;

	prj.SetLocateOtherDLLs(TOGGLE_OFF);

	return TRUE;
}


BOOL CDbgTestBase::SetProject(LPCSTR projName, PROJECT_TYPE projType /* PROJECT_EXE */, PROJECT_FLAGS flags /* fDefault */, LPCSTR cfgName /*NULL*/)
{
	if (projType = PROJECT_XBE)
		return SetXboxProject(projName, flags, cfgName);

	const char* const THIS_FUNCTION = "SetProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if( iName < 0 )
	{
		m_strProjectDir = FullPath("src");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("src") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}

	KillFiles(m_strProjectDir, "*.opt");
	KillFiles(m_strProjectDir, "*.exe");
	KillFiles(m_strProjectDir, "*.obj");
	KillFiles(m_strProjectDir, "*.ilk");
	KillFiles(m_strProjectDir, "*.ncb");
	KillFiles(m_strProjectDir, "*.plg");

	CIDESubSuite* pSubSuite=GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only
	// build the path, lib, and include environment strings.

	CString cstrPathEnv, cstrLibEnv, cstrIncludeEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingPathEnv, cstrPathEnv);
	cstrPathEnv = settingPathEnv + CString("=") + cstrPathEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingLibEnv, cstrLibEnv);
	cstrLibEnv = settingLibEnv + CString("=") + cstrLibEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingIncludeEnv, cstrIncludeEnv);
	cstrIncludeEnv = settingIncludeEnv + CString("=") + cstrIncludeEnv;

	// get windows and system dir and append to path environment string.
	CString cstrWindowsDir, cstrSystemDir;
	// each dir is prepended with a semi-colon as a separator. 
	char chDirBuf[MAX_PATH] = ";";
 	GetWindowsDirectory(&chDirBuf[1], MAX_PATH);	// &chDirBuf[0] = ';'
	cstrWindowsDir = chDirBuf;
	GetSystemDirectory(&chDirBuf[1], MAX_PATH);		// &chDirBuf[0] = ';'
	cstrSystemDir = chDirBuf;
	cstrPathEnv += cstrWindowsDir + cstrSystemDir;

	// nmake's environment block.
	char chNmakeEnv[1024];
	// pointer to navigate through block.
	char *pchNmakeEnv = chNmakeEnv;

	// put the path, lib, and include environment strings into the block.
	// each string is terminated by null.
	strcpy(pchNmakeEnv, cstrPathEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrLibEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrIncludeEnv);
	// block is terminated by additional null.
	pchNmakeEnv[strlen(pchNmakeEnv) + 1] = 0;
 
	// to find nmake.exe in the toolset path environment, 
	// we'll use cstrPathFrag to search	for and extract directories
	// from cstrPathEnv	(minus first 5 characters which are "PATH=").
	CString cstrPathFrag = cstrPathEnv.Mid(5);
	// stores dir extracted from cstrPathFrag.
	CString cstrDir;
	// stores index of next semi-colon (dir separator) in cstrPathEnv.
	int indexSemi;
	// handle to nmake.exe returned by FindFirstFile().
	HANDLE hNmake;
	// FindFirstFile param.
	WIN32_FIND_DATA fdFindData;

	while(1)
		
		{
		// find the next semi-colon which terminates the next dir to search.
		indexSemi = cstrPathFrag.Find(';');

		// if a semi-colon was found, extract the dir it terminates. otherwise
		// we are at the final dir in the path environment. 
		if(indexSemi != -1)
			cstrDir = cstrPathFrag.Left(indexSemi);
		else
			cstrDir = cstrPathFrag;
			
		// only want to search dirs at least 3 chars long. for example:
		// path  = C:\;
		// index = 0123
		if(cstrDir.GetLength() >= 3)
			hNmake = FindFirstFile(cstrDir + "\\nmake.exe", &fdFindData);
  		
		// stop searching if nmake was found in cstrPathFrag.
		if(hNmake != INVALID_HANDLE_VALUE)
			break;

		// if no semi-colon was found or it was the last char in the path, 
		// then we just searched the final dir in the environment string, 
		// but still haven't found nmake. 
	 	if((indexSemi == -1) || (cstrPathFrag.GetLength() == (indexSemi + 1)))
			{
			m_pLog->RecordInfo("ERROR in %s: could not find nmake.exe in path environment "
							   "specified by CAFE.", THIS_FUNCTION);
			return FALSE;
			}
		else
			// advance to the start of the next dir after the semi-colon.
			cstrPathFrag = cstrPathFrag.Mid(indexSemi + 1);
		}


	// determine the configuration switch that we need to pass to nmake.
	// also set platform member value for easy access by tests.
	if(cfgName==NULL)
	switch(GetUserTargetPlatforms())
		{
        case PLATFORM_WIN32_ALPHA:
            cfgName = "alpha";
            m_platform = PLATFORM_WIN32_ALPHA;
            break;
		case PLATFORM_WIN32_X86:
			cfgName = "x86";
			m_platform = PLATFORM_WIN32_X86;
			break;
		}

	// project name and configuration switch we will pass to nmake.
	// we enclose the project name in quotes to support names with spaces.
	CString cstrProjAndConfig = (CString)"\"" + m_strProjectName + ".mak\" CFG=" + cfgName;
	if( UIWB.GetPcodeSwitch() )
		cstrProjAndConfig += " PCODE=yes";
	// CreateProcess() params.
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;
	// fully qualified nmake.exe cmd line (cstrDir is directory we found nmake in earlier).
	char chNmakeCmdLine[MAX_PATH];
	strcpy(chNmakeCmdLine, cstrDir + "\\nmake.exe /a /f " + cstrProjAndConfig);

	// before spawning nmake make sure Debugger is not running, so vc50.pdb is released
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// Allocate console to be able to see how the project is built.  If we don't allocate it the window close
	// immediately after build process has finished. *dklem
	WaitStepInstructions("Allocating nmake console");
	AllocConsole();
	SetConsoleTitle(chNmakeCmdLine);

	// spawn nmake in the project dir.
	BOOL bRet = CreateProcess(NULL, chNmakeCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, chNmakeEnv,
							  m_strProjectDir, &siStartInfo, &piProcInfo);
	
	// verify that nmake was successfully spawned.						  
	if(!bRet)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe found but could not be spawned.", THIS_FUNCTION);
		return FALSE;
		}

	// nmake's exit code returned by GetExitCodeProcess().
	DWORD dwNmakeExitCode;

	// wait up to 60 minutes for nmake to terminate.
	for(int i = 0; i < 3600; i++)
		
		{
		Sleep(1000);
		// get nmake's exit code (if it has finished).
		GetExitCodeProcess(piProcInfo.hProcess, &dwNmakeExitCode);
		
		// keep sleeping if nmake is still running.
		if(dwNmakeExitCode != STILL_ACTIVE)
			break;
		}

	// Say good bye to the console
	WaitStepInstructions("Destroying nmake console");
	FreeConsole();

	// verify that nmake finished within the allotted time.
	if(i == 3600)
		{
		m_pLog->RecordInfo("ERROR in %s: after 60 minutes nmake is still running.", THIS_FUNCTION);
		return FALSE;
		}

	// verify that nmake was successful in building the executable.
	if(dwNmakeExitCode != 0)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe returned error code %d.", THIS_FUNCTION, dwNmakeExitCode);
		return FALSE;
		}

	// wait until nmake's window has gone away.
	if(!MST.WFndWndWait(chNmakeCmdLine, FW_NOEXIST, 5))
		{
		m_pLog->RecordInfo("ERROR in %s: after 5 seconds nmake's window still exists.", THIS_FUNCTION);
		return FALSE;
		}

	// stop here if we only want to build.
	if(flags & fBuildOnly)
		return TRUE;

	// project exe has same base as makefile (i.e. xxx.mak/xxx.exe/xxx.dll)
	// we want to strip out any prepended path and just use the file name
	// because we use this name to set the remote path, and the host
	// path will usually not match the remote path.
	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + 
							 ((projType == PROJECT_EXE) ? ".exe" : ".dll");


	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(prj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
							m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
		}

	// allows us to access ide's connection settings via pconnec.
	COConnection *pconnec = pSubSuite->GetIDE()->GetConnectionInfo();
	
/*	// TODO(michma - 8/12/98): connection stuff has been moved to project settings.
re-enable when support layer has been updated.

	// set the connection as specified by the user.
	if(pconnec->SetAll() != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not set connection settings.", THIS_FUNCTION);
		return FALSE;
		}
*/	
	// if indicated, set the remote path and copy the executable to the remote machine.
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		
		{
		if(prj.SetRemotePath(cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not set remote path using \"%s\".", 
							   THIS_FUNCTION, cstrProjectExe);
			return FALSE;
			}
		
		if(prj.UpdateRemoteFile(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not update remote file using \"%s\".", 
							   THIS_FUNCTION, m_strProjectDir + "\\" + cstrProjectExe);
			return FALSE;
			}
		}
	
	return TRUE;
	}


/*
** start debugging and do some initialization.  
*/

BOOL CDbgTestBase::StartDebugging(void)
{
	BOOL bSuccess; 
	COSource src;	

	bps.ClearAllBreakpoints();		// Clear All Breakpoints Just in case.
	dbg.StepOver(1);				// Start debugging session with initial trace.
	src.AttachActiveEditor();		// WinslowF
	bSuccess = dbg.AtSymbol("WinMain");

	// attach to the editor window the debugger opened
	bSuccess &= src.AttachActiveEditor();

	mem.SetMemoryFormat(MEM_FORMAT_BYTE); 
	dbg.SetSteppingMode(SRC); 		
	return bSuccess;
}


BOOL CDbgTestBase::StopDbgCloseProject(void)
{
	if (dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();
	UIWB.CloseAllWindows();
	prj.Close();						

	return TRUE;
}


BOOL CDbgTestBase::VerifyProjectRan(int exitcode /* = 0 */)
{

	// REVIEW: use CODebug::VerifyTermination when it is available.
	// OpenOutputWindow
	UIOutput uow = UIDebug::ShowDockWindow(IDW_OUTPUT_WIN, TRUE);
//	EXPECT( uow.IsActive() );
	// Select the last line, write it to clipboard and look for "exit code 0"
	MST.DoKeys( "^{end}" );
	MST.DoKeys( "{up}" );

	char buffer[10];
	CString	szexcode = "exited with code ";			
	szexcode += itoa(exitcode, buffer, 10 ); // WinslowF - for OEM compatibility now we can specify the exit code to be verified

	if ( UIWB.VerifySubstringAtLine( szexcode ))
	{
		return (TRUE);
	}
	else
	{
		return (FALSE);
	}		
	
	return TRUE;
}


BOOL CDbgTestBase::StepInUntilFrameAdded( CString addframe )
{
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line
	if(framelist0.CreateFromText( stk.GetAllFunctions() ) == FALSE)
	{
		m_pLog->RecordInfo( "StepInUntilFrameAdded - error retrieving stack frames");
		return FALSE;
	}
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		if(current.CreateFromText( stk.GetAllFunctions() ) == FALSE)
		{
			m_pLog->RecordInfo( "StepInUntilFrameAdded - error retrieving stack frames");
			return FALSE;
		}

		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ){
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() + 1 ) {
			// Test new top frame
			bResult = Frame( current[0] ).Test( addframe );

			// Only check function name or image name for 2nd frame since the line number
			// may change.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame+1];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[iFrame+1], (LPCTSTR)framelist0[iFrame] );
				}
			}
			break;	// Get out of loop

		}
		else {
			// Unexpected number of frames
			m_pLog->RecordInfo( "StepInUntilFrameAdded - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}

BOOL CDbgTestBase::StepInUntilFrameRemoved() {
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line
	if(framelist0.CreateFromText( stk.GetAllFunctions() ) == FALSE)
	{
		m_pLog->RecordInfo( "StepInUntilFrameRemoved - error retrieving stack frames");
		return FALSE;
	}
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		if(current.CreateFromText( stk.GetAllFunctions() ) == FALSE)
		{
			m_pLog->RecordInfo( "StepInUntilFrameRemoved - error retrieving stack frames");
			return FALSE;
		}

		//
		// REVIEW: This can be shared with StepInUntilAdded
		//
		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				CString str1;
				if( topframe.GetParameters( str1 ) ) {
					str0 += "(" + str1 + ")";
				}
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameRemoved - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch in frame %d, '%s' != '%s'",
						iFrame, (LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() - 1 ) {
			// The remaining frames should be identical
			for( int iFrame = 0; bResult && iFrame < current.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame+1] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch in frame %d, '%s' != '%s'",
						iFrame, (LPCTSTR)current[iFrame], (LPCTSTR)framelist0[iFrame+1] );
				}
			}
			break;	// Get out of loop
		}
		else {
			// Unexpected number of frames
			m_pLog->RecordInfo( "StepInUntilFrameRemoved - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}


int ReturnCode =0;
bp  * ReturnBP =0;

void CDbgTestBase::LogResult(int line, int result,LPCSTR szoperation, int code /* 0 */, LPCSTR szComment /* "" */)

	{
	CString szOpCom = (CString)szoperation + "  " + szComment;
	if(result == PASSED)
		m_pLog->RecordSuccess("%s", szOpCom);
	else
		{
		CString szextra;
		char chbuf[24];
		szextra = szextra + "Error Code = " + itoa(code, chbuf, 10);
		m_pLog->RecordFailure("LINE %d %s", line, szextra + szOpCom);
		}
	}


//
//	Returns the current directory of the first time this function was called.
//
LPCSTR CDbgTestBase::HomeDir()
{
	static CString szCurDir;

	if( szCurDir.IsEmpty() )
	{
		char* psz = szCurDir.GetBufferSetLength(_MAX_DIR);

		GetCurrentDirectory(_MAX_DIR - 1, psz);
		szCurDir.ReleaseBuffer(-1);
		if( szCurDir.Right(1) != '\\' )
			szCurDir += "\\";
	}
 	return szCurDir;
}

//
//	Returns the fully qualified path with szAddPath appended to the breadth dir.	
//
LPCSTR CDbgTestBase::FullPath( LPCSTR szAddPath )
{
	static CString szFilespec;

	szFilespec = HomeDir();
	szFilespec += szAddPath;

	return szFilespec;
}


void CDbgTestBase::FillExprInfo(EXPR_INFO &expr_info, 
								 int state, LPCSTR type, LPCSTR name, LPCSTR value)

	{
	expr_info.state = state;
	expr_info.type = type;
	expr_info.name = name;
	expr_info.value = value;
	}


BOOL CDbgTestBase::ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
							   int total_rows /* 1 */)
	
	{
	for(int i = 0; i < total_rows; i++)

		{
		if(expr_info_actual[i].state != expr_info_expected[i].state)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): state is %d instead of %d", 
								  expr_info_actual[i].state, expr_info_expected[i].state);

			return FALSE;
			}

		if(expr_info_actual[i].type != expr_info_expected[i].type)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): type is %s instead of %s", 
								  expr_info_actual[i].type, expr_info_expected[i].type);

			return FALSE;
			}

		if(expr_info_actual[i].name != expr_info_expected[i].name)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): name is %s instead of %s", 
								  expr_info_actual[i].name, expr_info_expected[i].name);

			return FALSE;
			}

		if(expr_info_expected[i].value.Mid(0, 7) != "UNKNOWN") 

			{
			BOOL value_tests_passed;

			if(expr_info_expected[i].value.Mid(0, 7) == "ADDRESS")
				
				{
				value_tests_passed = ValueIsAddress(expr_info_actual[i].value);

				// is extra data besides address expected? (ex. peek at string)
				if(expr_info_expected[i].value != "ADDRESS")
				
					{
					// user must supply extra data to avoid CString assert.
					EXPECT(expr_info_expected[i].value.GetLength() > 8);

					// make sure actual string is long enough so we avoid CString assert.
					if(expr_info_actual[i].value.GetLength() > 10)
					{
						// verify extra data is correct.
						if(expr_info_actual[i].value.Mid(10) ==  (" " + expr_info_expected[i].value.Mid(8)))
							value_tests_passed=TRUE;	
					}
					else
						// actual string wasn't long enough to contain extra data.
						value_tests_passed = FALSE;
					}
				}	 
	
			else	
				value_tests_passed = expr_info_actual[i].value == expr_info_expected[i].value;

			if(!value_tests_passed)
				
				{
				m_pLog->RecordFailure("ERROR in ExprInfoIs(): value is %s instead of %s", 
									  expr_info_actual[i].value, expr_info_expected[i].value);

				return FALSE;
				}
			}
		}

	return TRUE;
	}


BOOL CDbgTestBase::ValueIsAddress(CString str)
	{
	return (str.Mid(0, 2) == "0x") && 
		   (str.Mid(2).SpanIncluding("0123456789abcdef").GetLength() == 8);
	}


void CDbgTestBase::VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber)
{
	uivar.Activate();
	EXPECT_TRUE(uivar.SetPane(PANE_LOCALS) == ERROR_SUCCESS);

	EXPR_INFO expr_info;
	uivar.GetAllFields(&expr_info, lineNumber, 1);
	CString csType = expr_info.type;
	CString csName = expr_info.name;
	CString csValue = expr_info.value;


	WriteLog( (csType == strType && csName == strName && 
		csValue.Find(strValue) >= 0) ? PASSED : FAILED,
		"Current Locals line: \"%s %s %s \" Expectation: \"%s %s %s \"", 
		(LPCSTR)csType, (LPCSTR)csName, (LPCSTR)csValue, 
		(LPCSTR)strType, (LPCSTR)strName, (LPCSTR)strValue );
}

BOOL CDbgTestBase::LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber)
{
	uivar.Activate();
	EXPECT_TRUE(uivar.SetPane(PANE_LOCALS) == ERROR_SUCCESS);
	BOOL ret = FALSE;

	EXPR_INFO expr_info;
	if(uivar.GetAllFields(&expr_info, lineNumber, 1)!=ERROR_SUCCESS)
		return FALSE;
	if(strcmp(strType, expr_info.type)==0 &&
	   strcmp(strName, expr_info.name)==0 &&
	   strstr(strValue,expr_info.value)!=NULL)
		ret = TRUE;

	return ret;
}


BOOL CDbgTestBase::PrepareProject(LPCSTR projName)
{
	const char* const THIS_FUNCTION = "PrepareProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if( iName < 0 )
	{
		m_strProjectDir = FullPath("apps");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("apps") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}


	// project exe has same base as makefile (i.e. xxx.mak/xxx.exe/xxx.dll)
	// we want to strip out any prepended path and just use the file name
	// because we use this name to set the remote path, and the host
	// path will usually not match the remote path.
/*	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + 
							 ((projType == PROJECT_EXE) ? ".exe" : ".dll");
*/
	CString cstrProjectExe = m_strProjectName;

	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(prj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
							m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
		}

	CIDESubSuite* pSubSuite=GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only

	// allows us to access ide's connection settings via pconnec.
	COConnection *pconnec = pSubSuite->GetIDE()->GetConnectionInfo();
//	COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();

	// set the connection as specified by the user.
	if(pconnec->SetAll() != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not set connection settings.", THIS_FUNCTION);
		return FALSE;
		}
	
	// if indicated, set the remote path and copy the executable to the remote machine.
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		
		{
		if(prj.SetRemotePath(cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not set remote path using \"%s\".", 
							   THIS_FUNCTION, cstrProjectExe);
			return FALSE;
			}
		
		if(prj.UpdateRemoteFile(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not update remote file using \"%s\".", 
							   THIS_FUNCTION, m_strProjectDir + "\\" + cstrProjectExe);
			return FALSE;
			}
		}
	
	return TRUE;
}


void CDbgTestBase::LogTestHeader(LPCSTR test_desc_str, TestType testtype /* TT_TEST */)
{
	if( testtype == TT_TEST )
		m_pLog->RecordInfo("");
	m_pLog->RecordInfo("");
	CString strTestType;
    switch (testtype)
    {
		case TT_TEST:
			strTestType = "TEST";
			break;

		case TT_SUBTEST:
			strTestType = "SubTest";
			break;

		case TT_TESTCASE:
			strTestType = "TestCase";
			break;
	}

	m_pLog->RecordInfo("%s: %s", strTestType, test_desc_str);
}

void CDbgTestBase::LogTestStartEnd(LPCSTR test_desc_str, StartEndTest startend /* START_TEST */)
{
	CString strTest = "END";

	if( startend == START_TEST)
	{
		strTest = "START";
		m_pLog->RecordInfo("");
	}
 
	strTest += "***TEST";

	m_pLog->RecordInfo("%s: %s", strTest, test_desc_str);
}

void CDbgTestBase::LogTestBegin(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("BEGIN***TEST: %s", test_desc_str);
}

void CDbgTestBase::LogTestEnd(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("END***TEST: %s", test_desc_str);
}

void CDbgTestBase::LogTestEnd(LPCSTR test_desc_str, CTimeSpan elapsed_time, bool timing /* FALSE */)
{
//	GetLog()->RecordInfo("***TEST elapsed time %s", elapsed_time.Format("%H:%M:%S"));
	if( timing )
	{
		m_pLog->RecordInfo("END***TEST: %s  elapsed time %s", test_desc_str, elapsed_time.Format("%H:%M:%S"));
	}
	else
	{
		m_pLog->RecordInfo("END***TEST: %s", test_desc_str);
	}
}

void CDbgTestBase::LogSubTestHeader(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("SubTest: %s", test_desc_str);
}


BOOL CDbgTestBase::CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc )
{
	CString szPattern		= (CString)szSRCFileLoc + "*.*";

	// Copy sources to the project directory
	WIN32_FIND_DATA ffdImgFile;
    HANDLE hFile = FindFirstFile(szPattern, &ffdImgFile);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
			CopyFile( (CString)szSRCFileLoc + ffdImgFile.cFileName, (CString)szProjLoc + ffdImgFile.cFileName, FALSE );
			SetFileAttributes((CString)szProjLoc + ffdImgFile.cFileName, FILE_ATTRIBUTE_NORMAL );
		}
        while( FindNextFile(hFile, &ffdImgFile) );
        EXPECT( GetLastError() == ERROR_NO_MORE_FILES );
		return TRUE;
    }
	else
	{
		m_pLog->RecordFailure("Could not copy sources from %s to %s", szSRCFileLoc, szProjLoc);
		return FALSE;
	}
}

void CDbgTestBase::RemoveTestFiles( CString szProjLoc )
{
	KillAllFiles( szProjLoc, TRUE );
}
	
BOOL CDbgTestBase::IsMsgBox(CString strMsg, CString strBtn)
{	
	if( WaitMsgBoxText( strMsg, 10 ) )
	{
		MST.WButtonClick( strBtn );
		return TRUE;
	}
	else
		return FALSE;
}

CString CDbgTestBase::GetBldLog()
{
	CString BuildRecord;
	CString str;
	
	// Get build data
	UIWB.DoCommand(IDM_WINDOW_ERRORS,DC_ACCEL);  // goto output window
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(BuildRecord);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	BuildRecord.MakeLower();
	return (BuildRecord);
	
};


BOOL CDbgTestBase::VerifyBuildOccured( BOOL iBuild )
{
	// iBuild == TRUE  -  project should be rebuilt
	// iBuild == FALSE  -  project should not be rebuilt

	// Get the output window contents
	CString szBldLog = GetBldLog();
	if (szBldLog == "")
	{
		m_pLog->RecordFailure("Incorrect build: Output window is empty");
		return FALSE;
	}

	int iFoundCompiling = szBldLog.Find ("compiling");	// International ?
	int iFoundLinking = szBldLog.Find ("linking");		// International ?

	if( iBuild )
	{
		if( (iFoundCompiling < 0) && (iFoundLinking < 0) )
		{
			m_pLog->RecordFailure("Incorrect build: can't find 'Compiling' or 'Linking");
			return FALSE;
		}
	}
	else
	{
		if ( (iFoundCompiling > 0) || (iFoundLinking > 0) )
		{
			m_pLog->RecordFailure("Nothing change, the project shouldn't be rebuilt.");
			return FALSE;
		}
	}

	return TRUE;
}

int CDbgTestBase::VerifyBuildString( LPCSTR verifyString, BOOL fExist /* TRUE */ )
{
	int iFoundString;

	// Get the output window contents
	CString szBldLog = GetBldLog();
	CString testString = verifyString;

	// For some reason the output window text is always lower case when extracted.

	testString.MakeLower();
	iFoundString = szBldLog.Find(testString);

	if ( (iFoundString < 0) && fExist )
	{
		m_pLog->RecordFailure("Can't find %s", verifyString);
	}
	
	if ( (iFoundString >= 0) && !fExist )
	{
		m_pLog->RecordFailure("Found %s : it should not be there", verifyString);
	}

	return iFoundString;
}

int CDbgTestBase::VerifyDebugOutputString( LPCSTR verifyString, BOOL fExist /* TRUE */ )
{
	int iFoundString;
	CString csLog;
	CString testString = verifyString;

	// Get the output window contents
	// TODO(michma): mismatch with CODebug here. need to merge?
	dbg.SetDebugOutputPane(IDSS_PANE_DEBUG_OUTPUT);
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(csLog);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	csLog.MakeLower();

	// For some reason the output window text is always lower case when extracted.
	testString.MakeLower();
	iFoundString = csLog.Find(testString);

	if ( (iFoundString < 0) && fExist )
	{
		m_pLog->RecordFailure("Can't find %s", verifyString);
	}
	
	if ( (iFoundString >= 0) && !fExist )
	{
		m_pLog->RecordFailure("Found %s : it should not be there", verifyString);
	}

	return iFoundString;
}

CStartEndTest::CStartEndTest(LPCSTR testName, CDbgTestBase *test, bool timing /*=FALSE*/)
{
	m_testName = testName;
	m_Test = test;
	if( timing )
	{
		m_startTime = CTime::GetCurrentTime();
		m_timing = TRUE;
		m_Test->LogTestBegin( m_testName );
	}
}

CStartEndTest::~CStartEndTest()
{
	if( m_timing )
	{
		m_endTime = CTime::GetCurrentTime();
		CTimeSpan elapsed_time(m_endTime - m_startTime);
		m_Test->LogTestEnd( m_testName, elapsed_time, m_timing );
	}
	else
		m_Test->LogTestEnd( m_testName );
}


/*
unused in Xbox
char szecEditTypes[6][256] =
{
	"EC_NO_STACK_FRAME",
	"EC_CURRENT_FRAME_AFTER_IP",
	"EC_CURRENT_FRAME_BEFORE_IP",
	"EC_CURRENT_FRAME_AT_IP", 
	"EC_PARENT_FRAME_AFTER_IP", 
	"EC_PARENT_FRAME_BEFORE_IP"
};

BOOL CDbgTestBase::IsProjectReady(ProjType projType)
{
	switch (projType)
	{
	case PT_EXE:
		m_strProjectName = "ecconsol";
		break;
	case PT_EXT:
		m_strProjectName = "ecwinapp";
		break;
	case PT_INT:
		m_strProjectName = "ecmfcapp";
		break;
	}
	
	m_strSrcDir = "ecapp";	//ToDo: We should get the name from file with all languages strings
	m_strProjectLoc  = m_strCWD + "apps\\" + m_strProjectName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strSrcDir + "\\";
	CString szProjPathName	= (CString)("..\\apps\\") + m_strProjectName + "\\" + m_strProjectName;

	if (projType == PT_INT)	  // MFC app
		RemoveTestFiles( m_strProjectLoc + "res\\");
	RemoveTestFiles( m_strProjectLoc );
	CreateDirectory(m_strProjectLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjectLoc ) );
	if (projType == PT_INT)	   // MFC app
	{
		CreateDirectory(m_strProjectLoc + "res\\", 0);          
		EXPECT_TRUE( CopyProjectSources( szSRCFileLoc + "res\\", m_strProjectLoc + "res\\" ) );
	}
	if (projType == PT_EXE)	   // EXE consol app
	{
		if( SetProject(szProjPathName) )
			return TRUE;
	}
	else
	{
		int iWaitForBuild = 3;	// Minutes to wait for the build to complete
		if( PrepareProject(szProjPathName) && VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)))
		{
			prj.SetExeForDebugSession(m_strProjectName + ".exe");
			return TRUE;
		}
	}
	return FALSE;
}


LPCSTR CDbgTestBase::GetThreadIDStr(LPCSTR szThreadIDVar)

{
	static char szText[12] = "";
	DWORD dwThreadID;
	
	if(!cxx.GetExpressionValue(szThreadIDVar, &dwThreadID))
	{
		LOG->RecordInfo("CDbgTestBase::GetThreadIDStr - GetExpressionValue failed.");
		return (LPCSTR)szText;
	}

	sprintf(szText, "%.8x", dwThreadID);
	return (LPCSTR)szText;
}
*/


void CleanUp(LPCSTR szDirName)

{
	CString strPath;
	//strPath = (CString)"src\\" + szDirName + "\\";
	if (szDirName[0] != '\\')
		strPath = CString(TMP_PROJ_DIR) + "\\" + szDirName + "\\";
	else
		strPath = szDirName;

	KillFiles(strPath + "*.dsp");
	KillFiles(strPath + "*.dsw");
	KillFiles(strPath + "*.opt");
	KillFiles(strPath + "*.plg");
	KillFiles(strPath + "*.ncb");
	KillFiles(strPath + "*.mak");
	KillFiles(strPath + "*.lnk");
	KillFiles(strPath + "*.mdp");
	KillFiles(strPath + "*.pdb");
	KillFiles(strPath + "*.obj");
	KillFiles(strPath + "*.ilk");
	KillFiles(strPath + "*.dll");
	KillFiles(strPath + "*.exe");
	KillFiles(strPath + "*.xbe");
}


void KillFiles(LPCSTR szPathName, LPCSTR szFileName /* NULL */)

{
	WIN32_FIND_DATA ffdImgFile;
	HANDLE hFile;
	CString str, strPattern, strPath = szPathName;

	if(szFileName != NULL)
		
	{
		if((strPath.Right(1) != "\\") && (szFileName[0] != '\\'))
			strPath += "\\";

		strPattern = strPath + szFileName; 
	}

	else
		strPattern = strPath;

	hFile = FindFirstFile(strPattern, &ffdImgFile);
	
	if(hFile != INVALID_HANDLE_VALUE)
	{
		do
		{
			str = strPath + ffdImgFile.cFileName;
			DeleteFile(str);
		} while(FindNextFile(hFile, &ffdImgFile));
	}

	FindClose(hFile);
}


CString CDbgTestBase::FindInPath(LPCSTR szAppName)
{
	CIDESubSuite* pSubSuite=GetSubSuite();

	CString cstrPathEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingPathEnv, cstrPathEnv);
	cstrPathEnv = settingPathEnv + CString("=") + cstrPathEnv;

	// get windows and system dir and append to path environment string.
	CString cstrWindowsDir, cstrSystemDir;
	// each dir is prepended with a semi-colon as a separator. 
	char chDirBuf[MAX_PATH] = ";";
 	GetWindowsDirectory(&chDirBuf[1], MAX_PATH);	// &chDirBuf[0] = ';'
	cstrWindowsDir = chDirBuf;
	GetSystemDirectory(&chDirBuf[1], MAX_PATH);		// &chDirBuf[0] = ';'
	cstrSystemDir = chDirBuf;
	cstrPathEnv += cstrWindowsDir + cstrSystemDir;

	// environment block.
	char chEnvBlock[1024];
	// pointer to navigate through block.
	char *pch = chEnvBlock;

	// put the path into the block.
	// each string is terminated by null.
	strcpy(chEnvBlock, cstrPathEnv);
 
	// to find our app in the toolset path environment, 
	// we'll use cstrPathFrag to search	for and extract directories
	// from cstrPathEnv	(minus first 5 characters which are "PATH=").
	CString cstrPathFrag = cstrPathEnv.Mid(5);
	// stores dir extracted from cstrPathFrag.
	CString cstrDir;
	// stores index of next semi-colon (dir separator) in cstrPathEnv.
	int indexSemi;
	// handle to nmake.exe returned by FindFirstFile().
	HANDLE hNmake;
	// FindFirstFile param.
	WIN32_FIND_DATA fdFindData;

	while(1)
		
		{
		// find the next semi-colon which terminates the next dir to search.
		indexSemi = cstrPathFrag.Find(';');

		// if a semi-colon was found, extract the dir it terminates. otherwise
		// we are at the final dir in the path environment. 
		if(indexSemi != -1)
			cstrDir = cstrPathFrag.Left(indexSemi);
		else
			cstrDir = cstrPathFrag;
			
		// only want to search dirs at least 3 chars long. for example:
		// path  = C:\;
		// index = 0123
		if(cstrDir.GetLength() >= 3)
			hNmake = FindFirstFile(cstrDir + "\\" + szAppName, &fdFindData);
  		
		// stop searching if nmake was found in cstrPathFrag.
		if(hNmake != INVALID_HANDLE_VALUE)
			break;

		// if no semi-colon was found or it was the last char in the path, 
		// then we just searched the final dir in the environment string, 
		// but still haven't found nmake. 
	 	if((indexSemi == -1) || (cstrPathFrag.GetLength() == (indexSemi + 1)))
			{
			m_pLog->RecordInfo("ERROR in %s: could not find %s in path environment "
							   "specified by CAFE.", "CDbgTestBase::FindInPath", szAppName);
			return "";
			}
		else
			// advance to the start of the next dir after the semi-colon.
			cstrPathFrag = cstrPathFrag.Mid(indexSemi + 1);
		}

	return cstrDir;
}

BOOL CDbgTestBase::XboxDebuggerConnect()
{
	BOOL bRetVal = dbg.Go(0, 0, 0, WAIT_FOR_RUN);
	if (!bRetVal)
	{
		m_pLog->RecordInfo("ERROR in %s: unable to start debugger, forcing stop",
						   "CDbgTestBase::XboxDebuggerConnect()");
		dbg.StopDebugging(NOWAIT);
		return FALSE;
	}

	return bRetVal;
}

typedef HRESULT (CALLBACK* LPDMAPI_LPCSTR) (LPCSTR);
typedef HRESULT (CALLBACK* LPDMAPI_LPCSTR_LPCSTR) (LPCSTR, LPCSTR);

BOOL CDbgTestBase::XboxSetTarget(LPCSTR szXbox)
{
	WaitStepInstructions("Calling DmSetXboxName");
	HINSTANCE hXboxDbgDll = LoadLibrary("XboxDbg");
	if (hXboxDbgDll == NULL)
	{
		LOG->RecordInfo("LoadLibrary() failed");
		return FALSE;
	}

	LPDMAPI_LPCSTR pDmSetXboxName = (LPDMAPI_LPCSTR) GetProcAddress(hXboxDbgDll, "DmSetXboxName");
	if (!pDmSetXboxName)
	{
		LOG->RecordInfo("GetProcAddress(\"DmSetXboxName\") failed");
		FreeLibrary(hXboxDbgDll);
		return FALSE;
	}

	HRESULT hr = pDmSetXboxName(REMOTE_XBOX_IP);

	if (FAILED(hr))
	{
		LOG->RecordInfo("XboxSetTarget() failed");
		FreeLibrary(hXboxDbgDll);
		return FALSE;
	}

	FreeLibrary(hXboxDbgDll);
	return TRUE;
}


// copy xbe binary to target
BOOL CDbgTestBase::XboxCopyToTarget(LPCSTR szFileName /* = NULL */)
{
	//const char* const THIS_FUNCTION = "CopyToXboxTarget()";

	// TODO: fix COProject::GetOutputXbeFile

	CString xbeFile = ((szFileName && *szFileName) ? szFileName : 
		(CString(prj.GetDir()) + "\\Debug\\" + CString(prj.GetName()) + ".xbe"));

	CString xbeDir, xbeName;
	int ipos = xbeFile.ReverseFind('\\');
	if (ipos > -1)
	{
		xbeDir = xbeFile.Left(ipos);
		xbeName = xbeFile.Mid(ipos+1);
	}
	else
	{
		xbeName = xbeFile;
	}

	HINSTANCE hXboxDbgDll = LoadLibrary("XboxDbg");
	if (hXboxDbgDll == NULL)
	{
		LOG->RecordInfo("LoadLibrary() failed");
		return FALSE;
	}

	HRESULT hr;

	LPDMAPI_LPCSTR pDmMkdir = (LPDMAPI_LPCSTR) GetProcAddress(hXboxDbgDll, "DmMkdir");
	if (!pDmMkdir)
	{
		LOG->RecordInfo("GetProcAddress(\"DmMkdir\") failed");
		FreeLibrary(hXboxDbgDll);
		return FALSE;
	}

	hr = pDmMkdir(REMOTE_XBOX_DIR);
	/*
	if (FAILED(hr))
	{
		LOG->RecordInfo("XboxCopyToTarget() failed, DmMkdir(\"%s\") returned %08X",
			REMOTE_XBOX_DIR, hr);
		return FALSE;
	}
	*/

	LPDMAPI_LPCSTR_LPCSTR pDmSendFile = (LPDMAPI_LPCSTR_LPCSTR) GetProcAddress(hXboxDbgDll, "DmSendFileA");
	if (!pDmSendFile)
	{
		LOG->RecordInfo("GetProcAddress(\"DmSendFileA\") failed");
		FreeLibrary(hXboxDbgDll);
		return FALSE;
	}

	hr = pDmSendFile(xbeFile, REMOTE_XBOX_FILE);
	if (FAILED(hr))
	{
		LOG->RecordInfo("XboxCopyToTarget() failed, DmSendFileA(\"%s\", \"%s\") returned %08X",
			xbeFile, REMOTE_XBOX_FILE, hr);
		return FALSE;
	}

	return TRUE;
}


CString GetRemoteXboxIP()
{
	return CString(CMDLINE->GetTextValue("xbox",
		GetStrFromRegistry("HKCU\\Software\\Microsoft\\XboxSDK\\XboxName",
			"157.56.10.118")));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\automate\automate.cpp ===
#include <windows.h>


void func(void)
	{
START_OF_FUNC:
	return;
	}


void DebuggerObjectTest(void)
	{
	int i = 0;
AFTER_RUN_TO_CURSOR:
	func();
AFTER_STEP_OVER:
	func();
AFTER_STEP_OUT:
	return;
	}


void BreakpointsCollectionTest(void)
	{
	return;
	}


void BreakpointItemTest(void)
	{
	return;
	}


void MacroRecordingTest(void)
	{
	return;
	}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	{
	DebuggerObjectTest();
	BreakpointsCollectionTest();
	BreakpointItemTest();
	MacroRecordingTest();
	return 0;		
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\lineonly.cpp ===
__declspec(dllexport) void line_only_dll_func(void)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\crashdump\crashdumpdll.cpp ===
__declspec(dllexport) void dllfunc(void)
{
	int zero = 0;
	int i = zero / zero;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\dbgtestbase.h ===
///////////////////////////////////////////////////////////////////////////////
// DbgTestBase.h
//
//	Created by:		MichMa
//	Date:			3/30/98
//
//	Description:	Declaration of base class for all debugger tests.


#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#ifndef __DBGTESTBASE_H__
#define __DBGTESTBASE_H__

extern int ReturnCode;
extern bp  * ReturnBP;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

#define EXPECT_TRUE(f)    ((f)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_FALSE(f)    ((f)?LogResult(__LINE__, FAILED,#f):LogResult(__LINE__, PASSED,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f,ReturnCode));
#define EXPECT_VALIDBP(f) (((ReturnBP=(f))!=NULL)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_TRUE_COMMENT(f,comment) ((f)?LogResult(__LINE__, PASSED,#f,0,#comment):LogResult(__LINE__, FAILED,#f,0,#comment));

#define ABORT_SUBTEST() THROW( new CSubTestException )

#define EXPECT_SUBTEST_OLD(f)  if(f) { LogResult(__LINE__, PASSED,#f);} \
				else { LogResult(__LINE__, FAILED,#f); ABORT_SUBTEST(); }

#define EXPECT_SUBTEST(f)   if(f) { LogResult(__LINE__, PASSED,#f);} \
							else {LogResult(__LINE__, FAILED,#f); }

#define INFO(txt) WaitStepInstructions(#txt); Sleep (5000);

class CSubTestException : public CException {
	DECLARE_DYNAMIC( CSubTestException );
};

#define InitProject SetProject
#define RestoreFocusToSrcWnd() MST.DoKeys("{ESC}")

enum ProjType
{
	PT_EXE,
	PT_EXT,
	PT_INT
};

enum TestType
{
	TT_TEST,
	TT_SUBTEST,
	TT_TESTCASE
};

enum StartEndTest
{
	START_TEST,
	END_TEST
};

///////////////////////////////////////////////////////////////////////////////
//	class CDbgTestBase used as base for debugging tests

class CDbgTestBase : public CTest

{
	DECLARE_DYNAMIC(CDbgTestBase)
	friend class CStartEndTest;

public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CDbgTestBase(/*int metricID,*/ CIDESubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

protected: // data
	CString	m_strProjectDir;
	CString	m_strSrcDir;
	CString	m_strProjectName;
	CString	m_strProjectLoc;
	CString	m_szErrorText;
	int m_platform;
	ProjType m_projType;

	COSource src;
	COProject prj;
	CODebug dbg;
	COExpEval cxx;
	COBreakpoints bps;
	COStack stk;
	UIStack uistack;
	UIMemory uimem;
	COMemory mem;
	UIVariables uivar;
	COBrowse browse;
	COFile file;
	UIWatch uiwatch;
	UIQuickWatch uiqw;
	UIDAM uidam;
	UIRegisters uiregs;
	CODAM dam;
	COThreads threads;
	COLocals locals;
	CORegisters regs;
	COExpEval ee;
	COWatch watch;
	COClipboard clipboard;
	COApplication app;
	COAuto coauto;
	COConnection *pConnection;

	typedef enum {PROJECT_EXE, PROJECT_DLL, PROJECT_XBE} PROJECT_TYPE;
	typedef enum {fDefault, fBuildOnly} PROJECT_FLAGS;

	BOOL SetProject(LPCSTR projName, PROJECT_TYPE projType = PROJECT_EXE,
					PROJECT_FLAGS = fDefault, LPCSTR cfgName=NULL);
	BOOL SetXboxProject(LPCSTR projName, PROJECT_FLAGS = fDefault, LPCSTR cfgName=NULL);
	BOOL CreateXboxProjectFromSource(LPCSTR strProjBase, LPCSTR strSrcDir,
		LPCSTR strSrcFile, LPCSTR strSrcFile2 = 0);
#if 0
	virtual void InitTestState() { dbg.StopDebugging(); dbg.StepOver(); }
	void RunCases();
#endif

	BOOL PrepareProject(LPCSTR projName);
	BOOL IsProjectReady(ProjType projType);
	BOOL StartDebugging(void);
	BOOL StopDbgCloseProject(void);
	BOOL VerifyProjectRan(int exitcode = 0);
	BOOL StepInUntilFrameAdded(CString addframe);
	BOOL StepInUntilFrameRemoved(void);

	// shorthand method of filling EXPR_INFO object.
	void FillExprInfo(EXPR_INFO &expr_info, int state, LPCSTR type, LPCSTR name, LPCSTR value);

	// compares two EXPR_INFO objects
	BOOL ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
					int total_rows = 1);

	// tells whether string represents an address as displayed in an ee window.
	// for example: 0x1234abcd "xyz"
	// support function for ExprInfoIs()
	BOOL ValueIsAddress(CString str);
	LPCSTR GetThreadIDStr(LPCSTR szThreadIDVar);

	void LogResult(int line, int result,LPCSTR szoperation, int code=0, LPCSTR szComment="");
	LPCSTR HomeDir(void);
	LPCSTR FullPath(LPCSTR szAddPath);

	void LogTestHeader(LPCSTR test_desc_str, TestType testtype = TT_TEST);
	void LogTestStartEnd(LPCSTR test_desc_str, StartEndTest startend = START_TEST);
	void LogSubTestHeader(LPCSTR test_desc_str);
	void LogTestBegin(LPCSTR test_desc_str);
	void LogTestEnd(LPCSTR test_desc_str);
	void LogTestEnd(LPCSTR test_desc_str, CTimeSpan elapsed_time, bool timing);

	void VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);
	BOOL LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);

	CString GetBldLog();
	BOOL VerifyBuildOccured( BOOL iBuild );
	int VerifyBuildString( LPCSTR verifyString, BOOL fExist = TRUE );
	int VerifyDebugOutputString( LPCSTR verifyString, BOOL fExist = TRUE  );

	//unused in xbox - void VerifyECSuccess();
	//unused in xbox - void VerifyECCompileError();
	//unused in xbox - void VerifyECUnsupportedEdit();
	

	BOOL CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc );
	void RemoveTestFiles( CString szProjLoc );

	//unused in xbox - BOOL ModifyCodeLine(LPCSTR szFind, LPCSTR szReplace);
	//unused in xbox - BOOL ModifyCode(LPCSTR szFind, LPCSTR szReplace, int nLines = 1);
	BOOL IsMsgBox(CString strMsg, CString strBtn);

	// emmang ADDITION Xbox-specific methods
	CString FindInPath(LPCSTR szAppName);
	BOOL XboxSetTarget(LPCSTR szXbox);
	BOOL XboxDebuggerConnect();
	BOOL XboxCopyToTarget(LPCSTR strXbePath = NULL);
	CString XboxGetTarget();
};


class CStartEndTest
{

public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CStartEndTest(LPCSTR testName, CDbgTestBase *test, bool timing = FALSE);
	~CStartEndTest();

protected: // data
	CString	m_testName;
	bool m_timing;
	CTime m_startTime;
	CTime m_endTime;
	CDbgTestBase *m_Test;
};


void CleanUp(LPCSTR szDirName);
void KillFiles(LPCSTR szPathName, LPCSTR szFileName = NULL);
CString GetRemoteXboxIP();

extern char szecEditTypes[6][256];

// Xbox additions

#define REMOTE_XBOX_IP     GetRemoteXboxIP()
#define REMOTE_XBOX_DIR    "e:\\cafe6"
#define REMOTE_XBOX_FILE   REMOTE_XBOX_DIR "\\dbgtest.xbe"

#define TMP_PROJ_DIR       "c:\\cafe6tmp"

#endif	// __DBGTESTBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\crashdump\crashdumpexe.cpp ===
#include <windows.h>

__declspec(dllimport) void dllfunc(void);

int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	dllfunc();	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain0.c ===
/*DOC*
**
** CHAIN0.C
**
** Revision History :
** M001 2-Feb-1994
** - created from chain0.c, old callstack sources
**
**DOC*/


#include <string.h>
#include "foo.h"
#include "chain1.h"


#ifdef DLL                 // define DLL to enable dll tests
#include "chain4.h"
#endif

int Global=0;
int Result=0;
char * String=" Some sample string";


int ChainMain() {
  TagCallChain1:
  Result=chain_1(3);
DONE:
  return 1;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain1.c ===
/*DOC*
**
** Suite : 
** File  : chain1.c
**
** Revision History :
** M001 2-Feb-1994
** - created from chain1.c from old callstack sources.
**
**DOC*/

#include "foo.h"
#include "chain1.h"
#include "chain2.h"


int Global;

///////////////////////////////////////////////////////////////////////////
int   chain_1(int x)
{
    int Sum;
START:
    Sum=x+chain_2(x);
END:;
    return Sum;
};


///////////////////////////////////////////////////////////////////////////
int   chain_5(int x)
{
START:
    x=x*2;
END:;
    return x;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain1.h ===
int   chain_1(int x);
int   chain_5(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain2.h ===
int   chain_2(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain2.c ===
/*DOC*
**
** Suite : 
** File  : chain2.c.   Intended to be compiled with partial debug info.
**
** Thus have line number information, but do not have information about locals ...
**
** Revision History :
** M001 2-Feb-1994
** - created from chain2.c from old callstack sources.
**
**DOC*/

#include "foo.h"
#include "chain2.h"
#include "chain3.h"


int Global;

///////////////////////////////////////////////////////////////////////////
int   chain_2(int x)
{
    int Sum;
START:
    Sum=x+chain_3(x);
END:;
    return Sum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\cons01\cons01.cpp ===
#include <iostream.h>

int main()
{
 	char Char = 's';
 	int  Array1d[3] = {111, 222, 333};
 	long Array2d[3][3] = {11, 22, 33, 44, 55, 66, 77, 88, 99};
 	int Local=17;
 	float Real=(float)2.17;
 	double Double=1.303;
 	long double Ldouble=1.303;
 	char String[28] = "this is a string";
 	long Long=99;
	
	cout << Char;
	cout << Array1d[0] << Array1d[1] << Array1d[2] ;
	int i,j;
	for (i = 0; i < 3; i++)
		for (j = 0; j < 3; j++)
			cout << Array2d[i][j] ;
	cout << String;

	cin >> Char;
	cin >> Array1d[0] >> Array1d[1] >> Array1d[2] ;
	for (i = 0; i < 3; i++)
		for (j = 0; j < 3; j++)
			cin >> Array2d[i][j] ;
	cin >> String;

 	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain3.c ===
/*DOC*
**
** Suite : 
** File  : chain3.c  intended to be compiled without debug information
**
** Revision History :
** M001 2-Feb-1994
** - created from chain3.c from old callstack sources.
**
**DOC*/


#include "foo.h"
#include "chain3.h"


int Global;


extern int chain_4(int x);

///////////////////////////////////////////////////////////////////////////
int   chain_3(int x)
{
    int Sum;
START:
    Sum=x+chain_4(x);
END:;
    return Sum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain3.h ===
int   chain_3(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain4.h ===
#include "foox.h"

#if TEST == cBASIC

#ifdef hasPARAMS
#define  fooParams int paramA, int paramB
#else
#define  fooParams
#endif

#ifdef returnsVALUE
#define  fooReturn  int
#else
#define  fooReturn  void
#endif

fooReturn FUNCTYPE chainmain( fooParams );

#endif  // TEST == cBASIC

int  recursive_dll(int lim , int code);
int  chain_4(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\cxx.cxx ===
/*DOC*
**
** Suite : 
** File  : cxx.cxx
**
** Revision History :
** M001 2-Feb-1994
** - created from cxx.cxx from old callstack sources.
**
**DOC*/


#include "foo.h"
#include "cxx.h"

int Result=0;

extern "C"
{
void Cxx_Tests();
}

void Cxx_Tests()
{
  CALL_CONSTRUCTOR:
  fooclass foo1;


  CALL_MEMBER_FUNC:
  Result=foo1.getID();
  Result=foo1.getCount();


  CALL_CONVERSION:
  Result=foo1;


  CALL_STATIC:
  Result=fooclass::static_func();
  foo1.clear();  // clear private value

  CALL_INLINE:
  foo1.inline_func();
  Result=foo1;
  foo1.chain1_func();
};

void fooclass::chain1_func() {					// chain1 function
  START:
      unsigned char local_cpp_func='A';
      private_value++;                // increment private value
	  int chain2_return = chain2_func();
      private_value--;                // decrement private value
  END:;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\autopane\autopane.cpp ===
#include <xtl.h> //#include <windows.h>

char array[4] = "abc";
int global;
int i;
int *pi = &i;


class base
	{
	private:
		int m_private;
	public:
		virtual void func(int i);
		int m_public;
		char *m_pchar;
	} b;


void base::func(int i)

	// verify that function arguments appear when prolog reached
	{
	// verify that no locals appear after executing prolog
	while(0);

	// verify that only expressions from current statement and previous statement are added
	m_private = i;
	m_public = i;
	}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	
	{
	i = 0;
	*pi = 1;
	while(0);

	int *pint = &i;
	while(0);

	// navigate the stack to another function and back
	// verify that function calls arent added
	// step through prolog with this pane active, then select auto pane
	b.func(0);
	while(0);

	// verify that multi-line statements get scanned back 10 lines
	int j[60];

	for(int k = 0; k < 60; k++)
		j[k] = 1;
	
	k = j[1] +
		j[2] +
		j[3] +
		j[4] +
		j[5] + 
		j[6] +
		j[7] +
		j[8] +
		j[9] +
		j[10] +
		j[11] +
		j[12] +
		j[13] +
		j[14] +
		j[15];

	while(0);
	while(0);

	// verify that the unsupported operators are not included
	b.func(j[0]);
	i = (int)(char)j[1];
	j[2]++;
	j[3]--;
	i = !j[4];
	i = ~j[5];
	++j[6];
	--j[7];
	i = sizeof(j[8]);
	j[9] = 1, j[10] = 1;
	i = j[11] * j[12];
	i = j[13] / j[14];
	i = j[15] % j[16];
	i = j[17] + j[18];
	i = j[19] - j[20];
	i = j[21] << j[22];
	i = j[23] >> j[24];
	i = j[25] < j[26];
	i = j[27] <= j[28];
	i = j[29] > j[30];
	i = j[31] >= j[32];
	i = j[33] == j[34];
	i = j[35] != j[36];
	i = j[37] & j[38];
	i = j[39] ^ j[40];
	i = j[41] | j[42];
	i = j[43] && j[44];
	i = j[45] || j[46];
	i = j[47];
	i += j[49];
	i -= j[50];
	i *= j[51];
	i /= j[52];
	i %= j[53];
	i <<= j[54];
	i >>= j[55];
	i &= j[56];
	i ^= j[57];
	i |= j[58];
	i = j[59] ? j[60] : 0;

	array[0] = 'x';
	while(0);
	
	array[(5 + 15) / 10 * 2 - (4 + (int)'\x00')] = '1';
	while(0);

	array[array[4]] = 'a';
	while(0);

	base *pb2;
	base *pb = new base;
	pb2 = pb;

	*pb = *pb;

	//b.*m_pchar = 'a';
	//pb->*m_pchar = 'b';
	//char **ppchar = (char**)&array;
	//*ppchar[0] = 'c';
	//**ppchar = '1';

	pb->m_public = 0;
	pb->func(0);
	while(0);

	b.m_public = 1;
	b.func(1);
	while(0);

	while(0);
	while(0); // no expressions

	int before_comments = 0;
	// pi = 1;
	/* 
	global = 2;
	*/
	while(0);

	int i2 = 0;
	i2 = 1;
	while(0);

	::global = 1;
	while(0);

	// verify that no expressions with error values are added
	i = 1;
	while(1);
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\cxx.h ===
/*********************** FOOCLASS **********************/
class fooclass {
private:
  int private_value;
  int id;
  static int ref_cnt;
public:

  fooclass();
  ~fooclass();

  static int static_func() {
  START:
     return 9;
  END:;
  };

  void clear() {                       // Clear private value
  START:
     fooclass::private_value=0;
  END:;
  };

  int getID() {                       // return ID
  START:
      return id;
  END:;
  };

  int getCount() {                    // return reference_cnt
  START:
      return ref_cnt;
  END:;
  };

  operator int() {                    // return private value
  START:
      return (int)private_value;      // conversion operator
  END:;
  };

  inline void inline_func() {         // inline function
  START:
      private_value++;                // increment private value
  END:;
  };

  void chain1_func();					// chain1 function
  int chain2_func() {					// chain2 function
  START:
      return private_value+1;
  END:;
  };

};


/******************** define function for fooclass ************/
 int fooclass::ref_cnt=1;

  fooclass::fooclass() {              // constructor for fooclass
  START:
    id=ref_cnt;
    ref_cnt++;
    private_value=-2*id;
  END:;
  };

  fooclass::~fooclass() {             // destructor for fooclass
  START:
    ref_cnt--;
  END:;
  };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\breakpoints pri2\breakpoints pri2 exe.cpp ===
//#include <windows.h>
#include <xtl.h>

typedef void (APIENTRY *PDLLFUNC)(void);


struct FREQ_INFO	// struct returned by DLL function call- yes it's lame to define it here.
{
	unsigned long in_cycles;	// internal clock cycles during test	
	unsigned long ex_ticks;		// microseconds elapsed during test						
	unsigned long raw_freq;		// raw frequency of CPU in MHz
	unsigned long norm_freq;	// normalized frequency of CPU in MHz.
};


typedef FREQ_INFO (FAR *PCPUFUNC)(int BSFclocks);


int iGlobal = 0;
int giDelay = 0;


class CBase

{
public:

	int m_i;
	char m_ch;

	CBase(void)	// first line of CBase::CBase()
	{
		m_i = 0;
		m_ch = 0;
	}

} gCBaseObj;


/*xbox - not needed on xbox, we're not doing any throttling
int GetCPUSpeed(void)

{
	int iCPUSpeed = 0;

	// This function first uses a free distribution Intel DLL to determine CPU speed.  Note
	// that this only works for Intel CPUs!
	HINSTANCE hCpuDll = LoadLibrary("cpuinf32.dll");
	PCPUFUNC pCpuFunc = (PCPUFUNC)GetProcAddress(hCpuDll, "cpuspeed");
	FREQ_INFO CpuInfo = (*pCpuFunc)(0);
	iCPUSpeed = CpuInfo.norm_freq;
	FreeLibrary(hCpuDll);

	// If the DLL fails us, we might find the CPU speed in the registry.
	// WinNT puts it there, but Win95 doesn't.  Win98?  Dunno.
	if(iCPUSpeed <= 0)	// DLL function *should* return 0 if it fails
	
{
		HKEY keyOpen = NULL;
		LONG lRegStatus = ::RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
											"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",
											0,
											KEY_ALL_ACCESS, 
											&keyOpen);
		if (lRegStatus == ERROR_SUCCESS)
		{
			DWORD dwBufferSize = sizeof(int);
			lRegStatus = ::RegQueryValueEx(	keyOpen,
											"~MHz",
											NULL,
											NULL,
											(LPBYTE)&iCPUSpeed,
											&dwBufferSize);
		}
	
		if (lRegStatus != ERROR_SUCCESS)
			iCPUSpeed = 0;	// paranoia
	
		::RegCloseKey(keyOpen);
	}

	// If registry lookup fails, the calling routine will have to punt.  Return will be 0.
	return iCPUSpeed;
}
*/

void Func(void)

{						// first line of Func()
	int iLocal = 0;		// init iLocal in Func()

	while(0);			// line within Func()

	iLocal++;
	iGlobal = 1;

MultipleBreakpointsHitLabel:
	while(0);	// multiple breakpoints hit
}


void OverloadedFunc(void)
{							// first line of OverloadedFunc(void)
}

void OverloadedFunc(int i)
{							// first line of OverloadedFunc(int)
}


void APIENTRY DllFunc() // fake DLL function for xbox testing
{	// first line of DllFunc()
	static int c = 0;
	c++;
}


void __cdecl main()

{	// first line of main()
	int iLocal = 0;
	int i;

	Func();
	
	OverloadedFunc();	// line after call to Func()
	OverloadedFunc(1);
	
	gCBaseObj.m_ch = 'a';	
	while(0);	// gCBaseObj change

	//xbox HINSTANCE hDll = LoadLibrary("breakpoints pri2 dll.dll");
	//xbox PDLLFUNC pDllFunc = (PDLLFUNC)GetProcAddress(hDll, "DllFunc");
	PDLLFUNC pDllFunc = &DllFunc; // dll loaded

	/*xbox
	// We need to 'throttle' the number of iterations that the following for loops perform,
	// since too many iterations can cause Cafe to fail out at 5 min. on a slow machine, and
	// too few can cause both for loops to be executed in about the same span of time on a
	// fast machine.	mke 3/5/98
	int iCPUSpeed = GetCPUSpeed();
	int iLoopNum = 0;
	iCPUSpeed = (iCPUSpeed == 0) ? 133 : iCPUSpeed;	// assume 133 MHz (midrange) if speed test fails
	
	if(iCPUSpeed < 133)
		iLoopNum = 500;
	else if(iCPUSpeed < 200)
		iLoopNum = 3000;
	else
		iLoopNum = 10000;
	*/
	int iLoopNum = 500; /* good speed for remote connection */

	for(i = 0; i < iLoopNum; i++)
		pDllFunc();	// line within loop

	iLocal++;
	iGlobal++;

	for(i = 0; i < giDelay; i++)		   
		Sleep(1000);
	
	while(0);	// line within main()

	iGlobal = 100;
	while(0);	// iGlobal = 100

	//xbox FreeLibrary(hDll);
	//xbox hDll = LoadLibrary("breakpoints pri2 dll.dll");
	//xbox pDllFunc = (PDLLFUNC)GetProcAddress(hDll, "DllFunc");
	pDllFunc();

	while (1) i++; return; // emmang@xbox - never return from main()	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\foo.h ===
#define TRUE    1
#define FALSE   0

#define cBASIC     0
#define cCHAIN     1
#define cCXX       2
#define cRECURSIVE 3

#ifndef WIN32
  #ifndef FAR
    #define FAR                 _far
  #endif
typedef unsigned long ULONG;
#if !defined( _WINDEF_ )
typedef unsigned long INT;
#endif

#else
  #ifndef FAR
    #define FAR
  #endif
#endif

#pragma warning(disable:4102)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\all\test.cpp ===
//#define _UNICODE


#include <afxwin.h>
#include "nopdb.h"
#include "lineonly.h"
#include "test.h"


int global = 0;


class BASE_CLASS
	{
	private:
		int i_priv;
	protected:
		int i_prot;
	public:
		BASE_CLASS(void){i_priv = 1; i_prot = 2;}
		virtual ~BASE_CLASS(void){};
	};


class DERIVED_CLASS1 : public BASE_CLASS
	{
	private:
		char ch;
	public:
		DERIVED_CLASS1(void){ch = 'a';}
	};


class DERIVED_CLASS2 : public DERIVED_CLASS1
	{
	private:
		float f;
	public:
		DERIVED_CLASS2(void){f = 1.0f;}
	};


struct A_STRUCT
	{
	int i;
	};


class A_CLASS
	{
	public:
		virtual void func(unsigned char ch){}
		int i;
	};


void no_debug_func(void);
void diff_seg_func(void);


unsigned long __stdcall thread_func(void * pdata)
		{
		MessageBeep(0xffffffff);       
		while(1);
		return 0;
		}


BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lparam)
	{
	static i = 0;
	i++;
	if(i == 2)
		return FALSE;
	else
		return TRUE;
	}	


int empty_func(void)
	{
	return 0;
	}


void many_params_func(int* i, CString &cstring, _TCHAR* tchar_array, 
					  float* f, A_STRUCT* a_struct)
	{
	*i = 1;
	cstring = "abc";
	lstrcpy(tchar_array, _TEXT("xyz"));
	*f = 1.0f;
	a_struct->i = 1;
	}


int set_ints_func(int i)
	{
	i++;
	global = 1;
	diff_seg_func();
	return i;
	}


void exception_func(void)	
	{
	int zero = 0;
	int i = 1 / zero;
	}

void overloaded_func(void){}
void overloaded_func(int i){}

int recursive_func(int i)
	
	{
	if(i == 5)
		return i; // most nested return
	else
		{
		recursive_func(i + 1);
		return i;
		} 
	}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, 
				   LPSTR lszCmdLine, int nCmdShow)
	
	{
	recursive_func(0);
	header_func();
	inline_func();
	overloaded_func();
	














	
	overloaded_func(0);
		  
	CString cstring = _TEXT("abc");
	_TCHAR tchar_array[sizeof(_TCHAR) * 4] = _TEXT("xyz");
	int i = 1;

	for(int x = 0; x < 100; x++)
		{
		while(0);
		}

	float f = 1.0f;
	
	struct A_STRUCT a_struct;
	a_struct.i = 1;
	
	BASE_CLASS* object_base = new BASE_CLASS();
	BASE_CLASS* object1 = new DERIVED_CLASS1();
	BASE_CLASS* object2 = new DERIVED_CLASS2();
	BASE_CLASS*	object = object1;

	i++;
	
	cstring = "1234";
	cstring = "5678";
	
	lstrcpy(tchar_array, _TEXT("pdz"));
	lstrcpy(tchar_array, _TEXT("pdq"));
	
	empty_func();
	many_params_func(&i, cstring, tchar_array, &f, &a_struct);
	
	object = object2;
	
	char array[4] = "abc";
	strcpy(array, "xyz");
	strcpy(array, "xy3");
	
	A_CLASS obj;
	obj.i = 1;
	obj.func('a');
	
	int (*pfunc)(int) = set_ints_func;
	i = set_ints_func(0);
	i = (*pfunc)(1);
	
	no_debug_func();
	diff_seg_func(); 
	
	HANDLE thread_hdl;
	DWORD thread_id;
	thread_hdl = CreateThread(NULL, 0, thread_func, 0, 0, &thread_id); 

	call_dlls:

	//HINSTANCE hinst_dll = GetModuleHandle("nopdb.dll");
	//BOOL ret = FreeLibrary(hinst_dll);
	//no_pdb_dll_func();

	HINSTANCE hinst_dll = GetModuleHandle("nopdb.dll");
	BOOL ret = FreeLibrary(hinst_dll);
	LoadLibrary("nopdb.dll");
	no_pdb_dll_func();

	line_only_dll_func();
	
	//exception_func();

	EnumWindows(EnumWindowsProc, 0);

	//while(1);

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\foo0x.h ===
// #pragma warning(disable:4049)  //warning indirection in intializing...

void BPWithLengthTest(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\foox.h ===
#define hasPARAMS
#define FUNCTYPE _stdcall
#define returnsVALUE


#ifdef hasPARAMS
#define  fooParams int paramA, int paramB
#else
#define  fooParams
#endif

#ifdef returnsVALUE
#define  fooReturn  int
#else
#define  fooReturn  void
#endif

fooReturn FUNCTYPE foo( fooParams );
fooReturn FUNCTYPE foo2( fooParams );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\foox.c ===
/*DOC*
**
** Suite : 
** File  : foox.c
**
** Revision History :
** M001 2-Feb-1994
** - created from foox.c from old callstack sources.
**
**DOC*/

#include "foo.h"
#include "foox.h"

int Global;


////////////////////////////////////////////////////////////////////////////
//
// foo()
//
//
//      foo is a chamelion function it return value, calling convention,
//      paramters, and use of locals is determined by defining certain
//      FLAGS at compile time (ie hasLOCALS, hasPARAMS, returnsVALUE, DLL)
//
//
//
////////////////////////////////////////////////////////////////////////////
#ifdef hasLOCALS
#define  DeclareLocals   int Sum;
#define  RESULT          Sum
#else
#define  DeclareLocals
#define  RESULT          Global
#endif

#ifdef hasPARAMS
#define  fooAdd          paramA+paramB
#else
#define  fooAdd          Global+3
#endif

#ifdef returnsVALUE
#define  ReturnStmt      return Global
#else
#define  ReturnStmt
#endif

fooReturn	FUNCTYPE foo2(fooParams)
{
   DeclareLocals;
START:
   Global=3;
   RESULT = fooAdd;
   ReturnStmt;
END:;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbga\cpp.cpp ===
#include "cpp.h"

int Result=0;

extern "C"
{
void Cxx_Tests();
}

void Cxx_Tests()
{
  CALL_CONSTRUCTOR:
  fooclass foo1;

  foo1.vf1();
  Result = foo1.base::vf2();
  Result = foo1.vf2(7);
  Result = foo1.vf3(9);

  CALL_MEMBER_FUNC:
  Result=foo1.getID();
  Result=foo1.getCount();

  CALL_CONVERSION:
  Result=foo1;

  CALL_STATIC:
  Result=fooclass::static_func();
  foo1.clear();  // clear private value

  CALL_INLINE:
  foo1.inline_func();
  Result=foo1;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbga\cpp.h ===
// base class
class base {
public:
	virtual void vf1() { int i = 5; };
	virtual int  vf2() { return 10; };
	virtual int  vf3(int ind) { return ind*2; };
};


/*********************** FOOCLASS **********************/
class fooclass : public base {
private:
  int private_value;
  int id;
  static int ref_cnt;
public:

  fooclass();
  ~fooclass();

  void vf1() { int i = 7; };
  int  vf2(int j) { return j; };

  static int static_func() {
  START:
     return 9;
  END:;
  };

  void clear() {                       // Clear private value
  START:
     fooclass::private_value=0;
  END:;
  };

  int getID() {                       // return ID
  START:
      return id;
  END:;
  };

  int getCount() {                    // return reference_cnt
  START:
      return ref_cnt;
  END:;
  };

  operator int() {                    // return private value
  START:
      return (int)private_value;      // conversion operator
  END:;
  };

  inline void inline_func() {         // inline function
  START:
      private_value++;                // increment private value
  END:;
  };
};


/******************** define function for fooclass ************/
 int fooclass::ref_cnt=1;

  fooclass::fooclass() {              // constructor for fooclass
  START:
    id=ref_cnt;
    ref_cnt++;
    private_value=-2*id;
  END:;
  };

  fooclass::~fooclass() {             // destructor for fooclass
  START:
    ref_cnt--;
  END:;
  };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbga\main2.c ===
#include <windows.h>

#define IDM_EXIT  100

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
int MyPostMessage( HWND hwnd );
//extern int OtherMain();
extern void Cxx_Tests();

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                         LPSTR lpszCmdLine, int nCmdShow)
{

     static char szAppName[] = "foo" ;
     HWND        hwnd ;
     MSG         msg ;
     WNDCLASS    wndclass ;

     if (!hPrevInstance)
          {
          wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
          wndclass.lpfnWndProc   = (WNDPROC) WndProc ;
          wndclass.cbClsExtra    = 0 ;
          wndclass.cbWndExtra    = 0 ;
          wndclass.hInstance     = hInstance ;
          wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION); 
          wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
          wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
          wndclass.lpszMenuName  = szAppName ;  // MAC?
          wndclass.lpszClassName = szAppName ;

          RegisterClass (&wndclass) ;
          }

     hwnd = CreateWindowEx(
#if defined( _MAC )
					WS_EX_FORCESIZEBOX,
#else
					0,
#endif
     				szAppName,         // window class name
                    szAppName, 				// window caption
                    WS_OVERLAPPEDWINDOW,     // window style
                    CW_USEDEFAULT,           // initial x position
                    0, // CW_USEDEFAULT,           // initial y position
                    CW_USEDEFAULT,           // initial x size
                    0, // CW_USEDEFAULT,           // initial y size
                    NULL,                    // parent window handle
                    NULL,                    // window menu handle
                    hInstance,               // program instance handle
                    NULL) ;                  // creation parameters
     if (hwnd==0) {   //window not created
         return 1;
     }

     ShowWindow (hwnd, nCmdShow) ;
     UpdateWindow (hwnd) ;
     SendMessage( hwnd, WM_PAINT, (WORD)0, (DWORD)0);

     while (GetMessage (&msg, NULL, 0, 0))
          {
          TranslateMessage (&msg) ;
          DispatchMessage (&msg) ;
          }
     return msg.wParam ;
     }


LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     {
     HDC         hdc ;
     PAINTSTRUCT ps ;
     RECT        rect ;
     static HINSTANCE hInst;
     static FARPROC pCB;
     int x;
	 static int y = -1;

	 SAVELABEL(TagCallOtherMain);
	 SAVELABEL(TagCreateCase);

     switch (message)
          {
          case WM_CREATE:
TagCreateCase: hInst= ((LPCREATESTRUCT) lParam)->hInstance;

               ////////////// MAKE TESTING CALLS HERE  /////////
TagCallOtherMain: // OtherMain();
			   Cxx_Tests();
               x = 0;
               return 0 ;

          case WM_PAINT:
               hdc = BeginPaint (hwnd, &ps) ;
               GetClientRect (hwnd, &rect) ;
               DrawText (hdc, "Hello, Windows!", -1, &rect,
                          DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;
               EndPaint (hwnd, &ps) ;
              return 0 ;

#if defined( _MAC )
          case WM_SYSCOMMAND:
#endif
          case WM_COMMAND:        /* message: command from application menu */
               switch( wParam )
                  {
                  case IDM_EXIT:
                       DestroyWindow(hwnd);
                       break;
                  }
               break;

          case WM_DESTROY:
               PostQuitMessage (0) ;
               return 0 ;
#if !defined( _MAC )
           case WM_NULL:
               MyPostMessage(hwnd);
               return 0 ;
#endif
          }

     return DefWindowProc (hwnd, message, wParam, lParam) ;
}


int MyPostMessage( HWND hwnd )
{
    static int count = 0;

#if !defined( _MAC )
	SAVELABEL(TagPost);
					 
    if ( count < 5 )
    {
TagPost: PostMessage( hwnd, WM_PAINT, (WORD)0, (DWORD)0);
         PostMessage( hwnd, 0x0040, (WORD)0, (DWORD)0);
    }
    return count++;
#endif 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\cvtest.h ===
/*
** cvtest.h - definitions/declarations for standard codeview testing
** Copyright (c) 1992-1992, Microsoft Corporation. All rights reserved.
**
**Purpose:
**	This file defines the structures, values, macros, and functions
**	used by the codeview tests.
**
**
*/

#if !defined( _INC_CVTEST )

#define CVMAXMSG (80)

#if !defined CDECL 
#define CDECL _cdecl
#endif

#if !defined FASTCALL
#define FASTCALL _fastcall
#endif

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

/* prototypes */
void InitCVTest( void );
void EndCVTest( void );
int ChkEQ( int x, int y);
int ChkTrue( int x );
int ChkFalse( int x );
char *PrintIsFalse( int );
char *PrintIsTrue( int );
char *PrintIsEqual( int, int );

#define _INC_CVTEST
#endif	/* _INC_CVTEST */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\eh.cpp ===
/*****************************************************************************
*
*	File:		EH.CPP
*	Project:	THREAD
*	Owner:		briancr
*
*	Description: This is a C++ file that basically throws a C++ exception.
*
*	History:
*		briancr			09/20/93	created
*
*****************************************************************************/

//#include "eh.h"

extern "C" void DoCppException(void);
void ThrowException(void);

void DoCppException(void)
{
	ThrowException();							// dbg:stack_traverse
}

void ThrowException(void)
{
	throw 5;
}												// dbg:eh_stop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\dec.h ===
/*DOC***
**
** Suite : step
** Test  : dec.h
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
**
**
**
**DOC***/

#if defined( WIN32 )
#include <windows.h> 
#endif

void WINAPI Dec( LPWORD wBar );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\foo0x.c ===
/*DOC*
**
** Suite : 
** File  : foo0x.c
**
** Revision History :
** M001 2-Feb-1994
** - created from foo0x.c from old callstack sources.
**
**DOC*/

#include <string.h>
#include "foo.h"
#include "foo0x.h"

// #if TEST == cBASIC
// #ifdef DLL                                    // define DLL to enable dll tests
#include "chain4.h"
// #else
#include "foox.h"
// #endif //DLL
// #endif //cbasic

#ifdef hasPARAMS
#define  fooArgs  param1, param2
#else
#define  fooArgs
#endif

#ifdef returnsVALUE
#define  fooRet  Result=
#else
#define  fooRet
#endif

#define FOO  fooRet foo(fooArgs);

// #if TEST == cCXX
  void Cxx_Tests();
// #endif

int param1=1;
int param2=2;
int index=0;


extern int Global; // =0;
extern int Result; // =0;
extern char * String; // =" Some sample string";

int gi[5] = {0, 0, 0, 0, 0};

int OtherMain() {
int local;

  local=255;

#if TEST == cBASIC
  callFOO:

  FOO;

  RETURN:;

#endif // TEST == cBASIC



  BPWithLengthTest();
  callCXX:
  Cxx_Tests();
  (void)foo2(7, 1);
  TagStepEH: DoCppException();


  CALL_RUNTIME:;
  Result=strlen(String);


DONE:
  return 1;
};


void BPWithLengthTest(void)
{
	START:	
	gi[4]=99;
	gi[2]=99;  // breakpoint should fire and stop 
	BREAK:     // at the next line of code tagged with the BREAK label
	gi[2]=0; gi[3]=99;  
	END:
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\dllapp.h ===
/*DOC***
**
** Suite : step
** Test  : dllapp.h
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
**
**
**
**DOC***/

#define IDM_EXIT  100
#define IDM_ABOUT 101

BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, int);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);

LONG APIENTRY MainWndProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY About(HWND, UINT, UINT, LONG);
void BPWithLengthTest(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\main.c ===
/*DOC*
**
** Suite : 
** File  : main.c
**
** Revision History :
** M001 2-Feb-1994
** - created from chain1.c from old callstack sources.
**
**DOC*/


#include <windows.h>
#include "chain3.h"

#define IDM_EXIT  100

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
int MyPostMessage( HWND hwnd );
extern int ChainMain();
extern int OtherMain();

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

#ifdef DLL
extern int callback();
int WINAPI mycallbackfcn();
#endif

char szGExeBuffer[128];

void __cdecl main()
{

     static char szAppName[] = "foo" ;
     HWND        hwnd ;
     MSG         msg ;
     WNDCLASS    wndclass ;

     if (!hPrevInstance)
          {
          wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
          wndclass.lpfnWndProc   = (WNDPROC) WndProc ;
          wndclass.cbClsExtra    = 0 ;
          wndclass.cbWndExtra    = 0 ;
          wndclass.hInstance     = hInstance ;
          wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION); 
          wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
          wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
          wndclass.lpszMenuName  = szAppName ;  // MAC?
          wndclass.lpszClassName = szAppName ;

          RegisterClass (&wndclass) ;
          }

     hwnd = CreateWindowEx(
#if defined( _MAC )
					WS_EX_FORCESIZEBOX,
#else
					0,
#endif
     				szAppName,         // window class name
                    szAppName, 				// window caption
                    WS_OVERLAPPEDWINDOW,     // window style
                    CW_USEDEFAULT,           // initial x position
                    0, // CW_USEDEFAULT,           // initial y position
                    CW_USEDEFAULT,           // initial x size
                    0, // CW_USEDEFAULT,           // initial y size
                    NULL,                    // parent window handle
                    NULL,                    // window menu handle
                    hInstance,               // program instance handle
                    NULL) ;                  // creation parameters
     if (hwnd==0) {   //window not created
         return 1;
     }

     ShowWindow (hwnd, nCmdShow) ;
     UpdateWindow (hwnd) ;
//     PostMessage( hwnd, WM_NULL, (WORD)0, (DWORD)0);

     while (GetMessage (&msg, NULL, 0, 0))
          {
          TranslateMessage (&msg) ;
          DispatchMessage (&msg) ;
          }
     return msg.wParam ;
     }


LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     {
     HDC         hdc ;
     PAINTSTRUCT ps ;
     RECT        rect ;
     static HINSTANCE hInst;
     static FARPROC pCB;
     int x;
	 static int y = -1;

	 SAVELABEL(TagCallNoCVInfo);
	 SAVELABEL(TagCallOtherMain);
	 SAVELABEL(TagCallChainMain);
	 SAVELABEL(TagCreateCase);

     switch (message)
          {
          case WM_CREATE:
TagCreateCase: hInst= ((LPCREATESTRUCT) lParam)->hInstance;

               ////////////// MAKE TESTING CALLS HERE  /////////

TagCallChainMain: ChainMain();

TagCallOtherMain: OtherMain();

TagCallNoCVInfo: y = chain_3(99);

#ifdef DLL
CALL_CALLBACK:;
               pCB = MakeProcInstance(mycallbackfcn, hInst);
               x= callback(pCB, 4);
#endif
               x = 0;
               return 0 ;

          case WM_PAINT:
               hdc = BeginPaint (hwnd, &ps) ;
               GetClientRect (hwnd, &rect) ;
               DrawText (hdc, "Hello, Windows!", -1, &rect,
                          DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;
               EndPaint (hwnd, &ps) ;
               return 0 ;

#if defined( _MAC )
          case WM_SYSCOMMAND:
#endif
          case WM_COMMAND:        /* message: command from application menu */
               switch( wParam )
                  {
                  case IDM_EXIT:
                       DestroyWindow(hwnd);
                       break;
                  }
               break;

          case WM_DESTROY:
               PostQuitMessage (0) ;
               return 0 ;
#if !defined( _MAC )
           case WM_NULL:
               MyPostMessage(hwnd);
               return 0 ;
#endif
          }

     return DefWindowProc (hwnd, message, wParam, lParam) ;
}


int MyPostMessage( HWND hwnd )
{
    static int count = 0;

#if !defined( _MAC )
	SAVELABEL(TagPost);
					 
    if ( count < 5 )
    {
TagPost: PostMessage( hwnd, WM_PAINT, (WORD)0, (DWORD)0);
         PostMessage( hwnd, 0x0040, (WORD)0, (DWORD)0);
    }
    return count++;
#endif 

}


#ifdef DLL
int WINAPI mycallbackfcn()
{
   int x;

START:
   x=1;
   x=x+3;
   return x;
END:;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dbg\chain4.c ===
/*DOC*
**
** Suite : 
** File  : chain4.c
**
** Revision History :
** M001 2-Feb-1994
** - created from foodll.c from old callstack sources.
**
**DOC*/

#include <xtl.h> //xbox #include <windows.h>
#include "foo.h"
#include "chain1.h"
#include "chain4.h"

int Global;
// external int chain_5();
typedef int PASCAL CallBackFCN();
int callback(CallBackFCN lpfnCallBack, int x);

///////////////////////////////////////////////////////////////////////////
//INT WINAPI DllEntryPoint(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) {
int  WINAPI DllEntryPoint(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) {
// ulRbc is reason bieng called
    return 1;
} /* DllEntryPoint */


#if TEST == cBASIC
////////////////////////////////////////////////////////////////////////////
#ifdef hasLOCALS
#define  DeclareLocals   int Sum;
#define  RESULT          Sum
#else
#define  DeclareLocals
#define  RESULT          Global
#endif

#ifdef hasPARAMS
#define  fooAdd          paramA+paramB
#else
#define  fooAdd          Global+3
#endif

#ifdef returnsVALUE
#define  ReturnStmt      return Global
#else
#define  ReturnStmt
#endif

fooReturn FUNCTYPE foo( fooParams )
{
   DeclareLocals;
START:
   Global=3;
   RESULT = fooAdd;
#ifndef _ALPHA_
   ReturnStmt;
#endif
END:;
#ifdef _ALPHA_
// Alpha optimizes away lables without code after them.
   ReturnStmt;
#endif
};
#endif //TEST == BASIC


///////////////////////////////////////////////////////////////////////////
int  recursive_dll(int lim , int reset)
{
    static cnt=0;
    static limit=0;

START:
    if (reset)
    {
        cnt=0;
        limit=lim;
    }
    cnt++;
    if (cnt < limit )
    {
        recursive_dll(cnt, FALSE);
    }
END:;
    return cnt;
}



///////////////////////////////////////////////////////////////////////////
int chain_4(int x)
{
    int Sum_4;
START:
    Sum_4=x+1;
	x=chain_5(x)/2;
END:;
    return Sum_4;
};



int callback(CallBackFCN lpfnCallBack, int x)
{
    int cnt;
    int sum;
    int tmp;

START:
    cnt=0;
    sum=0;
    tmp=0;
    for (cnt=0; cnt < x ; cnt++)
    {
        tmp = (*lpfnCallBack)();
        sum=sum+tmp;
    };
    return sum;
END:;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\inc.h ===
/*DOC***
**
** Suite : step
** Test  : 
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
**
**
**
**DOC***/

#if defined( WIN32 )
#include <windows.h> 
#endif

void WINAPI Inc( LPWORD wBar );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\disasm\disasm.cpp ===
#include <xtl.h> //xbox #include <windows.h>

// DAM window test
#include <math.h>

extern "C" 
{
LPTHREAD_START_ROUTINE ThreadRoutine(LPVOID pArg);
}

void OverloadedFunc(int nArg)
{
	return;
}

void OverloadedFunc(void)
{
	return;
}

int Func(double dArg)
{
	return (int) dArg;
}

int FuncWithArg(int nArg)
{
	return nArg + 2;
}

// Template 
template <class T> T TemplateFoo(T tArg)
{
	return ++tArg;					/* TemplateFoo body */
}

void __cdecl main()
{
	char	chJustChar = 'a';
	int		nJustInt = 7;
	int		*pJustInt = &nJustInt;
	double	dJustDouble  =9.37;
	float  fJustFloat = 1.00;

	HANDLE hThread;
	DWORD dwThreadId;

	// The next two line should be normally commented.  They are used to ccause GPF and invoke default debugger
	//int *popa;
	//*popa = 65700;

	__asm {
		push eax;
		pop eax;
	}

	int *p = &nJustInt;
	*p = 0;

	TemplateFoo <char>(chJustChar);		/* First line for tests */
	TemplateFoo <int>(nJustInt);

	goto Ku_Ku;
		nJustInt = 7;
	Ku_Ku:
		nJustInt = 17;

	FuncWithArg(1);						/* Second line for tests */
	Func(dJustDouble);

	OverloadedFunc();
	OverloadedFunc(nJustInt);

	hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadRoutine, (void*) pJustInt, 0L,&dwThreadId);
	ResumeThread(hThread);

	while(1)							/* Last line for tests */
		Sleep(5000);

	return;							
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\incdll.c ===
/*DOC***
**
** Suite : 
** Test  : incdll.c
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
** M001 30-Jun-92	waltcr
** - add local var
**
**
**
**DOC***/

#if defined( WIN )
#include <windows.h>
#endif //WIN

#include "inc.h"
#include "cvtest.h"

void WINAPI Inc( LPWORD wBar ) {

	WORD wLocal;

	wLocal = ++(*wBar);
	++(*wBar);

} /* Inc */


INT WINAPI DllMain(HMODULE hInst, DWORD ulRbc, LPVOID lpReserved) {
// ulRbc is Reason Being Called
	return 1;
} /* IncDllEntryPoint */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\pow.h ===
/*DOC***
**
** Suite : step
** Test  : 
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
**
**
**
**DOC***/

#if defined( WIN32 )
#include <windows.h> 
#endif

double WINAPI dPow( int base, int power);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\DisAsm PP\DisAsm PP.cpp ===
#include <xtl.h> //xbox #include <windows.h>
#include <xmmintrin.h>

const float FLOAT_ZERO = 0;
__int64 GlobalInt64 = 0;

__int64 FloatVal[] =	//	32 bit register values for each integer
{
	3225419779,		//	-3
	3221225474,		//	-2	
	3212836866,		//	-1
	0,				//	0
	1065353218,		//	1
	1073741826,		//	2
	1077936131,		//	3
	1082130434,		//	4
	1084227586,		//	5
	1086324738,		//	6
	1088421890,		//	7	
	1090519041,		//	8
	1091567617,		//	9
	1092616193		//	10
};

__m128 Var128;

const int FLOATVAL_BASE = -3;

void ClearXMMReg(int regid);
void set_GlobalInt64(int Hi, int Low);
void set_XMMRegister(int regid, char upper, int Hi, int Low);
void set_XMMRegister(int regid, int X3, int X2, int X1, int X0);

void set_Register(int regid, __int64 regval);
void Test_MMX();
void Test_3dNow();
void Test_3dNowEnhanced();
void Test_Katmai();
void Test_WNI();

void __cdecl main()
{
	//	MMX & 3d Now! tests

	while(1)
	{
		Test_MMX(); // src.Find()
		Test_Katmai(); // src.Find()
	}
	
	return;							
}


void set_Register(int regid, __int64 regval)
{
	switch (regid)
	{
		case 0:		__asm { MOVQ MM0, regval }
					break;


		case 1:		__asm { MOVQ MM1, regval }
					break;


		case 2:		__asm { MOVQ MM2, regval }
					break;

		case 3:		__asm { MOVQ MM3, regval }
					break;


		case 4:		__asm { MOVQ MM4, regval }
					break;

		case 5:		__asm { MOVQ MM5, regval }
					break;

		case 6:		__asm { MOVQ MM6, regval }
					break;

		case 7:		__asm { MOVQ MM7, regval }
					break;

	}
}


void Test_MMX()
{
	//	MMX tests
	
	__int64 count = 0;
	__int32 iVar32 = 0;

	//	test all registers for visibility
	__asm {	MOVQ MM0,MM1 }
	__asm {	MOVQ MM1,MM2 }
	__asm {	MOVQ MM2,MM3 }
	__asm {	MOVQ MM3,MM4 }
	__asm {	MOVQ MM4,MM5 }
	__asm {	MOVQ MM5,MM6 }
	__asm {	MOVQ MM6,MM7 }
	__asm {	MOVQ MM7,MM0 }

	//	shift left
	__asm {	PSLLW MM0,count }
	__asm {	PSLLW MM0,MM1 }

	//	mov 32 bit
	__asm {	MOVD MM0,iVar32 }
	__asm {	MOVD iVar32,MM0 }
	__asm {	MOVQ MM0,count }	
	__asm {	MOVQ count,MM0 }	

	__asm {	MOVD MM0,eax }
	__asm {	MOVD eax,MM0 }
	__asm {	MOVQ MM0,MM1 }	
	
	//	Pack with Signed Saturation
	__asm {	PACKSSWB MM0,count }
	__asm {	PACKSSDW MM0,count }

	__asm {	PACKSSWB MM0,MM1 }
	__asm {	PACKSSDW MM0,MM1 }

	//	Pack with Unsigned Saturation	
	__asm {	PACKUSWB MM0,count }
	__asm {	PACKUSWB MM0,MM1 }

	//	Packed Add
	__asm {	PADDB MM0,count }
	__asm {	PADDW MM0,count }	
	__asm {	PADDD MM0,count }

	__asm {	PADDB MM0,MM1 }
	__asm {	PADDW MM0,MM1 }	
	__asm {	PADDD MM0,MM1 }

	//	Packed Add with Saturation
	__asm {	PADDSB MM0,count }
	__asm {	PADDSW MM0,count }

	__asm {	PADDSB MM0,MM1 }
	__asm {	PADDSW MM0,MM1 }

	//	Packed Add Unsigned with Saturation 
	__asm {	PADDUSB MM0,count }
	__asm {	PADDUSW MM0,count }

	__asm {	PADDUSB MM0,MM1 }
	__asm {	PADDUSW MM0,MM1 }

	//	Bitwise Logical And 
	__asm {	PAND MM0,count }
	__asm {	PAND MM0,MM1 }

	//	Bitwise Logical And Not 
	__asm {	PANDN MM0,count }
	__asm {	PANDN MM0,MM1 }

	//	Bitwise Logical Or
	__asm {	POR MM0,count }
	__asm {	POR MM0,MM1 }

	//	Compare for Equal 
	__asm {	PCMPEQB MM0,count }
	__asm {	PCMPEQW MM0,count }
	__asm {	PCMPEQD MM0,count }

	__asm {	PCMPEQB MM0,MM1 }
	__asm {	PCMPEQW MM0,MM1 }
	__asm {	PCMPEQD MM0,MM1 }

	//	Compare for Greater Than
	__asm {	PCMPGTB MM0,count }
	__asm {	PCMPGTW MM0,count }
	__asm {	PCMPGTD MM0,count }

	__asm {	PCMPGTB MM0,MM1 }
	__asm {	PCMPGTW MM0,MM1 }
	__asm {	PCMPGTD MM0,MM1 }

	//	Packed Multiply and Add 
	__asm {	PMADDWD MM0,count }
	__asm {	PMADDWD MM0,MM1 }

	//	Packed Multiply High
	__asm {	PMULHW MM0,count }
	__asm {	PMULHW MM0,MM1 }

	//	Packed Multiply Low
	__asm {	PMULLW MM0,count }
	__asm {	PMULLW MM0,MM1 }

	//	Packed Shift Left Logical
	__asm {	PSLLW MM0,count }
	__asm {	PSLLD MM0,count }
	__asm {	PSLLQ MM0,count }

	__asm {	PSLLW MM0,MM1 }
	__asm {	PSLLD MM0,MM1 }
	__asm {	PSLLQ MM0,MM1 }

	__asm {	PSLLW MM0,7 }
	__asm {	PSLLD MM0,7 }
	__asm {	PSLLQ MM0,7 }

	//	Packed Shift Right Arithmetic
	__asm {	PSRAW MM0,count }
	__asm {	PSRAD MM0,count }
	
	__asm {	PSRAW MM0,MM1 }
	__asm {	PSRAD MM0,MM1 }

	__asm {	PSRAW MM0,5 }
	__asm {	PSRAD MM0,5 }

	//	Packed Shift Right Logical
	__asm {	PSRLW MM0,count }
	__asm {	PSRLD MM0,count }
	__asm {	PSRLQ MM0,count }

	__asm {	PSRLW MM0,MM1 }
	__asm {	PSRLD MM0,MM1 }
	__asm {	PSRLQ MM0,MM1 }

	__asm {	PSRLW MM0,6 }
	__asm {	PSRLD MM0,6 }
	__asm {	PSRLQ MM0,6 }

	//	Packed Subtract
	__asm {	PSUBB MM0,count }
	__asm {	PSUBW MM0,count }
	__asm {	PSUBD MM0,count }

	__asm {	PSUBB MM0,MM1 }
	__asm {	PSUBW MM0,MM1 }
	__asm {	PSUBD MM0,MM1 }

	//	Packed Subtract with Saturation
	__asm {	PSUBSB MM0,count }
	__asm {	PSUBSW MM0,count }

	__asm {	PSUBSB MM0,MM1 }
	__asm {	PSUBSW MM0,MM1 }

	//	Packed Subtract Unsigned with Saturation
	__asm {	PSUBUSB MM0,count }
	__asm {	PSUBSW MM0,count }
	
	__asm {	PSUBUSB MM0,MM1 }
	__asm {	PSUBSW MM0,MM1 }
	
	//	Unpack High Packed Data
	__asm {	PUNPCKHBW MM0,count }	
	__asm {	PUNPCKHWD MM0,count }
	__asm {	PUNPCKHDQ MM0,count }
	
	__asm {	PUNPCKHBW MM0,MM1 }	
	__asm {	PUNPCKHWD MM0,MM1 }
	__asm {	PUNPCKHDQ MM0,MM1 }
	
	//	Unpack Low Packed Data
	__asm {	PUNPCKLBW MM0,iVar32 }
	__asm {	PUNPCKLWD MM0,iVar32 }
	__asm {	PUNPCKLDQ MM0,iVar32 }
	
	__asm {	PUNPCKLBW MM0,MM1 }
	__asm {	PUNPCKLWD MM0,MM1 }
	__asm {	PUNPCKLDQ MM0,MM1 }
	
	//	Bitwise Logical Exclusive OR
	__asm {	PXOR MM0,count }
	__asm {	PXOR MM0,MM1 }

}


void Test_3dNow()
{
	//	3d Now Tests

	__int64 count = 0;
	unsigned char int8 = 0;

	//	average of unsigned int bytes
	__asm {	PAVGUSB MM0,count }
	__asm {	PAVGUSB MM0,MM5 }

	//	float to 32 bit signed int
	__asm {	PF2ID MM0,count }
	__asm {	PF2ID MM0,MM5 }

	//	accumulator
	__asm {	PFACC MM0,count }
	__asm {	PFACC MM0,MM5 }

	//	add
	__asm {	PFADD MM0,count }
	__asm {	PFADD MM0,MM5 }

	//	compare for equal
	__asm {	PFCMPEQ MM0,count }
	__asm {	PFCMPEQ MM0,MM5 }

	//	compare for greater than or equal to
	__asm {	PFCMPGE MM0,count }
	__asm {	PFCMPGE MM0,MM5 }

	//	compare for greater than
	__asm {	PFCMPGT MM0,count }
	__asm {	PFCMPGT MM0,MM5 }
	
	//	maximum
	__asm {	PFMAX MM0,count }
	__asm {	PFMAX MM0,MM5 }

	//	minimum
	__asm {	PFMIN MM0,count }
	__asm {	PFMIN MM0,MM5 }

	//	multiply
	__asm {	PFMUL MM0,count }
	__asm {	PFMUL MM0,MM5 }
	
	//	reciprocal
	__asm {	PFRCP MM0,count }
	__asm {	PFRCP MM0,MM5 }

	//	reciprocal, reciprocal intermediate step 1, reciprocal intermediate step 2
	__asm {	PFRCPIT1 MM1,MM0 }
	__asm {	PFRCPIT2 MM0,MM1 }

	__asm {	PFRCPIT1 MM5,count }
	__asm {	PFRCPIT2 MM5,count }

	//	reciprocal sqrt
	__asm {	PFRSQRT MM0,count }
	__asm {	PFRSQRT MM0,MM5 }

	//	reciprocal sqrt, reciprocal sqrt intermediate step 1	
	__asm {	PFRSQIT1 MM1,MM0 }
	__asm {	PFRSQIT1 MM1,count }

	//	subtract
	__asm {	PFSUB MM0,count }
	__asm {	PFSUB MM0,MM5 }

	//	reverse subtraction
	__asm {	PFSUBR MM0,count }
	__asm {	PFSUBR MM0,MM5 }

	//	32 bit signed int to float
	__asm {	PI2FD MM0,count }
	__asm {	PI2FD MM0,MM5 }

	//	multiply high
	__asm {	PMULHRW MM0,count }
	__asm {	PMULHRW MM0,MM5 }

	int8 = 1;

	//	load a processor cache into data cache
	__asm {	PREFETCH int8 }

	//	same, sets MES state to modified
	__asm {	PREFETCHW int8 }

}


void Test_3dNowEnhanced()
{
	//	enhanced 3dnow tests

	__int64 count = 0;
	unsigned char count8 = 0;
	__int16 iVar16 = 0;

	//	packed float to int word with sign extend
	__asm {	PF2IW MM0,count }
	__asm {	PF2IW MM0,MM1 }

	//	packed float negative accumulate
	__asm {	PFNACC MM0,count }
	__asm {	PFNACC MM0,MM1 }

	//	packed float mixed +ve -ve accumulate
	__asm {	PFPNACC MM0,count }
 	__asm {	PFPNACC MM0,MM1 }
    
	//	packed int word to float
	//	somewhat erroneous values
	__asm {	PI2FW MM0,count }
	__asm {	PI2FW MM0,MM1 }

	//	packed swap double word
	__asm {	PSWAPD MM0,count }
	__asm {	PSWAPD MM0,MM1 }
	
	//	streaming store using byte mask
	//	DID NOT UNDERSTAND
	__asm {	MASKMOVQ MM0,MM1 }
	
	//	streaming store
	__asm {	MOVNTQ count,MM0 }
			
	//	packed avg of unsigned byte	
	__asm {	PAVGB MM0,count }
	__asm {	PAVGB MM0,MM1 }
	
	//	packed avg of unsigned word	
	__asm {	PAVGW MM0,count }
	__asm {	PAVGW MM0,MM1 }

	//	extract word into int register
	__asm {	PEXTRW EAX,MM0, 1 }

	//	insert word from int register
	__asm {	PINSRW MM0, EAX, 1 }
	__asm {	PINSRW MM0, iVar16, 1 }

	//	packed max signed word
	__asm {	PMAXSW MM0,count }	//	1431633926
	__asm {	PMAXSW MM0,MM1 }	//	1431633926
	
	//	packed max unsigned byte
	__asm {	PMAXUB MM0,count }	//	1834219928319
	__asm {	PMAXUB MM0,MM1 }	//	1834219928319
	
	//	packed min signed word
	__asm {	PMINSW MM0,count }	//	1431633921
	__asm {	PMINSW MM0,MM1 }	//	1431633921
	
	//	packed min unsigned byte	
	__asm {	PMINUB MM0,count }	//	730396487935
	__asm {	PMINUB MM0,MM1 }	//	730396487935
	
	//	move mask to integer register
	__asm {	PMOVMSKB EAX, MM0 }	//	EAX = 217
	
	//	packed multiply high unsigned word
	__asm {	PMULHUW MM0,count }	//	281474976841729
	__asm {	PMULHUW MM0,MM1 }	//	281474976841729

	//	prefetch non-temporal access
	__asm {	PREFETCHNTA count8 }
	
	//	prefetch to all cache levels
	__asm {	PREFETCHT0 count8 }
	
	//	prefetch to all cache levels except 0
	__asm {	PREFETCHT1 count8 }
	
	//	prefetch to all cache levels except 0 & 1
	__asm {	PREFETCHT2 count8 }

	//	packed sum of absolute byte differences
	__asm {	PSADBW MM0,count }	//	35
	__asm {	PSADBW MM0,MM1 }	//	35
	
	//	packed shuffle word
	__asm {	PSHUFW MM0,count,228 }	//	578437695752307201
	__asm {	PSHUFW MM0,MM1,225 }	//	578437695752307201
	
	// store fence
	__asm {	SFENCE }

}


void Test_Katmai()
{
	//	Katmai (PIII) tests
	
	float fVal = 0.0;
	__m128 mVar128 = {0,0,0,0};
	__int32 i32Val = 0;

	//	test all registers for visibility
	__asm { movss   xmm0, xmm1 }	//	0.0.0.9
	__asm { movss   xmm1, xmm2 }	//	0.0.0.9
	__asm { movss   xmm2, xmm3 }	//	0.0.0.9
	__asm { movss   xmm3, xmm4 }	//	0.0.0.9
	__asm { movss   xmm4, xmm5 }	//	0.0.0.9
	__asm { movss   xmm5, xmm6 }	//	0.0.0.9
	__asm { movss   xmm6, xmm7 }	//	0.0.0.9
	__asm { movss   xmm7, xmm0 }	//	0.0.0.9

	__asm { addps   xmm0, xmm1 }	//	XMM0 - 3,5,7,9
	__asm { addps   xmm0, mVar128 }	//	XMM0 - 3,5,7,9

	__asm { addss   xmm0, xmm1 }	//	1,2,3,9
	__asm { addss   xmm0, i32Val }	//	1,2,3,9

	__asm { andnps   xmm0, xmm1 }
	__asm { andnps   xmm0, mVar128 }

	__asm { andps   xmm0, xmm1 }	//	0
	__asm { andps   xmm0, mVar128 }	//	0

	__asm { cmpps   xmm0, xmm1, 0 }		//	eq
	__asm { cmpps   xmm0, xmm1, 1 }		//	lt
	__asm { cmpps   xmm0, xmm1, 2 }		//	le
	__asm { cmpps   xmm0, xmm1, 3 }		//	unord
	__asm { cmpps   xmm0, xmm1, 4 }		//	neq
	__asm { cmpps   xmm0, xmm1, 5 }		//	nlt
	__asm { cmpps   xmm0, xmm1, 6 }		//	nle
	__asm { cmpps   xmm0, xmm1, 7 }		//	ord
	
	__asm { cmpps   xmm0, mVar128, 0 }
	__asm { cmpps   xmm0, mVar128, 1 }
	__asm { cmpps   xmm0, mVar128, 2 }
	__asm { cmpps   xmm0, mVar128, 3 }
	__asm { cmpps   xmm0, mVar128, 4 }
	__asm { cmpps   xmm0, mVar128, 5 }
	__asm { cmpps   xmm0, mVar128, 6 }
	__asm { cmpps   xmm0, mVar128, 7 }

	__asm { cmpss   xmm0, xmm1, 0 }		//	eq
	__asm { cmpss   xmm0, xmm1, 1 }		//	lt
	__asm { cmpss   xmm0, xmm1, 2 }		//	le
	__asm { cmpss   xmm0, xmm1, 3 }		//	unord
	__asm { cmpss   xmm0, xmm1, 4 }		//	neq
	__asm { cmpss   xmm0, xmm1, 5 }		//	nlt
	__asm { cmpss   xmm0, xmm1, 6 }		//	nle
	__asm { cmpss   xmm0, xmm1, 7 }		//	ord
	
	__asm { cmpss   xmm0, i32Val, 0 }
	__asm { cmpss   xmm0, i32Val, 1 }
	__asm { cmpss   xmm0, i32Val, 2 }
	__asm { cmpss   xmm0, i32Val, 3 }
	__asm { cmpss   xmm0, i32Val, 4 }
	__asm { cmpss   xmm0, i32Val, 5 }
	__asm { cmpss   xmm0, i32Val, 6 }
	__asm { cmpss   xmm0, i32Val, 7 }

	__asm { cmpeqps   xmm0, xmm1 }	//	eq-eq-eq-eq
	__asm { cmpeqss   xmm0, xmm1 }	//	1,2,3,eq
	__asm { cmpltps   xmm0, xmm1 }	//	no-yes-no-no
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,yes
	__asm { cmpleps   xmm0, xmm1 }	//	yes,yes,no,no
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,yes
	__asm { cmpneqps  xmm0, xmm1 }	//	no,y,y,n
	__asm { cmpneqss   xmm0, xmm1 }	//	1,2,3,n
	__asm { cmpnltps   xmm0, xmm1 }	//	n,y,n,y
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,y
	__asm { cmpnleps   xmm0, xmm1 }	//	n,n,n,y
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,n

	__asm { comiss   xmm0, xmm1 }	//	1
	__asm { comiss   xmm0, i32Val }	//	1

	__asm { cvtpi2ps   xmm0, GlobalInt64 }	//	1,2,3,4
	__asm { cvtpi2ps   xmm0, mm0 }	//	1,2,3,4

	__asm { cvtps2pi   mm0, xmm0 }	//	MM0 has 2,5
	__asm { cvtps2pi   mm0, GlobalInt64 }	//	MM0 has 2,5

	__asm { cvtsi2ss   xmm0, eax }	//	1,2,3,17
	__asm { cvtsi2ss   xmm0, i32Val }	//	1,2,3,17

	__asm { cvtss2si   eax, xmm0 }	//	eax has 4
	__asm { cvtss2si   eax, i32Val }	//	eax has 4

	__asm { cvttps2pi   mm0, xmm0 }	//	MM0 has 7,5
	__asm { cvttps2pi   mm0, GlobalInt64 }	//	MM0 has 7,5

	__asm { cvttss2si   eax, xmm0 }	//	eax has 7
	__asm { cvttss2si   eax, i32Val }	//	eax has 7

	__asm { divps   xmm0, xmm1 }	//	0.5,1,3,4
	__asm { divps   xmm0, mVar128 }	//	0.5,1,3,4

	__asm { divss   xmm0, xmm1 }	//	1,2,3,5
	__asm { divss   xmm0, i32Val }	//	1,2,3,5

	__asm { maxps   xmm0, xmm1 }	//	5,2,9,5
	__asm { maxps   xmm0, mVar128 }	//	5,2,9,5

	__asm { maxss   xmm0, xmm1 }	//	5,2,7,6
	__asm { maxss   xmm0, i32Val }	//	5,2,7,6

	__asm { minps   xmm0, xmm1 }	//	4,2,7,3
	__asm { minps   xmm0, mVar128 }	//	4,2,7,3

	__asm { minss   xmm0, xmm1 }	//	1.2.3.4
	__asm { minss   xmm0, i32Val }	//	1.2.3.4

	__asm { movaps   xmm0, xmm1 }	//	5.5.5.5
	__asm { movaps   xmm0, mVar128 }	//	5.5.5.5
	__asm { movaps   mVar128, xmm1 }	//	5.5.5.5

	__asm { movhlps	 xmm0, xmm1 }	//	1,2,5,6

	__asm { movhps   xmm0, GlobalInt64 }	//	6.7.3.4
	__asm { movhps   GlobalInt64, xmm0 }	//	6.7.3.4

	__asm { movlps   xmm0, GlobalInt64 }	//	1.2.6.7
	__asm { movlps   GlobalInt64, xmm0 }	//	1.2.6.7

	__asm { movlhps   xmm0, xmm1 }	//	5.6.3.4

	__asm { movmskps   eax, xmm0 }	//	5

	__asm { movntps   mVar128, xmm0 }

	__asm { movss   xmm0, i32Val }	//	0.0.0.9
	__asm { movss   i32Val, xmm0 }	//	0.0.0.9
	__asm { movss   xmm0, xmm1 }	//	0.0.0.9

	__asm { movups   xmm0, xmm1 }	//	5,6,7,8
	__asm { movups   xmm0, mVar128 }	//	5,6,7,8
	__asm { movups   mVar128, xmm1 }	//	5,6,7,8

	__asm { mulps   xmm0, xmm1 }	//	2,6,0,10
	__asm { mulps   xmm0, mVar128 }	//	2,6,0,10

	__asm { mulss   xmm0, xmm1 }	//	1,2,3,8
	__asm { mulss   xmm0, i32Val }	//	1,2,3,8

	__asm { orps   xmm0, xmm1 }	//	1,x,y,z
	__asm { orps   xmm0, mVar128 }	//	1,x,y,z

	__asm { rcpps   xmm0, xmm1 }	//	1/2, 1/3, 1/4, 1/5
	__asm { rcpps   xmm0, mVar128 }	//	1/2, 1/3, 1/4, 1/5

	__asm { rcpss   xmm0, xmm1 }	//	1,2,3,1/2
	__asm { rcpss   xmm0, i32Val }	//	1,2,3,1/2

	__asm { rsqrtps   xmm0, xmm1 }	//	reciprocal 1,1.73,2,3
	__asm { rsqrtps   xmm0, mVar128 }	//	reciprocal 1,1.73,2,3

	__asm { rsqrtss   xmm0, xmm1 }	//	1,2,3, 1/3
	__asm { rsqrtss   xmm0, i32Val }	//	1,2,3, 1/3

	__asm { sfence }

	__asm { shufps   xmm0, xmm1, 114 }
	__asm { shufps   xmm0, mVar128, 115 }

	__asm { sqrtps   xmm0, xmm1 }	//	1,1.73,2,3
	__asm { sqrtps   xmm0, mVar128 }	//	1,1.73,2,3

	__asm { sqrtss   xmm0, xmm1 }	//	1,2,3,3
	__asm { sqrtss   xmm0, i32Val }	//	1,2,3,3

	__asm { stmxcsr  i32Val }
	__asm { ldmxcsr  i32Val }	//	1,2,3,5

	__asm { subps   xmm0, xmm1 }	//	-1,5,1,3
	__asm { subps   xmm0, mVar128 }	//	-1,5,1,3

	__asm { subss   xmm0, xmm1 }	//	1,8,5,-2
	__asm { subss   xmm0, i32Val }	//	1,8,5,-2

	__asm { ucomiss   xmm0, xmm1 }	//	0
	__asm { ucomiss   xmm0, i32Val }	//	0

	__asm { unpckhps   xmm0, xmm1 }	//	interleaved high - 5,1,6,2
	__asm { unpckhps   xmm0, mVar128 }	//	interleaved high - 5,1,6,2

	__asm { unpcklps   xmm0, xmm1 }	//	interleaved low - 7,3,8,4
	__asm { unpcklps   xmm0, mVar128 }	//	interleaved low - 7,3,8,4

	__asm { xorps   xmm0, xmm1 }	//	xor - 0,0,x,y
	__asm { xorps   xmm0, mVar128 }	//	xor - 0,0,x,y

}

void ClearXMMReg(int regid)
{

	switch(regid)
	{

	case 0:
		__asm { MOVSS XMM0, FLOAT_ZERO }
		break;

	case 1:
		__asm { MOVSS XMM1, FLOAT_ZERO }
		break;

	case 2:
		__asm { MOVSS XMM2, FLOAT_ZERO }
		break;

	case 3:
		__asm { MOVSS XMM3, FLOAT_ZERO }
		break;

	case 4:
		__asm { MOVSS XMM4, FLOAT_ZERO }
		break;

	case 5:
		__asm { MOVSS XMM5, FLOAT_ZERO }
		break;

	case 6:
		__asm { MOVSS XMM6, FLOAT_ZERO }
		break;

	case 7:
		__asm { MOVSS XMM7, FLOAT_ZERO }
		break;

	}

}

void set_GlobalInt64(int Hi, int Low)
{
	__int64 HiVal = FloatVal[Hi - FLOATVAL_BASE];
	__int64 LowVal = FloatVal[Low - FLOATVAL_BASE];

	GlobalInt64 = HiVal;
	GlobalInt64  = GlobalInt64 << 32;
	GlobalInt64 |= LowVal;
}

void set_XMMRegister(int regid, char upper, int Hi, int Low)
{

	switch (regid)
	{
		case 0:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM0, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM0, GlobalInt64 }
					}
					break;

		case 1:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM1, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM1, GlobalInt64 }
					}
					break;


		case 2:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM2, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM2, GlobalInt64 }
					}
					break;

		case 3:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM3, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM3, GlobalInt64 }
					}
					break;


		case 4:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM4, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM4, GlobalInt64 }
					}
					break;

		case 5:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM5, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM5, GlobalInt64 }
					}
					break;

		case 6:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM6, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM6, GlobalInt64 }
					}
					break;

		case 7:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM7, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM7, GlobalInt64 }
					}
					break;
	}
}


void set_XMMRegister(int regid, int X3, int X2, int X1, int X0)
{
	set_XMMRegister(regid, 1, X3, X2);	//	upper 64 bits
	set_XMMRegister(regid, 0, X1, X0);	//	lower 64 bits
}

void Test_WNI()
{
	__m128 mVar128 = {0,0,0,0};
	__m64 mVar64 = {0};

	__int8 mVar8;
	__int16 mVar16;
	__int32 mVar32;
	char arr[32];

	__asm
	{
		EMMS		
		
		ADDPD XMM0,XMM1
		ADDPD XMM2,XMM3
		ADDPD XMM4,XMM5
		ADDPD XMM6,XMM7
		ADDPD XMM1,XMM0
		ADDPD XMM3,XMM2
		ADDPD XMM5,XMM4
		ADDPD XMM7,XMM6
			
		ADDPD XMM0,XMM1
		ADDPD XMM0,mVar128
		
		ADDSD XMM0,XMM1
		ADDSD XMM0,mVar64

		ANDNPD XMM0,XMM1
		ANDNPD XMM0,mVar128
		
		ANDPD XMM0,XMM1
		ANDPD XMM0,mVar128
		
		CMPPD XMM0,XMM1, 0
		CMPPD XMM0,mVar128, 0
		CMPPD XMM0,XMM1, 1
		CMPPD XMM0,mVar128, 1
		CMPPD XMM0,XMM1, 2
		CMPPD XMM0,mVar128, 2
		CMPPD XMM0,XMM1, 3
		CMPPD XMM0,mVar128, 3
		CMPPD XMM0,XMM1, 4
		CMPPD XMM0,mVar128, 4
		CMPPD XMM0,XMM1, 5
		CMPPD XMM0,mVar128, 5
		CMPPD XMM0,XMM1, 6
		CMPPD XMM0,mVar128, 6
		CMPPD XMM0,XMM1, 7
		CMPPD XMM0,mVar128, 7
		
		CMPSD XMM0,XMM1, 0		
		CMPSD XMM0,mVar64, 0
		CMPSD XMM0,XMM1, 1		
		CMPSD XMM0,mVar64, 1
		CMPSD XMM0,XMM1, 2		
		CMPSD XMM0,mVar64, 2
		CMPSD XMM0,XMM1, 3		
		CMPSD XMM0,mVar64, 3
		CMPSD XMM0,XMM1, 4		
		CMPSD XMM0,mVar64, 4
		CMPSD XMM0,XMM1, 5		
		CMPSD XMM0,mVar64, 5
		CMPSD XMM0,XMM1, 6		
		CMPSD XMM0,mVar64, 6
		CMPSD XMM0,XMM1, 7		
		CMPSD XMM0,mVar64, 7
		
		COMISD XMM0,XMM1
		COMISD XMM0,mVar64
		
		CVTDQ2PD XMM0,XMM1
		CVTDQ2PD XMM0,mVar64

		CVTPD2PI MM0,XMM1	
		CVTPD2PI MM0,mVar128	
		
		CVTPD2DQ XMM0,XMM1	
		CVTPD2DQ XMM0,mVar128	

		
		CVTPD2PS XMM0,XMM1
		CVTPD2PS XMM0,mVar128
		
		CVTPI2PD XMM0,MM0
		CVTPI2PD XMM0,mVar64
		
		CVTPS2PD XMM0,XMM1
		CVTPS2PD XMM0,mVar64
		
		CVTSD2SI eax,XMM1
		CVTSD2SI eax,mVar64
		
		CVTSD2SS XMM0,XMM1
		CVTSD2SS XMM0,mVar64
		
		CVTSI2SD XMM0,eax
		CVTSI2SD XMM0,mVar32
		
		CVTSS2SD XMM0,XMM1
		CVTSS2SD XMM0,mVar32
		
		CVTTPD2PI MM0,XMM1
		CVTTPD2PI MM0,mVar128
		
		CVTTPD2DQ XMM0,XMM1
		CVTTPD2DQ XMM0,mVar128
		
		CVTTSD2SI eax,XMM1
		CVTTSD2SI eax,mVar64
		
		DIVPD XMM0,XMM1
		DIVPD XMM0,mVar128
		
		DIVSD XMM0,XMM1
		DIVSD XMM0,mVar64
		
		MAXPD XMM0,XMM1
		MAXPD XMM0,mVar128
		
		MAXSD XMM0,XMM1
		MAXSD XMM0,mVar64
		
		MINPD XMM0,XMM1
		MINPD XMM0,mVar128
		
		MINSD XMM0,XMM1
		MINSD XMM0,mVar64
		
		MOVAPD XMM0,XMM1
		MOVAPD XMM0,mVar128
		MOVAPD mVar128,XMM1
		
		MOVHPD XMM0,mVar64
		MOVHPD mVar64,XMM0
		
		MOVLPD XMM0,mVar64
		MOVLPD mVar64,XMM0
		
		MOVMSKPD eax,XMM1
		
		MOVSD XMM0,XMM1
		MOVSD XMM0,mVar64
		MOVSD mVar64,XMM1
		
		MOVUPD XMM0,XMM1
		MOVUPD XMM0,mVar128
		MOVUPD mVar128,XMM1
		
		MULPD XMM0,XMM1
		MULPD XMM0,mVar128
		
		MULSD XMM0,XMM1
		MULSD XMM0,mVar64
		
		ORPD XMM0,XMM1
		ORPD XMM0,mVar128
		
		SHUFPD XMM0,XMM1,8
		SHUFPD XMM0,mVar128,8
		
		SQRTPD XMM0,XMM1
		SQRTPD XMM0,mVar128
		
		SQRTSD XMM0,XMM1
		SQRTSD XMM0,mVar64
		
		SUBPD XMM0,XMM1
		SUBPD XMM0,mVar128
		
		SUBSD XMM0,XMM1
		SUBSD XMM0,mVar64
		
		UCOMISD XMM0,XMM1
		UCOMISD XMM0,mVar64
		
		UNPCKHPD XMM0,XMM1
		UNPCKHPD XMM0,mVar128
		
		UNPCKLPD XMM0,XMM1
		UNPCKLPD XMM0,mVar128
		
		XORPD XMM0,XMM1
		XORPD XMM0,mVar128

		
		CVTDQ2PS XMM0,XMM1
		CVTDQ2PS XMM0,mVar128

		CVTPS2DQ XMM0,XMM1
		CVTPS2DQ XMM0,mVar128

		CVTTPS2DQ XMM0,XMM1
		CVTTPS2DQ XMM0,mVar128

		//	not in manual
		CVTPI2PS XMM0,MM1
		CVTPI2PS XMM0,MM1

		//	not in manual
		CVTPS2PI MM0,XMM1
		CVTPS2PI MM0,XMM1
		
		//	not in manual
		CVTTPS2PI MM0,XMM1
		CVTTPS2PI MM0,XMM1
		
		MOVD XMM0,eax
		MOVD XMM0,mVar32
		MOVD eax,XMM1
		MOVD mVar32,XMM1
		
		MOVDQA XMM0,XMM1
		MOVDQA XMM0,mVar128
		MOVDQA mVar128,XMM1
		
		MOVDQU XMM0,XMM1
		MOVDQU XMM0,mVar128
		MOVDQU mVar128,XMM1
		
		MOVDQ2Q MM0,XMM1

		MOVQ2DQ XMM0,MM1
		
		MOVQ XMM0,XMM1
		MOVQ XMM0,mVar64
		MOVQ mVar64,XMM1

		PACKSSWB XMM0,XMM1
		PACKSSWB XMM0,mVar128
		
		PACKSSDW XMM0,XMM1
		PACKSSDW XMM0,mVar128
		
		PACKUSWB XMM0,XMM1
		PACKUSWB XMM0,mVar128
		
		PADDB XMM0,XMM1
		PADDB XMM0,mVar128
		
		PADDW XMM0,XMM1
		PADDW XMM0,mVar128
		
		PADDD XMM0,XMM1
		PADDD XMM0,mVar128
		
		PADDQ MM0,MM1
		PADDQ MM0,mVar64
		PADDQ XMM0,XMM1
		PADDQ XMM0,mVar128

		PADDSB XMM0,XMM1
		PADDSB XMM0,mVar128
		
		PADDSW XMM0,XMM1
		PADDSW XMM0,mVar128
		
		PADDUSB XMM0,XMM1
		PADDUSB XMM0,mVar128
		
		PADDUSW XMM0,XMM1
		PADDUSW XMM0,mVar128
		
		PAND XMM0,XMM1
		PAND XMM0,mVar128
		
		PANDN XMM0,XMM1
		PANDN XMM0,mVar128
		
		PAVGB XMM0,XMM1
		PAVGB XMM0,mVar128
		
		PAVGW XMM0,XMM1
		PAVGW XMM0,mVar128
		
		PCMPEQB XMM0,XMM1
		PCMPEQB XMM0,mVar128
		
		PCMPEQW XMM0,XMM1
		PCMPEQW XMM0,mVar128
		
		PCMPEQD XMM0,XMM1
		PCMPEQD XMM0,mVar128
		
		PCMPGTB XMM0,XMM1
		PCMPGTB XMM0,mVar128
		
		PCMPGTW XMM0,XMM1
		PCMPGTW XMM0,mVar128
		
		PCMPGTD XMM0,XMM1
		PCMPGTD XMM0,mVar128

		PEXTRW eax,XMM1,6

		PINSRW XMM0,mVar16,6
		PINSRW XMM0,eax,6
		
		PMADDWD XMM0,XMM1
		PMADDWD XMM0,mVar128

		PMAXSW XMM0,XMM1
		PMAXSW XMM0,mVar128

		PMAXUB XMM0,XMM1
		PMAXUB XMM0,mVar128
		
		PMINSW XMM0,XMM1
		PMINSW XMM0,mVar128
		
		PMINUB XMM0,XMM1
		PMINUB XMM0,mVar128
		
		PMOVMSKB eax,XMM1
		
		PMULHW XMM0,XMM1
		PMULHW XMM0,mVar128
		
		PMULHUW XMM0,XMM1
		PMULHUW XMM0,mVar128
		
		PMULLW XMM0,XMM1
		PMULLW XMM0,mVar128
		
		PMULUDQ MM0,MM1
		PMULUDQ MM0,mVar64
		PMULUDQ XMM0,XMM1
		PMULUDQ XMM0,mVar128
		
		POR XMM0,XMM1
		POR XMM0,mVar128
		
		PSADBW XMM0,XMM1
		PSADBW XMM0,mVar128
		
		PSHUFD XMM0,XMM1,8
		PSHUFD XMM0,mVar128,8
		
		PSHUFHW XMM0,XMM1,8
		PSHUFHW XMM0,mVar128,8
		
		PSHUFLW XMM0,XMM1,8
		PSHUFLW XMM0,mVar128,8
		
		PSLLDQ XMM0,8
		
		PSLLW XMM0,XMM1
		PSLLW XMM0,mVar128
		PSLLW XMM0,8
		
		PSLLD XMM0,XMM1
		PSLLD XMM0,mVar128
		PSLLD XMM0,8
		
		PSLLQ XMM0,XMM1
		PSLLQ XMM0,mVar128
		PSLLQ XMM0,8
		
		PSRAW XMM0,XMM1
		PSRAW XMM0,mVar128
		PSRAW XMM0,8
		
		PSRAD XMM0,XMM1
		PSRAD XMM0,mVar128
		PSRAD XMM0,8
		
		PSRLDQ XMM0,8
		
		PSRLW XMM0,XMM1
		PSRLW XMM0,mVar128
		PSRLW XMM0,8
		
		PSRLD XMM0,XMM1
		PSRLD XMM0,mVar128
		PSRLD XMM0,8
		
		PSRLQ XMM0,XMM1
		PSRLQ XMM0,mVar128
		PSRLQ XMM0,8
		
		PSUBB XMM0,XMM1
		PSUBB XMM0,mVar128
		
		PSUBW XMM0,XMM1
		PSUBW XMM0,mVar128
		
		PSUBD XMM0,XMM1
		PSUBD XMM0,mVar128

		PSUBQ MM0,MM1
		PSUBQ MM0,mVar64
		PSUBQ XMM0,XMM1
		PSUBQ XMM0,mVar128
		
		PSUBSB XMM0,XMM1
		PSUBSB XMM0,mVar128
		
		PSUBSW XMM0,XMM1
		PSUBSW XMM0,mVar128
		
		PSUBUSB XMM0,XMM1
		PSUBUSB XMM0,mVar128
		
		PSUBUSW XMM0,XMM1
		PSUBUSW XMM0,mVar128
		
		PUNPCKHBW XMM0,XMM1
		PUNPCKHBW XMM0,mVar128
		
		PUNPCKHWD XMM0,XMM1
		PUNPCKHWD XMM0,mVar128
		
		PUNPCKHDQ XMM0,XMM1
		PUNPCKHDQ XMM0,mVar128
		
		PUNPCKHQDQ XMM0,XMM1
		PUNPCKHQDQ XMM0,mVar128
		
		PUNPCKLBW XMM0,XMM1
		PUNPCKLBW XMM0,mVar128
		
		PUNPCKLWD XMM0,XMM1
		PUNPCKLWD XMM0,mVar128
		
		PUNPCKLDQ XMM0,XMM1
		PUNPCKLDQ XMM0,mVar128
		
		PUNPCKLQDQ XMM0,XMM1
		PUNPCKLQDQ XMM0,mVar128
		
		PXOR XMM0,XMM1
		PXOR XMM0,mVar128
		
		CLFLUSH mVar8
		push eax
		lea eax, dword ptr arr
		CLFLUSH  [eax]
		pop eax
		
		LFENCE

		MASKMOVDQU XMM0,XMM1
		
		MFENCE

		MOVNTPD mVar128,XMM1
		MOVNTDQ mVar128,XMM1

		MOVNTI mVar32, eax

		PAUSE
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\disasm\damthread.c ===
#include <xtl.h> //xbox #include <windows.h>
#include <math.h>

double FuncAcA(int nArg)
{
	return (double) (nArg*12);
}

LPTHREAD_START_ROUTINE ThreadRoutine(LPVOID pArg)
{
	int *nArg = (int*) pArg;
	*nArg += 25;
	
	SetLastError(1);
	while(1)
		sqrt(FuncAcA(*nArg));

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\base1.cpp ===
#include "base1.h"

int base1::base1_func(int i)
{
	return base1_var + i;
}

int base1::base1_virtual_func(int i)
{
	return base1_var + i;
}

int base1::base1_overloaded_func(int i)
{
	return base1_var + i;
}

int base1::base1_overridden_func(int i)
{
	return base1_var + i;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\base2.cpp ===
#include "base2.h"

// inherited, non-overloaded, non-overridden member function
int base2::base2_func(int i)
{
	return base2_var + i;
}

int base2::base2_virtual_func(int i)
{
	return base2_var + i;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\base1.h ===
class base1
{
protected:
	// inherited member variable.
	int base1_var;
public:
	base1(void){base1_var = 1;}
	int base1_func(int i);
	virtual int base1_virtual_func(int i);
	int base1_overloaded_func(int i);
	int base1_overridden_func(int i);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\base2.h ===
class base2
{
protected:
	int base2_var;
public:
	base2(void){base2_var = 2;}
	// inherited, non-overloaded, non-overridden member function
	int base2_func(int i);
	virtual int base2_virtual_func(int i);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\derived1.h ===
#include "base1.h"
#include "base2.h"

class derived1 : public base1, public base2
{
private:
	// private member variable.
	int derived1_private_var;
	// private member function.
	int derived1_private_func(int i);
protected:
	// protected member variable.
	int derived1_protected_var;
	// protected member function.
	int derived1_protected_func(int i);
public:
	// public member variable.
	int derived1_public_var;
	// class-nested enum.
	enum enum_class {one_class = 1, two_class, three_class};
	// declaration of class-nested enum var.
	enum_class enum_class_var;
	// static member variable.
	static int derived1_static_var;
	derived1(void);
	// non-inherited, non-overloaded member function.
	// public member function.
	int derived1_public_func(int i);
	// virtual inherited non-overloaded, overridden member function
	virtual int base1_virtual_func(int i);
	//static int derived1_static_func(int i);
	// inherited, overloaded, non-overridden member function
	int base1_overloaded_func(char ch);
	// inherited, non-overloaded, overridden member function
	int base1_overridden_func(int i);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\derived1.cpp ===
#include "derived1.h"

int derived1::derived1_static_var = 1;

derived1::derived1(void)
{
	derived1_public_var = base1_var + base2_var;
	enum_class_var = two_class;
	derived1_private_var = derived1_public_var + 1;
	derived1_protected_var = derived1_private_var + 1;
}

// non-inherited, non-overloaded member function.
int derived1::derived1_public_func(int i)
{
	return derived1_public_var + i;
}

// virtual inherited non-overloaded, overridden member function
int derived1::base1_virtual_func(int i)
{
	return derived1_public_var + i;
}

/*
int derived1::derived1_static_func(int i)
	{
	return derived_static_var + i;
	}
*/

// inherited, overloaded, non-overridden member function
int derived1::base1_overloaded_func(char ch)
{
	return derived1_public_var + ch;
}

// inherited, non-overloaded, overridden member function
int derived1::base1_overridden_func(int i)
{
	return derived1_public_var + i;
}

// protected member function.
int derived1::derived1_protected_func(int i)
{
	return derived1_public_var + i;
}

// private member function.
int derived1::derived1_private_func(int i)
{
	return derived1_public_var + i;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\dll.cpp ===
#include "dll.h"

dll_class::dll_class(void)
{
	dll_class_var = 0;
}

int dll_class::dll_class_func(int i)
{
	dll_class_var = i;
	return dll_class_var;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\dll.h ===
// class defined in dll
class dll_class
{
private:
	int dll_class_var;
public:
	__declspec(dllexport) dll_class(void);
	__declspec(dllexport) int dll_class_func(int i);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\global.cpp ===
#include "global.h"

// global variable.
int global_var = 0;

// non-overloaded global function.
int global_func(int i)
{
	return global_var + i;
}

// over-loaded global function.
int overloaded_global_func(int i)
{
	return global_var + i;
}

char overloaded_global_func(char ch)
{
	return global_var + ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\global.h ===
// global variable.
extern int global_var;

// enum (defined in header).
enum enum1{one = 1, two, three};

// non-overloaded global function.
int global_func(int i);
// overloaded global function.
int overloaded_global_func(int i);
char overloaded_global_func(char ch);
// inline function (defined in header).
inline int inline_func(int i){return global_var + i;};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\struct1.cpp ===
#include "struct1.h"

struct1::struct1(void)
	{
	struct1_var = 0;
	}

int struct1::struct1_func(int i)
	{
	struct1_var = i;
	return struct1_var;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\powdll.c ===
/*DOC***
**
** Suite : 
** Test  : 
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
** M001 30-Jun-92	waltcr
** - add local var
**
**
**
**DOC***/

#if defined( WIN )
#include <windows.h>
#endif //WIN

#include "dec.h"
#include "pow.h"
#include "cvtest.h"

double WINAPI dPow(int base, int power) {
	
	int i;
	double result;
	/* note: don't handle zero's */
	if (power==0)
		return 1;
	if (base==0)
		return 0;
	for (result=base,i=1;i<power;i++)
		result *= base;

	return result;
} /* pow */


INT WINAPI DllMain(HMODULE hInst, DWORD ulRbc, LPVOID lpReserved) {
// ulRbc is Reason Being Called
	return 1;
} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\struct1.h ===
// struct (declared in header)
struct struct1
		{
		private:
			int struct1_var;
		public:
			struct1(void);
			int struct1_func(int i);
		};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\union1.cpp ===
#include "union1.h"

union1::union1(void)
	{
	union1_var = 0;
	}

int union1::union1_func(int i)
	{
	union1_var = i;
	return union1_var;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\dec2.c ===
/*DOC***
**
** Suite : bvt
** Test  : dec2.c
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
** M001 30-Jun-92	waltcr
** - add local var
**
**
**
**DOC***/

#if defined( WIN )
#include <windows.h>
#endif //WIN

#include "dec.h"
#include "inc.h"
#include "pow.h"
#include "cvtest.h"

typedef double (APIENTRY *PFNDLL)(int,int);

void WINAPI Dec( LPWORD wBar ) {

	WORD wLocal;
	HANDLE  hDLL;
	PFNDLL dpfnPow;
	double dValue;
	char sz[80];

SAVELABEL( TagDecRet );
SAVELABEL( TagAfterGetProcAddr );
SAVELABEL( TagCallPow );

	wLocal = ++(*wBar);
	--(*wBar);
	Inc(wBar);   // call another implib'd dll.

	/* do a loadlibrary of another dll from this dll */
	TagLoadLib: hDLL = LoadLibrary("POWDLL.DLL");
	if( hDLL != NULL )
	{
		dpfnPow = (PFNDLL) GetProcAddress(hDLL, "dPow");
TagAfterGetProcAddr:
		if (dpfnPow)
		{
TagCallPow:		dValue = dpfnPow( 10, 3 );
TagAfterPow:	dValue = dValue+1;
		}
		FreeLibrary(hDLL);
	}

TagDecRet: ; } /* Dec */


INT WINAPI DllEntryPoint(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) {
// ulRbc is Reason Being Called
	return 1;
} /* DllEntryPoint */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\dllapp\dllappx.c ===
/*DOC***
**
** Suite : bvt
** Test  : dllappx.c
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx dd-Mon-yy       email name
** - description
** M000 28-Jun-92       waltcr
** - created
**
**
**
**DOC***/

#include <windows.h>   // required for all Windows applications
#include "dllapp.h"   // specific to this program
#include "dec.h"
#include "cvtest.h"

HINSTANCE hInst;        /* current instance */

char szAppName[] = "DllApp";
char szTitle[]   = "DllApp"; // The title bar text
int gi[5] = {0, 0, 0, 0, 0}; // some data for testing


/***
** for testing
*/

WORD   wValue = 10;
HANDLE hGlobalMem = NULL;
LPSTR  lpstr;

/***
**
**      FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
**
**      PURPOSE: calls initialization function, processes message loop
**
**      COMMENTS:
**
**              Windows recognizes this function by name as the initial entry point
**              for the program.  This function calls the application initialization
**              routine, if no other instance of the program is running, and always
**              calls the instance initialization routine.      It then executes a message
**              retrieval and dispatch loop that is the top-level control structure
**              for the remainder of execution.  The loop is terminated when a WM_QUIT
**              message is received, at which time this function exits the application
**              instance by returning the value passed by PostQuitMessage().
**
**              If this function must abort before entering the message loop, it
**              returns the conventional value NULL.
**
*/

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
	MSG msg;        /* message */

	if (!hPrevInstance)             /* Other instances of app running? */
		if (!InitApplication(hInstance))        /* Initialize shared things */
			return (FALSE);         /* Exits if unable to initialize */

	/* Perform initializations that apply to a specific instance */
	if (!InitInstance(hInstance, nCmdShow))
		return (FALSE);

	/* Acquire and dispatch messages until a WM_QUIT message is received. */
	while (GetMessage(&msg,         /* message structure */
		NULL,   /* handle of window receiving the message */
		0,   /* lowest message to examine    */
		0))  /* highest message to examine   */
	{
		TranslateMessage(&msg);         /* Translates virtual key codes           */
		DispatchMessage(&msg);          /* Dispatches message to window           */
	}
	return (msg.wParam);            /* Returns the value from PostQuitMessage */
}


/***
**
**      FUNCTION: InitApplication(HANDLE)
**
**      PURPOSE: Initializes window data and registers window class
**
**      COMMENTS:
**
**              This function is called at initialization time only if no other
**              instances of the application are running.  This function performs
**              initialization tasks that can be done once for any number of running
**              instances.
**
**              In this case, we initialize a window class by filling out a data
**              structure of type WNDCLASS and calling the Windows RegisterClass()
**              function. Since all instances of this application use the same window
**              class, we only need to do this when the first instance is initialized.
**
**
*/

BOOL InitApplication(HINSTANCE hInst) {
	WNDCLASS  wc;

	/* Fill in window class structure with parameters that describe the
		main window. */

	wc.style = 0;                                /* Class style(s) */
	wc.lpfnWndProc = MainWndProc;   /* Func to retrieve msgs for  */
									/* windows of this class */
	wc.cbClsExtra = 0;                              /* No per-class extra data */
	wc.cbWndExtra = 0;                              /* No per-window extra data */
	wc.hInstance = hInst;               /* Application that owns the class */
	wc.hIcon = LoadIcon(hInst, szAppName); // Icon name from .rc
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName =  szAppName;   /* Name of menu resource in .RC file. */
	wc.lpszClassName = szAppName;   /* Name used in call to CreateWindow. */

	/* Register the window class and return success/failure code. */
	return (RegisterClass(&wc));
}

/***
**
**      FUNCTION:  InitInstance(HANDLE, int)
**
**      PURPOSE:  Saves instance handle and creates main window
**
**      COMMENTS:
**
**              This function is called at initialization time for every instance of
**              this application.  This function performs initialization tasks that
**              cannot be shared by multiple instances.
**
**              In this case, we save the instance handle in a static variable and
**              create and display the main program window.
**        
*/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) {
	HWND    hWnd;   /* Main window handle */

	/* Save the instance handle in static variable, which will be used in
	   many subsequent calls from this application to Windows.      */

	hInst = hInstance;

	/* Create a main window for this application instance.  */

	hWnd = CreateWindow(
		szAppName,      /* See RegisterClass() call */
		szTitle,        /* Text for window title bar */
		WS_OVERLAPPEDWINDOW,    /* Window style */
		CW_USEDEFAULT,  /* Default horizontal position */
		CW_USEDEFAULT,  /* Default vertical position */
		CW_USEDEFAULT,  /* Default width */
		CW_USEDEFAULT,  /* Default height */
		NULL,   /* Overlapped windows have no parent */
		NULL,   /* Use the window class menu */
		hInstance,      /* This instance owns this window */
		NULL    /* Pointer not needed */
    );

	/* If window could not be created, return "failure" */

	if (!hWnd)
		return (FALSE);

	/* Make the window invisible; update its client area; and return "success" */

	ShowWindow(hWnd, SW_HIDE);             /* Show the window */
	UpdateWindow(hWnd);     /* Sends WM_PAINT message */
	SendMessage(hWnd, WM_NULL, 0, 0);
	return (TRUE);  /* Returns the value from PostQuitMessage */
}

/***
**
**      FUNCTION: MainWndProc(HWND, UINT, UINT, LONG)
**
**      PURPOSE:  Processes messages
**
**      MESSAGES:
**
**              WM_COMMAND        - application menu (About dialog box)
**              WM_DESTROY        - destroy window
**
**      COMMENTS:
**
**              To process the IDM_ABOUT message, call MakeProcInstance() to get the
**              current instance address of the About() function.  Then call Dialog
**              box which will create the box according to the information in your
**              DllApp.rc file and turn control over to the About() function.   When
**              it returns, free the intance address.
**
*/

LONG APIENTRY MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam) {
	FARPROC lpProcAbout;              /* pointer to the "About" function */

    HDC         hdc ;
    PAINTSTRUCT ps ;
	RECT            rect ;

	SAVELABEL( CALLDLLATSTART );
	SAVELABEL( CALLDLLATTERM );
	SAVELABEL( TagEndPaint );

	switch (message)
	{
		case WM_COMMAND:        /* message: command from application menu */
			switch( wParam )
			{
				case IDM_ABOUT:
					lpProcAbout = MakeProcInstance(About, hInst);
	
					DialogBox(hInst,                 /* current instance             */
						"AboutBox",                      /* resource to use              */
						hWnd,                    /* parent handle                */
						lpProcAbout);            /* About() instance address */
		
					FreeProcInstance(lpProcAbout);
					break;
	
				case IDM_EXIT:
					DestroyWindow(hWnd);
					break;
			}
			break;

		case WM_NULL:
TagEndPaint:return 0 ;
			break;	

		case WM_PAINT:
			hdc = BeginPaint (hWnd, &ps) ;
			GetClientRect (hWnd, &rect) ;
			DrawText (hdc, "DLL Application", -1, &rect,
				DT_SINGLELINE | DT_CENTER | DT_VCENTER);
			EndPaint (hWnd, &ps) ;
			return 0;
			break;

		case WM_CREATE:

			// a func call for testing purposes
CALLDLLATSTART:
			Dec( &wValue );

			/*
			** some arbitrary code for testing purposes
			*/
			if ( hGlobalMem = GlobalAlloc( GMEM_MOVEABLE, 100L ) )
			{
				if ( lpstr = GlobalLock( hGlobalMem ) )
				{
					lstrcpy( lpstr, "The Walt-Meister" );
					GlobalUnlock( hGlobalMem );
					// TODO: check return code?
					//
					//  You can display the contents of the string with the 
					//  following sequence of codeview commands:
					// 
					//  >wgh hGlobalMem
					//  0192:6E30
					//  >? *(char far*) 0x0192:0x6E30,s
				}
			}


			BPWithLengthTest();

			break;
	
		case WM_DESTROY:                  /* message: window being destroyed */
			// a func call for testing purposes
CALLDLLATTERM:
			Dec( &wValue );
			if (hGlobalMem)
				GlobalFree(hGlobalMem);
				// TODO: check return code ?
			PostQuitMessage(0);
			break;

		default:                          /* Passes it on if unproccessed        */
			return (DefWindowProc(hWnd, message, wParam, lParam));
	}
	return 0;
}

/***
**
**      FUNCTION: About(HWND, UINT, UINT, LONG)
**
**      PURPOSE:  Processes messages for "About" dialog box
**
**      MESSAGES:
**
**              WM_INITDIALOG - initialize dialog box
**              WM_COMMAND        - Input received
**
**      COMMENTS:
**
**              No initialization is needed for this particular dialog box, but TRUE
**              must be returned to Windows.
**
**              Wait for user to click on "Ok" button, then close the dialog box.
**
*/

BOOL APIENTRY About(HWND hDlg, UINT message, UINT wParam, LONG lParam) {
	switch (message)
	{
		case WM_INITDIALOG:             /* message: initialize dialog box */
		{
			/*
			** some arbitrary code for testing
			*/
			HANDLE hLocalMem = NULL;
			int i;
			char *   pMem;
			char *   pTmp;
			if ( hLocalMem = LocalAlloc( LMEM_MOVEABLE, 100 ) );
			{
				if (pMem = LocalLock( hLocalMem ));
				{
					/* now locked, so mucked with it */
					pTmp = pMem;
					for (i=0; i<20; i++)
					{
						*pTmp = 'w';
						++pTmp;
					}
					LocalUnlock( hLocalMem );
					// TODO: check return code ?
					}
			}
		 
			//  Now, after setting a breakpoint immediately after the call to LocalLock,
			//  the following command displays the array location:
			// 
			//  >dw pnArray
			// 
			//  Outside of this fragment, though, you cannot rely on the value of the
			//  pnArray variable since the actual data in the memory object may move.
			//  Therefore, use the following sequence to display the correct array
			//  location:
			//  >wlh hLocalMem 
			//  0192:100A
			//  dw 0192:100A

			if ( hLocalMem )
				LocalFree( hLocalMem );  //TODO: check return code ?

			CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
			return (TRUE);
			break;
		}

		case WM_COMMAND:        /* message: received a command */
			if (wParam == IDOK || wParam == IDCANCEL)
			{
				EndDialog(hDlg, TRUE);  /* Exits the dialog box */
				return (TRUE);
			}
			break;
	}
	return (FALSE);         /* Didn't process a message */
}

/***
**
**      FUNCTION: CenterWindow (HWND, HWND)
**
**      PURPOSE:  Center one window over another
**
**      COMMENTS:
**
**      Used to center the "About" box over application window
**      Dialog boxes take on the screen position that they were designed at,
**      which is not always appropriate. Centering the dialog over a particular
**      window usually results in a better position.
**
**      Used to center the "About" box over application window.
**
*/

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
	RECT    rChild, rParent;
	int     wChild, hChild, wParent, hParent;
	int     wScreen, hScreen, xNew, yNew;
	HDC     hdc;

	// Get the Height and Width of the child window
	GetWindowRect (hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// Get the Height and Width of the parent window
	GetWindowRect (hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// Get the display limits
	hdc = GetDC (hwndChild);
	wScreen = GetDeviceCaps (hdc, HORZRES);
	hScreen = GetDeviceCaps (hdc, VERTRES);
	ReleaseDC (hwndChild, hdc);

	// Calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) /2);
	if (xNew < 0) {
		xNew = 0;
	} else if ((xNew+wChild) > wScreen) {
		xNew = wScreen - wChild;
	}

	// Calculate new Y position, then adjust for screen
	yNew = rParent.top  + ((hParent - hChild) /2);
	if (yNew < 0) {
		yNew = 0;
	} else if ((yNew+hChild) > hScreen) {
		yNew = hScreen - hChild;
	}

	// Set it, and return
	return SetWindowPos (hwndChild, NULL,
		xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


void BPWithLengthTest(void)
{
	START:  
	gi[4]=99;
	gi[2]=99;  // breakpoint should fire for this line/instruction, but stop on the next line/instruction
	BREAK:     // tagged with the BREAK label
	gi[2]=0; gi[3]=99;  
	END:
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\union1.h ===
// union (declared in header)
union union1
		{
		private:
			int union1_var;
		public:
			union1(void);
			int union1_func(int i);
		};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\fibon\dll.cpp ===
#include "dll.h"

dll_class::dll_class(void)
{
	dll_class_var = 0;
}

int dll_class::dll_class_func(int i)
{
	dll_class_var = i;
	char *argv[]= {"damn dll", "4", "2"};

	while(i-->0)
		fiboncases(3,argv);

	return dll_class_var;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\fibon\dll.h ===
enum CALLTYPE{ __INT64=0, UNSIGNED, SIGNEDLONG};

class __declspec(dllexport) dll_class
	{
		private:
			int dll_class_var;

			__int64 fibon(__int64 n);
			long fibon(unsigned int u);
			long fibon(long m);
			long fibon(float f);
			__int64 fibontype(__int64 n, CALLTYPE type = UNSIGNED);
			int average(int first, ...);
			double factorial(double nn);
			void fiboncases(int argc, char *argv[]);

		public:
			/*__declspec(dllexport)*/ dll_class(void);
			/*__declspec(dllexport)*/ int dll_class_func(int i);
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\pch.h ===
// classed declared in .pch file.
class class_pch
	{
	private:
		int class_pch_var;
	public:
		class_pch(void);
		int class_pch_func(int i);
	};

// struct declared in .pch file.
struct struct_pch
	{
	private:
		int struct_pch_var;
	public:
		struct_pch(void);
		int struct_pch_func(int i);
	};

// union declared in .pch file.
union union_pch
	{
	private:
		int union_pch_var;
	public:
		union_pch(void);
		int union_pch_func(int i);
	};

// enum decalred in a .pch file.
enum enum_pch {one_pch = 1, two_pch, three_pch};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\fibon\fib.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
//placeholders for types
long g_long=1;
int  g_int=2;
unsigned int g_unsigned=3;
__int64 g__int64=4;
double  g_double=5.0;

enum CALLTYPE{ __INT64=0, UNSIGNED, SIGNEDLONG};


__int64 fibon(__int64 n)
{
	if(n==0)
		return 1;
	if(n==1)
		return 1;
	return fibon(n-2) + fibon(n-1);
}


long fibon(unsigned int u)
{ //funny thing: return the -fib(u)
	if(u==0)
		return -1;
	if(u==1)
		return -1;
	return -(fibon(u-2) + fibon(u-1));
}


long fibon(long m)
{
	if(m==0)
		return 1;
	int fib0=0;
	int fib1=1;

	for(int i=0; i<m; i++)
	{
		long temp = fib0;
		fib0 = fib1;
		fib1 = temp + fib1;
		/* fib0 += fib1; fib1 = fib0 - fib1 */
	}
	return fib1;
}


__int64 fibontype(__int64 n, CALLTYPE type = UNSIGNED)
{
	__int64 result=0;
	switch(type)
	{
	case __INT64: result = fibon(__int64(n));
		break;
	case UNSIGNED: result = fibon(unsigned int(n));
		break;
	case SIGNEDLONG: result = fibon(long(n));
	}
	return result;
}


//****************************************************************************
// Purpose:     function returning address and has ... parameter
int average(int first, ...)
{
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != INT_MIN)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

/*template <long nn>
long factorial(long  nn)
{ 
	return nn*factorial<nn-1>(nn-1); 
}

template<> long factorial<0>(long n)
{ return 1; }*/
double factorial(double nn)
{
	return (nn<=1)?1:factorial(nn-1)*nn;
}


//long fact(long)
//	long fact = factorial<40>(40);
//	double fact = factorial(m);

void fiboncases(int argc, char *argv[])
{

	__int64 nint64=(argc>1)?atoi(*(argv+1)):0; //arg for recursive fibon
	long nlong=1;
	long m=(argc>2)?atoi(*(argv+2)):0; //arg for norec fibon

	long tlong = fibon(5u);
	__int64 fib=0;
	fib=fibon(4i64);
	fib=fibon(g_unsigned);
	fib=fibon(nlong);
	fib=fibontype(fibon(4u), __INT64);
	double dresult = factorial( fibon(nlong));
	printf("fibon(%d):%d\n",nint64,fib);
	fib=fibon(m);
	printf("no rec fibon(%d):%d\n",m,fib);
	printf("Average:%d\n",average(1,2,3,4,5,6,7,8, INT_MIN) );
}


void main(int argc, char *argv[])
{
	for(int i=0;i<10;i++)
		fiboncases(argc,argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\fibon\driverdll.cpp ===
#include "dll.h"


void main(int argc, char *argv[])
{
	dll_class theClass;
	theClass.dll_class_func(5);
	theClass.dll_class_func(1);
	theClass.dll_class_func(10);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\fibon\fibon.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
//placeholders for types
long g_long=1;
int  g_int=2;
unsigned int g_unsigned=3;
__int64 g__int64=4;
double  g_double=5.0;


#ifdef DLL_CLASS
#include "dll.h"
#else
	enum CALLTYPE{ __INT64=0, UNSIGNED, SIGNEDLONG};
	__int64 fibontype(__int64 n, CALLTYPE type = UNSIGNED);
#endif

__int64
#ifdef DLL_CLASS
	dll_class::
#endif
fibon(__int64 n)
{
	if(n==0)
		return 1;
	if(n==1)
		return 1;
	return fibon(n-2) + fibon(n-1);
}


long
#ifdef DLL_CLASS
	dll_class::
#endif
fibon(float f)
{
	__int64 n=abs(static_cast<__int64>(f));
	return fibon((n));
}

long
#ifdef DLL_CLASS
	dll_class::
#endif
fibon(unsigned int u)
{ //funny thing: return the -fib(u)
	if(u==0)
		return -1;
	if(u==1)
		return -1;
	return -(fibon(u-2) + fibon(u-1));
}


long
#ifdef DLL_CLASS
	dll_class::
#endif
fibon(long m)
{
	if(m==0)
		return 1;
	int fib0=0;
	int fib1=1;

	for(int i=0; i<m; i++)
	{
		long temp = fib0;
		fib0 = fib1;
		fib1 = temp + fib1;
		/* fib0 += fib1; fib1 = fib0 - fib1 */
	}
	return fib1;
}


__int64
#ifdef DLL_CLASS
	dll_class::
#endif
fibontype(__int64 n, CALLTYPE type /*= UNSIGNED*/)
{
	__int64 result=0;
	switch(type)
	{
	case __INT64: result = fibon(__int64(n));
		break;
	case UNSIGNED: result = fibon(unsigned int(n));
		break;
	case SIGNEDLONG: result = fibon(long(n));
	}
	return result;
}


//****************************************************************************
// Purpose:     function returning address and has ... parameter
int
#ifdef DLL_CLASS
	dll_class::
#endif
average(int first, ...)
{
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != INT_MIN)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

/*template <long nn>
long factorial(long  nn)
{ 
	return nn*factorial<nn-1>(nn-1); 
}

template<> long factorial<0>(long n)
{ return 1; }*/
double 
#ifdef DLL_CLASS
	dll_class::
#endif
factorial(double nn)
{
	return (nn<=1)?1:factorial(nn-1)*nn;
}


//long fact(long)
//	long fact = factorial<40>(40);
//	double fact = factorial(m);

void 
#ifdef DLL_CLASS
	dll_class::
#endif
fiboncases(int argc, char *argv[])
{

	__int64 nint64=(argc>1)?atoi(*(argv+1)):0; //arg for recursive fibon
	long nlong=1;
	long m=(argc>2)?atoi(*(argv+2)):0; //arg for norec fibon

	long tlong = fibon(5u);
	__int64 fib=0;
	fib=fibon(4i64);
	fib=fibon(g_unsigned);
	fib=fibon(nlong);
	fib=fibontype(fibon(4u), SIGNEDLONG);
	double dresult = factorial( fibon(nlong));
	fibon((float)dresult);
	printf("fibon(%d):%d\n",nint64,fib);
	fib=fibon(m);
	printf("no rec fibon(%d):%d\n",m,fib);
	printf("Average:%d\n",average(0,fibon(g_unsigned),3,4,5,6,7,8, INT_MIN) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\fibon\main.cpp ===
extern void fiboncases(int argc, char *argv[]);


void main(int argc, char *argv[])
{
	for(int i=0;i<10;i++)
		fiboncases(argc,argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\pch.cpp ===
#include "pch.h"

class_pch::class_pch(void)
	{
	class_pch_var = 0;
	}

int class_pch::class_pch_func(int i)
	{
	class_pch_var = i;
	return class_pch_var;
	}

struct_pch::struct_pch(void)
	{
	struct_pch_var = 0;
	}

int struct_pch::struct_pch_func(int i)
	{
	struct_pch_var = i;
	return struct_pch_var;
	}

union_pch::union_pch(void)
	{
	union_pch_var = 0;
	}

int union_pch::union_pch_func(int i)
	{
	union_pch_var = i;
	return union_pch_var;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\fibon\testf.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
//placeholders for types
long g_long=1;
int  g_int=2;
unsigned int g_unsigned=3;
__int64 g__int64=4;
double  g_double=5.0;

enum CALLTYPE{ __INT64=0, UNSIGNED, SIGNEDLONG};


__int64 fibon(__int64 n)
{
	if(n==0)
		return 1;
	if(n==1)
		return 1;
	return fibon(n-2) + fibon(n-1);
}


long fibon(unsigned int u)
{ //funny thing: return the -fib(u)
	if(u==0)
		return -1;
	if(u==1)
		return -1;
	return -(fibon(u-2) + fibon(u-1));
}


long fibon(long m)
{
	if(m==0)
		return 1;
	int fib0=0;
	int fib1=1;

	for(int i=0; i<m; i++)
	{
		long temp = fib0;
		fib0 = fib1;
		fib1 = temp + fib1;
		/* fib0 += fib1; fib1 = fib0 - fib1 */
	}
	return fib1;
}


__int64 fibontype(__int64 n, CALLTYPE type = UNSIGNED)
{
	__int64 result=0;
	switch(type)
	{
	case __INT64: result = fibon(__int64(n));
		break;
	case UNSIGNED: result = fibon(unsigned int(n));
		break;
	case SIGNEDLONG: result = fibon(long(n));
	}
	return result;
}


//****************************************************************************
// Purpose:     function returning address and has ... parameter
int average(int first, ...)
{
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != INT_MIN)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

/*template <long nn>
long factorial(long  nn)
{ 
	return nn*factorial<nn-1>(nn-1); 
}

template<> long factorial<0>(long n)
{ return 1; }*/
double factorial(double nn)
{
	return (nn<=1)?1:factorial(nn-1)*nn;
}


//long fact(long)
//	long fact = factorial<40>(40);
//	double fact = factorial(m);

void fiboncases(int argc, char *argv[])
{

	__int64 nint64=(argc>1)?atoi(*(argv+1)):0; //arg for recursive fibon
	long nlong=1;
	long m=(argc>2)?atoi(*(argv+2)):0; //arg for norec fibon

	long tlong = fibon(5u);
	__int64 fib=0;
	fib=fibon(4i64);
	fib=fibon(g_unsigned);
	fib=fibon(nlong);
	fib=fibontype(fibon(4u), SIGNEDLONG);
	double dresult = factorial( fibon(nlong));
	printf("fibon(%d):%d\n",nint64,fib);
	fib=fibon(m);
	printf("no rec fibon(%d):%d\n",m,fib);
	printf("Average:%d\n",average(0,fibon(g_unsigned),3,4,5,6,7,8, INT_MIN) );
}


void main(int argc, char *argv[])
{
	for(int i=0;i<10;i++)
		fiboncases(argc,argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\execution pri1\execution pri1 exe.cpp ===
// first line of source file


#include <xtl.h>


LPARAM CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


int gintVar = 0;
int gintDenominator = 1;
HWND ghWnd;


void Func(void)

{	// first line of Func().

	gintVar = 1;
	while(0);	// line after expression bp hit.
}


void FuncCalledIndirectly(void)
{	// first line of FuncCalledIndirectly().
}


int InnerFunc(void)
{	// first line of InnerFunc().
	return 0;
}


void OuterFunc(int i)
{	// first line of OuterFunc().
}


void SendMessageFunc(void)
{	// first line of SendMessageFunc().
	//SendMessage(ghWnd, WM_NULL, 0, 0);
	int i = 0;
}


void __cdecl main()

{	// first line of main().

	while(0);	// second line of main().

	Func();
	while(0);	// line after call to Func().

	void (*pFuncCalledIndirectly)(void) = FuncCalledIndirectly;
	pFuncCalledIndirectly();

	OuterFunc(InnerFunc());

	_asm
	{
		push eax
		pop eax
	}

	int i = 1 / gintDenominator;

	/*
	WNDCLASS wndclass;
	wndclass.style = 0;
	wndclass.lpfnWndProc = WndProc;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.hInstance = hInstance;
	wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = "exepri1";
	RegisterClass(&wndclass);

	ghWnd = CreateWindow("exepri1", "exepri1", WS_OVERLAPPEDWINDOW, 
						 CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
						 NULL, NULL, hInstance, NULL);
	*/

	SendMessageFunc();
	
	while(1);	// loop line.
	
	while(0);	// return from main().

	while(1);	// returned from main().

	return;
}


/*
LPARAM CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
	
{	// first line of WndProc().
	switch(msg)
	{	
		case WM_NULL:
			return 0;
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
	}

	return DefWindowProc(hwnd, msg, wParam, lParam);
}
*/



/* 
START: for tests that require scrolling code out of view.












































END: for tests that require scrolling code out of view.
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee\ee.cpp ===
#include <xtl.h> //xbox #include <windows.h>
#include "derived1.h"
#include "struct1.h"
#include "union1.h"
#include "global.h"
#include "pch.h"
//#include "dll.h"


namespace namespace1
	
{
	// namespace variable.
	int namespace1_var = 1;

	// namespace function.
	int namespace1_func(int i)
	{
		return namespace1_var + i;
	}		
}


// struct declared in .cpp file (rather than header).
struct struct_cpp
	
{
private:
	int struct_cpp_var;

public:

	struct_cpp(void){struct_cpp_var = 0;}

	int struct_cpp_func(int i)
	{
		struct_cpp_var = i;
		return struct_cpp_var;
	}
};


// classed declared in .cpp file (rather than header).
class class_cpp
	
{
private:
	int class_cpp_var;
	
public:

	// const primitive member.
	const int m_const_int;
	const int *m_pconst_int;
	int const m_int_const;
	int const *m_pint_const;

	// const user type member.
	const struct_cpp m_const_struct_cpp;
	const struct_cpp *m_pconst_struct_cpp;
	struct_cpp const m_struct_cpp_const;
	struct_cpp const *m_pstruct_cpp_const;

	class_cpp(void)	:
		m_const_int(0), 
		m_pconst_int(&m_const_int),
		m_int_const(0),
		m_pint_const(&m_int_const),
		m_pconst_struct_cpp(&m_const_struct_cpp),
		m_pstruct_cpp_const(&m_struct_cpp_const)
	{
		class_cpp_var = 0;

	}

	int class_cpp_func(int i)
	{
		class_cpp_var = i;
		return class_cpp_var;
	}

};


// union declared in .cpp file (rather than header).
union union_cpp
	
{
private:
	int union_cpp_var;

public:

	union_cpp(void){union_cpp_var = 0;}

	int union_cpp_func(int i)
	{
		union_cpp_var = i;
		return union_cpp_var;
	}
};


// enum defined in cpp file (rather than header).
enum enum_cpp{one_cpp = 1, two_cpp, three_cpp};


// pointer to member function.
int (derived1::*ptr_to_mem_func)(int i) = &derived1::derived1_public_func;	
// pointer to member variable.
int derived1::*ptr_to_mem_var = &derived1::derived1_public_var;			


// global const primitive.
const int gconst_int = 0;
const int *gpconst_int;
int const gint_const = 0;
int const *gpint_const;


// global const user type.
const struct_cpp gconst_struct_cpp;
const struct_cpp *gpconst_struct_cpp;
struct_cpp const gstruct_cpp_const;
struct_cpp const *gpstruct_cpp_const;


void __cdecl main()
	
{
	// global const primitive.
	gpconst_int = &gconst_int;
	gpint_const = &gint_const;

	// global const user type.
	gpconst_struct_cpp = &gconst_struct_cpp;
	gpstruct_cpp_const = &gstruct_cpp_const;

	// local class.
	class class_local
	{
	public:
		int class_local_var;
	};

	// local struct.
	struct struct_local
	{
	public:
		int struct_local_var;
	};

	// local union.
	union union_local
	{
	public:
		int union_local_var;
	};

	// local enum.
	enum enum_local{one_local = 1, two_local, three_local};

	// static and dynamic access to class declared in header.
	derived1 derived1_obj;
	derived1 *derived1_obj_ptr = new derived1;

	// static and dynamic access to class declared in .cpp file.
	class_cpp class_cpp_obj;
	class_cpp *class_cpp_obj_ptr = new class_cpp;

	// static and dynamic access to local class.
	class_local class_local_obj;
	class_local *class_local_obj_ptr = new class_local;
	class_local_obj.class_local_var = 0;
	class_local_obj_ptr->class_local_var = 0;

	// static and dynamic access to class declared in .pch file.
	class_pch class_pch_obj;
	class_pch *class_pch_obj_ptr = new class_pch;
	/* xbox vc7 */ class_pch_obj.class_pch_func(0);
	
	// static and dynamic access to struct declared in header.
	struct1 struct1_obj;
	struct1 *struct1_obj_ptr = new struct1;

	// static and dynamic access to struct declared in .cpp file.
	struct_cpp struct_cpp_obj;
	struct_cpp *struct_cpp_obj_ptr = new struct_cpp;

	// static and dynamic access to local struct.
	struct_local struct_local_obj;
	struct_local *struct_local_obj_ptr = new struct_local;
	struct_local_obj.struct_local_var = 0;
	struct_local_obj_ptr->struct_local_var = 0;

	// static and dynamic access to struct declared in .pch file.
	struct_pch struct_pch_obj;
	struct_pch *struct_pch_obj_ptr = new struct_pch;
	/* xbox vc7 */ struct_pch_obj.struct_pch_func(0);
	
	// static and dynamic access to union declared in header.
	union1 union1_obj;
	union1 *union1_obj_ptr = new union1;

	// static and dynamic access to union declared in .cpp file.
	union_cpp union_cpp_obj;
	union_cpp *union_cpp_obj_ptr = new union_cpp;

	// static and dynamic access to local union.
	union_local union_local_obj;
	union_local *union_local_obj_ptr = new union_local;
	union_local_obj.union_local_var = 0;
	union_local_obj_ptr->union_local_var = 0;

	// static and dynamic access to union declared in .pch file.
	union_pch union_pch_obj;
	union_pch *union_pch_obj_ptr = new union_pch;
	/* xbox vc7 */ union_pch_obj.union_pch_func(0);

 	// reference to enum declared in header (non-pch).
	enum1 enum1_var = two;
	/* xbox vc7 bug, use all enum values otherwise debugger will go, huh? */
	enum1_var = one; enum1_var = three; enum1_var = two;

	// reference to enum declared in .cpp file.
	enum_cpp enum_cpp_var = three_cpp;
	/* xbox vc7 */ enum_cpp_var = one_cpp; enum_cpp_var = two_cpp; enum_cpp_var = three_cpp;

	// reference to local enum.
	enum_local enum_local_var = one_local;

	// reference to enum declared in a .pch file.
	enum_pch enum_pch_var = two_pch;
	/* xbox vc7 */ enum_pch_var = one_pch; enum_pch_var = three_pch; enum_pch_var = two_pch;

	// static local variable.
	static int static_local_var = 0;

	// static and dynamic access to class defined in dll.
	//xbox dll_class dll_class_obj;
	//xbox dll_class *dll_class_obj_ptr = new dll_class;

	// local const primitive.
	const int const_int = 0;
	const int *pconst_int = &const_int;
	int const int_const = 0;
	int const *pint_const = &int_const;

	// local const user type.
	const struct_cpp const_struct_cpp;
	const struct_cpp *pconst_struct_cpp = &const_struct_cpp;
	struct_cpp const struct_cpp_const;
	struct_cpp const *pstruct_cpp_const = &struct_cpp_const;

	return; /* run to here before evaluating [do not delete this comment] */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\eh01.cpp ===
#include "ehutil.h"
#include "nlgmain.h"

int counter = 0;
int ctorCounter = 0;
int dtorCounter = 0;

void eh01(void)
{
	int caseNum = 0;
	try 
	{
		++caseNum;
		Case1();   //throws t; no handler
		++caseNum; // should not execute
	}
	catch( ... ) // after Case1
	{
		++caseNum;
		Case2();   // doesn't throw anything
		++caseNum; // should execute

		try {
			++caseNum;
			Case3();   // throws t; doesn't catch it
			++caseNum; // should not execute
		}
		catch( ... ){ // after Case3
			try {
				++caseNum;
				Case4();   // throws t and catches it
				++caseNum; // should execute
			}
			catch( ... ) { // after Case4
				++caseNum; // should not execute
			}
		}
	}

 	try {
		++caseNum;
		Case5();   // throws t and catches it
		++caseNum; // should execute
	}
	catch( ... ) {
		++caseNum; // should not execute
	}

	try {
		++caseNum;
		Case6();   // throws t, rethrows it and catches it
		++caseNum; // should execute
	}
	catch( ... ) {
		++caseNum; // should not execute
	}

	try {
		++caseNum;
		Case7();   // throws t, rethrows it and catches it
		++caseNum; // should execute
	}
	catch( ... ) {
		++caseNum; // should not execute
	}

//	try {
//		++caseNum;
//		Case8();   // throws t, Ctor throws an int, Case8 doesn't catch t ??
//		++caseNum; // should execute ?
//	}
//	catch( ... ) {
//		++caseNum; // should not execute
//	}

	++caseNum; // should execute

}


/////////////////////////////////////////////////////////////////////////////

void Case1() {
	//	Throw without handler.
	ThrowObject t(1);
	throw t;	

	++counter; // Should not execute
}

void Case2() {
	//	try-block without a throw
	try {
		++counter;
	}
	catch( ... ) {
		++counter; // Should not execute
	}
	++counter; // Should execute
}

void Case4() {
	//	try-block with multiple handlers
	try { ++counter; ThrowObject t(4); throw t; }
	catch( int ) {
		++counter; // Should not execute
	}
	catch( ThrowObject c ) { ++counter; /* Should execute */ }
	catch( ... ) {
		++counter; // Should not execute
	}
	++counter; // Should execute
}

void Case5() {
	//	Throw from inner try-block caught in outer handler
	try {
		++counter;
		try {			
			++counter;
			ThrowObject t(5);
			throw t;

			++counter; // Should not execute
		}
		catch( int ) {
			++counter; // Should not execute
		}
		++counter; // Should not execute
	}
	catch( ThrowObject o ) {
		++counter; // Should execute
	}
	++counter; // Should execute
}

void Case6() {
	//	Throw from inner try-block handler caught in outer handler
	try {
		++counter;
		try {
			++counter;
			ThrowObject t(6);
			throw t;

			++counter; // Should not execute
		}
		catch( ThrowObject c ) {			
			++counter; // Should execute
			throw c;

			++counter; // Should not execute
		}
		++counter; // Should not execute
	}
	catch( ThrowObject o ) {
		++counter; // Should execute
	}

	++counter; // Should execute
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\fibon\winmain.cpp ===
#include <xtl.h> //xbox #include <windows.h>

extern void fiboncases(int argc, char *argv[]);


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
	char *argv[]= {"damn executable", "5", "3"};
	for(int i=0;i<10;i++)
		fiboncases(3,argv);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\eh01.h ===
#ifndef EH01_H
#define EH01_H

class ThrowObject {
public:
	ThrowObject();
	ThrowObject( int i );
	ThrowObject( const ThrowObject& );
	~ThrowObject();

private:
	int m_i;
};

extern int counter;

void Case1();
void Case2();
void Case3();
void Case4();
void Case5();
void Case6();
void Case7();

#endif // EH01_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\namspace\namspace.cpp ===
#include <xtl.h> //xbox #include <windows.h>

int i = 0;
int j = 0;

namespace n1
	
	{
	int i = 1;
	int j = 1;

	void func(void)
		{				// first line of n1::func()
		int local = 3;
		}

	namespace n2
		{
		int i = 2;
		int j = 2;
		}
	}

void __cdecl main()
	{
	using namespace n1;
	func();
	n1::j *= 10;
	while (1); /* xbox */ return;		// line after n1::j changed
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ExprEval PP\ExprEval PP.cpp ===
#include <xtl.h> //xbox #include <windows.h>
#include <xmmintrin.h>

const float FLOAT_ZERO = 0;
__int64 GlobalInt64 = 0;

__int64 FloatVal[] =	//	32 bit register values for each integer
{
3225419779,		//	-3
3221225474,		//	-2	
3212836866,		//	-1
0,				//	0
1065353218,		//	1
1073741826,		//	2
1077936131,		//	3
1082130434,		//	4
1084227586,		//	5
1086324738,		//	6
1088421890,		//	7	
1090519041,		//	8
1091567617,		//	9
1092616193		//	10
};

const int FLOATVAL_BASE = -3;
__m128 Var128;

void ClearXMMReg(int regid);
void set_GlobalInt64(int Hi, int Low);
void set_XMMRegister(int regid, char upper, int Hi, int Low);
void set_XMMRegister(int regid, int X3, int X2, int X1, int X0);

void set_Register(int regid, __int64 regval);
void test_MMX();
void test_3dNow();
void test_3dNowEnhanced();
void test_Katmai();

/*************************************************************************************************
*
*	main()
*
*************************************************************************************************/

void __cdecl main()
{
	
	//	3d Now! register tests
	test_MMX();
	test_3dNow();
	test_3dNowEnhanced();
	test_Katmai();

	return;
}


/********************************************
*
*	3d Now! - function to set a MMi register
*
*********************************************/

void set_Register(int regid, __int64 regval)
{
	switch (regid)
	{
		case 0:		__asm { MOVQ MM0, regval }
					break;


		case 1:		__asm { MOVQ MM1, regval }
					break;


		case 2:		__asm { MOVQ MM2, regval }
					break;

		case 3:		__asm { MOVQ MM3, regval }
					break;


		case 4:		__asm { MOVQ MM4, regval }
					break;

		case 5:		__asm { MOVQ MM5, regval }
					break;

		case 6:		__asm { MOVQ MM6, regval }
					break;

		case 7:		__asm { MOVQ MM7, regval }
					break;

	}
}

void test_MMX()
{
	//	MMX tests
	
	__int64 count = 0;

	//	test all registers for operability
	count = 1000; 		__asm {	MOVQ MM0,count }
	count = 2000; 		__asm {	MOVQ MM1,count }
	count = 3000; 		__asm {	MOVQ MM2,count }
	count = 4000; 		__asm {	MOVQ MM3,count }
	count = 5000; 		__asm {	MOVQ MM4,count }
	count = 6000; 		__asm {	MOVQ MM5,count }
	count = 7000; 		__asm {	MOVQ MM6,count }
	count = 8000; 		__asm {	MOVQ MM7,count }

	//	shift left
	set_Register(0,400);	count = 2; 	__asm {	PSLLW MM0,count }
	set_Register(0,9);		count = 6; 	__asm {	PSLLW MM0,count }	


	//	mov 32 bit
	count = 123456789; 		__asm {	MOVD MM0,count }	

	count = 4294967296; 	__asm {	MOVD MM0,count }	//	32 bits	
	count = 4294967295; 	__asm {	MOVD MM0,count }	//	32 bits - 1
	count = 4294967297; 	__asm {	MOVD MM0,count }	//	32 bits + 1
	count = 8589934592; 	__asm {	MOVD MM0,count }	//	33 bits


	count = 123456789; 		__asm {	MOVQ MM0,count }
	count = 4294967296; 	__asm {	MOVQ MM0,count }	
	count = 4294967295; 	__asm {	MOVQ MM0,count }	
	count = 4294967297; 	__asm {	MOVQ MM0,count }	
	count = 8589934592; 	__asm {	MOVQ MM0,count }	

	
	//	Pack with Signed Saturation
	set_Register(0,1);	count = 1; 	__asm {	PACKSSWB MM0,count }
	set_Register(0,1);	count = 1; 	__asm {	PACKSSDW MM0,count }

	//	Pack with Unsigned Saturation	
	set_Register(0,1);	count = 1; 	__asm {	PACKUSWB MM0,count }

	//	Packed Add
	set_Register(0,100);	count = 1; 	__asm {	PADDB MM0,count }
	set_Register(0,127);	count = 127; 	__asm {	PADDB MM0,count }
	set_Register(0,128);	count = 128; 	__asm {	PADDB MM0,count }
	set_Register(0,256);	count = 256; 	__asm {	PADDB MM0,count }

	set_Register(0,100);	count = 1; 	__asm {	PADDW MM0,count }
	set_Register(0,65535);	count = 1; 	__asm {	PADDW MM0,count }
	set_Register(0,65536);	count = 65536; 	__asm {	PADDW MM0,count }
	
	set_Register(0,100);	count = 1; 	__asm {	PADDD MM0,count }
	set_Register(0,1);	count = 4294967295; 	__asm {	PADDD MM0,count }
	set_Register(0,4294967296);	count = 4294967296; 	__asm {	PADDD MM0,count }

	//	Packed Add with Saturation
	set_Register(0,150);	count = 100; 	__asm {	PADDSB MM0,count }
	set_Register(0,65470);	count = 100; 	__asm {	PADDSW MM0,count }

	//	Packed Add Unsigned with Saturation 
	set_Register(0,200);	count = 100; 	__asm {	PADDUSB MM0,count }
	set_Register(0,65530);	count = 100; 	__asm {	PADDUSW MM0,count }

	//	Bitwise Logical And 
	set_Register(0,256);	count = 32; 	__asm {	PAND MM0,count }
	set_Register(0,255);	count = 15; 	__asm {	PAND MM0,count }

	//	Bitwise Logical And Not 
	set_Register(0,15);	count = 15; 	__asm {	PANDN MM0,count }
	set_Register(0,1);	count = 15; 	__asm {	PANDN MM0,count }

	//	Bitwise Logical Or
	set_Register(0,64);	count = 15; 	__asm {	POR MM0,count }

	//	Compare for Equal 
	set_Register(0,400);	count = 100; 	__asm {	PCMPEQB MM0,count }
	set_Register(0,200);	count = 100; 	__asm {	PCMPEQB MM0,count }
	set_Register(0,120);	count = 120; 	__asm {	PCMPEQB MM0,count }

	set_Register(0,400);	count = 100; 	__asm {	PCMPEQW MM0,count }
	set_Register(0,120);	count = 120; 	__asm {	PCMPEQW MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PCMPEQD MM0,count }
	set_Register(0,120);	count = 120; 	__asm {	PCMPEQD MM0,count }

	//	Compare for Greater Than
	set_Register(0,200);	count = 100; 	__asm {	PCMPGTB MM0,count }
	set_Register(0,127);	count = 100; 	__asm {	PCMPGTB MM0,count }
	set_Register(0,128);	count = 127; 	__asm {	PCMPGTB MM0,count }
	set_Register(0,127);	count = 128; 	__asm {	PCMPGTB MM0,count }	
	set_Register(0,256);	count = 0; 		__asm {	PCMPGTB MM0,count }
	set_Register(0,350);	count = 100; 		__asm {	PCMPGTB MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PCMPGTW MM0,count }
	set_Register(0,65536);	count = 0; 		__asm {	PCMPGTW MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PCMPGTD MM0,count }
	set_Register(0,4294967296);	count = 0; 	__asm {	PCMPGTD MM0,count }

	//	Packed Multiply and Add 
	set_Register(0,5);	count = 260; 	__asm {	PMADDWD MM0,count }
	set_Register(0,65536);	count = 65536; 	__asm {	PMADDWD MM0,count }

	//	Packed Multiply High
	set_Register(0,400);	count = 100; 	__asm {	PMULHW MM0,count }
	set_Register(0,6556);	count = 10; 	__asm {	PMULHW MM0,count }

	//	Packed Multiply Low
	set_Register(0,6556);	count = 10; 	__asm {	PMULLW MM0,count }
	set_Register(0,655);	count = 10; 	__asm {	PMULLW MM0,count }

	//	Packed Shift Left Logical
	set_Register(0,23);	count = 4; 	__asm {	PSLLW MM0,count }
	set_Register(0,65537);	count = 1; 	__asm {	PSLLW MM0,count }
	set_Register(0,2147483648);	count = 1; 	__asm {	PSLLW MM0,count }
	
	set_Register(0,23);	count = 4; 	__asm {	PSLLD MM0,count }
	set_Register(0,2147483649);	count = 1; 	__asm {	PSLLD MM0,count }
	set_Register(0,4294967296);	count = 1; 	__asm {	PSLLD MM0,count }
	set_Register(0,2147483648);	count = 1; 	__asm {	PSLLD MM0,count }
	
	set_Register(0,23);	count = 4; 	__asm {	PSLLQ MM0,count }

	//	Packed Shift Right Arithmetic
	set_Register(0,400);	count = 3; 		__asm {	PSRAW MM0,count }
	set_Register(0,5);		count = 3; 		__asm {	PSRAW MM0,count }
	set_Register(0,65538);	count = 1; 		__asm {	PSRAW MM0,count }
	set_Register(0,65536);	count = 1; 		__asm {	PSRAW MM0,count }
	set_Register(0,65537);	count = 1; 		__asm {	PSRAW MM0,count }
	
	set_Register(0,400);	count = 3; 		__asm {	PSRAD MM0,count }
	set_Register(0,5);	count = 3; 		__asm {	PSRAD MM0,count }
	set_Register(0,4294967298);	count = 1; 		__asm {	PSRAD MM0,count }
	set_Register(0,4294967296);	count = 1; 		__asm {	PSRAD MM0,count }
	set_Register(0,4294967297);	count = 1; 		__asm {	PSRAD MM0,count }
	
	//	Packed Shift Right Logical
	set_Register(0,256);	count = 4; 		__asm {	PSRLW MM0,count }
	set_Register(0,6);		count = 4; 		__asm {	PSRLW MM0,count }
	set_Register(0,65536);	count = 1; 		__asm {	PSRLW MM0,count }
	set_Register(0,65537);	count = 1; 		__asm {	PSRLW MM0,count }
	set_Register(0,65538);	count = 1; 		__asm {	PSRLW MM0,count }
	
	set_Register(0,256);	count = 4; 		__asm {	PSRLD MM0,count }
	set_Register(0,10);	count = 4; 		__asm {	PSRLD MM0,count }
	set_Register(0,4294967296);	count = 1; 		__asm {	PSRLD MM0,count }
	set_Register(0,4294967298);	count = 1; 		__asm {	PSRLD MM0,count }
	set_Register(0,4294967297);	count = 1; 		__asm {	PSRLD MM0,count }
	
	set_Register(0,256);	count = 4; 		__asm {	PSRLQ MM0,count }
	set_Register(0,15);		count = 4; 		__asm {	PSRLQ MM0,count }
//	set_Register(0,18446744073709551616);	count = 1; 	__asm {	PSLLQ MM0,count }
//	set_Register(0,18446744073709551617);	count = 1; 	__asm {	PSLLQ MM0,count }
//	set_Register(0,18446744073709551618);	count = 1; 	__asm {	PSLLQ MM0,count }
	
	//	Packed Subtract
	set_Register(0,240);	count = 100; 	__asm {	PSUBB MM0,count }
	set_Register(0,340);	count = 100; 	__asm {	PSUBB MM0,count }
	set_Register(0,65736);	count = 100; 	__asm {	PSUBB MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PSUBW MM0,count }
	set_Register(0,65750);	count = 100; 	__asm {	PSUBW MM0,count }
	set_Register(0,4294967496);	count = 100; 	__asm {	PSUBW MM0,count }
	set_Register(0,4294967390);	count = 100; 	__asm {	PSUBW MM0,count }

	set_Register(0,400);	count = 100; 	__asm {	PSUBD MM0,count }
	set_Register(0,4294967496);	count = 100; 	__asm {	PSUBD MM0,count }
//	set_Register(0,18446744073709551816);	count = 100; 	__asm {	PSUBD MM0,count }
	
	//	Packed Subtract with Saturation
	set_Register(0,240);	count = 100; 	__asm {	PSUBSB MM0,count }
	set_Register(0,400);	count = 100; 	__asm {	PSUBSB MM0,count }
	set_Register(0,65736);	count = 100; 	__asm {	PSUBSB MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PSUBSW MM0,count }
	set_Register(0,65750);	count = 100; 	__asm {	PSUBSW MM0,count }
	set_Register(0,4294967496);	count = 100; 	__asm {	PSUBSW MM0,count }

	//	Packed Subtract Unsigned with Saturation
	set_Register(0,240);	count = 100; 	__asm {	PSUBUSB MM0,count }	//	all "correct" values
	set_Register(0,400);	count = 100; 	__asm {	PSUBUSB MM0,count }
	set_Register(0,65736);	count = 100; 	__asm {	PSUBUSB MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PSUBSW MM0,count }
	set_Register(0,65750);	count = 100; 	__asm {	PSUBSW MM0,count }
	set_Register(0,4294967496);	count = 100; 	__asm {	PSUBSW MM0,count }

	
	//	Unpack High Packed Data
	set_Register(0,1);	count = 400; 	__asm {	PUNPCKHBW MM0,count }
	set_Register(0,1);	count = 24600; 	__asm {	PUNPCKHBW MM0,count }
	set_Register(0,1);	count = 4294967496; 	__asm {	PUNPCKHBW MM0,count }
	set_Register(0,4294967496);	count = 1; 	__asm {	PUNPCKHBW MM0,count }
	set_Register(0,4294967496);	count = 4294967496; 	__asm {	PUNPCKHBW MM0,count }
	
	set_Register(0,1);	count = 400; 	__asm {	PUNPCKHWD MM0,count }
	set_Register(0,1);	count = 24600; 	__asm {	PUNPCKHWD MM0,count }
	set_Register(0,1);	count = 4294967296; 	__asm {	PUNPCKHWD MM0,count }
	set_Register(0,4294967296);	count = 1; 	__asm {	PUNPCKHWD MM0,count }
	set_Register(0,4294967296);	count = 4294967296; 	__asm {	PUNPCKHWD MM0,count }
	
	set_Register(0,1);	count = 400; 	__asm {	PUNPCKHDQ MM0,count }
	set_Register(0,1);	count = 24600; 	__asm {	PUNPCKHDQ MM0,count }
	set_Register(0,1);	count = 4294967296; 	__asm {	PUNPCKHDQ MM0,count }
	set_Register(0,4294967296);	count = 1; 	__asm {	PUNPCKHDQ MM0,count }
	set_Register(0,4294967296);	count = 4294967296; 	__asm {	PUNPCKHDQ MM0,count }
	
	//	Unpack Low Packed Data
	set_Register(0,1);	count = 2; 	__asm {	PUNPCKLBW MM0,count }
	set_Register(0,2);	count = 1; 	__asm {	PUNPCKLBW MM0,count }

	set_Register(0,1);	count = 2; 	__asm {	PUNPCKLWD MM0,count }
	set_Register(0,2);	count = 1; 	__asm {	PUNPCKLWD MM0,count }
	
	set_Register(0,1);	count = 2; 	__asm {	PUNPCKLDQ MM0,count }
	set_Register(0,2);	count = 1; 	__asm {	PUNPCKLDQ MM0,count }
	
	//	Bitwise Logical Exclusive OR
	set_Register(0,255);	count = 15; 	__asm {	PXOR MM0,count }
	set_Register(0,15);		count = 15; 	__asm {	PXOR MM0,count }

}

void test_3dNow()
{
	//	3dNow Tests

	__int64 count = 0;
	unsigned char int8 = 0;

	//	average of unsigned int bytes
	set_Register(0,1);	count = 1; 	__asm {	PAVGUSB MM0,count }	//	1
	set_Register(0,1);	count = 0; 	__asm {	PAVGUSB MM0,count }	//	1
	set_Register(0,0);	count = 1; 	__asm {	PAVGUSB MM0,count }	//	1
	set_Register(0,807437600515);	count = 661408385285; 	__asm {	PAVGUSB MM0,count }	//	734423025668

	//	float to 32 bit signed int
	set_Register(0,1);	count = 1610612738; 	__asm {	PF2ID MM0,count }	//	2147483647
	set_Register(0,1);	count = 6917529037841629186; 	__asm {	PF2ID MM0,count }	//	9223372034707292159
	set_Register(0,1);	count = 1065353218; 	__asm {	PF2ID MM0,count }	//	1
	set_Register(0,1);	count = 1082130434; 	__asm {	PF2ID MM0,count }	//	4

	//	accumulator
	set_Register(0,1082130434);	count = 1065353218; 	__asm {	PFACC MM0,count }	//	4575657231080488962
	set_Register(0,1065353218);	count = 1; 	__asm {	PFACC MM0,count }	//	1065353218
	set_Register(0,1);	count = 1065353218; 	__asm {	PFACC MM0,count }	//	4575657229998358528
//	set_Register(0,4575657231080488962);	count = 1065353218; 	__asm {	PFACC MM0,count }	// not understood

	//	add
	set_Register(0,0);	count = 1065353218; 	__asm {	PFADD MM0,count }
	set_Register(0,1065353218);	count = 1073741826; 	__asm {	PFADD MM0,count }	//	1 + 2
	set_Register(0,1077936131);	count = 1082130434; 	__asm {	PFADD MM0,count }	//	3 + 4

	//	compare for equal
	set_Register(0,1);	count = 1; 	__asm {	PFCMPEQ MM0,count }	//	18446744073709551615
	set_Register(0,1065353218);	count = 1; 	__asm {	PFCMPEQ MM0,count }	//	18446744069414584320
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFCMPEQ MM0,count } //	18446744073709551615
	set_Register(0,4575657231063711746);	count = 1065353218; 	__asm {	PFCMPEQ MM0,count }	//	4294967295
	set_Register(0,4575657231063711746);	count = 1077936131; 	__asm {	PFCMPEQ MM0,count }	//	0

	//	compare for greater than or equal to
	set_Register(0,1);	count = 1; 	__asm {	PFCMPGE MM0,count }	//	 //	18446744073709551615
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFCMPGE MM0,count } //	18446744073709551615
	set_Register(0,4575657231063711746);	count = 1065353218; 	__asm {	PFCMPGE MM0,count }	//	18446744073709551615
	set_Register(0,4575657231063711746);	count = 1077936131; 	__asm {	PFCMPGE MM0,count }	//	18446744069414584320

	//	compare for greater than
	set_Register(0,1);	count = 1; 	__asm {	PFCMPGT MM0,count }
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFCMPGT MM0,count } //	0
	set_Register(0,4575657231063711746);	count = 1065353218; 	__asm {	PFCMPGT MM0,count }	//	18446744069414584320
	set_Register(0,4575657231076294659);	count = 1065353218; 	__asm {	PFCMPGT MM0,count }	//	18446744073709551615
	
	//	maximum
	set_Register(0,1);	count = 1; 	__asm {	PFMAX MM0,count }
	set_Register(0,1);	count = 4575657231063711746; 	__asm {	PFMAX MM0,count }
	set_Register(0,4575657231063711746);	count = 1077936131; 	__asm {	PFMAX MM0,count }	//	4575657231076294659
	set_Register(0,4575657231076294659);	count = 4611686028091064322; 	__asm {	PFMAX MM0,count }	//	4611686028095258627

	//	minimum
	set_Register(0,1);	count = 1; 	__asm {	PFMIN MM0,count }
	set_Register(0,1);	count = 4575657231063711746; 	__asm {	PFMIN MM0,count }
	set_Register(0,4575657231076294659);	count = 4611686028091064322; 	__asm {	PFMIN MM0,count }	//	4575657231072100354
	set_Register(0,4575657231076294659);	count = 1065353218; 	__asm {	PFMIN MM0,count }	//	1065353218

	//	multiply
	set_Register(0,1);	count = 1; 	__asm {	PFMUL MM0,count }
	set_Register(0,1);	count = 4575657231076294659; 	__asm {	PFMUL MM0,count }
	set_Register(0,4575657231076294659);	count = 4611686028091064322; 	__asm {	PFMUL MM0,count }
	
	//	reciprocal
	set_Register(0,1);	count = 1; 	__asm {	PFRCP MM0,count } //	9187343237679939583

	set_Register(0,1);	set_Register(1,1073741826);	 __asm {	PFRCP MM0,MM1 }	//	reciprocal of 2 - 4539626226423168512
	count = 1092616193; 	__asm {	PFMUL MM0,count }	//	multiply 10 by 0.5 - 1084227265

	//	reciprocal, reciprocal intermediate step 1, reciprocal intermediate step 2
	set_Register(0,1);	set_Register(1,1073741826);	 __asm {	PFRCP MM0,MM1 }	//	reciprocal of 2 - 4539626226423168512
	__asm {	PFRCPIT1 MM1,MM0 }	//	MM1 - 1065418239
	__asm {	PFRCPIT2 MM0,MM1 }	//	1057029630
	count = 1092616193; 	__asm {	PFMUL MM0,count }	//	multiply 10 by 0.5 - 1084308863
		
	//	reciprocal sqrt
	set_Register(0,1);	count = 1; 	__asm {	PFRSQRT MM0,count }		//	9187343237679939583
	set_Register(0,1);	count = 1082130434; 	__asm {	PFRSQRT MM0,count }	//	4 - 4539627325934796544 (not same as 1/2)
	set_Register(0,1);	count = 1091567617; 	__asm {	PFRSQRT MM0,count }	//	9 - 4515608494420437504 - exact!!

	//	reciprocal sqrt, reciprocal sqrt intermediate step 1	
	set_Register(0,1);	set_Register(1,1082130434); 	__asm {	PFRSQRT MM0,MM1 }	//	4 - 4539627325934796544 (not same as 1/2)
	__asm {	PFRSQIT1 MM1,MM0 }	//	1065369343 - off

	set_Register(0,1);	set_Register(1,1091567617); 	__asm {	PFRSQRT MM0,MM1 }	//	9 - 4515608494420437504 (not same as 1/2)
	__asm {	PFRSQIT1 MM1,MM0 }	//	1065365418 - off
	
	//	subtract
	set_Register(0,1);	count = 1; 	__asm {	PFSUB MM0,count }
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFSUB MM0,count }
	set_Register(0,1082130434);	count = 1065353218; 	__asm {	PFSUB MM0,count } //	 4-1 = 1077936131
	set_Register(0,4575657231076294659);	count =1065353218; 	__asm {	PFSUB MM0,count } //	4575657231072100354

	//	reverse subtraction
	set_Register(0,1);	count = 1; 	__asm {	PFSUBR MM0,count }
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFSUBR MM0,count }
	set_Register(0,1065353218);	count = 1082130434; 	__asm {	PFSUBR MM0,count } //	 4-1 = 1077936131
	set_Register(0,1065353218);	count =4575657231076294659; 	__asm {	PFSUBR MM0,count } //	4575657231072100354

	//	32 bit signed int to float
	set_Register(0,1);	count = 1; 	__asm {	PI2FD MM0,count }	//	1065353216
	set_Register(0,1);	count = 12884901890; 	__asm {	PI2FD MM0,count }	//	4629700418010611712
	set_Register(0,1);	count = 8589934593; 	__asm {	PI2FD MM0,count }	//	4611686019492741120

	//	multiply high
	set_Register(0,1);	count = 1; 	__asm {	PMULHRW MM0,count }
	set_Register(0,1688858450395145);	count = 1970346312335364; 	__asm {	PMULHRW MM0,count }	//	0!
	set_Register(0,2816897267531808);	count = 28148786178032640; 	__asm {	PMULHRW MM0,count }	//	8590000129!

	int8 = 1;

	//	load a processor cache into data cache
	__asm {	PREFETCH int8 }

	//	same, sets MES state to modified
	__asm {	PREFETCHW int8 }

}


void test_3dNowEnhanced()
{
	//	enhanced 3dnow tests

	__int64 count = 0;
	unsigned char count8 = 0;

	//	packed float to int word with sign extend
	set_Register(0,1);	count = 1; 	__asm {	PF2IW MM0,count }	//	0
	set_Register(0,1);	count = 4674736422882639874; 	__asm {	PF2IW MM0,count }	//	74 - 30064771076
	set_Register(0,1);	count = 4692750816015024128; 	__asm {	PF2IW MM0,count }	//	10-0 - 42949672960
	set_Register(0,1);	count = 13835058067084935170; 	__asm {	PF2IW MM0,count }	//	-2-1 - 18446744069414584319
	set_Register(0,1);	count = 3338666241; 	__asm {	PF2IW MM0,count }		//	4294934528

	//	packed float negative accumulate
	set_Register(0,1);	count = 1; 	__asm {	PFNACC MM0,count }	//	0
	set_Register(0,1);	count = 4647714825124708354; 	__asm {	PFNACC MM0,count }	//	0&47 - 4629700416936869888
	set_Register(0,4647714825120514050);	count = 4665729223629996034; 	__asm {	PFNACC MM0,count }	//	45&65 - 13799029259328552960

	//	packed float mixed +ve -ve accumulate
	set_Register(0,1);	count = 1; 	__asm {	PFPNACC MM0,count }
	set_Register(0,4647714825124708354);	count = 1; 	__asm {	PFPNACC MM0,count }	//	1077936128
	set_Register(0,4647714825124708354);	count = 4647714825120514050; 	__asm {	PFPNACC MM0,count }	//	47,45 - 4688247221760557056
   
	//	packed int word to float
	//	somewhat erroneous values

	set_Register(0,1);	count = 1; 	__asm {	PI2FW MM0,count }	//	1065353216
	set_Register(0,1);	count = 281466386841599; 	__asm {	PI2FW MM0,count }	//	13835058058495000576
	set_Register(0,1);	count = 30064771076; 	__asm {	PI2FW MM0,count }	//	4674736414292705280
 	set_Register(0,1);	count = 42949672960; 	__asm {	PI2FW MM0,count }	//	4692750811720056832
 	set_Register(0,1);	count = 32768; 	__asm {	PI2FW MM0,count }		//	3338665984

	//	packed swap double word
	set_Register(0,1);	count = 1; 	__asm {	PSWAPD MM0,count }  // 4294967296
	set_Register(0,1);	count = 4294967302; 	__asm {	PSWAPD MM0,count }  //	25769803777
	set_Register(0,1);	count = 25769803776; 	__asm {	PSWAPD MM0,count }	//	6

	//	streaming store using byte mask
	set_Register(0,1);	set_Register(1,255); 	__asm {	MASKMOVQ MM0,MM1 }
	set_Register(0,258);	set_Register(1,65535); 	__asm {	MASKMOVQ MM0,MM1 }
	set_Register(0,137561200);	set_Register(1,16777215); 	__asm {	MASKMOVQ MM0,MM1 }
	
	//	streaming store
	set_Register(0,10);	count = 1; 	__asm {	MOVNTQ count,MM0 }	//	count == mm0
	set_Register(0,34359738373);	count = 1; 	__asm {	MOVNTQ count,MM0 }

			
	//	packed avg of unsigned byte	
	set_Register(0,1);	count = 1; 	__asm {	PAVGB MM0,count }	//	1
	set_Register(0,1);	count = 0; 	__asm {	PAVGB MM0,count }	//	1
	set_Register(0,0);	count = 1; 	__asm {	PAVGB MM0,count }	//	1
	set_Register(0,807437600515);	count = 661408385285; 	__asm {	PAVGB MM0,count }	//	734423025668
	
	//	packed avg of unsigned word	
	set_Register(0,1);	count = 1; 	__asm {	PAVGW MM0,count }
	set_Register(0,13527687376553903363);	count = -7388155192895340543; 	__asm {	PAVGW MM0,count }	//	12293138128684057218
	set_Register(0,60000);	count = 50000; 	__asm {	PAVGW MM0,count }	//	55000


	//	extract word into int register
	set_Register(0,1);	__asm {	PEXTRW EAX,MM0,1 }	//	eax = 0
	set_Register(0,65538);	__asm {	PEXTRW EAX,MM0,1 }	//	eax = 1 


	//	insert word from int register

	set_Register(0,65540);	_asm { mov EAX, 2 }	 __asm {	PINSRW MM0, EAX, 1 }	//	MM0 = 131076

	//	packed max signed word
	set_Register(0,533958026541989887);	count = 576742218707042305; 	__asm {	PMAXSW MM0,count }	//	576742223002009601
	set_Register(0,1431633921);	count = 1431633926; 	__asm {	PMAXSW MM0,count }	//	1431633926
	
	//	packed max unsigned byte
	set_Register(0,730413330687);	count = 1834203085567; 	__asm {	PMAXUB MM0,count }	//	1834219928319
	
	//	packed min signed word
	set_Register(0,576742218707042305);	count = 533958026541989887; 	__asm {	PMINSW MM0,count }	//	533958022247022591
	set_Register(0,1431633926);	count = 1431633921; 	__asm {	PMINSW MM0,count }	//	1431633921
	
	//	packed min unsigned byte	
	set_Register(0,1834203085567);	count = 730413330687; 	__asm {	PMINUB MM0,count }	//	730396487935
	
	//	move mask to integer register
	set_Register(0,17356997142132031728);	__asm {	PMOVMSKB EAX, MM0 }	//	EAX = 217
	
	//	packed multiply high unsigned word
	set_Register(0,18446744069427435932);	count = 562954313924618; 	__asm {	PMULHUW MM0,count }	//	281474976841729

	//	prefetch non-temporal access
	__asm {	PREFETCHNTA count8 }
	
	//	prefetch to all cache levels
	__asm {	PREFETCHT0 count8 }
	
	//	prefetch to all cache levels except 0
	__asm {	PREFETCHT1 count8 }
	
	//	prefetch to all cache levels except 0 & 1
	__asm {	PREFETCHT2 count8 }

	//	packed sum of absolute byte differences
	set_Register(0,1300991683403908355);	count = 722835462628311810; 	__asm {	PSADBW MM0,count }	//	35
	set_Register(0,722835462628311810);	count = 1300991683403908355; 	__asm {	PSADBW MM0,count }	//	35
	
	//	packed shuffle word
	set_Register(0,1);	count = 1; 	__asm {	PSHUFW MM0,count,0 }	//	1 in every word 281479271743489
	set_Register(0,1);	count = 578437695752307201; 	__asm {	PSHUFW MM0,count,228 }	//	578437695752307201
	
	// store fence
	__asm {	SFENCE }
}

void test_Katmai()
{
	//	Katmai (PIII) Tests

	float fVal = 0.0;
	__int32 i32Val = 0;

	//	verifying each register for expression evaluation
	set_XMMRegister(0,1,2,3,4);
	set_XMMRegister(1,2,3,4,5);
	set_XMMRegister(2,3,4,5,6);
	set_XMMRegister(3,4,5,6,7);
	set_XMMRegister(4,5,6,7,8);
	set_XMMRegister(5,6,7,8,9);
	set_XMMRegister(6,7,8,9,10);
	set_XMMRegister(7,-1,-2,-3,6);


	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { addps   xmm0, xmm1 }	//	XMM0 - 3,5,7,9

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { addss   xmm0, xmm1 }	//	1,2,3,9

	ClearXMMReg(0); set_XMMRegister(1,0,4,0,1);
	__asm { andnps   xmm0, xmm1 }

	set_XMMRegister(0,1,1,1,1); set_XMMRegister(1,2,2,6,7);
	__asm { andnps   xmm0, xmm1 }

	set_XMMRegister(0,1,2,3,4); ClearXMMReg(1);
	__asm { andps   xmm0, xmm1 }	//	0

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,2,3,5);
	__asm { andps   xmm0, xmm1 }	//	1,2,3,4

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,2,3,5);
	__asm { cmpeqps   xmm0, xmm1 }	//	eq-eq-eq-neq (neq=>0)

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,2,3,4);
	__asm { cmpeqps   xmm0, xmm1 }	//	eq-eq-eq-eq

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,6,2,3,5);
	__asm { cmpeqss   xmm0, xmm1 }	//	1,2,3,0

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,6,2,3,4);
	__asm { cmpeqss   xmm0, xmm1 }	//	1,2,3,eq

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,1,0);
	__asm { cmpltps   xmm0, xmm1 }	//	no-yes-no-no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,0);
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,4);
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,5);
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,yes

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,0,0);
	__asm { cmpleps   xmm0, xmm1 }	//	yes,yes,no,no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,0);
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,5);
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,yes

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,4);
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,yes

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,4);
	__asm { cmpneqps  xmm0, xmm1 }	//	no,y,y,n

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,4);
	__asm { cmpneqss   xmm0, xmm1 }	//	1,2,3,n

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,3);
	__asm { cmpneqss   xmm0, xmm1 }	//	1,2,3,y


	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,2,4,1);
	__asm { cmpnltps   xmm0, xmm1 }	//	n,y,n,y

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,1,4,1);
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,y

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,1,4,5);
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,n

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,1,4,4);
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,y

	set_XMMRegister(0,1,2,3,7); set_XMMRegister(1,2,3,3,5);
	__asm { cmpnleps   xmm0, xmm1 }	//	n,n,n,y

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,1,1);
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,y

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,1,5);
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,n

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,1,4);
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,n


	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { comiss   xmm0, xmm1 }	//	0 (eq last no)

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,4);
	__asm { comiss   xmm0, xmm1 }	//	1

	set_XMMRegister(0,1,2,0,0); 
	GlobalInt64 = 3;  GlobalInt64  = GlobalInt64 << 32;	GlobalInt64 |= 4;
	__asm { cvtpi2ps   xmm0, GlobalInt64 }	//	1,2,3,4


	set_XMMRegister(0,1,2,2,5);
	__asm { cvtps2pi   mm0, xmm0 }	//	MM0 has 2,5

	set_XMMRegister(0,1,2,3,4); __asm { mov eax, 17 }
	__asm { cvtsi2ss   xmm0, eax }	//	1,2,3,17

	set_XMMRegister(0,1,2,3,4);
	__asm { cvtss2si   eax, xmm0 }	//	eax has 4

	set_XMMRegister(0,1,2,7,5);
	__asm { cvttps2pi   mm0, xmm0 }	//	MM0 has 7,5

	set_XMMRegister(0,1,2,3,7);
	__asm { cvttss2si   eax, xmm0 }	//	eax has 7

	set_XMMRegister(0,1,2,9,8); set_XMMRegister(1,2,2,3,2);
	__asm { divps   xmm0, xmm1 }	//	0.5,1,3,4

	set_XMMRegister(0,1,2,3,10); set_XMMRegister(1,2,2,3,2);
	__asm { divss   xmm0, xmm1 }	//	1,2,3,5

	set_XMMRegister(0,5,2,7,4); set_XMMRegister(1,4,2,9,5);
	__asm { maxps   xmm0, xmm1 }	//	5,2,9,5

	set_XMMRegister(0,5,2,7,4); set_XMMRegister(1,4,2,9,6);
	__asm { maxss   xmm0, xmm1 }	//	5,2,7,6

	set_XMMRegister(0,5,2,7,4); set_XMMRegister(1,4,2,9,2);
	__asm { maxss   xmm0, xmm1 }	//	5,2,7,4


	set_XMMRegister(0,5,2,7,4); set_XMMRegister(1,4,2,9,3);
	__asm { minps   xmm0, xmm1 }	//	4,2,7,3

	set_XMMRegister(0,1,2,3,7); set_XMMRegister(1,4,2,9,6);
	__asm { minss   xmm0, xmm1 }	//	1,2,3,6

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,4,2,9,6);
	__asm { minss   xmm0, xmm1 }	//	1.2.3.4

	set_XMMRegister(0,1,2,3,4);	set_XMMRegister(1,5,6,7,8);
	__asm { movaps   xmm0, xmm1 }	//	5,6,7,8

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,2,3);
	__asm { movhlps   xmm0, xmm1 }	//	1,2,5,6

	set_XMMRegister(0,1,2,3,4); set_GlobalInt64(6,7);
	__asm { movhps   xmm0, GlobalInt64 }	//	6.7.3.4

	set_XMMRegister(0,1,2,3,4); set_GlobalInt64(6,7);
	__asm { movlps   xmm0, GlobalInt64 }	//	1.2.6.7

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,5,6);
	__asm { movlhps   xmm0, xmm1 }	//	5.6.3.4

	set_XMMRegister(0,1,-2,3,-1);
	__asm { movmskps   eax, xmm0 }	//	5

	
	set_XMMRegister(0,7,8,9,-1);
	__asm { movntps	Var128, xmm0 }

	set_XMMRegister(0,1,2,3,4); fVal = 9;
	__asm { movss   xmm0, fVal }	//	0.0.0.9

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,7,8);
	__asm { movups   xmm0, xmm1 }	//	5,6,7,8

	set_XMMRegister(0,1,2,3,2); set_XMMRegister(1,2,3,0,5);
	__asm { mulps   xmm0, xmm1 }	//	2,6,0,10

	set_XMMRegister(0,1,2,3,2); set_XMMRegister(1,2,3,4,4);
	__asm { mulss   xmm0, xmm1 }	//	1,2,3,8

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,0,3,4,5);
	__asm { orps   xmm0, xmm1 }	//	1,3,6,5

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { rcpps   xmm0, xmm1 }	//	1/2, 1/3, 1/4, 1/5

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,2);
	__asm { rcpss   xmm0, xmm1 }	//	1,2,3,1/2

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,9);
	__asm { rsqrtps   xmm0, xmm1 }	//	reciprocal 1,1.73,2,3

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,9);
	__asm { rsqrtss   xmm0, xmm1 }	//	1,2,3, 1/3


	__asm { sfence }

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,7,8);
	__asm { shufps   xmm0, xmm1, 114 }	//	7,5,4,2

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,9);
	__asm { sqrtps   xmm0, xmm1 }	//	1,1.73,2,3

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,9);
	__asm { sqrtss   xmm0, xmm1 }	//	1,2,3,3

	__asm { stmxcsr   i32Val  }		//	8096 - not important

	set_XMMRegister(0,1,8,5,4); set_XMMRegister(1,2,3,4,1);
	__asm { subps   xmm0, xmm1 }	//	-1,5,1,3

	set_XMMRegister(0,1,8,5,4); set_XMMRegister(1,2,3,4,6);
	__asm { subss   xmm0, xmm1 }	//	1,8,5,-2

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { ucomiss   xmm0, xmm1 }	//	0

	set_XMMRegister(0,1,2,3,5); set_XMMRegister(1,2,3,4,5);
	__asm { ucomiss   xmm0, xmm1 }	//	1


	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,7,8);
	__asm { unpckhps   xmm0, xmm1 }	//	interleaved high - 5,1,6,2

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,7,8);
	__asm { unpcklps   xmm0, xmm1 }	//	interleaved low - 7,3,8,4

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,2,4,5);
	__asm { xorps   xmm0, xmm1 }	//	xor - 0,0,1.76324e-038,2.93874e-039

}


void ClearXMMReg(int regid)
{

	switch(regid)
	{

	case 0:
		__asm { MOVSS XMM0, FLOAT_ZERO }
		break;

	case 1:
		__asm { MOVSS XMM1, FLOAT_ZERO }
		break;

	case 2:
		__asm { MOVSS XMM2, FLOAT_ZERO }
		break;

	case 3:
		__asm { MOVSS XMM3, FLOAT_ZERO }
		break;

	case 4:
		__asm { MOVSS XMM4, FLOAT_ZERO }
		break;

	case 5:
		__asm { MOVSS XMM5, FLOAT_ZERO }
		break;

	case 6:
		__asm { MOVSS XMM6, FLOAT_ZERO }
		break;

	case 7:
		__asm { MOVSS XMM7, FLOAT_ZERO }
		break;

	}

}

void set_GlobalInt64(int Hi, int Low)
{
	__int64 HiVal = FloatVal[Hi - FLOATVAL_BASE];
	__int64 LowVal = FloatVal[Low - FLOATVAL_BASE];

	GlobalInt64 = HiVal;
	GlobalInt64  = GlobalInt64 << 32;
	GlobalInt64 |= LowVal;
}

void set_XMMRegister(int regid, char upper, int Hi, int Low)
{

	switch (regid)
	{
		case 0:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM0, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM0, GlobalInt64 }
					}
					break;

		case 1:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM1, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM1, GlobalInt64 }
					}
					break;


		case 2:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM2, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM2, GlobalInt64 }
					}
					break;

		case 3:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM3, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM3, GlobalInt64 }
					}
					break;


		case 4:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM4, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM4, GlobalInt64 }
					}
					break;

		case 5:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM5, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM5, GlobalInt64 }
					}
					break;

		case 6:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM6, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM6, GlobalInt64 }
					}
					break;

		case 7:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM7, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM7, GlobalInt64 }
					}
					break;
	}
}


void set_XMMRegister(int regid, int X3, int X2, int X1, int X0)
{
	set_XMMRegister(regid, 1, X3, X2);	//	upper 64 bits
	set_XMMRegister(regid, 0, X1, X0);	//	lower 64 bits
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\mem\mem.cpp ===
#include <xtl.h> //#include <windows.h>

// Memory Window Test

void FuncNoArg(void)
{
	return;
}

int FuncWithArg(int nArg)
{
	return nArg;
}


char FuncWithArg(char chArg)
{
	int		nJustLocalInt = 1;
	double	dJustLocalDouble = 3.14;
	return chArg + 2;
}

										/* Last FuncWithArg line */
void __cdecl main()
{
	char			chJustChar = 'M'; 
	char			sJustString[] =  "Mamba-hara-mambu-ru"; /* 19 chars in the string */
	unsigned char	uchJustUnsignedChar = 'u';
	short int		nsJustShort = -123;
	unsigned short	unsJustUnsignedShort = 22987;
	int				nJustInt = -65555;
	unsigned int	unJustUnsignedInt = 655551;
	long int		lJustLongInt = -77777;
	unsigned long	ulJustUnsignedLongInt  = 999999;	
	float			fJustFloat = (float) 123.14;
	double			dJustDouble = -777e50;
	long double		dlJustLongDouble = -999e70;
	__int64			sfJustSixtyFourInt = -1234567890987654909;
	unsigned __int64 sfJustSixtyFourUnsignedInt = 9876543212345678123;

	// Arrays for the Column test
	const int number_of_columns_to_be_tested = 3;

	char			asJustString [number_of_columns_to_be_tested + 2] = "Mamb";
	char			asLongString[8*number_of_columns_to_be_tested + 2] = "Mamba-Tumba-Rumba-Shurum";
	short int		ansJustShort[number_of_columns_to_be_tested + 1] = { -123, 12, -34, 45};
	unsigned short	aunsJustUnsignedShort[number_of_columns_to_be_tested + 1] = { 22987, 126, 334, 645};
	int				anJustInt[number_of_columns_to_be_tested + 1] = { -65555, 112, -354, 4451};
	unsigned int	aunJustUnsignedInt[number_of_columns_to_be_tested + 1] = { 655551, 2112, 9834, 45008};
	long int		alJustLongInt[number_of_columns_to_be_tested + 1] = { -77777, 120087, 3477, 99045};
	unsigned long	aulJustUnsignedLongInt[number_of_columns_to_be_tested + 1]  = { 999999, 77712, 36544, 22245};
	float			afJustFloat[number_of_columns_to_be_tested + 1] = { (float) 123.14, (float) 23.16, (float) 60.70, (float) 2.93};
	double			adJustDouble[number_of_columns_to_be_tested + 1] = { -777e50,  77e22,  12e5,  54e10};
	long double		adlJustLongDouble[number_of_columns_to_be_tested + 1] = { -999e70, 89e3,  18e2,  -4e17};
	__int64			asfJustSixtyFourInt[number_of_columns_to_be_tested + 1] = { -1234567890987654909, 1, -2, -3 };
	unsigned __int64 asfJustSixtyFourUnsignedInt[number_of_columns_to_be_tested + 1] = { 9876543212345678123, 12, 45, 1};

	// Pointers
	int		*pnJustIntPtr = &nJustInt;
	void	*pvJustVoidPtrStr = (void*) &sJustString;
	void	*pvJustVoidPtrShort = (void*) &ansJustShort;
	void	*pvJustVoidPtrInt = (void*) &anJustInt;
	void	*pvJustVoidPtrFloat = (void*) &afJustFloat;
	void	*pvJustVoidPtrDouble = (void*) &adJustDouble;
	void	*pvJustVoidPtrInt64 = (void*) &asfJustSixtyFourUnsignedInt;

	nJustInt++;								/* First line for tests */				
	chJustChar++;

	chJustChar = FuncWithArg(chJustChar);	/* Second line for tests */
	FuncNoArg();							/* Third line for tests */

	return;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\ee2\eetest.cpp ===
#include <xtl.h> //xbox #include <windows.h>

typedef void (*PFNINT)(void*, unsigned long);
typedef int (*PFNVAR)(void*, ...);

void afuncint(void*, DWORD)
{
}

int afuncvar(void*, ...)
{
	return 0;
}

int afunvar1(char*, ...)
{
	return 1;
}

int afunvar2(int*, int, ...)
{
	return 2;
}

class AClass
{
public:
	PFNINT pfnint;
	PFNVAR pfnvar;
protected:
	virtual void __cdecl    virt_method1() {};
	virtual void __fastcall virt_method2(long, ...) {};
};

PFNINT fun_return_pfn()
{
	return afuncint;
}

void pointers_to_functions()
{
	AClass aclass;
	AClass *pclass=&aclass;
	AClass class_table[1];

	PFNINT pfunint_table[1];
	PFNVAR pfunvar;

//pointers to functions
	pfunint_table[0] = afuncint; //eval("pfunint_table[0]")=="ADDRESS afuncint(void*, unsigned int)"
	pfunvar = (PFNVAR)afunvar1; //eval("pfunvar")=="ADDRESS afunvar1(char*, <no type>)"

//pointers to functions as members of class
	aclass.pfnint = afuncint; //eval("pclass->pfnint")=="ADDRESS afuncint(void*, unsigned int)"
	aclass.pfnvar = afuncvar; //eval("pclass->pfnvar")=="ADDRESS afuncvar(void*, <No type>)"
	aclass.pfnvar = (PFNVAR)afunvar1;//eval("pclass->pfnvar")=="ADDRESS afunvar1(char*, <no type>)"
	aclass.pfnvar = (PFNVAR)afunvar2;//eval("pclass->pfnvar")=="ADDRESS afunvar2(int*, int, <no type>)"

	(*aclass.pfnint)(NULL,1000);
	int ret=1;
	ret=(*aclass.pfnvar)(&ret,15,&ret);
//vtable pointers correct
	//eval("(class_table[0]).__vfptr[0]")=="ADDRESS AClass::virt_method1"
	//eval("(class_table[0]).__vfptr[1]")=="ADDRESS AClass::virt_method2"
	memset(class_table,0, sizeof(class_table)); //evaluate the NULL pointers (including virtual pointers)
	class_table[0] = aclass; //eval("class_table[0].pfnint")=="ADDRESS afuncint(void*, unsigned int)"
							//eval("class_table[0].pfnvar")=="ADDRESS afuncvar2(int*, int, <no type>)"
//TODO add the invocation of each function through all pointers and check the result
//	(*pfunc)(); //just like that

//vtable pointers
	//eval("(aclass).__vfptr[0]")=="ADDRESS AClass::virt_method1"
	//eval("(aclass).__vfptr[1]")=="ADDRESS AClass::virt_method2"
//vtable pointers corrupted by memset
	//eval("(class_table[0]).__vfptr[0]")=="Error: cannot display value"
	//eval("(class_table[0]).__vfptr[1]")=="Error: cannot display value"
	fun_return_pfn();
}


REFIID return_Unknown()
{
	REFIID unknown=IID_IUnknown;
	return unknown;
}

GUID return_GUIDUnknown()
{
	GUID guidunknown=IID_IUnknown;
	return guidunknown;
}

/* xbox - no VARIANTS in xbox
VARIANT return_variant()
{
	VARIANT variant;
	variant.vt=VT_I4;			//LONG
	variant.lVal = 0xffff;

	return variant;
}
*/

const GUID unKnownGuid = {0xf0ff0ff0, 0xff0f, 0xff0f, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00}; //global, misc. guid
GUID Global_Guid;
REFIID glob_refiid0=IID_IStub;
REFIID glob_refiid1=IID_IProxy;
void guids_and_refguids()
{
//non-static, local
	GUID Guid =IID_IClassFactory;
//global
	Global_Guid =IID_ISequentialStream;
//pointers to GUIDs
	GUID const *pGuid = &Guid;
	GUID *pBadGuid = NULL; //following NULL pointer
	pBadGuid = (GUID *)5;	//following AV
	REFIID pBadrefId = *pBadGuid;	//following AV
//static, local GUID
	static GUID unKnown = unKnownGuid;

	pGuid =&CLSID_PSGenObject;
	pGuid =&CLSID_PSClientSite;
	Guid =CLSID_PSClassObject;
	Guid =CLSID_PSInPlaceActive;

	//xbox no CATIDs CATID pCAT= CATID_Control;
	//xbox pCAT = CATID_DocObject;

	static REFIID refiid0 =IID_IUnknown;
	static REFIID refiid1 =IID_IRpcChannel;
	static REFIID refiid2 =IID_IRpcStub;
	static REFIID refiid3 =IID_IStubManager;
	static REFIID refiid4 =IID_IStream;
	REFIID refiid5 =IID_IEnumGeneric;
	REFIID refiid6 =IID_IEnumHolder;
	REFIID refiid7 =IID_IEnumCallback;
	REFIID refiid8 =IID_IDebug;
	REFIID refiid9 =IID_IDebugStream;
//global REFIIDs impossible to init here, but they shld be checked here
//	REFIID glob_refiid0=IID_IMarshal;
//	REFIID glob_refiid1=IID_IMalloc;

	return_Unknown();
	return_GUIDUnknown();
}


#if 0 //xbox no VARIANTs in xbox
VARIANT glob_variant; //declaration of global VARIANT
void variants()
{
//static local VARIANT
	static VARIANT variant1;

		variant1.vt = ~VT_BYREF|VT_UI1; //non-existent
		::VariantInit(&variant1); //VT_EMPTY
		variant1.vt = VT_I4;			//LONG
		variant1.lVal = 1052;
		
		variant1.vt = VT_UI1;		//BYTE
		variant1.bVal = 255;

		variant1.vt = VT_I2;			//SHORT
		variant1.iVal = 32000;

		variant1.vt = VT_R4;			//FLOAT
		variant1.fltVal = 20.00;

		variant1.vt = VT_R8;			//DOUBLE
		variant1.dblVal = 3.14e100;

		variant1.vt = VT_BOOL;		//VARIANT_BOOL
		variant1.boolVal = TRUE;

		variant1.vt = VT_ERROR;		//SCODE
		variant1.scode = E_FAIL; //variant.scode,hr=="E_FAIL", but variant=="{0x80004005 VT_ERROR}"

		variant1.vt = VT_CY;			//CY
		variant1.cyVal.Lo = 0xffffffff;variant1.cyVal.Hi = 0x7fffffff;	//variant=="{922337203685477.5807 VT_CY}"

		variant1.vt = VT_DATE;		//DATE //variant=="{???}"
		variant1.date = 35065.000000000; //COleDateTime(1996,1,1,0,0,0); == "{1/1/96 12:00:00 AM VT_DATE}"

//non-static local VARIANT
		VARIANT variant2;
		::VariantInit(&variant2);
		variant2.vt = VT_BSTR;		//BSTR
		WCHAR szW[100];MultiByteToWideChar(CP_ACP, 0, "BSTR test", -1, szW, 100);
		variant2.bstrVal = ::SysAllocString(szW);
		::SysFreeString(variant2.bstrVal);

		variant2.vt = VT_UNKNOWN;	//IUnknown*
		variant2.lVal = 255; //punkVal: see if bogus value works here

		variant2.vt = VT_DISPATCH;	//IDispatch*
		variant2.lVal = 255; //ppdispVal see if bogus value works here

		variant2.vt = VT_ARRAY;		//SAFEARRAY*
		variant2.lVal = 255; //pparray

//global VARIANT
		::VariantInit(&glob_variant);
		glob_variant.vt = VT_UI1|VT_BYREF;//BYTE*
		BYTE pbVal=255;glob_variant.pbVal = &pbVal; 

		glob_variant.vt = VT_I2|VT_BYREF;//SHORT*
		SHORT piVal=1000;glob_variant.piVal = &piVal;

		glob_variant.vt = VT_I4|VT_BYREF;//LONG*
		LONG plVal=1000000;glob_variant.plVal = &plVal;

		glob_variant.vt = VT_R4|VT_BYREF;//FLOAT*
		FLOAT pfltVal=20.00;glob_variant.pfltVal = &pfltVal;

		glob_variant.vt = VT_R8|VT_BYREF;//DOUBLE*
		DOUBLE pdblVal=10;glob_variant.pdblVal = &pdblVal;

		glob_variant.vt = VT_BOOL|VT_BYREF;//VARIANT_BOOL*
		VARIANT_BOOL pboolVal=FALSE;glob_variant.pboolVal = &pboolVal;

		glob_variant.vt = VT_ERROR|VT_BYREF;//SCODE*
		SCODE pscode=E_NOTIMPL; glob_variant.pscode = &pscode;

		glob_variant.vt = VT_CY|VT_BYREF;//CY*
		CY pcyVal;pcyVal.int64=0x7fffffffffffffffUL+1;glob_variant.pcyVal = &pcyVal; //variant=="{-922337203685477.5808 VT_CY|VT_BYREF}"

		glob_variant.vt = VT_DATE|VT_BYREF;//DATE*
		DATE pdate=35642.952071759/*COleDateTime(1997,07,31,22,50,59)*/;glob_variant.pdate = &pdate; //=="{7/31/97 10:50:59 PM VT_DATE|VT_BYREF}"

		glob_variant.vt = VT_UNKNOWN|VT_BYREF;//IUnknown **
		glob_variant.lVal = 5; //ppunkVal

		glob_variant.vt = VT_DISPATCH|VT_BYREF;//IDispatch **
		glob_variant.lVal = 5; //ppdispVal

		glob_variant.vt = VT_ARRAY|VT_BYREF;//SAFEARRAY **
		glob_variant.lVal = 5; //pparray

		glob_variant.vt = VT_VARIANT|VT_BYREF;//VARIANT *
		glob_variant.pvarVal = &glob_variant; //circular reference
		glob_variant.pvarVal = &variant2; //non-static,local variant referenced

		glob_variant.vt = VT_BSTR|VT_BYREF;//BSTR*
		//WCHAR szW[100];
		MultiByteToWideChar(CP_ACP, 0, "PBST test", -1, szW, 100);
		BSTR pbstrVal=::SysAllocString(szW);glob_variant.pbstrVal = &pbstrVal;
		SysFreeString(pbstrVal);

//subvariant - non-statc, local variant
		VARIANT subvariant;
		::VariantInit(&subvariant);
		subvariant.vt = VT_I4;
		subvariant.lVal = 10;
		variant2.vt = VT_BYREF;		//PVOID
		void* anyref=&subvariant;variant2.byref = &subvariant;

		variant2.vt = VT_I1;			//CHAR
		variant2.cVal = 'V';

		variant2.vt = VT_UI2;		//USHORT
		variant2.uiVal = 0xffff;

		variant2.vt = VT_UI4;		//ULONG
		variant2.ulVal = 0xffffffff;

		variant2.vt = VT_INT;		//INT
		variant2.intVal = -256;

		variant2.vt = VT_UINT;		//UINT
		variant2.uintVal = 256;

		variant2.vt = VT_DECIMAL|VT_BYREF;//DECIMAL *
		DECIMAL dec; memset(&dec, 0, sizeof(dec)); dec.Hi32=1; dec.scale=28; variant2.pdecVal = &dec;

		variant2.vt = VT_I1|VT_BYREF;//CHAR *
		variant2.pcVal = "char string test";

		variant2.vt = VT_UI2|VT_BYREF;//USHORT *
		variant2.puiVal = (USHORT*)&variant2; //bogus

		variant2.vt = VT_UI4|VT_BYREF;//ULONG *
		variant2.pulVal = (ULONG *)5; //error test

		variant2.vt = VT_INT|VT_BYREF;//INT *
		variant2.pintVal = NULL; //error test

		variant2.vt = VT_UINT|VT_BYREF;//UINT *
		variant2.puintVal = (UINT *)255; //still error

		return_variant();
}
#endif


BOOL MMX_Chip()
{
#pragma warning(disable:4035)
	__asm{
		mov eax,1;
		_emit 0x0f; //CPUID
		_emit 0xa2; //CPUID
		mov eax,1;
		test edx,0x0800000;
		jnz Yes
		mov eax,0
Yes:
	}
	return;
#pragma warning(default:4035)
} //MMX_Chip()

#pragma warning(disable:4799)
void MMXRegs()
{
	__int64 qmemory0=
		1+1*0x100000000;
	__int64 qmemory1=
		2+2*0x100000000;
	__int64 qmemory2=
		4+4*0x100000000;
	__int64 qmemory3=
		8+8*0x100000000;
	__int64 qmemory4=
		16+16*0x100000000;
	__int64 qmemory5=
		32+32*0x100000000;
	__int64 qmemory6=
		64+64*0x100000000;
	__int64 qmemory7=
		128+128*0x100000000;
if(MMX_Chip())
{
	int mm0=-10,Mm0=-20,mM0=-30;
	int mm1=-11,Mm1=-21,mM1=-31;
	int mm2=-12,Mm2=-22,mM2=-32;
	int mm3=-13,Mm3=-23,mM3=-33;
	__asm{
		movd mm0,ebx; //long(mm0)==ebx
		movd mm1,edx; //long(mm1)==edx
		movd mm2,esp; //long(mm2)==esp
		movd mm3,ebp; //long(mm3)==ebp

		movq mm0,qmemory0; //mm0==qmemory0
		movq mm1,qmemory1; //...
		movq mm2,qmemory2;
		movq mm3,qmemory3;
		movq mm4,qmemory4;
		movq mm5,qmemory5;
		movq mm6,qmemory6;
		movq mm7,qmemory7;
//the following sequence shldn't change the low words of mm0..mm7
		movd mm0,qmemory0; //mm0==long(qmemory0)
		movd mm1,qmemory1; //...
		movd mm2,qmemory2;
		movd mm3,qmemory3;
		movd mm4,qmemory4;
		movd mm5,qmemory5;
		movd mm6,qmemory6;
		movd mm7,qmemory7;

		movd eax,mm7; //eax==long(mm7)
//change mm0..mm7 manually
		movq qmemory0,mm0;
		movq qmemory1,mm1;
		movq qmemory2,mm2;
		movq qmemory3,mm3;
		movq qmemory4,mm4;
		movq qmemory5,mm5;
		movq qmemory6,mm6;
		movq qmemory7,mm7;
//check if qmemory[0..7] is what you've changed
//TODO some arithmetics (pand paad psub)
	} //__asm

} //if
} //MMXRegs()
#pragma warning(default:4799)

void __cdecl main()
{
	pointers_to_functions();
	
	guids_and_refguids();
	
	//xbox variants();

	MMXRegs();
//TODO add sth with safearray
//TODO come up with more values (different facilities) & unknown valuses (bad values do not apply)
//hresults & errors & misc (@TIB, @MM)
	HRESULT s_ok = S_OK;

	HRESULT s_err = E_NOINTERFACE;

	HRESULT s_unexp = E_UNEXPECTED;

	HRESULT s_eomem = E_OUTOFMEMORY;

	SetLastError(42);


	_asm int 3;					// stop here
	return;
}

//	Eval					Expected			VC5.0 did
//	pfunc					ADDR func			ADDR
//	(aclass).__vfptr[0x0]	ADDR AClass::f1		ADDR
//	@ERR					42					N/A
//	@TIB					ADDR				N/A
//	@MM0					ADDR64				N/A
//	refiid					{IID_IUnknown}		{...}
//	pGuid					{IID_IClassFactory}	{...}
//	variant					{42 VT_I4}			{...}
//	s_ok,hr					S_OK				N/A
//	5,hr					0x00000005 Access is denied.	N/A


/* GLS script
launch ee2\debug\ee2.exe
until EntryPointEvent2 wait
go
until CodeBreakpointEvent2 wait
seval "pfunc","ADDRESS func"
seval "(aclass).__vfptr[0x0]","ADDRESS AClass::f1"
#seval "@ERR","42"
#seval "@TIB,x","ADDRESS "
#seval "@MM0","ADDRESS64 "
seval "refiid","{IID_IUnknown}"
seval "pGuid","{IID_IClassFactory}"
seval "variant","{42 VT_I4}"
seval "s_ok,hr","S_OK"
seval "5,hr","0x00000005 Access is denied. "
seval "pBadGuid","ADDRESS {????????-????-????-????-????????????}"
go
until SessionDestroyEvent2 wait
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\locpane\Locals Application.cpp ===
#include <xtl.h> //xbox #include <windows.h>

// Locals Test

void FuncNoArg(void)
{
	return;
}

char FuncWithArg(char chArg)
{
	int		nJustLocalInt = 1;
	double	dJustLocalDouble = 3.14;
	return chArg + 2;
}										/* Last FuncWithArg line */
int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	char	chJustChar = 'a'; 
	int		nJustInt = 1965;
	int		&nJustIntRef =  nJustInt;
	double	dJustDouble = 2.92;

	nJustInt++;								/* First line for tests */				
	chJustChar++;

	chJustChar = FuncWithArg(chJustChar);	/* Second line for tests */
	FuncNoArg();							/* Third line for tests */

	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\ljmp01.cpp ===
// fpreset.c 
//#include <stdio.h>
//#include <signal.h>
#include <setjmp.h>
//#include <stdlib.h>
#include <float.h>
#include <math.h>
//#include <string.h>
#include "nlgmain.h"

jmp_buf mark;
int     error;
double check( int i );

//void main( void )
void ljmp01(void)
{
	double n1, n2, r1, r2;
	int jmpret;
#ifndef _68K_
	for( int i = 0; i < 100; i++ )
	{
		jmpret = setjmp( mark );
		if( jmpret == 0 )
		{
			n1 = 0.5 * (i + 3);
			r2 = (i + 7);
			r2 /= 7;
			n2 = modf( r2 , &r1 );
			if( n2 <= 0.0000000001 )
			{
				longjmp( mark, -1 );
			}
			else
			{
				r1 = n1/n2;
			}
		}
		else
			r1 = check(i);
	}

	for( i = 0; i < 100; i++ )
	{
		jmpret = setjmp( mark );
		switch( jmpret )
		{
			case 0:
				n1 = 0.5 * (i + 3);
				r2 = (i + 7);
				r2 /= 7;
				n2 = modf( r2 , &r1 );
				if( n2 <= 0.0000000001 )
				{
					ljmp02( mark, i );
				}
				else
				{
					r1 = n1/n2;
				}
				break;
			case -1:
				r1 = check(i);
				break;
			case 1:
				r1 = check(i) + 2.5;
				break;
			case 2:
				r1 = i * (i + 2) * 1.5;
				break;
			default:
				break;
		}
	}
#endif
}

double check( int i )
{
	return ( 0.7 * (i + 2)	);	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\ehutil.h ===
#ifndef EHUTIL_H
#define EHUTIL_H


class ThrowObject {
public:
	ThrowObject();
	ThrowObject( int i );
	ThrowObject( const ThrowObject& );
	~ThrowObject();

private:
	int m_i;
	int m_iCopy;
};

extern int counter;
extern int ctorCounter;
extern int dtorCounter;


#endif // EHUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\namspace\nspace01.cpp ===
#include <xtl.h> //xbox #include <windows.h>

int i = 0;
int j = 0;

namespace n1
	
	{
	int i = 1;
	int j = 1;

	void func(void)
		{				// first line of n1::func()
		int local = 3;
		}

	namespace n2
		{
		int i = 2;
		int j = 2;
		}
	}

void __cdecl main()
	{
	using namespace n1;
	func();
	if (j==1) {
		j += 2;
	}
	else {
		j *= 10; 
	}
	return;		// line after n1::j changed
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\retval\lineonly.cpp ===
int line_numbers_only(void)
	{
	return 1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\retval\nodebug.cpp ===
int no_debug_info(void)
	{
	return 1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\eh02.cpp ===
#include "ehutil.h"
#include "nlgmain.h"

extern int counter;

void Case3() {
	//	try-block with unhandled throw
	try {
		++counter;
		ThrowObject t(3);
		throw t;
	}
	catch( int ) {
		++counter; // Should not execute
	}
	++counter; // Should not execute
}

void Case7() {
	//	Rethrow from inner try-block handler caught in outer handler
	try {
		++counter;
		try {
			++counter;
			ThrowObject t(7);
			throw t;
//  int ii=5;
//  throw ii;
			++counter; // Should not execute
		}
		catch( int ) {			
			++counter; // Should execute
			throw;

			++counter; // Should not execute
		}
		catch( ThrowObject& ) {			
			++counter; // Should execute
			throw;

			++counter; // Should not execute
		}
		++counter; // Should not execute
	}
	catch( int ) {
		++counter; // Should execute
	}
	catch( ThrowObject o ) {
		++counter; // Should execute
	}

	++counter; // Should execute

	Case5();   // throws t and catches it
}


void Case8() {
	//	Throw from inner try-block caught in outer handler; Ctor throws an int
	try {
		++counter;
		try {			
			++counter;
			ThrowObject t(8);
			t = ThrowObject(80);
			throw t;

			++counter; // Should not execute
		}
		catch( int ) {
			++counter; // Should execute
		}
		++counter; // Should execute ?
	}
	catch( ThrowObject o ) {
		++counter; // Should execute
	}
	++counter; // Should execute
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\ljmp02.cpp ===
#include "nlgmain.h"
#include <setjmp.h>
#include <float.h>
#include <math.h>

//jmp_buf mark;

void ljmp02(jmp_buf mark, int nCase)
{
	int i = (int)(fmod(nCase, 3.0));
	if( i == 0 )
		longjmp( mark, -1 );
	else
		longjmp( mark, i );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\seh01\seh01.cpp ===
#include "sehutil.h"
#include "seh01.h"

int main()
{
	Seh01();

	return 0;
}

void Seh01()
{
	SehCase1();
	SehCase2();
	SehCase3();
	SehCase4();
	SehCase6();
	SehCase8();

	SehCase5();
	SehCase7();

}

void SehCase1() 
{
	++counter;

	//	Simple __try/__except with no exception.

	__try {
		++counter;
		RaiseNoException();
	}
	__except( ++counter, ExecuteHandler() ) {
		++counter; // Code should be skipped.
	}
	++counter; // should execute	
}

void SehCase2() 
{
	++counter;

	//	Simple __try/__finally with no exception.

	__try {
		++counter;
		RaiseNoException();
	}
	__finally {
		++counter; // should execute	
	}	
}

void SehCase3() 
{
	++counter;

	//	Simple __try/__except: EXCEPTION_CONTINUE_EXECUTION.

	__try {
		++counter;
		//	Use software exception from RaiseIntDivideByZero() instead of 
		//	hardware exception from IntDivideByZero() since continuing execution
		//	without fixing fault condition causes an infinite loop.

		RaiseIntDivideByZero();

		++counter; // Should continue here
	}
	__except( ++counter, ContinueExecution() ) {
		++counter; // Code should be skipped.
	}	
	++counter; // should execute	
}

void SehCase4() 
{
	++counter;

	//	Simple __try/__except: EXCEPTION_EXECUTE_HANDLER.

	__try {
		++counter;
		IntDivideByZero();
		//	Should no reach here.
		++counter;
	}
	__except( ++counter, ExecuteHandler() ) {
		++counter; // should execute	
	}	
}

void SehCase5() 
{
	++counter;

	//	Simple __try/__except: EXCEPTION_CONTINUE_SEARCH.

	__try {
		++counter;

		IntDivideByZero();
		//	Code could be executed if final handler returns
		//	EXCEPTION_CONTINUE_EXECUTION.
		++counter;
	}
	__except( ++counter, ContinueSearch() ) {
		++counter; // Code should be skipped
	}	
	++counter; // should execute	
}

void SehCase6() 
{
	++counter;

	//	Simple __try/__finally with exception.

	__try {
		++counter;
		__try {
			++counter;
			IntDivideByZero();
			//	Should no reach here.
			++counter;
		}
		__finally {
			++counter; // should execute	
		}
		//	Should not reach here.
		++counter;
	}
	__except( ++counter, ExecuteHandler() ) {
		++counter; // should execute	
	}
}


void SehCase7() 
{
	++counter;

	//	__try/__except: EXCEPTION_CONTINUE_SEARCH.

	__try {
		++counter;
		__try {
			++counter;

			IntDivideByZero();
			//	Code could be executed if final handler returns
			//	EXCEPTION_CONTINUE_EXECUTION.
			++counter;
		}
		__except( ++counter, ContinueSearch() ) {
			++counter; // Code should be skipped
		}	
		++counter; // should execute
	}	
	__except( ++counter, ContinueExecution() ) {
		++counter; // Code should be skipped
	}	
	++counter; // should execute	
}

void SehCase8() 
{
	++counter;

	//	Simple __try/__finally with exception.

	__try {	
		++counter; 
		__try { ++counter; RaiseIntDivideByZero(); /* Should no reach here */ ++counter;}
		__finally { ++counter; /* should execute */ }
		//	Should not reach here.
		++counter;
	}
	__except( ++counter, ExecuteHandler() ) {
		++counter; // should execute	
	}

	__try { ++counter; RaiseIntDivideByZero(); ++counter; /* Should continue here */ }
	__except( ++counter, ContinueExecution() ) { ++counter; /* Code should be skipped */ }	
	++counter; // should execute	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\seh01\seh01.h ===
#ifndef SEH01_H
#define SEH01_H

void Seh01();
void SehCase1();
void SehCase2();
void SehCase3();
void SehCase4();
void SehCase5();
void SehCase6();
void SehCase7();
void SehCase8();

#endif  // SEH01_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\nlgmain.cpp ===
// nlgmain.cpp 
#include <xtl.h> // #include <windows.h>
#include "nlgmain.h"

void __cdecl main()
{
	eh01();		// C++ exception handling cases
	ljmp01();		// Setjmp/Longjmp cases

	while(1); /* xbox */ return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\ehutil.cpp ===
#include "ehutil.h"


ThrowObject::ThrowObject() {
	m_i = 0; m_iCopy = 0;
}


ThrowObject::ThrowObject( int i ) {
	m_i = i; m_iCopy = 0;
}


ThrowObject::ThrowObject( const ThrowObject& src) {
	++ctorCounter;
	m_i = src.m_i; m_iCopy = src.m_iCopy + 1;

	//	Decrement m_i if non-zero and throw exception if m_i 
	//	decrements to 0.
//	if( m_i > 0 ) {
//		m_i--;
//		if( m_i == 0 ) {
//			throw m_i;
//		}
//	}
}


ThrowObject::~ThrowObject() {
	++dtorCounter;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\nlg\nlgmain.h ===
// nlgmain.h
#include <setjmp.h>
 
#ifndef NLGMAIN_H
#define NLGMAIN_H

void eh01(void);
void ljmp01(void);
void ljmp02(jmp_buf mark, int nCase);

void Case1();
void Case2();
void Case3();
void Case4();
void Case5();
void Case6();
void Case7();
void Case8();


#endif // NLGMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\registers\registers.cpp ===
#include <xtl.h> //xbox #include <windows.h>


DWORD dwMainThreadID;
DWORD dwSecondaryThreadID;


LPTHREAD_START_ROUTINE ThreadRoutine(LPVOID pArg)
{
	while(1)
		Sleep(5000);		/* Thread proc */		
	return 0;
}

int Foo(int nArg)
{
	return nArg*2;
}							/* Return form Foo */


void __cdecl main()
{

	HANDLE hThread;
	int res = Foo(7);		/* First line for tests */

	double y = 1e-19;
	_asm fld y;
	
	float f1;

	/* check Overflow exception */
	f1 = (float) 1.234567e38;
	f1 *= f1;
	f1 *= f1;	/* Exception should be here for CTRL 277 */
	f1 *= f1;

	/* check divide by zero exception */
	f1 = 10.;
	f1 /= 0;	/* Exception should be here for CTRL 27B */


	dwMainThreadID = GetCurrentThreadId();
	hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadRoutine, (void*) &res, 0L, &dwSecondaryThreadID);
	ResumeThread(hThread);

	while(1)						
		Sleep(5000);

	while (1); /* never exit */ return;							
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\spcfc01\Spcfc02.cpp ===
#include "spcfc01.h"

void nest_func(int N)
{
 	if (func(1)) 
   	func (recur_func() + func(N));
};

int func(int N)
{ 
//		__asm int 3
	return N*2;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\spcfc01\Spcfc01.cpp ===
//#include <afx.h>
#include <iostream.h>
#include <assert.h>

#include "spcfc01.h"
#define ArrayLength 100
#define StructString65 "String65String65String65String65String65String65String65String65"
#define LocalString65  "__local_String65__local_String65__local_String65__local_String65"
#define Flag 1

int Global;

struct Struct 
{
   int IntN;
   char *String65;
} StructG;

union Union 
{
   int Int;
   long Long;
} UnionG;

enum Enum 
{
  zero,
  one,
  two,
  three
} EnumG;


int myAssert(int exp)
{
	__asm int 3
	return 1;
}

static int foo(int Parameter);
int foo(int Parameter)
{
	int i = foo_Include(Parameter);
    return (i + Parameter);
};

int recur_func() 
{
   static x=1;
   x++;
   if (x<9) return recur_func();
   else return x;
};

int TestG()
{
 	int Local;
 	int Int;
 	long Long;
 	double Double;
 	long double Ldouble;
 	float Real;
 	char *String;
 	My_typedef Mine = 99;
 
	struct Struct Struct_local;

 	struct Struct Array_struct[ArrayLength];
 	int  Array1d[3];
 	long Array2d[3][3];
 	char Array3d[3][3][3];

 	if (Flag) 
	{

		for (Int=0; Int < ArrayLength; Int++)
   		{						                      // not executable code line
			Array_struct[Int].IntN = Int;
			Array_struct[Int].String65 = StructString65;
		};	  
 	};

 	for (Int=0; Int<3; Int++) 
	{
		Array1d[Int]=Int;
     	Array2d[Int][Int]=Int;
     	Array3d[Int][Int][Int]=Int;
  	};
	
	Local=17;
 	Array1d[2]=9;
 	StructG.IntN = 1;
 	StructG.String65 = StructString65;
 	Struct_local.IntN = 11;
 	Struct_local.String65 = LocalString65;
 	Int=2;Int=6;Int=9;
 	Real=(float)1.303;
 	Double=1.303;
 	Ldouble=1.303;
 	String="this is a string";
 	Global=77;
 	Long=99;
 	Int=func(3);
 	Int=foo(Local);
	Int = foo_Include(Int);
	Mine = foo_Include(Mine);
 	Int=recur_func();
  	nest_func(foo_Include(foo(Global)));

	Int = foo( foo_Include( foo( func(2) ) ) );
	Int = foo( foo_Include( foo( recur_func() ) ) );
	Int = foo( foo_Include(foo(foo_Include(func(5)))));
	Mine = foo_Include( foo_Include( foo( func(7) ) ) );

if(func(3) == 33)goto LabeL;
	Int = 999;
LabeL: 	return 1;
}



template <class Type> class Array;
template <class Type> ostream& 
	operator<<(ostream&, Array<Type>&);

const int ArraySize = 12;

template <class Type>
class Array 
{
public:
	Array(int sz=ArraySize) { init(0,sz); }
	Array(const Type *ar, int sz) { init(ar,sz); }
	Array(const Array &iA) { init(iA.ia, iA.size); }
	~Array() { delete [] ia; }

	Array& operator=(const Array&);
	int getSize() {return size; }
	void grow();
	Array& ngrow(int = 1);
	void print(ostream& = cout);

	Type& operator[](int ix) { return ia[ix]; }
	int find(Type);
	Type minar();
	Type maxar();
	static void static_func(int);

private:
	void swap(int,int);
	void init(const Type*, int);

	int size;
	Type *ia;

	static int static_int;
};

int Array<int>::static_int = 5;
int Array<double>::static_int = 15;

template <class Type> ostream&
	operator<<(ostream& os, Array<Type>& ar)
{
	ar.print(os);
	return os;
}

template <class Type> 
void Array<Type>::print(ostream& os)
{
	const lineLength = 12;
	
	os << " { " << size << " )< " ;
	for (int ix = 0; ix < size; ++ix)
	{
		if (ix % lineLength == 0 && ix) os << "\n\t";
		os << ia[ix];

		if (ix % lineLength != lineLength - 1 && ix != size - 1)
			os << ", ";
	}
	os << " >\n";
}


template <class Type> Array<Type>&
Array<Type>::operator=(const Array<Type> &iA)
{
	if (this == &iA) return *this;
	delete [] ia;
	init( iA.ia, iA.size );
	return *this;
}

template <class Type> void
Array<Type>::init(const Type *array, int sz)
{
	ia = new Type[size = sz];
	assert( ia != 0 );
					   
	for (int ix = 0; ix < size; ++ix)
		ia[ix] = (array!=0) ?  array[ix] : (Type)0;

	static_int = size;
}

template <class Type> Array<Type>&
Array<Type>::ngrow(int igrow)
{
	for (int i = 0; i < igrow; i++)
	    this->grow();
	return *this;
}

template <class Type> void
Array<Type>::grow()
{
	Type *oldia = ia;
	int oldSize = size;
	int newSize = oldSize + oldSize/2 + 1;

	ia = new Type[size = newSize];
	assert( ia != 0 );
	
	for (int i=0; i<oldSize; ++i) ia[i] = oldia[i];
	for (; i<size; ++i) ia[i] = (Type)0;

	delete oldia;
}


template <class Type> Type 
Array<Type>::minar()
{
	assert( ia != 0 );
	Type min_val = ia[0];
	
	for (int ix=1; ix<size; ++ix)
		if(min_val > ia[ix]) min_val = ia[ix];

	return min_val;
}


template <class Type> 
Type Array<Type>::maxar()
{
	assert( ia != 0 );
	Type max_val = ia[0];
	
	for (int ix=1; ix<size; ++ix)
		if(max_val < ia[ix]) max_val = ia[ix];

	return max_val;
}


template <class Type> 
int Array<Type>::find(Type val)
{
	for (int ix=1; ix<size; ++ix)
		if(val == ia[ix]) return ix;

	return -1;
}


template <class Type> 
void Array<Type>::swap(int i, int j)
{
	Type tmp = ia[i];
	ia[i] = ia[j];
	ia[j] = tmp;
}

template <class Type> void 
Array<Type>::static_func(int par)
{
	int ix = static_int + par;
}

template <class Type>
void try_array( Array<Type> &iA )
{
	Type find_val = iA[2];
	iA[iA.getSize()-1] = iA.minar();

	int mid = iA.getSize()/2;
	iA.static_func(mid);
	iA[0] = iA.maxar();
	iA[mid] = iA[0];

	Array<Type> iA2 =iA;
	iA[mid/2] = iA[mid];

	iA = iA2;

	iA.grow();

	int index = iA.find(find_val);

	if(index < 0)
	;
  	else
	{
		Type value = iA[index];
	}

}

int main(void)
{
	static int ia[] = {12, 7, 14, 9, 128, 17, 6, 3, 27, 5};
	static double da[] = {12.3, 7.9, 14.6, 9.8, 128.0};

	Array<int> iA(ia, sizeof(ia)/sizeof(int));
	Array<double> dA(da, sizeof(da)/sizeof(double));

	cout << "template Array<int> class\n" << endl;
	try_array(iA);
	try_array(iA.ngrow(2));

	cout << "template Array<double> class\n" << endl;
	try_array(dA);
	iA.static_func(iA.getSize());
	dA.static_func(iA.getSize());

	int iGo = TestG();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\Registers PP\Registers PP.cpp ===
#include <xtl.h> //xbox #include <windows.h>

__int64 GlobalInt64 = 0;

void set_GlobalInt64(int Hi, int Low);
void set_XMMRegister(int regid, char upper, int Hi, int Low);
void set_XMMRegister(int regid, int X3, int X2, int X1, int X0);

__int64 FloatVal[] =	//	32 bit register values for each integer
{
	0,				//	0
	0x3F800000,		//	1
	0x40000000,		//	2
	0x40400000,		//	3
	0x40800000,		//	4
	0x40A00000,		//	5
	0x40C00000,		//	6
	0x40E00000,		//	7	
	0x41000000,		//	8
	0x41100000,		//	9
	0x41200000,		//	10
	0x41300000,		//	11
	0x41400000,		//	12
	0x41500000,		//	13
	0x41600000,		//	14
	0x41700000,		//	15
	0x41800000,		//	16
	0x41880000,		//	17	
	0x41900000,		//	18
	0x41980000,		//	19
	0x41A00000,		//	20
	0x41A80000,		//	21
	0x41B00000,		//	22
	0x41B80000,		//	23
	0x41C00000,		//	24
	0x41C80000,		//	25
	0x41D00000,		//	26
	0x41D80000,		//	27	
	0x41E00000,		//	28
	0x41E80000,		//	29
	0x41F00000,		//	30
	0x41F80000,		//	31
	0x42000000,		//	32
};

void TestMMX()
{
	//	MMX test
	
	__int64 regVal = 0;

	regVal = 100;
	__asm { MOVQ MM0, regVal }

	regVal = 200;
	__asm { MOVQ MM1, regVal }

	regVal = 300;
	__asm { MOVQ MM2, regVal }

	regVal = 400;
	__asm { MOVQ MM3, regVal }

	regVal = 500;
	__asm { MOVQ MM4, regVal }

	regVal = 600;
	__asm { MOVQ MM5, regVal }

	regVal = 700;
	__asm { MOVQ MM6, regVal }

	regVal = 800;
	__asm { MOVQ MM7, regVal }

	regVal = 0;
	regVal = 1;
}

void TestXMM()
{
	//	XMM test
	
	float fVal = 0;

	set_XMMRegister(0,4,3,2,1); 
	set_XMMRegister(1,8,7,6,5);
	set_XMMRegister(2,12,11,10,9); 
	set_XMMRegister(3,16,15,14,13);
	set_XMMRegister(4,20,19,18,17); 
	set_XMMRegister(5,24,23,22,21);
	set_XMMRegister(6,28,27,26,25); 
	set_XMMRegister(7,32,31,30,29);

	fVal = 1.0;
	fVal = 2.0;
	fVal = 3.0;
}


void __cdecl main()
{
	//	MMX & MMX2 tests for 3dNow, Katmai
	TestMMX();
	TestXMM();

	while (1); /* never exit */ return;							
}

void set_GlobalInt64(int Hi, int Low)
{
	__int64 HiVal = FloatVal[Hi];
	__int64 LowVal = FloatVal[Low];

	GlobalInt64 = HiVal;
	GlobalInt64  = GlobalInt64 << 32;
	GlobalInt64 |= LowVal;
}

void set_XMMRegister(int regid, char upper, int Hi, int Low)
{

	switch (regid)
	{
		case 0:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM0, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM0, GlobalInt64 }
					}
					break;

		case 1:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM1, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM1, GlobalInt64 }
					}
					break;


		case 2:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM2, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM2, GlobalInt64 }
					}
					break;

		case 3:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM3, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM3, GlobalInt64 }
					}
					break;


		case 4:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM4, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM4, GlobalInt64 }
					}
					break;

		case 5:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM5, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM5, GlobalInt64 }
					}
					break;

		case 6:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM6, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM6, GlobalInt64 }
					}
					break;

		case 7:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM7, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM7, GlobalInt64 }
					}
					break;
	}
}


void set_XMMRegister(int regid, int X3, int X2, int X1, int X0)
{
	set_XMMRegister(regid, 1, X3, X2);	//	upper 64 bits
	set_XMMRegister(regid, 0, X1, X0);	//	lower 64 bits
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\seh01\sehutil.h ===
//
//	Use counter for tracing execution/setting breakpoints
//
//#include <wtypes.h>
#include <xtl.h> // types like LONG are pulled via xtl

extern int counter;

//	Functions for causing exceptions.

void RaiseNoException();
void RaiseIntDivideByZero();
void RaiseControlC();
void IntDivideByZero();


//	Functions used for filter-expressions.

LONG ContinueExecution();
LONG ExecuteHandler();
LONG ContinueSearch();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__dd.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



double	_cdecl CFncDD(double PSd)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSd = (double)counter;
    }
    return PSd;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\retval\retval.cpp ===
#include <xtl.h>

void func_void(void)
	{
	}

char func_char(void)
	{
	return CHAR_MAX;
	}

unsigned char func_uchar(void)
	{
	return UCHAR_MAX;
	}

int func_int(void)
	{
	return INT_MAX;
	}

unsigned int func_uint(void)
	{
	return UINT_MAX;
	}

long func_long(void)
	{
	return LONG_MAX;
	}

unsigned long func_ulong(void)
	{
	return ULONG_MAX;
	}

float func_float(void)
	{
	return FLT_MAX;
	}
	
double func_double(void)
	{
	return DBL_MAX;
	}

long double func_ldouble(void)
	{
	return LDBL_MAX;
	}

class base
	{
	public: 
		int m_var;
		virtual int m_func(void){return 0;}
		int overloaded_func(int i){return i;}
	};

class derived : public base
	{
	public:
		virtual int m_func(void){return m_var;}
		char overloaded_func(char ch){return ch;}
	};

base func_class(void)
	{
	base b;
	b.m_var = 1;
	return b;
	}

base *func_pclass(void)
	{
	base *pb = new base;
	pb->m_var = 1;
	return pb;
	}

void func_throw(void)
	{
	throw 0;
	}

int recursive_func(int i)
	
	{
	if(i == 5)
		return i; // most nested return
	else
		{
		recursive_func(i + 1);
		return i;
		} 
	}

#ifndef _MPPC_
int __fastcall fastcall_func(void)
	{
	return 1;
	}
#endif // _MPPC_
		
int	no_debug_info(void);
int	line_numbers_only(void);
//int dll_func(void);

int overloaded_func(int i){return i;}
char overloaded_func(char ch){return ch;}


void __cdecl main()
	
	{
	func_void();

	for(0;0;0);
	while(0);

	char ch = func_char();
	unsigned char uch = func_uchar();
	int i = func_int();
	unsigned int ui = func_uint();
	long l = func_long();
	unsigned long ul = func_ulong();
	float flt = func_float();
	double dbl = func_double();
	long double ldbl = func_ldouble();

	base b = func_class();
	base *pb = func_pclass();

	GetLastError();
	no_debug_info();
	line_numbers_only();
	recursive_func(1);

#ifndef _MPPC_
	fastcall_func();
#endif // _MPPC_

	abs(-1);
	while(0);

	base *pd = new derived;
	pd->m_var = 1;
	pd->m_func();
	while(0);

	pb->overloaded_func(1);
	pb->overloaded_func('a');
	overloaded_func(2);
	overloaded_func('b');

#ifndef _68K_
	//dll_func();
#endif // _68K_

	try
		{
		func_throw();
		}

	catch(...)
		{
		}

	while (1); return; //xbox never exit main
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\spcfc01\Spcfc01.h ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static int foo_Include(int number);
int TestG(void);
int func(int);
int recur_func();
void nest_func(int);
typedef int My_typedef;
int main(void);

int foo_Include(int number)
{
	number*=2;
	if(number == 3)
	{
		return (-1);
	}
	return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\seh01\sehutil.cpp ===
//		Utility functions for SEH.

//#include "stdafx.h"
//not in xbox - #include <wtypes.h>
#include <excpt.h>
//#include <afxwin.h>
#include "sehutil.h"

//	Use counter for tracing execution/setting breakpoints

int counter = 0;


//	Functions for causing exceptions.

void RaiseNoException() {
	//
	//	Empty function call
	//
}

void RaiseIntDivideByZero() {
	RaiseException( EXCEPTION_INT_DIVIDE_BY_ZERO, 0, 0, NULL );
}

void RaiseControlC() {
	RaiseException( DBG_CONTROL_C, 0, 0, NULL );
	//	GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0)
}

void IntDivideByZero() {
	int i = 1;
	int j = 0;
	int k;
	k = i/j;
}

//
//	Functions used for filter-expressions.
//
LONG ContinueExecution() {
	++counter;
	return EXCEPTION_CONTINUE_EXECUTION;
}

LONG ExecuteHandler() {
	++counter;
	return EXCEPTION_EXECUTE_HANDLER;
}

LONG ContinueSearch() {
	++counter;
	return EXCEPTION_CONTINUE_SEARCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__ldld.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



ldouble _cdecl CFncLDLD(ldouble PSld)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSld = (ldouble)counter;
    }
    return PSld;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__ff.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



float	_cdecl CFncFF(float PSf)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSf = (float)counter;
    }
    return PSf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__ll.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



long	_cdecl CFncLL(long PSl)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSl = (long)counter;
    }
    return PSl;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__narr.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



void	_cdecl CFncNearArray(void)
{
    short i;

    for( i = 0; i < NEARSIZE; i++ )
	GShortNearArray[i]=i;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__ucuc.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



uchar	_cdecl CFncUCUC(uchar PSuc)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSuc = (uchar)counter;
    }
    return PSuc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__rec.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



short	_cdecl CFncSSRecurse(short NTimes)
{	MIPS_DMY_PROLOG

    const char	   Cc = (char)NTimes;
    const uchar   Cuc = (uchar)NTimes;
    const short    Cs = (short)NTimes;
    const ushort  Cus = (ushort)NTimes;
    const long	   Cl = (long)NTimes;
    const ulong   Cul = (ulong)NTimes;
    const float    Cf = (float)NTimes;
    const double   Cd = (double)NTimes;
    const ldouble Cld = (ldouble)NTimes;

    char     c;
    uchar   uc;
    short    s;
    ushort  us;
    long     l;
    ulong   ul;
    float    f;
    double   d;
    ldouble ld;

    c = (char)NTimes;
    uc = (uchar)NTimes;
    s = (short)NTimes;
    us = (ushort)NTimes;
    l = (long)NTimes;
    ul = (ulong)NTimes;
    f = (float)NTimes;
    d = (double)NTimes;
    ld = (ldouble)NTimes;

    if( NTimes != 0 )
	NTimes = (short)CFncSSRecurse((short)(NTimes-1));
    return(NTimes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__ss.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



short	_cdecl CFncSS(short PSs)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSs = (short)counter;
    }
    return PSs;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__ulul.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



ulong	_cdecl CFncULUL(ulong PSul)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSul = (ulong)counter;
    }
    return PSul;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\stack01\cstack.h ===
#include <xtl.h>

#include <limits.h>
#include <float.h>
#include <stdarg.h>

//***************************************************************************
// prototypes
void __cdecl			main();

void                    VoidProcNoParam(void);
char                    CharProcNoParam(void);
unsigned char           UCharProcNoParam(void);
int                     IntProcNoParam(void);
unsigned int            UIntProcNoParam(void);
short                   ShortProcNoParam(void);
unsigned short          UShortProcNoParam(void);
long                    LongProcNoParam(void);
unsigned long           ULongProcNoParam(void);
float                   FloatProcNoParam(void);
double                  DoubleProcNoParam(void);
long double             LDoubleProcNoParam(void);

void                    VoidProc1Param(int i);
char                    CharProc1Param(char c);
unsigned char           UCharProc1Param(unsigned char uc);
int                     IntProc1Param(int i);
unsigned int            UIntProc1Param(unsigned int ui);
short                   ShortProc1Param(short s);
unsigned short          UShortProc1Param(unsigned short us);
long                    LongProc1Param(long l);
unsigned long           ULongProc1Param(unsigned long ul);
float                   FloatProc1Param(float f);
double                  DoubleProc1Param(double d);
long double             LDoubleProc1Param(long double ld);

short *            		PShortProc1Param(short * ps);
int * 					LPIntProc1Param(int * lpi);

int                     average(int first, ...);
unsigned long           factorial(int i);

long		            MultiParam(char c, int i, short s, long l, double d, long double ld, float f);

void 					check(int i, char *pc);

#ifdef __cplusplus
extern "C"
{
	int Cxx_Tests();
}
#else
	int Cxx_Tests();
#endif

// for mips
#if defined( _M_MRX000 ) || defined(_M_ALPHA)
#define MIPS_DMY_PROLOG int mip_dummy=0;
#else
#define MIPS_DMY_PROLOG 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__usus.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



ushort	_cdecl CFncUSUS(ushort PSus)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSus = (ushort)counter;
    }
    return PSus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\testbp.h ===
//**********************************************************************
//  Header for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#define HI 0
#define LO 1

#define FALSE 0
#define TRUE  1

#define NEARSIZE    10000
#define FARSIZE     32767
#define HUGESIZE    75000


typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;
typedef long double ldouble;


void	_cdecl CFncVV (void);
char	_cdecl CFncCC (char);
uchar	_cdecl CFncUCUC(uchar);
short	_cdecl CFncSS(short);
ushort	_cdecl CFncUSUS(ushort);
long	_cdecl CFncLL(long);
ulong	_cdecl CFncULUL(ulong);
float	_cdecl CFncFF(float);
double	_cdecl CFncDD(double);
ldouble _cdecl CFncLDLD(ldouble);
short	_cdecl CFncSSRecurse(short);
void	_cdecl CFncNearArray(void);
void	_cdecl Eval( ushort , char *);

//v-katsuf - for mips dmy prolog
#if defined(_M_MRX000) || defined(_M_ALPHA)
#define MIPS_DMY_PROLOG int mip_dummy=0;
#else
#define MIPS_DMY_PROLOG 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testgo01\testg.h ===
//**********************************************************************
//  Header for Testgo01 app : Testing of Go/Restart/StopDebugging
//***********************************************************************

 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

void        check();
int         check_int(int a, int b);
float       check_f(float a, float b);
int         check_func(int  a,int  l);
long        checkel_func(long a  ,long b,int  l);
float       checkef_func(float a , float b, int l);
double      checked_func(double a, double b, int l);
long double checkeld_func(long double a, long double b, int l);
char       *check_char(char *s);
char       *check_str(int a);
char       *check_lstr(int a, int b, char *s1, char *s2);

static int foo_Include(int number);

int foo_Include(int number)
{
	number*=2;
	if(number == 3)
	{
		return (-1);
	}
	return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\stack01\cstack.c ===
#include "cstack.h"

//****************************************************************************
// globals

char            test[]      = "CallStack";

char            scharmax    = SCHAR_MAX;
char            scharmin    = SCHAR_MIN;
unsigned char   ucharmax    = UCHAR_MAX;
unsigned char   ucharmin    = 0;
int             intmax      = INT_MAX;
int             intmin      = INT_MIN;
unsigned int    uintmax     = UINT_MAX;
unsigned int    uintmin     = 0;
short           shrtmax     = SHRT_MAX;
short           shrtmin     = SHRT_MIN;
unsigned short  ushrtmax    = USHRT_MAX;
unsigned short  ushrtmin    = 0;
long            longmax     = LONG_MAX;
long            longmin     = LONG_MIN;
unsigned long   ulongmax    = ULONG_MAX;
unsigned long   ulongmin    = 0;
double          dblmax      = DBL_MAX;
double          dblmin      = DBL_MIN;
long double     ldblmax     = LDBL_MAX;
long double     ldblmin     = LDBL_MIN;
float           fltmax      = FLT_MAX;
float           fltmin      = FLT_MIN;

char            *pscharmax  = &scharmax;
char            *pscharmin  = &scharmin;
unsigned char   *pucharmax  = &ucharmax;
unsigned char   *pucharmin  = &ucharmin;
int             *pintmax    = &intmax;
int             *pintmin    = &intmin;
unsigned int    *puintmax   = &uintmax;
unsigned int    *puintmin   = &uintmin;
short           *pshrtmax   = &shrtmax;
short           *pshrtmin   = &shrtmin;
unsigned short  *pushrtmax  = &ushrtmax;
unsigned short  *pushrtmin  = &ushrtmin;
long            *plongmax   = &longmax;
long            *plongmin   = &longmin;
unsigned long   *pulongmax  = &ulongmax;
unsigned long   *pulongmin  = &ulongmin;
double          *pdblmax    = &dblmax;
double          *pdblmin    = &dblmin;
long double     *pldblmax   = &ldblmax;
long double     *pldblmin   = &ldblmin;
float           *pfltmax    = &fltmax;
float           *pfltmin    = &fltmin;

//****************************************************************************
// Purpose:     main program
void __cdecl main()
{
    int     i_main = 4;

    // no parameters
    VoidProcNoParam();
    check(!(CharProcNoParam() == SCHAR_MIN), "CharProcNoParam()");
    check(!(UCharProcNoParam() == UCHAR_MAX), "UCharProcNoParam()");
    check(!(IntProcNoParam() == INT_MIN), "IntProcNoParam()");
    check(!(UIntProcNoParam() == UINT_MAX), "UIntProcNoParam()");
    check(!(ShortProcNoParam() == SHRT_MIN), "ShortProcNoParam()");
    check(!(UShortProcNoParam() == USHRT_MAX), "UShortProcNoParam()");
    check(!(LongProcNoParam() == LONG_MIN), "LongProcNoParam()");
    check(!(ULongProcNoParam() == ULONG_MAX), "ULongProcNoParam()");
    check(!(DoubleProcNoParam() == DBL_MIN), "DoubleProcNoParam()");
    check(!(LDoubleProcNoParam() == LDBL_MAX), "LDoubleProcNoParam()");
    check(!(FloatProcNoParam() == FLT_MIN), "FloatProcNoParam()");

    // at least one parameter
    VoidProc1Param(INT_MAX);
    check(!(CharProc1Param(SCHAR_MIN) == SCHAR_MIN), "CharProc1Param");
    check(!(UCharProc1Param(UCHAR_MAX) == UCHAR_MAX), "UCharProc1Param");
    check(!(IntProc1Param(INT_MIN) == INT_MIN), "IntProc1Param");
    check(!(UIntProc1Param(UINT_MAX) == UINT_MAX), "UIntProc1Param");
    check(!(ShortProc1Param(SHRT_MIN) == SHRT_MIN), "ShortProc1Param");
    check(!(UShortProc1Param(USHRT_MAX) == USHRT_MAX), "UShortProc1Param");
    check(!(LongProc1Param(LONG_MIN) == LONG_MIN), "LongProc1Param");
    check(!(ULongProc1Param(ULONG_MAX) == ULONG_MAX), "ULongProc1Param");
    check(!(DoubleProc1Param(DBL_MAX) == DBL_MAX), "DoubleProc1Param");
    check(!(LDoubleProc1Param(LDBL_MIN) == LDBL_MIN), "LDoubleProc1Param");
    check(!(FloatProc1Param(FLT_MAX) == FLT_MAX), "FloatProc1Param");

    // parameter passed on using global variables
    VoidProc1Param(intmax);
    check(!(CharProc1Param(scharmin) == SCHAR_MIN), "CharProc1Param");
    check(!(UCharProc1Param(ucharmax) == UCHAR_MAX), "UCharProc1Param");
    check(!(IntProc1Param(intmin) == INT_MIN), "IntProc1Param");
    check(!(UIntProc1Param(uintmax) == UINT_MAX), "UIntProc1Param");
    check(!(ShortProc1Param(shrtmin) == SHRT_MIN), "ShortProc1Param");
    check(!(UShortProc1Param(ushrtmax) == USHRT_MAX), "UShortProc1Param");
    check(!(LongProc1Param(longmin) == LONG_MIN), "LongProc1Param");
    check(!(ULongProc1Param(ulongmax) == ULONG_MAX), "ULongProc1Param");
    check(!(DoubleProc1Param(dblmax) == DBL_MAX), "DoubleProc1Param");
    check(!(LDoubleProc1Param(ldblmin) == LDBL_MIN), "LDoubleProc1Param");
    check(!(FloatProc1Param(fltmax) == FLT_MAX), "FloatProc1Param");

    // parameter passed on using pointers
    VoidProc1Param(*pintmax);
    check(!(CharProc1Param(*pscharmin) == SCHAR_MIN), "CharProc1Param*");
    check(!(UCharProc1Param(*pucharmax) == UCHAR_MAX), "UCharProc1Param*");
    check(!(IntProc1Param(*pintmin) == INT_MIN), "IntProc1Param*");
    check(!(UIntProc1Param(*puintmax) == UINT_MAX), "UIntProc1Param*");
    check(!(ShortProc1Param(*pshrtmin) == SHRT_MIN), "ShortProc1Param*");
    check(!(UShortProc1Param(*pushrtmax) == USHRT_MAX), "UShortProc1Param*");
    check(!(LongProc1Param(*plongmin) == LONG_MIN), "LongProc1Param*");
    check(!(ULongProc1Param(*pulongmax) == ULONG_MAX), "ULongProc1Param*");
    check(!(DoubleProc1Param(*pdblmax) == DBL_MAX), "DoubleProc1Param*");
    check(!(LDoubleProc1Param(*pldblmin) == LDBL_MIN), "LDoubleProc1Param*");
    check(!(FloatProc1Param(*pfltmax) == FLT_MAX), "FloatProc1Param*");

    // parameter passed on using near/far/ellipses
    check(!(PShortProc1Param(&shrtmin) == pshrtmin), "PShortProc1Param*");
    check(!(LPIntProc1Param((int *)&intmin) == (int *)pintmin), "LPIntProc1Param*");

    // variable parameters and recursive
    check(!(average(1,2,3,4,5,6,7,8,9, -1) == 5), "average");
    check(!(factorial(9) == (long)362880), "factorial");

    check(!(MultiParam(CHAR_MIN, INT_MAX, SHRT_MAX, LONG_MAX, DBL_MAX, LDBL_MAX, FLT_MAX) == LONG_MAX), "MultiParam");

    // C++ object parameters and template parameters
    check(!(Cxx_Tests() == 0), "C++ objects");

	return;
}

//****************************************************************************
// Purpose:     function returning void and has no parameter
void VoidProcNoParam(void)
{	MIPS_DMY_PROLOG
    return;
}

// Purpose:     function returning char and has no parameter
char CharProcNoParam(void)
{	MIPS_DMY_PROLOG
    return SCHAR_MIN;
}

// Purpose:     function returning unsigned char and has no parameter
unsigned char UCharProcNoParam(void)
{	MIPS_DMY_PROLOG
    return UCHAR_MAX;
}

// Purpose:     function returning int and has no parameter
int IntProcNoParam(void)
{	MIPS_DMY_PROLOG
    return INT_MIN;
}

// Purpose:     function returning unsigned int and has no parameter
unsigned int UIntProcNoParam(void)
{	MIPS_DMY_PROLOG
    return UINT_MAX;
}

// Purpose:     function returning short and has no parameter
short ShortProcNoParam(void)
{	MIPS_DMY_PROLOG
    return SHRT_MIN;
}

// Purpose:     function returning unsigned short and has no parameter
unsigned short UShortProcNoParam(void)
{	MIPS_DMY_PROLOG
    return USHRT_MAX;
}

// Purpose:     function returning long and has no parameter
long LongProcNoParam(void)
{	MIPS_DMY_PROLOG
    return LONG_MIN;
}

// Purpose:     function returning unsigned long and has no parameter
unsigned long ULongProcNoParam(void)
{	MIPS_DMY_PROLOG
    return ULONG_MAX;
}

// Purpose:     function returning float and has no parameter
float FloatProcNoParam(void)
{	MIPS_DMY_PROLOG
    return FLT_MIN;
}

// Purpose:     function returning Double and has no parameter
double DoubleProcNoParam(void)
{	MIPS_DMY_PROLOG
    return DBL_MIN;
}

// Purpose:     function returning long double and has no parameter
long double LDoubleProcNoParam(void)
{	MIPS_DMY_PROLOG
    return LDBL_MAX;
}

//****************************************************************************
// Purpose:     function returning void and has 1 parameter
void VoidProc1Param(int i)
{	MIPS_DMY_PROLOG
    return;
}

// Purpose:     function returning char and has 1 parameter
char CharProc1Param(char c)
{	MIPS_DMY_PROLOG
    return c;
}
// Purpose:     function returning unsigned char and has 1 parameter
unsigned char UCharProc1Param(unsigned char uc)
{	MIPS_DMY_PROLOG
    return uc;
}

// Purpose:     function returning int and has 1 parameter
int IntProc1Param(int i)
{	MIPS_DMY_PROLOG
    return i;
}

// Purpose:     function returning unsigned int and has 1 parameter
unsigned int UIntProc1Param(unsigned int ui)
{	MIPS_DMY_PROLOG
    return ui;
}

// Purpose:     function returning short and has 1 parameter
short ShortProc1Param(short s)
{	MIPS_DMY_PROLOG
    return s;
}

// Purpose:     function returning unsigned short and has 1 parameter
unsigned short UShortProc1Param(unsigned short us)
{	MIPS_DMY_PROLOG
    return us;
}

// Purpose:     function returning long and has 1 parameter
long LongProc1Param(long l)
{	MIPS_DMY_PROLOG
    return l;
}

// Purpose:     function returning unsigned long and has 1 parameter
unsigned long ULongProc1Param(unsigned long ul)
{	MIPS_DMY_PROLOG
    return ul;
}

// Purpose:     function returning float and has 1 parameter
float FloatProc1Param(float f)
{	MIPS_DMY_PROLOG
    return f;
}

// Purpose:     function returning Double and has 1 parameter
double DoubleProc1Param(double d)
{	MIPS_DMY_PROLOG
    return d;
}

// Purpose:     function returning long double and has 1 parameter
long double LDoubleProc1Param(long double ld)
{	MIPS_DMY_PROLOG
    return ld;
}

//****************************************************************************
// Purpose:     function returning address and has 1 parameter
//              as pointer
short * PShortProc1Param(short * ps)
{	MIPS_DMY_PROLOG
    return ps;
}

int * LPIntProc1Param(int * lpi)
{	MIPS_DMY_PROLOG
    return lpi;
}

//****************************************************************************
// Purpose:     function returning address and has ... parameter
int average(int first, ...)
{	MIPS_DMY_PROLOG
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != -1)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

//****************************************************************************
// Purpose:     recursive function
unsigned long factorial(int i)
{	MIPS_DMY_PROLOG
    if (i == 0)
        return 1;
    else
        return (i * factorial(i-1));
}

//****************************************************************************
// Purpose:     function returning long and has many parameters
long MultiParam(char c, int i, short s, long l, double d, long double ld, float f)
{	MIPS_DMY_PROLOG
	long double ldbl = (long double)c + (long double)i + (long double)s + (long double)l + (long double)d + (long double)ld + (long double)f;
	return l;
}

void check(int i, char *pc)
{	MIPS_DMY_PROLOG
	if( !i ) return;
	printf("%s FAILED", pc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__cc.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



char	_cdecl CFncCC (char PSc)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
lab1:		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
lab2:		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;
		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
lab3:		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSc = (char)counter;
    }
    return PSc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\tmplates\tmplates.cpp ===
#include <afxwin.h>
#include <map>

//make all data known data types
int global_int = 1;
float global_float = 1.0;


void globalfunc(void){}

template<typename Type>
void globaltemplatefunc(Type var) //ENC: edit template function declaration here: any case, rebuild
{ // first line of globaltemplatefunc
	int var1 = 1; //ENC: edit template function definition here: any case, rebuild
	int var2 = 3;
	int var3 = var1 + var2 + (int)var;
}


template<> void globaltemplatefunc<float>(float var)
{ // first line of float specialization of globaltemplatefunc
	float var1 = 1.0; //ENC: edit explicit template function specialization here: any case, rebuild
	float var2 = 2.0;
	float var3 = 2.0*var1 + 2.0*var2 + var;
}

template void globaltemplatefunc<double>(double); //ENC: edit explicit template function instantiation here: any case, rebuild

template<typename Type> class SomeReallyLongSymbolName; //ENC: edit template class declaration here

template<typename Type> class SomeReallyLongSymbolName
{
    public:
		SomeReallyLongSymbolName(Type var)
		{
			m_Type = var;
		}
		
		void func(Type var)
		{ // first line of template function 'func'
			m_Type = var;
			globalfunc();
			while(0); // in template function 'func'
		}
	//ENC: edit template class definition here, add some variable
		Type m_Type;
};

SomeReallyLongSymbolName<int> intObject(0);
SomeReallyLongSymbolName<char> charObject('a');

template<> class SomeReallyLongSymbolName<double>{}; //ENC: edit explicit class template specialization, add parameter?

typedef std::map<DWORD, SomeReallyLongSymbolName<DWORD> > STLTypeWithLongName;


void FuncWithTemplateClassParam(SomeReallyLongSymbolName<int> intObjectParam)
{ // first line of FuncWithTemplateClassParam
	int test=0;
}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
	SomeReallyLongSymbolName<float> localfloatObject(1.0); //ENC: edit template class instantiation (ex change to double)
	int var1 = 8;
	intObject.func(1);
	while(0); //1
	intObject.func(2);
	while(0); //2

	charObject.func('b');
	while(0); //b
	charObject.func('c');
	while(0); //c

	FuncWithTemplateClassParam(intObject);
	while(0); //intObject

	globaltemplatefunc(1);
	while(0); //::1
	globaltemplatefunc('a');
	while(0); //::a
	globaltemplatefunc(global_float);
	while(0);// ::global_float

	STLTypeWithLongName STLObjectWithLongName;
	if(var1==0)
	{
		var1++;
	}
	else 
		if(var1==4)
	{
		var1=0;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\stack01\cppstack.cpp ===
#include "cstack.h"
#include <xtl.h> //xbox #include <windows.h>

typedef void (*PFNINT)(void*, unsigned long);
typedef int (*PFNVAR)(void*, ...);

void afuncint(void*, DWORD)
{
}

static int afuncvar(void*, ...)
{
	return 0;
}

class AClass
{
public:
	PFNINT pfnint;
	PFNVAR pfnvar;
	static int m_static;
	virtual void __fastcall virt_method() {};
} the_Aclass;

int AClass::m_static = -1;
static AClass static_Aclass;

typedef AClass* PAClass;
typedef class ADerived: public AClass{
	void __fastcall virt_method() {
		int in_derived = 0;
	};
} CLASS_DERIVED;



CLASS_DERIVED the_derived;


static int Result=0;

static PFNVAR globalsecond1;
PFNVAR globalsecond2;

PAClass pclass = &the_Aclass;

//****************************************************************************
// Purpose:     function taking class & pointer to class
int paramclass(AClass the_class, AClass *the_pointer)
{	MIPS_DMY_PROLOG
	return 0;
}

//****************************************************************************
// Purpose:     function taking typedef class & pointer to class
int paramtypedefclass(CLASS_DERIVED the_class, PAClass the_pointer)
{	MIPS_DMY_PROLOG
	return 0;
}

//****************************************************************************
// Purpose:     function taking pointers to a functions as params
PFNINT poniterstofunc(PFNINT first, PFNVAR second)
{	MIPS_DMY_PROLOG
	static PFNINT localfirst=first;
	PFNVAR localsecond=second;
	int i=0;
	return first;
}

//****************************************************************************
// Purpose:     overloaded function taking int
int overloaded_function(int first)
{	MIPS_DMY_PROLOG
	static int i=1;
	static int j=first;
	return first;
}

//****************************************************************************
// Purpose:     overloaded function taking long
int overloaded_function(long first)
{	MIPS_DMY_PROLOG

	return first;
}



//****************************************************************************
// Purpose:     fpo function
double __fastcall fastcall_function(int first,long second, float third)
{	MIPS_DMY_PROLOG

	return first + second + third;
}


//****************************************************************************
// Purpose:     stdcall function
double __stdcall stdcall_function(int first,long second, float third)
{	MIPS_DMY_PROLOG

	return fastcall_function(first, second, third);
}


//****************************************************************************
// Purpose:     cdecl function
double __cdecl cdecl_function(int first,long second, float third)
{	MIPS_DMY_PROLOG

	return stdcall_function(first, second, third);
}
static int foo()
{
	return 10;
}

int Cxx_Tests()
{
	poniterstofunc(afuncint, afuncvar);
	poniterstofunc(afuncint, NULL);

	Result+=overloaded_function(1);
	Result+=overloaded_function(1L);
	static dooubleresult=cdecl_function(1, 2, 3.0);
	Result+=(int)dooubleresult;
	Result += 3;
	return Result==0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\testbp.c ===
//**********************************************************************
//  Main source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

const char     GCc = (char)1;
const uchar   GCuc = (uchar)1;
const short    GCs = (short)1;
const ushort  GCus = (ushort)1;
const long     GCl = (long)1;
const ulong   GCul = (ulong)1;
const float    GCf = (float)1;
const double   GCd = (double)1;
const ldouble GCld = (ldouble)1;

ushort GShortNearArray[NEARSIZE];
//ushort _near GShortNearArray[NEARSIZE];
//ushort _far GShortFarArray[FARSIZE];
//ushort _huge GShortHugeArray[HUGESIZE];

char	 Gc;
uchar	Guc;
short	 Gs;
ushort	Gus;
long	 Gl;
ulong	Gul;
float	 Gf;
double	 Gd;
ldouble Gld;
short PassTest;

struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst = &Gst;
union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun = &Gun;

int TestBP( void );


int TestBP()
{
#ifdef _M_ALPHA
    MIPS_DMY_PROLOG
#endif
    int counter;

    char     c;
    uchar   uc;
    short    s;
    ushort  us;
    long     l;
    ulong   ul;
    float    f;
    double   d;
    ldouble ld;

	 CFncVV ();
     c = CFncCC (c);
    uc = CFncUCUC(uc);
     s = CFncSS(s);
    us = CFncUSUS(us);
     l = CFncLL(l);
    ul = CFncULUL(ul);
     f = CFncFF(f);
     d = CFncDD(d);
    ld = CFncLDLD(ld);
     s = CFncSSRecurse(10);
	 CFncNearArray();

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
label:	c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
    }
	return (1);
}
#include <xtl.h> //xbox #include <windows.h>
void __cdecl main()
{
	int iBP = TestBP();
	while (1); /* xbox */ return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testgo01\testgo.c ===
/*********************************************/
/* testgo.c                                  */
/*********************************************/
/* CVM : g : Go command                      */
/*********************************************/
#include <stdio.h>
#include "testg.h"
#define ArrayLength 100
#define StructString65 "String65String65String65String65String65String65String65String65"
#define LocalString65  "__local_String65__local_String65__local_String65__local_String65"
#define Flag 1

int TestG(void);
int func();
int recur_func();
int foo(int);
void nest_func();
int Global;
typedef int My_typedef;

struct Struct 
{
   int IntN;
   char *String65;
} Struct;

union Union 
{
   int Int;
   long Long;
} Union;

enum Enum 
{
  one,
  two,
  three
} Enum;

void nest_func()
{
 	if (func()) 
   	foo (func());
};
int func() { 
			return 33;
		   };
int foo(int Parameter) {
    return Parameter;
 };

int recur_func() 
{
   static x=1;
   x++;
   if (x<9) recur_func();
   else return x;
};
#include <xtl.h> //xbox #include <windows.h>
void __cdecl main()
{
//	char c;
//	unsigned int ui;
	int iGo = TestG();
// 	c = getchar(&ui);
	while(1); /* xbox */ return;
}

int TestG()
{
 	int Local;
 	char Char;
 	int Int;
 	long Long;
 	double Double;
 	long double Ldouble;
 	float Real;
 	char *String;
 	void *Void;
 	My_typedef Mine;
 
	struct Struct Struct_local;
	union  Union Union_local;
	enum   Enum Enum_local;

 	struct Struct Array_struct[ArrayLength];
 	int  Array1d[3];
 	long Array2d[3][3];
 	char Array3d[3][3][3];

 	if (Flag) 
	{
  		for (Int=0; Int < ArrayLength; Int++)
   	{						                      // not executable code line
			Array_struct[Int].IntN = Int;
			Array_struct[Int].String65 = StructString65;
		};	  
 	};

 	for (Int=0; Int<3; Int++) 
	{
     	Array1d[Int]=Int;
     	Array2d[Int][Int]=Int;
     	Array3d[Int][Int][Int]=Int;
  	};

 	Local=17;
 	Array1d[2]=9;
 	Struct.IntN = 1;
 	Struct.String65 = StructString65;
 	Struct_local.IntN = 11;
 	Struct_local.String65 = LocalString65;
 	Int=2;Int=6;Int=9;
 	Real=1.303;
 	Double=1.303;
 	Ldouble=1.303;
 	String="this is a string";
 	Global=77;
 	Long=99;
 	Int=func();

 	if (Local > 0) 
	{
 		while (Local == 1)  
			Real = 9.9999;    // dead code
		if (Local > 1)
   	{							// not executable code line
	 		while (Local == 17)
			{                 // not executable code line
	 			Real = 8.88888;
				break;
			}
		}
 		else
 		 Real = 7.77;		// dead code
	}
 	else						
   {							// dead code
      Real = 6.1;	      // dead code
	}							// dead code

 	if (1 < Local) do { Double = 555.555; } while (Local == 0);

DA_FUNC:	                        // label
 	Int=foo(Local);
	Int = foo_Include(Int);
 	Int=recur_func();
 	Int=0;  Int=check_func(Int,90);
	Void = (void*)Int;
  	nest_func();
if(func() == 33)goto LabeL;
	Int = 999;
LabeL: 	return 1;
}


int check_func( int a, int l )
{
	char test[] = "TestName";
	
   if( !a )
   {
//      printf("%s: Passed , line: %d --- %d != 0\n",test, l, a );
   }
   else
   {
//      printf("%s: Failure, line: %d --- %d = 0\n",test, l, a );
   }
   return a;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\threads\threads.cpp ===
#include <xtl.h> //xbox #include <windows.h>


HANDLE hSecondaryThread;
DWORD dwSecondaryThreadID, dwMainThreadID;
int intGlobal = 0;
BOOL bInfiniteLoop = TRUE;


void FuncCalledBySecondaryThreadFunc(void)
{	// first line of FuncCalledBySecondaryThreadFunc().
}


unsigned long __stdcall SecondaryThreadFunc(void * pdata)

{	// first line of SecondaryThreadFunc().

	int intLocalSecondaryThreadFunc = 1;
	intGlobal = 1;
	while(0);							// line after intGlobal changed.
	
	FuncCalledBySecondaryThreadFunc();
	while(0);							// line after call to FuncCalledBySecondaryThreadFunc().

	while(bInfiniteLoop);				// loop inside SecondaryThreadFunc().
	return 1;
}


void CreateThreadFunc(void)
{
	hSecondaryThread = CreateThread(NULL, 0, SecondaryThreadFunc, 0, 0, &dwSecondaryThreadID);
	// sleeping will enure that the thread is created before this function returns.
	Sleep(500);	// line after call to CreateThread().
}	// last line of CreateThreadFunc().


void __cdecl main()
{
	dwMainThreadID = GetCurrentThreadId();
	int intLocalMain = 0;
	CreateThreadFunc();
	while(bInfiniteLoop);	// loop inside main().
	while (1); /* never exit main func */ return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\stress\src\stress01\Stress01.c ===
/*********************************************/
/* testgo.c                                  */
/*********************************************/
/* CVM : g : Go command                      */
/*********************************************/
#include <xtl.h>

void LoopLevel2(int level1)
{
	char buf[64];
	int local_count = 0;

	Sleep(1000);
	for (local_count = 0; local_count < 100; local_count++)
	{
		wsprintf(buf, "      LoopLevel2: %-5d - %-3d\n", level1, local_count+1);
		OutputDebugString(buf);
	}
	Sleep(10);
}

int global_count;
int LoopLevel1()
{
	char buf[64];
	global_count = 0; /* inside LoopLevel1 */

	for (global_count = 0; global_count < 10000; global_count++)
	{
		wsprintf(buf, "  LoopLevel1: %-5d\n", global_count+1);
		OutputDebugString(buf);
		LoopLevel2(global_count);
	}
	return 0;
}

void __cdecl main()
{
	OutputDebugString("Test code has started\n");
	LoopLevel1();
	OutputDebugString("Test code has ended\n");
	while(1);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\bin\core\src\testbp01\bp__vv.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;


void _cdecl CFncVV (void)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bp1cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BP1CASES.CPP
//
//	Created by :			Date :
//		YefimS			11/21/93
//
//	Description :
//		Implementation of the BP1Cases
//

#include <process.h>
#include "stdafx.h"
#include "bpcase.h"	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CbpIDETest::BreakAtLine(  )
{
 	LogTestHeader( "BreakAtLine" );
	UIBreakpoints bpd;

	CString strSource = "bp__cc.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource );

	CString strLine = "105";
	int nLine = 105;
	CString strLocation = (CString)"{," + strSource + ",}." + strLine;
	EXPECT( src.GoToLine(nLine) );
	DoKeys( KEY_TOGGLE_BREAKPOINT );
	bpd.Activate();
	EXPECT_TRUE_COMMENT( bpd.BreakpointIsSet(strLine, strSource), "F9 * Source Inactive * at line 105" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "us = (ushort)counter;"), "F9 * Source Inactive * Break at BP" );

	strLine = "109";
	nLine = 109;
	strLocation = (CString)"{," + strSource + ",}." + strLine;
	EXPECT( src.GoToLine(nLine) );
	DoKeys( KEY_TOGGLE_BREAKPOINT );
	bpd.Activate();
	EXPECT_TRUE_COMMENT( bpd.BreakpointIsSet(strLine, strSource), "F9 * Source Active * at line 109" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "d  = (double)counter;"), "F9 * Source Active * Break at BP" );
	
	bps.ClearAllBreakpoints();
	strSource = "bp__ll.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource );
	strLine = "108";
	nLine = 108;
	strLocation = (CString)"{," + strSource + ",}@" + strLine;
	bps.SetBreakpoint(strLocation);
	bpd.Activate();
	EXPECT_TRUE_COMMENT( bpd.BreakpointIsSet(strLine, strSource), "BPDlg * Source Inactive * at line 108" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "ul = (ulong)counter;"), "BPDlg * Source Inactive * Break at BP" );
	
	strLine = "125";
	nLine = 125;
	strLocation = (CString)"{," + strSource + ",}@" + strLine;
	bps.SetBreakpoint(strLocation);
	bpd.Activate();
	EXPECT_TRUE_COMMENT( bpd.BreakpointIsSet(strLine, strSource), "BPDlg * Source Active * at line 125" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "pun->ul = (ulong)counter;"), "BPDlg * Source Active * Break at BP" );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CbpIDETest::Disable_Enable()
{
 	LogTestHeader( "Disable_Enable" );
	bps.ClearAllBreakpoints();
	CString strSource = "bp__ll.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource );

	CString strLine = "106";
	CString strLocation = (CString)"{," + strSource + ",}@" + strLine;
	bp *pbp = bps.SetBreakpoint(strLocation);

	UIBreakpoints bpd;
	bpd.Activate();
	EXPECT_TRUE( bpd.BreakpointIsSet(strLine, strSource) );

	bpd.Disable();
	EXPECT_TRUE_COMMENT ( !bpd.BreakpointIsEnabled(strLine, strSource), "Disable BP : at line 106 in bp__ll.c" );

	bpd.Enable();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsEnabled(strLine, strSource), "Enable BP : at line 106 in bp__ll.c" );

	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "us = (ushort)counter;"), "Break at enabled BP" );

	bpd.Activate();
	bpd.Disable();
	EXPECT_TRUE_COMMENT ( !bpd.BreakpointIsEnabled(strLine, strSource), "Disable BP again: 106" );
	EXPECT( bpd.Close() == NULL );

	bps.ClearAllBreakpoints();
	strLine = "108";
	strLocation = (CString)"{," + strSource + ",}@" + strLine;
	pbp = bps.SetBreakpoint(strLocation);

	bpd.Activate();
	bpd.Disable();
	EXPECT_TRUE_COMMENT ( !bpd.BreakpointIsEnabled(strLine, strSource), "Disable BP : at line 108 in bp__ll.c" );

	EXPECT( bpd.Close() == NULL );
	//xbox EXPECT_TRUE_COMMENT ( dbg.Go(NULL,NULL,NULL,WAIT_FOR_TERMINATION) , "The Project testbp01 was run" );
	dbg.StopDebugging();

	bpd.Activate();
	bpd.Enable();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsEnabled(strLine, strSource), "Enable BP : at line 108 in bp__ll.c" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "ul = (ulong)counter;"), "Break at enabled BP: 108" );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CbpIDETest::BreakOnExpressionStaticVars()
{
 	LogTestHeader( "BreakOnExpressionStaticVars" );
	bps.ClearAllBreakpoints();
	dbg.Restart();

	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x==7", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.Go(NULL,NULL,NULL,0);
	if( WaitMsgBoxText("Break when '{recur_func}x==7'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x==7'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when Go is performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x==7'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==7",1) );

	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x", COBP_TYPE_IF_EXP_CHANGED) != NULL );
	dbg.Go(NULL,NULL,NULL,0);

	if( WaitMsgBoxText("Break when '{recur_func}x'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when Go is performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprChanged" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( cxx.ExpressionValueIs("x==8",1) );

	dbg.Go(NULL,NULL,NULL,0);
	if( WaitMsgBoxText("Break when '{recur_func}x'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when Go is performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprChanged" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==9",1) );

	//xbox EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	EXPECT_TRUE( dbg.Restart() );
	
	return (TRUE);
}

BOOL CbpIDETest::BreakOnCompoundExpression()
{
 	LogTestHeader( "BreakOnCompoundExpression" );
	bps.ClearAllBreakpoints();
 	dbg.Restart();

	EXPECT_TRUE( bps.SetBreakOnExpr("{TestG}(Global*Local+Int/3)==1", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.Go(NULL,NULL,NULL,0);
	WaitStepInstructions("Waiting for Break dialog");

	if( WaitMsgBoxText("Break when '{TestG}(Global*Local+Int/3)==1'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{TestG}(Global*Local+Int/3)==1'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when Go is performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{TestG}(Global*Local+Int/3)==1'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "for (Int=0; Int < ArrayLength; Int++)" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("(Global*Local+Int/3)==1",1) );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CbpIDETest::BreakAtVirtualFunc()
{
 	LogTestHeader( "BreakAtVirtualFunc" );
	bps.ClearAllBreakpoints();

	bps.SetBreakpoint("fooclass::vf1");
	bps.SetBreakpoint("fooclass::vf2");
	bps.SetBreakpoint("base::vf2");
	bps.SetBreakpoint("base::vf3");

	EXPECT_TRUE( dbg.Go(NULL, "void vf1() { int i = 7; };", "fooclass::vf1") );
	EXPECT_TRUE( dbg.Go(NULL, "virtual int  vf2() { return 10; };", "base::vf2") );
	EXPECT_TRUE( dbg.Go(NULL, "int  vf2(int j) { return j; };", "fooclass::vf2") );
	EXPECT_TRUE( dbg.Go(NULL, "virtual int  vf3(int ind) { return ind*2; };", "base::vf3") );

	dbg.StopDebugging();
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bp2cases.cpp ===
/*
** BREAK.CPP
**
**	Created by :			Date :
**		waltcr				8/14/94
**
**	Description :
**		breakpoint tests
*/


#include "stdafx.h"
#include "bpcase.h"	
#include "bpcase2.h"	

#if defined(_MIPS_) || defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

int UI2COBP( int x );


///////////////////////////////////////////////////////////////////////////////
//	Test Cases

/*
** Some tests lumped together.  Some involve different level of debug
** information or without debug information.  Also a test or two
** involving step/stepout and breakpoints.
** 
*/

BOOL CbpIDETest::BreakStepTrace(   )
{ 	
 	LogTestHeader( "BreakStepTrace" );

	bp *bp;
	BOOL fOkay = TRUE;
	
	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	bp=bps.SetBreakpoint("WndProc");
	dbg.Go();  								// execute to function WndProc 
	EXPECT_TRUE ( fOkay &= dbg.AtSymbol("WndProc") );	
	dbg.StepOver(); 						// Step past prolog
	bps.ClearAllBreakpoints();
	bp = bps.SetBreakpoint("TagCallChainMain"); 	// set breakpoint on label
	dbg.Go();  								// execute to bp at label
	EXPECT_TRUE ( fOkay &= dbg.AtSymbol("{WndProc}TagCallChainMain") );
	EXPECT_TRUE ( fOkay &= dbg.StepInto(1,"ChainMain") );
	EXPECT_TRUE ( fOkay &= bps.SetBreakpoint("chain_4") != NULL );
	EXPECT_TRUE ( fOkay &= bps.SetBreakpoint("chain_5") != NULL );
	dbg.Go();
	EXPECT_TRUE( fOkay &= dbg.AtSymbol("chain_4"));
	
	// attempt to step out but fire on breakpoint in nested function call
	// proper location is chain_5
	EXPECT_TRUE_COMMENT ( fOkay &= dbg.StepOut(1, NULL, NULL, "chain_5"), "Break in nested function" );

	dbg.StepInto();
	EXPECT_TRUE ( fOkay &= dbg.StepOut(1, NULL, NULL, "chain_4") );
	EXPECT_TRUE ( fOkay &= dbg.StepOut(1, NULL, NULL, "chain_3") );

	dbg.StopDebugging();
	return fOkay;
}									


/* 
** Execute a number of breakpoint tests defined in a table.
**
*/

BOOL CbpIDETest::BPTable(   )
{	
 	LogTestHeader( "BPTable" );

	BOOL fSuccess = TRUE;

	enum UIType	{ 
				UIBP_TYPE_LOC=1,
				UIBP_TYPE_LOC_IF_EXP_TRUE,
				UIBP_TYPE_LOC_IF_EXP_CHANGED,
				UIBP_TYPE_IF_EXP_TRUE,
				UIBP_TYPE_IF_EXP_CHANGED,
				UIBP_TYPE_WNDPROC_IF_MSG_RECVD 
				}; 

	struct CBreak
	{	
		BOOL fStopDbg;
		BOOL fRestart;
		char *szSymbol;
		char *szExpr;
		int Length;
		UIType Type;
		char *szVerifyWithOtherSymbol;
		char *szVerifyWithOtherExpr;
		BOOL fClear;
		//hmm, consider adding a verify current frame
		//hmmh, consider adding an int to execute n times.
		//hmmm, consider adding a pointer to func arg to call before setting
		//hmmm, consider adding a pointer to func to call after hitting bp.
		//hmmm, consider adding a description field
	} rgBreak[] = { // stop, restart, symbol, expr, length, type, verify_symbol, verify_expr, clear
/*pass*/			TRUE, FALSE, "WinMain", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/*pass*/			TRUE, FALSE, "WndProc", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/*pass*/			FALSE, FALSE, "chain_1", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/*pass*/			FALSE, FALSE, _CHAIN_2, NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/*pass*/			FALSE, FALSE, _CHAIN_3, NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/*pass*/			FALSE, FALSE, "chain_4", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/*pass*/			FALSE, FALSE, "chain_5", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/*pass*/		 	TRUE, FALSE, "{BPWithLengthTest}BREAK", "gi[0]", 3, UIBP_TYPE_LOC_IF_EXP_CHANGED, NULL, "*(gi+2)==99", FALSE,
/*pass*/		 	FALSE, FALSE, "{foo2}START", "{foo2}paramA>2", 0, UIBP_TYPE_LOC_IF_EXP_TRUE, "{foo2}START", NULL, FALSE,
					// add additional breakpoints above this line
					FALSE, FALSE, NULL, NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE
					};


	CBreak *rgbp = rgBreak;
	bp *ThisBP;
	int iErrCount = 0;

	bps.ClearAllBreakpoints();

	while ((rgbp->szSymbol != NULL) || (rgbp->szExpr != NULL))
	{

		if (rgbp->fStopDbg)
			dbg.StopDebugging();

		switch (rgbp->Type)
		{	
				case UIBP_TYPE_LOC:
					ThisBP = bps.SetBreakpoint(rgbp->szSymbol);
					break;
				case UIBP_TYPE_LOC_IF_EXP_TRUE:
				case UIBP_TYPE_LOC_IF_EXP_CHANGED:
					if (rgbp->Length != 0)
						ThisBP = bps.SetBreakOnExpr(rgbp->szSymbol,	rgbp->szExpr, UI2COBP(rgbp->Type), rgbp->Length);
					else
						ThisBP = bps.SetBreakOnExpr(rgbp->szSymbol,	rgbp->szExpr, UI2COBP(rgbp->Type));
					break;
				case UIBP_TYPE_IF_EXP_TRUE:
				case UIBP_TYPE_IF_EXP_CHANGED:
					if (rgbp->Length != 0)
						ThisBP = bps.SetBreakOnExpr(rgbp->szExpr, UI2COBP(rgbp->Type), rgbp->Length);
					else
						ThisBP = bps.SetBreakOnExpr(rgbp->szExpr, UI2COBP(rgbp->Type)-4);
					break;
				case UIBP_TYPE_WNDPROC_IF_MSG_RECVD:
					ThisBP = bps.SetBreakOnMsg(
						rgbp->szSymbol, 
						rgbp->szExpr);
					break;
		}

		fSuccess = (ThisBP != NULL);
		if (fSuccess)
		{

			if (rgbp->fRestart)
				dbg.Restart();
	
			dbg.Go();

			// verification 
			// REVIEW: TODO: write better pass/fail messsages!


			fSuccess &= (dbg.GetDebugState() != NotDebugging);
			if (fSuccess && (rgbp->szVerifyWithOtherSymbol != NULL))
			{
				fSuccess &= dbg.AtSymbol(rgbp->szVerifyWithOtherSymbol);
				if (!fSuccess)
					m_pLog->RecordFailure("Not at location \'%s\'", rgbp->szVerifyWithOtherSymbol);
			}
			else if (fSuccess && (rgbp->szSymbol != NULL))
			{
				fSuccess &= dbg.AtSymbol(rgbp->szSymbol);
				if (!fSuccess)
					m_pLog->RecordFailure("Not at bp location \'%s\'", rgbp->szSymbol);
			}
			if ( fSuccess && (rgbp->Type != UIBP_TYPE_WNDPROC_IF_MSG_RECVD) && (rgbp->szVerifyWithOtherExpr != NULL) )
			{
				fSuccess &= cxx.ExpressionValueIs(rgbp->szVerifyWithOtherExpr,1);
			}
			else if ( fSuccess && (rgbp->Type != UIBP_TYPE_WNDPROC_IF_MSG_RECVD) && (rgbp->szExpr != NULL)  )
			{
				fSuccess &= cxx.ExpressionValueIs(rgbp->szExpr, 1);
			}

			// cleanup
			if (rgbp->fClear)
				bps.RemoveBreakpoint(ThisBP);
			else
				bps.DisableBreakpoint(ThisBP);
		}

		WriteLog( fSuccess ? PASSED : FAILED, "breakpoint: loc='%s', exp='%s' ... ", rgbp->szSymbol, rgbp->szExpr);
		if (!fSuccess)
			iErrCount++;

		rgbp++;
	}
	
	return (iErrCount==0);
}


BOOL CbpIDETest::MessageBP(   )
{
 	LogTestHeader( "MessageBP" );

	BOOL fSuccess = TRUE;
	int count;

	/* 
	** attempt Breakpoint when message received.
	*/

	bps.ClearAllBreakpoints();

	EXPECT_TRUE( fSuccess &= (bps.SetBreakOnMsg("WndProc","WM_CREATE") != NULL) );

	dbg.Restart();
	dbg.Go();
	EXPECT_TRUE(fSuccess &= dbg.AtSymbol("WndProc"));

	// try to make sure we broke on the correct message
	count=0;
	int countNumber = 25;
	do 
	{
		count++;
		dbg.StepOver();
	} while( (count < countNumber) && (!dbg.AtSymbol("TagCreateCase")));

	EXPECT_TRUE_COMMENT ( (fSuccess &= dbg.AtSymbol("TagCreateCase")),  "Break on WM_CREATE message")

	return fSuccess;
}

BOOL CbpIDETest::LocationBPWithExp(   )
{	
 	LogTestHeader( "LocationBPWithExp" );

	BOOL fSuccess = TRUE;

	bps.ClearAllBreakpoints();
	dbg.Restart();
	if (bps.SetBreakOnExpr(
		"{foo}END",
		"Global==3",
		COBP_TYPE_IF_EXP_TRUE) == FALSE)
	{
		fSuccess = FALSE;
		m_pLog->RecordFailure("Unable to set location breakpoint w/expression");
	}
	else if (dbg.Go("END",NULL, "foo") == FALSE)
	{
		fSuccess = FALSE;
		m_pLog->RecordFailure("Not at expected location");
	}

	return fSuccess;
}

int UI2COBP(int x)
{
	switch(x)
	{
		case UIBP_TYPE_LOC_IF_EXP_TRUE:
		case UIBP_TYPE_LOC_IF_EXP_CHANGED:
			return x-2;
			
		case UIBP_TYPE_IF_EXP_TRUE:
		case UIBP_TYPE_IF_EXP_CHANGED:
			return x-4;
	}
	return 0;
}


/*
** Break at DllMain() which is executed early i.e. at DLL_PROCESS_ATTACH
**
*/

BOOL Cbp2IDETest::BreakDLLInit(   )
{
 	LogTestHeader( "BreakDLLInit" );

	BOOL bOkay = TRUE;

	dbg.StopDebugging();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( bOkay &= (bps.SetBreakpoint("{,,dec2.dll}DllEntryPoint") != NULL) );
	if (bOkay)
	{
		EXPECT_TRUE ( bOkay &= ( dbg.Go() && dbg.VerifyAtSymbol("{,,dec2.dll}DllEntryPoint") ) );
		bps.ClearAllBreakpoints();
	}

#if 0
	// at restart would be semi-interesting too
	FALSE, TRUE, "{,,dec2.dll}DllEntryPoint", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,  // hit bp during restart
	TRUE, FALSE, "{,,incdll.dll}DllMain", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
	// how about a virtual dll?
#endif 

	return bOkay;	// WriteLog( bOkay, GetTestDesc() );
}


BOOL Cbp2IDETest::LoadDLLBreak(   )
{
 	LogTestHeader( "LoadDLLBreak" );
	BOOL bOkay = TRUE;
//	bp *ThisBP;

	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	dbg.StepInto(4);

	EXPECT_TRUE ( bOkay &= (prj.SetAdditionalDLLs("powdll.dll") != ERROR_SUCCESS) );
	if( bOkay )
		dbg.StepInto(4);
/*	if (prj.SetAdditionalDLLs("powdll.dll") != ERROR_SUCCESS)
	{
		m_pLog->RecordFailure("unable to set additional dlls");
		bOkay = FALSE;
	}
	else
	{
	// REVIEW (michma): cannot currently load dll symbols while debugging (menu limitation).
	// however, since prj.SetAdditionalDLLs isn't working yet either, we need
	// to start debugging to load dll symbols to get this test to finish.
	 dbg.StepInto(4);
	}
*/
	EXPECT_TRUE ( bOkay &= (prj.SetAdditionalDLLs("powdll.dll") != ERROR_SUCCESS) );
	if( bOkay )
	{
		EXPECT_TRUE ( bOkay &= (bps.SetBreakpoint("dPow") != NULL) );
		if( bOkay )
		{
			EXPECT_TRUE ( bOkay &= (dbg.Go() && dbg.VerifyAtSymbol("dPow")) );
			bps.ClearAllBreakpoints();
		}
	}
/*	if (prj.SetAdditionalDLLs("powdll.dll") != ERROR_SUCCESS)
	{
		m_pLog->RecordFailure("unable to set additional dlls");
		bOkay = FALSE;
	}
	else
	{
		ThisBP = bps.SetBreakpoint("dPow");
		bOkay &= (ThisBP != NULL);
		if (ThisBP == NULL)
		{
			m_pLog->RecordFailure("unable to set breakpoint after loading symbols");
		}
		else
		{
			dbg.Go();
			if (dbg.VerifyAtSymbol("dPow") == FALSE)
			{
				bOkay &= FALSE;
				m_pLog->RecordFailure("Not at symbol \'%s\'", "dPow" );
			}
			bps.RemoveBreakpoint(ThisBP);
		}
	}
*/
	return bOkay;
}


BOOL Cbp2IDETest::BPTableDLL(   )
{
 	LogTestHeader( "BPTableDLL" );
	BOOL fSuccess = TRUE;

	enum UIType	{ 
				UIBP_TYPE_LOC=1,
				UIBP_TYPE_LOC_IF_EXP_TRUE,
				UIBP_TYPE_LOC_IF_EXP_CHANGED,
				UIBP_TYPE_IF_EXP_TRUE,
				UIBP_TYPE_IF_EXP_CHANGED,
				UIBP_TYPE_WNDPROC_IF_MSG_RECVD 
				}; 

	struct CBreak
	{	
		BOOL fStopDbg;
		BOOL fRestart;
		char *szSymbol;
		char *szExpr;
		int Length;
		UIType Type;
		char *szVerifyWithOtherSymbol;
		char *szVerifyWithOtherExpr;
		BOOL fClear;
		//hmm, consider adding a verify current frame!
		//hmmh, consider adding an int to execute n times.
		//hmmm, consider adding a pointer to func arg to call before setting
		//hmmm, consider adding a pointer to func to call after hitting bp.
		//hmmm, consider adding a description field
	} rgBreak[] = 	{ 
					// stop, restart, symbol, expr, length, type, verify_symbol, verify-expr, clear
/* pass */			TRUE, FALSE, "WinMain", NULL, 0, UIBP_TYPE_LOC, NULL, NULL,  FALSE, 
/* pass */			FALSE, TRUE, "MainWndProc", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/* pass */			FALSE, FALSE, "MainWndProc", "WM_CREATE", 0, UIBP_TYPE_WNDPROC_IF_MSG_RECVD,  NULL, NULL, FALSE,
/* pass */			TRUE, FALSE, "Dec", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE, 
/* pass */			FALSE, FALSE, "Inc", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
//					FALSE, TRUE, NULL, "{,,dllappx.exe}wValue", 0, UIBP_TYPE_IF_EXP_CHANGED, NULL, NULL, FALSE,  // TODO: need to be able to check between expressions
/* pass */			TRUE, TRUE, "InitApplication", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE, 
#if !defined(_ALPHA_) && !defined(_MIPS_)
/* pass bug */	//or#14945 is postponed:		FALSE, FALSE, NULL, "gi[0]", 3, UIBP_TYPE_IF_EXP_CHANGED, "{BPWithLengthTest}BREAK", "*(gi+2)==99", FALSE,
#endif
/* pass */			TRUE, TRUE, "InitInstance", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/* pass */			FALSE, TRUE, "{MainWndProc,,dllappx.exe}TagEndPaint", "{,,dllappx.exe}hGlobalMem!=0", 0, UIBP_TYPE_LOC_IF_EXP_TRUE, NULL, NULL, FALSE,
/* part a */		TRUE, FALSE, "{Dec,dec2.c,dec2.dll}TagAfterGetProcAddr", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/* part b */		FALSE, FALSE, "dPow", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
#if !defined(_MIPS_) && !defined(_ALPHA_)
/* pass a,b,c*/	//or#18749:
		// TODO(michma - 1/30/98) - this bp takes longer than 5 minutes to hit, but it hasn't before.
		//TRUE, FALSE, NULL, "{Dec,,dec2.dll}dValue==1000", 0, UIBP_TYPE_IF_EXP_TRUE, "TagAfterPow", "dValue==1000", FALSE,
#endif
/* pass */			TRUE, FALSE, "{,incdll.c,incdll.dll}DllMain", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
//					TRUE, FALSE, NULL, "{DllEntryPoint,,dec2.dll}ulRbc==0", 0, UIBP_TYPE_IF_EXP_TRUE, NULL, "ulRbc==0", FALSE,
					// add additional breakpoints above this line
					FALSE, FALSE, NULL, NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE
					};


	CBreak *rgbp = rgBreak;
	bp *ThisBP;
	int iErrCount = 0;


	bps.ClearAllBreakpoints();

	/* 
	** for portability the following bp tests had to be isolated.
	** attempt Breakpoint when expression true.
	** attempt Breakpoint when expression changed.
	** attempt Breakpoint on global expression.
	** attempt Breakpoint on local expression.
	*/

	while ((rgbp->szSymbol != NULL) || (rgbp->szExpr != NULL))
	{

		if (rgbp->fStopDbg)
			dbg.StopDebugging();

		switch (rgbp->Type)
		{	
				case UIBP_TYPE_LOC:
					ThisBP = bps.SetBreakpoint(rgbp->szSymbol);
					break;
				case UIBP_TYPE_LOC_IF_EXP_TRUE:
				case UIBP_TYPE_LOC_IF_EXP_CHANGED:
					if (rgbp->Length != 0)
						ThisBP = bps.SetBreakOnExpr(rgbp->szSymbol,	rgbp->szExpr, UI2COBP(rgbp->Type), rgbp->Length);
					else
						ThisBP = bps.SetBreakOnExpr(rgbp->szSymbol,	rgbp->szExpr, UI2COBP(rgbp->Type));
					break;
				case UIBP_TYPE_IF_EXP_TRUE:
				case UIBP_TYPE_IF_EXP_CHANGED:
					if (rgbp->Length != 0)
						ThisBP = bps.SetBreakOnExpr(rgbp->szExpr, UI2COBP(rgbp->Type), rgbp->Length);
					else
						ThisBP = bps.SetBreakOnExpr(rgbp->szExpr, UI2COBP(rgbp->Type));
					break;
				case UIBP_TYPE_WNDPROC_IF_MSG_RECVD:
					ThisBP = bps.SetBreakOnMsg(
						rgbp->szSymbol, 
						rgbp->szExpr);
					break;
		}

		
		fSuccess = (ThisBP != NULL);
		if (fSuccess)
		{
			if (rgbp->fRestart)
				dbg.Restart();
	
			dbg.Go();

			// verification 
			fSuccess &= (dbg.GetDebugState() != NotDebugging);
			if (fSuccess && (rgbp->szVerifyWithOtherSymbol != NULL))
			{
				fSuccess &= dbg.AtSymbol(rgbp->szVerifyWithOtherSymbol);
				if (!fSuccess)
					m_pLog->RecordFailure("Not at symbol \'%s\'", rgbp->szVerifyWithOtherSymbol);
			}
			else if (fSuccess && (rgbp->szSymbol != NULL))
			{
				fSuccess &= dbg.AtSymbol(rgbp->szSymbol);
				if (!fSuccess)
					m_pLog->RecordFailure("Not at bp symbol \'%s\'", rgbp->szSymbol);
			}
			if ( fSuccess && (rgbp->Type != UIBP_TYPE_WNDPROC_IF_MSG_RECVD) && (rgbp->szVerifyWithOtherExpr != NULL) )
			{
				fSuccess &= cxx.ExpressionValueIs(rgbp->szVerifyWithOtherExpr,1);
			}
			else if ( fSuccess && (rgbp->Type != UIBP_TYPE_WNDPROC_IF_MSG_RECVD) && (rgbp->szExpr != NULL) )
			{
				fSuccess &= cxx.ExpressionValueIs(rgbp->szExpr, 1);
			}

			// cleanup
			if (rgbp->fClear)
				bps.RemoveBreakpoint(ThisBP);
			else
				bps.DisableBreakpoint(ThisBP);
		}
		WriteLog( fSuccess ? PASSED : FAILED, "breakpoint: loc='%s', exp='%s' ... ", rgbp->szSymbol, rgbp->szExpr);
		if (!fSuccess)
			iErrCount++;

		rgbp++;
	}
	
	
	return (iErrCount==0);	// WriteLog( iErrCount==0, GetTestDesc() );
}


// TODO?

/* 
** attempt to step over function but which fires on a message bp.
*/


/* 
** test Breakpoint at line location.
*/


/* 
** test Breakpoint at func location in primary module.
*/


/* 
** attempt Breakpoint at location when expression changed.
*/


/* 
** test Breakpoint on expression involving static.
*/


/* 
** test Breakpoint on expression involving both local and global.
*/


/* 
** test Breakpoint when expression true with length.
*/


/* 
** attempt Breakpoint when class of message received.
*/


#if 0
/*
** while executing child, set breakpoint which will fire.
*/
	dbg.Go(NOWAIT);
	bps.SetBreakpoint(some location );
#endif


#if 0


/*
** two step_out's, first hitting bp, second should return
*/
	bps.ClearAllBreakpoints();
	dbg.Restart();
	bps.SetBreakOnExpr("{MyPostMessage,,}TagPost","count>1",COBP_TYPE_IF_EXP_TRUE);
	dbg.Go();
	EXPECT_TRUE( dbg.AtSymbol("TagPost"));
#endif

	
/* 
** attempt Breakpoint at func location in secondary module.
*/


/* 
** attempt to step over function but which fires on a message bp.
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bpcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "bpcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(CbpIDETest, CDbgTestBase, "Breakpoints base", -1, CbpSubSuite)
												 
void CbpIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CbpIDETest::Run()
{
	XSAFETY;
  
	if (SetProject("testbp01\\testbp01", PROJECT_XBE) )
	{	  
		BreakAtLine();
		XSAFETY;
		Disable_Enable();
		XSAFETY;
	}

#pragma message("port dbg and dbga")
	/*xbox TODO: port dbg
	// breakpoints against example x
	// TODO: use coproject to see if it is already open.
	if ( SetProject("dbg\\dbg") )
	{
		XSAFETY;
		StartDebugging();

		EXPECT_TRUE(BPTable());
		XSAFETY;
		EXPECT_TRUE(LocationBPWithExp());
		XSAFETY;
		if(GetUserTargetPlatforms() != PLATFORM_MAC_68K && 
			GetUserTargetPlatforms() != PLATFORM_MAC_PPC)
		{
			EXPECT_TRUE(MessageBP());
			XSAFETY;
		}
		EXPECT_TRUE(BreakStepTrace());
		XSAFETY;
	}
	//	StopDbgCloseProject();
	//	Sleep(1000);
	*/
 	
	if( SetProject("testgo01\\testgo01", PROJECT_XBE) )
	{	  
		BreakOnExpressionStaticVars();
		XSAFETY;
		BreakOnCompoundExpression();
		XSAFETY;
	}

	/*xbox TODO: port dbga
	if( SetProject("dbga\\dbga") )
	{	  
		XSAFETY;
		BreakAtVirtualFunc();
		XSAFETY;
	}
	*/
		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bpsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	bpsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CbpSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CbpSubSuite class

class CbpSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CbpSubSuite)
//	CbpSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bpcase2.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "bpcase2.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cbp2IDETest, CDbgTestBase, "Breakpoints DLLs", -1, CbpSubSuite)
												 
void Cbp2IDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void Cbp2IDETest::Run()
{
	XSAFETY;

	if (SetProject("dllapp\\incdll", PROJECT_DLL, fBuildOnly) && SetProject("dllapp\\powdll", PROJECT_DLL, fBuildOnly)
		&& SetProject("dllapp\\dec2", PROJECT_DLL, fBuildOnly) && SetProject("dllapp\\dllappx"))
	{	
		XSAFETY;
		// when makefile is wrapped, wrapper name is dllappx1.mak and exe for debug session 
		// becomes dllappx1.exe, so we must	change it back since we actually build dllappx.exe.
		prj.SetExeForDebugSession("dllappx.exe");

		// dllappx builds 4 files: incdll.dll, dec2.dll, powdll.dll and dllappx.exe.
		// dllappx.exe is copied to remote by SetProject, but we need to do dlls.
		COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();
		if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		{
			prj.UpdateRemoteFile("src\\dllapp\\incdll.dll");
			prj.UpdateRemoteFile("src\\dllapp\\dec2.dll");
			prj.UpdateRemoteFile("src\\dllapp\\powdll.dll");
		}

		StartDebugging();

		EXPECT_TRUE(BreakDLLInit());
		XSAFETY;
		EXPECT_TRUE(BPTableDLL());	   //bug#14945	postponed: one test is disabled
		XSAFETY;
		// TODO: WinslowF - Load additianal dlls does not work at this time. Need to rewrite the func.
		//	EXPECT_TRUE(LoadDLLBreak());
		//	XSAFETY;
		
		StopDbgCloseProject();
	}

	else
		m_pLog->RecordFailure("Could not initiate incdll, powdll, dec2, or dllappx projects.");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bpcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CbpIDETest Class
//

#ifndef __bpcase_H__
#define __bpcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "bpsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CbpIDETest class

class CbpIDETest : public CDbgTestBase
{
	DECLARE_TEST(CbpIDETest, CbpSubSuite)

// Attributes
public:

// Operations
public:  
	virtual void PreRun(void);
	virtual void Run();

protected:  // Test Cases
	// BP1Cases
	BOOL BreakAtLine(  );
	BOOL Disable_Enable(  );
	BOOL BreakOnExpressionStaticVars(  );
	BOOL BreakOnCompoundExpression(  );
	BOOL BreakAtVirtualFunc(  );

	// BP2Cases
	// for the static child
	BOOL BPTable(  );
	BOOL LocationBPWithExp(  );
	BOOL MessageBP(  );
	BOOL BreakStepTrace(  );   // stepping, tracing, breakpoints

};

#endif //__bpcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bpcase2.h ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the Cbp2IDETest Class
//

#ifndef __bpcase2_H__
#define __bpcase2_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "bpsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CbpIDETest class

class Cbp2IDETest : public CDbgTestBase
{
	DECLARE_TEST(Cbp2IDETest, CbpSubSuite)

// Attributes
public:

// Operations
public:  
	virtual void PreRun(void);
	virtual void Run();

protected:  // Test Cases

	// BP2Cases
	// for the child w/dll's
	BOOL BreakDLLInit(  );
	BOOL BPTableDLL(  );
	BOOL LoadDLLBreak(  );
};

#endif //__bpcase2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\disasm\disasub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDisAsmSubSuite class
//

#include "stdafx.h"
#include "DisAsub.h"
#include "afxdllx.h"
#include "..\..\DbgTestBase.h"

#include "DisAcase.h"
#include "DisAsmPP.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite

IMPLEMENT_SUBSUITE(CDisAsmSubSuite, CIDESubSuite, "Disassembly", "VCQA Debugger")

BEGIN_TESTLIST(CDisAsmSubSuite)
	TEST(CDisAsmIDETest, RUN)
	TEST(CDisAsmPP, RUN)
END_TESTLIST()

void CDisAsmSubSuite::CleanUp(void)
	{
	::CleanUp("testgo01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization

void CDisAsmSubSuite::SetUp(BOOL bCleanUp)

{
	CIDESubSuite::SetUp(bCleanUp);
	// TODO(michma - 9/2/98): re-enable when memory leak bugs are fixed.
	ExpectedMemLeaks(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bpcase3.h ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase3.h
//
//	Created by:			Date:
//		MichMa				10/10/97
//
//	Description :
//		Declaration of the CBp3Cases Class
//

#ifndef __BPCASE3_H__
#define __BPCASE3_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "bpsub.h"


///////////////////////////////////////////////////////////////////////////////
//	CBp3Cases class

class CBp3Cases : public CDbgTestBase

{
	DECLARE_TEST(CBp3Cases, CbpSubSuite)

public:

	// Operations
	virtual void PreRun(void);
	virtual void Run();

	// Test Cases
	void BreakOnGlobalConstructorAndRestart(void);
	void BreakOnFunctionContainingScopeOperator(void);
	void BreakOnOverloadedSymbolSetBeforeStartDebugging(void);
	void BreakOnOverloadedSymbolSetAfterStartDebugging(void);
	void StepOverFunctionThatHitsBp(void);
	void BreakWhenAggregateExpressionChanges(void);
	void BreakOnMultipleBreakpoints(void);
	void BreakOnDllFuncThatWasUnloadedAfterSettingBp(void);
	void CompareGlobalAndLocalDataBpPerformance(void);
	void StepOutOfFunctionThatHitsBp(void);
	void StepToCursorThatHitsBp(void);
	//xbox void HitBpInDllSetBeforeStartDebugging(void);
	//xbox void HitBpInDllSetAfterStartDebugging(void);
	void HitLocationBpInExeSetWhileDebuggeeRunning(void);
	//xbox void HitLocationBpInDllSetWhileDebuggeeRunning(void);
	void HitDataBpInExeSetWhileDebuggeeRunning(void);
	void EditBpCodeWhenSourceIsInForeground(void);
	void EditBpCodeWhenSourceIsOpenButNotInForeground(void);
	void EditBpCodeWhenSourceIsNotOpen(void);
	void EditBpCodeWhenInputIsRequiredToFindSource(void);
	void HitBpWithPassCount(void);
	void HitBpAfterInterruptingPassCountAndRestarting(void);
	void HitBpSetInStack(void);
	void RemoveBpSetInStack(void);
	void HitBpWhenInputRequiredToFindSource(void);
	void InitTestState(void);
};

#endif //__BPCASE3_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bpsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CbpSubSuite class
//

#include "stdafx.h"
#include "bpsub.h"
#include "afxdllx.h"

#include "bpcase.h"
#include "bpcase2.h"
#include "bpcase3.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CbpSubSuite

IMPLEMENT_SUBSUITE(CbpSubSuite, CIDESubSuite, "Breakpoint", "VCQA Debugger")

BEGIN_TESTLIST(CbpSubSuite)
	TEST(CbpIDETest, RUN)
	//xbox (bps in dlls) TEST(Cbp2IDETest, RUN)
	TEST(CBp3Cases, RUN)
END_TESTLIST()

void CbpSubSuite::CleanUp(void)
	{
	::CleanUp("testbp01");
	::CleanUp("testgo01");
	::CleanUp("dbg");
	::CleanUp("dbga");
	::CleanUp("bp3");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\disasm\disasub.h ===
///////////////////////////////////////////////////////////////////////////////
//	DisAsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDisAsmSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite class

class CDisAsmSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CDisAsmSubSuite)
//	CDisAsmSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
	void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\disasm\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\disasm\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\eecase.h ===
///////////////////////////////////////////////////////////////////////////////
//	EECASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CEEIDETest Class
//

#ifndef __EECASE_H__
#define __EECASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "eesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CEEIDETest class

class CEEIDETest : public CDbgTestBase
	
	{
	DECLARE_TEST(CEEIDETest, CEESubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__EECASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\disasm\disacase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DisAcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDisAsmIDETest Class
//

#ifndef __DisAcase_H__
#define __DisAcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "disasub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDisAsmIDETest class

class CDisAsmIDETest : public CDbgTestBase
{
	DECLARE_TEST(CDisAsmIDETest, CDisAsmSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases
	void SourceAnnotation(void);
	void GoToSymbol(void);
	void HitBreakPoint(void);
	void SwitchDAMtoSRCandBack(void);
	void TraceIntoCall(void);
	void SwitchSRCtoDAMMultiInstance(void);
	void VerifyDockingView(void);
	void GoToMaxMinAddress(void);
	void GoToInvalidAddress(void);
	void OpenDAMWhileChildIsRunning(void);
	void CodeBytes(void);
	void SetFocusToThread(void);
	void GoToOverloadedSymbol(void);
	void GoAfterScrollDisassemblyWndModified(void);
	void CheckAsmSourceAndDAMConsistency(void);
	void RedisplayingAfterEditingRegistersAndMemoryWindowsNoCVINFO(void);
	void ToolbarToDAMExpression(void);
	void StepIntoStepOver(void);

	void HitBreakPointNoCVINFO(void);
	void NavigateStackNoCVINFO(void);
	void PgUpDownCtrlHomeEndNoCVINFO(void);
	void SetNextStatementViaCtrlShiftF7NoCVINFO(void);

	//xbox void DebugJIT(void);

protected:
	BOOL GoAfterScrollDisassemblyWnd(void);
	void CheckThatIPisAtFuncWithArg(void);
	void MinimalTestResizeMoveWindow(void);
	void TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest);
	void PgUpDownCtrlHomeEnd(void);
	void PopulateDamWindowText(void);


private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
};

#endif //__DisAcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\disasm\disasmpp.h ===
///////////////////////////////////////////////////////////////////////////////
//	DISASMPP.H
//
//	Created by:			
//		dverma
//
//	Description:
//		VC6 Processor Pack testcases.
//

#ifndef __DisAsmPP_H__
#define __DisAsmPP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "disasub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDisAsmPP class

class CDisAsmPP : public CDbgTestBase
{
	DECLARE_TEST(CDisAsmPP, CDisAsmSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases
	void TestMMX(void);
	void TestKatmai(void);

protected:
	BOOL GoAfterScrollDisassemblyWnd(void);
	void CheckThatIPisAtFuncWithArg(void);
	void MinimalTestResizeMoveWindow(void);
	void TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest);
	void PgUpDownCtrlHomeEnd(void);


private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
};

#endif //__DisAsmPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\disasm\disacase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DisAcase.CPP
//											 
//	Created by :			
//		dklem
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "DisAcase.h"	
#include "process.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CDisAsmIDETest, CDbgTestBase, "General", -1, CDisAsmSubSuite)

// each function that runs a test has this prototype.
typedef void (CDisAsmIDETest::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

//#define XBOXBUG_INCRLINK

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.

PTR_TEST_FUNC tests[] = {
	&CDisAsmIDETest::HitBreakPoint,
	&CDisAsmIDETest::SourceAnnotation,
	&CDisAsmIDETest::GoToSymbol,
	&CDisAsmIDETest::SwitchDAMtoSRCandBack,
	&CDisAsmIDETest::TraceIntoCall,
	&CDisAsmIDETest::SwitchSRCtoDAMMultiInstance,
	&CDisAsmIDETest::GoToMaxMinAddress,
	&CDisAsmIDETest::GoToInvalidAddress,
	// TODO: (dklem 09/10/98) Uncomment the following 1 line when #7924 get fixed. Fixed!
	// TODO: (dklem 12/03/98) Uncomment the following 1 line and write a new code for this test when #11382 fixed.
	//&CDisAsmIDETest::OpenDAMWhileChildIsRunning,
	&CDisAsmIDETest::CodeBytes,
	&CDisAsmIDETest::SetFocusToThread,
	&CDisAsmIDETest::GoToOverloadedSymbol,
	&CDisAsmIDETest::GoAfterScrollDisassemblyWndModified,
	&CDisAsmIDETest::CheckAsmSourceAndDAMConsistency,
	&CDisAsmIDETest::ToolbarToDAMExpression,
	&CDisAsmIDETest::StepIntoStepOver,
	&CDisAsmIDETest::VerifyDockingView,
};


PTR_TEST_FUNC tests_woutcvinfo[] = {
	
	// TODO: (dklem 11/06/98) Uncomment the following line when #9202 is fixed.  Fixed in 8313.4
	&CDisAsmIDETest::HitBreakPointNoCVINFO,
	&CDisAsmIDETest::NavigateStackNoCVINFO,
	&CDisAsmIDETest::PgUpDownCtrlHomeEndNoCVINFO,
	// TODO: (dklem 12/16/98) Uncomment the following 1 line when #12874 is fixed
	&CDisAsmIDETest::SetNextStatementViaCtrlShiftF7NoCVINFO,
	&CDisAsmIDETest::RedisplayingAfterEditingRegistersAndMemoryWindowsNoCVINFO
	
	
};


// holds the asm we expect to see.
CStringArray csDamWindowTextAtTemplateFooLine;

												 
void CDisAsmIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDisAsmIDETest::Run()
{	 
	/******************
	 * INITIALIZATION *
	 ******************/
	PopulateDamWindowText();

	if (!CreateXboxProjectFromSource("disasm", "src\\disasm",
				"disasm.cpp", "damthread.c"))
			return;
	
	// indexes into the test function array.
	int iTest;
	
	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());
	
	// In the tests it is assumed that the initial DAM window has Docking View turned on
	EXPECT_TRUE(uidam.EnableDockingView(FALSE));
	EXPECT_TRUE(dbg.ToggleSourceAnnotation(TRUE));

	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC) + sizeof(tests_woutcvinfo) / sizeof(PTR_TEST_FUNC) + 2;
	// + 2 = 1 (DebugJIT) + 1 (GoAfterScrollDisassemblyWndModified() contains GoToMaxMinAddress() )

	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
	if (0)
		(this->*(tests[iTest]))();

	dbg.StopDebugging();

#pragma message("***Without CVINFO, its all screwy, revisit!")
	return;

	// for xbox
	WaitStepInstructions("End of CV tests, sleeping for 20 seconds.");
	Sleep(20000);

	// Rebuild without cvinfo
	prj.SetTarget((CString)m_strProjectName + " - Xbox " +
						GetLocString(IDSS_BUILD_RELEASE));

	// set remote path before building, so autocopy works
	EXPECT_SUCCESS(prj.SetRemotePath(REMOTE_XBOX_FILE));

	// now build
	EXPECT_SUCCESS(prj.Build());

	prj.SetLocateOtherDLLs(TOGGLE_OFF);

	// all tests expect the ide to be in this initial state.
	//EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, NOWAIT));

	// The tests that checks if the dialog "exe does not contain debugging information ...Show this message [ ]" comes up
	COApplication appRel;
	if(!appRel.Attach("Microsoft Developer Studio", 5))
	{
	//	TODO: (dklem 09/22/98) Uncomment the following 1 line when #6954 gets fixed.  Fixed in 8310.3
		LOG->RecordFailure("The dialog \"exe does not contain debugging information ...Show this message [ ]\" did not come up");
	}
	else
	{
		MST.WCheckCheck("@1");
		// Click OK on the dialog "exe does not contain debugging information ...Show this message [ ]" 
		appRel.SendKeys("{ENTER}");	
	}

	// we only want to randomly run each test once.
	RandomNumberCheckList rncl1(sizeof(tests_woutcvinfo) / sizeof(PTR_TEST_FUNC));

	if(CMDLINE->GetBooleanValue("random", TRUE))
	{
		// randomly run each test once.
		while((iTest = rncl1.GetNext()) != -1)
			(this->*(tests_woutcvinfo[iTest]))();
	}
	else
	{
		// run each test in sequence.
		for(iTest = 0; iTest < sizeof(tests_woutcvinfo) / sizeof(PTR_TEST_FUNC); iTest++)
			(this->*(tests_woutcvinfo[iTest]))();
	}

	dbg.StopDebugging(NOWAIT) ;
	prj.Close();

	//Debug retail exe.  JIT
	// TODO(michma - 10/22/98): re-enable when mc bug 8150 is fixed. manually verify it before re-enabling this test, since
	// bugs like this tend to not be fixed correctly the first time, and this bug hangs up the whole snap run.
	// remember to make the fixed ide your jit debugger when testing.
	//DebugJIT();

}	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

void CDisAsmIDETest::SourceAnnotation(void)
{

	LOGTESTHEADER("SourceAnnotation");

	bool bInitiallyMaximized;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	int nLinesInDamCode = sizeof(csDamWindowTextAtTemplateFooLine)/sizeof(csDamWindowTextAtTemplateFooLine[0]);

	uidam.Activate();

	// We need to maximize the DAM window to be able to read all csDamWindowTextAtTemplateFooLine[] instructions
	HWND hwnd = uidam.HWnd();

	if(IsZoomed(hwnd))
		bInitiallyMaximized = TRUE;
	else 
	{
		bInitiallyMaximized = FALSE;
		ShowWindow(hwnd, SW_MAXIMIZE);
	}

	// TODO: (dklem 02/04/99) MSTEST doesn't work correctly on W2K.  If we do {DOWN 50} and then {UP 50 }
	// the caret sometimes doesn't return to the same position 
	// so we check just 10 lines
	nLinesInDamCode = 10;

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(int ii = 0; ii < nLinesInDamCode; ii++) 
		EXPECT_TRUE(dam.InstructionContains(ii - 2, csDamWindowTextAtTemplateFooLine[ii], FALSE));

	// Restore the DAM window before restarting
	if(!bInitiallyMaximized)
		ShowWindow(hwnd, SW_RESTORE);

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Check that Source annotation off works
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Activate and maximize for the next test
	uidam.Activate();
	hwnd = uidam.HWnd();

	if(IsZoomed(hwnd))
		bInitiallyMaximized = TRUE;
	else 
	{
		bInitiallyMaximized = FALSE;
		ShowWindow(hwnd, SW_MAXIMIZE);
	}


	// Turn Source annotation off
	// TODO: (dklem 09/17/98) Uncomment the following 1 line when #6811 gets fixed
	EXPECT_TRUE(uidam.ChooseContextMenuItem(SOURCE_ANNOTATION));

	// Check that there are no Soure code lines.  We assume that each line in csDamWindowTextAtTemplateFooLine[]
	// which begins with space  or \t is a Source code line
	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(int jj = ii = 0; jj < nLinesInDamCode; ii++, jj++) 
	{
		// check if this is a Source code line
		while(csDamWindowTextAtTemplateFooLine[jj].GetAt(0) == (char) ' ' || csDamWindowTextAtTemplateFooLine[jj].GetAt(0) ==  '\t') 
			if(++jj >= nLinesInDamCode - 1)
				break;

	// TODO: (dklem 09/17/98) Uncomment the following 2 lines when #6774 gets fixed.  Fixed in 8337.0
			if(jj < nLinesInDamCode)
				EXPECT_TRUE(dam.InstructionContains(ii - 1, csDamWindowTextAtTemplateFooLine[jj], FALSE));

	}

	// Turn Source annotation on
	// TODO: (dklem 09/17/98) Uncomment the following 1 line when #6811 gets fixed
	EXPECT_TRUE(uidam.ChooseContextMenuItem(SOURCE_ANNOTATION));
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int FuncWithArg(int nArg)", FALSE));

	// Restore the DAM window
	if(!bInitiallyMaximized)
		ShowWindow(hwnd, SW_RESTORE);

	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}

void CDisAsmIDETest::GoToSymbol(void)
{
	LOGTESTHEADER("GoToSymbol");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();
	// We need this Step Over to locate caret at the current addres
	EXPECT_TRUE(dbg.StepOver());
	InstructionSaved = dam.GetInstruction();
	csAddress = InstructionSaved.Left(8);

	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int FuncWithArg(int nArg)", FALSE));
	EXPECT_TRUE(dam.InstructionContains(1, "push        ebp", FALSE));
	
	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	//* We need this Step Over to locate caret at the current addres
	//* EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/09/98) Uncomment the following 1 line when #6403 gets fixed. Fixed in Build 8296.1
	EXPECT_TRUE(dam.InstructionContains(0, InstructionSaved, FALSE));

	//Change address to hex
	csAddress = "0x" + csAddress;
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	//* EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/09/98) Uncomment the following 1 line when #6403 gets fixed. Fixed in Build 8296.1
	EXPECT_TRUE(dam.InstructionContains(0, InstructionSaved, FALSE));

	// Toggle Hex mode and do the previous tests to verify that hex mode doesn't affect them
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));
	
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.GotoSymbol(csAddress));
	//* EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/09/98) Uncomment the following 1 line when #6403 gets fixed. Fixed in Build 8296.1
	EXPECT_TRUE(dam.InstructionContains(0, InstructionSaved, FALSE));
	
	//Change address to dec
	csAddress = csAddress.Right(8);
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	//* EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/09/98) Uncomment the following 1 line when #6403 gets fixed. Fixed in Build 8296.1
	EXPECT_TRUE(dam.InstructionContains(0, InstructionSaved, FALSE));

	// Toggle Hex mode back
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}

void CDisAsmIDETest::HitBreakPoint(void)
{
	LOGTESTHEADER("HitBreakPoint");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// In this part we set a BP at FuncWithArg using F9

	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int FuncWithArg(int nArg)", FALSE));
	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	CheckThatIPisAtFuncWithArg();

	// In this part we Restart and Go and see in the a BP at FuncWithArg is hit
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	CheckThatIPisAtFuncWithArg();

	// In this part we Stop and Go and see in the a BP at FuncWithArg is hit. We also toggle the BP off
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	// Toggle breakpoint off
	EXPECT_TRUE(uidam.ChooseContextMenuItem(TOGGLE_BREAKPOINT));
	CheckThatIPisAtFuncWithArg();

	// In this part we set a BP at Func using Context Menu and Go.
	// We are trying to kill two birds here:
	// 1. Check if BP at FuncWithArg was actully toggled off, so we pass it
	// 2. BP at Func was set and hit
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dam.GotoSymbol("Func"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int Func(double dArg)", FALSE));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(INSERT_REMOVE_BREAK_POINT));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	// We need to make step over in the DAM window, so we activate
	dam.Enable();
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.InstructionContains(-3, "int Func(double dArg)", FALSE));

	// In this part we toggle BP at FuncWithArg on.  Check this and remove it.
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int FuncWithArg(int nArg)", FALSE));
	// Toggle breakpoint on
	EXPECT_TRUE(uidam.ChooseContextMenuItem(TOGGLE_BREAKPOINT));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	// Remove breakpoint
	EXPECT_TRUE(uidam.ChooseContextMenuItem(INSERT_REMOVE_BREAK_POINT));
	CheckThatIPisAtFuncWithArg();

	// In this part we check that BP at FuncWithArg was removed.
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	// We need to make step over in the DAM window, so we activate
	dam.Enable();
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.InstructionContains(-3, "int Func(double dArg)", FALSE));

	//Remove all BPs
	EXPECT_TRUE(bps.ClearAllBreakpoints());

	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}

void CDisAsmIDETest::CheckThatIPisAtFuncWithArg(void)
{

	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dam.InstructionContains(-2, "int FuncWithArg(int nArg)", FALSE));

	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC());
	EXPECT_TRUE(!dam.IsActive());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.VerifyCurrentLine("return nArg + 2;"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC());
	EXPECT_TRUE(dam.IsActive());
	EXPECT_TRUE(dbg.StepOver());
	// TODO (dklem 02/01/99)  ERROR.  Looks like a bug in 60.
	//'mov         al,byte ptr [chJustChar]' looks as 'mov         al,byte ptr [ebp - whatever]'
	// The following 1 line commented because this bug
	//	EXPECT_TRUE(dam.InstructionContains(-1, "mov         eax,dword ptr [nArg]", FALSE));
	EXPECT_TRUE(dam.InstructionContains(-2, "return nArg + 2;", FALSE));

}

void CDisAsmIDETest::SwitchDAMtoSRCandBack(void)
{
	LOGTESTHEADER("SwitchDAMtoSRCandBack");
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	
	dam.Enable();

	for(BOOL bUsingContextMenu = FALSE; bUsingContextMenu <= TRUE; bUsingContextMenu++)
		for(int ii = 0; ii < 4; ii++)
		{
			EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(bUsingContextMenu));
			EXPECT_TRUE(!dam.IsActive());
			EXPECT_TRUE(dbg.VerifyCurrentLine("TemplateFoo <char>(chJustChar);		/* First line for tests */"));
			EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(bUsingContextMenu));
			EXPECT_TRUE(dam.IsActive());
			//Sleep(500);
			EXPECT_TRUE(dam.InstructionContains(-1, "TemplateFoo <char>(chJustChar);     /* First line for tests */", FALSE));
												
			// TODO (dklem 02/01/99)  ERROR.  Looks like a bug in 60.
			//'mov         al,byte ptr [chJustChar]' looks as 'mov         al,byte ptr [ebp - whatever]'
			// The following 1 line commented because this bug
			// EXPECT_TRUE(dam.InstructionContains(0, "mov         al,byte ptr [chJustChar]", FALSE));

		}

	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}

void CDisAsmIDETest::SwitchSRCtoDAMMultiInstance(void)
{
	// Note that the Resolve Ambiguity verification implemented differently
	// in the GoToOverloadedSymbol() and in SwitchSRCtoDAMMultiInstance()
	// In SwitchSRCtoDAMMultiInstance() we find first instructions in each of TemplateFoo instances
	// by stepping in them and then verify that Resolve Ambiguity dialog brings us to the correct instructions.
	// In GoToOverloadedSymbol() we go to call TemplateFoo and check the address og the first instruction
	// and then verify that Resolve Ambiguity dialog brings us to the correct instructions.

	LOGTESTHEADER("SwitchSRCtoDAMMultiInstance");

	CString csResolveAmbiguityFunction[2];
	CString csInstructionInTemplateFoo[2];
	BOOL bFunctionFound;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// First of all we want to find first instruction in TemplateFoo <char>(chJustChar);		
	EXPECT_TRUE(dbg.StepInto());
	csInstructionInTemplateFoo[0] = dam.GetInstruction();

	// Then we want to find first instruction in TemplateFoo <int>(nJustInt);	
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(FALSE));
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(dbg.StepInto(2));
	csInstructionInTemplateFoo[1] = dam.GetInstruction();

	// Now check that Resolve Ambiguity dialog brings us to the correct instructions.
	csResolveAmbiguityFunction[0] = "TemplateFoo(char)";
	csResolveAmbiguityFunction[1] = "TemplateFoo(int)";

	for(int jj = 0; jj < 2; jj++)
	{
		dam.Disable();
		EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(FALSE));
		EXPECT_TRUE(dbg.ResolveSourceLineAmbiguity(csResolveAmbiguityFunction[jj]));

		//EXPECT_TRUE(dam.InstructionContains(1, csInstructionInTemplateFoo[jj], FALSE));

		bFunctionFound = FALSE;
		for(int ii = 0; ii < 10; ii++)
			if(	TRUE == (bFunctionFound = dam.InstructionContains(ii, csInstructionInTemplateFoo[jj], FALSE)))
				break;
		if(!bFunctionFound)
			LOG->RecordFailure("Address %s for %s was not found in %d lines", csInstructionInTemplateFoo[jj], csResolveAmbiguityFunction[jj], ii);
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~ delete until this line ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	}

	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::TraceIntoCall(void)
{
	LOGTESTHEADER("TraceIntoCall");

	CString csAddress, csAddress1;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Second line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Trace into call
	EXPECT_TRUE(dam.InstructionContains(-1, "FuncWithArg(1);", FALSE));
	EXPECT_TRUE(dam.InstructionContains(0, "push        1", FALSE));
	EXPECT_TRUE(dbg.StepInto());
	// Get address
	if(csAddress = dam.GetInstruction())
	{
		csAddress.MakeUpper();
		csAddress = csAddress.Right(csAddress.GetLength() - csAddress.Find("FUNCWITHARG"));
		csAddress = csAddress.Right(csAddress.GetLength() - csAddress.Find("(") - 1);
		csAddress = csAddress.Left(csAddress.FindOneOf("h)"));
	}

	// Check SHOW_NEX_STATEMENT
	EXPECT_TRUE(uidam.ChooseContextMenuItem(SHOW_NEX_STATEMENT));
	EXPECT_TRUE(dam.InstructionContains(0, "call", FALSE));
#ifdef XBOXBUG_INCRLINK
	EXPECT_TRUE("Test is running modified for Xbox incremental link bug");
	EXPECT_TRUE(dam.InstructionContains(0, "FuncWithArg (", FALSE));
#else
	EXPECT_TRUE(dam.InstructionContains(0, "(FuncWithArg) (", FALSE));
#endif
	

#ifdef XBOXBUG_INCRLINK
#else
	EXPECT_TRUE(dbg.StepInto());
	// Get address
	if(csAddress1 = dam.GetInstruction())
	{
		csAddress1.MakeUpper();
		// Check that the address is correct
		EXPECT_TRUE( -1 != (csAddress1.Left(8)).Find(csAddress));
		csAddress1 = csAddress1.Right(csAddress1.GetLength() - csAddress1.Find("FUNCWITHARG"));
		csAddress1 = csAddress1.Right(csAddress1.GetLength() - csAddress1.Find("(") - 1);
		csAddress1 = csAddress1.Left(csAddress1.FindOneOf("h)"));
	}

	EXPECT_TRUE(dam.InstructionContains(0, "jmp         FuncWithArg (", FALSE));
#endif

	EXPECT_TRUE(dbg.StepInto());
	
	// Check that the address is correct
	if(csAddress = dam.GetInstruction())
	{
		csAddress1.MakeUpper();	
		EXPECT_TRUE( -1 != (csAddress.Left(8)).Find(csAddress1));
	}

	EXPECT_TRUE(dam.InstructionContains(-2, "int FuncWithArg(int nArg)", FALSE));
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(dam.InstructionContains(1, "Func(dJustDouble);", FALSE));
	
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::GoToMaxMinAddress(void)
{

	LOGTESTHEADER("GoToMaxMinAddress");

	CString csAddress, csInstruction;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	EXPECT_TRUE(dam.GotoSymbol("00000000"));
	// TODO: (dklem 09/09/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	//csInstruction = uidam.GetInstruction(0, 1, TRUE);
	csInstruction = dam.GetInstruction();

	EXPECT_TRUE("00000000" == (csAddress = csInstruction.Left(8)));
	LOG->RecordInfo("CurrentAddress is %s", csAddress);

	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixed
	EXPECT_TRUE(dam.GotoSymbol("FFFFFFFF"));

	// TODO: (dklem 09/09/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	//csInstruction = uidam.GetInstruction(0, 1, TRUE);
	csInstruction = dam.GetInstruction();

	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixed
	EXPECT_TRUE("FFFFFFFF" == (csAddress = csInstruction.Left(8)));
	LOG->RecordInfo("CurrentAddress is %s", csAddress);
	
	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::GoAfterScrollDisassemblyWndModified(void)
{

	LOGTESTHEADER("GoAfterScrollDisassemblyWndModified");

	for ( int i = 0; i < 200; i++)
	{
		MST.DoKeys ("+{pgdn}",FALSE,2000); //wait for idling
		if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_PART,0)
			|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_PART,0))
			MST.WButtonClick( "Cancel" );
	}
		
	GoToMaxMinAddress();
}

void CDisAsmIDETest::GoToInvalidAddress(void)
{

	LOGTESTHEADER("GoToInvalidAddress");

	CString csAddress, csInstruction;
	HWND resulthWnd;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixed
	EXPECT_TRUE(dam.GotoSymbol("FFFFFFFFF5"));
	// TODO: (dklem 09/09/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// csInstruction = uidam.GetInstruction(0, 1, TRUE);
	csInstruction = dam.GetInstruction();

	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixed
	EXPECT_TRUE("FFFFFFF5" == (csAddress = csInstruction.Left(8)));
	LOG->RecordInfo("CurrentAddress is %s", csAddress);

	EXPECT_TRUE(dam.GotoSymbol("PRIVET", FALSE));

	EXPECT_TRUE(NULL != (resulthWnd = MST.WFndWnd("Microsoft Visual C++", FW_NOCASE | FW_EXIST)));
	if(NULL != resulthWnd)
	{
		MST.WButtonClick("OK");
	}
	dam.Enable();
	// TODO: (dklem 09/09/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// csInstruction = uidam.GetInstruction(0, 1, TRUE);
	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixedcsInstruction = dam.GetInstruction();
	EXPECT_TRUE("FFFFFFF5" == (csAddress = csInstruction.Left(8)));
	LOG->RecordInfo("CurrentAddress is %s", csAddress);

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::OpenDAMWhileChildIsRunning(void)
{

	LOGTESTHEADER("OpenDAMWhileChildIsRunning");

	CString csInstruction;
	
	// Restart and Go.  Close DAM Open DAM
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));

	dam.Enable();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	dam.Enable();
	csInstruction = dam.GetInstruction();
	// TODO: (dklem 11/03/98) Uncomment the following line when #8896 is fixed
	// EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// Stop and Go with DAM opened
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	dam.Enable();
	csInstruction = dam.GetInstruction();
	EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// Stop, Go and open DAM with Context menu
	// TODO: (dklem 09/10/98) Uncomment the following 5 line when #6530 and #6531 get fixed
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	csInstruction = dam.GetInstruction();
	EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// Stop, start, Go and open DAM 
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.StepInto());
	dam.Enable();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	dam.Enable();
	csInstruction = dam.GetInstruction();
	// TODO: (dklem 11/03/98) Uncomment the following line when #8896 is fixed
	// EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// Stop, start, open DAM and Go 
// TODO: (dklem 09/10/98) Uncomment the following 5 line when #6534 gets fixed
//	EXPECT_TRUE(dbg.StopDebugging());
//	EXPECT_TRUE(dbg.StepInto());
//	dam.Enable();
//	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
//	csInstruction = dam.GetInstruction();
//	EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// We can not restart neither when child is running nor when debugger is not started, so we stop and start it into 2 steps
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.StepInto());

	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	
}


void CDisAsmIDETest::CodeBytes(void)
{

	LOGTESTHEADER("CodeBytes");

	CString csAddress, csInstruction, csCodeBytes;
	char csCodeBytesInMemWindow[64];
	
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));

	for(int ii = 0; ii < 2; ii++)
	{
		EXPECT_TRUE(dbg.StepInto());
		csInstruction = dam.GetInstruction();
		csAddress = csInstruction.Left(8);
		csCodeBytes = csInstruction.Mid(9, 20);
		csCodeBytes.TrimLeft();
		csCodeBytes.TrimRight();
		mem.GetMemoryData(csAddress, csCodeBytesInMemWindow, MEM_FORMAT_BYTE, csCodeBytes.GetLength());
		csCodeBytesInMemWindow[csCodeBytes.GetLength()]  ='\0';
		LOG->Comment("csInstruction=[%s], csAddress=[%s], csCodeBytes=[%s]", csInstruction, csAddress, csCodeBytes);
		EXPECT_TRUE(0 == csCodeBytes.CompareNoCase(csCodeBytesInMemWindow));
	}
	
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));
	EXPECT_TRUE(!dam.InstructionContains(0, csCodeBytes, FALSE));

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));
	EXPECT_TRUE(dam.InstructionContains(0, csCodeBytes, FALSE));

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}



void CDisAsmIDETest::SetFocusToThread(void)
{
	// xbox: changed MessageBeep to SetLastError

	LOGTESTHEADER("SetFocusToThread");

	BOOL bFileSeparatorFound = FALSE; 
			
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(ERROR_SUCCESS == src.Open("damthread.c")); 
	EXPECT_TRUE(src.Find("SetLastError(1);", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.VerifyCurrentLine("SetLastError(1);"));

	dam.Enable();

	EXPECT_TRUE(dam.InstructionContains(-1, "SetLastError(1);", FALSE));
	EXPECT_TRUE(dam.InstructionContains(0, "push        1", FALSE));
	EXPECT_TRUE(dam.InstructionContains(1, "call        SetLastError", FALSE));
	/*
	EXPECT_TRUE(dam.InstructionContains(-1, "MessageBeep(1);", FALSE));
	EXPECT_TRUE(dam.InstructionContains(0, "mov         esi,esp", FALSE));
	EXPECT_TRUE(dam.InstructionContains(1, "push        1", FALSE));
	// One more check for a mangeled name
	EXPECT_TRUE(dam.InstructionContains(2, "call        dword ptr [__imp__MessageBeep@4", FALSE));
	*/


#if 1
#pragma message("Excluding code that checks for file separators, Xbox binaries dont match Win32 ones")
	EXPECT_TRUE("Excluding code that checks for file separators, Xbox binaries dont match Win32 ones");
#else
	// Check File separators
	EXPECT_TRUE(dam.GotoSymbol("ThreadRoutine"));
	// Using the next statement we just scroll 1 line up.  Actually it will be 2 lines scroll, 
	// since file separator is skipped while scrolling
	//dam.InstructionContains(-1, "", FALSE);
	EXPECT_TRUE(dam.InstructionContains(-3, "disasm xbe\\damthread.c  ---", FALSE));

	EXPECT_TRUE(dam.GotoSymbol("WinMain"));
	// Using the next statement we just scroll 8 lines up.  Actually it will be 9 lines scroll, 
	// since file separator is skipped while scrolling
	//dam.InstructionContains(-8, "", FALSE);

	for(int ii = 0; ii > -10; ii--)
		if(	TRUE == (bFileSeparatorFound = dam.InstructionContains(ii, m_strProjectName + ".cpp" + "  ---", FALSE)))
			break;
	if(!bFileSeparatorFound)
			LOG->RecordFailure("File separator for %s was not found in %d lines", m_strProjectName + ".cpp", ii);
#endif

	//Remove all BPs
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(ERROR_SUCCESS == src.Open(m_strProjectName + ".cpp"));

	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::GoToOverloadedSymbol(void)
{

	// Note that the Resolve Ambiguity verification implemented differently
	// in the GoToOverloadedSymbol() and in SwitchSRCtoDAMMultiInstance()
	// In SwitchSRCtoDAMMultiInstance() we find first instructions in each of TemplateFoo instances
	// by stepping in them and then verify that Resolve Ambiguity dialog brings us to the correct instructions.
	// In GoToOverloadedSymbol() we go to call TemplateFoo and check the address og the first instruction
	// and then verify that Resolve Ambiguity dialog brings us to the correct instructions.


	CString csInstruction, csAddress;
	CString csResolveAmbiguityFunction[2];
	CString csResolveAmbiguityInstruction[2];
	
	LOGTESTHEADER("GoToOverloadedSymbol");

	BOOL bFuncltionFound; 

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	csResolveAmbiguityFunction[0] = "OverloadedFunc(int)";
	csResolveAmbiguityInstruction[0] = "void OverloadedFunc(int nArg)";

	csResolveAmbiguityFunction[1] = "OverloadedFunc(void)";
	csResolveAmbiguityInstruction[1] = "void OverloadedFunc(void)";

	// Test Overloaded Functions
	for(int jj = 0; jj < 2; jj++)
	{
		dam.Enable();
		dam.GotoSymbol("OverloadedFunc", FALSE);
		EXPECT_TRUE(dbg.ResolveAmbiguity(csResolveAmbiguityFunction[jj]));
		dam.Enable();

		// TODO: (dklem 09/16/98) Uncomment the following line when #6013 gets fixed
		// #6013 was split into severeal bugs.  New bug for this case is #7884 (related bug #7887)
		// EXPECT_TRUE(dam.InstructionContains(0, "void OverloadedFunc(int nArg)", FALSE));
		// TODO: (dklem 09/16/98) Remove the following 5 lines when #6013 gets fixed
		// #6013 was split into severeal bugs.  New bug for this case is #7884 (related bug #7887)
		for(int ii = 0, bFuncltionFound = FALSE; ii > -20; ii--)
			if(	TRUE == (bFuncltionFound = dam.InstructionContains(ii, csResolveAmbiguityInstruction[jj], FALSE)))
				break;
		if(!bFuncltionFound)
				LOG->RecordFailure("Function %s was not found in %d lines", csResolveAmbiguityInstruction[jj], ii);
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~ delete until this line ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	}

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// The same test for Template Functions
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	
	csResolveAmbiguityFunction[0] = "TemplateFoo(char)";
	csResolveAmbiguityFunction[1] = "TemplateFoo(int)";

	for(jj = 0; jj < 2; jj++)
	{
		dam.Enable();
		EXPECT_TRUE(dbg.StepInto(3));

		if(csAddress = dam.GetInstruction())
		{
			csAddress = csAddress.Right(csAddress.GetLength() - csAddress.Find("TemplateFoo"));
			csAddress = csAddress.Right(csAddress.GetLength() - csAddress.Find("(") - 1);
#ifdef XBOXBUG_INCRLINK
			csAddress = csAddress.Left(csAddress.FindOneOf(")"));
#else
			csAddress = csAddress.Left(csAddress.FindOneOf("h)"));
#endif
			csAddress.MakeUpper();
		}

		dam.GotoSymbol("TemplateFoo", FALSE);
		EXPECT_TRUE(dbg.ResolveAmbiguity(csResolveAmbiguityFunction[jj]));
		dam.Enable();

		// TODO: (dklem 09/16/98) Uncomment the following line when #6013 gets fixed
		// #6013 was split into severeal bugs.  New bug for this case is #7884 (related bug #7887)
		// EXPECT_TRUE(dam.InstructionContains(0, csAddress, FALSE));
		// TODO: (dklem 09/16/98) Remove the following 5 lines when #6013 gets fixed
		// #6013 was split into severeal bugs.  New bug for this case is #7884 (related bug #7887)
		for(int ii = 0; ii < 10 ; ii++)
			if(	TRUE == (bFuncltionFound = dam.InstructionContains(ii, csAddress, FALSE)))
				break;
		if(!bFuncltionFound)
			LOG->RecordFailure("Address %s for %s was not found in %d lines", csAddress, csResolveAmbiguityFunction[jj], ii);
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~ delete until this line ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		EXPECT_TRUE(dbg.StepOver());
		EXPECT_TRUE(dbg.StepOut());
		EXPECT_TRUE(dbg.StepOver());
	}

	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}

void CDisAsmIDETest::CheckAsmSourceAndDAMConsistency(void)
{
	LOGTESTHEADER("CheckAsmSourceAndDAMConsistency");

	BOOL bFuncltionFound = FALSE; 

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("__asm {", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	EXPECT_TRUE(dam.InstructionContains(0, "push        eax", FALSE));
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionContains(0, "pop         eax", FALSE));

	// The following 4 lines are bug 3879 related
	// TODO (dklem 02/01/99)  ERROR.  Looks like a bug in 60.
	//'mov         al,byte ptr [chJustChar]' looks as 'mov         al,byte ptr [ebp - whatever]'
	// The following 4 lines used to skip such lines
/*
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionContains(0, "lea         eax,[nJustInt]", FALSE));
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionContains(0, "mov         dword ptr [p],eax ", FALSE));
*/
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}


void CDisAsmIDETest::ToolbarToDAMExpression(void)
{
	LOGTESTHEADER("ToolbarToDAMExpression");

	BOOL bFuncltionFound = FALSE; 

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("FuncWithArg", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	app.SendKeys("^F");
	app.SendKeys("^{F7}");	

	EXPECT_TRUE(dam.InstructionContains(-2, "FuncWithArg", FALSE));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	
}


void CDisAsmIDETest::StepIntoStepOver(void)
{

	LOGTESTHEADER("StepIntoStepOver");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests ", FALSE, FALSE, FALSE, 0 )); // last argument 0 = FD_DOWN
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(int ii = 2; ii < 4; ii++) {
		EXPECT_TRUE(dam.InstructionContains(0, csDamWindowTextAtTemplateFooLine[ii], FALSE));
		EXPECT_TRUE(dbg.StepOver());
	}

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests ", FALSE, FALSE, FALSE, 0 )); // last argument 0 = FD_DOWN
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(ii = 2; ii < 4; ii++) {
		EXPECT_TRUE(dam.InstructionContains(0, csDamWindowTextAtTemplateFooLine[ii], FALSE));
		EXPECT_TRUE(dbg.StepInto());
	}

	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 )); // last argument 0 = FD_DOWN
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(ii = 2; ii < 4; ii++) {
		// TODO: (dklem 10/8/98) Uncomment the following line when #4321 gets fixed
		EXPECT_TRUE(dam.InstructionContains(0, csDamWindowTextAtTemplateFooLine[ii], FALSE));
		EXPECT_TRUE(dbg.StepOver());
	}

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(ii = 2; ii < 4; ii++) {
		// TODO: (dklem 10/8/98) Uncomment the following line when #4321 gets fixed
		EXPECT_TRUE(dam.InstructionContains(0, csDamWindowTextAtTemplateFooLine[ii], FALSE));
		EXPECT_TRUE(dbg.StepInto());
	}


	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}

void CDisAsmIDETest::RedisplayingAfterEditingRegistersAndMemoryWindowsNoCVINFO(void)
{
	LOGTESTHEADER("RedisplayingAfterEditingRegistersAndMemoryWindowsNoCVINFO");

	CString csAddress, InstructionSaved;
	char csCodeBytesInMemWindow[64];

	// Restart 
	EXPECT_TRUE(dbg.Restart());

	dam.Enable();

	// We need this Step Over to locate caret at the current address
	EXPECT_TRUE(dbg.StepOver());
	InstructionSaved = dam.GetLines(10, 1);
	csAddress = InstructionSaved.Left(8);

	// Change register
	EXPECT_TRUE(regs.SetRegister(EIP, csAddress)); 

	dam.Enable();

	// TODO: (dklem 09/22/98) Uncomment the following line when #6923 and #6924 get fixed. #6923 is fixed in 8308.1. #6924 is fixed in 8323.0
	EXPECT_TRUE(dam.InstructionContains(0, csAddress, FALSE));
	EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/22/98) Uncomment the following line when #6923 gets fixed. Fixed in 8308.1
	EXPECT_TRUE(dam.InstructionContains(-1, csAddress, FALSE));

	// The test plan says that combination with DAM scrolling is interesting
	dam.Enable();

	PgUpDownCtrlHomeEnd();
	
	mem.GetMemoryData(csAddress, csCodeBytesInMemWindow, MEM_FORMAT_BYTE,1);
	csCodeBytesInMemWindow[2] = '\0';
	if(strcmp(csCodeBytesInMemWindow,"AA") == 0)
		strcpy(csCodeBytesInMemWindow, "FF");
	else
		strcpy(csCodeBytesInMemWindow, "AA");

	// TODO: (dklem 09/22/98) Uncomment the following line when #6923 gets fixed. Fixed in 8308.1
	EXPECT_TRUE(mem.SetMemoryData(csAddress, csCodeBytesInMemWindow, MEM_FORMAT_BYTE));
	
	dam.Enable();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));
	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	// TODO: (dklem 09/22/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// InstructionSaved = uidam.GetInstruction(0, 1, TRUE);
	InstructionSaved = dam.GetInstruction();

	// Get two first code bytes
	InstructionSaved = InstructionSaved.Mid(9, 20);
	InstructionSaved.TrimLeft(" \t");
	InstructionSaved = InstructionSaved.Left(2);

	// TODO: (dklem 09/22/98) Uncomment the following line when #6923 and #6013 get fixed. #6923 is fixed in 8308.1
	EXPECT_TRUE(InstructionSaved == csCodeBytesInMemWindow);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));

	// The test plan says that combination with DAM scrolling is interesting
	dam.Enable();
	PgUpDownCtrlHomeEnd();

}

void CDisAsmIDETest::HitBreakPointNoCVINFO(void)
{
	LOGTESTHEADER("HitBreakPointNoCVINFO");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());

	// We need this Step Over to locate caret at the current addres
	EXPECT_TRUE(dbg.StepOver());
	InstructionSaved = dam.GetLines(10, 1);
	csAddress = InstructionSaved.Left(8);

	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	// TODO: (dklem 09/16/98) Remove the following line when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// uidam.GetInstruction(0, 1, TRUE); This line should be removed
	EXPECT_TRUE(uidam.ChooseContextMenuItem(SET_NEXT_STATEMENT));	

	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	EXPECT_TRUE(dbg.StopDebugging(ASSUME_NORMAL_TERMINATION));

	dbg.StepOver();
	EXPECT_TRUE(bps.EnableAllBreakpoints());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	EXPECT_TRUE(dam.InstructionContains(0, csAddress, FALSE));

	//Remove all BPs
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CDisAsmIDETest::SetNextStatementViaCtrlShiftF7NoCVINFO(void)
{
	LOGTESTHEADER("SetNextStatementViaCtrlShiftF7NoCVINFO");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());

	// We need this Step Over to locate caret at the current addres
	EXPECT_TRUE(dbg.StepOver());
	InstructionSaved = dam.GetLines(10, 1);
	csAddress = InstructionSaved.Left(8);

	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	// TODO: (dklem 09/16/98) Remove the following line when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// uidam.GetInstruction(0, 1, TRUE); This line should be removed
	MST.DoKeys("^+{F7}");

	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.InstructionContains(-1, csAddress, FALSE));

}


void CDisAsmIDETest::NavigateStackNoCVINFO(void)
{
	LOGTESTHEADER("NavigateStackNoCVINFO");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	EXPECT_TRUE(stk.NavigateStack(0));
	// Check if DAM window came up
	EXPECT_TRUE(dam.InstructionContains(0, "push        ebp", FALSE));

	//Check that DAM comes up when the debugee is restarted
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dam.InstructionContains(0, "push        ebp", FALSE));
}

void CDisAsmIDETest::PgUpDownCtrlHomeEndNoCVINFO(void)
{

	LOGTESTHEADER("PgUpDownCtrlHomeEndNoCVINFO");
	
	// Restart 
	EXPECT_TRUE(dbg.Restart());
	dam.Enable();

	// Test RUN_TO_CURSOR
	EXPECT_TRUE(dam.InstructionContains(0, "push        ebp", FALSE));

	// TODO: (dklem 09/16/98) This is a dangerous place.  We can go out of scope, so RUN_TO_CURSOR will hang the child because of while(1) cycle
	MST.DoKeys("{PGDN}");

	// TODO: (dklem 09/16/98) Remove the following line when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// uidam.GetInstruction(0, 1, TRUE); This line should be removed
	EXPECT_TRUE(uidam.ChooseContextMenuItem(RUN_TO_CURSOR));
	EXPECT_TRUE(dbg.StepInto());
	// TODO (dklem 09/16/98) This won't work correct (result doesn't mean that we really moved to the new position) until #6774 gets fixed.  Fixed in 8337.0
	// Check that this gives an error if the following line: 
	// EXPECT_TRUE(uidam.ChooseContextMenuItem(RUN_TO_CURSOR));
	// above is commented ( when #6774 gets fixed )
	// The problem here is if RUN_TO_CURSOR doesn't work, StepInto will position EIP to the IP next to "push        ebp"
	// and this IP will be at the top of the DAM.  -1 in the next statement means pushing hte Up arrow.  However, since #6774
	// the IP will remain at the position next to "push        ebp" and the next statement doesn't make a sense.
	// So, try this test with commented EXPECT_TRUE(uidam.ChooseContextMenuItem(RUN_TO_CURSOR)); must give an error at the next line
	// If you shure that #6774 is fixed or doesn't exist, don't bother with this
	EXPECT_TRUE(!dam.InstructionContains(-1, "push        ebp", FALSE));
	
	// Return the caret to the original position.  This is necessary for the nex test PgUpDownCtrlHomeEnd()
	MST.DoKeys("{UP}");
	
	PgUpDownCtrlHomeEnd();
}

void CDisAsmIDETest::PgUpDownCtrlHomeEnd(void)
{

	CString csInitialAddress, csNewAddress, csNewAddress1;
	
	csInitialAddress = (dam.GetInstruction()).Left(8);
	
	// Check PhUp and PgDown
// TODO: (dklem 09/16/98) Uncomment the following /* */ block when #6763 is fixed
	MST.DoKeys("{PGUP 5}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	EXPECT_TRUE(csNewAddress < csInitialAddress);

	MST.DoKeys("{PGDN 5}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	MST.DoKeys("{PGDN 5}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("{PGUP 5}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6763 gets fixed
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	// Check Ctrl+End and Ctrl+Home
/*	MST.DoKeys("^{END}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("^{HOME}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress == csInitialAddress);
*/
	// Check Arrows Up and Down
	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress < csInitialAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress1 < csNewAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csNewAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	// TODO: (dklem 09/16/98) Uncomment the following 2 lines when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress1 > csNewAddress);
	EXPECT_TRUE(csNewAddress1 == csInitialAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 > csNewAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csNewAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress1 == csInitialAddress);

	MinimalTestResizeMoveWindow();

}

void CDisAsmIDETest::VerifyDockingView(void)
{
	LOGTESTHEADER("VerifyDockingView");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(uidam.EnableDockingView(TRUE));
	EXPECT_TRUE(uidam.IsDockingViewEnabled());
	// TODO: (dklem 09/14/98) Uncomment the following line when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next line if the Debug version of MSDEV causes Out of Memory
	 TestResizeMoveWindow(TRUE, TRUE);	

	EXPECT_TRUE(uidam.EnableDockingView(FALSE));
	EXPECT_TRUE(!uidam.IsDockingViewEnabled());
	// TODO: (dklem 09/14/98) Uncomment the following line when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next line if the Debug version of MSDEV causes Out of Memory
	TestResizeMoveWindow(FALSE, TRUE);	

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}


void CDisAsmIDETest::MinimalTestResizeMoveWindow()
{

// TODO remove the next line immediately
//	return;
	
	BOOL bInitiallyMaximized;

	uidam.Activate();
	HWND hwnd = uidam.HWnd();

	if(IsZoomed(hwnd))
	{
		bInitiallyMaximized = TRUE;
		ShowWindow(hwnd, SW_RESTORE);
	}
	else 
		bInitiallyMaximized = FALSE;
	
	

	// TODO: (dklem 09/14/98) Uncomment the following 4 lines when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next 4 lines if the Debug version of MSDEV causes Out of Memory
	TestResizeMoveWindow(FALSE, FALSE);

	// Restore the DAM window before turning Docking View on
	if(bInitiallyMaximized)
		ShowWindow(hwnd, SW_MAXIMIZE);
	
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));

	TestResizeMoveWindow(TRUE, FALSE);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
}

void CDisAsmIDETest::TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest)
{
	int nPositionMoved;
	uidam.Activate();

	BOOL DragFullWindows = TRUE;
	EXPECT_TRUE(GetDragFullWindows(&DragFullWindows));

	// Try minimum hor and ver sizes
	nPositionMoved = uidam. ResizeWindow(bIsDocked, SLeft, DRight, -1, DragFullWindows);
	uidam.ResizeWindow(bIsDocked, SLeft, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.ResizeWindow(bIsDocked, SBottom, DUp, -1, DragFullWindows);
	uidam.ResizeWindow(bIsDocked, SBottom, DDown, nPositionMoved, DragFullWindows);

	// Move the window
	nPositionMoved = uidam.MoveWindow(bIsDocked, DRight, 20, DragFullWindows);
	nPositionMoved = uidam.MoveWindow(bIsDocked, DDown, 20, DragFullWindows);
	nPositionMoved = uidam.MoveWindow(bIsDocked, DLeft, 20, DragFullWindows);
	nPositionMoved = uidam.MoveWindow(bIsDocked, DUp, 20, DragFullWindows);

	if(!bFullTest) return;

	// Try to go beyond screen borders
	nPositionMoved = uidam.ResizeWindow(bIsDocked, SLeft, DLeft, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		uidam.Activate();
	}
	uidam.ResizeWindow(bIsDocked, SLeft, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.ResizeWindow(bIsDocked, SRight, DRight, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		uidam.Activate();
	}
	uidam.ResizeWindow(bIsDocked, SRight, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.ResizeWindow(bIsDocked, SBottom, DDown, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		uidam.Activate();
	}
	uidam.ResizeWindow(bIsDocked, SBottom, DUp, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.ResizeWindow(bIsDocked, STop, DUp, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.ResizeWindow(bIsDocked, STop, DDown, 10, DragFullWindows);

	// I like to move it move it
	nPositionMoved = uidam.MoveWindow(bIsDocked, DRight, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.MoveWindow(bIsDocked, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.MoveWindow(bIsDocked, DLeft, -1, DragFullWindows);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.MoveWindow(bIsDocked, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.MoveWindow(bIsDocked, DDown, -1, DragFullWindows);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.MoveWindow(bIsDocked, DUp, nPositionMoved, DragFullWindows);

	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();

	nPositionMoved = uidam.MoveWindow(bIsDocked, DUp, -1, DragFullWindows);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.MoveWindow(bIsDocked, DDown, nPositionMoved, DragFullWindows);

}

void CDisAsmIDETest::PopulateDamWindowText(void)

{
	// This is a part of DAM window.  Copy it here if it changes.  I used the following steps
	// Use Ctrl+Sfift+F8 to select/remove rectangle 
	// I used the following steps
	// 1. Turn Off Code Byte in debugee's DAM, seclect lines you want to check and copy them
	// 2. Open a new text window and paste copied lines there.
	// 3. Select the very left rectangular part which contains addresses and delete it
	// 4. Select the part which left in the text window using Ctrl+Sfift+F8 (this is important). And copy this part.
	// 5. Switch to this file and select lines belonging to the csDamWindowTextAtTemplateFooLine array between
	//	   " and ",
	// 6. Press Ctrl+V.  
	// 7. Remove (addressh)
	// It is assumed in the SourceAnnotation that each line in csDamWindowTextAtTemplateFooLine[]
	// wchich begins with space or \t is a Source code line !
		
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add("        TemplateFoo <char>(chJustChar);     /* First line for tests */			");
			// TODO (dklem 02/01/99)  ERROR.  Looks like a bug in 60.
			//'mov         al,byte ptr [chJustChar]' looks as 'mov         al,byte ptr [ebp - whatever]'
			// The next 1 line should replace the 2 line
	/*"mov         al,byte ptr [chJustChar]											");
	"push        eax																");
	"call																			");
	"add         esp,4																");
	"        TemplateFoo <int>(nJustInt);											");
	"mov         ecx,dword ptr [nJustInt]											");
	"push        ecx																");
	"call																			");
	"add         esp,4																");
	"																				");
	"        goto Ku_Ku;															");
	"jmp         Ku_Ku+																");
	"                nJustInt = 7;													");
	"Ku_Ku:																			");
	"                nJustInt = 17;													");
	"mov         dword ptr [nJustInt],												");
	"																				");
	"        FuncWithArg(1);														");
	"push        1																	");
	"call																			");
	"add         esp,4																");
	"        Func(dJustDouble);														");
	"mov         edx,dword ptr [ebp-												");
	"push        edx																");
	"mov         eax,dword ptr [dJustDouble]										");
	"push        eax																");
	"call			 																");
	"add         esp,8																");
	"																				");
	"        OverloadedFunc();														");
	"call						 													");
	"        OverloadedFunc(nJustInt);												");
	"mov         ecx,dword ptr [nJustInt]											");
	"push        ecx																");
	"call						 													");
	"add         esp,4																");
	"																				");
	" hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadRoutine, (void*) pJustInt, 0L,&dwThreadId);");
	"mov         esi,esp															");
	"lea         edx,[dwThreadId]													");
	"push        edx																");
	"push        0																	");
	"mov         eax,dword ptr [pJustInt]											");
	"push        eax																");
	"push        offset @ILT+									");
	"push        0																	");
	"push        0																	");
	// If you remove the following line, add a line containing a mangeled name (@)
	"call        dword ptr [__imp__CreateThread@24									");	
	"cmp         esi,esp															");
	"call        																");
	"mov         dword ptr [hThread],eax											");
	"     ResumeThread(hThread);													");
	*/
	csDamWindowTextAtTemplateFooLine.Add("mov         al,byte ptr [														");
	csDamWindowTextAtTemplateFooLine.Add("push        eax																");
	csDamWindowTextAtTemplateFooLine.Add("call																			");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,4																");
	csDamWindowTextAtTemplateFooLine.Add("        TemplateFoo <int>(nJustInt);											");

	// code-gen is different for these two instructions for processor pack.
	if(1) //xbox - CMDLINE->GetBooleanValue("PP", FALSE))
	{
		csDamWindowTextAtTemplateFooLine.Add("mov         eax,dword ptr [													");
		csDamWindowTextAtTemplateFooLine.Add("push        eax																");
	}
	else
	{
		csDamWindowTextAtTemplateFooLine.Add("mov         ecx,dword ptr [													");
		csDamWindowTextAtTemplateFooLine.Add("push        ecx																");
	}

	csDamWindowTextAtTemplateFooLine.Add("call																			");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,4																");
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add("        goto Ku_Ku;															");
	csDamWindowTextAtTemplateFooLine.Add("jmp         Ku_Ku+																");
	csDamWindowTextAtTemplateFooLine.Add("                nJustInt = 7;													");
	csDamWindowTextAtTemplateFooLine.Add("Ku_Ku:																			");
	csDamWindowTextAtTemplateFooLine.Add("                nJustInt = 17;													");
	csDamWindowTextAtTemplateFooLine.Add("mov         dword ptr [														");
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add("        FuncWithArg(1);														");
	csDamWindowTextAtTemplateFooLine.Add("push        1																	");
	csDamWindowTextAtTemplateFooLine.Add("call																			");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,4																");
	csDamWindowTextAtTemplateFooLine.Add("        Func(dJustDouble);														");
	csDamWindowTextAtTemplateFooLine.Add("mov         edx,dword ptr [													");
	csDamWindowTextAtTemplateFooLine.Add("push        edx																");
	csDamWindowTextAtTemplateFooLine.Add("mov         eax,dword ptr [													");
	csDamWindowTextAtTemplateFooLine.Add("push        eax																");
	csDamWindowTextAtTemplateFooLine.Add("call			 																");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,8																");
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add("        OverloadedFunc();														");
	csDamWindowTextAtTemplateFooLine.Add("call						 													");
	csDamWindowTextAtTemplateFooLine.Add("        OverloadedFunc(nJustInt);												");
	csDamWindowTextAtTemplateFooLine.Add("mov         ecx,dword ptr [													");
	csDamWindowTextAtTemplateFooLine.Add("push        ecx																");
	csDamWindowTextAtTemplateFooLine.Add("call						 													");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,4																");
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add(" hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadRoutine, (void*) pJustInt, 0L,&dwThreadId);");
	csDamWindowTextAtTemplateFooLine.Add("mov         esi,esp															");
	csDamWindowTextAtTemplateFooLine.Add("lea         edx,[																");
	csDamWindowTextAtTemplateFooLine.Add("push        edx																");
	csDamWindowTextAtTemplateFooLine.Add("push        0																	");
	csDamWindowTextAtTemplateFooLine.Add("mov         eax,dword ptr [													");
	csDamWindowTextAtTemplateFooLine.Add("push        eax																");
	csDamWindowTextAtTemplateFooLine.Add("push        offset @ILT+									");
	csDamWindowTextAtTemplateFooLine.Add("push        0																	");
	csDamWindowTextAtTemplateFooLine.Add("push        0																	");
	// If you remove the following line, add a line containing a mangeled name (@)
	csDamWindowTextAtTemplateFooLine.Add("call        dword ptr [__imp__CreateThread@24									");	
}


////////////////////// OLD TESTS ///////////////////////////////////////////////
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
////////////////////////////////////////////////////////////////////////////////

BOOL CDisAsmIDETest::GoAfterScrollDisassemblyWnd(  )
{
	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.
	BOOL retval = TRUE;

	CODebug codebug;
	EXPECT( codebug.Restart() );

	// Open DAM
	UIDAM dam = UIDebug::ShowDockWindow( IDW_DISASSY_WIN, TRUE );
	EXPECT( dam.IsActive() );

	int i;
	for ( i = 0; i < 200; i++)
	{
		MST.DoKeys ("+{pgdn}",FALSE,2000); //wait for idling
		if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_PART,0)
			|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_PART,0))
			MST.WButtonClick( "Cancel" );
	}
		
	if ( !UIWB.VerifySubstringAtLine( "???" ) )
	{
		EXPECT ( src.GoToLine("0xf00000") );
	}

	if ( !UIWB.VerifySubstringAtLine( "???" ) )
	{
		EXPECT ( src.GoToLine("0xffffff") );
	}
		
	if ( !UIWB.VerifySubstringAtLine( "???" ) )
	{ 
   		m_pLog->RecordInfo("0x00ffffff : The app is too big: test case should be revised" );
		retval = FALSE;
	}

// YS: ToDo: we should use Go instead of StopDebugging

	//	EXPECT(	codebug.Go(NULL,NULL,NULL,0) );
	//	CString TitleRun = (CString)"[" + GetLocString(IDSS_DBG_RUN) + "]";
	//	MST.WFndWndWait(TitleRun, FW_PART, 10);
	//	
	//	UIWB.WaitForTermination();

	codebug.StopDebugging();		// TODO: WinslowF - Above three lines are replaced by this due to focus problems in Chicago.
// YS: end of block for ToDo

	WriteLog(PASSED, "01 : Scrolling Disassembly Window didn't corrupt Debugging as expected" );

	return retval;
}


	//~~~~~~~~~~~~~~~~~~~~~~~~~
/*
*	GO_TO_SOURCE,	
*	SHOW_NEX_STATEMENT,
*	INSERT_REMOVE_BREAK_POINT,
*	TOGGLE_BREAKPOINT,
*	RUN_TO_CURSOR,				
*	SET_NEXT_STATEMENT,
*	SOURCE_ANNOTATION,
*	CODE_BYTES,
	CODE_INJECTION,
*	DOCKING_VIEW,
*	CLOSE_HIDE
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\bp\bpcase3.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BPCASE3.CPP
//											 
//	Created by:			Date:			
//		MichMa				10/10/97	
//
//	Description:								 
//		Implementation of CBp3Cases		 

#include "stdafx.h"
#include "bpcase3.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
			 	 
											   
IMPLEMENT_TEST(CBp3Cases, CDbgTestBase, "Breakpoints Pri3", -1, CbpSubSuite)


// each function that runs a test has this prototype.
typedef void (CBp3Cases::*PTR_TEST_FUNC)(void); 

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = {
	&CBp3Cases::BreakOnGlobalConstructorAndRestart,
	&CBp3Cases::BreakOnFunctionContainingScopeOperator,
	&CBp3Cases::BreakOnOverloadedSymbolSetBeforeStartDebugging,
	&CBp3Cases::BreakOnOverloadedSymbolSetAfterStartDebugging,
	&CBp3Cases::StepOverFunctionThatHitsBp,
	&CBp3Cases::BreakWhenAggregateExpressionChanges,
	&CBp3Cases::BreakOnMultipleBreakpoints,
	//xbox &CBp3Cases::BreakOnDllFuncThatWasUnloadedAfterSettingBp,
	&CBp3Cases::CompareGlobalAndLocalDataBpPerformance,
	&CBp3Cases::StepOutOfFunctionThatHitsBp,
	&CBp3Cases::StepToCursorThatHitsBp,
	//xbox &CBp3Cases::HitBpInDllSetBeforeStartDebugging,
	//xbox &CBp3Cases::HitBpInDllSetAfterStartDebugging,
	&CBp3Cases::HitLocationBpInExeSetWhileDebuggeeRunning,
	//xbox &CBp3Cases::HitLocationBpInDllSetWhileDebuggeeRunning,
	&CBp3Cases::HitDataBpInExeSetWhileDebuggeeRunning,
	&CBp3Cases::EditBpCodeWhenSourceIsInForeground,
	&CBp3Cases::EditBpCodeWhenSourceIsOpenButNotInForeground,
	&CBp3Cases::EditBpCodeWhenSourceIsNotOpen,
	// TODO(michma): re-enable when bug vs98:36090 is fixed.
	//&CBp3Cases::EditBpCodeWhenInputIsRequiredToFindSource,
	&CBp3Cases::HitBpWithPassCount,
	&CBp3Cases::HitBpAfterInterruptingPassCountAndRestarting,
	&CBp3Cases::HitBpSetInStack,
	&CBp3Cases::RemoveBpSetInStack,
	&CBp3Cases::HitBpWhenInputRequiredToFindSource
};

void CBp3Cases::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CBp3Cases::Run()

{
	if (!CreateXboxProjectFromSource("breakpoints pri2", "src\\breakpoints pri2",
				"breakpoints pri2 exe.cpp"))
			return;

	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	/*
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
		(this->*(tests[iTest]))();
	*/
	for (iTest = 0; iTest < (sizeof(tests) / sizeof(PTR_TEST_FUNC)); iTest++)
		(this->*(tests[iTest]))();
}


void CBp3Cases::InitTestState()
{
	EXPECT_TRUE(dbg.Restart());
}


void CBp3Cases::BreakOnGlobalConstructorAndRestart(void)
{	
	LogTestHeader("BreakOnGlobalConstructorAndRestart");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_VALIDBP(bps.SetBreakpoint("CBase::CBase"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of CBase::CBase()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("CBase::CBase"));
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of CBase::CBase()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("CBase::CBase"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
}


// note that the <class>::<function> case is covered by BreakOnGlobalConstructorAndRestart(), so we only
// have to test global functions with scope operators here.
void CBp3Cases::BreakOnFunctionContainingScopeOperator(void)
{  
	LogTestHeader("BreakOnFunctionContainingScopeOperator");
	EXPECT_VALIDBP(bps.SetBreakpoint("::Func"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState(); 
}


void CBp3Cases::BreakOnOverloadedSymbolSetBeforeStartDebugging(void)
{
	LogTestHeader("BreakOnOverloadedSymbolSetBeforeStartDebugging");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_VALIDBP(bps.SetBreakpoint("OverloadedFunc"));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dbg.ResolveAmbiguity(1));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of OverloadedFunc(void)"));
	EXPECT_TRUE(stk.CurrentFunctionIs("OverloadedFunc()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState(); 
}


void CBp3Cases::BreakOnOverloadedSymbolSetAfterStartDebugging(void)
{
	LogTestHeader("BreakOnOverloadedSymbolSetAfterStartDebugging");
	EXPECT_VALIDBP(bps.SetAmbiguousBreakpoint("OverloadedFunc", 2));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of OverloadedFunc(int)"));
	EXPECT_TRUE(stk.CurrentFunctionIs("OverloadedFunc(int 1)"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState(); 
}


void CBp3Cases::StepOverFunctionThatHitsBp(void)
{
	LogTestHeader("StepOverFunctionThatHitsBp");
	EXPECT_TRUE(src.Find("Func();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	//xbox EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	InitTestState(); 
}


void CBp3Cases::BreakWhenAggregateExpressionChanges(void)
{
	LogTestHeader("BreakWhenAggregateExpressionChanges");
	EXPECT_VALIDBP(bps.SetBreakOnExpr("gCBaseObj", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("gCBaseObj change"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState(); 
}


void CBp3Cases::BreakOnMultipleBreakpoints(void)
{
	LogTestHeader("BreakOnMultipleBreakpoints");
	EXPECT_TRUE(src.Find("multiple breakpoints hit"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(src.Find("init iLocal in Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iGlobal + iLocal == 2", COBP_TYPE_IF_EXP_TRUE));
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iGlobal", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_VALIDBP(bps.SetBreakpoint("MultipleBreakpointsHitLabel"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(cxx.ExpressionValueIs("iGlobal + iLocal", 2));
	EXPECT_TRUE(dbg.CurrentLineIs("multiple breakpoints hit"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("multiple breakpoints hit"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	InitTestState(); 
}


void CBp3Cases::BreakOnDllFuncThatWasUnloadedAfterSettingBp(void)
{
	LogTestHeader("BreakOnDllFuncThatWasUnloadedAfterSettingBp");
	EXPECT_TRUE(src.Find("FreeLibrary(hDll)"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakpoint("DllFunc"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState(); 
}


void CBp3Cases::CompareGlobalAndLocalDataBpPerformance(void)
{
	LogTestHeader("CompareGlobalAndLocalDataBpPerformance");
	EXPECT_TRUE(src.Find("for(i = 0; i < iLoopNum; i++)"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iLocal", COBP_TYPE_IF_EXP_CHANGED));
	time_t timeStart = time(NULL);
	EXPECT_TRUE(dbg.Go());
	int timeLocalBp = time(NULL) - timeStart;
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart()); 
	EXPECT_TRUE(src.Find("for(i = 0; i < iLoopNum; i++)"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iGlobal", COBP_TYPE_IF_EXP_CHANGED));
	timeStart = time(NULL);
	EXPECT_TRUE(dbg.Go());
	int timeGlobalBp = time(NULL) - timeStart;
	EXPECT_TRUE(timeLocalBp > timeGlobalBp);
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	InitTestState(); 
}


void CBp3Cases::StepOutOfFunctionThatHitsBp(void)
{
	LogTestHeader("StepOutOfFunctionThatHitsBp");
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(src.Find("line within Func()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(dbg.CurrentLineIs("line within Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	//xbox EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	InitTestState(); 
}


void CBp3Cases::StepToCursorThatHitsBp(void)
{
	LogTestHeader("StepToCursorThatHitsBp");
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(src.Find("line within Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	//xbox EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	InitTestState(); 
}


/*xbox void CBp3Cases::HitBpInDllSetBeforeStartDebugging(void)
{
	LogTestHeader("HitBpInDllSetBeforeStartDebugging");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(prj.SetAdditionalDLLs("Debug\\" + m_strProjBase + " dll.dll"));
	EXPECT_VALIDBP(bps.SetBreakpoint("DllFunc"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(dbg.Restart()); 	
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_SUCCESS(prj.RemoveAdditionalDLLs(1));
	EXPECT_TRUE(dbg.StopDebugging());
	InitTestState(); 	
}*/


/*xbox void CBp3Cases::HitBpInDllSetAfterStartDebugging(void)
{
	LogTestHeader("HitBpInDllSetAfterStartDebugging");
	EXPECT_SUCCESS(prj.SetAdditionalDLLs("Debug\\" + m_strProjBase + " dll.dll"));
	EXPECT_VALIDBP(bps.SetBreakpoint("DllFunc"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(dbg.Restart()); 	
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_SUCCESS(prj.RemoveAdditionalDLLs(1));
	EXPECT_TRUE(dbg.StopDebugging());
	InitTestState(); 	
}*/


void CBp3Cases::HitLocationBpInExeSetWhileDebuggeeRunning(void)
{
	LogTestHeader("HitLocationBpInExeSetWhileDebuggeeRunning");
	EXPECT_TRUE(cxx.SetExpressionValue("giDelay", 60));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(src.Find("line within main()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("line within main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState(); 	
}


/*xbox void CBp3Cases::HitLocationBpInDllSetWhileDebuggeeRunning(void)
{
	LogTestHeader("HitLocationBpInDllSetWhileDebuggeeRunning");
	EXPECT_TRUE(cxx.SetExpressionValue("giDelay", 60));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_SUCCESS(prj.SetAdditionalDLLs("Debug\\" + m_strProjBase + " dll.dll"));
	EXPECT_VALIDBP(bps.SetBreakpoint("DllFunc"));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_SUCCESS(prj.RemoveAdditionalDLLs(1));
	EXPECT_TRUE(dbg.StopDebugging());
	InitTestState(); 	
}*/


void CBp3Cases::HitDataBpInExeSetWhileDebuggeeRunning(void)
{
	LogTestHeader("HitDataBpInExeSetWhileDebuggeeRunning");
	EXPECT_TRUE(cxx.SetExpressionValue("giDelay", 60));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iGlobal == 100", COBP_TYPE_IF_EXP_TRUE));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(cxx.ExpressionValueIs("iGlobal", 100));
	EXPECT_TRUE(dbg.CurrentLineIs("iGlobal = 100"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	InitTestState(); 	
}


void CBp3Cases::EditBpCodeWhenSourceIsInForeground(void)
{
	LogTestHeader("EditBpCodeWhenSourceIsInForeground");
	bp *pBp = bps.SetBreakpoint("Func");
	EXPECT_TRUE(bps.EditCode(pBp));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CBp3Cases::EditBpCodeWhenSourceIsOpenButNotInForeground(void)
{
	LogTestHeader("EditBpCodeWhenSourceIsOpenButNotInForeground");
	bp *pBp = bps.SetBreakpoint("Func");
	EXPECT_SUCCESS(src.Create());
	EXPECT_TRUE(bps.EditCode(pBp));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_SUCCESS(src.Close());
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CBp3Cases::EditBpCodeWhenSourceIsNotOpen(void)
{
	LogTestHeader("EditBpCodeWhenSourceIsNotOpen");
	bp *pBp = bps.SetBreakpoint("Func");
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	EXPECT_TRUE(bps.EditCode(pBp));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


#undef TMP_CASE_DIR
#define TMP_CASE_DIR TMP_PROJ_DIR "\\EditBpCodeWhenInputIsRequiredToFindSource"

void CBp3Cases::EditBpCodeWhenInputIsRequiredToFindSource(void)
{
	LogTestHeader("EditBpCodeWhenInputIsRequiredToFindSource");
	bp *pBp = bps.SetBreakpoint("Func");
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	// need to create a unique directory for moving source in this test, because if source
	// has already been 'found' at the same location by previous test of
	// HitBpWhenInputRequiredToFindSource, no 'Find Source' dialog will be displayed!
	CreateDirectory(TMP_CASE_DIR,  NULL);
	KillFiles(TMP_CASE_DIR, "*.*");
	EXPECT_TRUE(MoveFile(m_strProjectDir + "\\" + m_strProjectName + ".cpp", (TMP_CASE_DIR "\\") + m_strProjectName + ".cpp"));
	EXPECT_TRUE(bps.EditCode(pBp, TMP_CASE_DIR));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	EXPECT_TRUE(MoveFile((TMP_CASE_DIR "\\") + m_strProjectName + ".cpp", m_strProjectDir + "\\" + m_strProjectName + ".cpp"));
	RemoveDirectory(TMP_CASE_DIR);
	EXPECT_TRUE(bps.EditCode(pBp));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(prj.Close());

	EXPECT_SUCCESS(prj.Open(m_strProjectDir + "\\" + m_strProjectName));
	InitTestState();
}


void CBp3Cases::HitBpWithPassCount(void)
{
	LogTestHeader("HitBpWithPassCount");
	EXPECT_TRUE(src.Find("line within loop"));
	EXPECT_SUCCESS(src.AttachActive());
	int iLine = src.GetCurrentLine();
	bp *pBp = bps.SetBreakpoint(iLine, NULL, 100);
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line within loop"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 100));
	EXPECT_TRUE(bps.RemainingPassCountIs(pBp, 0));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CBp3Cases::HitBpAfterInterruptingPassCountAndRestarting(void)

{
	LogTestHeader("HitBpAfterInterruptingPassCountAndRestarting");
	EXPECT_TRUE(src.Find("dll loaded"));
	EXPECT_TRUE(dbg.StepToCursor());
	bp *pBp1 = bps.SetBreakpoint("DllFunc", 50);
	EXPECT_TRUE(src.Find("line within loop"));
	bp *pBp2 = bps.SetBreakpoint();
	
	for(int i = 0; i < 5; i++)
		EXPECT_TRUE(dbg.Go());

	EXPECT_TRUE(dbg.CurrentLineIs("line within loop"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 4));
	EXPECT_TRUE(bps.RemainingPassCountIs(pBp1, 46));
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(bps.RemainingPassCountIs(pBp1, 50));
	EXPECT_TRUE(bps.RemoveBreakpoint(pBp2));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.RemainingPassCountIs(pBp1, 0));
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 50));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CBp3Cases::HitBpSetInStack(void)
{
	LogTestHeader("HitBpSetInStack");
	EXPECT_VALIDBP(bps.SetBreakpoint("Func"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(stk.ToggleBreakpoint(1));
	EXPECT_TRUE(dbg.Go());
	// emmang@xbox.com - move mouse focus to edit window
	dbg.ShowNextStatement();
	EXPECT_TRUE(dbg.CurrentLineIs("line after call to Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CBp3Cases::RemoveBpSetInStack(void)
{
	LogTestHeader("RemoveBpSetInStack");
	EXPECT_VALIDBP(bps.SetBreakpoint("Func"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(stk.ToggleBreakpoint(1));
	EXPECT_TRUE(stk.ToggleBreakpoint(1));
	//xbox EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


#undef TMP_CASE_DIR
#define TMP_CASE_DIR TMP_PROJ_DIR "\\HitBpWhenInputRequiredToFindSource"

void CBp3Cases::HitBpWhenInputRequiredToFindSource(void)
{
	LogTestHeader("HitBpWhenInputRequiredToFindSource");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("line within main()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	// need to create a unique directory for moving source in this test, because if source
	// has already been 'found' at the same location by previous test of
	// EditBpCodeWhenInputIsRequiredToFindSource, no 'Find Source' dialog will be displayed!
	CreateDirectory(TMP_CASE_DIR,  NULL);
	KillFiles(TMP_CASE_DIR, "*.*");
	EXPECT_TRUE(MoveFile(m_strProjectDir + "\\" + m_strProjectName + ".cpp", (TMP_CASE_DIR "\\") + m_strProjectName + ".cpp"));
	//WaitStepInstructions("Source file moved, gonna wait for Find Source dialog");
	//Sleep(5000);
	UIWB.m_pTarget->SetHandleMsgs(FALSE); //handle Find Source manually
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK, TRUE));
	EXPECT_TRUE(dbg.SupplySourceLocation(TMP_CASE_DIR));
	UIWB.m_pTarget->SetHandleMsgs(TRUE); //restore automatic handling of Find Source
	EXPECT_TRUE(dbg.CurrentLineIs("line within main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	EXPECT_TRUE(MoveFile((TMP_CASE_DIR "\\") + m_strProjectName + ".cpp", m_strProjectDir + "\\" + m_strProjectName + ".cpp"));
	RemoveDirectory(TMP_CASE_DIR);
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line within main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(prj.Close());

	EXPECT_SUCCESS(prj.Open(m_strProjectDir + "\\" + m_strProjectName));
	InitTestState();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\disasm\disasmpp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DISASMPP.CPP
//											 
//	Created by:			
//		dverma
//
//	Description:								 
//		VC6 Processor Pack testcases.		 

#include "stdafx.h"
#include "DisAsmPP.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CDisAsmPP, CDbgTestBase, "Processor Pack", -1, CDisAsmSubSuite)

// each function that runs a test has this prototype.
typedef void (CDisAsmPP::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber * 100) / m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = 
{
	&CDisAsmPP::TestMMX,
	&CDisAsmPP::TestKatmai
};

												 
void CDisAsmPP::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDisAsmPP::Run()

{	
	/******************
	 * INITIALIZATION *
	 ******************/

	if (!CreateXboxProjectFromSource("DisAsm PP", "src\\Disasm PP",
				"Disasm PP.cpp"))
			return;

	// all tests expect the ide to be in this initial state.
	if(!XboxDebuggerConnect())
	{
		prj.Close();
		return;
	}
	
	// indexes into the test function array.
	int iTest;
	
	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);

	// run each test once.
	for(iTest = 0; iTest < m_TotalNumberOfTests; iTest++)
	{
		(this->*(tests[iTest]))();
	}
	
	EXPECT_TRUE(dbg.StopDebugging(NOWAIT));
	EXPECT_SUCCESS(prj.Close());
}	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////


#if 0
#define EBP8	"[ebp-8]"
#define EBP10H	"[ebp-10h]"
#else
#define EBP8	"[count]"
#define EBP10H	"[iVar32]"
#endif

void CDisAsmPP::TestMMX()
{
	//	MMX switch has already been checked for in Run()
	
	LOGTESTHEADER("TestMMX");
	
	// Find the function we want to step into from main.cpp
	EXPECT_TRUE(dbg.Break());
	EXPECT_SUCCESS(src.Open(m_strProjectDir + "\\" + m_strProjectName + ".cpp")); 
	EXPECT_TRUE(src.Find("Test_MMX(); // src.Find()")); 

	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	//	test all registers for visibility
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm1,mm2"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm2,mm3"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm3,mm4"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm4,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm5,mm6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm6,mm7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm7,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	shift left
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	mov 32 bit
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd mm0,dword ptr " EBP10H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd dword ptr " EBP10H ",mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mmword ptr " EBP8 ",mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd mm0,eax"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd eax,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Pack with Signed Saturation
	EXPECT_TRUE(dam.VerifyCurrentInstruction("packsswb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packssdw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packsswb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packssdw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Pack with Unsigned Saturation	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("packuswb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packuswb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Add

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddd mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.Ste