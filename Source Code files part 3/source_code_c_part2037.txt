erviceComponent", typeof(PCTDataServiceComponent))]
    [System.Xml.Serialization.XmlElementAttribute("MEG", typeof(PCTDataMEG))]
    [System.Xml.Serialization.XmlElementAttribute("Partner", typeof(PCTDataPartner))]
    [System.Xml.Serialization.XmlElementAttribute("ExportDetails", typeof(PCTDataExportDetails))]
    [System.Xml.Serialization.XmlElementAttribute("ServiceClass", typeof(PCTDataServiceClass))]
    [System.Xml.Serialization.XmlElementAttribute("VersionDetails", typeof(PCTDataVersionDetails))]
    public object[] Items;
*/    
    
        /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Offering")]
    public PCTDataOffering[] Offering;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Category")]
    public PCTDataCategory[] Category;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Resource")]
    public PCTDataResource[] Resource;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ServiceComponent")]
    public PCTDataServiceComponent[] ServiceComponent;
        
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("MEG")]
    public PCTDataMEG[] MEG;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Partner")]
    public PCTDataPartner[] Partner;        
       
    /// <remarks/>
    public PCTDataExportDetails ExportDetails;
    
    /// <remarks/>
    public PCTDataVersionDetails VersionDetails;

    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ServiceClass")]
    public PCTDataServiceClass[] ServiceClass;

}

/// <remarks/>
public class PCTDataOffering {
    
    /// <remarks/>
    public string OfferingName;
    
    /// <remarks/>
    public string OfferingCreationDate;
    
    /// <remarks/>
    public string Currency;
    
    /// <remarks/>
    public string OfferingModifiedDate;
    
    /// <remarks/>
    public string RevenueSKU;
    
    /// <remarks/>
    public int OfferingVersion;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool OfferingVersionSpecified;
    
    /// <remarks/>
    public int OfferingAlwaysValid;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool OfferingAlwaysValidSpecified;
    
    /// <remarks/>
    public string StartDate;
    
    /// <remarks/>
    public string EndDate;
    
    /// <remarks/>
    public int ImmediateSettlement;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ImmediateSettlementSpecified;
    
    /// <remarks/>
    public int MaxOwnershipType;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool MaxOwnershipTypeSpecified;
    
    /// <remarks/>
    public int MaxOwnership;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool MaxOwnershipSpecified;
    
    /// <remarks/>
    public int GracePeriod;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool GracePeriodSpecified;
    
    /// <remarks/>
    public int BaseOffering;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool BaseOfferingSpecified;
    
    /// <remarks/>
    public int SubscriptionDuration;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool SubscriptionDurationSpecified;
    
    /// <remarks/>
    public int SubscriptionDurationType;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool SubscriptionDurationTypeSpecified;
    
    /// <remarks/>
    public int MSNIAOffering;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool MSNIAOfferingSpecified;
    
    /// <remarks/>
    public string InternalOfferingDescription;
    
    /// <remarks/>
    public string AutoRenewTarget;
    
    /// <remarks/>
    public string OfferingTermLocation;
    
    /// <remarks/>
    public string CommitmentTerms;
    
    /// <remarks/>
    public int ActivateOnPurchase;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ActivateOnPurchaseSpecified;
    
    /// <remarks/>
    public int CycleForward;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool CycleForwardSpecified;
    
    /// <remarks/>
    public int Obsolete;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ObsoleteSpecified;
    
    /// <remarks/>
    public int TermCommit;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool TermCommitSpecified;
    
    /// <remarks/>
    public int VariableCharges;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool VariableChargesSpecified;
    
    /// <remarks/>
    public int AllowNoPaymentInstrument;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool AllowNoPaymentInstrumentSpecified;
    
    /// <remarks/>
    public int SuppressEmailOnRenew;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool SuppressEmailOnRenewSpecified;
    
    /// <remarks/>    
    //[System.Xml.Serialization.XmlArrayItemAttribute("PaymentInstrument", typeof(PCTDataOfferingPaymentInstrumentListPaymentInstrument))]
    [System.Xml.Serialization.XmlElementAttribute("PaymentInstrumentList")]
    public PCTDataOfferingPaymentInstrumentListPaymentInstrument[] PaymentInstrumentList;
    
    /// <remarks/>
//    [System.Xml.Serialization.XmlArrayItemAttribute("Country", typeof(PCTDataOfferingCountryListCountry))]
    [System.Xml.Serialization.XmlElementAttribute("CountryList")]
    public PCTDataOfferingCountryListCountry[] CountryList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("OfferingResource", typeof(PCTDataOfferingOfferingResourceListOfferingResource))]
    public PCTDataOfferingOfferingResourceListOfferingResource[] OfferingResourceList;
    
    /// <remarks/>
    public PCTDataOfferingMigrationPathList MigrationPathList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("Language", IsNullable=false)]
    public PCTDataOfferingLanguage[] LanguageList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("ServiceInstance", IsNullable=false)]
    public PCTDataOfferingServiceInstance[] ServiceInstanceList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("SignUpURL", typeof(PCTDataOfferingSignUpURLListSignUpURL))]
    public PCTDataOfferingSignUpURLListSignUpURL[] SignUpURLList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("UDE", IsNullable=false)]
//    [System.Xml.Serialization.XmlElementAttribute("UDEList")]
    public PCTDataOfferingUDE[] UDEList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string OfferingID;
}

/// <remarks/>
public class PCTDataOfferingPaymentInstrumentListPaymentInstrument {
    
    /// <remarks/>
    public string PaymentInstrument;
}

/// <remarks/>
public class PCTDataVersionDetails {
    
    /// <remarks/>
    public string Version;
}

/// <remarks/>
public class PCTDataServiceClass {
    
    /// <remarks/>
    public string Name;
    
    /// <remarks/>
    public string ID;
}

/// <remarks/>
public class PCTDataExportDetailsSummary {
    
    /// <remarks/>
    public int OfferingCount;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool OfferingCountSpecified;
    
    /// <remarks/>
    public int PartnerCount;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool PartnerCountSpecified;
    
    /// <remarks/>
    public int ResourceCount;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ResourceCountSpecified;
    
    /// <remarks/>
    public int ServiceComponentCount;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ServiceComponentCountSpecified;
    
    /// <remarks/>
    public int CategoryCount;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool CategoryCountSpecified;
    
    /// <remarks/>
    public int MEGCount;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool MEGCountSpecified;
}

/// <remarks/>
public class PCTDataExportDetails {
    
    /// <remarks/>
    public string Type;
    
    /// <remarks/>
    public int Version;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool VersionSpecified;
    
    /// <remarks/>
    public string Milestone;
    
    /// <remarks/>
    public string DateTime;
    
    /// <remarks/>
    public string User;
    
    /// <remarks/>
    public string Comment;
    
    /// <remarks/>
    public PCTDataExportDetailsSummary Summary;
    
    /// <remarks/>
    public string Hash;
}

/// <remarks/>
public class PCTDataPartner {
    
    /// <remarks/>
    public string PartnerName;
    
    /// <remarks/>
    public string PartnerUserID;
    
    /// <remarks/>
    public int IsCSR;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool IsCSRSpecified;
    
    /// <remarks/>
    public string ServiceProviderUID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute(DataType="ID")]
    public string PartnerID;
}

/// <remarks/>
public class PCTDataMEGMEGOfferingListMEGOffering {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTextAttribute()]
    public string Value;
}

/// <remarks/>
public class PCTDataMEG {
    
    /// <remarks/>
    public string MEGName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("MEGOffering", typeof(PCTDataMEGMEGOfferingListMEGOffering))]
    public PCTDataMEGMEGOfferingListMEGOffering[] MEGOfferingList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute(DataType="ID")]
    public string MEGID;
}

/// <remarks/>
public class PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaDataConnectorPropertiesProperty {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string name;
}

/// <remarks/>
public class PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaDataConnectorProperties {
    
    /// <remarks/>
    public PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaDataConnectorPropertiesProperty property;
}

/// <remarks/>
public class PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaDataSoapParameters {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
    public string wsdlFile;
}

/// <remarks/>
public class PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaData {
    
    /// <remarks/>
    public System.SByte AccountType;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool AccountTypeSpecified;
    
    /// <remarks/>
    public PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaDataSoapParameters SoapParameters;
    
    /// <remarks/>
    public PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaDataConnectorProperties connectorProperties;
    
    /// <remarks/>
    public string BasicAuthUser;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaDataType Type;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Method;
}

/// <remarks/>
public enum PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaDataType {
    
    /// <remarks/>
    AsyncSoap,
    
    /// <remarks/>
    Hotmail,
}

/// <remarks/>
public class PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttribute {
   
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Environment;

    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("MetaData", IsNullable=false)]
    public PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaData[] MetaDataSet;
}

/// <remarks/>
public class PCTDataServiceComponent {
    
    /// <remarks/>
    public string ServiceComponentName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("ServiceComponentAttribute", typeof(PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttribute))]
    public PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttribute[] ServiceComponentAttributeList;
    
    /// <remarks/>
    public int MaxRoles;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool MaxRolesSpecified;
    
    /// <remarks/>
    public string ServiceClass;
    
    /// <remarks/>
    public int ProvisionDelay;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ProvisionDelaySpecified;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="ID")]
    public string PartnerID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute(DataType="ID")]
    public string ServiceComponentID;
}

/// <remarks/>
public class PCTDataResource {
    
    /// <remarks/>
    public string ResourceName;
    
    /// <remarks/>
    public string ProductType;
    
    /// <remarks/>
    public string ResourceScope;
    
    /// <remarks/>
    public string UnitOfMeasure;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute(DataType="ID")]
    public string ResourceID;
}

/// <remarks/>
public class PCTDataCategoryCategoryOfferingListCategoryOffering {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTextAttribute()]
    public string Value;
}

/// <remarks/>
public class PCTDataCategory {
    
    /// <remarks/>
    public string CategoryName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("CategoryOffering", typeof(PCTDataCategoryCategoryOfferingListCategoryOffering))]
    public PCTDataCategoryCategoryOfferingListCategoryOffering[] CategoryOfferingList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute(DataType="ID")]
    public string CategoryID;
}

/// <remarks/>
public class PCTDataOfferingUDERatingRuleListRatingRule {
    
    /// <remarks/>
    public System.Double Rate;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool RateSpecified;
    
    /// <remarks/>
    public string TaxCode;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="ID")]
    public string Resource1;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="ID")]
    public string Resource2;
    
    /// <remarks/>
    public int CycleStart;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool CycleStartSpecified;
    
    /// <remarks/>
    public int CycleEnd;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool CycleEndSpecified;
    
    /// <remarks/>
    public int ImmediateSettlement;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ImmediateSettlementSpecified;
    
    /// <remarks/>
    public int IgnoreCredit;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool IgnoreCreditSpecified;
    
    /// <remarks/>
    public int CycleUnit;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool CycleUnitSpecified;
    
    /// <remarks/>
    public string RevenueSKU;
    
    /// <remarks/>
    public int ProratePercent;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ProratePercentSpecified;
    
    /// <remarks/>
    public int CycleDay;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool CycleDaySpecified;
    
    /// <remarks/>
    public string Name;
    
    /// <remarks/>
    public int ExecutionOrder;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool ExecutionOrderSpecified;
    
    /// <remarks/>
    public int UseSubscriptionCycles;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool UseSubscriptionCyclesSpecified;
    
    /// <remarks/>
    public int PerUnit;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool PerUnitSpecified;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Type;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute(DataType="ID")]
    public string RatingRuleID;
}

/// <remarks/>
public class PCTDataOfferingUDERatingRuleList {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("RatingRule")]
    public PCTDataOfferingUDERatingRuleListRatingRule[ ] RatingRule;
}

/// <remarks/>
public class PCTDataOfferingUDE {
    
    /// <remarks/>
    public string Name;
    
    /// <remarks/>
    public string Type;
    
    /// <remarks/>
    public PCTDataOfferingUDERatingRuleList RatingRuleList;
}

/// <remarks/>
public class PCTDataOfferingSignUpURLListSignUpURL {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Environment;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTextAttribute()]
    public string Value;
}

/// <remarks/>
public class PCTDataOfferingServiceInstance {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="ID")]
    public string ServiceComponentID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="ID")]
    public string ResourceID;
    
    /// <remarks/>
    public int Count;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool CountSpecified;
}

/// <remarks/>
public class PCTDataOfferingLanguage {
    
    /// <remarks/>
    public string Code;
    
    /// <remarks/>
    public string OfferingDescription;
    
    /// <remarks/>
    public string PriceDescription;
}

/// <remarks/>
public class PCTDataOfferingMigrationPathListMigrationPath {
    
    /// <remarks/>
    public string MigrationType;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="ID")]
    public string TargetID;
    
    /// <remarks/>
    public string InternalMigrationDescription;
}

/// <remarks/>
public class PCTDataOfferingMigrationPathList {
    
    /// <remarks/>
    public PCTDataOfferingMigrationPathListMigrationPath MigrationPath;
}

/// <remarks/>
public class PCTDataOfferingOfferingResourceListOfferingResource {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTextAttribute()]
    public string Value;
}

/// <remarks/>
public class PCTDataOfferingCountryListCountry {
    
    /// <remarks/>
    public string Country;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\waldorf\oldpcf\PCF.cs ===
//
//  PCF.cs
//
//  Waldorf (Billing-Cross-Check) tool
//
//  Ben Zotto (benzotto), September/October 2002
//
//
using System;
using System.IO;
using System.Collections;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions; 
using System.Globalization;                                    
                                     
namespace xonline.tools.billingxcheck.waldorf.oldpcf 
{

    class PCF
    {
            private OfferingModelerData _pcf = null;
            private ArrayList _offers = new ArrayList();
            private ArrayList _svcComponents = new ArrayList();
            
            public ArrayList Offers
            {
                get { return _offers; }
            }
            
            public void LoadFromFile(string filename)
            {
                Stream pcfFile;
                
                Output.WriteVerbose("Opening PCF file " + filename);
                
                try
                {
                    pcfFile = new FileStream(filename, FileMode.Open);                                       
                }
                catch
                {
                    throw new InvalidUsageException("Cannot open file " + filename + "!");
                }
                
                XmlSerializer xs = new XmlSerializer(typeof(OfferingModelerData));
                _pcf = (OfferingModelerData)xs.Deserialize(pcfFile);
                
                GetHierarchical();
                Output.WriteVerbose("Loaded " + _offers.Count + " offers and " + _svcComponents.Count + " service components.");                                                
            
                Output.WriteVerbose("PCF data loaded successfully.");
            }
                        
            //
            //  Looks at PCF data in a vacuum and ensures that some basic stuff looks OK.
            //  This method encapsulates some business logic, so if the requirements of PCF
            //  files change, this section should change accordingly.
            //            
            public int BaselineVerify(XboxLive env)
            {
                int errorCount = 0;
                string wsdlExpected = "";
                
                switch(env.Environment)
                {
                    case XboxLive.DEVNET:
                        wsdlExpected = "https://192.168.86.203/xcbk/sprov.asmx?wsdl";
                        break;
                    case XboxLive.TESTNET:
                        wsdlExpected = "https://192.168.86.203/xcbk/sprov.asmx?wsdl";
                        break;
                    case XboxLive.PARTNERNET:
                        wsdlExpected = "https://131.107.228.179/xcbk/sprov.asmx?wsdl";
                        break;
                    case XboxLive.BETANET:
                        wsdlExpected = "https://131.107.58.67/xcbk/sprov.asmx?wsdl";
                        break;
                    case XboxLive.PREPROD:
                        wsdlExpected = "https://131.107.58.67/xcbk/sprov.asmx?wsdl";
                        break;
                    case XboxLive.PRODUCTION:
                        wsdlExpected = "https://207.46.247.190/xcbk/sprov.asmx?wsdl";
                        break;
                    default:
                        throw new Exception("Must use a valid Xbox Live environment!");                    
                }
                
               
                foreach(PCFServiceComponent component in _svcComponents)
                {
                    //
                    // Make sure WSDLs are right.
                    //
                    
                    // WSDL location
                
                    foreach(OfferingModelerDataServiceComponentServiceComponentAttributesMetaData metadata in component._sc.ServiceComponentAttributes.MetaDataSet)
                    {
                        string wsdl = metadata.SoapParameters.wsdlFile;
                        
                        if(wsdl != wsdlExpected)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Bad Service Provider URL for component " + component._sc.ServiceComponentName.Trim());
                            Output.WriteVerbose("\texpected = " + wsdlExpected + "\n\tactual   = " + wsdl);                            
                        }                                                
                    }
                    
                    // Provision delay
                    
                    if(component._sc.ProvisionDelay != false)
                    {
                        errorCount++;
                        Output.WriteLine("WARNING: Suspicious ProvisionDelay (TRUE) for " + component._sc.ServiceComponentName.Trim());    
                    }
                    
                }

                
                foreach(PCFOffer po in _offers)
                {
                    //
                    // Check basic offer stuff
                    //
                    if(po._offer.BaseOffering != true)
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: Offering " + po._offer.OfferingID + " is not configured as a BaseOffering!");
                        Output.WriteVerbose("\t(" + po._offer.InternalOfferingDescription.Trim() + ")");
                    }
                                 
                    if(po._offer.CycleForward != true)
                    {
                        errorCount++;
                        Output.WriteLine("WARNING: Offering " + po._offer.OfferingID + " is not set to cycle forward!");
                        Output.WriteVerbose("\t(" + po._offer.InternalOfferingDescription.Trim() + ")");                                        
                    }    
                                       
                    if(po._serviceInstances.Length > 1)
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: Offering " + po._offeringID + " has " + po._serviceInstances.Length + " service components!");
                        Output.WriteVerbose("\t(expect no more than 1 service component per offer)"); 
                    }
                    
                    foreach(OfferingModelerDataUDE ude in po._udes)
                    {
                        if(ude.Type != "PurchaseSubscription" && ude.Type != "Subscription_Cycle")
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Offering " + ude.OfferingID + " has unexpected UDE type!");
                            Output.WriteVerbose("\tactual = " + ude.Type);                         
                        }
                        
                        if(ude.Type == "Subscription_Cycle")
                        {
                            foreach(OfferingModelerDataRatingRule rule in po._ratingRules)
                            {
                                if(ude.UDEID == rule.UDEID)
                                {
                                    po._duration = rule.CycleEnd - rule.CycleStart;    
                                }
                            }
                        }

                    }
                    
                    string thisOPD = null;    
                    foreach(OfferingModelerDataLanguage language in po._languages)
                    {
                       
                        if(language.Code == "en-US")
                        {
                            po._hasUSEnglish = true;
                        
                            if(thisOPD == null)
                            {                         
                                thisOPD = language.PriceDescription;
                                int r = po.ParseOfferingPriceDescription(language.PriceDescription);
                                if(r == 0) { continue; }
                                    
                                errorCount++;
                                thisOPD = null;
                                switch(r)
                                {
                                case -1:
                                    Output.WriteLine("FAIL: Cannot parse Offering Price Description for " + language.OfferingID + " locale " + language.Code);
                                    break;
                                case 0:
                                    break;
                                default:
                                    Output.WriteLine("FAIL: Cannot parse field " + r + " of OPD for offering " + language.OfferingID + " locale " + language.Code);
                                    break;
                                }
                                Output.WriteVerbose("\topd = " + language.PriceDescription);                                                                        
                            }
                        }
                    }
                        
                    if(po._hasUSEnglish != true)
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: No en-US locale on offer " + po._offeringID);
                    }
                    
                    foreach(OfferingModelerDataPaymentInstrumentList payinfolist in po._payInfoList)
                    {
                        if(payinfolist.PaymentInstrument != "CREDITCARD")
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Offering " + payinfolist.OfferingID + " doesn't accept CREDITCARD");
                            Output.WriteVerbose("\tactual set for= " + payinfolist.PaymentInstrument);                                             
                        }
                    }
                    
                    foreach(OfferingModelerDataPartnerOffering partneroffering in po._partnerOfferings)
                    {
                        if(partneroffering.PartnerID != "ecc7b465-3064-4e85-8d79-b4c84a5b27fe")
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Offering " + partneroffering.OfferingID + " not for Xbox Live!");
                            Output.WriteVerbose("\tBad partner ID= " + partneroffering.PartnerID);                                                                     
                        }
                    }
                
                
                }   // end loop over each offer
                

                return errorCount;                
            }
            
            
            public int OfferPerTypeVerify()
            {
                int errorCount = 0;
            
                //
                // Check thru all offers for per-offer data
                // TODO: revenue SKUs?
                //   

                foreach(PCFOffer o in _offers)
                {
                    if(o.opdOfferType == null || o.opdOfferType == "")
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: Cannot typecheck offer " + o._offeringID + " because it has no valid OPD.");
                        continue;
                    }
                    
                    if(o.opdOfferType == "basic subscription")
                    {
                        if(o._duration > 15 && o._duration < 9000)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Base sub " + o._offeringID + " has invalid (> 15 duration!"); 
                        }
                        
                        if(o.opdISOCurrency != o._offer.Currency)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Base sub " + o._offeringID + " has mismatched currency!"); 
                            Output.WriteVerbose("\tOPD says: " + o.opdISOCurrency + ", actual: " + o._offer.Currency);                           
                        }
                        
                        
                        if(o.isFree == false)
                        {   
                            if(o._offer.ImmediateSettlement != true)
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Non-free base sub " + o._offeringID + " not immediately settled!");
                            }
                        }
                        
                        //
                        // make sure price matches
                        //
                            
                        foreach(OfferingModelerDataRatingRule rule in o._ratingRules)
                        {
                            if(o.isFree == true)
                            {
                                if(rule.Rate != 0)
                                {
                                    errorCount++;
                                    Output.WriteLine("FAIL: Base sub " + o._offeringID + " should be free in PCF!!");
                                    Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate);
                                }
                            }
                            else
                            {
                                // Yen seem to be a special case where there is no decimal part at all in the rate
                                //                                
                                if(o.opdISOCurrency == "JPY")
                                {
                                    if(o.opdPriceWhole != rule.Rate)
                                    {   
                                        errorCount++;
                                        Output.WriteLine("FAIL: Base sub " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole);
                                    }
                                }
                                else
                                {
                                    if(o.opdPriceWhole != (int)(rule.Rate / 100) || o.opdPriceFractional != (int)(rule.Rate % 100))
                                    {   
                                        errorCount++;
                                        Output.WriteLine("FAIL: Base sub " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole + o.opdPriceFractional.ToString());
                                    }                                    
                                }
                            }
                            
                            
                            if(o.opdNumberFreeMonths != (rule.CycleStart - 1))
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Base sub " + o._offeringID + " has incorrect free period");
                                Output.WriteVerbose("\tSPS cycles: " + rule.CycleStart + "-" + rule.CycleEnd + " / expect: " + o.opdNumberFreeMonths );                                    
                            }
                       
                        }
                        


                        if(o._offer.MaxOwnership != false)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Base sub " + o._offeringID + " max ownership nonzero!");
                        }

                        if(o._offer.GracePeriod != 30)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Base sub " + o._offeringID + " grace period not = 30!");
                            Output.WriteVerbose("\tactual grace period = " + o._offer.GracePeriod);
                        }

                        if(o._offer.SuppressEmailOnRenew != false)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Base sub " + o._offeringID + " not suppressing email renewal!");
                        }
                                                
                        if(o._serviceInstances.Length != 1)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Expect exactly one service component for base sub " + o._offeringID );
                        }
                        

                        
                    }
                                                                 
                    if(o.opdOfferType == "premium subscription")
                    {
                        if(o._duration > 15 && o._duration < 9000)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Prem sub " + o._offeringID + " has invalid (> 15 duration!"); 
                        }
                                                
                        if(o.opdISOCurrency != o._offer.Currency)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Prem sub " + o._offeringID + " has mismatched currency!"); 
                            Output.WriteVerbose("\tOPD says: " + o.opdISOCurrency + ", actual: " + o._offer.Currency);                           
                        }
                        
                                                //
                        // make sure price matches
                        //
                            
                        foreach(OfferingModelerDataRatingRule rule in o._ratingRules)
                        {
                            if(o.isFree == true)
                            {
                                if(rule.Rate != 0)
                                {
                                    errorCount++;
                                    Output.WriteLine("FAIL: Prem sub " + o._offeringID + " should be free in PCF!!");
                                    Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate);
                                }
                            }
                            else
                            {
                                // Yen seem to be a special case where there is no decimal part at all in the rate
                                //                                
                                if(o.opdISOCurrency == "JPY")
                                {
                                    if(o.opdPriceWhole != rule.Rate)
                                    {   
                                        errorCount++;
                                        Output.WriteLine("FAIL: Prem sub " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole);
                                    }
                                }
                                else
                                {
                                    if(o.opdPriceWhole != (int)(rule.Rate / 100) || o.opdPriceFractional != (int)(rule.Rate % 100))
                                    {   
                                        errorCount++;
                                        Output.WriteLine("FAIL: Prem sub " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole + o.opdPriceFractional.ToString());
                                    }                                    
                                }
                            }
                            
                            if(o.opdNumberFreeMonths != (rule.CycleStart - 1))
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Prem sub " + o._offeringID + " has incorrect free period");
                                Output.WriteVerbose("\tSPS cycles: " + rule.CycleStart + "-" + rule.CycleEnd + " / expect: " + o.opdNumberFreeMonths );                                    
                            }

                        }

                    
                        if(o.isFree == false)
                        {   
                            if(o._offer.ImmediateSettlement != true)
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Non-free prem sub " + o._offeringID + " not immediately settled!");
                            }
                        }

                        if(o._offer.MaxOwnership != false)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Prem sub " + o._offeringID + " max ownership nonzero!");
                        }

                        if(o._offer.GracePeriod != 30)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Prem sub " + o._offeringID + " grace period not = 30!");
                            Output.WriteVerbose("\tactual grace period = " + o._offer.GracePeriod );
                        }

                        if(o._offer.SuppressEmailOnRenew != false)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Prem sub " + o._offeringID + " not suppressing email renewal!");
                        }
                                                
                        if(o._serviceInstances.Length != 1)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Expect exactly one service component for prem sub " + o._offeringID );
                        }
                                                        
                    }

                    if(o.opdOfferType == "premium content")
                    {
                        if(o._duration != 0 || (o._duration > 0 && o._duration < 9000))
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Content " + o._offeringID + " has invalid duration!"); 
                        }
                                                
                        if(o.opdISOCurrency != o._offer.Currency)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Content " + o._offeringID + " has mismatched currency!"); 
                            Output.WriteVerbose("\tOPD says: " + o.opdISOCurrency + ", actual: " + o._offer.Currency);                           
                        }                        

                        //
                        // make sure price matches
                        //
                            
                        foreach(OfferingModelerDataRatingRule rule in o._ratingRules)
                        {
                            if(o.isFree == true)
                            {
                                if(rule.Rate != 0)
                                {
                                    errorCount++;
                                    Output.WriteLine("FAIL: Content " + o._offeringID + " should be free in PCF!!");
                                    Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate);
                                }
                            }
                            else
                            {
                                // Yen seem to be a special case where there is no decimal part at all in the rate
                                //                                
                                if(o.opdISOCurrency == "JPY")
                                {
                                    if(o.opdPriceWhole != rule.Rate)
                                    {   
                                        errorCount++;
                                        Output.WriteLine("FAIL: Content " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole);
                                    }
                                }
                                else
                                {
                                    if(o.opdPriceWhole != (int)(rule.Rate / 100) || o.opdPriceFractional != (int)(rule.Rate % 100))
                                    {   
                                        errorCount++;
                                        Output.WriteLine("FAIL: Content " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole + o.opdPriceFractional.ToString());
                                    }                                    
                                }
                            }
                            
                            if(o.opdNumberFreeMonths != 0 || rule.CycleStart != 1)
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Content " + o._offeringID + " has incorrect free period");
                                Output.WriteVerbose("\tSPS cycles: " + rule.CycleStart + "-" + rule.CycleEnd + " / expect: " + o.opdNumberFreeMonths );                                    
                            }

                        }

                        
                        if(o.isFree == false)
                        {   
                            if(o._offer.ImmediateSettlement != true)
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Non-free content " + o._offeringID + " not immediately settled!");
                            }
                        }

                        if(o._offer.MaxOwnership != false)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Content " + o._offeringID + " max ownership nonzero!");
                        }

                        if(o._offer.GracePeriod != 0)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Content " + o._offeringID + " grace period not = 0!");
                            Output.WriteVerbose("\tactual grace period = " + o._offer.GracePeriod );
                        }

                        if(o._offer.SuppressEmailOnRenew != true)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Content " + o._offeringID + " is suppressing email renewal!");
                        }
                        
                        if(o._serviceInstances.Length != 0)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Expect ZERO service components for offer " + o._offeringID );
                        }
                        
                        foreach(OfferingModelerDataUDE ude in o._udes)
                        {
                            if(ude.Type != "PurchaseSubscription")
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Offering " + o._offeringID + " has unexpected UDE type!");
                                Output.WriteVerbose("\tactual = " + ude.Type);                         
                            }
                        }
                                                        
                    }

                }

                                            
                return errorCount;
            }
           
            
            private void GetHierarchical()
            {
                PCFOffer po;
                foreach(OfferingModelerDataOffering offer in _pcf.Offering)
                {
                    po = new PCFOffer();
                    if(offer.OfferingName.StartsWith("XBX") == false)
                    {
                        Output.WriteVerbose("IGNORING: Offer " + offer.OfferingName);
                    }
                    else 
                    {
                        po.LoadFromPCF(offer, _pcf);
                        _offers.Add(po);    
                    }
                }
                
                PCFServiceComponent psc;
                foreach(OfferingModelerDataPartnerServiceComponent pasc in _pcf.PartnerServiceComponent)
                {
                    if(pasc.PartnerID == "ecc7b465-3064-4e85-8d79-b4c84a5b27fe")                     
                    {
                        psc = new PCFServiceComponent();
                        psc.LoadFromPCF(pasc.ServiceComponentID, _pcf);
                        _svcComponents.Add(psc);
                    }
                }

            }
            
                
            public void TempDumpOffers()
            {
                       
                Output.WriteLine("*** This PCF file contains the following offers: ");
                foreach(OfferingModelerDataOffering offer in _pcf.Offering)
                {
                    Output.WriteLine("    " + offer.InternalOfferingDescription.Trim());
                }
                            
            }
            
            public class PCFServiceComponent
            {
                string _SCID;
                
                //
                // PCF native types
                //
                public OfferingModelerDataServiceComponent  _sc;
                
                // load em up
                public void LoadFromPCF(string componentID, OfferingModelerData pcf)
                {
                    _SCID = componentID;
                    
                    // get each field
                    foreach(OfferingModelerDataServiceComponent sc in pcf.ServiceComponent)
                    {
                        if(sc.ServiceComponentID == componentID)
                        {
                            _sc = sc;   
                        }
                    }
                }    
            }
            
            public class PCFOffer
            {
                public string _offeringID = null;
                public bool   _hasUSEnglish = false;                
                //
                // PCF native types
                //
                public OfferingModelerDataOffering          _offer;
                public OfferingModelerDataServiceInstance[] _serviceInstances;
                public OfferingModelerDataUDE[]             _udes;
                public OfferingModelerDataRatingRule[]      _ratingRules;
                public OfferingModelerDataLanguage[]        _languages;
                public OfferingModelerDataPaymentInstrumentList[] _payInfoList;
                public OfferingModelerDataPartnerOffering[] _partnerOfferings;
                public OfferingModelerDataCountryList[]     _countries;
                public int                                  _duration;
                
                
                //
                // OPD fields
                //
                public string Opd;
                public bool   opdParsedOK = false;
                public string opdOfferType;
                public string opdOfferFriendlyName;
                public string opdPrice;
                public string opdTax;
                public string opdRecurrence;
                public string opdFreeTrial;
                public int    opdPriceWhole;
                public int    opdPriceFractional;
                public int    opdNumberFreeMonths;
                public string opdISOCurrency;
                
                public bool   isFree = false;                
                
                // load em up
                public void LoadFromPCF(OfferingModelerDataOffering o, OfferingModelerData pcf)
                {
                    _offer = o;
                    _offeringID = o.OfferingID;
                    ArrayList al;
                    ArrayList rrs;
                    
                    // get each field
                    al = new ArrayList();
                    foreach(OfferingModelerDataServiceInstance instance in pcf.ServiceInstance)
                    {
                        if(instance.OfferingID == _offeringID)
                        {
                            al.Add(instance);    
                        }
                    }
                    _serviceInstances = (OfferingModelerDataServiceInstance[])al.ToArray(Type.GetType("OfferingModelerDataServiceInstance"));
                    
                    al.Clear();
                    rrs = new ArrayList();
                    foreach(OfferingModelerDataUDE ude in pcf.UDE)
                    {
                        if(ude.OfferingID == _offeringID)
                        {
                            al.Add(ude);
                            foreach(OfferingModelerDataRatingRule rrule in pcf.RatingRule)
                            {
                                if(rrule.UDEID == ude.UDEID)
                                {
                                    rrs.Add(rrule);
                                }
                            }
                        }
                    }
                    _udes = (OfferingModelerDataUDE[])al.ToArray(Type.GetType("OfferingModelerDataUDE"));
                    _ratingRules = (OfferingModelerDataRatingRule[])rrs.ToArray(Type.GetType("OfferingModelerDataRatingRule"));
                    
                    al.Clear();
                    foreach(OfferingModelerDataLanguage lang in pcf.Language)
                    {   
                        if(lang.OfferingID == _offeringID)
                        {
                            al.Add(lang);
                        }                          
                    }
                    _languages = (OfferingModelerDataLanguage[])al.ToArray(Type.GetType("OfferingModelerDataLanguage"));
                    
                    al.Clear();
                    foreach(OfferingModelerDataPaymentInstrumentList payinfolist in pcf.PaymentInstrumentList)
                    {   
                        if(payinfolist.OfferingID == _offeringID)
                        {
                            al.Add(payinfolist);
                        }                          
                    }
                    _payInfoList = (OfferingModelerDataPaymentInstrumentList[])al.ToArray(Type.GetType("OfferingModelerDataPaymentInstrumentList"));

                    al.Clear();
                    foreach(OfferingModelerDataPartnerOffering partneroffering in pcf.PartnerOffering)
                    {   
                        if(partneroffering.OfferingID == _offeringID)
                        {
                            al.Add(partneroffering);
                        }                          
                    }
                    _partnerOfferings = (OfferingModelerDataPartnerOffering[])al.ToArray(Type.GetType("OfferingModelerDataPartnerOffering"));                    
                                                               
                    al.Clear();
                    foreach(OfferingModelerDataCountryList countrylist in pcf.CountryList)
                    {   
                        if(countrylist.OfferingID == _offeringID)
                        {
                            al.Add(countrylist);
                        }                          
                    }
                    _countries = (OfferingModelerDataCountryList[])al.ToArray(Type.GetType("OfferingModelerDataCountryList"));                    
                                                               
                }
              
                
                
                public int ParseOfferingPriceDescription(string opd)
                {
                    string[] opdFields;
                    try
                    {
                        opdFields = opd.Split(new char[] {'|'});
                    } 
                    catch
                    {
                        return -1;
                    }
                    
                    if(opdFields.Length != 6)
                    {
                        //
                        // overall parse problem
                        //
                        return -1;                           
                    }
                    
                    Opd                     = opd.Trim();;
                    opdOfferType            = opdFields[0].Trim().ToLower();
                    opdOfferFriendlyName    = opdFields[1].Trim();
                    opdPrice                = opdFields[2].Trim();
                    opdTax                  = opdFields[3].Trim().ToLower();
                    opdRecurrence           = opdFields[4].Trim().ToLower();
                    opdFreeTrial            = opdFields[5].Trim();
                    
                    if(opdOfferType != "basic subscription" && opdOfferType != "premium subscription" && opdOfferType != "premium content")
                    {
                        return 1;
                    }
                    
                    if(opdOfferFriendlyName == null || opdOfferFriendlyName == "")
                    {
                        return 2;
                    }
                    
                    if(opdPrice == null || opdPrice == "" || ParsePrice(opdPrice) != true)
                    {
                        return 3;
                    }
                    
                    if(opdTax != "plus applicable taxes" && opdTax != "vat included")
                    {
                        return 4;                        
                    }
                    
                    if(opdRecurrence != "" && (opdRecurrence != "monthly" && opdRecurrence != "yearly"))
                    {   
                        return 5;
                    }
                    
                    if(opdFreeTrial == null || opdFreeTrial == "")
                    {
                        opdNumberFreeMonths = 0;
                    }
                    else
                    {
                        try
                        {
                            opdNumberFreeMonths = Convert.ToInt32(opdFreeTrial);
                        }
                        catch
                        {
                            return 6;
                        }
                    }
                    
                    if(opdNumberFreeMonths > 15)
                    {
                        return 6;
                    }
                    

                    //
                    //  all OK, return.
                    //              
                    opdParsedOK = true;               
                    return 0;                    
                    
                }
                
                //
                // assumes en-US formatting
                //            
                // UPDATE ME FOR FURTHER CURRENCIES!!
                //    
                private bool ParsePrice(string p)
                {
                    int n = 0;
                    string[] fields;
                    string cursym;
                    string jpy = Char.ToString(Convert.ToChar(0x00A5));
                    string gbp = Char.ToString(Convert.ToChar(0x00A3));
                    string eur = Char.ToString(Convert.ToChar(0x20AC));
                    

                    try
                    {
                        fields = p.Substring(n).Split(new char[] {' '});
                        
                        cursym = fields[0].Substring(0,1);
                        if(cursym == "$")
                        {
                            if(fields.Length == 2 && fields[1] == "CAD")
                            {
                                //
                                // There's a CAD differentiator here
                                //
                                opdISOCurrency = "CAD";
                            }
                            else
                            {
                                opdISOCurrency = "USD";
                            }
                        }
                        else if(cursym == jpy)
                        {
                            opdISOCurrency = "JPY";
                        }
                        else if(cursym == gbp)
                        {
                            opdISOCurrency = "GBP";
                        }
                        else if(cursym == eur)
                        {
                            opdISOCurrency = "EUR";
                        }
                        else
                        {
                            Output.WriteDebug("BAD CURRENCY MARKER: " + Convert.ToUInt16(Char.Parse(cursym)).ToString("x"));
                            return false;
                        }        
    
                        if(opdISOCurrency == "JPY")
                        {
                            opdPriceWhole = int.Parse(fields[0].Substring(1,fields[0].Length-1));
                            opdPriceFractional = 0;
                        }
                        else
                        {   
                            opdPriceWhole = int.Parse(fields[0].Substring(1, fields[0].Length-4));
                            opdPriceFractional = int.Parse(fields[0].Substring(fields[0].Length-2, 2));    
                        }
                    }
                    catch
                    {                    
                        return false;   
                    }
     
                    if(opdPriceFractional > 99 || opdISOCurrency.Length != 3)
                    {
                        return false;
                    }
                    
                    if(opdPriceWhole == 0 && opdPriceFractional == 0)
                    {
                        isFree = true;
                    }

                    return true;                                                         
                }
                
                
            }
            
           
                                           
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\Country.cs ===
using System;
using System.Collections;
using System.IO;

namespace xonline.tools.bountyhunter 
{
    /// <summary>
    /// Instances of this class keep information about users for a particular country.
    /// Instances of this class are contained within instances of the Title class.
    /// </summary>
    public class Country
    {
        private string _name;
        private int _id;
        private Hashtable _users;

        public Country(int id, string name)
        {
            _name = name;
            _id = id;
            _users = new Hashtable();
        }

        /// <summary>
        /// Copy constructor.  Note, this constructor does not copy the users.
        /// </summary>
        /// <param name="c">Country object to copy.</param>
        public Country(Country c)
        {
            _name = c.Name;
            _id = c.ID;
            _users = new Hashtable();
        }

        /// <summary>
        /// Add a user to this country.
        /// </summary>
        /// <param name="u">User to add.</param>
        public void AddUser(User u)
        {
            if(u.Country != this._id)
                throw new ArgumentException("Country of user being added does not match country being added to.");

            _users.Add(u.PUID, u);
        }

        /// <summary>
        /// Write country information and all contained users using the
        /// provided TextWriter object.
        /// </summary>
        /// <param name="tw">TextWriter object to use to write info out.</param>
        /// <param name="verbose">Write individual users?</param>
        public void Write(TextWriter tw, bool verbose)
        {
            if (_users.Count != 0)
            {
                tw.WriteLine(",," + _name + "," + _users.Count.ToString());
                if (verbose)
                {
                    foreach(DictionaryEntry entry in _users)
                    {
                        User user = (User)entry.Value;
                        user.Write(tw);
                    } //displaying users

                    tw.WriteLine("");
                } //only display users if verbose
            }
        }

        /// <summary>
        /// Retrieve country name
        /// </summary>
        public string Name
        {
            get{ return _name; }
        }

        /// <summary>
        /// Retrieve numeric country id
        /// </summary>
        public int ID
        {
            get{ return _id; }
        }

        public int NumUsers
        {
            get{ return _users.Count; }
        }
    }

} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\BountyHunterApp.cs ===
using System;
using System.Collections;
using System.IO;
using System.Data.SqlClient;
using xonline.common.tools.console;

namespace xonline.tools.bountyhunter 
{
    /// <summary>
    /// Console/command line wrapper for the BountyHunter class.
    /// </summary>
    public class BountyHunterApp
    {
        /// <summary>
        /// Write BountyHunter command line help to the console.
        /// </summary>
        private static void Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("BountyHunter.exe /start:<start date> /end:<end date> /server:<server> /db:<db> [/verbose]");
            Console.WriteLine("BountyHunter.exe /week:<start date> /server:<server> /db:<db> [/verbose]");
            Console.WriteLine("BountyHunter.exe /month:<month start> /server:<server> /db:<db> [/verbose]");
            Console.WriteLine("Date formats for <start date> and <end date> are YYYY-MM-DD");
            Console.WriteLine("Date format for <month start> is YYYY-MM");
            Console.WriteLine("<start date> and <month start> are inclusive, <end date> is exclusive.");
            Console.WriteLine("<end date> is internally computed for /week (<start date> + 7 days) and /month");
            Console.WriteLine("(<month start> + 1 month).");
            Console.WriteLine("Adding the /verbose option will cause individual gamertags to be listed");
            Console.WriteLine("in the report.");
        }

        /// <summary>
        /// Main entry point for BountyHunter.exe.
        /// </summary>
        /// <param name="rawArgs"></param>
        /// <returns></returns>
        public static int Main(string []rawArgs)
        {
            StreamWriter outStream = null;
            string connstr;
            bool verbose;

            try
            {
                //
                // Parse command line parameters
                //

                string [] tags = {
                                     "start",
                                     "end",
                                     "month",
                                     "week",
                                     "verbose",
                                     "db",
                                     "server"
                                 };

                NamedArgParser args = new NamedArgParser(tags);

                args.Parse(rawArgs);

                //
                //  Validate parameters
                //

                if (args == null || 
                    args["server"] == null || 
                    args["db"] == null) 
                { 
                    Usage(); 
                    return 1; 
                }

                if (args["month"] == null && 
                    args["week"] == null && 
                    (args["start"] == null || args["end"] == null)) 
                { 
                    Usage(); 
                    return 1; 
                }

                connstr = "Server=" + args["server"] + ";Database=" + args["db"] + ";Integrated Security=true";
                verbose = (args["verbose"] != null);

                //
                // Compute date ranges
                //

                DateTime startdate;
                DateTime enddate;

                string filenamePrefix;

                if(args["month"] != null)
                {
                    if(args["week"] != null || args["start"] != null || args["end"] != null)
                    {
                        Usage();
                        return 1;
                    }

                    try
                    {
                        startdate = DateTime.ParseExact(args["month"], "yyyy-M", null);
                    }
                    catch(FormatException)
                    {
                        Console.Write("\nError:  Invalid date format.\n\n");
                        Usage();
                        return 1;
                    }

                    enddate = startdate.AddDays(DateTime.DaysInMonth(startdate.Year, startdate.Month) - 1);
                    filenamePrefix = "MONTH-";
                }
                else if(args["week"] != null)
                {
                    if(args["start"] != null || args["end"] != null)
                    {
                        Usage();
                        return 1;
                    }

                    try
                    {
                        startdate = DateTime.Parse(args["week"]);
                    }
                    catch(FormatException)
                    {
                        Console.Write("\nError:  Invalid date format.\n\n");
                        Usage();
                        return 1;
                    }

                    enddate = startdate.AddDays(6);
                    filenamePrefix = "WEEK-";
                }
                else
                {
                    try
                    {
                        startdate = DateTime.Parse(args["start"]);
                        enddate = DateTime.Parse(args["end"]);
                    }
                    catch(FormatException)
                    {
                        Console.Write("\nError:  Invalid date format.\n\n");
                        Usage();
                        return 1;
                    }

                    filenamePrefix = "BOUNTY-";
                }

                if (startdate > enddate)
                {
                    Console.Write("Error: The start date occurs after the end date.\n\n");
                    Usage();
                    return 1;
                }

                //
                //  Generate date/time based output file name, and then open the file.
                //

                string outFileName = 
                    Path.Combine(Environment.CurrentDirectory, 
                    filenamePrefix + 
                    startdate.ToString("yyyyMMdd") + "-" + 
                    enddate.ToString("yyyyMMdd") + 
                    (verbose ? "V" : "") +
                    ".csv");

                outStream = File.CreateText(outFileName);

                //
                // Create bounty output
                //

                BountyHunter bh = new BountyHunter(connstr);
                bh.GetBountyInfo(startdate, enddate);
                Write(bh, outStream, verbose);

                Console.WriteLine("The report {0} was created successfully.", outFileName);

            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
            finally
            {
                if (null != outStream)
                {
                    outStream.Close();
                }
            }

            return 0;
        }

        /// <summary>
        /// This method takes a BountyHunter object that has already been
        /// populated with information and writes it out to a stream.
        /// </summary>
        /// <param name="bh">BountyHunter object that has been loaded with information in the specified date range.</param>
        /// <param name="tw">TextWriter that is used to write the output.</param>
        /// <param name="verbose">Write out individual gamertags?</param>
        private static void Write(BountyHunter bh, TextWriter tw, bool verbose)
        {
            //
            // Column headers
            //

            tw.WriteLine("Title,TitleID,Country,Users" + (verbose ? ",GamerTag,PUID" : ""));

            //
            // This prints out the info in a very readable format
            //

            bh.Write(tw, verbose);

        } //display info
    } //class
} //namespace

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\waldorf\oldpcf\PCFSchema.cs ===
﻿//------------------------------------------------------------------------------
// Generated by xsd.exe, edited by benzotto to conform to actual PCF formats
//------------------------------------------------------------------------------

using System.Xml.Serialization;


/// <remarks/>
[System.Xml.Serialization.XmlRootAttribute(Namespace="", IsNullable=false)]
public class OfferingModelerData {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Offering")]
    public OfferingModelerDataOffering[] Offering;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Category")]
    public OfferingModelerDataCategory[] Category;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Resource")]
    public OfferingModelerDataResource[] Resource;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ServiceComponent")]
    public OfferingModelerDataServiceComponent[] ServiceComponent;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("OfferingResources")]
    public OfferingModelerDataOfferingResources[] OfferingResources;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ServiceInstance")]
    public OfferingModelerDataServiceInstance[] ServiceInstance;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("CategoryOfferings")]
    public OfferingModelerDataCategoryOfferings[] CategoryOfferings;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("UDE")]
    public OfferingModelerDataUDE[] UDE;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("RatingRule")]
    public OfferingModelerDataRatingRule[] RatingRule;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("MEG")]
    public OfferingModelerDataMEG[] MEG;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("MEGOfferings")]
    public OfferingModelerDataMEGOfferings[] MEGOfferings;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("CountryList")]
    public OfferingModelerDataCountryList[] CountryList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Language")]
    public OfferingModelerDataLanguage[] Language;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Partner")]
    public OfferingModelerDataPartner[] Partner;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("PaymentInstrumentList")]
    public OfferingModelerDataPaymentInstrumentList[] PaymentInstrumentList;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("MigrationPath")]
    public OfferingModelerDataMigrationPath[] MigrationPath;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("PartnerOffering")]
    public OfferingModelerDataPartnerOffering[] PartnerOffering;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("PartnerServiceComponent")]
    public OfferingModelerDataPartnerServiceComponent[] PartnerServiceComponent;
    
    /// <remarks/>
    public OfferingModelerDataExportDetails ExportDetails;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ServiceClass")]
    public ServiceClassType[] ServiceClass;
}

/// <remarks/>
public class OfferingModelerDataOffering {
    
    /// <remarks/>
    public string OfferingName;
    
    /// <remarks/>
    public string OfferingCreationDate;
    
    /// <remarks/>
    public string Currency;
    
    /// <remarks/>
    public int OfferingStatus;
    
    /// <remarks/>
    public string OfferingModifiedDate;
    
    /// <remarks/>
    public string RevenueSKU;
    
    /// <remarks/>
    public string DesignID;
    
    /// <remarks/>
    public bool OfferingVersion;
    
    /// <remarks/>
    public bool OfferingAlwaysValid;
    
    /// <remarks/>
    public string StartDate;
    
    /// <remarks/>
    public string EndDate;
    
    /// <remarks/>
    public bool ImmediateSettlement;
    
    /// <remarks/>
    public System.SByte MaxOwnershipType;
    
    /// <remarks/>
    public bool MaxOwnership;
    
    /// <remarks/>
    public System.SByte GracePeriod;
    
    /// <remarks/>
    public bool BaseOffering;
    
    /// <remarks/>
    public short SubscriptionDuration;
    
    /// <remarks/>
    public bool SubscriptionDurationType;
    
    /// <remarks/>
    public bool MSNIAOffering;
    
    /// <remarks/>
    public string InternalOfferingDescription;
    
    /// <remarks/>
    public string AutoRenewTarget;
    
    /// <remarks/>
    public OfferingModelerDataOfferingOfferingTermLocation OfferingTermLocation;
    
    /// <remarks/>
    public string CommitmentTerms;
    
    /// <remarks/>
    public bool ActivateOnPurchase;
    
    /// <remarks/>
    public bool CycleForward;
    
    /// <remarks/>
    public bool Obsolete;
    
    /// <remarks/>
    public string SignUpURL;
    
    /// <remarks/>
    public System.SByte TermCommit;
    
    /// <remarks/>
    public bool VariableCharges;
    
    /// <remarks/>
    public bool AllowNoPaymentInstrument;
    
    /// <remarks/>
    public bool SuppressEmailOnRenew;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string OfferingID;
}


/// <remarks/>
public class OfferingModelerDataOfferingOfferingTermLocation {
}

/// <remarks/>
public class OfferingModelerDataExportDetails {
    
    /// <remarks/>
    public bool Exported;
    
    /// <remarks/>
    public string Environment;
}

/// <remarks/>
public class OfferingModelerDataPartnerServiceComponent {
    
    /// <remarks/>
    public string PartnerID;
    
    /// <remarks/>
    public string ServiceComponentID;
}

/// <remarks/>
public class OfferingModelerDataPartnerOffering {
    
    /// <remarks/>
    public string PartnerID;
    
    /// <remarks/>
    public string OfferingID;
}

/// <remarks/>
public class OfferingModelerDataMigrationPath {
    
    /// <remarks/>
    public string OfferingID;
    
    /// <remarks/>
    public string MigrationType;
    
    /// <remarks/>
    public string TargetID;
    
    /// <remarks/>
    public string DesignID;
    
    /// <remarks/>
    public string InternalMigrationDescription;
}

/// <remarks/>
public class OfferingModelerDataPaymentInstrumentList {
    
    /// <remarks/>
    public string PaymentInstrument;
    
    /// <remarks/>
    public string OfferingID;
    
    /// <remarks/>
    public string DesignID;
}

/// <remarks/>
public class OfferingModelerDataPartner {
    
    /// <remarks/>
    public string PartnerName;
    
    /// <remarks/>
    public string PartnerUserID;
    
    /// <remarks/>
    public bool IsCSR;
    
    /// <remarks/>
    public int Status;
    
    /// <remarks/>
    public string ServiceProviderUID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string PartnerID;
}

/// <remarks/>
public class OfferingModelerDataLanguage {
    
    /// <remarks/>
    public string Code;
    
    /// <remarks/>
    public string OfferingDescription;
    
    /// <remarks/>
    public string PriceDescription;
    
    /// <remarks/>
    public string DesignID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string OfferingID;
}

/// <remarks/>
public class OfferingModelerDataCountryList {
    
    /// <remarks/>
    public string Country;
    
    /// <remarks/>
    public string DesignID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string OfferingID;
}

/// <remarks/>
public class OfferingModelerDataMEGOfferings {
    
    /// <remarks/>
    public string OfferingID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public OfferingModelerDataMEGOfferingsMEGID MEGID;
}

/// <remarks/>
public enum OfferingModelerDataMEGOfferingsMEGID {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlEnumAttribute("0db2330d-6f8d-4a78-bf7f-0e60da22aaf1")]
    Item0db2330d6f8d4a78bf7f0e60da22aaf1,
    
    /// <remarks/>
    [System.Xml.Serialization.XmlEnumAttribute("58d75f8a-7d0b-43c2-af5f-35800a75d281")]
    Item58d75f8a7d0b43c2af5f35800a75d281,
}

/// <remarks/>
public class OfferingModelerDataMEG {
    
    /// <remarks/>
    public string MEGName;
    
    /// <remarks/>
    public int Status;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public OfferingModelerDataMEGMEGID MEGID;
}

/// <remarks/>
public enum OfferingModelerDataMEGMEGID {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlEnumAttribute("0db2330d-6f8d-4a78-bf7f-0e60da22aaf1")]
    Item0db2330d6f8d4a78bf7f0e60da22aaf1,
    
    /// <remarks/>
    [System.Xml.Serialization.XmlEnumAttribute("58d75f8a-7d0b-43c2-af5f-35800a75d281")]
    Item58d75f8a7d0b43c2af5f35800a75d281,
}

/// <remarks/>
public class OfferingModelerDataRatingRule {
    
    /// <remarks/>
    public int Rate;
    
    /// <remarks/>
    public string Resource1;
    
    /// <remarks/>
    public string Resource2;
    
    /// <remarks/>
    public System.SByte CycleStart;
    
    /// <remarks/>
    public short CycleEnd;
    
    /// <remarks/>
    public bool ImmediateSettlement;
    
    /// <remarks/>
    public bool IgnoreCredit;
    
    /// <remarks/>
    public System.SByte CycleUnit;
    
    /// <remarks/>
    public string RevenueSKU;
    
    /// <remarks/>
    public System.SByte ProratePercent;
    
    /// <remarks/>
    public bool CycleDay;
    
    /// <remarks/>
    public string Name;
    
    /// <remarks/>
    public string UDEID;
    
    /// <remarks/>
    public System.SByte ExecutionOrder;
    
    /// <remarks/>
    public bool UseSubscriptionCycles;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool UseSubscriptionCyclesSpecified;
    
    /// <remarks/>
    public System.SByte PerUnit;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool PerUnitSpecified;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Type;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string RatingRuleID;
}

/// <remarks/>
public class OfferingModelerDataUDE {
    
    /// <remarks/>
    public string Name;
    
    /// <remarks/>
    public string OfferingID;
    
    /// <remarks/>
    public string DesignID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Type;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string UDEID;
}

/// <remarks/>
public class OfferingModelerDataCategoryOfferings {
    
    /// <remarks/>
    public string OfferingID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string CategoryID;
}

/// <remarks/>
public class OfferingModelerDataServiceInstance {
    
    /// <remarks/>
    public string ServiceComponentID;
    
    /// <remarks/>
    public string DesignID;
    
    /// <remarks/>
    public string ResourceID;
    
    /// <remarks/>
    public System.SByte Count;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string OfferingID;
}

/// <remarks/>
public class OfferingModelerDataOfferingResources {
    
    /// <remarks/>
    public string ResourceID;
    
    /// <remarks/>
    public string DesignID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string OfferingID;
}

/// <remarks/>
public class ServiceClassType {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ID", typeof(string))]
    [System.Xml.Serialization.XmlElementAttribute("Name", typeof(string))]
    [System.Xml.Serialization.XmlChoiceIdentifierAttribute("ItemsElementName")]
    public string[] Items;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ItemsElementName")]
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public ItemsChoiceType[] ItemsElementName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(IncludeInSchema=false)]
public enum ItemsChoiceType {
    
    /// <remarks/>
    ID,
    
    /// <remarks/>
    Name,
}

/// <remarks/>
public class OfferingModelerDataServiceComponentServiceComponentAttributesMetaDataConnectorPropertiesProperty {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string name;
}

/// <remarks/>
public class OfferingModelerDataServiceComponentServiceComponentAttributesMetaDataConnectorProperties {
    
    /// <remarks/>
    public OfferingModelerDataServiceComponentServiceComponentAttributesMetaDataConnectorPropertiesProperty property;
}

/// <remarks/>
public class OfferingModelerDataServiceComponentServiceComponentAttributesMetaDataSoapParameters {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
    public string wsdlFile;
}

/// <remarks/>
public class OfferingModelerDataServiceComponentServiceComponentAttributesMetaData {
    
    /// <remarks/>
    public System.SByte AccountType;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool AccountTypeSpecified;
    
    /// <remarks/>
    public OfferingModelerDataServiceComponentServiceComponentAttributesMetaDataSoapParameters SoapParameters;
    
    /// <remarks/>
    public OfferingModelerDataServiceComponentServiceComponentAttributesMetaDataConnectorProperties connectorProperties;
    
    /// <remarks/>
    public string BasicAuthUser;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public OfferingModelerDataServiceComponentServiceComponentAttributesMetaDataType Type;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Method;
}

/// <remarks/>
public enum OfferingModelerDataServiceComponentServiceComponentAttributesMetaDataType {
    
    /// <remarks/>
    AsyncSoap,
    
    /// <remarks/>
    Hotmail,
}

/// <remarks/>
public class OfferingModelerDataServiceComponentServiceComponentAttributes {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute("MetaData", IsNullable=false)]
    public OfferingModelerDataServiceComponentServiceComponentAttributesMetaData[] MetaDataSet;
}

/// <remarks/>
public class OfferingModelerDataServiceComponent {
    
    /// <remarks/>
    public string ServiceComponentName;
    
    /// <remarks/>
    public OfferingModelerDataServiceComponentServiceComponentAttributes ServiceComponentAttributes;
    
    /// <remarks/>
    public bool MaxRoles;
    
    /// <remarks/>
    public ServiceClassType ServiceClass;
    
    /// <remarks/>
    public bool ProvisionDelay;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string ServiceComponentID;
}

/// <remarks/>
public class OfferingModelerDataResource {
    
    /// <remarks/>
    public string ResourceName;
    
    /// <remarks/>
    public OfferingModelerDataResourceProductType ProductType;
    
    /// <remarks/>
    public string ResourceScope;
    
    /// <remarks/>
    public OfferingModelerDataResourceUnitOfMeasure UnitOfMeasure;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string ResourceID;
}

/// <remarks/>
public enum OfferingModelerDataResourceProductType {
    
    /// <remarks/>
    Online,
    
    /// <remarks/>
    OnlineDownload,
}

/// <remarks/>
public enum OfferingModelerDataResourceUnitOfMeasure {
    
    /// <remarks/>
    Currency,
    
    /// <remarks/>
    Minute,
}

/// <remarks/>
public class OfferingModelerDataCategory {
    
    /// <remarks/>
    public string CategoryName;
    
    /// <remarks/>
    public int Status;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string CategoryID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\User.cs ===
using System.IO;

namespace xonline.tools.bountyhunter 
{
    //
    // This is where I keep information about a certain user
    //

    public class User
    {
        private long _puid; 
        private string _gamertag;
        private int _country;

        public User(long puid, string gamertag, int country)
        {
            _puid = puid;
            _gamertag = gamertag;
            _country = country;
        }

        public void Write(TextWriter tw)
        {
            tw.WriteLine(",,,," + _gamertag + "," + _puid);    
        }

        public long PUID
        {
            get{ return _puid; }
        }

        public string GamerTag
        {
            get{ return _gamertag; }
        }

        public int Country
        {
            get{ return _country; }
        }
    }

} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\waldorf\bdk.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://sps25tiexbox1.tiexbox1.ssd.extest.microsoft.com/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReplacePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReplacePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\Title.cs ===
using System.Collections;
using System.IO;

namespace xonline.tools.bountyhunter 
{
    //
    // This keeps track of how many users are in a certain title
    // Specific user info is tracked by country, but kept in the big users array
    //

    public class Title
    {
        private Hashtable _countries; //holds user info by country
        private string _name;
        private int _titleid;
        private byte _internalonly;

        public Title(int id, string titlename, byte internalonly)
        {
            _titleid = id;
            _name = titlename;
            _countries = new Hashtable();
            _internalonly = internalonly;
        }

        public void AddUser(User u, Country c)
        {
            if(_countries.ContainsKey(u.Country))
                c = (Country)_countries[u.Country];
            else
            {
                c = new Country(c);
                _countries.Add(c.ID, c);
            }
           
            c.AddUser(u);
        }

        public void Write(TextWriter tw, bool verbose)
        {
            int totalusers = 0;

            tw.WriteLine(_name + "," + _titleid.ToString("x"));
            foreach(DictionaryEntry entry in _countries)
            {
                Country country = (Country)entry.Value;
                totalusers += country.NumUsers;
                country.Write(tw, verbose);

            } //showing info by country

            tw.WriteLine(",,Total," + totalusers.ToString());
            tw.WriteLine("");
        }

        public string Name
        {
            get{ return _name; }
        }

        public int TitleID
        {
            get{ return _titleid; }
        }

        public byte InternalOnly
        {
            get
            {
                return _internalonly;
            }
        }
    }

} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\buckets\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\BountyHunter.cs ===
using System;
using System.Collections;
using System.Data.SqlClient;
using System.IO;
using System.Runtime.Serialization;

namespace xonline.tools.bountyhunter 
{
    /// <summary>
    /// Exception thrown when an empty country list is retrieved from the DB.
    /// </summary>
    public class EmptyCountryListException : Exception, ISerializable
    {
        const string message = "No country information was retrieved from the database.";

        public EmptyCountryListException( ) : 
            base( message )
        { }

        public EmptyCountryListException( string auxMessage ) : 
            base( message + " - " + auxMessage )
        { }

        public EmptyCountryListException( string auxMessage, Exception inner ) :
            base( message + " - " + auxMessage, inner )    
        { }

        public EmptyCountryListException( SerializationInfo info, StreamingContext context ) :
            base( info, context )
        { }
    }

    /// <summary>
    /// Gets info for users who logged in with a non-exempt title
    /// </summary>
    public class BountyHunter
    {
        private Hashtable _titles; //All our titles (holding all countries, users, eventually)
        private Hashtable _countries; //just a list of what country codes have what names
        private string _connstr;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="connstr"></param>
        public BountyHunter(string connstr)
        {
            _connstr = connstr;
            _titles = new Hashtable();
            _countries = new Hashtable();

            LoadCountryInfo();
        }

        /// <summary>
        /// Load country information from the DB.
        /// </summary>
        private void LoadCountryInfo()
        {
            SqlDataReader rval = null;
            SqlConnection conn = null;
            string query = "exec p_XRSupp_GetCountries";

            //matches a country's id with it's name
            try
            {
                conn = new SqlConnection(_connstr);
                conn.Open();

                rval = RunSqlQuery(conn, query);

                while (rval.Read())
                {
                    Country country = new Country((int) rval.GetSqlInt16(0).Value, rval.GetString(1));
                    _countries.Add(country.ID, country);
                }

                if(_countries.Count == 0)
                    throw new EmptyCountryListException();
            }
            finally
            {
                if(rval != null)
                    rval.Close();
                if(conn != null)
                    conn.Close();
            }

        } //GetCountryInfo

  
        public int GetBountyInfo(DateTime startdate, DateTime enddate)
        {
            int nRetVal = 0;
            SqlConnection conn = null;
            SqlDataReader rval = null;

            //
            //  Parameter validation
            //

            if(startdate >= enddate)
                throw new ArgumentException("Start date must be less than end date.");

            //
            //  Remove any existing info
            //

            _titles.Clear();

            //
            //  Call the bounty stored proc and process the result set
            //

            try
            {
                string query  = "exec p_XR_Bounty '" + startdate.ToString("yyyy-MM-dd") + "', '" + enddate.AddDays(1).ToString("yyyy-MM-dd")+ "'";

                conn = new SqlConnection(_connstr);
                conn.Open();

                rval = RunSqlQuery(conn, query);

                while (rval.Read())
                {
                    /*
                        Params:
                        0: Titleid
                        1: TitleName
                        2: InternalOnly
                        3: Userpuid
                        4: GamerTag
                        5: CountryID
                    */

                    Title title;
                    int titleid;
                    string titlename;
                    byte InternalOnly;
                    long puid;
                    string gamertag;
                    int country;

                    titleid = rval.GetInt32(0);
                    titlename = rval.GetString(1);
                    InternalOnly = rval.GetByte(2);
                    puid = rval.GetInt64(3);
                    gamertag = rval.GetString(4);
                    country = rval.GetByte(5);

                    if(_titles.ContainsKey(titleid))
                    {
                        title = (Title)_titles[titleid];
                    }
                    else
                    {
                        title = new Title(titleid, titlename, InternalOnly);
                        _titles.Add(titleid, title); 
                    }

                    User user = new User(puid, gamertag, country);

                    title.AddUser(user, (Country)_countries[user.Country]);
                    nRetVal = 1;
                }

                if (0 == nRetVal)
                {
                    // There is no data for the date range specified.
                    Console.Write("Error: There is no data for the date range specified.\n\n");
                }
            }
            finally
            {
                if(rval != null)
                    rval.Close();
                if(conn != null)
                    conn.Close();
            }

            return nRetVal;
        } //GetAllInfo

        /// <summary>
        /// Write out bounty info to the text writer provided
        /// </summary>
        /// <param name="tw"></param>
        /// <param name="verbose"></param>
        public void Write(TextWriter tw, bool verbose)
        {
            foreach (DictionaryEntry entry in _titles)
            {
                Title title = (Title)entry.Value;

                if (1 != title.InternalOnly)
                {
                    title.Write(tw, verbose);
                }
            } //showing info by title
        }

        private static SqlDataReader RunSqlQuery(SqlConnection conn, string sqlcommand)
        {
            SqlCommand cmd = new SqlCommand(sqlcommand, conn);
            cmd.CommandTimeout = 0;

            SqlDataReader rval = cmd.ExecuteReader();

            return rval;
        }

    } //class
} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\test\dvt\TitleTest.cs ===
using System.IO;
using NUnit.Framework;
using xonline.tools.bountyhunter;

namespace xonline.tools.bountyhunter.test.dvt 
{
    /// <summary>
    /// Summary description for TitleTest.
    /// </summary>
    [TestFixture]
    public class TitleTest
    {
        public TitleTest()
        {
        }

        [Test]
        public void CtorTest()
        {
            Title t1 = new Title(-131072, "Xbox Live Dashboard", 1);
            Assert.AreEqual(-131072, t1.TitleID);
            Assert.AreEqual("Xbox Live Dashboard", t1.Name);
            Assert.AreEqual(1, t1.InternalOnly);
        }

        [Test]
        public void DisplayTest()
        {
            Title t1;
            User u1;
            StringWriter sw;
            string s;

            t1 = new Title(-131072, "Xbox Live Dashboard", 1);
            
            sw = new StringWriter();
            t1.Write(sw, false);
            s = sw.ToString();
            Assert.AreEqual("Xbox Live Dashboard,fffe0000\r\n,,Total,0\r\n\r\n", s);
            
            u1 = new User(666, "Satan", 103);
            t1.AddUser(u1, new Country(103, "United States"));

            sw = new StringWriter();
            t1.Write(sw, false);
            s = sw.ToString();
            Assert.AreEqual("Xbox Live Dashboard,fffe0000\r\n,,United States,1\r\n,,Total,1\r\n\r\n", s);

            sw = new StringWriter();
            t1.Write(sw, true);
            s = sw.ToString();
            Assert.AreEqual("Xbox Live Dashboard,fffe0000\r\n,,United States,1\r\n,,,,Satan,666\r\n\r\n,,Total,1\r\n\r\n", s);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\test\dvt\UserTest.cs ===
using System.IO;
using NUnit.Framework;
using xonline.tools.bountyhunter;

namespace xonline.tools.bountyhunter.test.dvt 
{
    /// <summary>
    /// Unit tests for the XBOX.Tools.BountyHunter.User class.
    /// </summary>
    /// 
    [TestFixture]
    public class UserTest
    {
        public UserTest()
        {
        }

        [Test]
        public void CtorTest()
        {
            User u1 = new User(0, "foo", 1);
            Assert.AreEqual(u1.Country, 1);
            Assert.AreEqual(u1.PUID, 0);
            Assert.AreEqual(u1.GamerTag, "foo");
        }

        [Test]
        public void DisplayTest()
        {
            User u1 = new User(666, "Satan", 103);

            StringWriter sw = new StringWriter();

            u1.Write(sw);

            string s = sw.ToString();

            Assert.AreEqual(s, ",,,,Satan,666\r\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\test\dvt\CountryTest.cs ===
using System;
using System.IO;
using NUnit.Framework;
using xonline.tools.bountyhunter;

namespace xonline.tools.bountyhunter.test.dvt 
{
    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class CountryTest
    {
        /// <summary>
        /// Constructor tests.
        /// </summary>
        [Test]
        public void CtorTest()
        {
            Country c1 = new Country(103, "United States");
            Assert.AreEqual(103, c1.ID);
            Assert.AreEqual("United States", c1.Name);
            Assert.AreEqual(0, c1.NumUsers);

            Country c2 = new Country(c1);
            Assert.AreEqual(103, c2.ID);
            Assert.AreEqual("United States", c2.Name);
            Assert.AreEqual(0, c2.NumUsers);

            //
            //  Add a user and then create a new country with
            //  the copy constructor and verify that the new
            //  object does not have any users
            //

            c2.AddUser(new User(1, "floobie", 103));
            Country c3 = new Country(c2);
            Assert.AreEqual(0, c3.NumUsers);
        }

        /// <summary>
        /// Positive tests for adding users to countries.
        /// </summary>
        [Test]
        public void AddUserTest()
        {
            Country c1 = new Country(103, "United States");
            Assert.AreEqual(103, c1.ID);
            Assert.AreEqual("United States", c1.Name);
            Assert.AreEqual(0, c1.NumUsers);

            User u1 = new User(666, "Satan", 103);
            User u2 = new User(8675309, "Eddie Money", 103);

            c1.AddUser(u1);
            Assert.AreEqual(1, c1.NumUsers);

            c1.AddUser(u2);
            Assert.AreEqual(2, c1.NumUsers);
        }

        /// <summary>
        /// Adding same user twice should throw an exception.
        /// </summary>
        [Test]
        [NUnit.Framework.ExpectedException(typeof(ArgumentException))]
        public void DupUserExceptionTest()
        {
            Country c1 = new Country(103, "United States");
            User u1 = new User(666, "Satan", 103);

            c1.AddUser(u1);
            c1.AddUser(u1); // Throws ArgumentException
        }

        /// <summary>
        /// Mismatch of user's country and country being added to should
        /// throw an exception.
        /// </summary>
        [Test]
        [NUnit.Framework.ExpectedException(typeof(ArgumentException))]
        public void CountryMismatchTest()
        {
            Country c1 = new Country(103, "United States");
            User u1 = new User(666, "Satan", 74);
            c1.AddUser(u1);
        }

        /// <summary>
        /// Make sure information is displayed correctly.
        /// </summary>
        [Test]
        public void DisplayTest()
        {
            StringWriter sw;
            string s;

            Country c1 = new Country(103, "United States");

            sw = new StringWriter();
            c1.Write(sw, false);
            s = sw.ToString();
            Assert.AreEqual("", s);

            User u1 = new User(666, "Satan", 103);
            User u2 = new User(8675309, "Eddie Money", 103);

            c1.AddUser(u1);
            c1.AddUser(u2);

            sw = new StringWriter();
            c1.Write(sw, false);
            s = sw.ToString();
            Assert.AreEqual(",,United States,2\r\n", s);

            sw = new StringWriter();
            c1.Write(sw, true);
            s = sw.ToString();
            Assert.AreEqual(",,United States,2\r\n,,,,Satan,666\r\n,,,,Eddie Money,8675309\r\n\r\n", s);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\buckets\buckets.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.IO;
using System.Text.RegularExpressions;

namespace buckets
{
    /*

    The purpose of this tool is quite narrow.  During the Tsunami->Xenon migration, the need arose to repartition databases
    as part of the user data migration.  This mean that for each of the ~10 destination servers, we needed to execute a 
    query that selected the buckets for that destination server out of the source databases.  Rather than do this by hand,
    which can be error prone on the various environments (BVTNet, NewProd, etc) this utility was written to automatically
    make a copy of the migration script customized for each destination partition.

    During testing it was found that using the "WHERE si_hash_bucket IN (x, y, z, ...)" was much slower than the equivalent
    "WHERE si_hash_bucket >= x AND si_hash_bucket <= y", hence the optimization for consecutive bucket ranges.
    
    */
    
	class Buckets
	{
		static void Main(string[] args)
		{
			if (args.Length != 6)
			{
				Console.WriteLine("usage: buckets <wstConfigServerName> <wstConfigDBName> <applicationName> <destinationServer> <sourceFile> <regex>");
				Console.WriteLine("usage: buckets test test <replacement> <destinationServer> <sourceFile> <regex>");
				Console.WriteLine("example1: buckets wstconfig uodb BXXALLSQL01 XETMIGSQL005 MigrationMigrateUODBXProfile.sql bucketlist");
				Console.WriteLine("example2: buckets test test \"% 10 = 1\" XETMIGSQL005 MigrationMigrateUODBXProfile.sql bucketlist");

				return;
			}

			string wstConfigServerName = args[0];
			string wstConfigDBName = args[1];
			string applicationName = args[2];

			string destinationServer = args[3];
			string sourceFileName = args[4];
			string replacementRegex = args[5];

			if (wstConfigServerName == "test" && wstConfigDBName == "test")
			{
				string fileText = File.OpenText(sourceFileName).ReadToEnd();
				Regex regex = new Regex(replacementRegex, RegexOptions.IgnoreCase);
				string newFileText = regex.Replace(fileText, applicationName);
		
				string destFileName = Path.GetFileNameWithoutExtension(sourceFileName) + destinationServer + Path.GetExtension(sourceFileName);
				StreamWriter w = File.CreateText(destFileName);
				w.Write(newFileText);
				w.Flush();
			}
			else
			{
				ArrayList buckets = new ArrayList(420);

				using (SqlConnection c = new SqlConnection("Data Source=" + wstConfigServerName + ";Initial Catalog=" + 
						   wstConfigDBName + ";Integrated Security=SSPI"))
				{
					c.Open();

					using (SqlCommand cmd = c.CreateCommand())
					{
						cmd.CommandType = CommandType.Text;
						cmd.CommandText = "SELECT dp.PartitionNum FROM DataServer ds INNER JOIN SQLDatabase sd ON ds.DataServerUID = sd.DataServerUID" +
							" INNER JOIN SQLFailSafeSet fss ON sd.SQLDatabaseUID = fss.PrimarySQLDBUID INNER JOIN DataPartition dp ON fss.DeploymentUID = dp.DeploymentUID" + 
							" AND fss.SQLFSSNum = dp.SQLFSSNum WHERE sd.SQLDatabaseName = '" + applicationName + "' AND ds.ServerName = '" + destinationServer + "'";

						SqlDataReader r = cmd.ExecuteReader();
						while (r.Read())
						{
							buckets.Add(((int) r.GetInt16(0)));
						}
					}
				}

				buckets.Sort();

				int lastbucket = -1;
				bool contiguous = true;
				foreach (int bucket in buckets)
				{
					if (lastbucket == -1)
					{
						lastbucket = bucket;
						continue;
					}

					if (lastbucket != bucket - 1)
					{
						contiguous = false;
						break;
					}

					lastbucket = bucket;
				}

				string bucketQuery = null;

				if (contiguous)
				{
					bucketQuery = "WHERE si_hash_bucket >= ";
					bucketQuery += ((int) buckets[0]).ToString();
					bucketQuery += " AND si_hash_bucket <= ";
					bucketQuery += ((int) buckets[buckets.Count - 1]).ToString();
				}
				else
				{
					// fall back to an explicit list of buckets

					bucketQuery = "WHERE si_hash_bucket IN (";
					bucketQuery += ((int) buckets[0]).ToString("d");
					for (int i = 1; i < 420; i++)
					{
						int bucket = (int) buckets[i];
						if (bucket != -1)
							bucketQuery += ", " + bucket.ToString("d");
					}
					bucketQuery += ")";
				}

				string fileText = File.OpenText(sourceFileName).ReadToEnd();
				Regex regex = new Regex(replacementRegex, RegexOptions.IgnoreCase);
				string newFileText = regex.Replace(fileText, bucketQuery);
		
				string destFileName = Path.GetFileNameWithoutExtension(sourceFileName) + destinationServer + Path.GetExtension(sourceFileName);
				StreamWriter w = File.CreateText(destFileName);
				w.Write(newFileText);
				w.Flush();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BulkUser\Accounts.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using BulkUser.UserAccountService;
using System.Timers;
using System.Security.Cryptography.X509Certificates;

namespace BulkUser
{
    class Accounts
    {
        private AccountData data;
        private static Random random = new Random();
        private UserAccount userAccountService = null;
        
        private bool ValidateData()
        {
            bool valid = true;

            if (string.IsNullOrEmpty(data.Partner.Trim()) || data.Partner.Trim().Length > 5)
            {
                Utility.LogError("Partner Name can't be empty or more than 5 char.");
                valid = false;
            }

            if (string.IsNullOrEmpty(data.Domain.Trim()) || data.Domain.Trim()[0] != '@')
            {
                Utility.LogError("Partner Name can't be empty or more than 5 char.");
                valid = false;
            }

            if (data.CountryId == 0)
            {
                Utility.LogError("Wrong CountryId.");
                valid = false;
            }

            if (data.LanguageId == 0)
            {
                Utility.LogError("Wrong LanguageId.");
                valid = false;
            }

            if (data.StartSeed == 0)
            {
                Utility.LogError("Wrong start seed.");
                valid = false;
            }

            if (data.NumOfAccounts == 0)
            {
                Utility.LogError("Total no of accounts should be more than 0.");
                valid = false;
            }

            if (data.TimeInterval == 0)
            {
                Utility.LogError("Time interval should be more than 0 sec.");
                valid = false;
            }

            if (!Directory.Exists(data.FolderPath))
            {
                Utility.LogError("Folder doesn't exist.");
                valid = false;
            }
            else
            {
                if (!File.Exists(data.FilePath))
                {
                    //File.Write
                    using (StreamWriter w = File.CreateText(data.FilePath))
                    {
                        w.WriteLine("UserName,Password,Gamertag,Secret Question,Secret Answer");
                        w.Flush();
                        w.Close();
                    }
                }
            }

            return valid;
        }

        private bool WriteFile(CreateBulkUserResponse response, int seed)
        {
            Utility.LogInfo("---------------------------------------------");
            Utility.LogInfo("---------------------------------------------");
            Utility.LogInfo("Account created for seed :" + seed.ToString());
            Utility.LogInfo("UserName :" + response.userName);
            Utility.LogInfo("Password :" + response.password);
            Utility.LogInfo("GamerTag :" + response.gamertag);
            Utility.LogInfo("SecretQuestion :" + response.secretQuestion);
            Utility.LogInfo("SecretAnswer :" + response.secretAnswer);
            Utility.LogInfo("---------------------------------------------");
            Utility.LogInfo("---------------------------------------------");

            //File.Write
            using (StreamWriter w = File.AppendText(data.FilePath))
            {
                w.WriteLine("{0},{1},{2},{3},{4}", response.userName, response.password, response.gamertag, response.secretQuestion, response.secretAnswer);
                w.Flush();
                w.Close();
            }

            return true;
        }

        private bool CreateAccount(int seed)
        {
            System.Threading.Thread.Sleep(data.TimeInterval * 1000);
            Utility.LogInfo("Creating account for seed :" + seed.ToString());

            CreateBulkUserResponse resp = null;

            CreateBulkUserRequest req = new CreateBulkUserRequest();
            int month = 1 + random.Next(11);
            int year = DateTime.Now.AddYears(-20).Year - random.Next(20);
            int day = 1 + random.Next(27);
            req.birthdate = new DateTime(year, month, day); //It should be random.
            req.countryId = (byte)data.CountryId;
            req.partner = data.Partner;
            req.languageId = (byte)data.LanguageId;
            req.domain = data.Domain.Trim();
            char p1 = (char)random.Next(65, 90);
            char p2 = (char)random.Next(65, 90);
            char p3 = (char)random.Next(65, 90);
            char p4 = (char)random.Next(65, 90);
            string prefix = string.Format("{0}{1}{2}{3}",p1 ,p2,p3, p4); 
            req.memberName = prefix + req.partner + seed.ToString();
            if (req.partner.Length + seed.ToString().Length > 15)
            {
                Utility.LogError("MemberName exceeds 15 char limit");
                return false;
            }

            try
            {
                resp = userAccountService.CreateBulkUser(req);
            }
            catch (Exception ex)
            {
                Utility.LogError(ex.ToString());
                return false;
            }

            return WriteFile(resp, seed);
        }

        public void CreateAccounts(AccountData acctData)
        {
            data = acctData;

            Utility.LogInfo("-----Start Validating data----");
            if (ValidateData())
            {
                Utility.LogInfo("-----End Validating data----");

                userAccountService = new UserAccount();
                userAccountService.Url = System.Configuration.ConfigurationManager.AppSettings["ServiceUrl"];
#if !DEBUG
                string certName = System.Configuration.ConfigurationManager.AppSettings["CertName"];

                X509Certificate clientCert = X509Certificate.CreateFromCertFile(certName);
                userAccountService.ClientCertificates.Add(clientCert);
#endif
                Utility.LogInfo("-----Start creating accounts ----");

                for (int i = 0; i < data.NumOfAccounts; i++)
                {
                    if (!CreateAccount(data.StartSeed + i))
                    {
                        Utility.LogInfo("-----Error while creating account. ----");
                        bool error = true;
                        //trying two more times.
                        for (int j = 0; j < 2; j++)
                        {
                            if (CreateAccount(data.StartSeed + i))
                            {
                                error = false;
                                break;
                            }
                        }

                        if (error)
                        {
                            Utility.LogInfo("-----Stopping creating accounts. ----");
                            return;
                        }
                    }
                }

                Utility.LogInfo("-----End creating accounts ----");
            }
            else
            {
                Utility.LogInfo("-----Input data does not meet validations. Exiting ----");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BountyHunter\test\dvt\BountyHunterTest.cs ===
using NUnit.Framework;
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using xonline.tools.bountyhunter;

namespace xonline.tools.bountyhunter.test.dvt 
{
    /// <summary>
    /// Unit tests for the XBOX.Tools.BountyHunter.BountyHunter class.  Sets up database and collects bounty data
    /// for various date ranges.
    /// </summary>
    /// 
    [TestFixture]
    public class BountyHunterTest
    {
        private const long OFFERID_BETA1            = -562947805937663; // 0xFFFE000080000001
        private const long OFFERID_BETA2            = -562947805937662; // 0xFFFE000080000002
        private const long OFFERID_BETA3            = -562947805937661; // 0xFFFE000080000003
        private const long OFFERID_BETA4            = -562947805937660; // 0xFFFE000080000004
        private const long OFFERID_GIFT1            = -562947805937659; // 0xFFFE000080000005
        private const long OFFERID_GIFT2            = -562947805937658; // 0xFFFE000080000006
        private const long OFFERID_BASE             = -562947805937656; // 0xFFFE000080000008
        private const long OFFERID_GAME_TRIAL       = -562947805937655; // 0xFFFE000080000009
        private const long OFFERID_CONSOLE_TRIAL    = -562947805937654; // 0xFFFE00008000000A
        private const long OFFERID_RENEWAL_M        = -562947805937653; // 0xFFFE00008000000B
        private const long OFFERID_RENEWAL_Y        = -562947805937652; // 0xFFFE00008000000C
        private const long OFFERID_PREPAID          = -562947805937651; // 0xFFFE00008000000D

        private const string sUnitTestDBConnStr = "Database=xreport_unittest;Integrated Security=true;Pooling=false";
        private const string sMasterDBConnStr   = "Database=master;Integrated Security=true;Pooling=false";

        public BountyHunterTest()
        {
        }

        [TestFixtureSetUp]
        public void TestFixtureSetUp()
        {
            Console.WriteLine("-------- TestFixtureSetUp() --------\r\n");

            Uri assemblyUri = new Uri(Assembly.GetExecutingAssembly().CodeBase);
            string sqlPath = Path.GetDirectoryName(assemblyUri.LocalPath);

            SqlConnection connMaster = null;
            SqlConnection connXReport = null;

            try
            {
                //
                //  Create database
                //

                connMaster = new SqlConnection(sMasterDBConnStr);
                connMaster.Open();

                RunSqlQuery(connMaster, "CREATE DATABASE XReport_UnitTest");
                RunSqlQuery(connMaster, "EXEC sp_addlogin N'xreport_user', N'xreport', N'XReport_UnitTest'"); 

                //
                //  Build out user account and schema
                //

                connXReport = new SqlConnection(sUnitTestDBConnStr);
                connXReport.Open();

                //  Create Xreport_User account
                RunSqlQuery(connXReport, "EXEC sp_grantdbaccess N'xreport_user', N'xreport_user'");

                //  Execute XRepSchema.sql
                RunSqlScript(connXReport, Path.Combine(sqlPath, "XRepSchema.sql"));

                //  Create necessary tables
                RunSqlQuery(connXReport, "EXEC p_RecreateAndLoad_XPROF_Users");
                RunSqlQuery(connXReport, "EXEC p_RecreateAndLoad_BountyTracking");
                RunSqlQuery(connXReport, "EXEC p_RecreateAndLoad_UODB_Subscriptions");
                RunSqlQuery(connXReport, "EXEC p_RecreateAndLoad_UODB_Users");
                RunSqlQuery(connXReport, "EXEC p_RecreateAndLoad_TitleInfo");
                RunSqlQuery(connXReport, "EXEC p_RecreateAndLoad_RegionInfo");
                RunSqlQuery(connXReport, "EXEC p_RecreateAndLoad_CountryRegionInfo");

                //  Execute XRepRosetta.sql
                RunSqlScript(connXReport, Path.Combine(sqlPath, "XRepRosetta.sql"));

                //  Load static data
                //  Countries and Regions
                InsertRegion(connXReport, 1, "NA", "North America");
                InsertRegion(connXReport, 2, "EM", "EMEA");

                InsertCountry(connXReport, 103, "US", "United States", 1);
                InsertCountry(connXReport, 74, "NL", "Netherlands", 2);

                //  Load test data
                //  Titles
                InsertTitle(connXReport, "Mech Assault", 1297285143);
                InsertTitle(connXReport, "Unreal Championship", 1229389860);
                InsertTitle(connXReport, "Ghost Recon", 1431502854);

                //  Users
                long puid;

                //  Base subscription
                puid = 2533274790395905;
                InsertUser(connXReport, "UserBase", puid, 103, 1297285143, DateTime.Parse("3/15/2003"));
                InsertSub(connXReport, puid, OFFERID_BASE, DateTime.Parse("3/15/2003"), DateTime.Parse("3/15/2004"));

                //  Trial => yearly
                puid = 2533274790395906;
                InsertUser(connXReport, "UserCTtoY", puid, 103, 1297285143, DateTime.Parse("3/16/2003"));
                InsertSub(connXReport, puid, OFFERID_CONSOLE_TRIAL, DateTime.Parse("3/16/2003"), DateTime.Parse("5/16/2003"));
                InsertSub(connXReport, puid, OFFERID_RENEWAL_Y, DateTime.Parse("5/16/2003"), DateTime.Parse("12/31/9999"));

                puid = 2533274790395907;
                InsertUser(connXReport, "UserGTtoY", puid, 103, 1297285143, DateTime.Parse("3/16/2003"));
                InsertSub(connXReport, puid, OFFERID_GAME_TRIAL, DateTime.Parse("3/16/2003"), DateTime.Parse("5/16/2003"));
                InsertSub(connXReport, puid, OFFERID_RENEWAL_Y, DateTime.Parse("5/16/2003"), DateTime.Parse("12/31/9999"));


                //  Trial => monthly
                puid = 2533274790395908;
                InsertUser(connXReport, "UserCTtoM", puid, 103, 1297285143, DateTime.Parse("3/16/2003"));
                InsertSub(connXReport, puid, OFFERID_CONSOLE_TRIAL, DateTime.Parse("3/16/2003"), DateTime.Parse("5/16/2003"));
                InsertSub(connXReport, puid, OFFERID_RENEWAL_M, DateTime.Parse("5/16/2003"), DateTime.Parse("12/31/9999"));

                puid = 2533274790395909;
                InsertUser(connXReport, "UserGTtoM", puid, 103, 1297285143, DateTime.Parse("3/16/2003"));
                InsertSub(connXReport, puid, OFFERID_GAME_TRIAL, DateTime.Parse("3/16/2003"), DateTime.Parse("5/16/2003"));
                InsertSub(connXReport, puid, OFFERID_RENEWAL_M, DateTime.Parse("5/16/2003"), DateTime.Parse("12/31/9999"));


                //  32983 - Renewal before trial
                puid = 2533274790395910;
                InsertUser(connXReport, "UserMtoGT", puid, 103, 1297285143, DateTime.Parse("4/2/2003"));
                InsertSub(connXReport, puid, OFFERID_RENEWAL_M, DateTime.Parse("4/2/2003"), DateTime.Parse("12/31/9999"));
                InsertSub(connXReport, puid, OFFERID_GAME_TRIAL, DateTime.Parse("4/15/2003"), DateTime.Parse("6/15/2003"));
            }
            catch(Exception e)
            {
                Console.WriteLine(e);
                throw;
            }
            finally
            {
                if(connMaster != null)
                    connMaster.Close();
                if(connXReport != null)
                    connXReport.Close();
            }
                
            Console.WriteLine("\r\n-------- TestFixtureSetUp() - Done --------");
        }

        [TestFixtureTearDown]
        public void TestFixtureTearDown()
        {
            Console.WriteLine("-------- TestFixtureTearDown() --------\r\n");

            SqlConnection connMaster = null;
            SqlConnection connXReport = null;

            try
            {
                //  Remove user from db
                connXReport = new SqlConnection(sUnitTestDBConnStr);
                connXReport.Open();
                RunSqlQuery(connXReport, "EXEC sp_revokedbaccess N'xreport_user'");
            }
            catch
            {
                //  In case of exception we don't want to skip the next try/finally block
                //  An exception here probably means either that XReport_UnitTest does
                //  not exist (Open() failed), or xreport_user is not a user of the db
                //  (sp_revokedbaccess failed).  In either case we need to swallow 
                //  the exception and continue.
            }
            finally
            {
                if(connXReport != null)
                    connXReport.Close();
            }

            try
            {
                connMaster = new SqlConnection(sMasterDBConnStr);
                connMaster.Open();

                //  Remove xreport_user login
                RunSqlQuery(connMaster, "EXEC sp_droplogin N'xreport_user'");

                //  Drop test database
                RunSqlQuery(connMaster, "DROP DATABASE XReport_UnitTest");
            }
            finally
            {
                if(connMaster != null)
                    connMaster.Close();
            }
                
            Console.WriteLine("\r\n-------- TestFixtureTearDown() - Done --------");
        }

        private void InsertRegion(SqlConnection conn, short nRegion, string sRegionShortName, string sRegionName)
        {
            string query = "INSERT RegionInfo (\r\nsiRegion, vcRegionCode, vcRegionName)\r\nVALUES (\r\n" + nRegion.ToString() + ",'" + sRegionShortName + "','" + sRegionName + "')";

            RunSqlQuery(conn, query);
        }

        private void InsertCountry(SqlConnection conn, short nCountryCode, string sCountryShortName, string sCountryName, short nRegion)
        {
            string query = "INSERT CountryRegionInfo (\r\nsiCountryCode, vcCountryCode, vcCountryName, siRegion)\r\nVALUES (\r\n" + nCountryCode.ToString() + ",'" + sCountryShortName + "','" + sCountryName + "'," + nRegion.ToString() + ")";

            RunSqlQuery(conn, query);
        }

        private void InsertTitle(SqlConnection conn, string name, int id)
        {
            string query = "INSERT TitleInfo (\r\niTitleID, vcTitleName, tiDownloadOnly, tiInternalOnly, tiBetaTitle, tiPackinTitle, biUUBitMask, tiNoDownloads, vcTitleNameSales, dtAvailableSince)\r\nVALUES (\r\n" + id.ToString("d") + ",'" + name + "',0,0,0,0,0,0,'" + name + "','2002-11-15')";

            RunSqlQuery(conn, query);
        }

        private void InsertUser(SqlConnection conn, string gamertag, long puid, short country, int bountytitle, DateTime bountychange)
        {
            string xprofUsersQuery = "INSERT XPROF_Users (" +
                                        "bi_user_puid," +
                                        "vc_account_name," +
                                        "f_flush_tickets," +
                                        "i_friend_list_ver," +
                                        "i_friend_list_len," + 
                                        "i_lockout_list_ver," +
                                        "i_lockout_list_len," +
                                        "dt_system_msg_read," +
                                        "i_num_user_msg," +
                                        "i_bounty_title_id," +
                                        "dt_bounty_change," +
                                        "si_Hash_Bucket," +
                                        "dt_Change_datetime )" +
                                     "VALUES (" + 
                                        puid.ToString() + 
                                        ",'" + gamertag + 
                                        "', 0, 0, 0, 0, 0, '2002-11-15', 0, " + 
                                        bountytitle.ToString() + 
                                        ",'" + bountychange.ToString("yyyy-MM-dd") + "',0,2002-11-15 )";
            string uodbUsersQuery = "INSERT UODB_Users (" +
                                        "bi_user_puid," +
                                        "bi_owner_puid," +
                                        "bi_machine_puid," +
                                        "vc_gamertag," +
                                        "dt_birthdate," +
                                        "ti_country_id," +
                                        "bin_acct_pin," +
                                        "vc_billing_account_id," +
                                        "vc_billing_payinfo_id," +
                                        "si_ticket_flags," +
                                        "dt_acct_resume_date," +
                                        "i_suspension_length," +
                                        "dt_voice_resume_date," +
                                        "i_voice_ban_length," +
                                        "ti_name_change_required," +
                                        "dt_accepted_tos," +
                                        "dt_reset_date," +
                                        "i_billing_account_status," +
                                        "f_ms_opt_in," +
                                        "f_partner_opt_in," +
                                        "si_hash_bucket," +
                                        "dt_Change_datetime )" +
                                    "VALUES ( " +
                                        puid.ToString() +
                                        "," + puid.ToString() +
                                        "," + puid.ToString() +
                                        ",'" + gamertag +
                                        "','1966-3-15'," + country.ToString() +
                                        ",0x00000000,'','',0,'2002-11-15',0,'2002-11-15',0,0,'2002-11-15','2002-11-15',0,0,0,0,'2002-11-15' )";

            RunSqlQuery(conn, xprofUsersQuery);
            RunSqlQuery(conn, uodbUsersQuery);
        }

        private void InsertSub(SqlConnection conn, long puid, long offerid, DateTime startdate, DateTime enddate)
        {
            string uodbSubscriptionsQuery = "INSERT UODB_Subscriptions (" +
                                                "bi_primary_puid," +
                                                "bi_offer_id," +
                                                "i_instances," +
                                                "vc_svc_instance_id," +
                                                "i_puid_is_machine," +
                                                "dt_start_date," +
                                                "dt_end_date," +
                                                "i_subscription_status_id," +
                                                "i_transaction_flags," +
                                                "si_hash_bucket," +
                                                "dt_Change_datetime )" +
                                            "VALUES (" +
                                                puid.ToString() +
                                                "," + offerid.ToString() +
                                                ",1,'',0,'" + startdate.ToString("yyyy-MM-dd") +
                                                "','" + enddate.ToString("yyyy-MM-dd") +
                                                "',0,0,0,'2002-11-15' )";

            RunSqlQuery(conn, uodbSubscriptionsQuery);
        }

        private void RunSqlScript(SqlConnection conn, string script)
        {
            string s;
            StringBuilder sb = new StringBuilder();
            StreamReader sr = new StreamReader(script);

            while((s = sr.ReadLine()) != null)
            {
                s = s.Trim();

                if(s.ToUpper() != "GO")
                {
                    sb.Append(s);
                    sb.Append("\r\n");
                }
                else
                {
                    RunSqlQuery(conn, sb.ToString());
                    sb = new StringBuilder();
                }
            }

            sr.Close();
        }

        private void RunSqlQuery(SqlConnection conn, string sqlcommand)
        {
            Console.WriteLine("RunSqlQuery:\r\n" + sqlcommand);

            SqlCommand cmd = new SqlCommand(sqlcommand, conn);
            cmd.CommandTimeout = 0;

            cmd.ExecuteNonQuery();
        }

        //------------------------------------
        //
        //  Test Cases Start Here
        //
        //------------------------------------

        /// <summary>
        /// Main line tests:
        /// 1.  User with a base subscription and no renewals
        /// 2.  User created with trial converting to yearly
        /// 3.  User created with trial converting to monthly
        /// 
        /// Data for these users is inserted in TestFixtureSetup.
        /// </summary>
        [Test]
        public void PositiveTests()
        {
            Console.WriteLine("-------- PositiveTests() --------\r\n");

            string s;
            StringWriter sw;

            BountyHunter bh = new BountyHunter(sUnitTestDBConnStr);

            sw = new StringWriter();
            bh.Write(sw, false);
            s = sw.ToString();
            Assert.AreEqual("", s);

            sw = new StringWriter();
            bh.Write(sw, true);
            s = sw.ToString();
            Assert.AreEqual("", s);

            //
            //  First date range, base subscription user only.
            //

            bh.GetBountyInfo(DateTime.Parse("3/12/2003"), DateTime.Parse("3/18/2003"));

            sw = new StringWriter();
            bh.Write(sw, false);
            s = sw.ToString();
            Console.Write(s);
            Assert.AreEqual("Mech Assault,4d530017\r\n,,United States,1\r\n,,Total,1\r\n\r\n", s);

            sw = new StringWriter();
            bh.Write(sw, true);
            s = sw.ToString();
            Console.Write(s);
            Assert.AreEqual("Mech Assault,4d530017\r\n,,United States,1\r\n,,,,UserBase,2533274790395905\r\n\r\n,,Total,1\r\n\r\n", s);

            //
            //  Second date range, trial users after converting
            //

            bh.GetBountyInfo(DateTime.Parse("5/12/2003"), DateTime.Parse("5/18/2003"));

            sw = new StringWriter();
            bh.Write(sw, false);
            s = sw.ToString();
            Console.Write(s);
            Assert.AreEqual("Mech Assault,4d530017\r\n,,United States,2\r\n,,Total,2\r\n\r\n", s);

            sw = new StringWriter();
            bh.Write(sw, true);
            s = sw.ToString();
            Console.Write(s);
            Assert.AreEqual("Mech Assault,4d530017\r\n,,United States,2\r\n,,,,UserGTtoY,2533274790395907\r\n,,,,UserCTtoY,2533274790395906\r\n\r\n,,Total,2\r\n\r\n", s);

            Console.WriteLine("\r\n-------- PositiveTests() - Done --------");
        }

        /// <summary>
        /// Specific test case for bug 32983.  In this case, the user's
        /// first subscription is a renewal, and the second subscription is 
        /// a trial.  This is a situation that cannot normally happen.
        /// </summary>
        [Test]
        public void Bug32983Test()
        {
            Console.WriteLine("-------- Bug32983Test() --------\r\n");

            StringWriter sw;
            string s;

            BountyHunter bh = new BountyHunter(sUnitTestDBConnStr);
            bh.GetBountyInfo(DateTime.Parse("4/1/2003"), DateTime.Parse("5/1/2003"));

            sw = new StringWriter();
            bh.Write(sw, false);
            s = sw.ToString();
            Console.Write(s);
            Assert.AreEqual("", s);

            sw = new StringWriter();
            bh.Write(sw, true);
            s = sw.ToString();
            Console.Write(s);
            Assert.AreEqual("", s);

            Console.WriteLine("\r\n-------- Bug32983Test() - Done --------");
        }

        /// <summary>
        /// Validate parameter checking on GetBountyInfo.
        /// </summary>
        [Test]
        [ExpectedException(typeof(ArgumentException))]
        public void BadParamTest()
        {
            Console.WriteLine("-------- BadParamTest() --------\r\n");

            BountyHunter bh = new BountyHunter(sUnitTestDBConnStr);

            try
            {
                bh.GetBountyInfo(DateTime.Parse("6/1/2003"), DateTime.Parse("5/1/2003"));
            }
            finally
            {
                Console.WriteLine("\r\n-------- BadParamTest() - Done --------");
            }
        }

        [Test]
        [ExpectedException(typeof(EmptyCountryListException))]
        public void EmptyCountryListTest()
        {
            Console.WriteLine("-------- EmptyCountryListTest() --------\r\n");

            SqlConnection connXReport;

            connXReport = new SqlConnection(sUnitTestDBConnStr);
            connXReport.Open();

            try
            {
                RunSqlQuery(connXReport, "delete from CountryRegionInfo");

                //  This should throw...
                BountyHunter bh = new BountyHunter(sUnitTestDBConnStr);
            }
            finally
            {
                if(connXReport != null && connXReport.State == ConnectionState.Open)
                {
                    //
                    //  Re-insert the countries we deleted above.
                    //

                    InsertCountry(connXReport, 103, "US", "United States", 1);
                    InsertCountry(connXReport, 74, "NL", "Netherlands", 2);

                    connXReport.Close();
                }

                Console.WriteLine("\r\n-------- EmptyCountryListTest() - Done --------");
            }
        }

        /// <summary>
        /// Empty test case.  Used to verify Setup/TearDown.
        /// </summary>
        [Test]
        public void DummyTest()
        {
            Console.WriteLine("-------- DummyTest() --------\r\n");
            Console.WriteLine("\r\n-------- DummyTest() - Done --------");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BulkUser\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Security.Cryptography.X509Certificates;

namespace BulkUser
{
    class CertPolicy : ICertificatePolicy
    {
        public bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificationProblem)
        {
            return true;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Utility.Initialize();
            RequestParser parser = new RequestParser();
            bool reqParsed = parser.Parse(args);

            if (reqParsed)
            {
                AccountData data = parser.Data;
                new Accounts().CreateAccounts(data);
            }
            else
            {
                //Write usage.
                Utility.LogInfo("---Invalid arguments supplied----");
                Utility.LogInfo("---CORRECT USAGE IS----");
                Utility.LogInfo("/ti:          Time Interval(in sec)");
                Utility.LogInfo("/seed:        Start Seed (>=1)");
                Utility.LogInfo("/noOfAcct:    No of Accounts (int)");
                Utility.LogInfo("/cid:         CountryId");
                Utility.LogInfo("/D:           Domain");
                Utility.LogInfo("/lid:         LanguageId");
                Utility.LogInfo("/P:           Partner Name (less than equal to 5 char)");
                Utility.LogInfo(".........................");
                Utility.LogInfo("For Example-----");
                Utility.LogInfo("BulkUser.exe /ti:5 /seed:1 /cid:103 /lid:1 /P:GOWSA /noOfAcct:5 /D:@xboxlivefamily.com");            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BulkUser\AccountData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace BulkUser
{
    class AccountData
    {
        private int startSeed = 1;
        private int numOfAccounts = 1;
        private int countryId = 103;
        private int languageId = 1;
        private int timeInterval = 5;
        private string partner = string.Empty;
        private string domain = "@xboxlivefamily.com";
        private string folderPath = string.Empty;

        public int StartSeed
        {
            get 
            {
                return startSeed;
            }
            set
            {
                startSeed = value;
            }
        }

        public string FilePath
        {
            get
            {
                if (string.IsNullOrEmpty(this.FolderPath))
                {
                    throw new Exception("FolderPath can't be empty");
                }

                if (string.IsNullOrEmpty(this.Partner))
                {
                    throw new Exception("Partner can't be empty");
                }

                return Path.Combine(this.FolderPath, this.Partner + ".csv");
            }
        }

        public int NumOfAccounts
        {
            get
            {
                return numOfAccounts;
            }
            set
            {
                numOfAccounts = value;
            }
        }

        public int TimeInterval
        {
            get
            {
                return timeInterval;
            }
            set
            {
                timeInterval = value;
            }
        }

        public string FolderPath
        {
            get
            {
                return Utility.FolderPath;
            }
        }

        public string Domain
        {
            get { return this.domain; }
            set { this.domain = value; }
        }

        public string Partner
        {
            get
            {
                return partner;
            }
            set
            {
                partner = value;
            }
        }

        public int CountryId
        {
            get
            {
                return countryId;
            }
            set
            {
                countryId = value;
            }
        }

        public int LanguageId
        {
            get
            {
                return languageId;
            }
            set
            {
                languageId = value;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BulkUser\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 4.0.30319.1.
// 
#pragma warning disable 1591

namespace BulkUser.UserAccountService
{
    using System;
    using System.Web.Services;
    using System.Diagnostics;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class UserAccount : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback CreateBulkUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback LinkUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback LinkedGamerTagsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserSettingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetInfoSharingOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAccountStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserAuthorizationOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateWholesaleAccountOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public UserAccount() {
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event CreateBulkUserCompletedEventHandler CreateBulkUserCompleted;
        
        /// <remarks/>
        public event LinkUserCompletedEventHandler LinkUserCompleted;
        
        /// <remarks/>
        public event LinkedGamerTagsCompletedEventHandler LinkedGamerTagsCompleted;
        
        /// <remarks/>
        public event GetUserSettingsCompletedEventHandler GetUserSettingsCompleted;
        
        /// <remarks/>
        public event SetInfoSharingCompletedEventHandler SetInfoSharingCompleted;
        
        /// <remarks/>
        public event GetAccountStatusCompletedEventHandler GetAccountStatusCompleted;
        
        /// <remarks/>
        public event GetUserAuthorizationCompletedEventHandler GetUserAuthorizationCompleted;
        
        /// <remarks/>
        public event CreateWholesaleAccountCompletedEventHandler CreateWholesaleAccountCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/CreateBulkUser", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public CreateBulkUserResponse CreateBulkUser(CreateBulkUserRequest request) {
            object[] results = this.Invoke("CreateBulkUser", new object[] {
                        request});
            return ((CreateBulkUserResponse)(results[0]));
        }
        
        /// <remarks/>
        public void CreateBulkUserAsync(CreateBulkUserRequest request) {
            this.CreateBulkUserAsync(request, null);
        }
        
        /// <remarks/>
        public void CreateBulkUserAsync(CreateBulkUserRequest request, object userState) {
            if ((this.CreateBulkUserOperationCompleted == null)) {
                this.CreateBulkUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateBulkUserOperationCompleted);
            }
            this.InvokeAsync("CreateBulkUser", new object[] {
                        request}, this.CreateBulkUserOperationCompleted, userState);
        }
        
        private void OnCreateBulkUserOperationCompleted(object arg) {
            if ((this.CreateBulkUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateBulkUserCompleted(this, new CreateBulkUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkUser", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool LinkUser([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
            object[] results = this.Invoke("LinkUser", new object[] {
                        WebID,
                        GamerTag,
                        Owner,
                        PhonePrefix,
                        PhoneNumber,
                        PhoneExtension,
                        PostalCode,
                        CardHolder,
                        CardNumber});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void LinkUserAsync(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
            this.LinkUserAsync(WebID, GamerTag, Owner, PhonePrefix, PhoneNumber, PhoneExtension, PostalCode, CardHolder, CardNumber, null);
        }
        
        /// <remarks/>
        public void LinkUserAsync(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber, object userState) {
            if ((this.LinkUserOperationCompleted == null)) {
                this.LinkUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLinkUserOperationCompleted);
            }
            this.InvokeAsync("LinkUser", new object[] {
                        WebID,
                        GamerTag,
                        Owner,
                        PhonePrefix,
                        PhoneNumber,
                        PhoneExtension,
                        PostalCode,
                        CardHolder,
                        CardNumber}, this.LinkUserOperationCompleted, userState);
        }
        
        private void OnLinkUserOperationCompleted(object arg) {
            if ((this.LinkUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LinkUserCompleted(this, new LinkUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkedGamerTags", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LinkInfo[] LinkedGamerTags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID) {
            object[] results = this.Invoke("LinkedGamerTags", new object[] {
                        WebID});
            return ((LinkInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LinkedGamerTagsAsync(byte[] WebID) {
            this.LinkedGamerTagsAsync(WebID, null);
        }
        
        /// <remarks/>
        public void LinkedGamerTagsAsync(byte[] WebID, object userState) {
            if ((this.LinkedGamerTagsOperationCompleted == null)) {
                this.LinkedGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLinkedGamerTagsOperationCompleted);
            }
            this.InvokeAsync("LinkedGamerTags", new object[] {
                        WebID}, this.LinkedGamerTagsOperationCompleted, userState);
        }
        
        private void OnLinkedGamerTagsOperationCompleted(object arg) {
            if ((this.LinkedGamerTagsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LinkedGamerTagsCompleted(this, new LinkedGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetUserSettings", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint GetUserSettings([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag) {
            object[] results = this.Invoke("GetUserSettings", new object[] {
                        WebID,
                        GamerTag});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserSettingsAsync(byte[] WebID, string GamerTag) {
            this.GetUserSettingsAsync(WebID, GamerTag, null);
        }
        
        /// <remarks/>
        public void GetUserSettingsAsync(byte[] WebID, string GamerTag, object userState) {
            if ((this.GetUserSettingsOperationCompleted == null)) {
                this.GetUserSettingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserSettingsOperationCompleted);
            }
            this.InvokeAsync("GetUserSettings", new object[] {
                        WebID,
                        GamerTag}, this.GetUserSettingsOperationCompleted, userState);
        }
        
        private void OnGetUserSettingsOperationCompleted(object arg) {
            if ((this.GetUserSettingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserSettingsCompleted(this, new GetUserSettingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/SetInfoSharing", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool SetInfoSharing([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo) {
            object[] results = this.Invoke("SetInfoSharing", new object[] {
                        WebID,
                        GamerTag,
                        acceptMSInfo,
                        acceptPartnerInfo});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void SetInfoSharingAsync(byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo) {
            this.SetInfoSharingAsync(WebID, GamerTag, acceptMSInfo, acceptPartnerInfo, null);
        }
        
        /// <remarks/>
        public void SetInfoSharingAsync(byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo, object userState) {
            if ((this.SetInfoSharingOperationCompleted == null)) {
                this.SetInfoSharingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetInfoSharingOperationCompleted);
            }
            this.InvokeAsync("SetInfoSharing", new object[] {
                        WebID,
                        GamerTag,
                        acceptMSInfo,
                        acceptPartnerInfo}, this.SetInfoSharingOperationCompleted, userState);
        }
        
        private void OnSetInfoSharingOperationCompleted(object arg) {
            if ((this.SetInfoSharingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetInfoSharingCompleted(this, new SetInfoSharingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetAccountStatus", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserAccountStatus GetAccountStatus([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag) {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                        WebID,
                        GamerTag});
            return ((UserAccountStatus)(results[0]));
        }
        
        /// <remarks/>
        public void GetAccountStatusAsync(byte[] WebID, string GamerTag) {
            this.GetAccountStatusAsync(WebID, GamerTag, null);
        }
        
        /// <remarks/>
        public void GetAccountStatusAsync(byte[] WebID, string GamerTag, object userState) {
            if ((this.GetAccountStatusOperationCompleted == null)) {
                this.GetAccountStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountStatusOperationCompleted);
            }
            this.InvokeAsync("GetAccountStatus", new object[] {
                        WebID,
                        GamerTag}, this.GetAccountStatusOperationCompleted, userState);
        }
        
        private void OnGetAccountStatusOperationCompleted(object arg) {
            if ((this.GetAccountStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountStatusCompleted(this, new GetAccountStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetUserAuthorization", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserAuthorization GetUserAuthorization(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag) {
            object[] results = this.Invoke("GetUserAuthorization", new object[] {
                        titleId,
                        webId,
                        gamerTag});
            return ((UserAuthorization)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(uint titleId, byte[] webId, string gamerTag) {
            this.GetUserAuthorizationAsync(titleId, webId, gamerTag, null);
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(uint titleId, byte[] webId, string gamerTag, object userState) {
            if ((this.GetUserAuthorizationOperationCompleted == null)) {
                this.GetUserAuthorizationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserAuthorizationOperationCompleted);
            }
            this.InvokeAsync("GetUserAuthorization", new object[] {
                        titleId,
                        webId,
                        gamerTag}, this.GetUserAuthorizationOperationCompleted, userState);
        }
        
        private void OnGetUserAuthorizationOperationCompleted(object arg) {
            if ((this.GetUserAuthorizationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserAuthorizationCompleted(this, new GetUserAuthorizationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/CreateWholesaleAccount", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public CreateWholesaleAccountResponse CreateWholesaleAccount(CreateWholesaleAccountRequest request) {
            object[] results = this.Invoke("CreateWholesaleAccount", new object[] {
                        request});
            return ((CreateWholesaleAccountResponse)(results[0]));
        }
        
        /// <remarks/>
        public void CreateWholesaleAccountAsync(CreateWholesaleAccountRequest request) {
            this.CreateWholesaleAccountAsync(request, null);
        }
        
        /// <remarks/>
        public void CreateWholesaleAccountAsync(CreateWholesaleAccountRequest request, object userState) {
            if ((this.CreateWholesaleAccountOperationCompleted == null)) {
                this.CreateWholesaleAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateWholesaleAccountOperationCompleted);
            }
            this.InvokeAsync("CreateWholesaleAccount", new object[] {
                        request}, this.CreateWholesaleAccountOperationCompleted, userState);
        }
        
        private void OnCreateWholesaleAccountOperationCompleted(object arg) {
            if ((this.CreateWholesaleAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateWholesaleAccountCompleted(this, new CreateWholesaleAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class CreateBulkUserRequest {
        
        private string memberNameField;
        
        private string domainField;
        
        private string partnerField;
        
        private byte countryIdField;
        
        private ushort languageIdField;
        
        private System.DateTime birthdateField;
        
        private string altEmailField;
        
        /// <remarks/>
        public string memberName {
            get {
                return this.memberNameField;
            }
            set {
                this.memberNameField = value;
            }
        }
        
        /// <remarks/>
        public string domain {
            get {
                return this.domainField;
            }
            set {
                this.domainField = value;
            }
        }
        
        /// <remarks/>
        public string partner {
            get {
                return this.partnerField;
            }
            set {
                this.partnerField = value;
            }
        }
        
        /// <remarks/>
        public byte countryId {
            get {
                return this.countryIdField;
            }
            set {
                this.countryIdField = value;
            }
        }
        
        /// <remarks/>
        public ushort languageId {
            get {
                return this.languageIdField;
            }
            set {
                this.languageIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime birthdate {
            get {
                return this.birthdateField;
            }
            set {
                this.birthdateField = value;
            }
        }
        
        /// <remarks/>
        public string altEmail {
            get {
                return this.altEmailField;
            }
            set {
                this.altEmailField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class CreateWholesaleAccountResponse {
        
        private int userPuidHighField;
        
        private int userPuidLowField;
        
        private string gamertagField;
        
        private string passwordField;
        
        /// <remarks/>
        public int userPuidHigh {
            get {
                return this.userPuidHighField;
            }
            set {
                this.userPuidHighField = value;
            }
        }
        
        /// <remarks/>
        public int userPuidLow {
            get {
                return this.userPuidLowField;
            }
            set {
                this.userPuidLowField = value;
            }
        }
        
        /// <remarks/>
        public string gamertag {
            get {
                return this.gamertagField;
            }
            set {
                this.gamertagField = value;
            }
        }
        
        /// <remarks/>
        public string password {
            get {
                return this.passwordField;
            }
            set {
                this.passwordField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class PhoneInfo {
        
        private string phonePrefixField;
        
        private string phoneNumberField;
        
        private string phoneExtensionField;
        
        /// <remarks/>
        public string phonePrefix {
            get {
                return this.phonePrefixField;
            }
            set {
                this.phonePrefixField = value;
            }
        }
        
        /// <remarks/>
        public string phoneNumber {
            get {
                return this.phoneNumberField;
            }
            set {
                this.phoneNumberField = value;
            }
        }
        
        /// <remarks/>
        public string phoneExtension {
            get {
                return this.phoneExtensionField;
            }
            set {
                this.phoneExtensionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class AddressInfo {
        
        private string street1Field;
        
        private string street2Field;
        
        private string cityField;
        
        private string districtField;
        
        private string stateField;
        
        private string postalCodeField;
        
        /// <remarks/>
        public string street1 {
            get {
                return this.street1Field;
            }
            set {
                this.street1Field = value;
            }
        }
        
        /// <remarks/>
        public string street2 {
            get {
                return this.street2Field;
            }
            set {
                this.street2Field = value;
            }
        }
        
        /// <remarks/>
        public string city {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
        /// <remarks/>
        public string district {
            get {
                return this.districtField;
            }
            set {
                this.districtField = value;
            }
        }
        
        /// <remarks/>
        public string state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public string postalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class CreateWholesaleAccountRequest {
        
        private ulong offerIdField;
        
        private string firstNameField;
        
        private string lastNameField;
        
        private AddressInfo addressInfoField;
        
        private PhoneInfo phoneInfoField;
        
        private string emailField;
        
        private byte countryIdField;
        
        private ushort languageIdField;
        
        private System.DateTime birthdateField;
        
        private string memberNameField;
        
        private string externalReferenceIdField;
        
        private byte[] reservedBytesField;
        
        /// <remarks/>
        public ulong offerId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public string firstName {
            get {
                return this.firstNameField;
            }
            set {
                this.firstNameField = value;
            }
        }
        
        /// <remarks/>
        public string lastName {
            get {
                return this.lastNameField;
            }
            set {
                this.lastNameField = value;
            }
        }
        
        /// <remarks/>
        public AddressInfo addressInfo {
            get {
                return this.addressInfoField;
            }
            set {
                this.addressInfoField = value;
            }
        }
        
        /// <remarks/>
        public PhoneInfo phoneInfo {
            get {
                return this.phoneInfoField;
            }
            set {
                this.phoneInfoField = value;
            }
        }
        
        /// <remarks/>
        public string email {
            get {
                return this.emailField;
            }
            set {
                this.emailField = value;
            }
        }
        
        /// <remarks/>
        public byte countryId {
            get {
                return this.countryIdField;
            }
            set {
                this.countryIdField = value;
            }
        }
        
        /// <remarks/>
        public ushort languageId {
            get {
                return this.languageIdField;
            }
            set {
                this.languageIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime birthdate {
            get {
                return this.birthdateField;
            }
            set {
                this.birthdateField = value;
            }
        }
        
        /// <remarks/>
        public string memberName {
            get {
                return this.memberNameField;
            }
            set {
                this.memberNameField = value;
            }
        }
        
        /// <remarks/>
        public string externalReferenceId {
            get {
                return this.externalReferenceIdField;
            }
            set {
                this.externalReferenceIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] reservedBytes {
            get {
                return this.reservedBytesField;
            }
            set {
                this.reservedBytesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class UserAuthorization {
        
        private bool acceptedTermsOfServiceField;
        
        private bool isVoiceBannedField;
        
        private bool isSuspendedField;
        
        private bool[] privilegesField;
        
        private uint[] servicesField;
        
        /// <remarks/>
        public bool acceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool isVoiceBanned {
            get {
                return this.isVoiceBannedField;
            }
            set {
                this.isVoiceBannedField = value;
            }
        }
        
        /// <remarks/>
        public bool isSuspended {
            get {
                return this.isSuspendedField;
            }
            set {
                this.isSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool[] privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint[] services {
            get {
                return this.servicesField;
            }
            set {
                this.servicesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class UserAccountStatus {
        
        private bool acceptMSInfoField;
        
        private bool acceptPartnerInfoField;
        
        private bool forceNameChangeField;
        
        private bool voiceBannedField;
        
        private System.DateTime voiceBannedUntilField;
        
        private bool nicknameBannedField;
        
        private bool accountSuspendedField;
        
        private System.DateTime accountSuspendedUntilField;
        
        /// <remarks/>
        public bool acceptMSInfo {
            get {
                return this.acceptMSInfoField;
            }
            set {
                this.acceptMSInfoField = value;
            }
        }
        
        /// <remarks/>
        public bool acceptPartnerInfo {
            get {
                return this.acceptPartnerInfoField;
            }
            set {
                this.acceptPartnerInfoField = value;
            }
        }
        
        /// <remarks/>
        public bool forceNameChange {
            get {
                return this.forceNameChangeField;
            }
            set {
                this.forceNameChangeField = value;
            }
        }
        
        /// <remarks/>
        public bool voiceBanned {
            get {
                return this.voiceBannedField;
            }
            set {
                this.voiceBannedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime voiceBannedUntil {
            get {
                return this.voiceBannedUntilField;
            }
            set {
                this.voiceBannedUntilField = value;
            }
        }
        
        /// <remarks/>
        public bool nicknameBanned {
            get {
                return this.nicknameBannedField;
            }
            set {
                this.nicknameBannedField = value;
            }
        }
        
        /// <remarks/>
        public bool accountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime accountSuspendedUntil {
            get {
                return this.accountSuspendedUntilField;
            }
            set {
                this.accountSuspendedUntilField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class LinkInfo {
        
        private string gamerTagField;
        
        private bool ownerField;
        
        /// <remarks/>
        public string GamerTag {
            get {
                return this.gamerTagField;
            }
            set {
                this.gamerTagField = value;
            }
        }
        
        /// <remarks/>
        public bool Owner {
            get {
                return this.ownerField;
            }
            set {
                this.ownerField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.1")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class CreateBulkUserResponse {
        
        private string gamertagField;
        
        private string userNameField;
        
        private string passwordField;
        
        private string secretQuestionField;
        
        private string secretAnswerField;
        
        /// <remarks/>
        public string gamertag {
            get {
                return this.gamertagField;
            }
            set {
                this.gamertagField = value;
            }
        }
        
        /// <remarks/>
        public string userName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
        /// <remarks/>
        public string password {
            get {
                return this.passwordField;
            }
            set {
                this.passwordField = value;
            }
        }
        
        /// <remarks/>
        public string secretQuestion {
            get {
                return this.secretQuestionField;
            }
            set {
                this.secretQuestionField = value;
            }
        }
        
        /// <remarks/>
        public string secretAnswer {
            get {
                return this.secretAnswerField;
            }
            set {
                this.secretAnswerField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    public delegate void CreateBulkUserCompletedEventHandler(object sender, CreateBulkUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateBulkUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateBulkUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public CreateBulkUserResponse Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CreateBulkUserResponse)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    public delegate void LinkUserCompletedEventHandler(object sender, LinkUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LinkUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LinkUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    public delegate void LinkedGamerTagsCompletedEventHandler(object sender, LinkedGamerTagsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LinkedGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LinkedGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LinkInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LinkInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    public delegate void GetUserSettingsCompletedEventHandler(object sender, GetUserSettingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserSettingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserSettingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    public delegate void SetInfoSharingCompletedEventHandler(object sender, SetInfoSharingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetInfoSharingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetInfoSharingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    public delegate void GetAccountStatusCompletedEventHandler(object sender, GetAccountStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAccountStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserAccountStatus Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserAccountStatus)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    public delegate void GetUserAuthorizationCompletedEventHandler(object sender, GetUserAuthorizationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserAuthorizationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserAuthorizationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserAuthorization Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserAuthorization)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    public delegate void CreateWholesaleAccountCompletedEventHandler(object sender, CreateWholesaleAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateWholesaleAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateWholesaleAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public CreateWholesaleAccountResponse Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CreateWholesaleAccountResponse)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\makefile.inc ===
$(O)\$(TARGETNAME).$(TARGETEXT).config : app.config
    @echo 
    @echo **** Copy AppConfig file ****
    copy app.config $(O)\$(TARGETNAME).$(TARGETEXT).config
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\tool\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

# Include standard CERT makefile
!INCLUDE ..\..\makefile.inc

#private app data file
$(O)\$(TARGETNAME).data.xml : app.data.xml
    @echo 
    @echo **** Copy app data files ****
    copy app.data.xml $(O)\$(TARGETNAME).data.xml
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BulkUser\Utility.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace BulkUser
{
    class Utility
    {
        public static string FolderPath;
        private static string filePath;
       
        public static void Initialize()
        {
            FolderPath = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().GetModules()[0].FullyQualifiedName);
            filePath = Path.Combine(FolderPath, "logs" + DateTime.Now.ToString().Replace(":","_").Replace("/","_").Replace(" ","") +".txt");
            if (!File.Exists(filePath))
            {
                using (StreamWriter w = File.CreateText(filePath))
                {
                    w.WriteLine("Starting writing logs.");
                    w.Flush();
                    w.Close();
                }
            }
        }

        public static void LogInfo(string message)
        {
            Log(message);
        }

        public static void LogError(string message)
        {
            Log("[ERROR:] " + message);
        }

        private static void Log(string message)
        {
            Console.WriteLine(message);

            using (StreamWriter w = File.AppendText(filePath))
            {
                w.WriteLine(message + " " + DateTime.Now.ToString());
                w.Flush();
                w.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BulkUser\RequestParser.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace BulkUser
{
    class RequestParser
    {
        private Dictionary<string, string> options = new Dictionary<string, string>();

        public AccountData Data
        {
            get;
            set;
        }

        public RequestParser()
        {
            this.Data = new AccountData();
            this.options.Add("/ti", "Time Interval(in sec)");
            this.options.Add("/seed", "Start Seed (>=1)");
            this.options.Add("/noOfAcct", "No of Accounts (int)");
            this.options.Add("/cid", "CountryId");
            this.options.Add("/D", "Domain");
            this.options.Add("/lid", "LanguageId");
            this.options.Add("/P", "Partner Name (less than equal to 5 char)");
        }

        public bool Parse(string[] args)
        {
            bool isValidated = false;

            if (args != null && args.Length > 0)
            {
                foreach (string arg in args)
                {
                    isValidated = ParseKeyValue(arg);
                    if (!isValidated)
                        break;
                }
            }

            return isValidated;
        }

        private string CheckOption(string option)
        {
            if (this.options.ContainsKey(option))
            {
                return option;
            }

            return string.Empty;
        }

        private bool Populate(string option, string value)
        {
            bool isValid = true;
            switch(option)
            {
                case "/ti": isValid = PopulateTimeInterval(value); break;
                case "/seed": isValid = PopulateStartSeed(value); break;
                case "/noOfAcct": isValid = PopulateNoOfAccts(value); break;
                case "/P": Data.Partner = value.Trim(); break;
                case "/D": Data.Domain = value.Trim(); break;
                case "/cid": isValid = PopulateCountryId(value); break;
                case "/lid": isValid = PopulateLanguageId(value); break;
            }

            return isValid;
        }

        private bool ParseKeyValue(string arg)
        {
            bool valid = false;
            if (!string.IsNullOrEmpty(arg))
            {
                string[] arr = arg.Split(':');
                if (arr.Length == 2)
                {
                    string option = CheckOption(arr[0]);
                    if (option != string.Empty)
                    {
                        valid = Populate(option, arr[1]);
                    }
                }
            }

            return valid;
        }

        private bool PopulateNoOfAccts(string value)
        {
            try
            {
                this.Data.NumOfAccounts = Convert.ToInt32(value);
            }
            catch
            {
                Utility.LogError("Unable to Parse Number of Accounts. It should be in (int)");
                return false;
            }

            return true;
        }

        private bool PopulateCountryId(string value)
        {
            try
            {
                this.Data.CountryId = Convert.ToInt32(value);
            }
            catch
            {
                Utility.LogError("Unable to Parse CountryId. It should be in (int)");
                return false;
            }

            return true;
        }

        private bool PopulateLanguageId(string value)
        {
            try
            {
                this.Data.LanguageId = Convert.ToInt32(value);
            }
            catch
            {
                Utility.LogError("Unable to Parse LanguageId. It should be in (int)");
                return false;
            }

            return true;
        }

        private bool PopulateTimeInterval(string value)
        {
            try
            {
                this.Data.TimeInterval = Convert.ToInt32(value);
            }
            catch 
            {
                Utility.LogError("Unable to Parse TimeInterval. It should be in (int)");
                return false;
            }

            return true;
        }

        private bool PopulateStartSeed(string value)
        {
            try
            {
                this.Data.StartSeed = Convert.ToInt32(value);
            }
            catch
            {
                Utility.LogError("Unable to Parse StartSeed. It should be in (int)");
                return false;
            }

            return true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\tool\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\tool\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_setusermsg_none_12.4.56.0_none_0ee3093d0146ebd1
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=setusermsg
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7.manifest
XP_MANIFEST_PATH=manifests\msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7.cat
XP_CATALOG_PATH=manifests\msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7.cat
XP_PAYLOAD_PATH=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=setusermsg,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\tool\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_setusermsg_none_12.4.56.0_none_0ee3093d0146ebd1
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=setusermsg
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7.manifest
XP_MANIFEST_PATH=manifests\msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7.cat
XP_CATALOG_PATH=manifests\msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7.cat
XP_PAYLOAD_PATH=msil_setusermsg_no-public-key_12.4.56.0_x-ww_fab21ed7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=setusermsg,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\tool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\WebRef\WebRefSupApi\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BulkUser\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("BulkUser")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("BulkUser")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("0fb70348-c0da-4c55-989c-a0036db90134")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\tool\main.cs ===
using System;
using System.Xml;
using System.Xml.Serialization;
using System.IO;
using xonline.tools.cert.setusermsg.webref.webrefsupapi ;

namespace xonline.tools.cert.setusermsg 
{

	[XmlRootAttribute("Application_Data")]
	public class ApplicationData
	{
		protected System.String			m_strAppDataFileName;

		[XmlElement(ElementName = "Tool_Path")]
		public System.String m_strMessageToolPath;
		[XmlElement(ElementName = "MessageTool_Name")]
		public System.String m_strMessageToolExe;
		[XmlArrayAttribute("Message_Store_Servers"), XmlArrayItem("Server_RootPath")]
		public System.String[] m_listMessageStoreRoot;

		[XmlElement(ElementName = "Last_MessageID")]
		public System.UInt32 m_uiLastMsgID;
		[XmlElement(ElementName = "Last_MessageText")]
		public System.String m_strLastMessage;

		public ApplicationData() : this( "App.Data.Xml" ){}

		public ApplicationData( System.String strXmlFileName )
		{
			m_uiLastMsgID = 104190000; // stupid constant... 
			m_strAppDataFileName = strXmlFileName;
		}


		public bool LoadFromFile()
		{
			bool bRet = false;

			XmlSerializer serializer = new XmlSerializer(this.GetType());
			serializer.UnknownNode+= new XmlNodeEventHandler(serializer_UnknownNode);
			serializer.UnknownAttribute+= new XmlAttributeEventHandler(serializer_UnknownAttribute);
			
			ApplicationData appData;
			try 
			{	
				/* Use the Deserialize method to restore the object's state with
				data from the XML document. */
				FileStream fs = new FileStream( m_strAppDataFileName, FileMode.Open, FileAccess.ReadWrite, FileShare.Read );
				appData = (ApplicationData) serializer.Deserialize(fs);
				
				fs.Close();

				this.m_strMessageToolPath = appData.m_strMessageToolPath;
				this.m_strMessageToolExe = appData.m_strMessageToolExe;
				this.m_listMessageStoreRoot = appData.m_listMessageStoreRoot;
				this.m_uiLastMsgID = appData.m_uiLastMsgID;
				this.m_strLastMessage = appData.m_strLastMessage;

				bRet = true;
			}
			catch( Exception e )
			{
				System.Console.WriteLine("!!! Exception Encountered: !!!\n{0}", e.ToString() );
			}
			return bRet;
		}

		public bool SaveToFile()
		{
			bool bRet = false;
			XmlSerializer serializer = new XmlSerializer(this.GetType());

			try 
			{
				FileStream fs = new FileStream( m_strAppDataFileName, FileMode.Open, FileAccess.ReadWrite, FileShare.Read );
				serializer.Serialize( fs, this );
				fs.Close();
				bRet = true;
			}
			catch( Exception e )
			{
				Console.WriteLine("!!! Exception Encountered: !!!\n{0}", e.ToString() );
			}
			return bRet;
		}

		protected void serializer_UnknownNode( object sender, XmlNodeEventArgs e )
		{
			Console.WriteLine("Unknown Node:" + e.Name + "\t" + e.Text);
		}

		protected void serializer_UnknownAttribute( object sender, XmlAttributeEventArgs e )
		{
			System.Xml.XmlAttribute attr = e.Attr;
			Console.WriteLine("Unknown attribute " + attr.Name + "='" + attr.Value + "'");
		}

	}

	/// <summary>
	/// Summary description for TheApp.
	/// </summary>
	class TheApp
	{
		static protected System.String m_strAppName;
		static protected System.String m_strExeName;

		static TheApp()
		{
			m_strExeName = System.AppDomain.CurrentDomain.FriendlyName;
			m_strAppName = m_strExeName.Substring(0, m_strExeName.ToLower().LastIndexOf(".exe"));
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: Add code to start application here
			//
			System.DateTime dtTomorrow = System.DateTime.Now.AddDays(2.0);

			System.UInt64 uilPuid;
			System.UInt32 uiMsgId = 1;

			MyCmdLineArgs cmdArgs = new MyCmdLineArgs( m_strExeName );
			ApplicationData appData = new ApplicationData( m_strAppName + ".Data.Xml");
			
			// Load data from AppData settings file
			try
			{
				if( !appData.LoadFromFile() )
				{
					System.Console.WriteLine("Error reading application data file");
					return;
				}
			}
			catch( Exception e )
			{
				System.Console.WriteLine("Exception: {0}", e.ToString() );
			}
			
			// Parse command line args
			if( cmdArgs.ProcessArgs( args ) )
			{
				if( GetUserPuid( cmdArgs.GamerTag, out uilPuid ) )
				{
					System.Text.StringBuilder msgToolArgs;
					System.String strNewMsgFmt = "/addstring /lang:1 /serverpath:{0} /id:{1} /text:\"{2}\"";
					System.String strUsrMsgFmt = "/addusermsg /recommended /id:{0} /user:{1} /expiration:\"{2}\"";

					// If a "message" was specified, then add this to the message store
					if( cmdArgs.Message != null )
					{
						// Lazy checking... if we just did this same message, no need to add
						// it to the store again.

						// We'd be better off storing all messages, but there are other
						// complications with that.
						if( (appData.m_strLastMessage == null) 
							|| (cmdArgs.Message.ToLower() != appData.m_strLastMessage.ToLower()) )
						{
							uiMsgId = ++appData.m_uiLastMsgID;
							appData.m_strLastMessage = cmdArgs.Message;
							System.Console.WriteLine("Adding message '{0}' (Id = {1}) to message store.", cmdArgs.Message, uiMsgId );
							foreach( System.String s in appData.m_listMessageStoreRoot )
							{
								msgToolArgs = new System.Text.StringBuilder();
								msgToolArgs.AppendFormat(strNewMsgFmt, s, uiMsgId, cmdArgs.Message );
								LaunchApp( appData.m_strMessageToolPath, appData.m_strMessageToolExe, msgToolArgs.ToString() );
							}
							if( !appData.SaveToFile() )
							{
								System.Console.WriteLine("Error: Failed to update current 'AppData' file.");
							}
						}
						else
						{
							uiMsgId = appData.m_uiLastMsgID;
						}
					}

					// Add message to user's queue
					msgToolArgs = new System.Text.StringBuilder();
					msgToolArgs.AppendFormat(strUsrMsgFmt , uiMsgId, uilPuid, dtTomorrow.ToShortDateString() );

					System.Console.WriteLine("Adding message ID ({0}) into queue for user: {1}", uiMsgId, cmdArgs.GamerTag );
					LaunchApp( appData.m_strMessageToolPath, appData.m_strMessageToolExe, msgToolArgs.ToString() );
				}
			}
			return;

		}

		static bool GetUserPuid( System.String strGamerTag, out System.UInt64 uilPuid )
		{
			bool bRet = false;
			
			xonline.tools.cert.setusermsg.webref.webrefsupapi.CXSuppApi supApi = new xonline.tools.cert.setusermsg.webref.webrefsupapi.CXSuppApi();
 			System.UInt32 uiResult;

			System.String strErrMsg = "<None>";

			System.Console.WriteLine( "Resolving PUID for user: '{0}'", strGamerTag );
			uiResult = supApi.getPuidFromXName( strGamerTag, out uilPuid, out strErrMsg );
			if( uiResult != 0 )
			{
				System.Console.WriteLine( "Error: Unable to get PUID for user '{0}'.  Result = '{1:x}'.  Message = '{2}'", strGamerTag, uiResult, strErrMsg );
			}
			else
			{
				System.Console.WriteLine( "Success:  User '{0}' has PUID: '{1}'", strGamerTag, uilPuid );
				bRet = true;
			}
			return bRet;
		}

		static bool LaunchApp( System.String strPath, System.String strAppName, System.String strArgs )
		{
			bool bRet = false;
			System.Text.StringBuilder strFullPath = new System.Text.StringBuilder( "" , strPath.Length + strAppName.Length + 1 );

			try
			{
				if( null != strPath ) 
				{
					strFullPath.Append( strPath );
					if( '\\' != strPath[ strPath.Length -1 ] )
					{
						strFullPath.Append( '\\' );
					}
				}
				strFullPath.Append( strAppName );

				//System.Console.WriteLine("Status: Launching application: {0}", strFullPath.ToString() );
				//System.Console.WriteLine("Status:      with paramteters: {0}", strArgs );
				System.Diagnostics.ProcessStartInfo si = new System.Diagnostics.ProcessStartInfo( strFullPath.ToString(), strArgs );
				System.Diagnostics.Process myProc = System.Diagnostics.Process.Start( si );

				if( myProc.WaitForExit( 60000 ) )
				{
					bRet = true;
				}
			}
			catch( Exception e )
			{
				System.Console.WriteLine("Encountered error: {0}", e.ToString() );
			}


			return bRet;
		}
	}

	struct SingleArg
	{
		public System.String m_name;
		public System.String m_value;

		public bool IsValid()
		{
			return( (null != m_name) && (System.String.Empty != m_name) );
		}
		public bool HasValue()
		{
			return( null != m_value && (System.String.Empty != m_value) );
		}
	}


	class CmdLineArgs
	{
		protected SingleArg [] m_inputArgs;
		protected int m_numArgs;

		protected CmdLineArgs()
		{
			m_numArgs = 0;
		}

		public CmdLineArgs( System.String [] inputArgs )
		{
			Parse( inputArgs );
		}

		public int Num
		{
			get
			{
				return m_numArgs;
			}
		}

		public SingleArg this[ int index ]
		{
			get
			{
				if( (0 > index) || (index >= m_numArgs) )
				{
					throw new System.IndexOutOfRangeException();
				}

				return m_inputArgs[index];
			}
		}

		public int IndexOf( System.String strName )
		{
			int iRet = -1;

			if( (null == strName) || (System.String.Empty == strName) )
			{
				throw new IndexOutOfRangeException("Name must be valid");
			}

			if( 0 < m_numArgs )
			{
				int i = 0;
				for( ; i < m_numArgs; ++i )
				{
					if( strName.ToLower() == m_inputArgs[i].m_name.ToLower() )
					{
						break;
					}
				}

				if( (0 <= i) && (i < m_numArgs) )
				{
					iRet = i;
				}
			}
			return iRet;
		}

		protected void Parse(System.String [] inputStrings)
		{
			m_numArgs = inputStrings.Length;
			m_inputArgs = new SingleArg[ m_numArgs ];

			for( int i = 0; i < m_numArgs; ++i )
			{
				System.String cur = inputStrings[i];

				int iColon = 0;
				int iLen = cur.Length;

				if( 0 < iLen )
				{
					// Arguments with "/" or "-"
					if( ('/' == cur[0]) || ('-' == cur[0]) )
					{
						// look for /<name>:<val> syntax
						iColon = cur.IndexOf(':');
						if( 0 == iColon )
						{
							// error invalid arg
							throw new System.ArgumentNullException();
						}
						else if( 0 < iColon )
						{
							m_inputArgs[i].m_value = cur.Substring(iColon + 1, iLen - iColon - 1);
							iLen = iColon;
						}

						m_inputArgs[i].m_name = cur.Substring(1, iLen - 1);
					}
					else
					{
						//Arguments without "/" or "-"
						m_inputArgs[i].m_value = cur;
					}
				}
			}
		}

	}

	class MyCmdLineArgs : CmdLineArgs
	{
		static protected System.String appName = "app.exe";
		public const System.String switchGamerTag = "gamertag";
		public const System.String switchMsg = "message";

		protected System.String m_gamerTag;
		protected System.String m_msg;

		protected MyCmdLineArgs()
		{}
		
		public MyCmdLineArgs( System.String strAppName ) : base()
		{ 
			appName = strAppName;
		}

		public System.String GamerTag
		{
			get
			{
				return m_gamerTag;
			}
		}

		public System.String Message
		{
			get
			{
				return m_msg;
			}
		}

		public bool ProcessArgs( System.String[] inputArgs )
		{
			bool bRet = false;
			try
			{
				Parse( inputArgs );
				if( m_numArgs > 0 )
				{
					int index = IndexOf( switchGamerTag );
					if( index >= 0 )
					{
						System.String tmp = this[index].m_value;
						if( (System.String.Empty != tmp) && ("" != tmp) )
						{
							m_gamerTag = tmp;
							if( m_numArgs == 1)
							{
								bRet = true;
							}
							else if( m_numArgs == 2 )
							{
								index = IndexOf( switchMsg );
								if( index >= 0 )
								{
									tmp = this[index].m_value;
									if( (System.String.Empty != tmp) && ("" != tmp) )
									{
										m_msg = tmp;
										bRet = true;
									}
								}
							}
						}
					}
				}

			}
			catch
			{
				bRet = false;
				System.Console.WriteLine( "ERROR:  Invalid parameters!");
			}
			if( !bRet )
			{
				Usage();
			}

			return bRet;
		}

		static void Usage()
		{			
			System.Console.Write("USAGE:");
			System.Console.WriteLine("\t{0} /{1}:<MyGamerTag> [/{2}:<MyMessage>]", appName, switchGamerTag, switchMsg );
			System.Console.WriteLine("\t<MyGamerTag> = Name of valid XBox Live! user account");
			System.Console.WriteLine("\t<MyMessage>  = [optional] 'Recommended Message' text added to the XBox");
			System.Console.WriteLine("\t               Live! account for user.  If not supplied, the user will");
			System.Console.WriteLine("\t               receive a 'Voice Ban' message in their message queue.");
			System.Console.WriteLine();

			return;
		}
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\WebRef\WebRefSupApi\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__webrefsupapi_2_none_12.4.56.0_none_4f2e1468ca988a0d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_webrefsupapi_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653.manifest
XP_MANIFEST_PATH=manifests\x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653.cat
XP_CATALOG_PATH=manifests\x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653.cat
XP_PAYLOAD_PATH=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_webrefsupapi_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\clientbins\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_clientbin_none_12.4.56.0_none_205dd28ffdbc0382
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=clientbin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2.manifest
XP_MANIFEST_PATH=manifests\x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2.cat
XP_CATALOG_PATH=manifests\x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2.cat
XP_PAYLOAD_PATH=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=clientbin,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\clientbins\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_clientbin_none_12.4.56.0_none_205dd28ffdbc0382
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=clientbin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2.manifest
XP_MANIFEST_PATH=manifests\x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2.cat
XP_CATALOG_PATH=manifests\x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2.cat
XP_PAYLOAD_PATH=x86_clientbin_no-public-key_12.4.56.0_x-ww_ffa305f2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=clientbin,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\WebRef\WebRefSupApi\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__webrefsupapi_2_none_12.4.56.0_none_4f2e1468ca988a0d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_webrefsupapi_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653.manifest
XP_MANIFEST_PATH=manifests\x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653.cat
XP_CATALOG_PATH=manifests\x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653.cat
XP_PAYLOAD_PATH=x86__webrefsupapi_2_no-public-key_12.4.56.0_x-ww_67844653
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_webrefsupapi_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\CommunityWeb\RulesProcessor\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\CommunityWeb\Batch\makefile.inc ===
SQLTARGET:
    -md %_NT386TREE%\tools\CommunityWeb\Batch
    -robocopy . %_NT386TREE%\tools\CommunityWeb\Batch *.cmd /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\CommunityWeb\SQL\makefile.inc ===
SQLTARGET:
    -md %_NT386TREE%\tools\CommunityWeb\SQL
    for /f %i in ('dir /b *.sql') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BUILDVER%/" > %_NT386TREE%\tools\CommunityWeb\SQL\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\CommunityWeb\RulesProcessor\RulesProcessor.cs ===
using System;

namespace CommunityMgr
{
	/// <summary>
	/// Summary description for RulesProcessor.
	/// </summary>
	class RulesProcessor
	{
		[STAThread]
		static void Main(string[] args)
		{

            // cmdline parameters for SQL Server, DB, SOAP, SOAP interval?

            // load rules -- into an array ??
            
            //while more rules

                // get list of PUIDs which would have new feedback for this fdbk type
                // iterate through the list
                    // updating their counts
                    // marking that feedback as processed

                // get list of PUIDs which will have a new EC created
                // iterate through the list, 
                    // adding a new EC
                    // marking that feedback as processed
                    // ?? spawning a thread to do the SOAP calls to update the row with enforcement status, etc.

            // next rule

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cert\SetUserMsg\WebRef\WebRefSupApi\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.tools.cert.setusermsg.webref.webrefsupapi {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="CXSuppApiSoap", Namespace="http://xbox.com/xsuppapi/")]
    public partial class CXSuppApi : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback getPuidFromXNameOperationCompleted;
        
        private System.Threading.SendOrPostCallback getAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback modifyAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback getRelatedAccountsOperationCompleted;
        
        private System.Threading.SendOrPostCallback getSubscriptionCodeStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback getAccountExOperationCompleted;
        
        private System.Threading.SendOrPostCallback getPassportMemberNameOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveGamerPictureOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetUserMottoOperationCompleted;
        
        /// <remarks/>
        public CXSuppApi() {
            this.Url = "http://darrenan3:13010/xsuppapi/cxsuppapi.asmx";
        }
        
        /// <remarks/>
        public event getPuidFromXNameCompletedEventHandler getPuidFromXNameCompleted;
        
        /// <remarks/>
        public event getAccountCompletedEventHandler getAccountCompleted;
        
        /// <remarks/>
        public event modifyAccountCompletedEventHandler modifyAccountCompleted;
        
        /// <remarks/>
        public event getRelatedAccountsCompletedEventHandler getRelatedAccountsCompleted;
        
        /// <remarks/>
        public event getSubscriptionCodeStatusCompletedEventHandler getSubscriptionCodeStatusCompleted;
        
        /// <remarks/>
        public event getAccountExCompletedEventHandler getAccountExCompleted;
        
        /// <remarks/>
        public event getPassportMemberNameCompletedEventHandler getPassportMemberNameCompleted;
        
        /// <remarks/>
        public event RemoveGamerPictureCompletedEventHandler RemoveGamerPictureCompleted;
        
        /// <remarks/>
        public event SetUserMottoCompletedEventHandler SetUserMottoCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getPuidFromXName", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getPuidFromXName(string XName, out ulong puid, out string errorString) {
            object[] results = this.Invoke("getPuidFromXName", new object[] {
                        XName});
            puid = ((ulong)(results[1]));
            errorString = ((string)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetPuidFromXName(string XName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getPuidFromXName", new object[] {
                        XName}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetPuidFromXName(System.IAsyncResult asyncResult, out ulong puid, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            puid = ((ulong)(results[1]));
            errorString = ((string)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getPuidFromXNameAsync(string XName) {
            this.getPuidFromXNameAsync(XName, null);
        }
        
        /// <remarks/>
        public void getPuidFromXNameAsync(string XName, object userState) {
            if ((this.getPuidFromXNameOperationCompleted == null)) {
                this.getPuidFromXNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetPuidFromXNameOperationCompleted);
            }
            this.InvokeAsync("getPuidFromXName", new object[] {
                        XName}, this.getPuidFromXNameOperationCompleted, userState);
        }
        
        private void OngetPuidFromXNameOperationCompleted(object arg) {
            if ((this.getPuidFromXNameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getPuidFromXNameCompleted(this, new getPuidFromXNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getAccount(ulong puid, out bool isAccountOwner, out bool isActive, out bool isLockedOut, out bool isVoiceBanned, out bool isNicknameBanned, out bool mustChangeXName, out string errorString) {
            object[] results = this.Invoke("getAccount", new object[] {
                        puid});
            isAccountOwner = ((bool)(results[1]));
            isActive = ((bool)(results[2]));
            isLockedOut = ((bool)(results[3]));
            isVoiceBanned = ((bool)(results[4]));
            isNicknameBanned = ((bool)(results[5]));
            mustChangeXName = ((bool)(results[6]));
            errorString = ((string)(results[7]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetAccount(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getAccount", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetAccount(System.IAsyncResult asyncResult, out bool isAccountOwner, out bool isActive, out bool isLockedOut, out bool isVoiceBanned, out bool isNicknameBanned, out bool mustChangeXName, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            isAccountOwner = ((bool)(results[1]));
            isActive = ((bool)(results[2]));
            isLockedOut = ((bool)(results[3]));
            isVoiceBanned = ((bool)(results[4]));
            isNicknameBanned = ((bool)(results[5]));
            mustChangeXName = ((bool)(results[6]));
            errorString = ((string)(results[7]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getAccountAsync(ulong puid) {
            this.getAccountAsync(puid, null);
        }
        
        /// <remarks/>
        public void getAccountAsync(ulong puid, object userState) {
            if ((this.getAccountOperationCompleted == null)) {
                this.getAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetAccountOperationCompleted);
            }
            this.InvokeAsync("getAccount", new object[] {
                        puid}, this.getAccountOperationCompleted, userState);
        }
        
        private void OngetAccountOperationCompleted(object arg) {
            if ((this.getAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getAccountCompleted(this, new getAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/modifyAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint modifyAccount(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, out string errorString) {
            object[] results = this.Invoke("modifyAccount", new object[] {
                        puid,
                        isLockedOut,
                        isVoiceBanned,
                        isNicknameBanned,
                        mustChangeXName});
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginmodifyAccount(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("modifyAccount", new object[] {
                        puid,
                        isLockedOut,
                        isVoiceBanned,
                        isNicknameBanned,
                        mustChangeXName}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndmodifyAccount(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void modifyAccountAsync(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName) {
            this.modifyAccountAsync(puid, isLockedOut, isVoiceBanned, isNicknameBanned, mustChangeXName, null);
        }
        
        /// <remarks/>
        public void modifyAccountAsync(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, object userState) {
            if ((this.modifyAccountOperationCompleted == null)) {
                this.modifyAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnmodifyAccountOperationCompleted);
            }
            this.InvokeAsync("modifyAccount", new object[] {
                        puid,
                        isLockedOut,
                        isVoiceBanned,
                        isNicknameBanned,
                        mustChangeXName}, this.modifyAccountOperationCompleted, userState);
        }
        
        private void OnmodifyAccountOperationCompleted(object arg) {
            if ((this.modifyAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.modifyAccountCompleted(this, new modifyAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getRelatedAccounts", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getRelatedAccounts(ulong puid, out ulong[] relatedAccounts, out string[] relatedAccountNames, out string errorString) {
            object[] results = this.Invoke("getRelatedAccounts", new object[] {
                        puid});
            relatedAccounts = ((ulong[])(results[1]));
            relatedAccountNames = ((string[])(results[2]));
            errorString = ((string)(results[3]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetRelatedAccounts(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getRelatedAccounts", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetRelatedAccounts(System.IAsyncResult asyncResult, out ulong[] relatedAccounts, out string[] relatedAccountNames, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            relatedAccounts = ((ulong[])(results[1]));
            relatedAccountNames = ((string[])(results[2]));
            errorString = ((string)(results[3]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getRelatedAccountsAsync(ulong puid) {
            this.getRelatedAccountsAsync(puid, null);
        }
        
        /// <remarks/>
        public void getRelatedAccountsAsync(ulong puid, object userState) {
            if ((this.getRelatedAccountsOperationCompleted == null)) {
                this.getRelatedAccountsOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetRelatedAccountsOperationCompleted);
            }
            this.InvokeAsync("getRelatedAccounts", new object[] {
                        puid}, this.getRelatedAccountsOperationCompleted, userState);
        }
        
        private void OngetRelatedAccountsOperationCompleted(object arg) {
            if ((this.getRelatedAccountsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getRelatedAccountsCompleted(this, new getRelatedAccountsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getSubscriptionCodeStatus", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getSubscriptionCodeStatus(string SubscriptionCode, out bool bValidSubscriptionCode, out bool bUsed, out bool bUsedMaxTimes, out ulong ulLastUser, out string szLastUser, out System.DateTime ftLastUsage, out ulong ulOfferID, out string szOffer, out string errorString) {
            object[] results = this.Invoke("getSubscriptionCodeStatus", new object[] {
                        SubscriptionCode});
            bValidSubscriptionCode = ((bool)(results[1]));
            bUsed = ((bool)(results[2]));
            bUsedMaxTimes = ((bool)(results[3]));
            ulLastUser = ((ulong)(results[4]));
            szLastUser = ((string)(results[5]));
            ftLastUsage = ((System.DateTime)(results[6]));
            ulOfferID = ((ulong)(results[7]));
            szOffer = ((string)(results[8]));
            errorString = ((string)(results[9]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetSubscriptionCodeStatus(string SubscriptionCode, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getSubscriptionCodeStatus", new object[] {
                        SubscriptionCode}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetSubscriptionCodeStatus(System.IAsyncResult asyncResult, out bool bValidSubscriptionCode, out bool bUsed, out bool bUsedMaxTimes, out ulong ulLastUser, out string szLastUser, out System.DateTime ftLastUsage, out ulong ulOfferID, out string szOffer, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            bValidSubscriptionCode = ((bool)(results[1]));
            bUsed = ((bool)(results[2]));
            bUsedMaxTimes = ((bool)(results[3]));
            ulLastUser = ((ulong)(results[4]));
            szLastUser = ((string)(results[5]));
            ftLastUsage = ((System.DateTime)(results[6]));
            ulOfferID = ((ulong)(results[7]));
            szOffer = ((string)(results[8]));
            errorString = ((string)(results[9]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getSubscriptionCodeStatusAsync(string SubscriptionCode) {
            this.getSubscriptionCodeStatusAsync(SubscriptionCode, null);
        }
        
        /// <remarks/>
        public void getSubscriptionCodeStatusAsync(string SubscriptionCode, object userState) {
            if ((this.getSubscriptionCodeStatusOperationCompleted == null)) {
                this.getSubscriptionCodeStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetSubscriptionCodeStatusOperationCompleted);
            }
            this.InvokeAsync("getSubscriptionCodeStatus", new object[] {
                        SubscriptionCode}, this.getSubscriptionCodeStatusOperationCompleted, userState);
        }
        
        private void OngetSubscriptionCodeStatusOperationCompleted(object arg) {
            if ((this.getSubscriptionCodeStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getSubscriptionCodeStatusCompleted(this, new getSubscriptionCodeStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getAccountEx", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getAccountEx(ulong puid, out ulong biOwnerPuid, out System.DateTime dtAccountResumeDate, out int iSuspensionLength, out System.DateTime dtVoiceResumeDate, out int iVoiceBanLength, out bool bMustChangeXName, out System.DateTime dtAcceptedTOS, out byte tiCountryID, out string errorString) {
            object[] results = this.Invoke("getAccountEx", new object[] {
                        puid});
            biOwnerPuid = ((ulong)(results[1]));
            dtAccountResumeDate = ((System.DateTime)(results[2]));
            iSuspensionLength = ((int)(results[3]));
            dtVoiceResumeDate = ((System.DateTime)(results[4]));
            iVoiceBanLength = ((int)(results[5]));
            bMustChangeXName = ((bool)(results[6]));
            dtAcceptedTOS = ((System.DateTime)(results[7]));
            tiCountryID = ((byte)(results[8]));
            errorString = ((string)(results[9]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetAccountEx(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getAccountEx", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetAccountEx(System.IAsyncResult asyncResult, out ulong biOwnerPuid, out System.DateTime dtAccountResumeDate, out int iSuspensionLength, out System.DateTime dtVoiceResumeDate, out int iVoiceBanLength, out bool bMustChangeXName, out System.DateTime dtAcceptedTOS, out byte tiCountryID, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            biOwnerPuid = ((ulong)(results[1]));
            dtAccountResumeDate = ((System.DateTime)(results[2]));
            iSuspensionLength = ((int)(results[3]));
            dtVoiceResumeDate = ((System.DateTime)(results[4]));
            iVoiceBanLength = ((int)(results[5]));
            bMustChangeXName = ((bool)(results[6]));
            dtAcceptedTOS = ((System.DateTime)(results[7]));
            tiCountryID = ((byte)(results[8]));
            errorString = ((string)(results[9]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getAccountExAsync(ulong puid) {
            this.getAccountExAsync(puid, null);
        }
        
        /// <remarks/>
        public void getAccountExAsync(ulong puid, object userState) {
            if ((this.getAccountExOperationCompleted == null)) {
                this.getAccountExOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetAccountExOperationCompleted);
            }
            this.InvokeAsync("getAccountEx", new object[] {
                        puid}, this.getAccountExOperationCompleted, userState);
        }
        
        private void OngetAccountExOperationCompleted(object arg) {
            if ((this.getAccountExCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getAccountExCompleted(this, new getAccountExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getPassportMemberName", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getPassportMemberName(ulong puid, out string userPmn, out string parentPmn, out string errorString) {
            object[] results = this.Invoke("getPassportMemberName", new object[] {
                        puid});
            userPmn = ((string)(results[1]));
            parentPmn = ((string)(results[2]));
            errorString = ((string)(results[3]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetPassportMemberName(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getPassportMemberName", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetPassportMemberName(System.IAsyncResult asyncResult, out string userPmn, out string parentPmn, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            userPmn = ((string)(results[1]));
            parentPmn = ((string)(results[2]));
            errorString = ((string)(results[3]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getPassportMemberNameAsync(ulong puid) {
            this.getPassportMemberNameAsync(puid, null);
        }
        
        /// <remarks/>
        public void getPassportMemberNameAsync(ulong puid, object userState) {
            if ((this.getPassportMemberNameOperationCompleted == null)) {
                this.getPassportMemberNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetPassportMemberNameOperationCompleted);
            }
            this.InvokeAsync("getPassportMemberName", new object[] {
                        puid}, this.getPassportMemberNameOperationCompleted, userState);
        }
        
        private void OngetPassportMemberNameOperationCompleted(object arg) {
            if ((this.getPassportMemberNameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getPassportMemberNameCompleted(this, new getPassportMemberNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/RemoveGamerPicture", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint RemoveGamerPicture(ulong puid, out string errorString) {
            object[] results = this.Invoke("RemoveGamerPicture", new object[] {
                        puid});
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveGamerPicture(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveGamerPicture", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndRemoveGamerPicture(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void RemoveGamerPictureAsync(ulong puid) {
            this.RemoveGamerPictureAsync(puid, null);
        }
        
        /// <remarks/>
        public void RemoveGamerPictureAsync(ulong puid, object userState) {
            if ((this.RemoveGamerPictureOperationCompleted == null)) {
                this.RemoveGamerPictureOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveGamerPictureOperationCompleted);
            }
            this.InvokeAsync("RemoveGamerPicture", new object[] {
                        puid}, this.RemoveGamerPictureOperationCompleted, userState);
        }
        
        private void OnRemoveGamerPictureOperationCompleted(object arg) {
            if ((this.RemoveGamerPictureCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveGamerPictureCompleted(this, new RemoveGamerPictureCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SetUserMotto", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint SetUserMotto(ulong puid, string newMotto, out string errorString) {
            object[] results = this.Invoke("SetUserMotto", new object[] {
                        puid,
                        newMotto});
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetUserMotto(ulong puid, string newMotto, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetUserMotto", new object[] {
                        puid,
                        newMotto}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndSetUserMotto(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void SetUserMottoAsync(ulong puid, string newMotto) {
            this.SetUserMottoAsync(puid, newMotto, null);
        }
        
        /// <remarks/>
        public void SetUserMottoAsync(ulong puid, string newMotto, object userState) {
            if ((this.SetUserMottoOperationCompleted == null)) {
                this.SetUserMottoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserMottoOperationCompleted);
            }
            this.InvokeAsync("SetUserMotto", new object[] {
                        puid,
                        newMotto}, this.SetUserMottoOperationCompleted, userState);
        }
        
        private void OnSetUserMottoOperationCompleted(object arg) {
            if ((this.SetUserMottoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetUserMottoCompleted(this, new SetUserMottoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getPuidFromXNameCompletedEventHandler(object sender, getPuidFromXNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getPuidFromXNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getPuidFromXNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ulong puid {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getAccountCompletedEventHandler(object sender, getAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public bool isAccountOwner {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public bool isActive {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public bool isLockedOut {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public bool isVoiceBanned {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public bool isNicknameBanned {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public bool mustChangeXName {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[6]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[7]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void modifyAccountCompletedEventHandler(object sender, modifyAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class modifyAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal modifyAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getRelatedAccountsCompletedEventHandler(object sender, getRelatedAccountsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getRelatedAccountsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getRelatedAccountsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ulong[] relatedAccounts {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string[] relatedAccountNames {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getSubscriptionCodeStatusCompletedEventHandler(object sender, getSubscriptionCodeStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getSubscriptionCodeStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getSubscriptionCodeStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public bool bValidSubscriptionCode {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public bool bUsed {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public bool bUsedMaxTimes {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public ulong ulLastUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public string szLastUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public System.DateTime ftLastUsage {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[6]));
            }
        }
        
        /// <remarks/>
        public ulong ulOfferID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[7]));
            }
        }
        
        /// <remarks/>
        public string szOffer {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[8]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[9]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getAccountExCompletedEventHandler(object sender, getAccountExCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getAccountExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getAccountExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ulong biOwnerPuid {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime dtAccountResumeDate {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public int iSuspensionLength {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public System.DateTime dtVoiceResumeDate {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int iVoiceBanLength {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public bool bMustChangeXName {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[6]));
            }
        }
        
        /// <remarks/>
        public System.DateTime dtAcceptedTOS {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[7]));
            }
        }
        
        /// <remarks/>
        public byte tiCountryID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((byte)(this.results[8]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[9]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getPassportMemberNameCompletedEventHandler(object sender, getPassportMemberNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getPassportMemberNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getPassportMemberNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string userPmn {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string parentPmn {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveGamerPictureCompletedEventHandler(object sender, RemoveGamerPictureCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RemoveGamerPictureCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RemoveGamerPictureCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetUserMottoCompletedEventHandler(object sender, SetUserMottoCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetUserMottoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetUserMottoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Accessing Voice, Text and Photo Messages\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\EnforcerTest.cs ===
using System;
using System.Collections;
// using XBOX.Utilities.Console;
// using Xbox.Online.Utilities.nUnit;


namespace xonline.tools.communitymgr.quickenforcement 
{
	/// <summary>
	/// Not-so-Test-first pseudocode for Enforcer command line application.
	/// </summary>
	public class EnforcerTest
	{
		public EnforcerTest()
		{

            // Environmental robustness tests 
            //  (possibly their own test suites to have individualize setup/teardown ?)
            // test bad args?
            // test DB doesn't exist
            // test DB no login
            // test DB no permissions
            
            // Application focused testing --> I'm already doing this in the app... 
            // 1. check user state before test
            // 2. take enforcement action
            // 3. check user state after test (confirm we called successfully, not that CUST did the right thing)
            //    for second 2 weeks ban, the only diff will be the ban lift date.

            // Forced Name change
            // Gamertag Complaint
            // FNC when the user is already marked for FNC

            // Lockout enforcements
            //  --> are we able to add nickname to forbidden names list??
            // Nickname Complaints
            // Nickname ban 1 day
            // Nickname ban 1 week
            // Nickname ban 2 weeks
            // Nickname ban 2nd 2 weeks
            // Cheating ban 1 day
            // Cheating ban 1 week
            // Cheating ban 2 weeks
            // Cheating ban 2nd 2 weeks

            // VoiceBan enforcements
            // Swearing ban 1 day
            // Swearing ban 1 week
            // Swearing ban 2 weeks
            // Swearing ban 2nd 2 weeks
                       

		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Accessing Voice, Text and Photo Messages\MsgUtils.cs ===
// MsgUtils.cs
//
//	Utiliy classes and functions used by messaging that dont' have a better place to be
//

using System;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message notification flags in lower 24 bits and message type in upperbyte
	/// </summary>
	public class MsgNotification : WireData
	{
		MsgNotification( uint dw ) { dwTypeAndFlags = dw; }

		public uint dwTypeAndFlags;

		public byte type  {get{ return (byte)( dwTypeAndFlags >> 24 ); }}
		public uint flags {get{ return  dwTypeAndFlags & 0x00FFFFFF;   }}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Utility functions taken from macros found in xonlinep.h
	/// </summary>
	public class MsgUtility
	{
		public static bool IsMessageTransient( uint msgId )
		{
			return 0 != (msgId & XonPresNoti.MSG_ID_TRANSIENT_MESSAGE );
		}

		public static bool IsNotifyMsgType( byte type ) 
		{
			return (type == XonPresNoti.MSG_TYPE_GAME_INVITE);
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Custom Exception class to carry and identify failures due to invalid message properties 
	/// </summary>
	public class InvalidMsgPropertyException : Exception
	{
		public MsgProperty Prop; 
		public InvalidMsgPropertyException( MsgProperty prop ) : base() { Prop = prop; }
		public InvalidMsgPropertyException( MsgProperty prop, string message) : base(message) { Prop = prop; }
		public InvalidMsgPropertyException( MsgProperty prop, string message, Exception inner) : base(message, inner) { Prop = prop; }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Enforcements.cs ===
using System;
using System.Text;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.tools.communitymgr.quickenforcement 
{
	/// <summary>
    /// This class has a number of static, public functions to map between "feedbacktype" (= rule number)
    ///  and the resulting enforcement actions taken for each of these feedback types.
    ///  A future version of the tool will use data-driven mapping 
    ///  e.g. read from a DB what to do when someone gets "enforced" for too many swearing complaints
	/// </summary>
	public class Enforcement
	{

        //100 - Forced Name Change
        public static bool ForcedNameChange(ulong PUID, string Gamertag, CXSuppApi cxcust)
        {
            //FNC = Enforcement Gamertag complaint 
            
            bool owner, active, lockout, voiceban, nickban, fnc, geoFenceExempt;
            bool result = false;
            string errorstring;
            
            // check that user still has gamertag, isn't currently marked for FNC 
            cxcust.getAccount(PUID, out owner, out active, out lockout, out voiceban, out nickban, out fnc, out geoFenceExempt, out errorstring);

            //enforce
            if (!fnc)
            {
                //FNC 'em ..
                fnc = true;
                cxcust.modifyAccount(PUID, lockout, voiceban, nickban, fnc, geoFenceExempt, out errorstring);

                fnc = false;
                //check to confirm user's account is now marked for FNC
                cxcust.getAccount(PUID, out owner, out active, out lockout, out voiceban, out nickban, out fnc, out geoFenceExempt, out errorstring);
                if (fnc)
                {
                    // then they're in the right state ... ;-)
                    result = true;
                }
            } // fnc already?

            return result;

        } // FNC


        //150 - User Motto Change
        public static bool ChangeUserMotto( ulong PUID, string NewMotto, CXSuppApi cxcust )
        {
            bool result = false;
            string errorString;

            //task: it would be nice to verify this change, but it's not essential now
            uint hr = cxcust.SetUserMotto( PUID, NewMotto, out errorString );
            
            if (
//                ( errorString.CompareTo( "No error" ) == 0 ) &&  //I really dislike string return codes
                ( hr == 0 )  //HResult.S_OK 
                )
            {
                //  We decide to only lock out the user if we successfully change the motto
                //  This is as opposed to locking out user regardless of the result of SetUserMotto
                //  as if we run this 2 times, the first time SetUserMotto fails, but succeeds on the 2nd time
                //  then the user ban level would increase.
                result = LockOut(PUID, cxcust);
            }

            return result;

        } //motto


        /// <summary>
        /// 300 - Execute a lockout enforcement against the specified account
        /// </summary>
        /// <param name="PUID"></param>
        /// <param name="cxcust"></param>
        /// <returns></returns>
        public static bool LockOut(ulong PUID, CXSuppApi cxcust)
        {
            //Cheat, Nickname

            bool owner, active, lockout, voiceban, nickban, fnc, geoFenceExempt;
            // prove that we succeed before saying we have
            bool result = false;
            string errorstring;

            cxcust.getAccount(PUID, out owner, out active, out lockout, out voiceban, out nickban, out fnc, out geoFenceExempt, out errorstring);

            //enforce
            if (!lockout)
            {
                //lock 'em out..
                lockout = true;
                cxcust.modifyAccount(PUID, lockout, voiceban, nickban, fnc, geoFenceExempt, out errorstring);

                lockout = false;
                //check to confirm user is locked out
                cxcust.getAccount(PUID, out owner, out active, out lockout, out voiceban, out nickban, out fnc, out geoFenceExempt, out errorstring);
                
                if (lockout)
                {
                    // then they're in the right state ... ;-)
                    result = true;
                }

            } // locked out already
            
            return result;
        } // lockout



        //400 - Voice / Communication ban this user
        public static bool VoiceBan(ulong PUID, CXSuppApi cxcust)
        {
            //Voice

            bool owner, active, lockout, voiceban, nickban, fnc, geoFenceExempt;
            bool result = false;
            string errorstring;

            cxcust.getAccount(PUID, out owner, out active, out lockout, out voiceban, out nickban, out fnc, out geoFenceExempt, out errorstring);

            //enforce
            if (!voiceban && !lockout)
            {
                //ban 'em..
                voiceban = true;

                cxcust.modifyAccount(PUID, lockout, voiceban, nickban, fnc, geoFenceExempt, out errorstring);

                voiceban = false;

                //check to confirm user is voicebanned
                cxcust.getAccount(PUID, out owner, out active, out lockout, out voiceban, out nickban, out fnc, out geoFenceExempt, out errorstring);
                if (voiceban)
                {
                    // then they're in the right state ... ;-)
                    result = true;
                }
            }

            return result;

        } // voiceban


        //500 - Personal Photo removal
        public static bool RemovePersonalPhoto( ulong PUID, CXSuppApi cxcust )
        {

            bool result = false;
            string errorString;

            uint hr = cxcust.RemoveGamerPicture( PUID, out errorString );

            //( errorString.CompareTo("No error" ) == 0 ) &&  //I really dislike strings as returns            
            if ( hr == 0 )  //HResult.S_OK 
            {
                result = true;
                result = result && LockOut( PUID, cxcust );
            }

            return result;

        } // personal photo

        //600 - Personal URL removal
        public static bool RemovePersonalUrl(ulong PUID, string newUrl, CXSuppApi cxcust)
        {
            bool result = false;
            string errorString;

            ProfileItem[] settings = new ProfileItem[1];
            settings[0] = new ProfileItem();
            settings[0].profileItem = ProfileDefs.XPROFILE_GAMERCARD_USER_URL;
            settings[0].profileItemValue = newUrl;
            settings[0].titleId = XOn.XENON_DASH_TITLE_ID;

            uint hr = cxcust.SetUserProfileItems(PUID, settings, out errorString);

            if (hr == 0)  //HResult.S_OK 
            {
                result = true;
            }

            return result;
        }

	} //class enforcement

} // namespace CommunityMgr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Accessing Voice, Text and Photo Messages\Class1.cs ===
using System;
using ServerTestFramework.LiveService.Notification;
using System.IO;
using ServerTestFramework.LiveService.PresNotiCommon ;

namespace StorageLocationConvertor
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Class1
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{

			//TODO: The code should output //vid.67... for the text string below. 
			//			string text = "0x02005000C6090000C703010014AF010000000000440000002F2F7669642E36372F753A303030393030303030303030306130382F32643361393764392D313835322D343731662D343437332D3264306163373534373637325F633600";
			//
			//			string output = "//vid.67/u:0009000000000a08/2d3a97d9-1852-471f-4473-2d0ac7547672_c6";

			if(args.Length!=1)
			{
				Help();
				return;
			}

			string inputTextFile = args[0];
			System.Collections.ArrayList listOfVBProperties = new System.Collections.ArrayList();

			try 
			{
				// Create an instance of StreamReader to read from a file.
				using (StreamReader sr = new StreamReader(inputTextFile)) 
				{
					String line;
					// Read and display lines from the file until the end of 
					// the file is reached.
					while ((line = sr.ReadLine()) != null) 
					{
						if(line == "")
						{
							continue;
						}
						listOfVBProperties.Add(line.Trim());
					}
				}
			}
			catch (Exception e) 
			{
				// Let the user know what went wrong.
				Console.WriteLine("The file could not be read:");
				Console.WriteLine(e.Message);
				return;
			}


			System.Collections.ArrayList outputList = new System.Collections.ArrayList();

			foreach(object vbproperty in listOfVBProperties)
			{

				string s = null;
				string type = null;

				

				byte[] detailsBlob = HexStringToByteArray(vbproperty.ToString());


				MsgDetails details = MsgDetails.CreateBlank();
				
				try
				{
					details.ReadBytes(detailsBlob);
				


					foreach(MsgProperty prop in details.properties)
					{
						if(prop.wPropTag.type == XonPresNoti.MSG_PROP_TYPE_ATTACHMENT)
						{
							MsgPropertyAttachment attachments = details.GetAttachmentProperty(prop.wPropTag.tag);
							switch(prop.wPropTag.tag) 
							{
								case  XonPresNoti.MSG_PROP_VIDEO_DATA:
									s = attachments.url;
									type = "Video";

									
									break;
								case  XonPresNoti.MSG_PROP_PHOTO_DATA:
									
									s = attachments.url;
									type = "Photo";

									
									break;
								case  XonPresNoti.MSG_PROP_VOICE_DATA:
									
									s = attachments.url;
									type = "Voice";

									break;

								default:
									type = "";

									break;

							}

							if(type!="")
							{
								AddToList(s, type, outputList);
							}

						}
					}
				}
				catch(Exception ex)
				{
					Console.WriteLine("Exception thrown: "+ ex);
					Console.WriteLine("Exception thrown on input data: " + vbproperty.ToString());
					
				}

				
			}

			WriteToTextFile(outputList);
		}

		public static void AddToList(string url, string type, System.Collections.ArrayList outputList)
		{
			Console.WriteLine(url +" " +type);
			outputList.Add(url+ " "+ type);
		}

		public static void WriteToTextFile(System.Collections.ArrayList list)
		{

			const string FILE_NAME = "Results.txt";
			if (File.Exists(FILE_NAME)) 
			{
				Console.WriteLine("Overwriting file Results.txt...");
			}
			StreamWriter sr = File.CreateText(FILE_NAME);
			
			foreach(object line in list)
			{

				sr.WriteLine(line.ToString());
			
			}

			sr.Close();
		
			Console.WriteLine("Paths to storage were written in Results.txt...");

		}


		public static void Help()
		{
			Console.WriteLine("This tool takes a text file as input and outputs a text file with the storage location paths for these files. The text file contains text strings (one per line) that come from the vb_properties table in the txt_xmsg_user_messages table. The output is a text file that contains the storage location of the message and the type of message. The output file is always created in the directory that the tool is being run in and is named Results.txt.\n");
			
			Console.WriteLine("Usage: StorageLocationConvertor.exe <vb_properties file>"); 
			return;

		}

		public static byte[] HexStringToByteArray(string s)
		{
			s = s.Trim().ToUpper();

			if (s[0] == '0' && s[1] == 'X')
				s = s.Substring(2);

			int numBytes = s.Length / 2;
			byte[] bytes = new byte[numBytes];

			for (int j = 0;j < numBytes;j++)
			{
				bytes[j] = Byte.Parse(s.Substring(j * 2, 2), System.Globalization.NumberStyles.HexNumber);
			}

			return bytes;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Enforcer.cs ===
namespace xonline.tools.communitymgr.quickenforcement 
{
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.SqlClient;
    using System.IO;
    using System.Security.Principal;
    using System.Text;
    using System.Threading;
    using System.Net.Mail;
       
    
    /// <summary>
    /// Command line tool to send enforcement actions to CUSTAPI from a database.
    /// </summary>
    class Enforcer
    {   

        // private class members
        private static CXSuppApi mycust;
        private static readonly Hashtable argsHash      = new Hashtable();
        private static readonly Hashtable Letters       = new Hashtable();
        private static readonly Hashtable CodeOfConduct = new Hashtable();
        private static StreamWriter logfile    = null;
        private static string logfilepath      = "";

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            //task: one day, with time, I'd like to make this a more general arg list parser
            //      it would tell me if all my required / optional args are what I want them to be
            //      it would be easy to say "A is required", "B is optional" ... 
            //      the big question is how to specify this if I need (A && B) || C  ??
            //      ... till then, these are required args, they must not be null after arg parsing
            // PREPROD TEST location http://131.107.23.212/xsuppapi/cxsuppapi.asmx

            argsHash.Add("SQLE", null);
            argsHash.Add("DBEN", null);
            argsHash.Add("MAIL", null);
            argsHash.Add("CURL", "http://192.168.86.195/xsuppapi/cxsuppapi.asmx");
            argsHash.Add("SMTP", null);
            argsHash.Add("WAIT", null);

            try
            {
                // does this clearly have too few params to be valid?
                if (args.Length <= 2)
                {
                    ShowUsage();
                    return;
                }
                    // need to check the args
                else 
                {
                    if (!CheckArgs(args))
                    {                     
                        ShowUsage();
                        Console.WriteLine("One or more arguments had a problem, please check usage above and try again.");
                        return;
                    }
                }

                if (argsHash["MTST"] != null)
                {
                    MailTest();
                    return;
                }

                // NOTE: you can only write to the logfile after CheckFile()

                if (!CheckPreReqs())
                {
                    Console.WriteLine("");
                    Console.WriteLine("One or more environmental requirements are not present,");
                    Console.WriteLine("  please confirm setup is correct and try again.");
                    return;
                }

                // process rows of data
                ProcessRows();
            }
            catch (Exception e)
            {
                Console.WriteLine("A serious error occurred: " + e.Message);
                Console.WriteLine("Here is the Full Message output");
                Console.WriteLine("{0}", e);
            }
            finally
            {
                if (logfile != null)
                {
                    try 
                    { 
                        logfile.Close();
                        //send report to admin DL
                        SendReport();
                    }
                    catch
                    {
                        Console.WriteLine("Send Report Failed. Review logfile before proceeding.");
                    }
                }
            }
        }


        private static void ShowUsage()
        {
            Console.WriteLine();    
            Console.WriteLine();
            Console.WriteLine("Usage of the Enforcer tool:"); 
            Console.WriteLine("/SQLE <SQLServerName or IP for enforcements> "); 
            Console.WriteLine("/DBEN <Name of the DB where enforcement tasks are> "); 
            Console.WriteLine("/MAIL <fully qualified email destination for enforcement report> "); 
            Console.WriteLine("/SMTP <SMTP Server Name or IP> "); 
            Console.WriteLine("/WAIT <milliseconds to wait between enforcement actions (suggested range is 0 to 30000> ");
            Console.WriteLine("/CURL <URL for CUST service.>");
            Console.WriteLine("      Defaults to Testnet: http://192.168.86.196/xsuppapi/cxsuppapi.asmx > "); 
            Console.WriteLine("/CERT <path to .cer file for client cert>");
            Console.WriteLine("");
            Console.WriteLine("Notes: ");
            Console.WriteLine("    Output file defaults to the current directory.");
            Console.WriteLine("    You must ALSO install the client cert (.pfx) into the store of the user running this tool.");
            Console.WriteLine("");
            Console.WriteLine("Example:"); 
            Console.WriteLine("QuickEnforcement.exe /SQLE mysqlserver /DBEN CommunityMgr /MAIL xlcm@microsoft.com /SMTP smarthost /WAIT 1000 " );
            Console.WriteLine("                     /CURL https://A.B.C.D/xsuppapi/cxsuppapi.asmx /CERT certificate.cer "); 
        }

        /// <summary>
        /// Send all enforcement letters, in all languages to the email
        /// address specified by the /MTST parameter.  This parameter
        /// is formatted as toAddr[:language[:enforcement]]
        /// </summary>
        private static void MailTest()
        {
            string [] testArgs = argsHash["MTST"].ToString().Split(':');
            string toAddr = testArgs[0];
            ArrayList enforcements = new ArrayList();
            ArrayList languages = new ArrayList();

            if (testArgs.Length > 1)
            {
                languages.Add(Int32.Parse(testArgs[1]));
            }
            else
            {
                for (int iCurLanguage = 1; iCurLanguage <= 9; iCurLanguage++)
                {
                    languages.Add(iCurLanguage);
                }
            }

            if (testArgs.Length > 2)
            {
                enforcements.Add(Int32.Parse(testArgs[2]));
            }
            else
            {
                enforcements.Add(100);
                enforcements.Add(150);
                enforcements.Add(300);
                enforcements.Add(400);
                enforcements.Add(500);
            }

            foreach(int enforcement in enforcements)
            {
                foreach (int language in languages)
                {
                    SendMail(toAddr, enforcement, language);
                }
            }
        }

        /// <summary>
        /// Check all necessary command-line arguments are present and well-formed
        /// </summary>
        /// <param name="myargs"></param>
        /// <returns></returns>
        private static bool CheckArgs(string[] myargs)
        {

            // if too few args are supplied, return usage information
            // if the only argument is /?, you'll still get the usage info... 
            //task: how to deal with labels being counted as args?  10 vs 5
            if ((myargs.Length < argsHash.Count)) 
            {
                ShowUsage();
                return false; 
            }
            
            for (int i = 0; i < myargs.Length; i++)
            {
                // process arguments
                // deliberately chose same length arg labels to use nice clean switch
                switch (myargs[i].Substring(0,5).ToUpper())
                {
                    case "/SQLE":
                        argsHash["SQLE"] = myargs[i+1];
                        break;
                    case "/DBEN":
                        argsHash["DBEN"] = myargs[i+1];
                        break;
                    case "/MAIL":
                        argsHash["MAIL"] = myargs[i+1];
                        break;
                    case "/SMTP":
                        argsHash["SMTP"] = myargs[i+1];
                        break;
                    case "/WAIT":
                        argsHash["WAIT"] = myargs[i+1];
                        break;
                    case "/CURL":
                        argsHash["CURL"] = myargs[i+1];
                        break;
                    case "/CERT":
                        argsHash["CERT"] = myargs[i+1];
                        break;
                    case "/MTST":
                        argsHash["MTST"] = myargs[i+1];
                        break;
                    default:
                        Console.WriteLine("An extra parameter {0} encountered.  Parameter ignored", myargs[i].ToUpper());
                        break;
                }
              
                Console.Write(myargs[i].Substring(1) + ":  " );
                if ( i < myargs.Length )
                {
                    Console.WriteLine( myargs[i+1] );

                }
                else
                {
                    Console.WriteLine();
                }
                //skip to the next label
                i++;  

            } // for

            if (Convert.ToInt32(argsHash["WAIT"]) < 0)
            {
                return false;
            }

            //task: any other arg format validity checks to do?

            //check that all "required" args were found in args list
            if (argsHash.ContainsValue(null))
            {
                return false;
            }
            else
            {
                return true;
            }

        }

        /// <summary>
        /// Check that all environment pre-requisites are present for the tool to run successfully.
        /// </summary>
        /// <returns></returns>
        public static bool CheckPreReqs()
        {

            /* ======================================================================  */            
            // Check pre-requisites
            /* ======================================================================  */            

            // GetLetters(103) --> Get the US enforcement letters...
            // Other countries, we'll request them and add them to this "cache" as needed 
            // since they may take up a lot of space... 
            if (
                CheckDB() && 
                GetLetters( 1 ) &&   //english
                GetCodeOfConductLocalizations( CodeOfConduct ) &&
                CheckCertFile( argsHash["CERT"].ToString() ) && 
                CheckCust() && 
                CheckMail() && 
                CheckLogFile() )
            {
                return true;
            }
            else
            {
                return false;
            }

        } // check pre-reqs

        private static bool CheckDB()
        {
            //Test: Can we connect to ENforcements DatabasE?
            object response;

            bool dbworking = true;
            string myQuery = "exec dbo.p_EnforceTestQuery";
            SqlConnection myConnection = new SqlConnection("Data Source=" + argsHash["SQLE"] + ";Trusted_Connection=Yes;Initial Catalog=" + argsHash["DBEN"]);
            Console.WriteLine("Testing connection to Enforcements -- SQLE/DBEN: " + argsHash["SQLE"] + " / " + argsHash["DBEN"]);
            Console.WriteLine("Security Context " + WindowsIdentity.GetCurrent().Name);

            // try reading data from the ENforcements DB
            try 
            {
                SqlCommand myCommand = new SqlCommand(myQuery,myConnection);
                myConnection.Open();
                response = myCommand.ExecuteScalar();
                if (response.ToString() == "connected")
                {
                    Console.WriteLine("Success connecting to Enforcements.");
                }
                else
                {    
                    Console.WriteLine("Incorrect SQL Configuration.");
                    Console.WriteLine("Check stored procs and tables since SQL may be misconfigured. Enforcements SQL Server (SQLE): " + argsHash["SQLE"] + "  Database (DBEN): " + argsHash["DBEN"]);
                    dbworking = false;
                }
            }
            catch (Exception e)
            {
                //task: log an event?
                Console.WriteLine("An exception occurred connecting to SQLE: \r\n  " + argsHash["SQLE"] + " DBEN: " + argsHash["DBEN"] + " Exception text: " + e.Message);
                Console.WriteLine("  Check connectivity and permissions to SQL Server.");
                dbworking = false;
            }
            finally 
            {
                // always call Close when done reading.
                myConnection.Close();
            }

            // now that the CMDB sits on the Reporting server, we do all the
            // processing before the console app even starts... 
            // and there's no need to check for a reporting DB

            return dbworking;

        } // checkdb

        private static bool CheckCust()
        {
            //Test: Can we connect to CUST via SOAP?
            //Test: is CURL a valid URL?
            //... no sense making a call if it doesn't look like a URL to begin with

            bool custconnect = true;

            Console.WriteLine("Attempting Connection to CUST API " + argsHash["CURL"] + ".");

            // check that connection to CUST can initialize
            try 
            {
                ulong PUID;
                string errorstring;

                //will throw a UriFormatException if format is invalid, its not null at this point
                Uri custURL = new Uri( argsHash["CURL"].ToString() );

                mycust = new CXSuppApi( custURL.ToString() );
                mycust.InitializeClientCert( argsHash["CERT"].ToString() );

                //use the first name from the list to be enforced to test CUST
                mycust.getPuidFromXName("", out PUID, out errorstring);
                if (errorstring != "Invalid User")
                {
                    //we weren't able to successfully get info
                    custconnect = false;
                    // Xenon 48295: Gamertag is invalid or for some reason
                    // XSuppAPI failed, so print the error for the user, 
                    // instead of telling them that we couldn't connect to 
                    // XSuppApi, which is an error handled by the catch all
                    // below.
                    // Console.WriteLine("Failure attempting connection to CUST API " + argsHash["CURL"].ToString() + " using gamertag " + testgamer + "...");
                    Console.WriteLine("Failed.");
                    Console.WriteLine("Errorstring: {0}", errorstring);
                }
                else
                {
                    Console.WriteLine("Success in connecting to CUST API.");
                }
            }
            catch ( UriFormatException )
            {
                Console.WriteLine("The CUST URL was invalid.\r\nURL supplied: " + argsHash["CURL"] + "\r\nPlease find correct URL and try again." );
                custconnect = false;
            }
            catch (Exception e)
            {
                Console.WriteLine("An exception occurred initializing the connection to CUST URL: \r\n  " + argsHash["CURL"] + " Exception text: " + e);
                custconnect = false;
            }

            return custconnect;

        } // checkcust

        private static string GetFromAddress()
        {
            //remember that only ChrisMa can send as XLCM@Microsoft.com
#if DEBUG
            string user = WindowsIdentity.GetCurrent().Name;
            user = user.Substring( user.IndexOf( @"\", 0, user.Length ) + 1 );
            return user + "@microsoft.com"; 
#else
            return "xlcm@microsoft.com";
#endif

        }

        private static bool CheckMail()
        {
            // Can we connect to SMTP server?
            bool checkmail = true;

            //task: figure out how to confirm the SMTP relay is out there, like by attempting a TCP connection on port 25 and confirming there's a response
            //      the idea being it will save us having to actually *send* an email... 
            Console.WriteLine("Sending Test mail via SMTP server " + argsHash["SMTP"] + " to " + argsHash["MAIL"] + "...");
            try 
            {
                MailMessage myMsg = new MailMessage();
                myMsg.To.Add(new MailAddress(argsHash["MAIL"].ToString()));

                //to handle new email security 
                myMsg.From = new MailAddress(GetFromAddress());

                Console.WriteLine("Sending test email as " + myMsg.From );
                myMsg.Subject = "Test Message";
                myMsg.Body = "<html><head><style type=\"text/css\">p {color: #0000ff} </style></head><body><H1>Hello, World!</h1><br><p>If you can read this... thank a teacher.</p><br><p>This is <font size=+1>Big Blue Text</font>.</p><p>Nothing great was ever achieved without enthusiasm. Think Blue.</p></body></html>";

                myMsg.BodyEncoding = Encoding.UTF8;
                myMsg.IsBodyHtml = true;

                SmtpClient SmtpMail = new SmtpClient();
                SmtpMail.Host = argsHash["SMTP"].ToString();
                SmtpMail.UseDefaultCredentials = true;
                SmtpMail.Send(myMsg);
                Console.WriteLine("Test email sent.");
            }
            catch (Exception e)
            {
                checkmail = false;
                Console.WriteLine("An error occurred sending mail: \r\n   " + e);
            }

            return checkmail;
        
        } // checkmail

        private static bool CheckLogFile()
        {
            
            bool result = false;

            // Can we write to output file location?
            try
            {
                logfilepath = Directory.GetCurrentDirectory() + "\\EnforcementLog_" + DateTime.Now.Year + "_" + DateTime.Now.Month + "_" + DateTime.Now.Day + "_" + DateTime.Now.Hour + "_" + DateTime.Now.Minute + "_" + DateTime.Now.Second + ".csv";
                logfile = new StreamWriter(logfilepath,true, Encoding.UTF8);
                logfile.AutoFlush = true;
                Console.WriteLine("Creating log file " + logfilepath + "\r\n at: " + Directory.GetCurrentDirectory() + "  ...");
                
                // write to file
                // Date,Time, Action, PUID, Gamertag, Success/Fail
                logfile.WriteLine("Date-Time,Action,PUID,Gamertag,Success/Fail");

                // flush
                logfile.Flush();

                // check file existence
                if (File.Exists(logfilepath))
                {
                    result = true;
                }
            } // try

            catch (Exception e)
            {
                // something went wrong
                Console.WriteLine("An error occurred creating the log file: \r\n" + logfilepath);
                Console.WriteLine("Error was: \r\n  " + e);
                result = false;
            }
            
            return result;
        } // checkfile

        //task: restructure these tests to be part of CheckReady class, 
        //task: perhaps only do certs once?
        private static bool CheckCertFile( string certPath )
        {
            
            bool result;
                
            // Can we write to output file location?
            try
            {
                // check file existence
                if (File.Exists(certPath))
                {
                    result = true;
                }
                else
                {
                    Console.WriteLine("Cert file was not found at: " + certPath );
                    result = false;
                }

            } // try

            catch (Exception e)
            {
                // something went wrong
                Console.WriteLine("An error occurred validating cert file: \r\n" + certPath );
                Console.WriteLine("Error was: \r\n  " + e);
                result = false;
            }
            
            return result;
        } // checkfile


        /// <summary>
        /// Retrieves the letters associated with a specific country.
        /// </summary>
        /// <param name="Language"></param>
        /// <returns></returns>
        private static bool GetLetters(int Language)
        {
            bool getletters = true;

            Console.WriteLine("Attempting to get notification letter for " + Language);

            string myQuery = "exec dbo.p_GetLettersbyLanguage " + Language;
            SqlConnection myConnection = new SqlConnection("Data Source=" + argsHash["SQLE"] + ";Trusted_Connection=Yes;Initial Catalog=" + argsHash["DBEN"]);
            SqlCommand myCommand = new SqlCommand(myQuery, myConnection);

            // start reading data
            try 
            {
                myConnection.Open();
                SqlDataReader LetterReader = myCommand.ExecuteReader(CommandBehavior.SingleResult);
                // move to the first record before retrieving data
                // also returns true if there was a next row to go to...   
                if (LetterReader.Read())
                {
                    // backwards logic brought to you by missing .HasRows in .Net 1.0
                    do
                    {
                        // Letters("countryID_enforcementtype") = Version + Letter 
                        // Letter version added as a hidden HTML comment

                        // siCountryCode, siLetterType, siLatestVersion, nvcLetter
                        int letterLanguage = (int) LetterReader.GetSqlInt32(0);
                        string lettertype = LetterReader.GetSqlInt16(1).ToString();
                        string latestversion = LetterReader.GetSqlInt16(2).ToString();
                        string letter = LetterReader.GetSqlString(3).ToString();
                        Letters[letterLanguage + "_" + lettertype] = "<!-- Letter info: " + letterLanguage + "_" + latestversion + " --> " + letter;
                    } while (LetterReader.Read());

                    Console.WriteLine("Success getting notification letter for " + Language);
                }
                else
                {
                    // letter wasn't there
                    Console.WriteLine("Required Letter for language " + Language + " Is not present in the Enforcement database");
                    getletters = false;

                } // has letter

            } // try
            catch (Exception e)
            {         
                Console.WriteLine("An exception occurred connecting to SQLE: \r\n  " + argsHash["SQLE"] + " DBEN: " + argsHash["DBEN"] + " Exception text: " + e.Message);
                getletters = false;
            }
            finally 
            {
                // always call Close when done reading.
                myConnection.Close();
            }

            return getletters;
        } // getletters

        /// <summary>
        /// Retrieves the enforcement mottos associated with a specific country.
        /// </summary>
        /// <returns></returns>
        private static bool GetCodeOfConductLocalizations( IDictionary codes )
        {
            bool getMottoLocs = true;

            Console.WriteLine( "Attempting to get Code of Conduct localizations..." );

            string myQuery = "exec dbo.p_GetCodeOfConductLocalizations ";
            SqlConnection myConnection = new SqlConnection("Data Source=" + argsHash["SQLE"] + ";Trusted_Connection=Yes;Initial Catalog=" + argsHash["DBEN"]);
            SqlCommand myCommand = new SqlCommand(myQuery, myConnection);

            // start reading data
            try 
            {
                myConnection.Open();
                SqlDataReader mottoReader = myCommand.ExecuteReader( CommandBehavior.SingleResult );
                // move to the first record before retrieving data
                // also returns true if there was a next row to go to...   
                if (mottoReader.Read())
                {
                    do
                    {
                        // languageID, localizedString
                        int languageID = (int) mottoReader.GetSqlInt32(0);
                        //oddly, SqlString does not implicitly cast to string
                        string localizedString = mottoReader.GetSqlString(1).ToString(); 
                        codes[ languageID ] = localizedString;

                    } while ( mottoReader.Read() );

                    Console.WriteLine( "Success getting Code of Conduct localizations for {0} languages.", codes.Count );
                }
                else
                {
                    // letter wasn't there
                    Console.WriteLine( "Localizations for Code of Conduct necessary for Motto Changes are not present " );
                    Console.WriteLine( "  in the Community Manager database.  Please remedy and retry." );
                    getMottoLocs = false;

                } // has letter

            } // try
            catch ( Exception e )
            {
                Console.WriteLine("An exception occurred connecting to SQLE: \r\n  " + argsHash["SQLE"] + " DBEN: " + argsHash["DBEN"] + " Exception text: " + e.Message);
                getMottoLocs = false;
            }
            finally 
            {
                // always call Close when done reading.
                myConnection.Close();
            }

            return getMottoLocs;
        }
        
        /// <summary>
        /// Sends a single enforcement mail.
        /// </summary>
        /// <returns></returns>
        private static void SendMail(string toaddress, int enforcementtype, int language)
        {

            // no return code -- sending mail is best effort, and hard to confirm anyway

            //task: process the text replacements when we're ready to
            String LetterIndex = language + "_" + enforcementtype;

            try 
            {
                MailMessage myMsg = new MailMessage();
                myMsg.To.Add(new MailAddress(toaddress));

                //to handle new email security 
                myMsg.From = new MailAddress(GetFromAddress());

                myMsg.Subject = "Notification of Enforcement Action";

                // don't want to add it by requesting it -- does it have the one we want?
                if (Letters.ContainsKey(LetterIndex))
                {
                    // it's already there... 
                    myMsg.Body = (string) Letters[LetterIndex];
                }
                else  // go fish... 
                {
                    // did we get it from the DB?
                    // we load by country, but an incorrect number results in an attempt to 
                    // reload the country.  Need to make sure we got the letter ID we needed
                    if (GetLetters(language) && Letters.ContainsKey(LetterIndex))
                    {
                        myMsg.Body = (string) Letters[LetterIndex];
                    }
                    else
                    {
                        //write red to the log
                        Console.WriteLine("MISSING: Enforcement letter for: " + LetterIndex + " while sending mail to " + toaddress);

                        //throw an exception
                        throw(new Exception("Missing Enforcement Letter for " + LetterIndex));

                    } // if retrieved correct letter

                } // if (Letters.ContainsKey(LetterIndex))


                myMsg.BodyEncoding = Encoding.UTF8;
                myMsg.IsBodyHtml = true;

                SmtpClient SmtpMail = new SmtpClient();
                SmtpMail.Host = argsHash["SMTP"].ToString();
                SmtpMail.UseDefaultCredentials = true;
                SmtpMail.Send(myMsg);
            } // try

            catch (Exception e)
            {
                //task: drop an event?  write to log??
                Console.WriteLine("While sending mail, an error occurred: " + e.Message);
                throw(e);
            }

        } // sendmail



        private static void SendReport()
        {           
            // send it to xlcm@microsoft.com
            MailMessage myMsg = new MailMessage();
            myMsg.To.Add(new MailAddress(argsHash["MAIL"].ToString()));

            //to handle new email security 
            myMsg.From = new MailAddress(GetFromAddress());

            myMsg.Subject = "Report of Enforcement Actions";
            myMsg.Body = "This is the report of enforcement actions from the most recent batch.";

            myMsg.Attachments.Add(new Attachment(logfilepath));
            myMsg.BodyEncoding = Encoding.UTF8;
            myMsg.IsBodyHtml = true;

            SmtpClient SmtpMail = new SmtpClient();
            SmtpMail.Host = argsHash["SMTP"].ToString();
            SmtpMail.UseDefaultCredentials = true;
            SmtpMail.Send(myMsg);

        } // send report 



        private static bool EnforcementAction( ulong userid, int enforcementtype, string gamertag, int language )
        {
            bool flag;

            try 
            {
                // Xenon 54869: Ensure the language ID is valid
                if( CodeOfConduct[language] == null )
                {
                    Console.WriteLine("Error: Invalid language id.");
                    flag = false;
                }
                else
                {
                    switch ( enforcementtype )
                    {
                        
                        case 100:  //FNC
                            // the enforcement for having an offensive gamertag is...
                            // ya gotta change it... just FNC the account
                            // FNC => Enforcement Gamertag complaint 

                            // logfile.WriteLine("<p>Attempting FNC against PUID: {0} for gamertag: {1} </p>", userid.ToString(), gamertag);
                            flag = Enforcement.ForcedNameChange(userid, gamertag, mycust);
                            break;
                        
                        case 150:  //Motto change
                            flag = Enforcement.ChangeUserMotto(userid, (string) CodeOfConduct[ language ], mycust);
                            break;

                        case 200:  //Nickname
                            // the enforcement for getting too many Nickname complaints is lockout...

                            //logfile.WriteLine("<p>Attempting Nickname-initiated Lockout against PUID: {0} with gamertag: {1} </p>", userid.ToString(), gamertag);
                            flag = Enforcement.LockOut(userid, mycust);
                            break;

                        case 300:  //Cheat - lockout
                            // the enforcement for getting too many cheating complaints is lockout... 

                            //logfile.WriteLine("<p>Attempting Cheating-initiated Lockout against PUID: {0} with gamertag: {1} </p>", userid.ToString(), gamertag);
                            flag = Enforcement.LockOut(userid, mycust);
                            break;

                        case 400:  //Voice
                            //enforce
                            // the enforcement for getting too many swearing complaints is voice ban... 
                            // logfile.WriteLine("<p>Attempting Voiceban against PUID: {0} with gamertag: {1} </p>", userid.ToString(), gamertag);

                            flag = Enforcement.VoiceBan(userid, mycust);
                            break;

                        case 500:  //Personal Photo Removal
                            flag = Enforcement.RemovePersonalPhoto(userid, mycust);
                            break;

                        case 600:
                            flag = Enforcement.RemovePersonalUrl(userid, (string) CodeOfConduct[ language ], mycust);
                            break;

                        default:
                            // there was an error!
                            Console.WriteLine("Error: Ignoring invalid enforcement type {2} against PUID: {0} with gamertag: {1}", userid, gamertag, enforcementtype);
                            flag = false;
                            break;
                    } // switch
                } 

            } // try
            catch ( Exception e )
            {
                Console.WriteLine( "\r\nException occurred: \r\n" + e );
                flag = false;
            }
            
            return flag;
        }

        private static void ProcessEnforcement(
            int enforcementId,
            string gamertag,
            string email
            )
        {
            using (SqlConnection MarkingConnection = new SqlConnection("Data Source=" + argsHash["SQLE"] + ";Trusted_Connection=Yes;Initial Catalog=" + argsHash["DBEN"]))
            {
                MarkingConnection.Open();
                
                using (SqlCommand MarkingCommand = MarkingConnection.CreateCommand())
                {
                    // mark row processed --> being careful not to double punish anyone.
                    MarkingCommand.CommandText = 
                        string.Format("exec dbo.p_ProcessQuickEnforcement {0}, '{1}', '{2}'",
                            enforcementId,
                            gamertag,
                            email);
                    if ((int) MarkingCommand.ExecuteScalar() != 0)
                    {
                        throw new ApplicationException(
                            "\nSerious error attempting to execute: p_ProcessQuickEnforcement.  Check Database Connectivity.");
                    }
                }
            }
        }

        private static void ProcessRows()
        {
            //we don't specify ms to Sleep, we create timespan object... 
            TimeSpan ts = new TimeSpan(0,0,0,0,Convert.ToInt32(argsHash["WAIT"]));
            using(SqlConnection RowsConnection = new SqlConnection("Data Source=" + argsHash["SQLE"] + ";Trusted_Connection=Yes;Initial Catalog=" + argsHash["DBEN"]))
            {
                try
                {
                    // connection used to get the rows to process
                    using (SqlCommand EnforcementCommand = new SqlCommand("exec dbo.p_GetQuickEnforcements ", RowsConnection))
                    {
                        RowsConnection.Open();

                        SqlDataReader EnforcementReader = EnforcementCommand.ExecuteReader(CommandBehavior.SingleResult);

                        // awkward do-while/exception logic brought to you by ".HasRows is missing in .Net 1.0"
                        // don't try to process if we didn't get *any* rows back
                        if (!EnforcementReader.Read())
                        {
                            Console.WriteLine("There are no rows to process");
                            return;
                        }

                        // start outer loop for processing batches of 100
                        do
                        {
                            // start reading data (move to first/next row)
                            do
                            {
                                //   0,          1,        2,             3,      4
                                // EID, vcGamertag, language, siEnforcement, biPUID
                                int enforcementId = EnforcementReader.GetInt32(0);
                                string gamertag = EnforcementReader.GetString(1);
                                int language = EnforcementReader.GetInt32(2);
                                int enforcementType = EnforcementReader.GetInt16(3);
                                ulong puid = (ulong) EnforcementReader.GetInt64(4);

                                //  First make sure we can retrieve the user's email address from passport before 
                                //  we continue.

                                string email, parent, errorString;

                                uint returnCode = mycust.getPassportMemberName(
                                    puid,
                                    out email,
                                    out parent,
                                    out errorString);

                                //  If an error was returned when retrieving the email address, write it to the log
                                //  and skip the enforcement.
                                if (returnCode != 0)
                                {
                                    logfile.Write(
                                        "{0},{1},{2},{3},Failed to retrieve email address\r\n\treturn code = 0x{4}\r\n\terror string = \"{5}\"\r\n",
                                        DateTime.Now, enforcementType, puid, gamertag, returnCode.ToString("08X"),
                                        errorString);
                                    logfile.WriteLine("Skipping enforcement for {0}", gamertag);

                                    ProcessEnforcement(enforcementId, gamertag, "NO EMAIL - SKIPPED");

                                    continue;
                                }

                                //  If the gamer being enforced does not have an email address, write a message
                                //  to the log and skip the enforcement.
                                if (email == null || email.Trim().Length == 0)
                                {
                                    logfile.Write(
                                        "{0},{1},{2},{3},No email address found for this gamertag.",
                                        DateTime.Now, enforcementType, puid, gamertag);
                                    logfile.WriteLine("Skipping enforcement for {0}", gamertag);

                                    ProcessEnforcement(enforcementId, gamertag, "NO EMAIL - SKIPPED");

                                    continue;
                                }

                                // do enforcement
                                if (EnforcementAction(puid, enforcementType, gamertag, language))
                                {
                                    ProcessEnforcement(enforcementId, gamertag, email);

                                    // enforcement was SUCCESSful
                                    // Date,Time, Action, PUID, Gamertag, Success/Fail
                                    logfile.WriteLine("{0},{1},{2},{3},Success", DateTime.Now, enforcementType, puid,
                                                      gamertag);

                                    // FNC 100       --> no email
                                    // Motto 150     --> email
                                    // Nickname 200  --> email
                                    // Cheating 300  --> email
                                    // Swearing 400  --> email
                                    // PersPhoto 500 --> email
                                    if (enforcementType != 100)
                                    {
                                        // send mail - and log the attempt
                                        SendMail(email, enforcementType, language);
                                        // Date,Time, Action, PUID, Gamertag, Success/Fail
                                        logfile.WriteLine("{0},{1},{2},{3},Attempt", DateTime.Now,
                                                          "Attempted to send (" + language + "_" +
                                                          enforcementType + ") letter",
                                                          puid, gamertag);
                                    }
                                }
                                else
                                {
                                    // enforcement FAILED because an incompatible enforcement was already in place
                                    // Date,Time, Action, PUID, Gamertag, Success/Fail
                                    logfile.WriteLine("{0},{1},{2},{3},Failure", DateTime.Now, enforcementType, puid,
                                                      gamertag);

                                    ProcessEnforcement(enforcementId, gamertag, email);
                                } // enforcement worked?

                                // wait for a moment to avoid overwhelming Live
                                // 1000ms should generally be enough, but it's up to the user
                                Thread.Sleep(ts);
                            } while (EnforcementReader.Read()); // while (more rows)

                            logfile.Flush();

                            // now that we've finished that last bunch... 
                            // refresh the Enforcement reader with the next rows
                            EnforcementReader.Close();
                            EnforcementReader = EnforcementCommand.ExecuteReader(CommandBehavior.SingleResult);
                        } while (EnforcementReader.Read()); // while (one more batch of rows)
                    }
                } // try

                catch (ApplicationException ae)
                {
                    // application specific errors... 
                    Console.WriteLine("\n\nAn app exception occurred during processing enforcements. Exception text: " +
                                      ae.Message);
                }
                catch (Exception e)
                {
                    Console.WriteLine("\n\nAn exception occurred during processing enforcements. Exception text: \r\n" +
                                      e + "\r\n");
                }
            }

        } // ProcessRows

    } //class Enforcer

} // namespace Community Manager
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Accessing Voice, Text and Photo Messages\MsgProperty.cs ===
// MsgProperty.cs
//
//	Message property protocol data
//

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message Property tags occupy a word where the upper byte indicates the property's 
	/// data type, and the lower byte indicates a unique identifier for the property.
	/// Property identifiers only need to be unique within a given message type.
	/// </summary>
	public class MsgPropertyTag : WireData
	{
		public ushort tag;

		public const ushort size = 2;

		public static ushort Make( byte type, byte id ) 
		{ 
			return (ushort)( ((ushort)type << 8) | id ); 
		}
			
		public byte id   {get{ return (byte)( tag & 0xff ); }}
		public byte type {get{ return (byte)( tag >> 8 );   }}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message Property contains the tag and a value who's meaning depends on property
	/// type. 
	/// </summary>
	public class MsgProperty : WireData
	{
		// This property's type and unique identifier
		public MsgPropertyTag wPropTag = new MsgPropertyTag();
		
		// Value depends on property type
		public ushort data;     

		public const ushort size = MsgPropertyTag.size + 2;

		// For type XONLINE_MSG_PROP_TYPE_I2
		public ushort wordData 
		{
			get{ return data;  }
			set{ data = value; }
		}
		
		// For type XONLINE_MSG_PROP_TYPE_I1
		public byte byteData 
		{
			get{ return (byte)data; }
			set{ data = value;      }
		}

		// For type XONLINE_MSG_PROP_TYPE_BOOL
		public bool boolData 
		{
			get{ return data == 1;       }
			set{ data = (ushort)(value ? 1 : 0); }
		}
	
		// For all other types the offset from the start of MsgDeatails property data blob 
		public ushort offset 
		{
			get{ return data;  }
			set{ data = value; }
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Format of MSG_PROP_TYPE_BINARY property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyBinary : WireData
	{
		public ushort dataLen;
		public byte[] data;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Format of MSG_PROP_TYPE_ATTACHMENT property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyAttachment : WireData
	{
		public uint   cbAttach;
		public uint   dwFlags;
		public uint   urlLen;
		[WireInfo(NullTerminated=true)] 
		public string url;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Format of MSG_PROP_TYPE_STRING property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyString : WireData
	{
		public ushort sLen;
		public string s;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\CUSTProxyCode.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.312
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.tools.communitymgr.quickenforcement {
    using System.Diagnostics;
    using System.Security.Cryptography.X509Certificates;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="CXSuppApiSoap", Namespace="http://xbox.com/xsuppapi/")]
    public partial class CXSuppApi : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback getPuidFromXNameOperationCompleted;
        
        private System.Threading.SendOrPostCallback getAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback getMachineAccountByConsoleIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback modifyAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback banAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback getRelatedAccountsOperationCompleted;
        
        private System.Threading.SendOrPostCallback getSubscriptionCodeStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback getAccountExOperationCompleted;
        
        private System.Threading.SendOrPostCallback getPassportMemberNameOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveGamerPictureOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetUserMottoOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetUserProfileItemsOperationCompleted;
        
        /// <remarks/>
        public CXSuppApi(string myurl)
        {
            try
            {
                this.Url = myurl;
            }
            catch (Exception e)
            {
                throw (new Exception("Error in CXSuppAPI Constructor. " + e.Message));
            }
        }

        public void InitializeClientCert(string CertFilePath)
        {
            // Add the client certificate to the ClientCertificates property of the proxy class.           
            X509Certificate clientCert = X509Certificate.CreateFromCertFile(CertFilePath);

            //the cert file contains the PUBLIC key, and other info
            //in order to make a request that authenticated to this user, we need to encrypt the message
            //with the PRIVATE key which is in the CryptoStore... 
            this.ClientCertificates.Add(clientCert);

        }
        
        /// <remarks/>
        public event getPuidFromXNameCompletedEventHandler getPuidFromXNameCompleted;
        
        /// <remarks/>
        public event getAccountCompletedEventHandler getAccountCompleted;
        
        /// <remarks/>
        public event getMachineAccountByConsoleIdCompletedEventHandler getMachineAccountByConsoleIdCompleted;
        
        /// <remarks/>
        public event modifyAccountCompletedEventHandler modifyAccountCompleted;
        
        /// <remarks/>
        public event banAccountCompletedEventHandler banAccountCompleted;
        
        /// <remarks/>
        public event getRelatedAccountsCompletedEventHandler getRelatedAccountsCompleted;
        
        /// <remarks/>
        public event getSubscriptionCodeStatusCompletedEventHandler getSubscriptionCodeStatusCompleted;
        
        /// <remarks/>
        public event getAccountExCompletedEventHandler getAccountExCompleted;
        
        /// <remarks/>
        public event getPassportMemberNameCompletedEventHandler getPassportMemberNameCompleted;
        
        /// <remarks/>
        public event RemoveGamerPictureCompletedEventHandler RemoveGamerPictureCompleted;
        
        /// <remarks/>
        public event SetUserMottoCompletedEventHandler SetUserMottoCompleted;
        
        /// <remarks/>
        public event SetUserProfileItemsCompletedEventHandler SetUserProfileItemsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getPuidFromXName", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getPuidFromXName(string XName, out ulong puid, out string errorString) {
            object[] results = this.Invoke("getPuidFromXName", new object[] {
                        XName});
            puid = ((ulong)(results[1]));
            errorString = ((string)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetPuidFromXName(string XName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getPuidFromXName", new object[] {
                        XName}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetPuidFromXName(System.IAsyncResult asyncResult, out ulong puid, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            puid = ((ulong)(results[1]));
            errorString = ((string)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getPuidFromXNameAsync(string XName) {
            this.getPuidFromXNameAsync(XName, null);
        }
        
        /// <remarks/>
        public void getPuidFromXNameAsync(string XName, object userState) {
            if ((this.getPuidFromXNameOperationCompleted == null)) {
                this.getPuidFromXNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetPuidFromXNameOperationCompleted);
            }
            this.InvokeAsync("getPuidFromXName", new object[] {
                        XName}, this.getPuidFromXNameOperationCompleted, userState);
        }
        
        private void OngetPuidFromXNameOperationCompleted(object arg) {
            if ((this.getPuidFromXNameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getPuidFromXNameCompleted(this, new getPuidFromXNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getAccount(ulong puid, out bool isAccountOwner, out bool isActive, out bool isLockedOut, out bool isVoiceBanned, out bool isNicknameBanned, out bool mustChangeXName, out bool isGeofenceExempt, out string errorString) {
            object[] results = this.Invoke("getAccount", new object[] {
                        puid});
            isAccountOwner = ((bool)(results[1]));
            isActive = ((bool)(results[2]));
            isLockedOut = ((bool)(results[3]));
            isVoiceBanned = ((bool)(results[4]));
            isNicknameBanned = ((bool)(results[5]));
            mustChangeXName = ((bool)(results[6]));
            isGeofenceExempt = ((bool)(results[7]));
            errorString = ((string)(results[8]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetAccount(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getAccount", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetAccount(System.IAsyncResult asyncResult, out bool isAccountOwner, out bool isActive, out bool isLockedOut, out bool isVoiceBanned, out bool isNicknameBanned, out bool mustChangeXName, out bool isGeofenceExempt, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            isAccountOwner = ((bool)(results[1]));
            isActive = ((bool)(results[2]));
            isLockedOut = ((bool)(results[3]));
            isVoiceBanned = ((bool)(results[4]));
            isNicknameBanned = ((bool)(results[5]));
            mustChangeXName = ((bool)(results[6]));
            isGeofenceExempt = ((bool)(results[7]));
            errorString = ((string)(results[8]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getAccountAsync(ulong puid) {
            this.getAccountAsync(puid, null);
        }
        
        /// <remarks/>
        public void getAccountAsync(ulong puid, object userState) {
            if ((this.getAccountOperationCompleted == null)) {
                this.getAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetAccountOperationCompleted);
            }
            this.InvokeAsync("getAccount", new object[] {
                        puid}, this.getAccountOperationCompleted, userState);
        }
        
        private void OngetAccountOperationCompleted(object arg) {
            if ((this.getAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getAccountCompleted(this, new getAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getMachineAccountByConsoleId", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getMachineAccountByConsoleId(ulong puid, string consoleId, out bool isLockedOut, out string errorString) {
            object[] results = this.Invoke("getMachineAccountByConsoleId", new object[] {
                        puid,
                        consoleId});
            isLockedOut = ((bool)(results[1]));
            errorString = ((string)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetMachineAccountByConsoleId(ulong puid, string consoleId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getMachineAccountByConsoleId", new object[] {
                        puid,
                        consoleId}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetMachineAccountByConsoleId(System.IAsyncResult asyncResult, out bool isLockedOut, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            isLockedOut = ((bool)(results[1]));
            errorString = ((string)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getMachineAccountByConsoleIdAsync(ulong puid, string consoleId) {
            this.getMachineAccountByConsoleIdAsync(puid, consoleId, null);
        }
        
        /// <remarks/>
        public void getMachineAccountByConsoleIdAsync(ulong puid, string consoleId, object userState) {
            if ((this.getMachineAccountByConsoleIdOperationCompleted == null)) {
                this.getMachineAccountByConsoleIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetMachineAccountByConsoleIdOperationCompleted);
            }
            this.InvokeAsync("getMachineAccountByConsoleId", new object[] {
                        puid,
                        consoleId}, this.getMachineAccountByConsoleIdOperationCompleted, userState);
        }
        
        private void OngetMachineAccountByConsoleIdOperationCompleted(object arg) {
            if ((this.getMachineAccountByConsoleIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getMachineAccountByConsoleIdCompleted(this, new getMachineAccountByConsoleIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/modifyAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint modifyAccount(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, bool isGeoFenceExempt, out string errorString) {
            object[] results = this.Invoke("modifyAccount", new object[] {
                        puid,
                        isLockedOut,
                        isVoiceBanned,
                        isNicknameBanned,
                        mustChangeXName,
                        isGeoFenceExempt});
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginmodifyAccount(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, bool isGeoFenceExempt, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("modifyAccount", new object[] {
                        puid,
                        isLockedOut,
                        isVoiceBanned,
                        isNicknameBanned,
                        mustChangeXName,
                        isGeoFenceExempt}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndmodifyAccount(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void modifyAccountAsync(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, bool isGeoFenceExempt) {
            this.modifyAccountAsync(puid, isLockedOut, isVoiceBanned, isNicknameBanned, mustChangeXName, isGeoFenceExempt, null);
        }
        
        /// <remarks/>
        public void modifyAccountAsync(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, bool isGeoFenceExempt, object userState) {
            if ((this.modifyAccountOperationCompleted == null)) {
                this.modifyAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnmodifyAccountOperationCompleted);
            }
            this.InvokeAsync("modifyAccount", new object[] {
                        puid,
                        isLockedOut,
                        isVoiceBanned,
                        isNicknameBanned,
                        mustChangeXName,
                        isGeoFenceExempt}, this.modifyAccountOperationCompleted, userState);
        }
        
        private void OnmodifyAccountOperationCompleted(object arg) {
            if ((this.modifyAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.modifyAccountCompleted(this, new modifyAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/banAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint banAccount(ulong puid, bool isLockedOut, out string errorString) {
            object[] results = this.Invoke("banAccount", new object[] {
                        puid,
                        isLockedOut});
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginbanAccount(ulong puid, bool isLockedOut, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("banAccount", new object[] {
                        puid,
                        isLockedOut}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndbanAccount(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void banAccountAsync(ulong puid, bool isLockedOut) {
            this.banAccountAsync(puid, isLockedOut, null);
        }
        
        /// <remarks/>
        public void banAccountAsync(ulong puid, bool isLockedOut, object userState) {
            if ((this.banAccountOperationCompleted == null)) {
                this.banAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnbanAccountOperationCompleted);
            }
            this.InvokeAsync("banAccount", new object[] {
                        puid,
                        isLockedOut}, this.banAccountOperationCompleted, userState);
        }
        
        private void OnbanAccountOperationCompleted(object arg) {
            if ((this.banAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.banAccountCompleted(this, new banAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getRelatedAccounts", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getRelatedAccounts(ulong puid, out ulong[] relatedAccounts, out string[] relatedAccountNames, out string errorString) {
            object[] results = this.Invoke("getRelatedAccounts", new object[] {
                        puid});
            relatedAccounts = ((ulong[])(results[1]));
            relatedAccountNames = ((string[])(results[2]));
            errorString = ((string)(results[3]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetRelatedAccounts(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getRelatedAccounts", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetRelatedAccounts(System.IAsyncResult asyncResult, out ulong[] relatedAccounts, out string[] relatedAccountNames, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            relatedAccounts = ((ulong[])(results[1]));
            relatedAccountNames = ((string[])(results[2]));
            errorString = ((string)(results[3]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getRelatedAccountsAsync(ulong puid) {
            this.getRelatedAccountsAsync(puid, null);
        }
        
        /// <remarks/>
        public void getRelatedAccountsAsync(ulong puid, object userState) {
            if ((this.getRelatedAccountsOperationCompleted == null)) {
                this.getRelatedAccountsOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetRelatedAccountsOperationCompleted);
            }
            this.InvokeAsync("getRelatedAccounts", new object[] {
                        puid}, this.getRelatedAccountsOperationCompleted, userState);
        }
        
        private void OngetRelatedAccountsOperationCompleted(object arg) {
            if ((this.getRelatedAccountsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getRelatedAccountsCompleted(this, new getRelatedAccountsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getSubscriptionCodeStatus", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getSubscriptionCodeStatus(string SubscriptionCode, out bool bValidSubscriptionCode, out bool bUsed, out bool bUsedMaxTimes, out ulong ulLastUser, out string szLastUser, out System.DateTime ftLastUsage, out ulong ulOfferID, out string szOffer, out string errorString) {
            object[] results = this.Invoke("getSubscriptionCodeStatus", new object[] {
                        SubscriptionCode});
            bValidSubscriptionCode = ((bool)(results[1]));
            bUsed = ((bool)(results[2]));
            bUsedMaxTimes = ((bool)(results[3]));
            ulLastUser = ((ulong)(results[4]));
            szLastUser = ((string)(results[5]));
            ftLastUsage = ((System.DateTime)(results[6]));
            ulOfferID = ((ulong)(results[7]));
            szOffer = ((string)(results[8]));
            errorString = ((string)(results[9]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetSubscriptionCodeStatus(string SubscriptionCode, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getSubscriptionCodeStatus", new object[] {
                        SubscriptionCode}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetSubscriptionCodeStatus(System.IAsyncResult asyncResult, out bool bValidSubscriptionCode, out bool bUsed, out bool bUsedMaxTimes, out ulong ulLastUser, out string szLastUser, out System.DateTime ftLastUsage, out ulong ulOfferID, out string szOffer, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            bValidSubscriptionCode = ((bool)(results[1]));
            bUsed = ((bool)(results[2]));
            bUsedMaxTimes = ((bool)(results[3]));
            ulLastUser = ((ulong)(results[4]));
            szLastUser = ((string)(results[5]));
            ftLastUsage = ((System.DateTime)(results[6]));
            ulOfferID = ((ulong)(results[7]));
            szOffer = ((string)(results[8]));
            errorString = ((string)(results[9]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getSubscriptionCodeStatusAsync(string SubscriptionCode) {
            this.getSubscriptionCodeStatusAsync(SubscriptionCode, null);
        }
        
        /// <remarks/>
        public void getSubscriptionCodeStatusAsync(string SubscriptionCode, object userState) {
            if ((this.getSubscriptionCodeStatusOperationCompleted == null)) {
                this.getSubscriptionCodeStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetSubscriptionCodeStatusOperationCompleted);
            }
            this.InvokeAsync("getSubscriptionCodeStatus", new object[] {
                        SubscriptionCode}, this.getSubscriptionCodeStatusOperationCompleted, userState);
        }
        
        private void OngetSubscriptionCodeStatusOperationCompleted(object arg) {
            if ((this.getSubscriptionCodeStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getSubscriptionCodeStatusCompleted(this, new getSubscriptionCodeStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getAccountEx", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getAccountEx(ulong puid, out ulong biOwnerPuid, out System.DateTime dtAccountResumeDate, out int iSuspensionLength, out System.DateTime dtVoiceResumeDate, out int iVoiceBanLength, out bool bMustChangeXName, out System.DateTime dtAcceptedTOS, out byte tiCountryID, out bool isGeoFenceExempt, out string errorString) {
            object[] results = this.Invoke("getAccountEx", new object[] {
                        puid});
            biOwnerPuid = ((ulong)(results[1]));
            dtAccountResumeDate = ((System.DateTime)(results[2]));
            iSuspensionLength = ((int)(results[3]));
            dtVoiceResumeDate = ((System.DateTime)(results[4]));
            iVoiceBanLength = ((int)(results[5]));
            bMustChangeXName = ((bool)(results[6]));
            dtAcceptedTOS = ((System.DateTime)(results[7]));
            tiCountryID = ((byte)(results[8]));
            isGeoFenceExempt = ((bool)(results[9]));
            errorString = ((string)(results[10]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetAccountEx(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getAccountEx", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetAccountEx(System.IAsyncResult asyncResult, out ulong biOwnerPuid, out System.DateTime dtAccountResumeDate, out int iSuspensionLength, out System.DateTime dtVoiceResumeDate, out int iVoiceBanLength, out bool bMustChangeXName, out System.DateTime dtAcceptedTOS, out byte tiCountryID, out bool isGeoFenceExempt, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            biOwnerPuid = ((ulong)(results[1]));
            dtAccountResumeDate = ((System.DateTime)(results[2]));
            iSuspensionLength = ((int)(results[3]));
            dtVoiceResumeDate = ((System.DateTime)(results[4]));
            iVoiceBanLength = ((int)(results[5]));
            bMustChangeXName = ((bool)(results[6]));
            dtAcceptedTOS = ((System.DateTime)(results[7]));
            tiCountryID = ((byte)(results[8]));
            isGeoFenceExempt = ((bool)(results[9]));
            errorString = ((string)(results[10]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getAccountExAsync(ulong puid) {
            this.getAccountExAsync(puid, null);
        }
        
        /// <remarks/>
        public void getAccountExAsync(ulong puid, object userState) {
            if ((this.getAccountExOperationCompleted == null)) {
                this.getAccountExOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetAccountExOperationCompleted);
            }
            this.InvokeAsync("getAccountEx", new object[] {
                        puid}, this.getAccountExOperationCompleted, userState);
        }
        
        private void OngetAccountExOperationCompleted(object arg) {
            if ((this.getAccountExCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getAccountExCompleted(this, new getAccountExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getPassportMemberName", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint getPassportMemberName(ulong puid, out string userPmn, out string parentPmn, out string errorString) {
            object[] results = this.Invoke("getPassportMemberName", new object[] {
                        puid});
            userPmn = ((string)(results[1]));
            parentPmn = ((string)(results[2]));
            errorString = ((string)(results[3]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetPassportMemberName(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getPassportMemberName", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndgetPassportMemberName(System.IAsyncResult asyncResult, out string userPmn, out string parentPmn, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            userPmn = ((string)(results[1]));
            parentPmn = ((string)(results[2]));
            errorString = ((string)(results[3]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void getPassportMemberNameAsync(ulong puid) {
            this.getPassportMemberNameAsync(puid, null);
        }
        
        /// <remarks/>
        public void getPassportMemberNameAsync(ulong puid, object userState) {
            if ((this.getPassportMemberNameOperationCompleted == null)) {
                this.getPassportMemberNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetPassportMemberNameOperationCompleted);
            }
            this.InvokeAsync("getPassportMemberName", new object[] {
                        puid}, this.getPassportMemberNameOperationCompleted, userState);
        }
        
        private void OngetPassportMemberNameOperationCompleted(object arg) {
            if ((this.getPassportMemberNameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getPassportMemberNameCompleted(this, new getPassportMemberNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/RemoveGamerPicture", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint RemoveGamerPicture(ulong puid, out string errorString) {
            object[] results = this.Invoke("RemoveGamerPicture", new object[] {
                        puid});
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveGamerPicture(ulong puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveGamerPicture", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndRemoveGamerPicture(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void RemoveGamerPictureAsync(ulong puid) {
            this.RemoveGamerPictureAsync(puid, null);
        }
        
        /// <remarks/>
        public void RemoveGamerPictureAsync(ulong puid, object userState) {
            if ((this.RemoveGamerPictureOperationCompleted == null)) {
                this.RemoveGamerPictureOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveGamerPictureOperationCompleted);
            }
            this.InvokeAsync("RemoveGamerPicture", new object[] {
                        puid}, this.RemoveGamerPictureOperationCompleted, userState);
        }
        
        private void OnRemoveGamerPictureOperationCompleted(object arg) {
            if ((this.RemoveGamerPictureCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveGamerPictureCompleted(this, new RemoveGamerPictureCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SetUserMotto", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint SetUserMotto(ulong puid, string newMotto, out string errorString) {
            object[] results = this.Invoke("SetUserMotto", new object[] {
                        puid,
                        newMotto});
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetUserMotto(ulong puid, string newMotto, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetUserMotto", new object[] {
                        puid,
                        newMotto}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndSetUserMotto(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void SetUserMottoAsync(ulong puid, string newMotto) {
            this.SetUserMottoAsync(puid, newMotto, null);
        }
        
        /// <remarks/>
        public void SetUserMottoAsync(ulong puid, string newMotto, object userState) {
            if ((this.SetUserMottoOperationCompleted == null)) {
                this.SetUserMottoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserMottoOperationCompleted);
            }
            this.InvokeAsync("SetUserMotto", new object[] {
                        puid,
                        newMotto}, this.SetUserMottoOperationCompleted, userState);
        }
        
        private void OnSetUserMottoOperationCompleted(object arg) {
            if ((this.SetUserMottoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetUserMottoCompleted(this, new SetUserMottoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SetUserProfileItems", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint SetUserProfileItems(ulong puid, ProfileItem[] profileItems, out string errorString) {
            object[] results = this.Invoke("SetUserProfileItems", new object[] {
                        puid,
                        profileItems});
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetUserProfileItems(ulong puid, ProfileItem[] profileItems, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetUserProfileItems", new object[] {
                        puid,
                        profileItems}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndSetUserProfileItems(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void SetUserProfileItemsAsync(ulong puid, ProfileItem[] profileItems) {
            this.SetUserProfileItemsAsync(puid, profileItems, null);
        }
        
        /// <remarks/>
        public void SetUserProfileItemsAsync(ulong puid, ProfileItem[] profileItems, object userState) {
            if ((this.SetUserProfileItemsOperationCompleted == null)) {
                this.SetUserProfileItemsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserProfileItemsOperationCompleted);
            }
            this.InvokeAsync("SetUserProfileItems", new object[] {
                        puid,
                        profileItems}, this.SetUserProfileItemsOperationCompleted, userState);
        }
        
        private void OnSetUserProfileItemsOperationCompleted(object arg) {
            if ((this.SetUserProfileItemsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetUserProfileItemsCompleted(this, new SetUserProfileItemsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
    public partial class ProfileItem {
        
        private uint profileItemField;
        
        private string profileItemValueField;
        
        private uint titleIdField;
        
        /// <remarks/>
        public uint profileItem {
            get {
                return this.profileItemField;
            }
            set {
                this.profileItemField = value;
            }
        }
        
        /// <remarks/>
        public string profileItemValue {
            get {
                return this.profileItemValueField;
            }
            set {
                this.profileItemValueField = value;
            }
        }
        
        /// <remarks/>
        public uint titleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getPuidFromXNameCompletedEventHandler(object sender, getPuidFromXNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getPuidFromXNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getPuidFromXNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ulong puid {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getAccountCompletedEventHandler(object sender, getAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public bool isAccountOwner {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public bool isActive {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public bool isLockedOut {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public bool isVoiceBanned {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public bool isNicknameBanned {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public bool mustChangeXName {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[6]));
            }
        }
        
        /// <remarks/>
        public bool isGeofenceExempt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[7]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[8]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getMachineAccountByConsoleIdCompletedEventHandler(object sender, getMachineAccountByConsoleIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getMachineAccountByConsoleIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getMachineAccountByConsoleIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public bool isLockedOut {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void modifyAccountCompletedEventHandler(object sender, modifyAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class modifyAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal modifyAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void banAccountCompletedEventHandler(object sender, banAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class banAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal banAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getRelatedAccountsCompletedEventHandler(object sender, getRelatedAccountsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getRelatedAccountsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getRelatedAccountsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ulong[] relatedAccounts {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string[] relatedAccountNames {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getSubscriptionCodeStatusCompletedEventHandler(object sender, getSubscriptionCodeStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getSubscriptionCodeStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getSubscriptionCodeStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public bool bValidSubscriptionCode {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public bool bUsed {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public bool bUsedMaxTimes {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public ulong ulLastUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public string szLastUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public System.DateTime ftLastUsage {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[6]));
            }
        }
        
        /// <remarks/>
        public ulong ulOfferID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[7]));
            }
        }
        
        /// <remarks/>
        public string szOffer {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[8]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[9]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getAccountExCompletedEventHandler(object sender, getAccountExCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getAccountExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getAccountExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ulong biOwnerPuid {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime dtAccountResumeDate {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public int iSuspensionLength {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public System.DateTime dtVoiceResumeDate {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int iVoiceBanLength {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public bool bMustChangeXName {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[6]));
            }
        }
        
        /// <remarks/>
        public System.DateTime dtAcceptedTOS {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[7]));
            }
        }
        
        /// <remarks/>
        public byte tiCountryID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((byte)(this.results[8]));
            }
        }
        
        /// <remarks/>
        public bool isGeoFenceExempt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[9]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[10]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void getPassportMemberNameCompletedEventHandler(object sender, getPassportMemberNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getPassportMemberNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getPassportMemberNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string userPmn {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string parentPmn {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveGamerPictureCompletedEventHandler(object sender, RemoveGamerPictureCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RemoveGamerPictureCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RemoveGamerPictureCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetUserMottoCompletedEventHandler(object sender, SetUserMottoCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetUserMottoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetUserMottoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetUserProfileItemsCompletedEventHandler(object sender, SetUserProfileItemsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetUserProfileItemsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetUserProfileItemsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string errorString {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Accessing Voice, Text and Photo Messages\MsgDetails.cs ===
// MsgDetails.cs
//
//	Message details protocol data
//

using System;
using System.IO;
using System.Text;
using System.Collections;
using ServerTestFramework.LiveService.PresNotiCommon;


namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message details data (a collection of Message Properties)
	/// </summary>
	public class MsgDetails : WireData
	{
		// Protocol Data
		public ushort        propertiesLen;
		public ushort        propertyDataLen;
		public MsgProperty[] properties;
		public byte[]        propertyData;

		//////////////////////////////////////
		/// <summary>
		/// Better than Size with a capital S that lives in WireData
		/// </summary>
		public ushort size 
		{
			get
			{
				if( _writePropList != null )
				{
					return (ushort)(4 + (_writePropList.Count * MsgProperty.size) + _writeData.Length);
				}
				else
				{
					return (ushort)(4 + (propertiesLen * MsgProperty.size) + propertyDataLen); 
				}
			}
		}

		// Dynamic storage used by "AddProperty" methods.
		private ArrayList    _writePropList = null;
		private MemoryStream _writeData     = null;
		private BinaryWriter _writer        = null;

		//////////////////////////////////////
		/// <summary>
		/// Create a blank set of message details that's ready to have properties added.
		/// Use of static factory, allows default constructor used by input serialization
		/// to not have to create the dynamic storage crap
		/// </summary>
		public static MsgDetails CreateBlank()
		{
			MsgDetails details = new MsgDetails();
			details._writePropList = new ArrayList();
			details._writeData     = new MemoryStream();
			details._writer        = new BinaryWriter( details._writeData, Encoding.UTF8 );
			return details;
		}

		//////////////////////////////////////
		/// <summary>
		/// Output serializion overload that first loads portocol data member variable form
		/// dynamic storage variable use by AddPorperty methods before calling base version
		/// </summary>
		/// <param name="binaryWriter">Output serializer</param>
		public override void WriteStream( BinaryWriter binaryWriter )
		{
			properties   = (MsgProperty[]) _writePropList.ToArray( typeof( MsgProperty ) );
			propertyData = _writeData.ToArray();

			base.WriteStream( binaryWriter );
		}

		//////////////////////////////////////
		/// <summary>
		/// Add an empty property
		/// </summary>
		/// <param name="tag">Property tag</param>
		public void AddProperty( ushort tag ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.data         = 0;

			_writePropList.Add( prop );
		}

		//////////////////////////////////////
		/// <summary>
		/// Add an 8-bit property
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="u8">8-bit value</param>
		public void AddProperty( ushort tag, byte u8 ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.byteData     = u8;

			_writePropList.Add( prop );
		}
		
		//////////////////////////////////////
		/// <summary>
		/// Add a 16-bit property
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="u16">16-bit value</param>
		public void AddProperty( ushort tag, ushort u16 ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.wordData     = u16;

			_writePropList.Add( prop );
		}
		
		//////////////////////////////////////
		/// <summary>
		/// Add a 32-bit property
		/// (Also works for String Server ID's)
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="u32">32-bit value</param>
		public void AddProperty( ushort tag, uint u32 ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.offset       = (ushort)_writeData.Length;

			_writer.Write( u32 );
			_writePropList.Add( prop );
		}
		
		//////////////////////////////////////
		/// <summary>
		/// Add a 64-bit property
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="u64">64-bit value</param>
		public void AddProperty( ushort tag, ulong u64 ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.offset       = (ushort)_writeData.Length;

			_writer.Write( u64 );
			_writePropList.Add( prop );
		}

		//////////////////////////////////////
		/// <summary>
		/// Add a string property
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="sz">String value</param>
		public void AddProperty( ushort tag, string sz ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.offset       = (ushort)_writeData.Length;

			MsgPropertyString propString = new MsgPropertyString();
			propString.s = sz;

			propString.WriteStream( _writer );
			_writePropList.Add( prop );
		}
		
		//////////////////////////////////////
		/// <summary>
		/// Add a DataTime property
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="dt">DateTime value</param>
		public void AddProperty( ushort tag, DateTime dt ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.offset       = (ushort)_writeData.Length;

			_writer.Write( dt.ToFileTime() );
			_writePropList.Add( prop );
		}
		
		//////////////////////////////////////
		/// <summary>
		/// Add a Binary Blob property
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="blob">Binary array</param>
		public void AddProperty( ushort tag, byte[] blob ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.offset       = (ushort)_writeData.Length;

			MsgPropertyBinary propBinary = new MsgPropertyBinary();
			propBinary.data = blob;

			propBinary.WriteStream( _writer );
			_writePropList.Add( prop );
		}
		
		//////////////////////////////////////
		/// <summary>
		/// Add an Attachment property
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="size"></param>
		/// <param name="flags"></param>
		/// <param name="url"></param>
		public void AddProperty( ushort tag, uint size, uint flags, string url ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.offset       = (ushort)_writeData.Length;

			MsgPropertyAttachment propAttachment = new MsgPropertyAttachment();
			propAttachment.cbAttach = size;
			propAttachment.dwFlags	= flags;
			propAttachment.url      = url;

			propAttachment.WriteStream( _writer );
			_writePropList.Add( prop );
		}

		//////////////////////////////////////
		/// <summary>
		/// Add a Bool property
		/// </summary>
		/// <param name="tag">Property tag</param>
		/// <param name="b">Bool value</param>
		public void AddProperty( ushort tag, bool b ) 
		{
			MsgProperty prop  = new MsgProperty();
			prop.wPropTag.tag = tag;
			prop.boolData     = b;

			_writePropList.Add( prop );
		}

		// Wraps binary property data blob for use by "Get" methodes
		private MemoryStream _propData = null;
		private BinaryReader _reader   = null;

		//////////////////////////////////////
		/// <summary>
		/// Input serialization that first loads up the protocol data members then set up 
		/// buffer/reader wrapper for binary data blob
		/// </summary>
		/// <param name="binaryReader">Input serializer</param>
		/// <returns>Self</returns>
		public override WireData ReadStream( BinaryReader binaryReader )
		{
			base.ReadStream( binaryReader );

			_propData = new MemoryStream( propertyData );
			_reader   = new BinaryReader( _propData, Encoding.UTF8 );

			return this;
		}

		//////////////////////////////////////
		/// <summary>
		/// Checks if a Null type property is present.  Because this type of property has no data all
		/// we can do is see if it's there
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>true if property found and type is null</returns>
		public bool HasNullProperty( ushort tag )
		{
			try
			{
				byte index = GetPropertyIndex( tag );
				if( XonPresNoti.MSG_PROP_TYPE_NULL == properties[index].wPropTag.type )
				{
					return true;
				}
			}
			catch( InvalidMsgPropertyException ) {}

			return false;
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the byte value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public byte GetByteProperty( ushort tag )
		{
			return (byte)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I1 );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the word value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public ushort GetWordProperty( ushort tag )
		{
			return (ushort)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I2 );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the dword value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public uint GetDwordProperty( ushort tag )
		{
			return (uint)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I4 );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the qword value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public ulong GetQwordProperty( ushort tag )
		{
			return (ulong)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I8 );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the string value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public string GetStringProperty( ushort tag )
		{
			return (string)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_STRING );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the DateTime value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public DateTime GetDateTimeProperty( ushort tag )
		{
			return (DateTime)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_FILETIME );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the byte array value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public byte[] GetBinaryProperty( ushort tag )
		{
			return (byte[])GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_BINARY );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the Attachment info value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public MsgPropertyAttachment GetAttachmentProperty( ushort tag )
		{
			return (MsgPropertyAttachment)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_ATTACHMENT );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the boolean value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public bool GetBoolProperty( ushort tag )
		{
			return (bool)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_BOOL );
		}

		//////////////////////////////////////
		/// <summary>
		/// Returns the String ID value of the property with the given tag
		/// </summary>
		/// <param name="index">Property tag</param>
		/// <returns>Value of property </returns>
		public uint GetStringIdProperty( ushort tag )
		{
			return (uint)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_STRING_ID );
		}
		
		//////////////////////////////////////
		/// <summary>
		/// Finds the index of a given property tag in the properties list
		/// </summary>
		/// <param name="tag">Property Id</param>
		/// <returns>Index into properties list</returns>
		public byte GetPropertyIndex( ushort tag )
		{
			for( byte i = 0; i < properties.Length; ++i )
			{
				if( properties[i].wPropTag.tag == tag )
				{
					return i;
				}
			}
			
			throw new InvalidMsgPropertyException( null, "Msg Prop "+tag.ToString( "4X" )+" Not Found" );
		}
				
		//////////////////////////////////////
		/// <summary>
		/// Returns the value of the property at given index as the type indicated in the property tag
		/// </summary>
		/// <param name="index">Index into MsgProperty array</param>
		/// <returns>Value of property in type specified by index</returns>
		public object GetPropertyData( byte index, byte type )
		{
			if(	index >= properties.Length )
				throw new ArgumentOutOfRangeException( "index" );

			if( type != properties[index].wPropTag.type )
			{
				throw new InvalidMsgPropertyException( properties[index], 
					"Msg Prop "+properties[index].wPropTag.tag.ToString( "4X" )+" Invalid - "+
					"Expected type: "+type+", Got type: "+properties[index].wPropTag.type );
			}

			switch( type )
			{
				case XonPresNoti.MSG_PROP_TYPE_NULL:
					throw new Exception( "Can't Get Property Data, Null properties have no value" );

				case XonPresNoti.MSG_PROP_TYPE_I1:
					return properties[index].byteData;

				case XonPresNoti.MSG_PROP_TYPE_I2:
					return properties[index].wordData;
				
				case XonPresNoti.MSG_PROP_TYPE_I4:
					_reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
					return _reader.ReadUInt32();
				
				case XonPresNoti.MSG_PROP_TYPE_I8:
					_reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
					return _reader.ReadUInt64();
				
				case XonPresNoti.MSG_PROP_TYPE_STRING:
					_reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
					MsgPropertyString propString = new MsgPropertyString();
					propString.ReadStream( _reader );
					return propString.s;

				case XonPresNoti.MSG_PROP_TYPE_FILETIME:
					_reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
					return DateTime.FromFileTime( _reader.ReadInt64() );

				case XonPresNoti.MSG_PROP_TYPE_BINARY:
					_reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
					MsgPropertyBinary propBinary = new MsgPropertyBinary();
					propBinary.ReadStream( _reader );
					return propBinary.data;

				case XonPresNoti.MSG_PROP_TYPE_ATTACHMENT:
					_reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
					MsgPropertyAttachment propAttach = new MsgPropertyAttachment();
					propAttach.ReadStream( _reader );
					return propAttach;

				case XonPresNoti.MSG_PROP_TYPE_BOOL:
					return properties[index].boolData;

				case XonPresNoti.MSG_PROP_TYPE_STRING_ID:
					_reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
					return _reader.ReadUInt32();

				default:
					throw new Exception( "Can't Get Property, Invalid Prop Type: "+properties[index].wPropTag.type );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Accessing Voice, Text and Photo Messages\XonPresNoti.cs ===
// XonPresNoti.cs
//
//  Duplication of constants found in Presence and Notification
//  sectoin of Xonlinep.h
//
//  NOTE: Does not include internal constants not usefull for testing purposes.

using System;


namespace ServerTestFramework.LiveService.PresNotiCommon
{
    //////////////////////////////////////
    // XonPresNoti 
    //
    //  Container for constants
    //
    public class XonPresNoti 
    {
        // XPNF Service Urls
        // -----------------
        public static readonly string PRESENCE_URL    = "/xpnfront/xpresence.srf";
        public static readonly string NOIFICATION_URL = "/xpnfront/xnotification.srf";
        public static readonly string TEAMS_URL       = "/xpnfront/xteams.srf";
        public static readonly string MESSAGING_URL   = "/xpnfront/xmessaging.srf";
        public static readonly string STATE_URL       = "/xpnfront/state.ashx";
        
        // Current protocol versions
        // -------------------------
        public const uint   CURRENT_XPPROTOCOL_VER = 0x00010000; // v1.0
        public const ushort PresProt_VER_MAJOR = 1;
        public const ushort PresProt_VER_MINOR = 0;

        // Current service versions
        // ------------------------
        public const uint   PRESENCE_SERVICE_VER = 0x00010000; //  1 = XONLINE_PRESENCE_SERVICE
        public const ushort PresServ_VER_MAJOR = 1;
        public const ushort PresServ_VER_MINOR = 0;
        public const uint MESSAGING_SERVICE_VER  = 0x00010000; // 18 = XONLINE_MESSAGING_SERVICE
        public const ushort MessServ_VER_MAJOR = 1;
        public const ushort MessServ_VER_MINOR = 0;
        public const uint TEAM_SERVICE_VER       = 0x00010000; // 19 = XONLINE_TEAM_SERVICE
        public const ushort TeamServ_VER_MAJOR = 1;
        public const ushort TeamServ_VER_MINOR = 0;

        // Presence Message Types (IDs)
        // ----------------------------
        // ... Incoming
        public const uint PMSG_HELLO              = 1000;
        public const uint PMSG_ALIVE              = 1001;
        public const uint PMSG_SYNC               = 1002;
        public const uint PMSG_REFRESH            = 1003;
        public const uint PMSG_ADD                = 1004;
        public const uint PMSG_DELETE             = 1005;
        public const uint PMSG_ACCEPT             = 1006;
        public const uint PMSG_REJECT             = 1007;
        public const uint PMSG_BLOCK              = 1008;
        public const uint PMSG_UNBLOCK            = 1009;
        public const uint PMSG_INVITE             = 1010;
        public const uint PMSG_CANCEL             = 1011;
        public const uint PMSG_INVITE_ANSWER      = 1012;
        public const uint PMSG_NICKNAME           = 1013;
        public const uint PMSG_STATE              = 1014;
        public const uint PMSG_DEAD_XBOX          = 1015;
        public const uint PMSG_DEAD_SG            = 1016;
        public const uint PMSG_DEAD_USER          = 1024;
        public const uint PMSG_ALIVE_2            = 1025;
        public const uint PMSG_WEB_FRIENDS        = 1026;
        public const uint PMSG_WEB_ALIVE          = 1027;
        public const uint PMSG_PEER_SESSION       = 1031;
        public const uint PMSG_TEAM_LIST_TEAMS    = 1032;
        public const uint PMSG_TEAM_LIST_MEMBERS  = 1033;
        public const uint PMSG_TEAM_CREATE        = 1034;
        public const uint PMSG_TEAM_DELETE        = 1035;
        public const uint PMSG_TEAM_REMOVE        = 1036;
        public const uint PMSG_TEAM_MANAGE_TEAM   = 1037;
        public const uint PMSG_TEAM_MANAGE_MEMBER = 1038;
        public const uint PMSG_TEAM_RECRUIT       = 1039;
        public const uint PMSG_TEAM_JOIN          = 1040;
        public const uint PMSG_TEAM_GET_TICKET    = 1041;
        public const uint PMSG_PEER_SUBSCRIBE     = 1042;
        public const uint PMSG_PEER_UNSUBSCRIBE   = 1043;
        public const uint PMSG_WATCH_START        = 1044;
        public const uint PMSG_WATCH_STOP         = 1045;
        public const uint PMSG_ADD_2              = 1046;
        public const uint PMSG_INVITE_2           = 1047;
        public const uint PMSG_ALIVE_INTERNAL     = 1048;
        public const uint PMSG_STATE_2            = 1049;
        public const uint PMSG_GET_STATE          = 1050;
        public const uint PMSG_TEAM_CREATE_TEAM_XE= 1051;
        public const uint PMSG_TEAM_MANAGE_TEAM_XE= 1052;
        public const uint PMSG_ADD_AFFILIATES     = 1053;
        public const uint PMSG_IS_AFFILIATE       = 1054;
        public const uint PMSG_QUERY_AFFILIATES         = 1055;
        public const uint PMSG_GET_PRESENCE_INFO        = 1056;
        public const uint PMSG_PRESENCE_INFO_REPLY             = 1057;
        public const uint PMSG_INVALIDATE_USER          = 1058;
        public const uint PMSG_FIND_USER                = 1059;
        public const uint PMSG_CHECK_TITLE_MESSAGES     = 1060;
        public const uint PMSG_TEAM_LIST_USER_TEAMS     = 1061;
        // ... Outgoing
        public const uint PMSG_ALIVE_REPLY              = 1101;
        public const uint PMSG_SYNC_REPLY               = 1102;
        public const uint PMSG_WEB_FRIENDS_REPLY        = 1103;
        public const uint PMSG_WEB_ALIVE_REPLY          = 1104;
        public const uint PMSG_PEER_SESSION_REPLY       = 1105;
        public const uint PMSG_INVITE_REPLY             = 1106;
        public const uint PMSG_TEAM_LIST_TEAMS_REPLY    = 1107;
        public const uint PMSG_TEAM_LIST_MEMBERS_REPLY  = 1108;
        public const uint PMSG_TEAM_CREATE_REPLY        = 1109;
        public const uint PMSG_TEAM_DELETE_REPLY        = 1110;
        public const uint PMSG_TEAM_REMOVE_REPLY        = 1111;
        public const uint PMSG_TEAM_MANAGE_TEAM_REPLY   = 1112;
        public const uint PMSG_TEAM_MANAGE_MEMBER_REPLY = 1113;
        public const uint PMSG_TEAM_RECRUIT_REPLY       = 1114;
        public const uint PMSG_TEAM_JOIN_REPLY          = 1115;
        public const uint PMSG_TEAM_GET_TICKET_REPLY    = 1116;
        public const uint PMSG_PEER_SUBSCRIBE_REPLY     = 1117;
        public const uint PMSG_PEER_UNSUBSCRIBE_REPLY   = 1118;
        public const uint PMSG_GET_STATE_REPLY          = 1119;
        public const uint PMSG_IS_AFFILIATE_REPLY       = 1120;
        public const uint PMSG_QUERY_AFFILIATES_REPLY   = 1121;
        public const uint PMSG_FIND_USER_REPLY          = 1122;
        public const uint PMSG_CHECK_TITLE_MESSAGES_REPLY= 1123;
        public const uint PMSG_TEAM_LIST_USER_TEAMS_REPLY = 1124;

        // Notification Message Types (IDs)
        // --------------------------------
        // ... Incoming
        public const uint QMSG_HELLO                  = 0;
        public const uint QMSG_USER_INFO              = 1;
        public const uint QMSG_ADD                    = 2;
        public const uint QMSG_DELETE                 = 3;
        public const uint QMSG_DELETE_MATCHES         = 4;
        public const uint QMSG_DEAD_XBOX              = 5;
        public const uint QMSG_DEAD_SG                = 6;
        public const uint QMSG_LIST                   = 7;
        public const uint QMSG_DEQUEUE                = 8;
        public const uint QMSG_DEAD_USER              = 9;
        public const uint QMSG_WEB_USER_INFO          = 10;
        public const uint QMSG_WEB_PRESENCE           = 11;
        public const uint QMSG_WEB_LIST               = 12;
        public const uint QMSG_ENUM_MESSAGES          = 13;
        public const uint QMSG_MESSAGE_SUMMARY        = 14;
        public const uint QMSG_MESSAGE_DETAILS        = 15;
        public const uint QMSG_DELETE_MESSAGE         = 16;
        public const uint QMSG_SEND_MESSAGE           = 17;
        public const uint QMSG_REVOKE_MESSAGE         = 18;
        public const uint QMSG_DELETE_TITLE           = 19;
        public const uint QMSG_ENUM_TITLES            = 20;
        public const uint QMSG_MESSAGE_FLAGS          = 21;
        public const uint QMSG_ENUM_SYSTEM_MESSAGES   = 22;
        public const uint QMSG_SYSTEM_MESSAGE_DETAILS = 23;
        public const uint QMSG_DELETE_SYSTEM_MESSAGE  = 24;
        public const uint QMSG_SEND_SYSTEM_MESSAGE    = 25;
        public const uint QMSG_REVOKE_MESSAGE_EX      = 26;
        public const uint QMSG_ENUM_MESSAGES_2        = 27;
        public const uint QMSG_MESSAGE_SUMMARY_2      = 28;

        // ... Outgoing
        public const uint QMSG_LIST_REPLY                   = 100;
        public const uint QMSG_WEB_LIST_REPLY               = 101;
        public const uint QMSG_ENUM_MESSAGES_REPLY          = 102;
        public const uint QMSG_MESSAGE_SUMMARY_REPLY        = 103;
        public const uint QMSG_MESSAGE_DETAILS_REPLY        = 104;
        public const uint QMSG_DELETE_MESSAGE_REPLY         = 105;
        public const uint QMSG_SEND_MESSAGE_REPLY           = 106;
        public const uint QMSG_REVOKE_MESSAGE_REPLY         = 107;
        public const uint QMSG_DELETE_TITLE_REPLY           = 108;
        public const uint QMSG_ENUM_TITLES_REPLY            = 109;
        public const uint QMSG_MESSAGE_FLAGS_REPLY          = 110;
        public const uint QMSG_ENUM_SYSTEM_MESSAGES_REPLY   = 111;
        public const uint QMSG_SYSTEM_MESSAGE_DETAILS_REPLY = 112;
        public const uint QMSG_DELETE_SYSTEM_MESSAGE_REPLY  = 113;
        public const uint QMSG_SEND_SYSTEM_MESSAGE_REPLY    = 114;
        public const uint QMSG_ENUM_MESSAGES_2_REPLY        = 115;
        public const uint QMSG_MESSAGE_SUMMARY_2_REPLY      = 116;

        // Misc protocol related constants
        // --------------------------------
        // ... Max Sizes
        public const uint MAX_HELLO_DESCRIPTION_LEN  = 80;
        public const uint MAX_ACCTNAME_BYTES         = 16; // XONLINE_GAMERTAG_SIZE
        public const uint MAX_NICKNAME_BYTES         = 24;
        public const uint MAX_TITLE_STATE_BYTES      = 32;
        public const uint MAX_TITLE_DATA_BYTES       = 256;
        public const uint MAX_NOT_TITLE_STATE_BYTES  = 8;  // Constants for spliting state
        public const uint MAX_NOT_NICKNAME_BYTES     = 24; //   into the old notification message
        public const uint MAX_BUDDIES                = 100;
        public const uint MAX_BLOCKS                 = 250;
        public const uint MAX_PEER_SUBSCRIPTIONS     = 1000;
        public const uint MAX_NUM_MESSAGES           = 125;
        public const uint MAX_MESSAGE_RECIPIENTS     = 100;
        public const uint MAX_MESSAGE_DETAILS        = 4096;
        public const uint MAX_RETURNED_USER_TITLES   = 100; // max that QMSG_ENUM_TITLES will return
        public const uint MAX_RETURNED_SYSTEM_MSGS   = 100; // max that QMSG_ENUM_SYSTEM_MESSAGES will return
        public const uint MAX_TRANSIENT_MESSAGES     = 25;
        public const uint MAX_PERSISTENT_MESSAGES    = 100;
        public const uint MAX_TOTAL_USER_MESSAGES    = (MAX_TRANSIENT_MESSAGES + MAX_PERSISTENT_MESSAGES);
        public const uint MAX_SYSTEM_MSG_DESC_LEN    = 64;
        public const uint MAX_TEAM_COUNT             = 8;
        public const uint MAX_TEAM_RECRUIT_COUNT     = 100;
        public const uint MAX_TEAM_MEMBER_COUNT      = 64;
        public const uint MIN_MAX_TEAM_MEMBER_COUNT  = 2;
        public const uint MAX_TEAM_NAME_SIZE         = 16;
        public const uint MAX_TEAM_NAME_BYTES        = 32;
        public const uint MAX_TEAM_DESCRIPTION_SIZE  = 256;
        public const uint MAX_TEAM_DESCRIPTION_BYTES = 512;
        public const uint MAX_TEAM_MOTTO_SIZE        = 256;
        public const uint MAX_TEAM_MOTTO_BYTES       = 512;
        public const uint MAX_TEAM_URL_SIZE          = 256;
        public const uint MAX_TEAM_URL_BYTES         = 512;
        public const uint MAX_TEAM_DATA_SIZE         = 100;
        public const uint MAX_TEAM_MEMBER_DATA_SIZE  = 100;
        public const uint MAX_SUBJECT_SIZE           = 20;
        // ... Invites expire after 1-day
        public const uint INVITE_EXPIRATION_MINUTES = 1440;
        // ... Friend requests and Team recruits expire after 30 days
        public const uint FRIEND_REQUEST_EXPIRATION_MINUTES  = 43200; 
        public const uint TEAM_RECRUIT_EXPIRATION_MINUTES    = 43200;
        // ... Invalid Match Session ID
        public const ulong IGNOREME_SESSID = 0;
        // ... Common Ack Message Type (ID)
        public const uint MSGTYPE_ACK = 0xffffffff;
        // ... Flag to block a sender when deleting a message
        public const uint DELETE_MESSAGE_FLAG_BLOCK_SENDER = 0x00000001;
        // ... Flags for Revoke Ex messages
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER = 0x00000001;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID       = 0x00000002;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER   = 0x00000004;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT  = 0x00000008;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP     = 0x00000010;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE     = 0x00000020;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED    = 0xFFFFFFC0;
        // ... Flag to clean our user queues as well when deleting a system message
        public const uint DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL = 0x00000001;
        // ... Flag that user has opted in to marketing for a title when enrumerating titles
        public const uint USER_TITLE_FLAG_ACCEPT_MARKETING = 0x00000001;

        // Presence State Masks
        // --------------------
        public const uint P_STATE_MASK_NONE            = 0x00000000;
        public const uint P_STATE_MASK_ONLINE          = 0x00000001;
        public const uint P_STATE_MASK_PLAYING         = 0x00000002;
        public const uint P_STATE_MASK_CLOAKED         = 0x00000004;
        public const uint P_STATE_MASK_VOICE           = 0x00000008;
        public const uint P_STATE_MASK_JOINABLE        = 0x00000010;
        public const uint P_STATE_MASK_GUESTS          = 0x00000060;

        // private user set state enumeration
        public const uint P_STATE_ENUM_ONLINE              = 0x00000000;
        public const uint P_STATE_ENUM_AWAY                = 0x00010000;
        public const uint P_STATE_ENUM_BUSY                = 0x00020000;
        public const uint P_STATE_ENUM_WEB                 = 0x00030000;
        public const uint P_STATE_ENUM_RESERVED2           = 0x00040000;
        public const uint P_STATE_ENUM_RESERVED3           = 0x00050000;
        public const uint P_STATE_ENUM_RESERVED4           = 0x00060000;
        public const uint P_STATE_MASK_USER_STATE          = 0x000F0000;
        
        public const uint P_STATE_MASK_SENTREQUEST     = 0x40000000;
        public const uint P_STATE_MASK_RECEIVEDREQUEST = 0x80000000;

        // Buddy Status
        // ------------
        public const byte NOT_A_BUDDY            = 0xff;
        public const byte P_BUDDY_STATUS_OK      = 0;  // Mutualy accepted buddy
        public const byte P_BUDDY_STATUS_PENDING = 1;  // Buddy request pending acceptance
        public const byte P_BUDDY_STATUS_REQUEST = 2;  // Buddy request to accept or reject
        public const byte P_BUDDY_STATUS_ACCEPTED = 3; // Client only status to avoid multiple accepts


        /// <summary>
        /// Get the friendly name for a buddy status byte
        /// </summary>
        public static string BuddyStatusToString(byte status)
        {
            switch(status)
            {
                case NOT_A_BUDDY:
                    return "NotABuddy";
                case P_BUDDY_STATUS_OK:
                    return "BuddyOk";
                case P_BUDDY_STATUS_PENDING:
                    return "BuddyPending";
                case P_BUDDY_STATUS_REQUEST:
                    return "BuddyRequested";
                default:
                    return "Unknown";
            }
        }

        // Invitation Replies
        // ------------------
        public const ushort PINVITE_REPLY_NO    = 0;
        public const ushort PINVITE_REPLY_YES   = 1;
        public const ushort PINVITE_REPLY_NEVER = 2;

        // Generic Reply Values
        // ------------------
        public const byte REPLY_NO    = 0;
        public const byte REPLY_YES   = 1;
        public const byte REPLY_NEVER = 2;

        // Team Member Privliges
        // ---------------------
        public const uint TEAM_DELETE                    = 0x00000001;
        public const uint TEAM_MODIFY_DATA               = 0x00000002;
        public const uint TEAM_MODIFY_MEMBER_PERMISSIONS = 0x00000004;
        public const uint TEAM_DELETE_MEMBER             = 0x00000008;
        public const uint TEAM_RECRUIT_MEMBERS           = 0x00000010;
        public const uint TEAM_LIVE_PERMISSIONS_FORCE_DWORD = 0xFFFFFFFF;
        
        // Notification Queue Types and Masks
        // ----------------------------------
        // ... Request IDs
        public const ushort PQUEUE_BUDDY_REQ      = 0;
        public const ushort PQUEUE_LIST_CHANGE    = 1;
        public const ushort PQUEUE_PRESENCE       = 2;
        public const ushort PQUEUE_INVITE         = 3;
        public const ushort PQUEUE_INVITE_ANSWER  = 4;
        public const ushort PQUEUE_TRANSIENT_MSGS = 5;
        public const ushort PQUEUE_PEER_PRESENCE  = 6;
        public const ushort PQUEUE_PRESENCE_2     = 7;

        
        /// <summary>
        /// Get the friendly name for a presence QType ID
        /// </summary>
        public static string QTypeToString(uint qType)
        {
            switch(qType)
            {
                case PQUEUE_BUDDY_REQ:
                    return "BuddyRequest";
                case PQUEUE_LIST_CHANGE:
                    return "ListChange";
                case PQUEUE_PRESENCE:
                    return "Presence";
                case PQUEUE_INVITE:
                    return "Invite";
                case PQUEUE_INVITE_ANSWER:
                    return "InviteAnswer";
                case PQUEUE_TRANSIENT_MSGS:
                    return "TransientMessages";
                case PQUEUE_PEER_PRESENCE:
                    return "PeerPresence";
                case PQUEUE_PRESENCE_2:
                    return "RichPresence";
                default:
                    return "Unknown";
            }
        }

        // ... Qflag Masks 
        public const uint QFLAG_MASK_BUDDY_REQ      = 0x00000001;
        public const uint QFLAG_MASK_LIST_CHANGE    = 0x00000002;
        public const uint QFLAG_MASK_PRESENCE       = 0x00000004;
        public const uint QFLAG_MASK_INVITE         = 0x00000008;
        public const uint QFLAG_MASK_INVITE_ANSWER  = 0x00000010;
        public const uint QFLAG_MASK_TRANSIENT_MSGS = 0x00000020;
        public const uint QFLAG_MASK_PEER_PRESENCE  = 0x00000040;
        public const uint QFLAG_MASK_PRESENCE_2     = 0x00000080;
        public const uint QFLAG_MASK_ANY            = 0x000000FF;

        /// <summary>
        /// Build a string representation of a qflags bit set
        /// </summary>
        public static string BuildQFlagsString(uint flags)
        {
            string strFlags = "";
            if((flags & XonPresNoti.QFLAG_MASK_BUDDY_REQ) != 0)
                strFlags += "+BuddyRequest";
            if((flags & XonPresNoti.QFLAG_MASK_LIST_CHANGE) != 0)
                strFlags += "+ListChange";
            if((flags & XonPresNoti.QFLAG_MASK_PRESENCE) != 0)
                strFlags += "+Presence";
            if((flags & XonPresNoti.QFLAG_MASK_INVITE) != 0)
                strFlags += "+Invite";
            if((flags & XonPresNoti.QFLAG_MASK_INVITE_ANSWER) != 0)
                strFlags += "+InviteAnswer";
            if((flags & XonPresNoti.QFLAG_MASK_TRANSIENT_MSGS) != 0)
                strFlags += "+TransientMsgs";
            if((flags & XonPresNoti.QFLAG_MASK_PEER_PRESENCE) != 0)
                strFlags += "+PeerPresence";
            if((flags & XonPresNoti.QFLAG_MASK_PRESENCE_2) != 0)
                strFlags += "+Presence2";

            return strFlags;
        }

        // List Change Operations
        // ----------------------
        public const ushort PLIST_BUDDY_NOP    = 0;
        public const ushort PLIST_BUDDY_ADD    = 1;
        public const ushort PLIST_BUDDY_ADDED  = 2;
        public const ushort PLIST_BUDDY_ACCEPT = 3;
        public const ushort PLIST_BUDDY_REJECT = 4;
        public const ushort PLIST_BUDDY_DELETE = 5;

        /// <summary> 
        /// Get the friendly name for a list change operation
        /// </summary>
        public static string ListChangeOpToString(ushort listChangeOp)
        {
            switch(listChangeOp)
            {
                case PLIST_BUDDY_NOP:
                    return "Noop";
                case PLIST_BUDDY_ADD:
                    return "BuddyAdd";
                case PLIST_BUDDY_ADDED:
                    return "BuddyAdded";
                case PLIST_BUDDY_ACCEPT:
                    return "BuddyAccept";
                case PLIST_BUDDY_REJECT:
                    return "BuddyReject";
                case PLIST_BUDDY_DELETE:
                    return "BuddyDelete";
                default:
                    return "Unknown";
            }
        }

        // Message IDs
        // -----------
        public const uint MSG_ID_SEND_FAILED       = 0x80000000; // NOTE: This high bit must not be used so that send can use it to return failed HRESULTs
        public const uint MSG_ID_SYSTEM_MESSAGE    = 0x40000000; // A message sent by the Live service or a publisher
        public const uint MSG_ID_TRANSIENT_MESSAGE = 0x20000000; // A special type of message that goes away when the sender goes offline
        public const uint MSG_ID_BASE_MASK         = 0x00FFFFFF;
        public const uint MSG_ID_RESERVED_MASK     = 0x1F000000;

        // Message Notifications
        // ---------------------
        public const uint MSG_NOTIFICATION_FLAG_SAME_TITLE         = 0x000001;
        public const uint MSG_NOTIFICATION_FLAG_SAME_PUBLISHER     = 0x000002;
        public const uint MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND = 0x000004;
        public const uint MSG_NOTIFICATION_FLAG_HAS_VOICE          = 0x000008;
        public const uint MSG_NOTIFICATION_FLAG_HAS_TEXT           = 0x000010;
        public const uint MSG_NOTIFICATION_FLAG_ALT_TITLE          = 0x000020;
        public const uint MSG_NOTIFICATION_FLAG_TITLE_RESERVED     = 0xFF0000;
        public const uint MSG_NOTIFICATION_FLAG_RESERVED           = 0x00FFC0;

        /// <summary>
        /// Build a string representation of the messaging qval notification flags.
        /// </summary>
        public static string BuildMsgNotificationFlagsString(uint dataFlags)
        {
            string strFlags = "";

            // Pull out the type from high byte
            strFlags += "Type[" + MessageTypeToString((uint)(0xff & (dataFlags >> 24))) + "] ";

            // Pull metadata flags from flags from low 3 bytes
            strFlags += "Flags[" + (0x00ffffff & dataFlags).ToString("x8") + "] ";

            // Standard flags
            if((dataFlags & MSG_NOTIFICATION_FLAG_SAME_TITLE) != 0)
                strFlags += "+SameTitle";
            if((dataFlags & MSG_NOTIFICATION_FLAG_SAME_PUBLISHER) != 0)
                strFlags += "+SamePublisher";
            if((dataFlags & MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND) != 0)
                strFlags += "+FromFriend";
            if((dataFlags & MSG_NOTIFICATION_FLAG_HAS_VOICE) != 0)
                strFlags += "+HasVoice";
            if((dataFlags & MSG_NOTIFICATION_FLAG_HAS_TEXT) != 0)
                strFlags += "+HasText";
            if((dataFlags & MSG_NOTIFICATION_FLAG_ALT_TITLE) != 0)
                strFlags += "+AltTitle";

            return strFlags;
        }
 
        // Message Types
        // -------------
        // A message type establishes the purpose of the message and the properties that 
        // are required for a message of that type.
        public const byte MSG_TYPE_TITLE_CUSTOM      = 1;  // context: title defined;    required props: title defined
        public const byte MSG_TYPE_FRIEND_REQUEST    = 2;  // context: 0;                required props: none
        public const byte MSG_TYPE_GAME_INVITE       = 3;  // context: see msg flags;    required props: XONLINE_MSG_PROP_SESSION_ID for Xbox, XONLINE_MSG_PROP_SESSION_DESCRIPTION, XONLINE_MSG_PROP_SESSION_HOST_XNADDR, XONLINE_MSG_PROP_SESSION_HOST_KEY in addition for Xenon.
        public const byte MSG_TYPE_TEAM_RECRUIT      = 4;  // context: inviting team ID; required props: none
        public const byte MSG_TYPE_COMP_REMINDER     = 5;  // context: comp event ID;    required props: MSG_PROP_COMP_NAME, MSG_PROP_COMP_EVENT_START
        public const byte MSG_TYPE_COMP_REQUEST      = 6;  // context: comp entity ID;   required props: MSG_PROP_COMP_NAME, MSG_PROP_COMP_START, MSG_PROP_COMP_REG_CLOSE 
        public const byte MSG_TYPE_LIVE_MESSAGE      = 7;  // context: 0                 required props: MSG_PROP_SYSTEM_TEXT
        public const byte MSG_TYPE_PERSONAL_MESSAGE  = 8;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VOICE_DATA.
        public const byte MSG_TYPE_VIDEO_MESSAGE     = 9;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VIDEO_DATA
        public const byte MSG_TYPE_QUICK_CHAT_INVITE = 10; // context: 0
        public const byte MSG_TYPE_VIDEO_CHAT_INVITE = 11; // context: 0

        public static string MessageTypeToString(uint msgType)
        {
            switch(msgType)
            {
                case MSG_TYPE_TITLE_CUSTOM:
                    return "TitleCustom";       
                case MSG_TYPE_FRIEND_REQUEST:
                    return "FriendRequest";     
                case MSG_TYPE_GAME_INVITE:
                    return "GameInvite";        
                case MSG_TYPE_TEAM_RECRUIT:
                    return "TeamRecruit";       
                case MSG_TYPE_COMP_REMINDER:
                    return "CompReminder";      
                case MSG_TYPE_COMP_REQUEST:
                    return "CompRequest";       
                case MSG_TYPE_LIVE_MESSAGE:
                    return "LiveMessage";       
                case MSG_TYPE_PERSONAL_MESSAGE:
                    return "PersonalMessage";       
                case MSG_TYPE_VIDEO_MESSAGE:
                    return "VideoMessage";      
                case MSG_TYPE_QUICK_CHAT_INVITE:
                    return "ChatInvite";        
                case MSG_TYPE_VIDEO_CHAT_INVITE:
                    return "VideoChatInvite";
                default:
                    return "UnknownType";
            }
        }

        // Message Flags
        // -------------
        public const uint MSG_FLAG_REQUIRED              = 0x00000001; // User required to read this message
        public const uint MSG_FLAG_RECOMMENDED           = 0x00000002; // User has a system recommended message
        public const uint MSG_FLAG_HAS_VOICE             = 0x00000004; // Message contains a voice attachment
        public const uint MSG_FLAG_HAS_TEXT              = 0x00000008; // Message contains a text body
        public const uint MSG_FLAG_READ                  = 0x00000010; // Message has been read
        public const uint MSG_FLAG_NON_EXPORTABLE        = 0x00000020; // Message should only be displayed on Xbox consoles, not the web
        public const uint MSG_FLAG_TEAM_CONTEXT          = 0x00000040; // Message's sender context refers to a team ID
        public const uint MSG_FLAG_COMP_CONTEXT          = 0x00000080; // This message's sender context refers to a competition event or entity ID
        public const uint MSG_FLAG_ALTERNATE_TITLE       = 0x00000100; // This message is from an alternate Title of the currently logged on title (only available on Xbox consoles)
        public const uint MSG_FLAG_MARKETING             = 0x00000200; // Used on title-sent messages to indicate the message is marketing-related and opt-in settings should be checked
        public const uint MSG_FLAG_MS_MARKETING          = 0x00000400; // Used on title-sent messages to indicate the message is MS marketing-related and opt-in settings should be checked
        public const uint MSG_FLAGS_TITLE_RESERVED       = 0xFF000000; // Flags reserved for title custom messages
        // ... Internal
        public const uint MSG_FLAG_SENDER_IS_FRIEND      = 0x00800000; // Used by Notification to detect invites that should go to V1 clients, also used by clients to allow cross-title invites
        public const uint MSG_FLAG_RECV_DETAILS_NEEDED   = 0x00200000; // Used by the client on received summaries to indicate that the title has requested downloading details
        public const uint MSG_FLAG_SEND_MSG_OWNED        = 0x00200000; // Used by the client on message sends to indicate that the message handle is owned by the Send operation
        public const uint MSG_FLAGS_RESERVED             = 0x005FFC00; // Flags reserved for future use
        // ... Flags valid in a call to send a message
        public const uint MSG_FLAGS_VALID_SEND_MASK = 
            MSG_FLAG_REQUIRED |
            MSG_FLAG_RECOMMENDED |
            MSG_FLAG_HAS_VOICE |
            MSG_FLAG_HAS_TEXT |
            MSG_FLAG_NON_EXPORTABLE |
            MSG_FLAGS_TITLE_RESERVED |
            MSG_FLAG_TEAM_CONTEXT |
            MSG_FLAG_COMP_CONTEXT |
            MSG_FLAG_MARKETING;
        // ... Flags a title is allowed to set on an already sent message
        public const uint MSG_FLAGS_TITLE_SETABLE = 
            MSG_FLAG_READ |
            MSG_FLAGS_TITLE_RESERVED; 
        // ... Flags a title is allowed to clear on an already sent message
        public const uint MSG_FLAGS_TITLE_CLEARABLE = 
            MSG_FLAGS_TITLE_RESERVED; 
        // ... Test: Flags expected in a V1 iinvite message
        public const uint MSG_FLAGS_TEST_V1INVITE_EXPECTED =
            MSG_FLAG_SENDER_IS_FRIEND;

        // Attachment Flags
        // ----------------
        // ... This attachment should not be visible when the message is displayed on the web
        public const uint MSG_ATTACHMENT_FLAG_NON_EXPORTABLE = 0x00000001; 
        // ... The property value points to an ANSI path string to a local directory that will be uploaded to storage, instead of a binary blob
        public const uint MSG_ATTACHMENT_FLAG_DIRECTORY      = 0x00000002; 
        // ... Flags reserved for future use
        public const uint MSG_ATTACHMENT_FLAGS_RESERVED      = 0xFFFFFFFC; 

        // Message Property Types
        // ----------------------
        public const byte MSG_PROP_TYPE_NULL       =  1; // no data
        public const byte MSG_PROP_TYPE_I1         =  2; // 8-bits of data
        public const byte MSG_PROP_TYPE_I2         =  3; // 16-bits of data
        public const byte MSG_PROP_TYPE_I4         =  4; // 32-bits of data
        public const byte MSG_PROP_TYPE_I8         =  5; // 64-bits of data
        public const byte MSG_PROP_TYPE_STRING     =  6; // NULL-terminated wide character string
        public const byte MSG_PROP_TYPE_FILETIME   =  7; // time value
        public const byte MSG_PROP_TYPE_BINARY     =  8; // binary blob that fits in the message details
        public const byte MSG_PROP_TYPE_ATTACHMENT =  9; // binary blob (or directory path, depending on attachment flags) 
                                                         //  that will be uploaded to storage during XOnlineMessageSend
        public const byte MSG_PROP_TYPE_BOOL       = 10; // boolean value (1=TRUE, 0=FALSE)
        public const byte MSG_PROP_TYPE_STRING_ID  = 11; // A string ID whose text can be requested from the string service

        // Message Property IDs 
        // --------------------
        // Property IDs should adhere to the following ranges:
        // Range      Purpose
        // 0x00-0x7F  Reserved for use by titles
        // 0x80-0xBF  Reserved for use by Microsoft for non-global properties
        // 0xC0-0xFF  Reserved for use by Microsoft for properties that span all message types
        public const byte MSG_PROP_ID_BUILTIN = 0x80; // Used for properties defined by Microsoft
        public const byte MSG_PROP_ID_GLOBAL  = 0x40; // Used for properties that can span all message types

        // Message Property Tags
        // ---------------------
        // ... Global property tags, allowed in any message type
        // All message types can contain a voice attachment specified in the following properties.  All three
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_VOICE message 
        // flag can be used to test for the presence of these properties before the message details have been 
        // retrieved.
        public const ushort MSG_PROP_VOICE_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 1);
        public const ushort MSG_PROP_VOICE_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 2);
        public const ushort MSG_PROP_VOICE_DATA_DURATION = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 3);

        // All message types can contain a text summary specified in the following properties.  Both
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_TEXT message 
        // flag can be used to test for the presence of these properties before the message details have been 
        // retrieved.  The text should be 256 characters or less and may be used by Live anywhere that a text
        // summary of the message is useful, such as in a Messenger Alert, on the web, or in the Dashboard.
        public const ushort MSG_PROP_TEXT                = ((ushort)MSG_PROP_TYPE_STRING     << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 4);
        public const ushort MSG_PROP_TEXT_LANGUAGE       = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 5);

        // ... Invite message properties
        public const ushort MSG_PROP_SESSION_ID          = ((ushort)MSG_PROP_TYPE_I8         << 8) | (MSG_PROP_ID_BUILTIN | 1);
        public const ushort MSG_PROP_SESSION_DESCRIPTION = ((ushort)MSG_PROP_TYPE_STRING     << 8) | (MSG_PROP_ID_BUILTIN | 2);
        public const ushort MSG_PROP_SESSION_HOST_XNADDR = ((ushort)MSG_PROP_TYPE_I8         << 8) | (MSG_PROP_ID_BUILTIN | 3);
        public const ushort MSG_PROP_SESSION_HOST_KEY    = ((ushort)MSG_PROP_TYPE_I8         << 8) | (MSG_PROP_ID_BUILTIN | 4);

        // ... Live system message properties
        public const ushort MSG_PROP_SYSTEM_TEXT         = ((ushort)MSG_PROP_TYPE_STRING_ID << 8) | (MSG_PROP_ID_BUILTIN | 1);

        // ... Team Recruit message properties
        public const ushort MSG_PROP_TEAM_NAME           = ((ushort)MSG_PROP_TYPE_STRING << 8) | (MSG_PROP_ID_BUILTIN | 1);

        // ... Competitions message properties
        public const ushort MSG_PROP_COMP_DATASET        = ((ushort)MSG_PROP_TYPE_I4        << 8) | (MSG_PROP_ID_BUILTIN | 0x1);             
        public const ushort MSG_PROP_COMP_NAME           = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0x2);             
        public const ushort MSG_PROP_COMP_START          = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x3);             
        public const ushort MSG_PROP_COMP_ROUND          = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x4);             
        public const ushort MSG_PROP_COMP_OPPONENT       = ((ushort)MSG_PROP_TYPE_STRING_ID << 8) | (MSG_PROP_ID_BUILTIN | 0x5);             
        public const ushort MSG_PROP_COMP_ADMIN          = ((ushort)MSG_PROP_TYPE_I8        << 8) | (MSG_PROP_ID_BUILTIN | 0x6);             
        public const ushort MSG_PROP_COMP_REG_CLOSE      = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x7);             
        public const ushort MSG_PROP_COMP_PRIVATE_SLOTS  = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x8);             
        public const ushort MSG_PROP_COMP_PUBLIC_SLOTS   = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x9);             
        public const ushort MSG_PROP_COMP_UNITS          = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xA);             
        public const ushort MSG_PROP_COMP_INTERVAL       = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xB);             
        public const ushort MSG_PROP_COMP_DAYMASK        = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xC);             
        public const ushort MSG_PROP_COMP_DESCRIPTION    = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0xD);             
        public const ushort MSG_PROP_COMP_URL            = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0xE);             
        public const ushort MSG_PROP_COMP_EVENT_ID       = ((ushort)MSG_PROP_TYPE_I8        << 8) | (MSG_PROP_ID_BUILTIN | 0x10);             
        public const ushort MSG_PROP_COMP_EVENT_START    = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x11);             

        // Voice Codec types (values for XONLINE_MSG_PROP_VOICE_DATA_CODEC)
        // ----------------------------------------------------------------
        public const ushort PROP_VOICE_DATA_CODEC_WMAVOICE_V90 = 1;
        public const ushort PROP_VOICE_DATA_CODEC_SASE3200     = 2;
        // All message types can contain a photo attachment in the following properties.  Both
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_PHOTO message
        // flag can be used to test for the presence of these properties before the message details have been
        // retrieved.  
        public const ushort MSG_PROP_PHOTO_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT<< 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 6);
        public const ushort MSG_PROP_PHOTO_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 7);
        
        public const ushort PROP_PHOTO_DATA_CODEC_PNG    = 1;

        //
        // Video Message Properties
        //
        public const ushort MSG_PROP_VIDEO_FRAME_DATA    = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_BUILTIN | 1);
        //This defines the First Frame of the Video as JPG, BMPetc if we wanted to show the First Frame of the Video in the HUD.
        public const ushort MSG_PROP_VIDEO_FRAME_CODEC   = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_BUILTIN | 2);          
        public const ushort MSG_PROP_VIDEO_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_BUILTIN | 3);
        public const ushort MSG_PROP_VIDEO_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_BUILTIN | 4);
        public const ushort MSG_PROP_VIDEO_DATA_DURATION = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_BUILTIN | 5);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CommunityMgr\QuickEnforcement\Accessing Voice, Text and Photo Messages\wiredata.cs ===
using System;
using System.Reflection;
using System.Net;
using System.Collections;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.ComponentModel;
using System.Runtime.InteropServices;

namespace ServerTestFramework
{

    /// <summary>
    /// Extend this if you want to include a base class's members in the Wiredata serialization. This will 
    /// include all public instance variables in base classes, up through the chain to the base Wiredata class.
    /// Fields in base classes will be serialized first.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class WireDataIncludeBase : WireData
    {
        // Remove the BindingFlags.DeclaredOnly so that we include inherited members as well
        public WireDataIncludeBase() : base(BindingFlags.Public | BindingFlags.Instance)
        {
        }
    }


    /// <summary>
    /// Provides easy serialization of  structured data into byte streams.
    /// </summary>
    /// <remarks>
    /// The <c>WireData</c> class provides a method of serializing class data into byte streams.  This is especially 
    /// useful transfering data over the network.  Using <c>WireData</c> is very simple.  First create a class that derives 
    /// from <c>WireData</c>.  Then add public member variables that specify the format of the data that this class targets in 
    /// the order it appears in the stream.  For many cases this is enough to start serializing and deserializing with 
    /// your <c>WireData</c> class.
    /// <list type="bullet">
    /// <item>
    /// <term>Serialization to a byte[]</term>
    /// <description>Fill out your structure and cast your class to a <c>byte[]</c>.  The resulting <c>byte[]</c> will be your serialization data.  Alternatively you can call WriteStream and pass a <c>Stream</c> for a similar effect.</description>
    /// </item>
    /// <item>
    /// <term>Deserialization from a byte[] or a Stream</term>
    /// <description>Construct a new instance of your class and call ReadStream on your <c>byte[]</c> or <c>Stream</c>.  Your instance will contain the data that was present in the <c>Stream</c>.</description>
    /// </item>
    /// </list>
    /// 
    /// WireData derived classes are made up of different data types.  The valid data types for serialization are as follows:
    /// <list type="bullet">
    /// <item>
    /// <term>Supported native types</term>
    /// <description>The types that may make up WireData types are: <c>bool</c>, <c>byte</c>, <c>char</c>, <c>decimal</c>, <c>double</c>, <c>short</c>, <c>int</c>, <c>long</c>, <c>sbyte</c>, <c>float</c>, <c>ushort</c>, <c>uint</c>, <c>ulong</c>, <c>DateTime</c>, <c>string</c>, arrays of any of these types and other <c>WireData</c> derived classes.  <c>DateTime</c> is supported like a native type and is serialized by calling its ToFileTime.</description>
    /// </item>
    /// <item>
    /// <term>Embedded WireData classes</term>
    /// <description><c>WireData</c> classes can also contain other embedded <c>WireData</c> classes as members.</description>
    /// </item>
    /// <item>
    /// <term>Arrays</term>
    /// <description><c>WireData</c> supports arrays of any of the other types of supported data types.  To use an array you must specifiy how many items are in the array.  See <see cref="ServerTestFramework.WireInfoAttribute"/> and "Arrays" section below for details on how to use arrays.</description>
    /// </item>
    /// <item>
    /// <term>Strings</term>
    /// <description>Strings are treated almost identically to arrays.  To use a string you must specifiy how many characters are in the string.  See <see cref="ServerTestFramework.WireInfoAttribute"/> and the "Arrays" section below for more information.  They are UTF8 encoded for serialization.</description>
    /// </item>
    /// </list>
    /// 
    /// <b>Arrays</b><br/>
    /// <para>Since Arrays are not always the same size there are special considerations that are nescessary.  For example, a deserializer needs to know how many elements to allocate for the array and how much data to pull in.  A seriailzer needs to know where to serialize the element count for a variable sized array.  For these and other reasons, a <see cref="ServerTestFramework.WireInfoAttribute"/> needs to be specified any time an array is declared.</para>
    /// The size needs to be specified in one of three ways:
    /// <list type="number">
    /// <item>
    /// <term>ArraySize</term>
    /// <description>Specify an <c>ArraySize</c> when the array always has a constant number of elements.  If there are 4 <c>int</c>s (comprising 16 bytes) set <c>SizeParam = 4</c>.  On serialization if the array doesn't have enough elements the stream will be zero-padded.</description>
    /// </item>
    /// <item>
    /// <term>SizeParam</term>
    /// <description>For variable-sized arrays you can tell <c>WireData</c> to look at a different integral (such as <c>int</c>) field to get and set the number of array elements from and to.  Set <c>SizeParam</c> to be the name of the field that represents the element count.  If you set this up then when serializing/deserializing, <c>WireData</c> will take care of setting the linked count so you do not have to.  See the example below for more information.</description>
    /// </item>
    /// <item>
    /// <term>&lt;field&gt;Len</term>
    /// <description>For coveniance you don't usually have to specify the attribute for variable sized arrays at all.  Just take the field that you want to link as if you were using <c>SizeParam</c> above and name it the same as the array but append "Len" to the end.  See the example below for more information.</description>
    /// </item>
    /// </list>
    /// <para><b>Overloaded ReadStream/WriteStream</b></para>
    /// <para>There are situations where the above features don't make up enough functionality to match your protocol.  In these cases you will need to override <c>ReadStream</c> and <c>WriteStream</c> in your <c>WireData</c> derived class.  See <see cref="ServerTestFramework.WireData.ReadStream"/> for more information.</para>
    /// </remarks>
    /// 
    /// <example>
    /// This sample shows how to call use the main features of WireData.
    /// <code>
    ///	public class ExampleWireData : WireData
    ///	{
    ///		public byte JustAByte = 0;
    ///		[WireInfo(ArraySize=10)] public string ConstString;
    ///		public int SizeForVarString;
    ///		[WireInfo(SizeParam="SizeForVarString")] public string VarString;
    ///		public uint VarByteArrayLen;
    ///		public int[] VarByteArray;
    ///
    ///		[STAThread]
    ///		static void Main(string[] args)
    ///		{
    ///			// Create and fill out the ExampleWireData structure
    ///			ExampleWireData wd1 = new ExampleWireData();
    ///			wd1.JustAByte = 4;
    ///			wd1.ConstString = "hello";
    ///			wd1.VarString = "goodbye";
    ///			wd1.VarByteArray = new int[3] {5, 6, 7};
    ///
    ///			// Serialize ExampleWireData to byte array
    ///			byte[] data = (byte[])wd1;
    ///			Debug.Assert(data.Length == 38);
    ///
    ///			// Create, deserialize and verify that it was converted correctly
    ///			ExampleWireData wd2 = new ExampleWireData();
    ///			wd2.ReadBytes(data);
    ///			Debug.Assert(wd2.JustAByte == 4);
    ///			Debug.Assert(wd2.ConstString == "hello");
    ///			Debug.Assert(wd2.VarString == "goodbye");
    ///			Debug.Assert(wd2.VarByteArray[0] == 5);
    ///			Debug.Assert(wd2.VarByteArray[1] == 6);
    ///			Debug.Assert(wd2.VarByteArray[2] == 7);
    ///		}
    ///	}
    /// </code>
    /// </example>
    /// 
    [StructLayout(LayoutKind.Sequential)]
    public class WireData
    {
        [WireInfo(Serialize=false)]
        protected static UTF8Encoding    utf8 = new UTF8Encoding();
        [WireInfo(Serialize=false)]
        protected static UnicodeEncoding unicodeEnc = new UnicodeEncoding();
 
        /// <summary>
        /// If set, you will need to manually provide array sizes when writing WireDatas
        /// </summary>
        [WireInfo(Serialize=false)]
        public bool ManualArraySize = false;

        /// <summary>
        /// Setting this to true will dump WireData info as it's being written to a stream
        /// </summary>
        [WireInfo(Serialize=false)]
        public static bool DumpDiagnosticInfo = false;
		
        /// <summary>
        /// If set, overrides NullTerminated attribute. That is things that are supposed to be 
        ///  null terminated, won't be.
        /// </summary>
        [WireInfo(Serialize=false)]
        public bool NullTermOverRide = false;

        private class SizeParamIndex
        {
            public int[] forward = null;
            public int[] reverse = null;

            public SizeParamIndex(int size)
            {
                forward = new int[size];
                reverse = new int[size];

                for (int i = 0; i < size; i++)
                {
                    forward[i] = -1;
                    reverse[i] = -1;
                }
            }
        }

        [WireInfo(Serialize=false)]
        private static Hashtable sizeParamIndicies = new Hashtable();
        [WireInfo(Serialize=false)]
        private static Hashtable fieldCache = new Hashtable();

        [WireInfo(Serialize=false)]
        protected static BindingFlags defaultBindingFlags = (BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

        public WireData() : this(defaultBindingFlags)
        {
        }

        public WireData(BindingFlags bindingFlags)
        {
            // Grab the lock to make sure we get this done in the right order.  We would like to do a early out for 
            // this in the common case but because of some .NET out of order processing magic, execution might not occur in 
            // the expected order.
            // We lock on the hashtable, which is a more restrictive lock than we might be able to use (GetType())
            // might be better but then we have to lock sizeParamIndicies at exactly the right places, which is even 
            // more confusing.
            lock (sizeParamIndicies)
            {
                // Check to see if this WireData has already been initialized.
                if (sizeParamIndicies[GetType()] != null)
                    return;

                // Index this WireData derivative.
                // If not DeclaredOnly (which means we are including inherited members), then we
                // need to sort by the hierarchy.  Within a given class, the order of fields
                // is correct, but the order of classes is reversed.
                FieldCache fc;
                if ((bindingFlags & BindingFlags.DeclaredOnly) == 0)
                {
                    fc = new FieldCache(GetType().GetFields(bindingFlags), true);
                }
                else
                {
                    fc = new FieldCache(GetType().GetFields(bindingFlags), false);
                }
                SizeParamIndex index = new SizeParamIndex(fc.Fields.Length);

                for (int i = 0; i < fc.Fields.Length; i++)
                {
                    FieldInfo field = fc.Fields[i];
                    WireInfoAttribute wireInfo = fc.WireInfo[i];

                    if (!wireInfo.Serialize)
                        continue;	// ignore this field

                    if (field.FieldType.IsArray || field.FieldType == typeof(string))
                    {
                        if (wireInfo.ArraySize == -1)
                        {
                            if ( !wireInfo.WriteOnlyVarLenString )
                            {
                                string sizeParamName = fc.WireInfo[i].SizeParam;
                                if (sizeParamName == null)
                                    sizeParamName = field.Name + "Len";

                                int j;
                                for (j = 0; j < i; j++)
                                    if (fc.Fields[j].Name == sizeParamName)
                                        break;

                                if (j == i)
                                    throw new Exception("Field \"" + field.Name + "\" must have either an ArraySize, a SizeParam or there must be a field named \"" + field.Name + "Len\".");

                                index.forward[i] = j;
                                index.reverse[j] = i;
                            }
                        }
                        else
                        {
                            if (wireInfo.SizeParam != null)
                                throw new Exception("Field \"" + field.Name + "\" can not have both a SizeParam and an ArraySize.");
                        }
                    }
                }

                sizeParamIndicies.Add(GetType(), index);
                fieldCache.Add(GetType(), fc);
            }        
        }

        /// <summary>
        /// This serializes a <c>WireData</c> class to a byte[].
        /// </summary>
        public static explicit operator byte[](WireData wiredata)
        {
            if (wiredata == null)
                return null;
            MemoryStream stream = new MemoryStream();
            wiredata.WriteStream(stream);
            return stream.ToArray();
        }

        /// <summary>
        /// ReadBytes deserializes a byte[] to a <c>WireData</c> class.
        /// </summary>
        public WireData ReadBytes(byte[] bytes)
        {
            if (bytes == null)
                return null;
            return ReadStream(new BinaryReader(new MemoryStream(bytes)));
        }

        /// <summary>
        /// ReadBytes deserializes a byte[] to a <c>WireData</c> class.
        /// </summary>
        /// <param name="bytes">Byte array of data, may be larger than necessary</param>
        /// <param name="bytesSize">The number of bytes of data to use. Must be less than or equal to bytes.Length.</param>
        /// <returns></returns>
        public WireData ReadBytes(byte[] bytes, int bytesSize)
        {
            return ReadStream(new BinaryReader(new MemoryStream(bytes, 0, bytesSize)));
        }

        #region Reader
        /// <summary>
        /// ReadStream deserializes a stream to fill this <c>WireData</c> class.
        /// </summary>
        /// <param name="stream">The source stream to deserialize from.</param>
        /// <returns>Returns a copy of itself.  This is just a convenience for constructing and deserializing at once.</returns>
        /// <example>
        /// <b>Overloaded ReadStream/WriteStream</b>
        /// <para>When implementing a complex protocol you may run into situations where the built in functionality is not sufficient.  An common example of this is when a header precedes a section that's structure depends on a value in the header.  For example, a IP packet has a byte 24 bytes in which if it equals 17 then the rest of the packet after the header should be interpreted as UDP and if it's 6, TCP.  This affects the following structure of the packet.</para>
        /// <para>The example below is a trivialized version of making TCP/UDP/IP packets.  For simplicity I am leaving out portions of the protocol and not actually handling the body of the packets.  This implementation is completely self-contained.  All you have to do is create a <c>Packet</c> object and call ReadStream on it to pull in a UDP or TCP packet.</para>
        /// <code>
        ///	public class Packet : WireData
        ///	{
        ///		public IPHeader IPHeader;
        ///		public ProtocolHeader ProtocolHeader;
        ///
        ///		public override WireData ReadStream(Stream stream)
        ///		{
        ///			IPHeader.ReadStream(stream);
        ///			Debug.Assert(IPHeader.Type == 0x11 || IPHeader.Type == 0x6);
        ///			if (IPHeader.Type == 0x11)
        ///				ProtocolHeader = (ProtocolHeader)new UDPHeader().ReadStream(stream);
        ///			else
        ///				ProtocolHeader = (ProtocolHeader)new TCPHeader().ReadStream(stream);
        ///
        ///			return this;
        ///		}
        ///
        ///		public override void WriteStream(Stream stream)
        ///		{
        ///			if (ProtocolHeader is UDPHeader)
        ///				IPHeader.Type = 0x11;
        ///			else
        ///				IPHeader.Type = 0x6;
        ///
        ///			IPHeader.WriteStream(stream);
        ///			ProtocolHeader.WriteStream(stream);
        ///		}
        ///	}
        ///
        ///	public class IPHeader : WireData
        ///	{
        ///		public byte Version;
        ///		public byte TOS;
        ///		public ushort TotalSize;
        ///		[WireInfo(ArraySize=5)] public byte[] Other1;
        ///		public byte Type;
        ///		[WireInfo(ArraySize=10)] public byte[] Other2;
        ///	}
        ///
        ///	public class ProtocolHeader : WireData
        ///	{
        ///	}
        ///
        ///	public class UDPHeader : ProtocolHeader
        ///	{
        ///		public short SourcePort;
        ///		public short DestPort;
        ///		public short DataLen;
        ///		public short Checksum;
        ///		[WireInfo(ArraySize=0)] public byte[] Data;
        ///	}
        ///
        ///	public class TCPHeader : ProtocolHeader
        ///	{
        ///		public short SourcePort;
        ///		public short DestPort;
        ///		public uint SequenceNumber;
        ///		[WireInfo(ArraySize=12)] public byte[] Other2;
        ///		[WireInfo(ArraySize=0)] public byte[] Data;
        ///	}
        ///	</code>
        /// </example>
        public WireData ReadStream(Stream stream)
            // DO NOT MAKE THIS VIRTUAL! If you need to override it, override ReadStream(BinaryReader) instead - reljam
        {
            // Create the reader, uses UTF8 decoding by default
            return ReadStream(new BinaryReader(stream));
        }

        public virtual WireData ReadStream(BinaryReader binaryReader)
        {
            SizeParamIndex index = (SizeParamIndex)sizeParamIndicies[GetType()];
            if (index == null)
                throw new Exception("This WireData type has not been initialized!  It should have been found in the sizeParamIndicies hashtable.");

            FieldCache fc = (FieldCache)fieldCache[GetType()];

            for (int i = 0; i < fc.Fields.Length; i++)
            {
                FieldInfo field = fc.Fields[i];
                WireInfoAttribute wireInfo = fc.WireInfo[i];

                if (!wireInfo.Serialize)
                    continue;

                object o = null;
                // Handle arrays
                if (field.FieldType.IsArray || field.FieldType == typeof(string))
                {
                    int size = wireInfo.ArraySize;
                    if (size == -1)
                    {
                        try
                        {
                            size = Convert.ToInt32(fc.Fields[index.forward[i]].GetValue(this));
                        }
                        catch(InvalidCastException e)
                        {
                            throw new Exception("Field \"" + field.Name + "\" is not an index (numeric) type.", e);
                        }						
                    }

                    if (field.FieldType == typeof(string))
                    {
                        byte[] rawBytes = binaryReader.ReadBytes( size );
                        string s;
                        if( wireInfo.UnicodeEncoded )
                        {
                            s = unicodeEnc.GetString( rawBytes );
                        }
                        else
                        {
                            s = utf8.GetString( rawBytes );
                        }
                        int termPos = s.IndexOf((char)0);
                        if (termPos > 0)
                            o = s.Substring(0, s.IndexOf((char)0));
                        else if (termPos == -1)
                            o = s;
                        else
                            o = "";
                    }
                    else
                    {
                        o = field.GetValue(this);
                        if ( o==null )
                        {
                            Type[] types = {typeof(int)};
                            object[] param = {size};
                            o = field.FieldType.GetConstructor(types).Invoke(param);
                            for (int j = 0; j < size; j++)
                                (o as Array).SetValue(ReadValue(binaryReader, field.FieldType.GetElementType(),null), j);
                        } 
                        else 
                        {
                            // Use type info from the actual data passed in.
                            for (int k=0; k<(o as Array).Length; ++k)
                            {
                                object val = (o as Array).GetValue(k);
                                (o as Array).SetValue(ReadValue(binaryReader, val.GetType(), val), k);
                            }
                        }
                    }
                }
                else
                    o = ReadValue(binaryReader, field.FieldType, null);
                field.SetValue(this, o);
            }

            return this;
        }
        #endregion

        #region Writer
        /// <summary>
        /// ReadStream serializes this <c>WireData</c> class into a stream.
        /// </summary>
        /// <remarks>
        /// See <see cref="ServerTestFramework.WireData.ReadStream"/> for more information and an example.
        /// </remarks>
        /// <param name="stream">The destination stream to serialize to.</param>
        public void WriteStream(Stream stream)
            // DO NOT MAKE THIS VIRTUAL! If you need to override it, override WriteStream(BinaryWriter) instead - reljam
        {
            // Create the writer, uses UTF8 encoding by default
            WriteStream(new BinaryWriter(stream));
        }

        public virtual void WriteStream(BinaryWriter binaryWriter)
        {
            SizeParamIndex index = (SizeParamIndex)sizeParamIndicies[GetType()];
            if (index == null)
                throw new Exception("This WireData type has not been initialized!  It should have been found in the sizeParamIndicies hashtable.");

            FieldCache fc = (FieldCache)fieldCache[GetType()];

            for (int i = 0; i < fc.Fields.Length; i++)
            {
                FieldInfo field = fc.Fields[i];
                WireInfoAttribute wireInfo = fc.WireInfo[i];

                if (!wireInfo.Serialize)
                    continue;

                if (WireData.DumpDiagnosticInfo)
                    Console.WriteLine(field.DeclaringType.ToString() + "::" + field.Name);

                object o = field.GetValue(this);
                if (field.FieldType.IsArray || field.FieldType == typeof(string))
                {
                    long startPos = binaryWriter.BaseStream.Position;
                    int actualArraySize = 0;

                    if (o != null)
                    {
                        actualArraySize = field.FieldType.IsArray ? (o as Array).Length : (o as string).Length;
					
                        if (!ManualArraySize)
                        {
                            // The size of the array or string should not be greater than the ArraySize attribute
                            if (wireInfo.ArraySize != -1 && actualArraySize > wireInfo.ArraySize)
                                throw new Exception("Field \"" + field.Name + "\" contains too many items for it's ArraySize.");
                        }

                        if (field.FieldType.IsArray)
                        {
                            if( wireInfo.UnicodeEncoded &&
                                (actualArraySize > 0) &&
                                ((o as Array).GetValue(0).GetType() == typeof( char )) )
                            {
                                char[] sz = (char[])o;
                                byte[] bytes = new byte[ sz.Length * 2 ];
                                unicodeEnc.GetBytes( sz, 0, sz.Length, bytes, 0 );
                                binaryWriter.Write( bytes );

                                if( (wireInfo.NullTerminated) && !NullTermOverRide )
                                {
                                    binaryWriter.Write( (ushort)0 );
                                }
                            }
                            else
                            {
                                for (int j = 0; j < actualArraySize; j++)
                                {
                                    object val = (o as Array).GetValue(j);
                                    WriteValue(binaryWriter, val);
                                }
                            }
                        }
                        else // This is a string 
                        {
                            string s = (string)o;

                            if( wireInfo.UnicodeEncoded )
                            {
                                binaryWriter.Write( unicodeEnc.GetBytes( s ) );
                            }
                            else
                            {
                                binaryWriter.Write( utf8.GetBytes( s ) );
                            }

                            if( (wireInfo.NullTerminated) && !NullTermOverRide )
                            {
                                if( wireInfo.UnicodeEncoded )
                                {
                                    binaryWriter.Write( (ushort)0 );
                                }
                                else 
                                {
                                    binaryWriter.Write( (byte)0 );
                                }
                            }
                        }
                    }

                    if (!ManualArraySize)
                    {
                        // Pad the end of the array/string with 0's if nescessary
                        if (wireInfo.ArraySize != -1)
                        {
                            if (field.FieldType.IsArray)
                            {
                                if (field.FieldType.GetElementType().IsSubclassOf(typeof(WireData)))
                                {
                                    ConstructorInfo ci = field.FieldType.GetElementType().GetConstructor(Type.EmptyTypes);
                                    if (ci == null)
                                        throw new Exception("WireData(): for type " + GetType().Name + "::" + field.FieldType.GetElementType().Name + " -- If the number of elements in the array is less than the ArraySize, the class must have a default constructor to use for padding the end of the array with empty structures.");

                                    int size = (ci.Invoke(null) as WireData).Size() * (wireInfo.ArraySize - actualArraySize);

                                    for (int j = 0; j < size; j++)
                                        binaryWriter.Write((byte)0);
                                }
                                else
                                {
                                    for (int j = actualArraySize; j < wireInfo.ArraySize; j++)
                                        WriteValue(binaryWriter, 0, field.FieldType.GetElementType());
                                }
                            }
                            else
                            {
                                // this must be a string so ArraySize is in bytes
                                binaryWriter.Write(new byte[wireInfo.ArraySize - (binaryWriter.BaseStream.Position - startPos)]);
                            }
                        }
                    }
                }
                else
                {
                    if (index.reverse[i] != -1)
                    {
                        if (!ManualArraySize)
                        {
                            object oT = fc.Fields[index.reverse[i]].GetValue(this);
                            if (oT == null)
                                o = 0;
                            else
                            {
                                // Determining the size of an array is not as simple as string.Length
                                // we need to convert the string to UTF-8 and get the size of that
                                // it would be great if we could cache this....
                                if (oT is Array)
                                    o = ((Array)oT).Length;
                                else
                                {
                                    if( fc.WireInfo[index.reverse[i]].UnicodeEncoded )
                                    {
                                        if( (fc.WireInfo[index.reverse[i]].NullTerminated) && !NullTermOverRide )
                                            o = unicodeEnc.GetByteCount((string)oT) + 2;
                                        else
                                            o = unicodeEnc.GetByteCount((string)oT);
                                    }
                                    else
                                    {
                                        if( (fc.WireInfo[index.reverse[i]].NullTerminated) && !NullTermOverRide )
                                            o = utf8.GetByteCount((string)oT) + 1;
                                        else
                                            o = utf8.GetByteCount((string)oT);
                                    }
                                }
                            }
                        }
                    }
                    if (wireInfo.OnlySerializeIfNotEmpty && (int) o==0)
                        return;
                    WriteValue(binaryWriter, o, field.FieldType);
                }
            }
        }
        #endregion
        
        /// <summary>
        /// Returns the size of this WireData class as currently configured.
        /// </summary>
        /// <remarks>
        /// This is expensive because it requires actually serializing the structure and getting the length of the resulting data.
        /// </remarks>
        public int Size()
        {
            MemoryStream stream = new MemoryStream();
            WriteStream(stream);
            return (int)stream.Length;
        }

        #region Read/Write Converters

        private object ReadValue(BinaryReader reader, Type type, object obj)
        {
            if (type == typeof(bool))
                return reader.ReadBoolean();
            else if (type == typeof(byte))
                return reader.ReadByte();
            else if (type == typeof(char))
                return reader.ReadChar();
            else if (type == typeof(decimal))
                return reader.ReadDecimal();
            else if (type == typeof(double))
                return reader.ReadDouble();
            else if (type == typeof(short))
                return reader.ReadInt16();
            else if (type == typeof(int))
                return reader.ReadInt32();
            else if (type == typeof(long))
                return reader.ReadInt64();
            else if (type == typeof(sbyte))
                return reader.ReadSByte();
            else if (type == typeof(float))
                return reader.ReadSingle();
            else if (type == typeof(ushort))
                return reader.ReadUInt16();
            else if (type == typeof(uint))
                return reader.ReadUInt32();
            else if (type == typeof(ulong))
                return reader.ReadUInt64();
            else if (type == typeof(DateTime))
                return DateTime.FromFileTimeUtc(reader.ReadInt64());
            else if (type.IsSubclassOf(typeof(WireData)))
            {
                if(obj == null)
                    return (type.GetConstructor(Type.EmptyTypes).Invoke(null) as WireData).ReadStream(reader);
                else	// use the ones that passed in
                    return (obj as WireData).ReadStream(reader);
            }
            else
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");
        }

        private void WriteValue(BinaryWriter writer, object o) {WriteValue(writer, o, null);}
        private void WriteValue(BinaryWriter writer, object o, Type type)
        {
            if (type == null)
                type = o.GetType();
            if (type == typeof(bool))
                writer.Write(Convert.ToBoolean(o));
            else if (type == typeof(byte))
                writer.Write(Convert.ToByte(o));
            else if (type == typeof(char))
                writer.Write(Convert.ToChar(o));
            else if (type == typeof(decimal))
                writer.Write(Convert.ToDecimal(o));
            else if (type == typeof(double))
                writer.Write(Convert.ToDouble(o));
            else if (type == typeof(short))
                writer.Write(Convert.ToInt16(o));
            else if (type == typeof(int))
                writer.Write(Convert.ToInt32(o));
            else if (type == typeof(long))
                writer.Write(Convert.ToInt64(o));
            else if (type == typeof(sbyte))
                writer.Write(Convert.ToSByte(o));
            else if (type == typeof(float))
                writer.Write(Convert.ToSingle(o));
            else if (type == typeof(ushort))
                writer.Write(Convert.ToUInt16(o));
            else if (type == typeof(uint))
                writer.Write(Convert.ToUInt32(o));
            else if (type == typeof(ulong))
                writer.Write(Convert.ToUInt64(o));
            else if (type == typeof(DateTime))
                writer.Write(Convert.ToDateTime(o).ToFileTimeUtc());
            else if (type.IsSubclassOf(typeof(WireData)))
            {
                if (o != null)  // If the WireData is null then assume a 0 size and don't output anything
                    (o as WireData).WriteStream(writer);
            }
            else
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");
        }
        #endregion

        private class FieldCache
        {
            public FieldInfo[] Fields;
            public WireInfoAttribute[] WireInfo;

            public FieldCache(FieldInfo[] fields, bool bSortedByClass)
            {
                if (bSortedByClass)
                {
                    this.Fields = SortFields(fields);
                }
                else
                {
                    this.Fields = fields;
                }
				
                WireInfo = new WireInfoAttribute[this.Fields.Length];
                for (int i = 0; i < this.Fields.Length; i++)
                    WireInfo[i] = GetWireInfo(this.Fields[i]);
            }

            private static WireInfoAttribute GetWireInfo(FieldInfo field)
            {
                int len = field.GetCustomAttributes(typeof(WireInfoAttribute), false).Length;
                Debug.Assert(len == 0 || len == 1);
                if (len == 1)
                    return (WireInfoAttribute)field.GetCustomAttributes(typeof(WireInfoAttribute), false)[0];
                else
                    return WireInfoAttribute.None;
            }

            // Sorts the field list by base member class.  This is only a problem when we include
            // fields from base classes as well, which is not a default behavior.  The fields for 
            // a given class are sorted correctly, but the order of the classes is reversed.  That
            // is, the first fields are from the child class, followed by its parent, and so on.
            // We need to reverse this, as I would expect the deepest inherited members should be
            // the first ones serialized.
            private FieldInfo[] SortFields(FieldInfo[] fields)
            {
                if (fields == null || fields.Length == 0)
                    return fields;

                ArrayList list = new ArrayList(fields.Length);
                int insertIdx = 0;
                System.Type lastType = fields[fields.Length-1].DeclaringType;

                // Bump this to the end of the array every time we find a new class
                for (int i = fields.Length - 1; i >= 0; i--)
                {
                    System.Type thisType = fields[i].DeclaringType;
                    if (thisType != lastType)
                    {
                        lastType = thisType;
                        insertIdx = list.Count;
                    }
                    list.Insert(insertIdx, fields[i]);
                }

                return (FieldInfo[])list.ToArray(typeof(FieldInfo));
            }
        }
    }

    /// <summary>
    /// Attribute placed on fields of a class derived from WireData to add context to the field in order to serialze it
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class WireInfoAttribute : Attribute
    {
        /// <summary>
        /// Used to specify a constant size for an array.
        /// </summary>
        public int ArraySize = -1;

        /// <summary>
        /// Used to specify which other field in a <c>WireData</c> class specifies the size of the array or string this attribute is put on.
        /// </summary>
        public string SizeParam = null;

        /// <summary>
        /// Include the Null in a varible length string and add 1 to it's length variable (if there is one)
        /// </summary>
        public bool NullTerminated = false;

        /// <summary>
        /// Use unicode Encoding instead of the default (UTF8)
        /// </summary>
        public bool UnicodeEncoded = false;

        public bool WriteOnlyVarLenString = false;
        public bool	Serialize=true;
        public bool	OnlySerializeIfNotEmpty=false;

        /// <summary>
        /// An static instance of <c>WireInfoAttribute</c> with all values set to defaults.
        /// </summary>
        public static WireInfoAttribute None = new WireInfoAttribute();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\common\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\common\InterfaceBucketControl.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Xml;
using System.Text;
using System.IO;

namespace xonline.tools.configuration.buckets
{
    public static class InterfaceBucketControl
    {
        /// <summary>
        /// Removes the specified interface bucket.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <param name="title">title identifier</param>
        /// <param name="bucket">index of the interface bucket</param>
        public static void DeleteBucket(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title,
           int bucket)
        {
            if (null == connection)
                throw new ArgumentException("connection");

            using (SqlCommand command = connection.CreateCommand())
            {
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_config_delete_interface_bucket";
                command.Transaction = transaction;

                command.Parameters.AddWithValue("@vc_environment", environment);
                command.Parameters.AddWithValue("@vc_interface", iface);
                command.Parameters.AddWithValue("@i_title_id", title);
                command.Parameters.AddWithValue("@i_bucket", bucket);

                command.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Clears all interface buckets for a specific titles interface.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <param name="title">title identifier</param>
        /// <returns>Number of deleted buckets</returns>
        public static int ClearBuckets(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title)
        {
            if (null == connection)
                throw new ArgumentNullException("connection");

            using (SqlCommand command = connection.CreateCommand())
            {
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_config_clear_interface_buckets";
                command.Transaction = transaction;

                command.Parameters.AddWithValue("@vc_environment", environment);
                command.Parameters.AddWithValue("@vc_interface", iface);
                command.Parameters.AddWithValue("@i_title_id", title);

                // t_config_logs is updated via a trigger we dont want this row change factored in the count
                return Math.Max(0, command.ExecuteNonQuery() - 1);
            }
        }

        /// <summary>
        /// Clears all interface buckets for a specific titles interface.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <returns>Number of deleted buckets</returns>
        public static int ClearBuckets(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface)
        {
            if (null == connection)
                throw new ArgumentNullException("connection");

            using (SqlCommand command = connection.CreateCommand())
            {
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_config_clear_interface_buckets";
                command.Transaction = transaction;

                command.Parameters.AddWithValue("@vc_environment", environment);
                command.Parameters.AddWithValue("@vc_interface", iface);

                // t_config_logs is updated via a trigger we dont want this row change factored in the count
                return Math.Max(0, command.ExecuteNonQuery() - 1);
            }
        }

        /// <summary>
        /// Retrieves the specified interface bucket.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <param name="title">title identifier</param>
        /// <param name="bucket">index of the interface bucket</param>
        /// <returns>Reader containing the t_interface_bucket row specified.</returns>
        public static SqlDataReader GetBucketReader(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title,
           int bucket)
        {
            if (null == connection)
                throw new ArgumentNullException("connection");

            using (SqlCommand command = connection.CreateCommand())
            {
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_config_get_interface_bucket";
                command.Transaction = transaction;

                command.Parameters.AddWithValue("@vc_environment", environment);
                command.Parameters.AddWithValue("@vc_interface", iface);
                command.Parameters.AddWithValue("@i_title_id", title);
                command.Parameters.AddWithValue("@i_bucket", bucket);

                return command.ExecuteReader();
            }
        }

        /// <summary>
        /// Determines whether or not the specified interface bucket exists.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <param name="title">title identifier</param>
        /// <param name="bucket">index of the interface bucket</param>
        /// <returns>true when the bucket exists, false otherwise.</returns>
        public static bool DoesBucketExist(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title,
           int bucket)
        {
            using (SqlDataReader reader = GetBucketReader(connection, transaction, environment, iface, title, bucket))
            {
                return reader.Read();
            }
        }

        /// <summary>
        /// Creates or overwrites an interface bucket.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <param name="title">title identifier</param>
        /// <param name="bucket">index of the interface bucket</param>
        /// <param name="server">server name</param>
        /// <param name="nextServer">migration server name</param>
        /// <param name="migrationStart">migration start time</param>
        /// <param name="info1">random info most people ignore</param>
        /// <param name="info2">random info everyone ignores</param>
        /// <param name="info3">even more random info everyone ignores</param>
        /// <param name="info4">more of the same</param>
        /// <param name="overwrite">overwrite existing data if present</param>
        /// <exception cref="ExistingInterfaceBucketException">
        /// Raised when overwrite is set to false for a bucket that already exists.
        /// </exception>
        public static void CreateBucket(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title,
           int bucket,
           string server,
           string nextServer,
           DateTime migrationStart,
           string info1,
           string info2,
           string info3,
           string info4,
           bool overwrite)
        {
            if (null == connection)
                throw new ArgumentNullException("connection");

            using (SqlCommand command = connection.CreateCommand())
            {
                command.CommandType = CommandType.StoredProcedure;
                command.Transaction = transaction;

                // gentleman start your engines (race condition)
                if (!DoesBucketExist(connection, transaction, environment, iface, title, bucket))
                    command.CommandText = "p_config_insert_interface_bucket";
                else
                {
                    if (!overwrite)
                    {
                        InterfaceBucket ib;
                        ib = new InterfaceBucket(environment, iface, null, null, title, bucket);
                        throw new ExistingInterfaceBucketException(ib);
                    }

                    command.CommandText = "p_config_update_interface_bucket";
                }

                command.Parameters.AddWithValue("@vc_environment", environment);
                command.Parameters.AddWithValue("@vc_interface", iface);
                command.Parameters.AddWithValue("@i_title_id", title);
                command.Parameters.AddWithValue("@i_bucket", bucket);
                command.Parameters.AddWithValue("@vc_server", server);
                command.Parameters.AddWithValue("@vc_next_server", nextServer);
                command.Parameters.AddWithValue("@dt_migration_start", migrationStart);
                command.Parameters.AddWithValue("@vc_info1", info1 ?? "");
                command.Parameters.AddWithValue("@vc_info2", info2 ?? "");
                command.Parameters.AddWithValue("@vc_info3", info3 ?? "");
                command.Parameters.AddWithValue("@vc_info4", info4 ?? "");

                command.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Retrieves interface buckets matching the specified constraints.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <param name="title">title identifier, this value can be null</param>
        /// <param name="bucketStart">lower index of the interface bucket, this value can be null</param>
        /// <param name="bucketEnd">upper index of the interface bucket, this value can be null</param>
        /// <param name="server">server name, this value can be null</param>
        /// <returns>Reader containing the t_interface_bucket rows satisfying the query.</returns>
        public static SqlDataReader QueryBuckets(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int? title,
           int? bucketStart,
           int? bucketEnd,
           string server)
        {
            if (null == connection)
                throw new ArgumentNullException("connection");

            using (SqlCommand command = connection.CreateCommand())
            {
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_config_query_interface_buckets";
                command.Transaction = transaction;

                command.Parameters.AddWithValue("@vc_environment", environment);
                command.Parameters.AddWithValue("@vc_interface", iface);
                command.Parameters.AddWithValue("@vc_server", server);
                if (title.HasValue)
                    command.Parameters.AddWithValue("@i_title_id", title.Value);
                if (bucketStart.HasValue)
                    command.Parameters.AddWithValue("@i_bucket_start", bucketStart.Value);
                if (bucketEnd.HasValue)
                    command.Parameters.AddWithValue("@i_bucket_end", bucketEnd.Value);

                return command.ExecuteReader();
            }
        }

        /// <summary>
        /// Retrieves interface buckets matching the specified constraints.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <returns>Reader containing the t_interface_bucket rows satisfying the query.</returns>
        public static SqlDataReader QueryBuckets(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface)
        {
            return QueryBuckets(connection, transaction, environment, iface, null, null, null, null);
        }

        /// <summary>
        /// Retrieves interface buckets matching the specified constraints.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <param name="title">title identifier, this value can be null</param>
        /// <returns>Reader containing the t_interface_bucket rows satisfying the query.</returns>
        public static SqlDataReader QueryBuckets(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title)
        {
            return QueryBuckets(connection, transaction, environment, iface, title, null, null, null);
        }

        /// <summary>
        /// Commits the specified servers to t_interface_buckets in a striping pattern
        /// for the specified interface.
        /// </summary>
        /// <param name="connection">connection to server with npdb present</param>
        /// <param name="environment">deployment environment</param>
        /// <param name="iface">component interface name</param>
        /// <param name="title">title identifier</param>
        /// <param name="servers">server list for the interface</param>
        /// <param name="buckets">number of interface buckets to configure</param>
        /// <remarks>
        /// Buckets for this particular environment/interface/title should be clear before
        /// this call is made.  This call will fail to overwrite any existing buckets (by design)
        /// </remarks>
        public static void ApplyStriping(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title,
           string[] servers,
           int buckets)
        {
            if (null == connection)
                throw new ArgumentNullException("connection");
            if (null == servers)
                throw new ArgumentNullException("servers");
            if (servers.Length > buckets)
                throw new ArgumentException("more servers than buckets", "buckets");

            for (int c = 0; c < servers.Length; c++)
            {
                if (string.IsNullOrEmpty(servers[c]))
                    throw new ArgumentNullException("servers[" + c.ToString() + "]");
            }

            if (servers.Length > 0)
            {
                for (int c = 0; c < buckets; c++)
                {
                    CreateBucket(
                       connection,
                       transaction,
                       environment,
                       iface,
                       title,
                       c,
                       servers[c % servers.Length],  // server
                       servers[c % servers.Length],  // next Server
                       SqlDateTime.MinValue.Value,   // migration start
                       "", "", "", "",               // info1,2,3,4
                       false                         // no overwrite
                    );
                }
            }
        }

        private static SqlXml CreateValueList<T>(T[] values)
        {
            XmlDocument content;
            SqlXml result;

            content = new XmlDocument();
            content.AppendChild(content.CreateElement("list"));

            if (null != values)
            {
                foreach (T value in values)
                {
                    content.DocumentElement.AppendChild(
                       content.CreateElement("item")).Value = value.ToString();
                }
            }

            using (StringReader text = new StringReader(content.OuterXml))
            {
                using (XmlTextReader reader = new XmlTextReader(text))
                {
                    result = new SqlXml(reader);
                }
            }

            return result;
        }

        private static SqlParameter AddValueListParameter<T>(SqlCommand command, string name, T[] values)
        {
            SqlParameter parameter;
            SqlXml xml;

            xml = CreateValueList<T>(values);
            parameter = new SqlParameter(name, SqlDbType.Xml, xml.Value.Length);

            command.Parameters.Add(parameter);

            return parameter;
        }

        public static string[] SubtractServerList(
           string[] left,
           string[] right)
        {
            Dictionary<string, string> set;

            set = new Dictionary<string, string>();
            foreach (string entry in left)
                set[entry.Trim().ToUpper()] = entry.Trim();

            foreach (string entry in right)
                set.Remove(entry.Trim().ToUpper());

            return new List<string>(set.Values).ToArray();
        }

        public static string[] SubtractServerList(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           string[] servers)
        {
            return SubtractServerList(GetServerList(connection, transaction, environment, iface), servers);
        }

        public static string[] SubtractServerList(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title,
           string[] servers)
        {
            return SubtractServerList(GetServerList(connection, transaction, environment, iface, title), servers);
        }

        public static string[] UnionServerList(
           string[] left,
           string[] right)
        {
            Dictionary<string, string> set;

            set = new Dictionary<string, string>();
            foreach (string entry in left)
                set[entry.Trim().ToUpper()] = entry.Trim();

            foreach (string entry in right)
                set[entry.Trim().ToUpper()] = entry.Trim();

            return new List<string>(set.Keys).ToArray();
        }

        public static string[] UnionServerList(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           string[] servers)
        {
            return UnionServerList(GetServerList(connection, transaction, environment, iface), servers);
        }

        public static string[] UnionServerList(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title,
           string[] servers)
        {
            return UnionServerList(GetServerList(connection, transaction, environment, iface, title), servers);
        }

        public static string[] GetServerList(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface)
        {
            List<string> results;

            results = new List<string>();
            using (SqlDataReader reader = QueryBuckets(connection, transaction, environment, iface))
            {
                int ord = reader.GetOrdinal("vc_next_server");

                while (reader.Read())
                {
                    string server = reader.GetString(ord).ToUpper();

                    if (!results.Contains(server))
                        results.Add(server);
                }
            }

            return results.ToArray();
        }

        public static string[] GetServerList(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string iface,
           int title)
        {
            List<string> results;

            results = new List<string>();
            using (SqlDataReader reader = QueryBuckets(connection, transaction, environment, iface, title))
            {
                int ord = reader.GetOrdinal("vc_next_server");

                while (reader.Read())
                {
                    string server = reader.GetString(ord).ToUpper();

                    if (!results.Contains(server))
                        results.Add(server);
                }
            }

            return results.ToArray();
        }

        private static bool MetSearchCriteria(
           InterfaceBucket item,
           string environment,
           Dictionary<string, string> servers,
           Dictionary<string, string> interfaces,
           Dictionary<int, int> titles)
        {
            if (item.m_environment.ToUpper() != environment.ToUpper())
                return false;
            if (interfaces.Count > 0 && !interfaces.ContainsKey(item.m_interface.ToUpper()))
                return false;
            if (servers.Count > 0 && !servers.ContainsKey(item.m_server.ToUpper()) && !servers.ContainsKey(item.m_nextServer.ToUpper()))
                return false;
            if (titles.Count > 0 && !titles.ContainsKey(item.m_titleid))
                return false;

            return true;
        }

        public static InterfaceBucketLog[] QueryBucketLogs(
           SqlConnection connection,
           SqlTransaction transaction,
           string environment,
           string[] interfaces,
           int[] titles,
           string[] servers,
           string user,
           DateTime start,
           DateTime end)
        {
            List<InterfaceBucketLog> results;
            Dictionary<string, string> serverLookup;
            Dictionary<string, string> interfaceLookup;
            Dictionary<int, int> titleLookup;

            if (null == connection)
                throw new ArgumentNullException("connection");

            results = new List<InterfaceBucketLog>();

            interfaceLookup = new Dictionary<string, string>();
            if (null != interfaces)
            {
                for (int c = 0; c < interfaces.Length; c++)
                    interfaceLookup[interfaces[c].ToUpper()] = interfaces[c];
            }

            serverLookup = new Dictionary<string, string>();
            if (null != servers)
            {
                for (int c = 0; c < servers.Length; c++)
                    serverLookup[servers[c].ToUpper()] = servers[c];
            }

            titleLookup = new Dictionary<int, int>();
            if (null != titles)
            {
                for (int c = 0; c < titles.Length; c++)
                    titleLookup[titles[c]] = titles[c];
            }

            using (SqlCommand command = connection.CreateCommand())
            {
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_config_query_interface_bucket_logs";
                command.Transaction = transaction;

                command.Parameters.AddWithValue("@vc_user", user);
                command.Parameters.AddWithValue("@dt_start", start);
                command.Parameters.AddWithValue("@dt_end", end);

                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        string userName;
                        string application;
                        string[] insertLogs;
                        string[] deleteLogs;
                        int iterations;
                        DateTime date;

                        userName = reader.GetString(0);
                        application = reader.GetString(1);
                        date = reader.GetDateTime(2);

                        insertLogs = reader.GetString(3).Split('\n');
                        deleteLogs = reader.GetString(4).Split('\n');
                        iterations = Math.Max(insertLogs.Length, deleteLogs.Length);

                        for (int c = 0; c < iterations; c++)
                        {
                            InterfaceBucketLog entry;
                            bool foundMatch;

                            entry = new InterfaceBucketLog();

                            entry.m_application = application;
                            entry.m_date = date;
                            entry.m_user = userName;

                            foundMatch = false;

                            if (deleteLogs.Length > c && !string.IsNullOrEmpty(deleteLogs[c]))
                            { // create the old record
                                entry.m_old = new InterfaceBucket(deleteLogs[c]);
                                foundMatch |= MetSearchCriteria(entry.m_old, environment, serverLookup, interfaceLookup, titleLookup);
                            }

                            if (insertLogs.Length > c && !string.IsNullOrEmpty(insertLogs[c]))
                            { // create the new record
                                entry.m_new = new InterfaceBucket(insertLogs[c]);
                                foundMatch |= MetSearchCriteria(entry.m_new, environment, serverLookup, interfaceLookup, titleLookup);
                            }

                            if (foundMatch)
                                results.Add(entry);
                        }
                    }
                }
            }

            return results.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\common\SettingOverrideControl.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;

namespace xonline.tools.configuration.setting_override
{
    public static class SettingOverrideControl
    {
      /// <summary>
      /// Retrieves the specified Setting Override
      /// </summary>
      /// <param name="connection">connection to server with npdb present</param>
      /// <param name="environment">deployment environment</param>
      /// <param name="site_id">site ID</param>
      /// <param name="server">server name</param>
      /// <param name="component">setting component</param>
      /// <param name="setting">setting name</param>
      /// <returns>Reader containing the t_setting_override specified.</returns>
      public static SqlDataReader GetSettingOverride(
          SqlConnection connection,
          string environment,
          int site_id,
          string server,
          string component,
          string setting)
      {
          if (null == connection)
              throw new ArgumentNullException("connection");

          using (SqlCommand command = connection.CreateCommand())
          {
              command.CommandType = CommandType.StoredProcedure;
              command.CommandText = "p_config_get_setting_overrides";

              command.Parameters.AddWithValue("@vc_environment", environment);
              command.Parameters.AddWithValue("@i_site_id", site_id);
              command.Parameters.AddWithValue("@vc_server", server);
              command.Parameters.AddWithValue("@vc_component", component);
              command.Parameters.AddWithValue("@vc_setting", setting);

              return command.ExecuteReader();
          }
      }

      /// <summary>
      /// Determines whether or not the setting override exists.
      /// </summary>
      /// <param name="connection">connection to server with npdb present</param>
      /// <param name="environment">deployment environment</param>
      /// <param name="site_id">site ID</param>
      /// <param name="server">server name</param>
      /// <param name="component">setting component</param>
      /// <param name="setting">setting name</param>
      /// <returns>true when the setting override exists, false otherwise.</returns>
      public static bool DoesSettingOverrideExist(
          SqlConnection connection,
          string environment,
          int site_id,
          string server,
          string component,
          string setting)
      {
          using (SqlDataReader reader = GetSettingOverride(connection, environment, site_id, server, component, setting))
          {
              return reader.Read();
          }
      }

      /// <summary>
      /// Adds a setting override in NPDB
      /// </summary>
      /// <param name="connection">connection to server with npdb present</param>
      /// <param name="environment">deployment environment</param>
      /// <param name="site_id">site ID</param>
      /// <param name="server">server name</param>
      /// <param name="component">setting component</param>
      /// <param name="setting">setting name</param>
      /// <param name="value">setting override value</param>
      /// <param name="overwrite">overwrite enable</param>
      public static void AddSettingOverride(
          SqlConnection connection,
          string environment,
          int site_id,
          string server,
          string component,
          string setting,
          string value,
          bool overwrite)
      {
          if (null == connection)
              throw new ArgumentException("connection");

          using (SqlCommand command = connection.CreateCommand())
          {
              command.CommandType = CommandType.StoredProcedure;
              command.CommandText = "p_config_add_setting_override";
              if (!overwrite && DoesSettingOverrideExist(connection, environment, site_id, server, component, setting))
              {
                  SettingOverride so;
                  so = new SettingOverride(environment, site_id, server, component, setting);
                  throw new ExistingSettingOverrideException(so);
              }

              command.Parameters.AddWithValue("@setting", setting);
              command.Parameters.AddWithValue("@value", value);
              command.Parameters.AddWithValue("@environment", environment);
              command.Parameters.AddWithValue("@component", component);
              command.Parameters.AddWithValue("@siteId", site_id);
              command.Parameters.AddWithValue("@server", server);
              command.Parameters.AddWithValue("@overwriteExistingValue", overwrite);

              command.ExecuteNonQuery();
          }
      }

      /// <summary>
      /// Removes a setting override in NPDB
      /// </summary>
      /// <param name="connection">connection to server with npdb present</param>
      /// <param name="environment">deployment environment</param>
      /// <param name="site_id">site ID</param>
      /// <param name="server">server name</param>
      /// <param name="component">setting component</param>
      /// <param name="setting">setting name</param>
      public static void RemoveSettingOverride(
          SqlConnection connection,
          string environment,
          int site_id,
          string server,
          string component,
          string setting)
      {
          if (null == connection)
              throw new ArgumentException("connection");

          using (SqlCommand command = connection.CreateCommand())
          {
              command.CommandType = CommandType.StoredProcedure;
              command.CommandText = "p_config_delete_setting_override";

              command.Parameters.AddWithValue("@setting", setting);
              command.Parameters.AddWithValue("@environment", environment);
              command.Parameters.AddWithValue("@component", component);
              command.Parameters.AddWithValue("@siteId", site_id);
              command.Parameters.AddWithValue("@server", server);

              command.ExecuteNonQuery();
          }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\common\InterfaceBucket.cs ===
﻿using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;
using System.Text.RegularExpressions;

namespace xonline.tools.configuration.buckets {
   [Serializable]
   public partial class InterfaceBucket : IComparable<InterfaceBucket> {
      public InterfaceBucket(SqlDataReader reader) {
         if (null == reader)
            throw new ArgumentNullException("reader");

         UpdateFields(reader);
      }

      //('stressnet2','livecache',0,0,'ST2LSLIVCIIS001','ST2LSLIVCIIS001',2008-06-19 02:21:10.960,'','','','') 
      public InterfaceBucket(string logline) {
         string pattern;
         Match  result;

         if (string.IsNullOrEmpty(logline))
            throw new ArgumentException("can not be null or empty", "logline");
         if (logline.Trim().Length == 0)
            throw new ArgumentException("only contains white space", "logline");

         pattern = 
            @"^\(" +
               @"'(?<environment>(''|[^'])*)'," +
               @"'(?<interface>(''|[^'])*)'," +
               @"(?<title>\d+)," +
               @"(?<bucket>\d+)," +
               @"'(?<server>(''|[^'])*)'," +
               @"'(?<next>(''|[^'])*)'," +
               @"(?<migration>\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\.\d{3})," +
               @"'(?<info1>(''|[^'])*)'," +
               @"'(?<info2>(''|[^'])*)'," +
               @"'(?<info3>(''|[^'])*)'," +
               @"'(?<info4>(''|[^'])*)'" +
            @"\)$";

         result = Regex.Match(logline, pattern);
 
         if (!result.Success)
            throw new ArgumentException("does not match the expected format.", "logline");

         m_environment = result.Groups["environment"].Value;
         m_interface = result.Groups["interface"].Value;
         m_titleid = int.Parse(result.Groups["title"].Value);
         m_bucket = int.Parse(result.Groups["bucket"].Value);
         m_server = result.Groups["server"].Value;
         m_nextServer = result.Groups["server"].Value;
         m_migrationStart = DateTime.Parse(result.Groups["migration"].Value);
         m_info1 = result.Groups["info1"].Value;
         m_info2 = result.Groups["info2"].Value;
         m_info3 = result.Groups["info3"].Value;
         m_info4 = result.Groups["info4"].Value;
      }

      public InterfaceBucket(
         string environment, 
         string iface, 
         string server, 
         string nextServer, 
         int title, 
         int bucket) 
      {
         m_environment = environment;
         m_interface = iface;
         m_server = server;
         m_nextServer = nextServer;
         m_titleid = title;
         m_bucket = bucket;
         m_migrationStart = SqlDateTime.MinValue.Value;
      }

      public InterfaceBucket() { }

      public bool IsMigrating() {
         return m_server != m_nextServer;
      }

      public void Refresh(SqlConnection connection)
      {
          using (SqlDataReader reader = 
              InterfaceBucketControl.GetBucketReader(connection, null, m_environment, m_interface, m_titleid, m_bucket))
          {
              if (reader.Read())
                  UpdateFields(reader);
              else
                  throw new NonExistingInterfaceBucketException(this);
          }
      }

      public string ToString(int outterIndent, int innerIndent) {
         StringBuilder result;
         string outterTab;
         string innerTab;

         if (outterIndent < 0)
            throw new ArgumentOutOfRangeException("outterIndent");
         if (innerIndent < 0)
            throw new ArgumentOutOfRangeException("innerIndent");

         result = new StringBuilder();

         outterTab = string.Empty.PadRight(outterIndent);
         innerTab = string.Empty.PadRight(innerIndent);

         result.AppendLine(outterTab + "{");
         result.AppendLine(string.Format("{1}Environment = {0} ", m_environment, innerTab));
         result.AppendLine(string.Format("{1}Interface = {0} ", m_interface, innerTab));
         result.AppendLine(string.Format("{1}Title = {0} ", m_titleid, innerTab));
         result.AppendLine(string.Format("{1}Bucket = {0} ", m_bucket, innerTab));
         result.AppendLine(string.Format("{1}Server = {0} ", m_server, innerTab));
         result.AppendLine(string.Format("{1}Next Server = {0} ", m_nextServer, innerTab));
         result.AppendLine(string.Format("{1}Migration = '{0}' ", m_migrationStart, innerTab));
         result.AppendLine(string.Format("{1}Info1 = '{0}' ", m_info1 ?? "", innerTab));
         result.AppendLine(string.Format("{1}Info2 = '{0}' ", m_info2 ?? "", innerTab));
         result.AppendLine(string.Format("{1}Info3 = '{0}' ", m_info3 ?? "", innerTab));
         result.AppendLine(string.Format("{1}Info4 = '{0}'", m_info4 ?? "", innerTab));
         result.AppendLine(outterTab + "}");

         return result.ToString();
      }

      public override string ToString() {
         return ToString(0, 3);
      }

      public string m_environment;
      public string m_interface;
      public string m_server;
      public string m_nextServer;
      public int m_titleid;
      public int m_bucket;

      public DateTime m_migrationStart;
      public string m_info1;
      public string m_info2;
      public string m_info3;
      public string m_info4;

      #region IComparable<InterfaceBucket> Members
      int IComparable<InterfaceBucket>.CompareTo(InterfaceBucket other) {
         int result;

         // bubble sort behavior:
         // ORDER BY 
         //    env, iface, titleid, bucket, server, nextServer, migration

         if (0 != (result = m_environment.CompareTo(other.m_environment)))
            return result | 0x40000000;
         if (0 != (result = m_interface.CompareTo(other.m_interface)))
            return result | 0x20000000;
         if (0 != (result = m_titleid.CompareTo(other.m_titleid)))
            return result | 0x10000000;
         if (0 != (result = m_bucket.CompareTo(other.m_bucket)))
            return result | 0x08000000;
         if (0 != (result = m_server.CompareTo(other.m_server)))
            return result | 0x04000000;
         if (0 != (result = m_nextServer.CompareTo(other.m_nextServer)))
            return result | 0x02000000;
         if (0 != (result = m_migrationStart.CompareTo(other.m_migrationStart)))
            return result | 0x01000000;
         if (0 != (result = m_info1.CompareTo(other.m_info1)))
            return result;
         if (0 != (result = m_info2.CompareTo(other.m_info2)))
            return result;
         if (0 != (result = m_info3.CompareTo(other.m_info3)))
            return result;
         if (0 != (result = m_info4.CompareTo(other.m_info4)))
            return result;

         return 0;
      }
      #endregion
   }

   public partial class InterfaceBucket {
      private void UpdateFields(SqlDataReader reader) {
         m_environment = (string)reader["vc_environment"];
         m_interface = (string)reader["vc_interface"];
         m_server = (string)reader["vc_server"];
         m_nextServer = (string)reader["vc_next_server"];
         m_titleid = (int)reader["i_title_id"];
         m_bucket = (int)reader["i_bucket"];

         m_migrationStart = (DateTime)reader["dt_migration_start"];

         m_info1 = (string)reader["vc_info1"];
         m_info2 = (string)reader["vc_info2"];
         m_info3 = (string)reader["vc_info3"];
         m_info4 = (string)reader["vc_info4"];
      }
   }

   public struct InterfaceBucketLog {
      public string ToString(int indentation) {
         StringBuilder result;
         string operation;
         string tab;

         if (indentation < 0)
            throw new ArgumentOutOfRangeException("indentation");

         result = new StringBuilder();

         tab = string.Empty.PadRight(indentation);

         if (null == m_new) operation = "delete";
         else if (null == m_old) operation = "insert";
         else operation = "update";

         result.AppendLine("{");
         result.AppendLine(string.Format("{1}User = {0}", m_user, tab));
         result.AppendLine(string.Format("{1}Application = {0}", m_application, tab));
         result.AppendLine(string.Format("{1}Date = {0}", m_date, tab));
         result.AppendLine(string.Format("{1}Operation = {0}", operation, tab));

         if (null == m_old)
            result.AppendLine(string.Format("{0}Deleted Interface is empty.", tab));
         else {
            result.AppendLine(string.Format("{0}Deleted Interface:", tab));
            result.AppendLine(m_old.ToString(indentation, indentation + 3));
         }

         if (null == m_new)
            result.AppendLine(string.Format("{0}Inserted Interface is empty.", tab));
         else {
            result.AppendLine(string.Format("{0}Inserted Interface:", tab));
            result.AppendLine(m_new.ToString(indentation, indentation + 3));
         }

         result.AppendLine("}");

         return result.ToString();
      }

      public override string ToString() {
         return ToString(3);
      }

      public InterfaceBucket m_old;
      public InterfaceBucket m_new;
      public string m_user;
      public string m_application;
      public DateTime m_date;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Exceptions.cs ===
﻿using System;
using System.Runtime.Serialization;

namespace xonline.tools.configuration {
   [Serializable]
   public class ActionFailedException : Exception {
      public ActionFailedException() { }
      public ActionFailedException(string message) : base(message) { }
      public ActionFailedException(string message, Exception inner) : base(message, inner) { }
      protected ActionFailedException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }
   }

   [Serializable]
   public class SafetyConstraintException : Exception {
      public SafetyConstraintException() { }
      public SafetyConstraintException(string message) : base(message) { }
      public SafetyConstraintException(string message, Exception inner) : base(message, inner) { }
      protected SafetyConstraintException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\common\SettingOverride.cs ===
﻿using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;
using System.Text.RegularExpressions;

namespace xonline.tools.configuration.setting_override
{
    [Serializable]
    public partial class SettingOverride : IComparable<SettingOverride>
    {
        public SettingOverride(SqlDataReader reader)
        {
            if (null == reader)
                throw new ArgumentNullException("reader");

            UpdateFields(reader);
        }

        public SettingOverride(
          string environment,
          int site_id,
          string server,
          string component,
          string setting)
        {
            m_environment = environment;
            m_site_id = site_id;
            m_server = server;
            m_component = component;
            m_setting = setting;
        }

        public SettingOverride() { }


        public void Refresh(SqlConnection connection)
        {
            using (SqlDataReader reader =
                SettingOverrideControl.GetSettingOverride(connection, m_environment, m_site_id, m_server, m_component, m_setting))
            {
                if (reader.Read())
                    UpdateFields(reader);
                else
                    throw new NonExistingSettingOverrideException(this);
            }
        }

        public string ToString(int outterIndent, int innerIndent)
        {
            StringBuilder result;
            string outterTab;
            string innerTab;

            if (outterIndent < 0)
                throw new ArgumentOutOfRangeException("outterIndent");
            if (innerIndent < 0)
                throw new ArgumentOutOfRangeException("innerIndent");

            result = new StringBuilder();

            outterTab = string.Empty.PadRight(outterIndent);
            innerTab = string.Empty.PadRight(innerIndent);

            result.AppendLine(outterTab + "{");
            result.AppendLine(string.Format("{1}Environment = {0} ", m_environment, innerTab));
            result.AppendLine(string.Format("{1}SiteID = {0} ", m_site_id, innerTab));
            result.AppendLine(string.Format("{1}Server = {0} ", m_server, innerTab));
            result.AppendLine(string.Format("{1}Component = {0} ", m_component, innerTab));
            result.AppendLine(string.Format("{1}Setting = '{0}' ", m_setting, innerTab));
            result.AppendLine(string.Format("{1}Value = '{0}' ", m_value, innerTab));
            result.AppendLine(outterTab + "}");

            return result.ToString();
        }

        public override string ToString()
        {
            return ToString(0, 3);
        }
        
        public string m_environment;
        public int m_site_id;
        public string m_server;
        public string m_component;
        public string m_setting;
        public string m_value;

        #region IComparable<SettingOverride> Members
        int IComparable<SettingOverride>.CompareTo(SettingOverride other)
        {
            int result;

            // bubble sort behavior:
            // ORDER BY 
            //    env, site_id, server, component, setting

            if (0 != (result = m_environment.CompareTo(other.m_environment)))
                return result | 0x40000000;
            if (0 != (result = m_site_id.CompareTo(other.m_site_id)))
                return result | 0x20000000;
            if (0 != (result = m_server.CompareTo(other.m_server)))
                return result | 0x10000000;
            if (0 != (result = m_component.CompareTo(other.m_component)))
                return result | 0x08000000;
            if (0 != (result = m_setting.CompareTo(other.m_setting)))
                return result | 0x04000000;
            if (0 != (result = m_value.CompareTo(other.m_value)))
                return result;

            return 0;
        }
        #endregion
    }

    public partial class SettingOverride
    {
        private void UpdateFields(SqlDataReader reader)
        {
            m_environment = (string)reader["vc_environment"];
            m_site_id = (int)reader["i_site_id"];
            m_server = (string)reader["vc_server"];
            m_component = (string)reader["vc_component"];
            m_value = (string)reader["vc_value"];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\common\Exceptions.cs ===
﻿using System;
using System.Runtime.Serialization;
using System.Security.Permissions;

using xonline.tools.configuration.buckets;
using xonline.tools.configuration.setting_override;

namespace xonline.tools.configuration
{
    #region Interface Bucket Exceptions

    [Serializable]
    public class InterfaceBucketException : Exception
    {
        public InterfaceBucketException(InterfaceBucket bucket) { }
        public InterfaceBucketException(InterfaceBucket bucket, string message) : base(message) { }
        public InterfaceBucketException(InterfaceBucket bucket, string message, Exception inner) : base(message, inner) { }
        protected InterfaceBucketException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            m_bucket = (InterfaceBucket)info.GetValue("_bucket", typeof(InterfaceBucket));
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("_bucket", m_bucket);
        }

        public override string Message
        {
            get
            {
                return base.Message + "\n" + (null == m_bucket ? "unspecified bucket" : m_bucket.ToString());
            }
        }

        public InterfaceBucket Bucket
        {
            get { return m_bucket; }
        }

        private InterfaceBucket m_bucket;
    }

    [Serializable]
    public class ExistingInterfaceBucketException : InterfaceBucketException
    {
        public ExistingInterfaceBucketException(InterfaceBucket bucket)
            : base(bucket, "Interface bucket already exists.") { }

        public ExistingInterfaceBucketException(InterfaceBucket bucket, Exception inner)
            : base(bucket, "Interface bucket already exists.", inner) { }

        public ExistingInterfaceBucketException(InterfaceBucket bucket, string message)
            : base(bucket, message) { }

        public ExistingInterfaceBucketException(InterfaceBucket bucket, string message, Exception inner)
            : base(bucket, message, inner) { }

        protected ExistingInterfaceBucketException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }
    }

    [Serializable]
    public class NonExistingInterfaceBucketException : InterfaceBucketException
    {
        public NonExistingInterfaceBucketException(InterfaceBucket bucket)
            : base(bucket, "Interface bucket does not exist.") { }

        public NonExistingInterfaceBucketException(InterfaceBucket bucket, Exception inner)
            : base(bucket, "Interface bucket does not exist.", inner) { }

        public NonExistingInterfaceBucketException(InterfaceBucket bucket, string message)
            : base(bucket, message) { }

        public NonExistingInterfaceBucketException(InterfaceBucket bucket, string message, Exception inner)
            : base(bucket, message, inner) { }

        protected NonExistingInterfaceBucketException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }
    }

    #endregion

    #region Setting Override Exceptions

    [Serializable]
    public class SettingOverrideException : Exception
    {
        public SettingOverrideException(SettingOverride bucket) { }
        public SettingOverrideException(SettingOverride bucket, string message) : base(message) { }
        public SettingOverrideException(SettingOverride bucket, string message, Exception inner) : base(message, inner) { }
        protected SettingOverrideException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            m_setting_override = (SettingOverride)info.GetValue("_bucket", typeof(InterfaceBucket));
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("_bucket", m_setting_override);
        }

        public override string Message
        {
            get
            {
                return base.Message + "\n" + (null == m_setting_override ? "unspecified setting override" : m_setting_override.ToString());
            }
        }

        public SettingOverride SettingOverride
        {
            get { return m_setting_override; }
        }

        private SettingOverride m_setting_override;
    }

    [Serializable]
    public class ExistingSettingOverrideException : SettingOverrideException
    {
        public ExistingSettingOverrideException(SettingOverride settingOverride)
            : base(settingOverride, "Setting override already exists.") { }

        public ExistingSettingOverrideException(SettingOverride settingOverride, Exception inner)
            : base(settingOverride, "Setting override already exists.", inner) { }

        public ExistingSettingOverrideException(SettingOverride settingOverride, string message)
            : base(settingOverride, message) { }

        public ExistingSettingOverrideException(SettingOverride settingOverride, string message, Exception inner)
            : base(settingOverride, message, inner) { }

        protected ExistingSettingOverrideException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }
    }

    [Serializable]
    public class NonExistingSettingOverrideException : SettingOverrideException
    {
        public NonExistingSettingOverrideException(SettingOverride settingOverride)
            : base(settingOverride, "Setting override does not exist.") { }

        public NonExistingSettingOverrideException(SettingOverride settingOverride, Exception inner)
            : base(settingOverride, "Setting override does not exist.", inner) { }

        public NonExistingSettingOverrideException(SettingOverride settingOverride, string message)
            : base(settingOverride, message) { }

        public NonExistingSettingOverrideException(SettingOverride settingOverride, string message, Exception inner)
            : base(settingOverride, message, inner) { }

        protected NonExistingSettingOverrideException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }
    }

    #endregion

    [Serializable]
    public class MissingDatabaseException : Exception
    {
        public MissingDatabaseException() { }
        public MissingDatabaseException(string message) : base(message) { }
        public MissingDatabaseException(string message, Exception inner) : base(message, inner) { }
        protected MissingDatabaseException(SerializationInfo info, StreamingContext context) : base(info, context) { }
    }

    [Serializable]
    public class InstructionParameterException : Exception
    {
        public InstructionParameterException(string message) : base(message) { }
        public InstructionParameterException(string message, Exception inner) : base(message, inner) { }
        protected InstructionParameterException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Application.cs ===
﻿// See http://xblwiki/default.aspx/XboxLive/ConfigNPDB.html on information on how to add more actions.

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;
using System.Reflection;

namespace xonline.tools.configuration
{
    public class Application
    {
        /// <summary>
        /// Main Entry point into the application
        /// </summary>
        /// <param name="args">Console Arguments</param>
        /// <returns>0 on Success, Non-Zero on failure</returns>
        public static int Main(string[] args)
        {
            ApplicationAction rootAction;
            List<string> arguments;

            // First action is the application action container holding Action objects and other child container objects
            rootAction = new ApplicationAction();
            arguments = new List<string>(args);

            if (args.Length == 0)
            {
                ConsoleWriteError("No parameters specified, use the help command for more details.");
                return 1;
            }

            if (Action.NormalizeCommand(args[0]) == "help")
            {
                // display the help text for the passed in action command
                arguments.RemoveAt(0);
                Action.LocateAction(rootAction, arguments.ToArray()).ShowHelp();
                return 0;
            }
            else
            {
                // process the command
                Action command;
                string[] commandArguments;
                StringDictionary parameters;

                // locate the final child node for the action command object
                try
                {
                    command = Action.LocateAction(rootAction, arguments.ToArray(), false, false, out commandArguments);
                }
                catch (ArgumentException e)
                {
                    ConsoleWriteError(e.Message);
                    return 1;
                }
                catch (Exception e)
                {
                    ShowUnexpectedException(e);
                    return 2;
                }

                // prepare the action with the parameters provided
                try
                {
                    parameters = Action.BuildParameterDictionary(command, commandArguments);
                    command.IngestParameters(parameters);
                }
                catch (ArgumentException e)
                {
                    ConsoleWriteError("Usage: " + command.Command + " " + command.FormattedUsage);
                    Console.WriteLine();
                    ConsoleWriteError(e.Message);
                    return 1;
                }
                catch (SafetyConstraintException e)
                {
                    ConsoleWriteError("Action Blocked: " + e.Message);
                    return 1;
                }
                catch (Exception e)
                {
                    ShowUnexpectedException(e);
                    return 2;
                }

                // run the command
                try
                {
                    Console.WriteLine();
                    Console.WriteLine("Invoking {0} command with parameters:", command.Name);
                    foreach (string key in parameters.Keys)
                        Console.WriteLine("   {0} = {1}", key, parameters[key] ?? "(null)");
                    Console.WriteLine();

                    command.Execute();

                    Console.WriteLine();
                    ConsoleWriteSuccess("Command {0} executed successfully.", command.Name);
                }
                catch (MissingDatabaseException e)
                {
                    ConsoleWriteError("Error: {0}", e.Message);
                    return 2;
                }
                catch (SqlException inner)
                {
                    ConsoleWriteError("SQL Error: {0}", inner.Message);
                    return 2;
                }
                catch (ActionFailedException e)
                {
                    ConsoleWriteError("Command {0} terminated with failures: {1}", command.Name, e.Message ?? "");
                    return 2;
                }
                catch (Exception e)
                {
                    ShowUnexpectedException(e);
                    return 2;
                }
            }

            return 0;
        }

        #region Utility Console Functions

        public static void ConsoleWriteError(string format, params object[] args)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(format, args);
            Console.ResetColor();
        }

        public static void ConsoleWriteSuccess(string format, params object[] args)
        {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine(format, args);
            Console.ResetColor();
        }

        private static void ShowUnexpectedException(Exception inner)
        {
            ConsoleWriteError("Unexpected Exception:");
            ConsoleWriteError(inner.ToString());
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\SafetyConstraints.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;
using System.Reflection;

namespace xonline.tools.configuration {
   public static class SafetyConstraints {
      public static bool AllowProductionEnvironmentWrites = false;

      public static void AssertDevelopmentEnvironment(SqlConnection connection, string environment) {
         if (!AllowProductionEnvironmentWrites) {
            using (SqlCommand command = connection.CreateCommand()) {
               command.CommandText = "p_config_get_environment";
               command.CommandType = System.Data.CommandType.StoredProcedure;
               command.Parameters.AddWithValue("@vc_environment", environment);

               using (SqlDataReader reader = command.ExecuteReader()) {
                  string environmentType;

                  if (!reader.Read())
                     throw new ArgumentException(environment + " is not present in t_environments", "environment");

                  environmentType = (string)reader["vc_environment_type"];

                  if (environmentType != "development")
                     throw new SafetyConstraintException(environment + " is not a development environment");
               }
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Action.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;

namespace xonline.tools.configuration
{
    public interface ITransactableAction 
    {
        void Execute(SqlTransaction transaction);
    }

    public abstract partial class Action
    {
        public const string GLOBAL_PARAM_NPDB_SERVER = "npdbServer";
        public const string GLOBAL_PARAM_NPDB_DATABASE = "npdbDatabase";

        public static SqlConnection GetConnection(string server, string database)
        {
            SqlConnection masterConnection;
            SqlConnection connection = null;

            using (masterConnection = new SqlConnection(GetConnectionString(server, "master")))
            {
                masterConnection.Open();

                using (SqlCommand command = masterConnection.CreateCommand())
                {
                    command.CommandText = string.Format("SELECT 1 FROM sysdatabases NOLOCK WHERE name='{0}'", database);
                    command.CommandType = System.Data.CommandType.Text;

                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        if (!reader.Read())
                            throw new MissingDatabaseException(
                               string.Format("the server {0} does not contain {1}.", server, database));
                    }

                    connection = new SqlConnection(GetConnectionString(server, database));
                    connection.Open();
                }
            }

            return connection;
        }

        public static string GetConnectionString(string server, string database)
        {
            if (string.IsNullOrEmpty(server))
                throw new ArgumentException("cannot be null or empty", "server");
            if (string.IsNullOrEmpty(database))
                throw new ArgumentException("cannot be null or empty", "database");

            SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();
            builder.IntegratedSecurity = true;
            builder.DataSource = server;
            builder.InitialCatalog = database;

            return builder.ConnectionString;
        }

        public Action(Action parent)
        {
            m_children = new List<Action>();
            m_parent = parent;
        }

        public abstract void IngestParameters(StringDictionary args);
        public abstract void Execute();

        public string FormattedUsage
        {
            //HACK: to keep named parameter blocks together
            get { return Usage.Replace('\a', ' '); }
        }

        public string Usage
        {
            get
            {
                StringBuilder usage;

                usage = new StringBuilder();

                foreach (Parameter parameter in Parameters)
                {
                    if (parameter.m_positional)
                    {
                        usage.AppendFormat(
                           "{0}{1}{2} ",
                           parameter.m_optional ? "[" : "(",
                           parameter.m_name,
                           parameter.m_optional ? "]" : ")");
                    }
                    else
                    {
                        //HACK: (\a) see ConstructUsageBlock or FormattedUsage
                        usage.AppendFormat(
                           "{0}-{1}\avalue{2} ",
                           parameter.m_optional ? "[" : "(",
                           parameter.m_name,
                           parameter.m_optional ? "]" : ")");
                    }
                }

                return usage.ToString().Trim();
            }
        }

        public Action[] Children { get { return m_children.ToArray(); } }
        public abstract string Name { get; }
        public abstract Parameter[] Parameters { get; }

        public string ShortDescription
        {
            get { return Description.Split('.')[0] + "."; }
        }

        public abstract string Description { get; }
        public virtual string[] Constraints { get { return new string[0]; } }
        public virtual string ExtraHelp { get { return ""; } }

        protected List<Action> m_children;
        protected Action m_parent;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\ApplicationAction.cs ===
﻿using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using xonline.tools.configuration.buckets;
using xonline.tools.configuration.setting_override;

namespace xonline.tools.configuration
{
    public class ApplicationAction : Action
    {
        public ApplicationAction()
            : base(null)
        {
            m_children.Add(new BucketAction(this));
            m_children.Add(new SettingOverrideAction(this));
            m_children.Add(new RegisterNPDB(this));

            ConfigureServerChildren();
        }

        private void ConfigureServerChildren() 
        {
            ContainerAction server;

            server = new ContainerAction
            (
                this,
                "server",
                "Server specific configuration operations.",
                ConfigureLiveCacheServerChildren
            );

            m_children.Add(server);
        }

        private IEnumerable<Action> ConfigureLiveCacheServerChildren(ContainerAction serverDeferred)
        {
            ContainerAction livecache;

            livecache = new ContainerAction
            (
                serverDeferred, 
                "livecache", 
                "Livecache server configuration operations.",
                delegate (ContainerAction livecacheDeferred) 
                {
                    return new Action[] 
                    {
                        new servers.RemoveLivecacheServers(livecacheDeferred),
                        new servers.RestoreLivecacheBucketing(livecacheDeferred)
                    };
                }
            );

            return new Action[] { livecache };
        }

        public override void IngestParameters(System.Collections.Specialized.StringDictionary args)
        {
            throw new NotImplementedException();
        }

        public override void Execute()
        {
            throw new NotImplementedException();
        }

        public override string Name
        {
            get { return Assembly.GetEntryAssembly().GetName().Name; }
        }

        public override string Description
        {
            get { return "Console utility created for management of NPDB resources including settings and server data."; }
        }

        public override Parameter[] Parameters
        {
            get { throw new NotImplementedException(); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Action.HelpText.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;

namespace xonline.tools.configuration {
   public abstract partial class Action {
      private const string TAB = "   ";

      public string Command {
         get { return m_parent == null ? Name : m_parent.Command + " " + Name; }
      }

      protected string HelpCommand {
         get { return m_parent == null ? Name + " help" : m_parent.HelpCommand + " " + Name; }
      }

      private static StringBuilder CreateNewIndentedLine(int indent) {
         StringBuilder result;

         result = new StringBuilder();
         result.Append(" ".PadRight(indent));

         return result;
      }

      protected static int WindowWidth {
         get {
            try { 
               return Console.WindowWidth; 
            }
            catch (IOException) { // not running in a console (no console buffer)
               return 1024;
            }
         }
      }

      public static string AdjustConsoleText(int indent, string prefix, string text, bool trim) {
         StringBuilder result = new StringBuilder();
         StringBuilder line = new StringBuilder();
         List<string> lines = new List<string>();
         int target = WindowWidth;
         int consumed = 0;

         text = text.Replace("\r\n", "\n");
         lines.AddRange(text.Split('\n'));

         if (!string.IsNullOrEmpty(prefix)) {
            line.Append(prefix);
            consumed = 1;
         }

         while (lines.Count > 0) {
            string adjustedLine = trim ? lines[0].Trim() : lines[0];
            List<string> words = new List<string>();

            words.AddRange(adjustedLine.Split(
               new char[] { ' ', '\t' }));

            while (words.Count > 0) {
               while (words.Count > 0) {
                  string word = words[0] + (words.Count > 1 ? " " : "");

                  if (line.Length + word.Length >= target) {
                     if (consumed > 0) {
                        line.AppendLine(); //hard new line

                        break;
                     }
                     else if (target - line.Length > 1) {
                        words[0] = words[0].Substring(target - line.Length - 1);

                        line.Append(word.Substring(0, target - line.Length - 1));
                        line.Append("-"); //soft new line

                        break;
                     }
                     else { //its ugly but we need to make some progress
                        line.AppendLine(word); //soft and hard new line
                        words.RemoveAt(0);

                        break;
                     }
                  }
                  else {
                     line.Append(word);

                     words.RemoveAt(0);
                     consumed++;
                  }
               }

               result.Append(line.ToString());
               line = CreateNewIndentedLine(indent);
               consumed = 0;
            }

            lines.RemoveAt(0);

            if (lines.Count > 0)
               result.AppendLine();
         }

         return result.ToString();
      }

      public static string AdjustConsoleText(int indent, string prefix, string text) {
         return AdjustConsoleText(indent, prefix, text, true);
      }

      private string ConstructSimpleIndentedBlock(int indent, string prefix, string text) {
         return AdjustConsoleText(indent, prefix, text);
      }

      private string ConstructDescriptionBlock() {
         string prefix;

         prefix = TAB + Name + " -- ";

         return AdjustConsoleText(prefix.Length, prefix, Description);
      }

      private string ConstructParameterDetails() {
         StringBuilder text = new StringBuilder();
         int longestName = 0;
         int indent = 0;

         foreach (Parameter param in Parameters)
            longestName = Math.Max(longestName, param.m_name.Length);

         indent = longestName + TAB.Length * 2;

         foreach (Parameter param in Parameters) {
            string line;

            line = AdjustConsoleText(
               indent,
               TAB + param.m_name.PadRight(longestName) + TAB,
               (param.m_optional ? "Optional. " : "") + param.m_description);

            text.AppendLine(line);
         }

         return text.ToString();
      }

      private string ConstructChildActionDetails() {
         StringBuilder text = new StringBuilder();
         int longestText = 0;
         int indent = 0;

         foreach (Action action in m_children)
            longestText = Math.Max(longestText, action.HelpCommand.Length);

         indent = longestText + TAB.Length * 2;

         foreach (Action action in m_children) {
            string line;

            line = AdjustConsoleText(
               indent,
               TAB + action.HelpCommand.PadRight(longestText) + TAB,
               action.ShortDescription);

            text.AppendLine(line);
         }

         return text.ToString();
      }

      private void ConsoleWriteTitle(string header) {
         if (Console.BackgroundColor != ConsoleColor.White)
            Console.ForegroundColor = ConsoleColor.White;

         Console.WriteLine(header);

         Console.ResetColor();
      }

      private string ConstructUsageBlock() {
         string usage;
         string prefix;

         prefix = TAB + Command + " ";
         usage  = ConstructSimpleIndentedBlock(prefix.Length, prefix, Usage);

         //HACK: to keep named parameter blocks together
         return usage.Replace('\a', ' ');
      }

      public void ShowHelp() {
         Console.WriteLine();
         ConsoleWriteTitle("Description:");
         Console.WriteLine(ConstructDescriptionBlock());

         if (m_children.Count > 0) {
            Console.WriteLine();
            ConsoleWriteTitle("For more details on sub-commands try:");
            Console.WriteLine(ConstructChildActionDetails());
         }
         else {
            Console.WriteLine();
            ConsoleWriteTitle("Usage:");
            Console.WriteLine(ConstructUsageBlock());

            Console.WriteLine();
            ConsoleWriteTitle("Parameters:");
            Console.WriteLine(ConstructParameterDetails());

            if (Constraints.Length > 0) {
               Console.WriteLine();
               ConsoleWriteTitle("Constraints:");
               foreach (string constraint in Constraints)
                  Console.WriteLine(ConstructSimpleIndentedBlock(TAB.Length * 2, TAB, constraint));
            }

            if (!string.IsNullOrEmpty(ExtraHelp)) {
               Console.WriteLine();
               Console.WriteLine(ExtraHelp);
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Action.CommandLine.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

namespace xonline.tools.configuration
{
    public abstract partial class Action
    {
        /// <summary>
        /// Removes all leading and trailing whitespaces, prefix dashes and slashes and converts to all lowercase
        /// </summary>
        /// <param name="argument">argument string</param>
        /// <returns>normalized string</returns>
        public static string NormalizeCommand(string argument)
        {
            argument = argument.Trim();
            argument = argument.TrimStart('-', '\\', '/');

            return argument.ToLower();
        }

        /// <summary>
        /// Determines if a string is a named parameter
        /// </summary>
        /// <param name="argument">argument string</param>
        /// <returns>true if named, false otherwise</returns>
        private static bool IsNamedParameter(string argument)
        {
            argument = argument.Trim();
            if (argument.StartsWith("-"))
                return true;
            if (argument.StartsWith("\\"))
                return true;
            if (argument.StartsWith("/"))
                return true;
            return false;
        }

        /// <summary>
        /// Creates and returns a StringDictionary of parameters
        /// </summary>
        /// <param name="root">The root command action</param>
        /// <param name="arguments">action argument strings</param>
        /// <returns>Parameter Dictionary</returns>
        public static StringDictionary BuildParameterDictionary(Action root, string[] arguments)
        {
            StringDictionary result;
            List<string> remainingArguments = new List<string>(arguments);
            Dictionary<string, Parameter> namedParameters = new Dictionary<string, Parameter>();
            Dictionary<string, Parameter> requiredNamedParameters = new Dictionary<string, Parameter>();

            result = new StringDictionary();

            // read the positional parameters, and defer the named arguments for later processing
            foreach (Parameter parameter in root.Parameters)
            {
                if (!parameter.m_positional)
                {
                    namedParameters.Add(parameter.m_name, parameter);

                    if (!parameter.m_optional)
                        requiredNamedParameters.Add(parameter.m_name, parameter);

                    continue;
                }

                if (0 == remainingArguments.Count)
                {
                    if (parameter.m_optional)
                        continue;

                    // we have a positional required parameter that isn't specified
                    throw new ArgumentException("Missing positional parameter.", parameter.m_name);
                }

                if (parameter.m_optional)
                {
                    if (!IsNamedParameter(remainingArguments[0]))
                    {
                        result.Add(parameter.m_name, remainingArguments[0]);
                        remainingArguments.RemoveAt(0);
                    }
                }
                else
                {
                    result.Add(parameter.m_name, remainingArguments[0]);
                    remainingArguments.RemoveAt(0);
                }
            }

            while (remainingArguments.Count > 1)
            {
                if (IsNamedParameter(remainingArguments[0]))
                {
                    string name = NormalizeCommand(remainingArguments[0]);

                    if (namedParameters.ContainsKey(name))
                    {
                        result.Add(name, remainingArguments[1]);
                        remainingArguments.RemoveRange(0, 2);
                        namedParameters.Remove(name);
                        requiredNamedParameters.Remove(name);
                    }
                    else
                        throw new ArgumentException("Unexpected named parameter.", name);
                }
                else
                    throw new ArgumentException("Unexpected nameless parameter.", remainingArguments[0]);
            }

            if (requiredNamedParameters.Count > 0)
                throw new ArgumentException("Missing required named parameters.");

            if (remainingArguments.Count > 0)
                throw new ArgumentException("Unexpected trailing argument.", remainingArguments[0]);

            return result;
        }

        /// <summary>
        /// Returns the corresponding Action object being referenced in the root command
        ///     by recursing down to the last child
        /// </summary>
        /// <param name="root">root command</param>
        /// <param name="arguments">argument strings</param>
        /// <returns>Action object</returns>
        public static Action LocateAction(Action root, string[] arguments)
        {
            string[] stuffToIgnore;

            return LocateAction(root, arguments, true, true, out stuffToIgnore);
        }

        /// <summary>
        /// Returns the corresponding Action object being referenced in the root command
        ///     by recursing down to the last child
        /// </summary>
        /// <param name="root">root command</param>
        /// <param name="arguments">argument strings</param>
        /// <param name="allowNodeMatch">allow node match</param>
        /// <param name="allowPartialMatch">allow partial match</param>
        /// <param name="parameters">result parameters</param>
        /// <returns>Action object</returns>
        public static Action LocateAction(
           Action root,
           string[] arguments,
           bool allowNodeMatch,
           bool allowPartialMatch,
           out string[] parameters)
        {
            List<string> resultParameters = new List<string>(arguments);
            List<string> consumedParameters = new List<string>();

            while ((resultParameters.Count > 0) && (root.Children.Length > 0))
            {
                string command = NormalizeCommand(resultParameters[0]);
                Action next = null;

                foreach (Action action in root.Children)
                {
                    if (action.Name == command)
                    {
                        consumedParameters.Add(command); //record keeping for error reporting
                        resultParameters.RemoveAt(0); //remove command from parameter list

                        next = action;
                    }
                }

                if (null == next)
                {
                    if (!allowPartialMatch)
                        throw new ArgumentException("Unexpected command, see: " + root.HelpCommand, command);
                    else
                        break;
                }
                else
                    root = next;
            }

            if ((root.Children.Length > 0) && !allowNodeMatch)
                throw new ArgumentException("Incomplete command specification, see: " + root.HelpCommand);

            parameters = resultParameters.ToArray();
            return root;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\RegisterNPDB.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using Microsoft.Win32;

using xonline.tools.configuration.buckets;

namespace xonline.tools.configuration {
   public class RegisterNPDB : Action {
      private const string PARAM_NPDB_SERVER = "npdbServer";
      private const string PARAM_NPDB_DATABASE = "npdbDatabase";

      private const string NativeKey = "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\XboxLive\\CommonConfig";
      private const string WoW64Key = "HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\XboxLive\\CommonConfig";

      public RegisterNPDB(Action parent) 
         : base(parent) { }

      public override void IngestParameters(StringDictionary args) {
          npdbServer = args[PARAM_NPDB_SERVER];
          npdbDatabase = args[PARAM_NPDB_DATABASE];
      }

      public override void Execute() {
          Registry.SetValue(NativeKey, "Server", npdbServer);
          if (IntPtr.Size == 8) //64-bit platform make sure to write to the WoW registry as well.
              Registry.SetValue(WoW64Key, "Server", npdbServer);

          Registry.SetValue(NativeKey, "Database", npdbDatabase);
          if (IntPtr.Size == 8) //64-bit platform make sure to write to the WoW registry as well.
              Registry.SetValue(WoW64Key, "Database", npdbDatabase);
         
      }

      public override string Name {
         get { return "register-npdb"; }
      }

      public override string Description {
         get { return "Stores the npdb server and database names in the local windows registry."; }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               new Parameter(PARAM_NPDB_SERVER,   "name associated with the server hosting npdb."),
               new Parameter(PARAM_NPDB_DATABASE, "name associated with the database hosting npdb.")
            );
         }
      }

      private string npdbServer;
      private string npdbDatabase;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\ContainerAction.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;

namespace xonline.tools.configuration {
   public delegate IEnumerable<Action> DeferredChildList(ContainerAction self);

   public class ContainerAction : Action {
      private ContainerAction(Action parent, string name, string description)
         : base(parent)
      {
         if (string.IsNullOrEmpty(name))
            throw new ArgumentNullException("name");
         if (string.IsNullOrEmpty(description))
            throw new ArgumentNullException("description");

         this.name = name;
         this.description = description;
      }

      public ContainerAction(Action parent, string name, string description, IEnumerable<Action> children)
         : this(parent, name, description)
      {
         if (null == children)
            throw new ArgumentNullException("children");

         this.m_children.AddRange(children);

         if (0 == this.m_children.Count)
            throw new ArgumentException("no children specified", "children");
      }

      public ContainerAction(Action parent, string name, string description, DeferredChildList deferredChildren)
         : this(parent, name, description)
      {
         if (null == deferredChildren)
            throw new ArgumentNullException("deferredChildren");

         this.m_children.AddRange(deferredChildren(this));

         if (0 == this.m_children.Count)
            throw new ArgumentException("no children specified", "children");
      }

      public override void IngestParameters(StringDictionary args) {
         throw new NotSupportedException();
      }

      public override void Execute() {
         throw new NotSupportedException();
      }

      public override string Name {
         get { return name; }
      }

      public override string Description {
         get { return description; }
      }

      public override Parameter[] Parameters {
         get { throw new NotImplementedException(); }
      }

      private string name;
      private string description;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\BucketAction.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

namespace xonline.tools.configuration.buckets
{
    /// <summary>
    /// A container for all interface bucket actions
    /// </summary>
    public class BucketAction : Action
    {
        private const string PARAM_NPDB_SERVER = GLOBAL_PARAM_NPDB_SERVER;
        private const string PARAM_NPDB_DATABASE = GLOBAL_PARAM_NPDB_DATABASE;
        private const string PARAM_ENV = "env";
        private const string PARAM_IFACE_O = "iface";
        private const string PARAM_TITLE_O = "title";
        
        /// <summary>
        /// Constructor for the Bucket container
        /// </summary>
        /// <param name="parent">Parent container object</param>
        public BucketAction(Action parent)
            : base(parent)
        {
            if (this.GetType() == typeof(BucketAction))
            {
                m_children.Add(new ServerAction(this));
                m_children.Add(new XmlAction(this));
                m_children.Add(new InsertBucket(this));
                m_children.Add(new DeleteBucket(this));
                m_children.Add(new ClearInterface(this));
                m_children.Add(new QueryLog(this));
                m_children.Add(new QueryInterfaces(this));
            }

            m_forceInterface = true;
            m_forceTitle = false;
        }

        /// <summary>
        /// Returns the SQL Connection object to NPDB
        /// </summary>
        /// <returns>SQL Connection object</returns>
        protected SqlConnection GetConnection()
        {
            return GetConnection(m_npdbServer, m_npdbDatabase);
        }

        /// <summary>
        /// Sets the member variables according to the parameters
        /// </summary>
        /// <param name="args"></param>
        public override void IngestParameters(StringDictionary args)
        {
            m_npdbServer = Parameter.ReadString(args, PARAM_NPDB_SERVER);
            m_npdbDatabase = Parameter.ReadString(args, PARAM_NPDB_DATABASE);
            m_environment = Parameter.ReadString(args, PARAM_ENV);
            m_interface = Parameter.ReadString(args, PARAM_IFACE_O, true);
            if (args.ContainsKey(PARAM_TITLE_O))
                m_title = Parameter.ReadTitleId(args, PARAM_TITLE_O);
        }

        /// <summary>
        /// Not supported
        /// </summary>
        public override void Execute()
        {
            throw new NotSupportedException();
        }

        /// <summary>
        /// "bucket"
        /// </summary>
        public override string Name
        {
            get { return "bucket"; }
        }

        /// <summary>
        /// "Interface bucket configuration and information operations."
        /// </summary>
        public override string Description
        {
            get { return "Interface bucket configuration and information operations."; }
        }

        /// <summary>
        /// Constraints to the Bucket container
        /// </summary>
        public override string[] Constraints
        {
            get
            {
                return Parameter.JoinConstraints(
                   "The application user must have login and write access for the npdb database for the specified npdb server.",
                   "The specified environment must be present in t_environments to satisfy FK constraints.",
                   "The specified interface must be present in t_interfaces to satisfy FK constraints."
                );
            }
        }

        /// <summary>
        /// Parameters property of bucket container
        /// </summary>
        public override Parameter[] Parameters
        {
            get
            {
                return Parameter.JoinParameters(
                   new Parameter(PARAM_NPDB_SERVER, "host name of the server with the npdb database."),
                   new Parameter(PARAM_NPDB_DATABASE, "name of the npdb database."),
                   new Parameter(PARAM_ENV, "target environment name."),
                   m_forceInterface ?
                      new Parameter(PARAM_IFACE_O, "target interface name.") :
                      new Parameter(PARAM_IFACE_O, "target interface name.", true, true),
                   m_forceTitle ?
                      new Parameter(PARAM_TITLE_O, "target title identifier in integer or 0x prefixed hex format.") :
                      new Parameter(PARAM_TITLE_O, "target title identifier in integer or 0x prefixed hex format.", true, true)
                );
            }
        }

        /// <summary>
        /// Environment variable
        /// </summary>
        protected string Environment
        {
            get { return m_environment; }
        }

        /// <summary>
        /// Interface variable
        /// </summary>
        protected string Interface
        {
            get { return m_interface; }
        }

        /// <summary>
        /// Title ID or null
        /// </summary>
        protected int? Title
        {
            get { return m_title; }
        }

        /// <summary>
        /// NPDB Connection String
        /// </summary>
        protected string ConnectionString
        {
            get { return GetConnectionString(m_npdbServer, m_npdbDatabase); }
        }

        private string m_npdbServer;
        private string m_npdbDatabase;
        private string m_environment;
        private string m_interface;
        private int? m_title;
        protected bool m_forceInterface;
        protected bool m_forceTitle;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Parameter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Globalization;
using System.Text;


namespace xonline.tools.configuration
{
    public struct Parameter
    {
        public static string GetParameterOptionText(Type enumeration)
        {
            return string.Format(
               "The following are valid values: {0}.",
               string.Join(", ", Enum.GetNames(enumeration)));
        }

        public static string[] JoinConstraints(params string[] constraints)
        {
            return JoinConstraints(null, constraints);
        }

        public static string[] JoinConstraints(string[] baseConstraints, params string[] constraints)
        {
            List<string> results;

            results = new List<string>();

            if (null != baseConstraints)
                results.AddRange(baseConstraints);
            if (null != constraints)
                results.AddRange(constraints);

            return results.ToArray();
        }

        public static Parameter[] JoinParameters(params Parameter[] parameters)
        {
            return JoinParameters(null, parameters);
        }

        public static Parameter[] JoinParameters(Parameter[] baseParameters, params Parameter[] parameters)
        {
            List<Parameter> joined = new List<Parameter>();
            List<Parameter> results = new List<Parameter>();
            List<Parameter> nonPositional = new List<Parameter>();
            List<Parameter> optionalPositional = new List<Parameter>();
            List<string> optionalPositionalNames = new List<string>();

            if (null != baseParameters)
                joined.AddRange(baseParameters);
            if (null != parameters)
                joined.AddRange(parameters);

            foreach (Parameter parameter in joined)
            {
                if (!parameter.m_positional)
                    nonPositional.Add(parameter);
                else if (parameter.m_optional)
                {
                    optionalPositional.Add(parameter);
                    optionalPositionalNames.Add(parameter.m_name);
                }
                else
                    results.Add(parameter);
            }

            if (optionalPositional.Count > 1)
            {
                throw new InvalidOperationException(
                   "multiple optional positional parameters specified. (" +
                   string.Join(", ", optionalPositionalNames.ToArray()) + ")"
                );
            }

            foreach (Parameter parameter in optionalPositional)
                results.Add(parameter);

            foreach (Parameter parameter in nonPositional)
                results.Add(parameter);

            return results.ToArray();
        }

        public static string ReadString(StringDictionary args, string name, bool optional)
        {
            if (!args.ContainsKey(name) && !optional)
                throw new ArgumentException("parameter missing", name);

            return args[name];
        }

        public static string ReadString(StringDictionary args, string name)
        {
            return ReadString(args, name, false);
        }

        private static int ReadInt(string value, string name)
        {
            try { return int.Parse(value); }
            catch (FormatException inner)
            {
                throw new ArgumentException("not a valid int", name, inner);
            }
        }

        private static int ReadTitleId(string value, string name)
        {
           value = value.ToLower().Trim();

           if (value.StartsWith("0x")) {
              try {
                 return int.Parse(value.Substring(2), NumberStyles.HexNumber);
              }
              catch (FormatException inner) {
                 throw new ArgumentException("not a valid hex number", name, inner);
              }
           }
           else
              return ReadInt(value, name);
        }

        public static T ReadEnum<T>(StringDictionary args, string name) where T : struct
        {
            try { return (T)Enum.Parse(typeof(T), args[name], true); }
            catch (ArgumentException inner)
            {
                throw new ArgumentException(
                   "not a valid " + typeof(T).Name + ".  " + GetParameterOptionText(typeof(T)),
                   name,
                   inner);
            }
        }

        public static DateTime ReadDate(StringDictionary args, string name)
        {
            try
            {
                return DateTime.Parse(args[name]);
            }
            catch (FormatException inner)
            {
                throw new ArgumentException("not a valid date", name, inner);
            }
        }

        public static int ReadInt(StringDictionary args, string name)
        {
            return ReadInt(args[name], name);
        }

        public static int ReadPositiveInt(StringDictionary args, string name)
        {
            int result = ReadInt(args, name);

            if (result < 0)
                throw new ArgumentException("value cannot be negative", name);

            return result;
        }

        public static int ReadTitleId(StringDictionary args, string name) 
        {
            return ReadTitleId(args[name], name);
        }
        
        public static int[] ReadCommaSeparatedTitleIdList(StringDictionary args, string name)
        {
           string[] strings;
           int[] results;

           strings = ReadCommaSepartedList(args, name, true);
           results = new int[strings.Length];

           for (int c = 0; c < strings.Length; c++)
              results[c] = ReadTitleId(strings[c], string.Format("{0}[{1}]", name, c));

           return results;
        }

        public static int[] ReadCommaSepartedIntList(StringDictionary args, string name)
        {
            string[] strings;
            int[] results;

            strings = ReadCommaSepartedList(args, name, true);
            results = new int[strings.Length];

            for (int c = 0; c < strings.Length; c++)
                results[c] = ReadInt(strings[c], string.Format("{0}[{1}]", name, c));

            return results;
        }

        public static string[] ReadCommaSepartedList(StringDictionary args, string name, bool trim)
        {
            string[] results;

            results = args[name].Split(
               new string[] { "," },
               StringSplitOptions.RemoveEmptyEntries);

            if (trim)
            {
                for (int c = 0; c < results.Length; c++)
                    results[c] = results[c].Trim();
            }

            return results;
        }

        public Parameter(string name, string description) : this(name, description, false, true) { }
        public Parameter(string name, string description, bool optional) : this(name, description, optional, !optional) { }
        public Parameter(string name, string description, bool optional, bool positional)
        {
            m_name = name;
            m_description = description;
            m_optional = optional;
            m_positional = positional;
        }

        public string m_name;
        public string m_description;
        public bool m_optional;
        public bool m_positional;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\ClearInterface.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;

namespace xonline.tools.configuration.buckets {
   public class ClearInterface : BucketAction, ITransactableAction {
      public ClearInterface(Action parent) : base(parent) {

      }

      public override void IngestParameters(StringDictionary args) {
         base.IngestParameters(args);

         try {
            using (SqlConnection connection = GetConnection()) {
               SafetyConstraints.AssertDevelopmentEnvironment(
                  connection,
                  Environment);
            }
         }
         catch (MissingDatabaseException) {
            // nothing doing
         }

         _initialized = true;
      }

      public override void Execute() {
         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         try {
            using (SqlConnection connection = GetConnection()) {
               using (SqlTransaction transaction = connection.BeginTransaction(Guid.NewGuid().ToString("N"))) {
                  try {
                     Execute(transaction);
                     transaction.Commit();
                  }
                  catch {
                     Console.WriteLine("Error encountered, rolling back transaction.");
                     transaction.Rollback();
                     throw;
                  }
               }
            }
         }
         catch (MissingDatabaseException inner) {
            Console.WriteLine("Database not present, skipping operation: {0}", inner.Message);
         }
      }

      public void Execute(SqlTransaction transaction) {
         SqlConnection connection;
         int results;

         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         connection = transaction.Connection;

         if (Title.HasValue) {
            Console.WriteLine("deleting interface buckets ({0}, {1}, {2})...", Environment, Interface, Title.Value);
            results = InterfaceBucketControl.ClearBuckets(connection, transaction, Environment, Interface, Title.Value);
         }
         else {
            Console.WriteLine("deleting interface buckets ({0}, {1})...", Environment, Interface);
            results = InterfaceBucketControl.ClearBuckets(connection, transaction, Environment, Interface);
         }

         Console.WriteLine("deleted {0} interface bucket rows", results);
      }

      public override string Name {
         get { return "clear"; }
      }

      public override string Description {
         get { 
            return 
               "Deletes all buckets from the specified interface.  " +
               "This operation is always scoped to an environment, and title when specified.  " +
               "If a title is specified only buckets for that title and interface will be removed, " +
               "otherwise all buckets for that interface will be removed."; 
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               base.Constraints,
               "The specified environment must be a development environment.  This is set in place to prevent disruptions to production environments."
            );
         }
      }

      private bool   _initialized;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\DeleteBucket.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;

namespace xonline.tools.configuration.buckets {
   public class DeleteBucket : BucketAction, ITransactableAction {
      private const string PARAM_BUCKET = "bucket";

      public DeleteBucket(Action parent)
         : base(parent) 
      {
         m_forceTitle = true;
      }

      public override void IngestParameters(StringDictionary args) {
         base.IngestParameters(args);

         _bucket = Parameter.ReadInt(args, PARAM_BUCKET);

         try {
            using (SqlConnection connection = GetConnection()) {
               SafetyConstraints.AssertDevelopmentEnvironment(
                  connection,
                  Environment);
            }
         }
         catch (MissingDatabaseException) {
            // nothing doing
         }

         _initialized = true;
      }

      public override void Execute() {
         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         try {
            using (SqlConnection connection = GetConnection()) {
               using (SqlTransaction transaction = connection.BeginTransaction(Guid.NewGuid().ToString("N"))) {
                  try {
                     Execute(transaction);
                     transaction.Commit();
                  }
                  catch {
                     Console.WriteLine("Error encountered, rolling back transaction.");

                     transaction.Rollback();
                     throw;
                  }
               }
            }
         }
         catch (MissingDatabaseException inner) {
            Console.WriteLine("Database not present, skipping operation: {0}", inner.Message);
         }
      }

      public void Execute(SqlTransaction transaction) {
         SqlConnection connection;

         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         connection = transaction.Connection;

         Console.WriteLine("Deleting bucket...");

         InterfaceBucketControl.DeleteBucket(
            connection,
            transaction,
            Environment,
            Interface,
            Title.Value,
            _bucket
         );
      }

      public override string Name {
         get { return "delete"; }
      }

      public override string Description {
         get {
            return
               "Deletes a bucket from the specified interface.  " +
               "If the specified interface bucket does not exists this operation will be a no-op.";
         }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               base.Parameters,
               new Parameter(PARAM_BUCKET, "target bucket number.")
            );
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               base.Constraints,
               "The specified environment must be a development environment.  This is set in place to prevent disruptions to production environments."
            );
         }
      }

      private bool _initialized;
      private int _bucket;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\InsertBucket.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;

namespace xonline.tools.configuration.buckets {
   public class InsertBucket : BucketAction, ITransactableAction {
      private const string PARAM_BUCKET = "bucket";
      private const string PARAM_SERVER = "server";
      private const string PARAM_NEXT_SERVER = "next-server";
      private const string PARAM_MIGRATE_O = "migration";
      private const string PARAM_INFO1_O = "info1";
      private const string PARAM_INFO2_O = "info2";
      private const string PARAM_INFO3_O = "info3";
      private const string PARAM_INFO4_O = "info4";

      public InsertBucket(Action parent) 
         : base(parent) 
      {
         m_forceTitle = true;
      }

      public override void IngestParameters(StringDictionary args) {
         base.IngestParameters(args);

         _bucket = Parameter.ReadInt(args, PARAM_BUCKET);
         _server = args[PARAM_SERVER];
         _nextServer = args[PARAM_NEXT_SERVER];
         _migration = args.ContainsKey(PARAM_MIGRATE_O) ? Parameter.ReadDate(args, PARAM_MIGRATE_O) : SqlDateTime.MinValue.Value;
         _info1 = args.ContainsKey(PARAM_INFO1_O) ? args[PARAM_INFO1_O] : "";
         _info2 = args.ContainsKey(PARAM_INFO2_O) ? args[PARAM_INFO2_O] : "";
         _info3 = args.ContainsKey(PARAM_INFO3_O) ? args[PARAM_INFO3_O] : "";
         _info4 = args.ContainsKey(PARAM_INFO4_O) ? args[PARAM_INFO4_O] : "";

         if (_info1.Length > 256)
            throw new ArgumentException("value cannot contain more than 256 characters", PARAM_INFO1_O);
         if (_info2.Length > 256)
            throw new ArgumentException("value cannot contain more than 256 characters", PARAM_INFO2_O);
         if (_info3.Length > 256)
            throw new ArgumentException("value cannot contain more than 256 characters", PARAM_INFO3_O);
         if (_info4.Length > 256)
            throw new ArgumentException("value cannot contain more than 256 characters", PARAM_INFO4_O);

         using (SqlConnection connection = GetConnection()) {
            SafetyConstraints.AssertDevelopmentEnvironment(
               connection,
               Environment);
         }

         _initialized = true;
      }

      public override void Execute() {
         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         using (SqlConnection connection = GetConnection()) {
            using (SqlTransaction transaction = connection.BeginTransaction(Guid.NewGuid().ToString("N"))) {
               try {
                  Execute(transaction);
                  transaction.Commit();
               }
               catch {
                  Console.WriteLine("Error encountered, rolling back transaction.");

                  transaction.Rollback();
                  throw;
               }
            }
         }
      }

      public void Execute(SqlTransaction transaction) {
         SqlConnection connection;

         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         connection = transaction.Connection;

         Console.WriteLine("Inserting bucket...");
         //TODO: create special handlers for title based interfaces

         InterfaceBucketControl.CreateBucket(
            connection,
            transaction,
            Environment,
            Interface,
            Title.Value,
            _bucket,
            _server,
            _nextServer,
            _migration,
            _info1,
            _info2,
            _info3,
            _info4,
            true     //force over-write
         );
      }

      public override string Name {
         get { return "insert"; }
      }

      public override string Description {
         get {
            return
               "Inserts a new bucket for the specified interface.  " +
               "If the specified interface bucket already exists it will be updated by this operation.";
         }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               base.Parameters,
               new Parameter(PARAM_BUCKET,      "target bucket number."),
               new Parameter(PARAM_SERVER,      "server name for interface target server."),
               new Parameter(PARAM_NEXT_SERVER, "server name for interface target next server."),
               new Parameter(PARAM_MIGRATE_O,   "migration start time.", true, false),
               new Parameter(PARAM_INFO1_O,     "interface specific data slot 1.", true, false),
               new Parameter(PARAM_INFO2_O,     "interface specific data slot 2.", true, false),
               new Parameter(PARAM_INFO3_O,     "interface specific data slot 3.", true, false),
               new Parameter(PARAM_INFO4_O,     "interface specific data slot 4.", true, false)
            );
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               base.Constraints,
               "The specified environment must be a development environment.  This is set in place to prevent disruptions to production environments.",
               "The specified info parameters must be less than 256 characters long."
            );
         }
      }

      private bool _initialized;
      private int _bucket;
      private string _server;
      private string _nextServer;
      private DateTime _migration;
      private string _info1;
      private string _info2;
      private string _info3;
      private string _info4;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\QueryLog.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;

namespace xonline.tools.configuration.buckets {
    public class QueryLog : Action
    {
      private const string PARAM_NPDB_SERVER = GLOBAL_PARAM_NPDB_SERVER;
      private const string PARAM_NPDB_DATABASE = GLOBAL_PARAM_NPDB_DATABASE;
      private const string PARAM_ENV  = "env";
      private const string PARAM_IFACES_O = "ifaces";
      private const string PARAM_TITLES_O = "titles";
      private const string PARAM_SERVERS_O = "servers";
      private const string PARAM_USER_O = "user";
      private const string PARAM_START_O = "start";
      private const string PARAM_END_O = "end";

      public QueryLog(Action parent) : base(parent) { }

      public override void IngestParameters(StringDictionary args) {
         _npdbServer = args[PARAM_NPDB_SERVER];
         _npdbDatabase = args[PARAM_NPDB_DATABASE];
         _environment = args[PARAM_ENV];
         //specifying defaults
         _interfaces = new string[0];
         _titles = new int[0];
         _servers = new string[0];
         _user = null;
         _changeStart = DateTime.UtcNow - TimeSpan.FromDays(5);
         _changeEnd = DateTime.UtcNow;

         if (args.ContainsKey(PARAM_IFACES_O))
            _interfaces = Parameter.ReadCommaSepartedList(args, PARAM_IFACES_O, true);
         if (args.ContainsKey(PARAM_TITLES_O))
            _titles = Parameter.ReadCommaSeparatedTitleIdList(args, PARAM_TITLES_O);
         if (args.ContainsKey(PARAM_SERVERS_O))
            _servers = Parameter.ReadCommaSepartedList(args, PARAM_SERVERS_O, true);
         if (args.ContainsKey(PARAM_USER_O))
            _user = args[PARAM_USER_O];
         if (args.ContainsKey(PARAM_START_O))
            _changeStart = Parameter.ReadDate(args, PARAM_START_O);
         if (args.ContainsKey(PARAM_END_O))
            _changeEnd = Parameter.ReadDate(args, PARAM_END_O);

         if (_changeStart > _changeEnd)
            throw new ArgumentException("end date less than start date", PARAM_END_O);
      }

      public override void Execute() {
         InterfaceBucketLog[] logs;

         using (SqlConnection connection = GetConnection(_npdbServer, _npdbDatabase)) {
            Console.WriteLine("Querying interface bucket logs...");

            logs = InterfaceBucketControl.QueryBucketLogs(
               connection,
               null,
               _environment,
               _interfaces,
               _titles,
               _servers,
               _user,
               _changeStart,
               _changeEnd);

            if (logs.Length > 0) {
               Console.WriteLine();
               Console.WriteLine("Results:");

               foreach (InterfaceBucketLog log in logs) {
                  string line = log.ToString();

                  line = AdjustConsoleText(3, "   ", line, false);

                  Console.WriteLine(line);
               }

               Console.WriteLine();
               Console.WriteLine("{0} results returned", logs.Length);
            }
            else {
               Console.WriteLine();
               Console.WriteLine("No entries located for the specified search criteria.");
            }
         }
      }

      public override string Name {
         get { return "log"; }
      }

      public override string Description {
         get {
            return
               "Examines configuration logs for interface bucket changes.  " +
               "Configuration logs, populated via triggers, are located in the t_config_logs table.  " +
               "Of these log entries only the ones matching the search criteria specified will be returned.";
         }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               new Parameter(PARAM_NPDB_SERVER, "host name of the server with the npdb database."),
               new Parameter(PARAM_NPDB_DATABASE, "name of the ndpb database."),
               new Parameter(PARAM_ENV, "target environment name."),
               new Parameter(PARAM_IFACES_O, "comma separated list of interfaces to search for, if unspecified interface name wont be used to filter the search.", true, false),
               new Parameter(PARAM_TITLES_O, "comma separated list of title ids to search for in integer or 0x prefixed hex format, if unspecified title id wont be used to filter the search.", true, false),
               new Parameter(PARAM_SERVERS_O, "comma separated list of server names to search for (current or next), if unspecified server name wont be used to filter the search.", true, false),
               new Parameter(PARAM_USER_O, "user responsible for the change, if unspecified user name wont be used to filter the search.", true, false),
               new Parameter(PARAM_START_O, "lower bound on the date (utc) of the change, if unspecified 5 days ago will be used.", true, false),
               new Parameter(PARAM_END_O, "upper bound on the date (utc) of the change, if unspecified now will be used.", true, false)
            );
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               "The application user must have login and write access for the npdb database for the specified npdb server.",
               "The end date parameter must be larger than the start date parameter."
            );
         }
      }

      private string _npdbServer;
      private string _npdbDatabase;
      private string _environment;
      private string[] _interfaces;
      private int[] _titles;
      private string[] _servers;
      private string _user;
      private DateTime _changeStart;
      private DateTime _changeEnd;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\Servers\InstallServers.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;

namespace xonline.tools.configuration.buckets {
   public class InstallServers : ServerAction, ITransactableAction {
      private const string PARAM_SERVERS = "servers";
      private const string PARAM_BUCKETS = "buckets";

      public InstallServers(Action parent) : base(parent) {

      }

      public override void IngestParameters(StringDictionary args) {
         base.IngestParameters(args);
         
         using (SqlConnection connection = GetConnection()) {
            SafetyConstraints.AssertDevelopmentEnvironment(
               connection,
               Environment);
         }

         
         _initialized = true;
      }

      public override string Name {
         get { return "install"; }
      }

      public override string Description {
         get {
            return
               "Installs new servers to a title interface.  " +
               "The specified servers will be unioned with the set of servers configured for the title interface.  " +
               "This resulting server set is bucketed in a striping pattern, after clearing the existing bucket configuration.";
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               base.Constraints,
               "The specified servers must be registed for the environment.",
               "The specified environment must be a development environment.  This is set in place to prevent disruptions to production environments.",
               "The bucket count must be larger than the number of servers in the resulting server set."
            );
         }
      }

      public override void Execute() {
         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         using (SqlConnection connection = GetConnection()) {
            using (SqlTransaction transaction = connection.BeginTransaction(Guid.NewGuid().ToString("N"))) {
               try {
                  Execute(transaction);
                  transaction.Commit();
               }
               catch {
                  Console.WriteLine("Error encountered, rolling back transaction.");

                  transaction.Rollback();
                  throw;
               }
            }
         }
      }

      public void Execute(SqlTransaction transaction) {
         SqlConnection connection;
         string[] servers;
         int title;

         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");  

         connection = transaction.Connection;

         title = Title ?? 0;

         Console.WriteLine("Unioning server set with existing servers for this interface...");
         Console.WriteLine();

         servers = InterfaceBucketControl.UnionServerList(connection, transaction, Environment, Interface, title, Servers);

         Console.WriteLine("Resulting server set {");
         Console.WriteLine("   {0}", string.Join("\n   ", servers));
         Console.WriteLine("}");
         Console.WriteLine();

         if (servers.Length > Buckets) {
            throw new InvalidOperationException(
               string.Format(
                  "operation aborted.  the number of servers {0}, is larger than the number of interface buckets specified {1}.",
                  servers.Length,
                  Buckets));
         }

         Console.WriteLine("Removing old configuration...");
         Console.WriteLine();
         InterfaceBucketControl.ClearBuckets(connection, transaction, Environment, Interface, title);

         Console.WriteLine("Writing new configuration...");
         InterfaceBucketControl.ApplyStriping(connection, transaction, Environment, Interface, title, servers, Buckets);
      }

      private bool     _initialized;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\QueryInterfaces.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;

namespace xonline.tools.configuration.buckets {
   // Make sure to update QueryInterfaces.ExtraHelp to reflect changes here
   public enum InterfaceDisplays {
      buckets,
      servers,
      interfaces,
      titles,
      all
   }

   public class QueryInterfaces : Action
   {
      private const string PARAM_NPDB_SERVER = GLOBAL_PARAM_NPDB_SERVER;
      private const string PARAM_NPDB_DATABASE = GLOBAL_PARAM_NPDB_DATABASE;
      private const string PARAM_ENV = "env";
      private const string PARAM_DISPLAY = "display";
      private const string PARAM_IFACE_O = "iface";
      private const string PARAM_TITLE_O = "title";
      private const string PARAM_SERVER_O = "server";
      private const string PARAM_START_O = "bucket-start";
      private const string PARAM_END_O = "bucket-end";

      public QueryInterfaces(Action parent) : base(parent) { }

      public override void IngestParameters(StringDictionary args) {
         _npdbServer = Parameter.ReadString(args, PARAM_NPDB_SERVER);
         _npdbDatabase = Parameter.ReadString(args, PARAM_NPDB_DATABASE);
         _environment = Parameter.ReadString(args, PARAM_ENV);
         _display = Parameter.ReadEnum<InterfaceDisplays>(args, PARAM_DISPLAY);

         if (args.ContainsKey(PARAM_IFACE_O))
            _interface = Parameter.ReadString(args, PARAM_IFACE_O);
         if (args.ContainsKey(PARAM_TITLE_O))
            _title = Parameter.ReadTitleId(args, PARAM_TITLE_O);
         if (args.ContainsKey(PARAM_SERVER_O))
            _server = Parameter.ReadString(args, PARAM_SERVER_O);
         if (args.ContainsKey(PARAM_START_O))
            _start = Parameter.ReadPositiveInt(args, PARAM_START_O);
         if (args.ContainsKey(PARAM_END_O))
            _end = Parameter.ReadPositiveInt(args, PARAM_END_O);
      }

      public override void Execute() {
         Console.WriteLine("Establishing a connection to the NPDB SQL Server.");

         using (SqlConnection connection = Action.GetConnection(_npdbServer, _npdbDatabase)) {
            Console.WriteLine();
            Console.WriteLine("Searching for items matching the specified criteria.");
            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, _environment, _interface, _title, _start, _end, _server)) {
               List<InterfaceBucket> buckets;

               buckets = new List<InterfaceBucket>();
               while (reader.Read())
                  buckets.Add(new InterfaceBucket(reader));

               if (buckets.Count == 0) {
                  Console.WriteLine();
                  Console.WriteLine("No results found.");
               }
               else {
                  switch (_display) {
                     case InterfaceDisplays.buckets:
                        DisplayBuckets(buckets);
                        break;
                     case InterfaceDisplays.servers:
                        DisplayServers(buckets);
                        break;
                     case InterfaceDisplays.interfaces:
                        DisplayInterfaces(buckets);
                        break;
                     case InterfaceDisplays.titles:
                        DisplayInterfaces(buckets);
                        break;
                     default:
                        DisplayAll(buckets);
                        break;
                  }
               }
            }
         }
      }

      public void DisplayBuckets(List<InterfaceBucket> buckets) {
         Console.WriteLine();
         Console.WriteLine("{0} interface bucket results.", buckets.Count);

         foreach (InterfaceBucket bucket in buckets)
            Console.WriteLine(bucket.ToString());
      }

      public void DisplayServers(List<InterfaceBucket> buckets) {
         string[] items;

         items = ExtractUniqueStringList(
            buckets,
            delegate(InterfaceBucket b) { return new string[] { b.m_server, b.m_nextServer }; }
         );

         Console.WriteLine();
         Console.WriteLine("{0} servers results.", items.Length);

         foreach (string item in items)
            Console.WriteLine("   server: {0}", item);
      }

      public void DisplayInterfaces(List<InterfaceBucket> buckets) {
         string[] items;

         items = ExtractUniqueStringList(
            buckets,
            delegate(InterfaceBucket b) { return new string[] { b.m_interface }; }
         );

         Console.WriteLine();
         Console.WriteLine("{0} interface results.", items.Length);

         foreach (string item in items)
            Console.WriteLine("   interface: {0}", item);

      }

      public void DisplayTitles(List<InterfaceBucket> buckets) {
         string[] items;

         items = ExtractUniqueStringList(
            buckets,
            delegate(InterfaceBucket b) { return new string[] { b.m_titleid.ToString() }; }
         );

         Console.WriteLine();
         Console.WriteLine("{0} title identifier results.", items.Length);

         foreach (string item in items)
            Console.WriteLine("   title: {0}", item);
      }

      public void DisplayAll(List<InterfaceBucket> buckets) {
         DisplayBuckets(buckets);
         DisplayServers(buckets);
         DisplayInterfaces(buckets);
         DisplayTitles(buckets);
      }

      private string[] ExtractUniqueStringList(List<InterfaceBucket> buckets, Converter<InterfaceBucket, string[]> extractor) {
         List<string> results;

         results = new List<string>();
         foreach (InterfaceBucket bucket in buckets) {
            foreach (string item in extractor(bucket)) {
               if (!results.Contains(item))
                  results.Add(item);
            }
         }

         return results.ToArray();
      }

      public override string Name {
         get { return "query"; }
      }

      public override string Description {
         get {
            return
               "Searches interface buckets matching the specified criteria.";
         }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               new Parameter(PARAM_NPDB_SERVER, "host name of the server with the npdb database."),
               new Parameter(PARAM_NPDB_DATABASE, "name of the npdb database."),
               new Parameter(PARAM_ENV, "target environment name."),
               new Parameter(PARAM_DISPLAY, "result details to display.  " + Parameter.GetParameterOptionText(typeof(InterfaceDisplays))),
               new Parameter(PARAM_IFACE_O, "target interface name to search for, if unspecified interface name wont be used to filter the search.", true, false),
               new Parameter(PARAM_TITLE_O, "target title identifier search for in integer or 0x prefixed hex format, if unspecified title id wont be used to filter the search.", true, false),
               new Parameter(PARAM_SERVER_O, "target server name to search for (current or next), if unspecified server name wont be used to filter the search.", true, false),
               new Parameter(PARAM_START_O, "lower bound on bucket identifier, if unspecified bucket identifier wont be filtered by lower bound.", true, false),
               new Parameter(PARAM_END_O, "upper bound on bucket identifier, if unspecified bucket identifier wont be filtered by upper bound.", true, false)
            );
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               "The application user must have login and write access for the npdb database for the specified npdb server.",
               "The bucket lower and upper bound identifiers need to be non-negative integers."
            );
         }
      }

      public override string ExtraHelp {
         get {
            return 
               "Display Types:\n" +
               "buckets      displays the full interface bucket details for each search result.\n" +
               "servers      displays a list of the server names present in the search results.\n" +
               "interfaces   displays a list of the interface names present in the search results.\n" +
               "titles       displays a list of the title identfiers present in the search results.\n" +
               "all          displays each of the available views for the search results.";
         }
      }

      private string _npdbServer;
      private string _npdbDatabase;
      private string _environment;
      private string _interface;
      private string _server;
      private int? _title;
      private int? _start;
      private int? _end;
      private InterfaceDisplays _display;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\Servers\RemoveServers.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;

namespace xonline.tools.configuration.buckets {
   public class RemoveServers : ServerAction, ITransactableAction {
      public RemoveServers(Action parent) : base(parent) { }

      public override void IngestParameters(StringDictionary args) {
         base.IngestParameters(args);

         try {
            using (SqlConnection connection = GetConnection()) {
               SafetyConstraints.AssertDevelopmentEnvironment(
                  connection,
                  Environment);
            }
         }
         catch (MissingDatabaseException) {
            // nothing doing
         }

         _initialized = true;
      }

      public override string Name {
         get { return "remove"; }
      }

      public override string Description {
         get {
            return
               "Removes existing servers from a title interface.  " +
               "The specified servers will be subtracted from the set of servers configured for the title interface.  " +
               "This resulting server set is bucketed in a striping pattern, after clearing the existing bucket configuration.";
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               base.Constraints,
               "The bucket count must be larger than the number of servers in the resulting server set.",
               "The specified environment must be a development environment.  This is set in place to prevent disruptions to production environments."
            );
         }
      }

      public override void Execute() {
         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         try {
            using (SqlConnection connection = GetConnection()) {
               using (SqlTransaction transaction = connection.BeginTransaction(Guid.NewGuid().ToString("N"))) {
                  try {
                     Execute(transaction);
                     transaction.Commit();
                  }
                  catch {
                     Console.WriteLine("Error encountered, rolling back transaction.");
                     transaction.Rollback();
                     throw;
                  }
               }
            }
         }
         catch (MissingDatabaseException inner) {
            Console.WriteLine("Database not present, skipping operation: {0}", inner.Message);
         }
      }

      public void Execute(SqlTransaction transaction) {
         SqlConnection connection;
         string[] servers;
         int title;

         if (!_initialized)
            throw new InvalidOperationException("no parameters specified");

         title = Title ?? 0;

         Console.WriteLine("Subtracting server set from existing servers for this interface...");
         Console.WriteLine();

         connection = transaction.Connection;
         servers = InterfaceBucketControl.SubtractServerList(connection, transaction, Environment, Interface, title, Servers);

         if (servers.Length == 0) {
            Console.WriteLine("Resulting server set is empty.");
            Console.WriteLine();
         }
         else {
            Console.WriteLine("Resulting server set {");
            Console.WriteLine("   {0}", string.Join("\n   ", servers));
            Console.WriteLine("}");
            Console.WriteLine();
         }

         if (servers.Length > Buckets) {
            throw new InvalidOperationException(
               string.Format(
                  "operation aborted. the number of servers {0}, is larger than the number of interface buckets specified {1}.",
                  servers.Length,
                  Buckets));
         }

         Console.WriteLine("Removing old configuration...");
         Console.WriteLine();
         InterfaceBucketControl.ClearBuckets(connection, transaction, Environment, Interface, title);

         if (servers.Length == 0)
            Console.WriteLine("No configuration to write, server list is empty.");
         else {
            Console.WriteLine("Writing new configuration...");
            InterfaceBucketControl.ApplyStriping(connection, transaction, Environment, Interface, title, servers, Buckets);
         }
      }

      private bool     _initialized;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\Servers\ServerAction.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

namespace xonline.tools.configuration.buckets {
   public class ServerAction : BucketAction {
      private const string PARAM_SERVERS = "servers";
      private const string PARAM_BUCKETS = "buckets";

      public ServerAction(Action parent) : base(parent) {
         if (GetType() == typeof(ServerAction)) {
            m_children.Add(new InstallServers(this));
            m_children.Add(new RemoveServers(this));
         }
      }

      public override void IngestParameters(StringDictionary args) {
         base.IngestParameters(args);

         _servers = Parameter.ReadCommaSepartedList(args, PARAM_SERVERS, true);
         _buckets = Parameter.ReadPositiveInt(args, PARAM_BUCKETS);
      }

      public override void Execute() {
         throw new NotSupportedException();
      }

      public override string Name {
         get { return "servers"; }
      }

      public override string Description {
         get { return "Server oriented operations for interface buckets."; }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               base.Parameters,
               new Parameter(PARAM_SERVERS, "comma separated list of servers to install."),
               new Parameter(PARAM_BUCKETS, "number of buckets to associate with the interface.")
            );
         }
      }

      protected string[] Servers {
         get { return _servers; }
      }

      protected int Buckets {
         get { return _buckets; }
      }

      private string[] _servers;
      private int _buckets;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\Xml\XmlAction.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;
using System.Xml;

namespace xonline.tools.configuration.buckets {
    public class XmlAction : Action
    {
      static XmlAction() {
         m_mapping = new Dictionary<string, Type>();

         m_mapping.Add("serverInstall", typeof(InstallServers));
         m_mapping.Add("serverRemove", typeof(RemoveServers));
         m_mapping.Add("bucketClear", typeof(ClearInterface));
         m_mapping.Add("bucketDelete", typeof(DeleteBucket));
         m_mapping.Add("bucketInsert", typeof(InsertBucket));
      }

      public XmlAction(Action parent) : base(parent) {
         if (typeof(XmlAction) == GetType()) {
            m_children.Add(new XmlImport(this));
            m_children.Add(new XmlExport(this));
         }
      }

      public override void IngestParameters(System.Collections.Specialized.StringDictionary args) {
         throw new NotImplementedException();
      }

      public override void Execute() {
         throw new NotImplementedException();
      }

      protected void ValidateParameters(StringDictionary parameters, Action action) {
         Dictionary<string, bool> all;
         Dictionary<string, string> required;

         all = new Dictionary<string, bool>();
         required = new Dictionary<string, string>();

         // move the parameters to lookup tables
         foreach (Parameter parameter in action.Parameters) {
            if (!parameter.m_optional)
               required[parameter.m_name.ToLower()] = parameter.m_name;

            all[parameter.m_name.ToLower()] = false;
         }

         // make sure all the parameters are valid (recognized and unique)
         foreach (string key in parameters.Keys) {
            string normalizedKey = key.ToLower();

            if (!all.ContainsKey(normalizedKey))
               throw new ArgumentException("unrecognized parameter", key);
            if (all[normalizedKey] == true)
               throw new ArgumentException("duplicate parameter", key);

            all[normalizedKey] = true;
            required.Remove(normalizedKey);
         }

         // make sure all required parameters are spoken for
         foreach (string key in required.Keys)
            throw new ArgumentException("parameter missing", required[key]);
      }

      protected StringDictionary ReadParameters(XmlElement element) {
         StringDictionary parameters;

         parameters = new StringDictionary();
         foreach (XmlAttribute attribute in element.Attributes)
            parameters.Add(attribute.Name, attribute.Value);

         return parameters;
      }

      protected Action CreateAction(XmlElement element) {
         object[] args;

         if (!m_mapping.ContainsKey(element.Name))
            throw new ArgumentException("unexpected action specified", element.Name ?? "");

         args = new object[] { null }; // no parent

         return (Action)Activator.CreateInstance(m_mapping[element.Name], args);
      }

      public override string Name {
         get { return "xml"; }
      }

      public override string Description {
         get { return "Interface bucket xml batch configuration operations."; }
      }

      public override Parameter[] Parameters {
         get { throw new NotImplementedException(); }
      }

      protected static Dictionary<string, Type> m_mapping;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\Xml\XmlImport.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;

namespace xonline.tools.configuration.buckets {
   // Note: RestoreLivecacheBucketing's coupled with the parameter spec of this action.  Keep in sync.
   public class XmlImport : XmlAction {
      private const string PARAM_FILENAME = "file";

      public XmlImport(Action parent) : base(parent) { }

      public override void IngestParameters(System.Collections.Specialized.StringDictionary args) {
         XmlDocument document;

         document = new XmlDocument();
         try { document.Load(Parameter.ReadString(args, PARAM_FILENAME)); }
         catch (FileNotFoundException) {
            throw new ArgumentException("path does not exist", PARAM_FILENAME);
         }

         _document = document;
      }

      private bool ExtractConnectionInfo(out string server, out string database) {
         bool hasResults = false;

         server = null;
         database = null;

         foreach (XmlElement element in _document.SelectNodes("/config/child::node()")) {
            XmlAttribute currentServer;
            XmlAttribute currentDatabase;

            currentServer = element.Attributes[GLOBAL_PARAM_NPDB_SERVER];
            currentDatabase = element.Attributes[GLOBAL_PARAM_NPDB_DATABASE];

            // Make sure the attributes are present
            if (null == currentServer || string.IsNullOrEmpty(currentServer.Value))
               throw new Exception("input xml document contains an element missing the " + GLOBAL_PARAM_NPDB_SERVER + " attribute.");
            if (null == currentDatabase || string.IsNullOrEmpty(currentDatabase.Value))
               throw new Exception("input xml document contains an element missing the " + GLOBAL_PARAM_NPDB_DATABASE + " attribute.");

            // Set if null, compare if not
            if (string.IsNullOrEmpty(server))
               server = currentServer.Value;
            else if (0 != StringComparer.CurrentCultureIgnoreCase.Compare(server, currentServer.Value))
               throw new Exception("input xml document contains elements whose server names differ, server names need to be the same for all elements.");

            // Set if null, compare if not
            if (string.IsNullOrEmpty(database))
               database = currentDatabase.Value;
            else if (0 != StringComparer.CurrentCultureIgnoreCase.Compare(database, currentDatabase.Value))
               throw new Exception("input xml document contains elements whose database name differ, database names need to be the same for all elements.");

            hasResults = true;
         }

         return hasResults;
      }

      public override void Execute() {
         string server;
         string database;

         if (null == _document)
            throw new InvalidOperationException("no parameters specified");

         if (ExtractConnectionInfo(out server, out database)) {
            using (SqlConnection connection = GetConnection(server, database)) {
               using (SqlTransaction transaction = connection.BeginTransaction(Guid.NewGuid().ToString("N"))) {
                  try {
                     foreach (XmlElement element in _document.SelectNodes("/config/child::node()")) {
                        StringDictionary parameters;
                        string breaker;
                        Action action;
                        ITransactableAction transactionAction;

                        action = CreateAction(element);
                        transactionAction = action as ITransactableAction;

                        // Read Parameter
                        parameters = ReadParameters(element);

                        breaker = "-- PROCESSING " + element.Name + " ";
                        breaker = breaker.PadRight(WindowWidth, '-');

                        Console.Write(breaker);
                        Console.WriteLine();

                        // Validate -> Set Parameters
                        ExecuteParameterConsumption(parameters, action);

                        if (null != transactionAction) {
                           Console.WriteLine("EXECUTING [TRANSACTIONAL]");
                           Console.WriteLine();

                           transactionAction.Execute(transaction);
                        }
                        else {
                           Console.WriteLine("EXECUTING [NON-TRANSACTIONAL]");
                           Console.WriteLine();

                           action.Execute();
                        }
                     }

                     transaction.Commit();
                  }
                  catch {
                     Console.WriteLine("ENCOUNTERED ERROR: Rolling back import operations.");
                     transaction.Rollback();

                     throw;
                  }
               }
            }
         }
         else
            Console.WriteLine("Input XML Document Empty.");
      }

      private void ExecuteParameterConsumption(StringDictionary parameters, Action action) {
         try { ValidateParameters(parameters, action); }
         catch (ArgumentException inner) {
            Console.WriteLine("ERROR: " + inner.Message);
            throw new ActionFailedException("invalid arguments", inner);
         }

         action.IngestParameters(parameters);

         Console.WriteLine("INPUT PARAMETERS");
         Console.WriteLine();

         foreach (string key in parameters.Keys)
            Console.WriteLine("   {0} = {1}", key, parameters[key] ?? "(null)");

         Console.WriteLine();
      }

      public override string Name {
         get { return "import"; }
      }

      public override string Description {
         get {
            return
               "Performs a series of interface bucket operations specified in the specified xml file.";
         }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               new Parameter(PARAM_FILENAME, "input xml file path.")
            );
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               "The specified xml file must match the schema."
            );
         }
      }

      private XmlDocument _document;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Bucket\Xml\XmlExport.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;

namespace xonline.tools.configuration.buckets {
   // Note: RemoveLivecacheServer's coupled with the parameter spec of this action.  Keep in sync.
   public class XmlExport : XmlAction {
      private const string PARAM_NPDB_SERVER = GLOBAL_PARAM_NPDB_SERVER;
      private const string PARAM_NPDB_DATABASE = GLOBAL_PARAM_NPDB_DATABASE;
      private const string PARAM_ENV = "env";
      private const string PARAM_IFACE = "iface";
      private const string PARAM_TITLE_O = "title";
      private const string PARAM_FILENAME = "file";
      private const string PARAM_OPTIONS_O = "options";

      public XmlExport(Action parent) : base(parent) { }

      public override void IngestParameters(System.Collections.Specialized.StringDictionary args) {
         XmlDocument document;

         _output = Parameter.ReadString(args, PARAM_FILENAME);
         _npdbServer = Parameter.ReadString(args, PARAM_NPDB_SERVER);
         _npdbDatabase = Parameter.ReadString(args, PARAM_NPDB_DATABASE);
         _environment = Parameter.ReadString(args, PARAM_ENV);
         _interface = Parameter.ReadString(args, PARAM_IFACE);
         _options = "";

         if (args.ContainsKey(PARAM_TITLE_O))
            _title = Parameter.ReadTitleId(args, PARAM_TITLE_O);
         if (args.ContainsKey(PARAM_OPTIONS_O))
            _options = Parameter.ReadString(args, PARAM_OPTIONS_O).ToLower().Trim();

         try {
            document = new XmlDocument();

            switch (_options) {
               case "overwrite": // nothing to do here
                  break;
               case "append": // load fail ok
                  document.Load(_output); 
                  break;
               case "": // load should fail with FileNotFoundException
                  document.Load(_output);
                  throw new ArgumentException("xml file already exists, the append or overwrite option must be specified.", PARAM_OPTIONS_O);
               default:
                  throw new ArgumentException("unrecognized option", PARAM_OPTIONS_O);
            }
         }
         catch (FileNotFoundException) {
            document = new XmlDocument();
         }

         _document = document;
      }

      public override void Execute() {
         XmlElement config;
         string directory;

         if (null == _document)
            throw new InvalidOperationException("no parameters specified");

         config = GetOrCreateConfigElement();

         Console.WriteLine("Connecting to NPDB SQL Server.");
         
         using (SqlConnection connection = Action.GetConnection(_npdbServer, _npdbDatabase)) {
            int count = 0;

            config.AppendChild(CreateClearElement());

            Console.WriteLine();
            Console.WriteLine("Creating insert statements.");
            
            foreach (XmlElement element in CreateInsertElements(connection)) {
               config.AppendChild(element);
               count++;
            }

            Console.WriteLine();
            Console.WriteLine("{0} results inserted.", count);
         }

         Console.WriteLine();
         Console.WriteLine("Saving xml document.");

         directory = Path.GetDirectoryName(_output);

         if (!string.IsNullOrEmpty(directory))
            Directory.CreateDirectory(directory);

         _document.Save(_output);
      }

      private XmlElement GetOrCreateConfigElement() {
         XmlElement config;

         config = _document.DocumentElement;

         if (null == config)
            config = (XmlElement)_document.AppendChild(_document.CreateElement("config"));

         if (config.Name != "config")
            throw new ArgumentException("unexpected root found 'config' expected.", config.Name);

         return config;
      }

      private XmlElement CreateClearElement() {
         XmlElement element;

         element = _document.CreateElement("bucketClear");
         element.Attributes.Append(_document.CreateAttribute(PARAM_NPDB_SERVER)).Value = _npdbServer;
         element.Attributes.Append(_document.CreateAttribute(PARAM_NPDB_DATABASE)).Value = _npdbDatabase;
         element.Attributes.Append(_document.CreateAttribute(PARAM_ENV)).Value = _environment;
         element.Attributes.Append(_document.CreateAttribute(PARAM_IFACE)).Value = _interface;

         if (_title.HasValue)
            element.Attributes.Append(_document.CreateAttribute(PARAM_TITLE_O)).Value = _title.ToString();

         return element;
      }

      private XmlElement[] CreateInsertElements(SqlConnection conn) {
         List<XmlElement> elements;

         elements = new List<XmlElement>();

         using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(conn, null, _environment, _interface, _title, null,null,null)) {
            while (reader.Read()) {
               XmlElement element;
               InterfaceBucket bucket;

               bucket = new InterfaceBucket(reader);
               element = _document.CreateElement("bucketInsert");
               element.Attributes.Append(_document.CreateAttribute(PARAM_NPDB_SERVER)).Value = _npdbServer;
               element.Attributes.Append(_document.CreateAttribute(PARAM_NPDB_DATABASE)).Value = _npdbDatabase;
               element.Attributes.Append(_document.CreateAttribute(PARAM_ENV)).Value = bucket.m_environment;
               element.Attributes.Append(_document.CreateAttribute(PARAM_IFACE)).Value = bucket.m_interface;
               element.Attributes.Append(_document.CreateAttribute(PARAM_TITLE_O)).Value = bucket.m_titleid.ToString();
               element.Attributes.Append(_document.CreateAttribute("bucket")).Value = bucket.m_bucket.ToString(); ;
               element.Attributes.Append(_document.CreateAttribute("server")).Value = bucket.m_server;
               element.Attributes.Append(_document.CreateAttribute("next-server")).Value = bucket.m_nextServer;
               element.Attributes.Append(_document.CreateAttribute("migration")).Value = bucket.m_migrationStart.ToString();
               element.Attributes.Append(_document.CreateAttribute("info1")).Value = bucket.m_info1;
               element.Attributes.Append(_document.CreateAttribute("info2")).Value = bucket.m_info2;
               element.Attributes.Append(_document.CreateAttribute("info3")).Value = bucket.m_info3;
               element.Attributes.Append(_document.CreateAttribute("info4")).Value = bucket.m_info4;

               elements.Add(element);
            }
         }

         return elements.ToArray();
      }

      public override string Name {
         get { return "export"; }
      }

      public override string Description {
         get {
            return
               "Exports a batch of interface bucket operations to an xml file.  " +
               "These operations, if imported, would result in restoring the given state of the interface bucket.  " +
               "The exported instructions are appended to the file if it exists and is non-empty.";
         }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               new Parameter(PARAM_NPDB_SERVER, "host name of the server with the npdb database."),
               new Parameter(PARAM_NPDB_DATABASE, "name of the npdb database."),
               new Parameter(PARAM_ENV, "target environment name."),
               new Parameter(PARAM_IFACE,    "target interface name."),
               new Parameter(PARAM_FILENAME, "input xml file path."),
               new Parameter(PARAM_TITLE_O, "target title identifier in integer or 0x prefixed hex format.", true, false),
               new Parameter(PARAM_OPTIONS_O, "xml file control option (overwrite or append).  " +
                  "overwrite destroys the contents of the original file (if it exists).  " +
                  "append will add rows to the end (potentially duplicating existing rows).  " +
                  "if omitted the the operation will fail if the file already exists; otherwise a new export will be created.", true, false)
            );
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               "The application user must have login and write access for the npdb database for the specified npdb server.",
               "The specified xml file must match the schema and be writable."
            );
         }
      }

      private string _npdbServer;
      private string _npdbDatabase;
      private string _environment;
      private string _interface;
      private int? _title;
      private XmlDocument _document;
      private string _output;
      private string _options;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Setting\AddSettingOverride.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;

namespace xonline.tools.configuration.setting_override
{
    public class AddSettingOverride : SettingOverrideAction
    {
        private const string PARAM_VALUE = "value";

        public AddSettingOverride(Action parent)
            : base(parent)
        {
        }

        public override void IngestParameters(StringDictionary args)
        {
            base.IngestParameters(args);

            _value = args[PARAM_VALUE];

            using (SqlConnection connection = GetConnection())
            {
                SafetyConstraints.AssertDevelopmentEnvironment(
                   connection,
                   Environment);
            }

            _initialized = true;
        }

        public override void Execute()
        {
            if (!_initialized)
                throw new InvalidOperationException("no parameters specified");

            using (SqlConnection connection = GetConnection())
            {
                Console.WriteLine("Adding setting override...");

                SettingOverrideControl.AddSettingOverride(
                    connection,
                    Environment,
                    SiteID,
                    Server,
                    Component,
                    Setting,
                    _value,
                   true     //force over-write
                );
            }
        }

        public override string Name
        {
            get { return "add"; }
        }

        public override string Description
        {
            get
            {
                return
                   "Adds a new setting override.  " +
                   "If the specified setting override already exists it will be updated by this operation.";
            }
        }

        public override Parameter[] Parameters
        {
            get
            {
                return Parameter.JoinParameters(
                   base.Parameters,
                   new Parameter(PARAM_VALUE, "target setting override value.")
                );
            }
        }

        public override string[] Constraints
        {
            get
            {
                return Parameter.JoinConstraints(
                   base.Constraints,
                   "The specified environment must be a development environment.  This is set in place to prevent disruptions to production environments."
                );
            }
        }

        private bool _initialized;
        private string _value;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Server\LiveCache\RestoreLivecacheBucketing.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;

using xonline.tools.configuration.buckets;

namespace xonline.tools.configuration.servers {
   // Note: Coupling between this actions parameters and XmlImport's parameters.  Keep in sync.
   public class RestoreLivecacheBucketing : Action {
      private const string PARAM_FILENAME = "file";

      public RestoreLivecacheBucketing(Action parent) : base(parent) { }

      public override void IngestParameters(StringDictionary args) {
         filePath = Parameter.ReadString(args, PARAM_FILENAME);

         initialized = true;
      }

      public override void Execute() {
         XmlImport importer = new XmlImport(null);
         StringDictionary parameters = new StringDictionary();

         if (!initialized)
            throw new InvalidOperationException("no parameters specified");

         // build the parameter list XmlImport expects
         parameters.Add(PARAM_FILENAME, filePath);

         // allow production writes for this operation
         SafetyConstraints.AllowProductionEnvironmentWrites = true;

         // import the xml file
         importer.IngestParameters(parameters);
         importer.Execute();
      }

      public override string Name {
         get { return "restore-buckets"; }
      }

      public override string Description {
         get { return "Restores the original interface bucketing configuration for livecache."; }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               new Parameter(PARAM_FILENAME, "path to backup xml file.")
            );
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               "The specified xml file must match the schema."
            );
         }
      }

      private bool initialized;
      private string filePath;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Setting\DeleteSettingOverride.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;

namespace xonline.tools.configuration.setting_override
{
    public class DeleteSettingOverride : SettingOverrideAction
    {
        public DeleteSettingOverride(Action parent)
            : base(parent)
        {
        }

        public override void IngestParameters(StringDictionary args)
        {
            base.IngestParameters(args);

            using (SqlConnection connection = GetConnection())
            {
                SafetyConstraints.AssertDevelopmentEnvironment(
                   connection,
                   Environment);
            }

            _initialized = true;
        }

        public override void Execute()
        {
            if (!_initialized)
                throw new InvalidOperationException("no parameters specified");

            using (SqlConnection connection = GetConnection())
            {
                Console.WriteLine("Deleting setting override...");

                SettingOverrideControl.RemoveSettingOverride(
                    connection,
                    Environment,
                    SiteID,
                    Server,
                    Component,
                    Setting
                );
            }
        }

        public override string Name
        {
            get { return "delete"; }
        }

        public override string Description
        {
            get
            {
                return "Deletes a setting override.";
            }
        }

        public override Parameter[] Parameters
        {
            get
            {
                return base.Parameters;
            }
        }

        public override string[] Constraints
        {
            get
            {
                return Parameter.JoinConstraints(
                   base.Constraints,
                   "The specified environment must be a development environment.  This is set in place to prevent disruptions to production environments."
                );
            }
        }

        private bool _initialized;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\func\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\func\EnvironmentSettingCloning.cs ===
using System;
using System.Data.SqlClient;
using System.Diagnostics;
using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.tools.configuration.setting_override;
using xonline.common.config;

namespace xonline.tools.configuration.test {
   public static class Helper {
      public static SqlDataReader GetUnoverridenSetting(SqlConnection connection) {
         string query;

         query = string.Format(
            "SELECT TOP 1 s.vc_setting, r.vc_server, c.vc_component " +
            "FROM t_settings s " +
            "INNER JOIN t_servers r ON r.vc_environment=N'{0}' " +
            "INNER JOIN t_components c ON 1 = 1 " +
            "WHERE 0 = (SELECT COUNT(*) FROM t_setting_overrides WHERE vc_environment=N'{0}' AND vc_setting=s.vc_setting)",
            FuncTest.Environment);

         return FuncTest.ExecuteQuery(connection, query);
      }
   }

   [Owner("raphamun"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class VerifyNoUnintendedWritesFuncTest : FuncTest {
      static string TestName = "Verify No Unintended Writes";
      static string Description = "Verifies that adding new setting overrides only affects one row of one table across all of npdb.";

      public VerifyNoUnintendedWritesFuncTest() 
         : base(TestName, Description) { }

      protected override void Functional() {
         string setting;
         string server;
         string component;
         string query;
         long current;
         int count;

         using (SqlConnection connection = GetNpdbConnection()) {
            // Locate an un-used setting override
            using (SqlDataReader reader = Helper.GetUnoverridenSetting(connection)) {
               if (!reader.Read())
                  NewException("could not find an unused setting.");

               setting = reader.GetString(0);
               server = reader.GetString(1);
               component = reader.GetString(2);
            }

            // Get the current config log number
            using (SqlDataReader reader = ExecuteQuery(connection, "SELECT TOP 1 bi_change_id FROM t_config_log ORDER BY bi_change_id DESC")) {
               if (reader.Read())
                  current = reader.GetInt64(0);
               else
                  current = 0;
            }

            try {
               // Write the setting using the API
               SettingOverrideControl.AddSettingOverride(
                  connection,
                  Environment,
                  Config.MainSiteId,
                  server,
                  component,
                  setting,
                  "stf",
                  true);

               // Verify via the config log that these were the only changes made
               query = string.Format("SELECT COUNT(*) FROM t_config_log WHERE bi_change_id > {0}", current);

               count = ExecuteScalar<int>(connection, query);

               if (count != 1)
                  NewException("{0} rows were modified, when only 1 should have been updated.", count);
            }
            finally {
               // Remove the setting override
               SettingOverrideControl.RemoveSettingOverride(
                  connection,
                  Environment,
                  Config.MainSiteId,
                  server,
                  component,
                  setting);
            }
         }
      }
   }

   [Owner("raphamun"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class RewriteSettingsFuncTest : FuncTest {
      static string TestName = "Rewrite Support";
      static string Description = "";

      public RewriteSettingsFuncTest()
         : base(TestName, Description) { }

      protected override void Functional() {string setting;
         string server;
         string component;

         using (SqlConnection connection = GetNpdbConnection()) {
            // Locate an un-used setting override
            using (SqlDataReader reader = Helper.GetUnoverridenSetting(connection)) {
               if (!reader.Read())
                  NewException("could not find an unused setting.");

               setting = reader.GetString(0);
               server = reader.GetString(1);
               component = reader.GetString(2);
            }

            try {
               // Write the setting using the API
               SettingOverrideControl.AddSettingOverride(
                  connection,
                  Environment,
                  Config.MainSiteId,
                  server,
                  component,
                  setting,
                  "stf",
                  true);

               // Write the setting with a new value using the API
               SettingOverrideControl.AddSettingOverride(
                  connection,
                  Environment,
                  Config.MainSiteId,
                  server,
                  component,
                  setting,
                  "new stf",
                  true);

               // Verify the new setting value
               using (SqlDataReader reader = SettingOverrideControl.GetSettingOverride(connection, Environment, Config.MainSiteId, server, component, setting)) {
                  string value;

                  if (!reader.Read())
                     NewException("setting was not present.");

                  value = (string)reader["vc_value"];

                  if (value != "new stf")
                     NewException("new value '{0}' does not match the expected value '{1}'.", value, "new stf");
               }
            }
            finally {
               // Remove the setting override
               SettingOverrideControl.RemoveSettingOverride(
                  connection,
                  Environment,
                  Config.MainSiteId,
                  server,
                  component,
                  setting);
            }
         }
      }
   }

   [Owner("raphamun"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class ProductionWriteRejectFuncTest : FuncTest {
      static string TestName = "Production Write Reject";
      static string Description = "Writes to production environments are not permitted, verify that this is observed by the application.";

      public ProductionWriteRejectFuncTest()
         : base(TestName, Description) { }

      protected override void Functional() {
         Process process;
         string output;
         string current;

         if (Environment == "prodnet")
            NewException("This test should not be run in production.");

         using (SqlConnection connection = GetNpdbConnection()) {
            // Store the old current environment name
            current = ExecuteScalar<string>(connection, "SELECT vc_environment FROM t_environments WHERE b_current=1");

            try {
               // Set the current environment to production
               ExecuteNonQuery(connection, "UPDATE t_environments SET b_current = CASE vc_environment WHEN N'prodnet' THEN 1 ELSE 0 END");

               // Execute confnpdb.exe with arguments to add a bogus over
               process = new Process();

               process.StartInfo.FileName = "confnpdb.exe";
               process.StartInfo.Arguments = string.Format("settingoverride add {0} prodnet -1 {0} wcdebugtest fake_setting foo", NpdbServer);
               process.StartInfo.RedirectStandardOutput = true;
               process.StartInfo.UseShellExecute = false;
               process.StartInfo.CreateNoWindow = true;
               process.Start();

               process.WaitForExit();

               // Verify that it fails approapriately (look for "Action Blocked: " in output)
               output = process.StandardOutput.ReadToEnd();

               if (!output.Contains("Action Blocked:"))
                  NewException("the action was not blocked: {0}", output);
            }
            finally {
               string query;

               // Reset productions current flag to its original environment
               query = string.Format("UPDATE t_environments SET b_current = CASE vc_environment WHEN N'{0}' THEN 1 ELSE 0 END", current);

               ExecuteNonQuery(connection, query);
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Setting\SettingOverrideAction.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

namespace xonline.tools.configuration.setting_override
{
    public class SettingOverrideAction : Action
    {
        private const string PARAM_NPDB_SERVER = "npdbServer";
        private const string PARAM_NPDB_DATABASE = "npdbDatabase";
        private const string PARAM_ENV = "env";
        private const string PARAM_SITE_ID = "site_id";
        private const string PARAM_SERVER = "server";
        private const string PARAM_COMPONENT = "component";
        private const string PARAM_SETTING = "setting";

        public SettingOverrideAction(Action parent)
            : base(parent)
        {
            if (this.GetType() == typeof(SettingOverrideAction))
            {
                m_children.Add(new AddSettingOverride(this));
                m_children.Add(new DeleteSettingOverride(this));
            }
        }

        protected SqlConnection GetConnection()
        {
            return GetConnection(m_npdbServer, m_npdbDatabase);
        }

        public override void IngestParameters(StringDictionary args)
        {
            m_npdbServer = Parameter.ReadString(args, PARAM_NPDB_SERVER);
            m_npdbDatabase = Parameter.ReadString(args, PARAM_NPDB_DATABASE);
            m_environment = Parameter.ReadString(args, PARAM_ENV);
            m_site_id = Parameter.ReadInt(args, PARAM_SITE_ID);
            m_server = Parameter.ReadString(args, PARAM_SERVER);
            m_component = Parameter.ReadString(args, PARAM_COMPONENT);
            m_setting = Parameter.ReadString(args, PARAM_SETTING);
        }

        public override void Execute()
        {
            throw new NotSupportedException();
        }

        public override string Name
        {
            get { return "settingoverride"; }
        }

        public override string Description
        {
            get { return "Setting Override configuration and information operations."; }
        }

        public override string[] Constraints
        {
            get
            {
                return Parameter.JoinConstraints(
                   "The application user must have login and write access for the npdb database for the specified npdb server.",
                   "The specified environment must be present in t_environments to satisfy FK constraints."
                );
            }
        }

        public override Parameter[] Parameters
        {
            get
            {
                return Parameter.JoinParameters(
                   new Parameter(PARAM_NPDB_SERVER, "host name of the server with the npdb database."),
                   new Parameter(PARAM_NPDB_DATABASE, "name of the npdb database."),
                   new Parameter(PARAM_ENV, "target environment name."),
                   new Parameter(PARAM_SITE_ID, "target site id or -1."),
                   new Parameter(PARAM_SERVER, "target server name or ALL."),
                   new Parameter(PARAM_COMPONENT, "target component or ALL."),
                   new Parameter(PARAM_SETTING, "target setting.")
                );
            }
        }

        protected string Environment
        {
            get { return m_environment; }
        }

        protected int SiteID
        {
            get { return m_site_id; }
        }

        protected string Server
        {
            get { return m_server; }
        }

        protected string Component
        {
            get { return m_component; }
        }

        protected string Setting
        {
            get { return m_setting; }
        }

        protected string ConnectionString
        {
            get { return GetConnectionString(m_npdbServer, m_npdbDatabase); }
        }

        private string m_npdbServer;
        private string m_npdbDatabase;
        private string m_environment;
        private int m_site_id;
        private string m_server;
        private string m_component;
        private string m_setting;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\console\Actions\Server\LiveCache\RemoveLivecacheServers.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;

using xonline.tools.configuration.buckets;

namespace xonline.tools.configuration.servers {
   using ServerDictionary = System.Collections.Generic.Dictionary<string, string>;

    // Note: Coupling between this actions parameters and XmlExports's parameters.  Keep in sync.
   public class RemoveLivecacheServers : Action, ITransactableAction {
      private const string PARAM_NPDB_SERVER = GLOBAL_PARAM_NPDB_SERVER;
      private const string PARAM_NPDB_DATABASE = GLOBAL_PARAM_NPDB_DATABASE;
      private const string PARAM_ENV = "env";
      private const string PARAM_FILENAME = "file";
      private const string PARAM_SERVERS  = "servers";

      private const string PARAM_EXPORT_IFACE = "iface";

      public RemoveLivecacheServers(Action parent) : base(parent) { }

      public override void IngestParameters(StringDictionary args) {
         npdbServer = Parameter.ReadString(args, PARAM_NPDB_SERVER);
         npdbDatabase = Parameter.ReadString(args, PARAM_NPDB_DATABASE);
         environment = Parameter.ReadString(args, PARAM_ENV);
         filePath = Parameter.ReadString(args, PARAM_FILENAME);
         servers = Parameter.ReadCommaSepartedList(args, PARAM_SERVERS, true);

         initialized = true;
      }

      public override void Execute() {
         if (!initialized)
            throw new InvalidOperationException("no parameters specified");

         using (SqlConnection connection = XmlAction.GetConnection(npdbServer, npdbDatabase)) {
            using (SqlTransaction transaction = connection.BeginTransaction(Guid.NewGuid().ToString("N"))) {
               try {
                  Execute(transaction);
                  transaction.Commit();
               }
               catch {
                  Console.WriteLine("Error encountered, rolling back transaction.");
                  transaction.Rollback();
                  throw;
               }
            }
         }
      }

      public void Execute(SqlTransaction transaction) {
         List<InterfaceBucket> targetedBuckets = new List<InterfaceBucket>();
         ServerDictionary serverLookup;
         string[] serverList;
         string[] replacementList;

         if (!initialized)
            throw new InvalidOperationException("no parameters specified");

         // Step 1-a: Get the list of Servers in the livecache Bank
         serverLookup = GetServerList(transaction, out serverList);

         Console.WriteLine();
         Console.WriteLine("Server Bank Information [- indicates removal target] (");

         foreach (string name in serverList) {
             Predicate<string> predicate = delegate(string x) { return String.Compare(x, name, true) == 0; };

             if (Array.Exists<string>(servers, predicate))
                 Console.WriteLine(" - " + name);
             else
                 Console.WriteLine("   " + name);
         }

         Console.WriteLine(")");
         Console.WriteLine();

         // Step 1-b: Build Targetted Bucket List
         foreach (string name in servers) {
            if (serverLookup.ContainsKey(name)) {
               SqlConnection conn = transaction.Connection;

               using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(conn, transaction, environment, interfaceName, title, null, null, name)) {
                  while (reader.Read()) {
                     targetedBuckets.Add(new InterfaceBucket(reader));
                  }
               }
            }
            else {
               throw new ActionFailedException(string.Format("server [{0}] not present in the {1} bank of servers", name, interfaceName));
            }
         }

         // Step 1-c: Sort Targeted Bucket List
         targetedBuckets.Sort(
            delegate(InterfaceBucket x, InterfaceBucket y) { return x.m_bucket - y.m_bucket; }
         );

         // Step 1-d: Generate Replacement List for Targetted Buckets
         replacementList = InterfaceBucketControl.SubtractServerList(serverList, servers);

         if (replacementList.Length == 0)
            throw new ActionFailedException("This operation would result in all servers being removed from the interface bank, this is not permitted.");

         Console.WriteLine("Rebalancing will take place on {0} buckets.", targetedBuckets.Count);

         // Step 2: Export Original Configuration XML
         ExportOriginalConfiguration();

         // Step 3: Rebalance Servers Bucketing
         for (int c = 0; c < targetedBuckets.Count; c++)
            ReplaceServer(transaction, targetedBuckets[c], replacementList[c % replacementList.Length]);
      }

      private void ReplaceServer(SqlTransaction transaction, InterfaceBucket bucket, string replacementServer) {
         InterfaceBucketControl.CreateBucket(
            transaction.Connection,
            transaction,
            bucket.m_environment,
            bucket.m_interface,
            bucket.m_titleid,
            bucket.m_bucket,
            replacementServer,
            replacementServer,
            bucket.m_migrationStart,
            bucket.m_info1,
            bucket.m_info2,
            bucket.m_info3,
            bucket.m_info4,
            true // overwrite
         );
      }

      private ServerDictionary GetServerList(SqlTransaction transaction, out string[] serverList) {
         ServerDictionary result = new ServerDictionary(StringComparer.CurrentCultureIgnoreCase);

         serverList = InterfaceBucketControl.GetServerList(
            transaction.Connection, 
            transaction, 
            environment, 
            interfaceName, 
            title);

         for (int c = 0; c < serverList.Length; c++)
            result.Add(serverList[c], serverList[c]);

         
         return result;
      }

      private void ExportOriginalConfiguration() {
         XmlExport export = new XmlExport(null);
         StringDictionary exportParameters = new StringDictionary();

         // generate the property list
         exportParameters.Add(PARAM_NPDB_SERVER, npdbServer);
         exportParameters.Add(PARAM_NPDB_DATABASE, npdbDatabase);
         exportParameters.Add(PARAM_ENV, environment);
         exportParameters.Add(PARAM_FILENAME, filePath);

         exportParameters.Add(PARAM_EXPORT_IFACE, interfaceName);

         // present the parameters to the action
         export.IngestParameters(exportParameters);
         
         // execute action
         export.Execute();
      }

      public override string Name {
         get { return "remove-servers"; }
      }

      public override string Description {
         get {
            return
               "Removes livecache servers from the server bank.  " +
               "The remaining servers as redistributed across the interfaces mapped to the servers removed from the bank.  ";
         }
      }

      public override Parameter[] Parameters {
         get {
            return Parameter.JoinParameters(
               new Parameter(PARAM_NPDB_SERVER, "host name of the server with the npdb database."),
               new Parameter(PARAM_NPDB_DATABASE, "name of the npdb database."),
               new Parameter(PARAM_ENV, "target environment name."),
               new Parameter(PARAM_SERVERS, "comma separated list of servers to remove from the bank."),
               new Parameter(PARAM_FILENAME, "path to write backup xml file.")
            );
         }
      }

      public override string[] Constraints {
         get {
            return Parameter.JoinConstraints(
               "The application user must have login and write access for the npdb database for the specified npdb server.",
               "The application user must have write access to the specified backup xml file path.",
               "Their must be at least one server remaining in the livecache bank after removing the specified servers."
            );
         }
      }

      private const int title = 0;
      private const string interfaceName = "livecache";

      private bool initialized;

      private string npdbServer;
      private string npdbDatabase;
      private string environment;
      private string filePath;
      private string[] servers;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\unit\EnvironmentSettingCloningHelper.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;

namespace xonline.tools.configuration.test {
   public static class EnvironmentSettingCloningHelper {
      public const string EnvironmentColumn  = "vc_environment";
      public const string ComponentColumn    = "vc_component";
      public const string SiteColumn         = "i_site_id";
      public const string ServerColumn       = "vc_server";
      public const string SettingColumn      = "vc_setting";
      public const string ValueColumn        = "vc_value";

      public static void ValidateReaderData(SqlDataReader reader, Dictionary<string, object> data) {
         foreach (string key in data.Keys) {
            if (!data[key].Equals(reader[key])) {
               string message;

               message = string.Format("value mismatch for the {0} column, {1} found but {2} expected.", key, reader[key], data[key]);

               throw new Exception(message);
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\unit\EnvironmentSettingCloning.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Core;

using xonline.tools.configuration.setting_override;
using xonline.common.config;

namespace xonline.tools.configuration.test {
   [Owner("raphamun"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class SettingOverrideSchema : UnitTest {
      static string TestName = "Setting Override Schema";
      static string Description = "Verifies the schema of t_setting_overrides matches expectations.";

      public SettingOverrideSchema()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            using (SqlDataReader reader = ExecuteQuery(connection, "SELECT TOP 1 * FROM t_setting_overrides")) {
               DataTable schemaTable;

               schemaTable = reader.GetSchemaTable();

               ValidateColumnCount(schemaTable);

               ValidateColumn(schemaTable, 0, EnvironmentSettingCloningHelper.EnvironmentColumn, "nvarchar");
               ValidateColumn(schemaTable, 1, EnvironmentSettingCloningHelper.ComponentColumn, "nvarchar");
               ValidateColumn(schemaTable, 2, EnvironmentSettingCloningHelper.SiteColumn, "int");
               ValidateColumn(schemaTable, 3, EnvironmentSettingCloningHelper.ServerColumn, "nvarchar");
               ValidateColumn(schemaTable, 4, EnvironmentSettingCloningHelper.SettingColumn, "nvarchar");
               ValidateColumn(schemaTable, 5, EnvironmentSettingCloningHelper.ValueColumn, "nvarchar");
            }
         }
      }

      private void ValidateColumnCount(DataTable schemaTable) {
         int columns = schemaTable.Rows.Count;

         if (columns != 6)
            throw new Exception(string.Format("t_setting_overrides contains {0} columns, when 6 were expected.", columns));
      }

      private void ValidateColumn(DataTable schemaTable, int ordinal, string name, string dataTypeName) {
         string columnName = schemaTable.Rows[ordinal].Field<string>("ColumnName");
         string columnDataTypeName = schemaTable.Rows[ordinal].Field<string>("DataTypeName");

         if (columnName != name)
            throw new Exception(string.Format("t_setting_overrides contains column named {0} in ordinal {1}, but {2} is expected.", columnName, ordinal, name));

         if (columnDataTypeName != dataTypeName)
            throw new Exception(string.Format("t_setting_overrides column named {0} has data type {1}, but {2} is expected.", name, columnDataTypeName, dataTypeName));
      }
   }

   [Owner("raphamun"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class GetSettingOverride : UnitTest {
      static string TestName = "Get Setting Override";
      static string Description = "Verifies SettingOverride controllers ability to get setting overrides.";

      public GetSettingOverride()
         : base(TestName, Description) { }

      protected override void Unit() {
         Dictionary<string, object> data = new Dictionary<string, object>();
         string environment;
         string component;
         int site;
         string server;
         string setting;

         using (SqlConnection connection = GetNpdbConnection()) {
            // Pick a setting override, any setting override
            using (SqlDataReader reader = ExecuteQuery(connection, "SELECT TOP 1 * FROM t_setting_overrides")) {
               if (!reader.Read())
                  NewException("no settings available, no conclusive tests can be run if t_setting_overrides is empty.");

               environment = (string)reader[EnvironmentSettingCloningHelper.EnvironmentColumn];
               data[EnvironmentSettingCloningHelper.ComponentColumn] = component = (string)reader[EnvironmentSettingCloningHelper.ComponentColumn];
               data[EnvironmentSettingCloningHelper.SiteColumn] = site = (int)reader[EnvironmentSettingCloningHelper.SiteColumn];
               data[EnvironmentSettingCloningHelper.ServerColumn] = server = (string)reader[EnvironmentSettingCloningHelper.ServerColumn];
               setting = (string)reader[EnvironmentSettingCloningHelper.SettingColumn];
               data[EnvironmentSettingCloningHelper.ValueColumn] = reader[EnvironmentSettingCloningHelper.ValueColumn];
            }

            // Verify that GetSettingOverride correctly locates and retrieves this setting override
            using (SqlDataReader reader = SettingOverrideControl.GetSettingOverride(connection, environment, site, server, component, setting)) {
               if (!reader.Read())
                  NewException("GetSettingOverride return now record even though one exists: env={0}, comp={1}, site={2}, server={3} setting={4}", environment, component, site, server, setting);

               EnvironmentSettingCloningHelper.ValidateReaderData(reader, data);
            }
         }
      }
   }

   [Owner("raphamun"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class DoesSettingOverrideExist : UnitTest {
      static string TestName = "Setting Override Exists Check";
      static string Description = "Verifies SettingOverride controllers ability to determine if a setting override exists.";

      public DoesSettingOverrideExist()
         : base(TestName, Description) { }

      protected override void Unit() {
         string environment;
         string component;
         int site;
         string server;
         string setting;

         using (SqlConnection connection = GetNpdbConnection()) {
            // Pick a setting override, any setting override
            using (SqlDataReader reader = ExecuteQuery(connection, "SELECT TOP 1 * FROM t_setting_overrides")) {
               if (!reader.Read())
                  NewException("no settings available, no conclusive tests can be run if t_setting_overrides is empty.");

               environment = (string)reader[EnvironmentSettingCloningHelper.EnvironmentColumn];
               component = (string)reader[EnvironmentSettingCloningHelper.ComponentColumn];
               site = (int)reader[EnvironmentSettingCloningHelper.SiteColumn];
               server = (string)reader[EnvironmentSettingCloningHelper.ServerColumn];
               setting = (string)reader[EnvironmentSettingCloningHelper.SettingColumn];
            }

            // Verify that DoesSettingOverrideExist correctly identify it as being present
            if (!SettingOverrideControl.DoesSettingOverrideExist(connection, environment, site, server, component, setting))
               NewException("setting is present but reported as absent (env:{0} site:{1} srv:{2} comp:{3} set:{4})", environment, site, server, component, setting);
         }
      }
   }

   [Owner("raphamun"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class AddSettingOverride : UnitTest {
      static string TestName = "Add Setting Override";
      static string Description = "Verifies SettingOverride controllers ability to set setting overrides.";

      public AddSettingOverride()
         : base(TestName, Description) { }

      protected override void Unit() {
         string query;
         string component;
         string setting;
         string value = "stf";

         query = string.Format(
            "SELECT TOP 1 s.vc_setting " +
            "FROM t_settings s " +
            "WHERE 0 = (SELECT COUNT(*) FROM t_setting_overrides WHERE vc_environment=N'{0}' AND vc_setting=s.vc_setting)",
            Environment);

         using (SqlConnection connection = GetNpdbConnection()) {
            // Select a setting which has not yet been overriden
            using (SqlDataReader reader = ExecuteQuery(connection, query)) {
               // This is possible albeit quite unlikely
               if (!reader.Read())
                  NewException("could not find an unused setting.");

               component = "wcdebugtest";
               setting = reader.GetString(0);
            }

            try {
               // Add an override to this setting under the wcdebugtest component
               SettingOverrideControl.AddSettingOverride(connection, Environment, Config.MainSiteId, NpdbServer, component, setting, value, false);

               // Read the newly added setting and verify the value
               query = string.Format(
                  "SELECT * FROM t_setting_overrides WHERE " +
                  "vc_environment=N'{0}' AND i_site_id={1} AND vc_server=N'{2}' AND " +
                  "vc_component=N'{3}' AND vc_setting=N'{4}'",
                  Environment, Config.MainSiteId, NpdbServer, component, setting);

               using (SqlDataReader reader = ExecuteQuery(connection, query)) {
                  string data;

                  // It exists right?
                  if (!reader.Read())
                     NewException("setting override was not added.");

                  data = (string)reader[EnvironmentSettingCloningHelper.ValueColumn];

                  if (value != data)
                     NewException("setting value '{0}' does not match expectation '{1}'", data, value);
               }
            }
            finally {
               // Clean-up the newly added value
               query = string.Format(
                  "DELETE FROM t_setting_overrides WHERE " +
                  "vc_environment=N'{0}' AND i_site_id={1} AND vc_server=N'{2}' AND " +
                  "vc_component=N'{3}' AND vc_setting=N'{4}'",
                  Environment, Config.MainSiteId, NpdbServer, component, setting);

               ExecuteNonQuery(connection, query);
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\func\Suite.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.tools.configuration.buckets;

namespace xonline.tools.configuration.test {
   [TestGroup]
   public class EnvironmentSettingCloningSuite : FuncTest {
      public EnvironmentSettingCloningSuite()
         : base("Environment Setting Cloning Functionals", "XboxLive deployment configuration functional tests for environment setting cloning functionality.") 
      {
         AddChild(new VerifyNoUnintendedWritesFuncTest(), true, false);
         AddChild(new RewriteSettingsFuncTest(), true, false);
         AddChild(new ProductionWriteRejectFuncTest(), true, false);
         
      }

      protected override void Functional() {
         throw new NotImplementedException();
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\unit\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\unit\Suite.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Core;

using xonline.tools.configuration.buckets;

namespace xonline.tools.configuration.test {
   [TestGroup, Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class InterfaceBucketSuite : UnitTest {
      public InterfaceBucketSuite()
         : base("Interface Bucket Units", "XboxLive deployment configuration unit tests for interface bucket functionality.") 
      {
         AddChild(new InterfaceBucketSchema(), true, false);
         AddChild(new GetInterfaceBucket(), true, false);
         AddChild(new InsertInterfaceBucket(), true, false);
         AddChild(new ExistInterfaceBucket(), true, false);
         AddChild(new ClearInterfaceBucket(), true, false);
         AddChild(new DeleteInterfaceBucket(), true, false);
         AddChild(new SimpleQueryInterfaceBucket(), true, false);
         AddChild(new TitleQueryInterfaceBucket(), true, false);
         AddChild(new BucketQueryInterfaceBucket(), true, false);
         AddChild(new ServerQueryInterfaceBucket(), true, false);
         AddChild(new RangedServerQueryInterfaceBucket(), true, false);
         AddChild(new StripingInterfaceBucket(), true, false);
         AddChild(new QueryInterfaceBucketLogs(), true, false);
      }

      protected override void Unit() {
         throw new NotImplementedException();
      }
   }

   [TestGroup, Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class EnvironmentSettingCloningSuite : UnitTest {
      public EnvironmentSettingCloningSuite()
         : base("Environment Setting Cloning Units", "XboxLive deployment configuration unit tests for environment setting cloning functionality.")
      {
         AddChild(new SettingOverrideSchema(), true, false);
         AddChild(new GetSettingOverride(), true, false);
         AddChild(new DoesSettingOverrideExist(), true, false);
         AddChild(new AddSettingOverride(), true, false);
      }

      protected override void Unit() {
         throw new NotImplementedException();
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\unit\InterfaceBucketControl.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Core;

using xonline.tools.configuration.buckets;
using xonline.common.config;

namespace xonline.tools.configuration.test {
   // No Assumptions, Schema Challenged
   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class InterfaceBucketSchema : UnitTest {
      static string TestName    = "InterfaceBucket Schema";
      static string Description = "Verifies the schema of t_interface_buckets matches expectations.  This unit test will enable others to assume the schema.";

      public InterfaceBucketSchema() 
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            using (SqlDataReader reader = ExecuteQuery(connection, "SELECT TOP 1 * FROM t_interface_buckets")) {
               DataTable schemaTable;

               schemaTable = reader.GetSchemaTable();

               ValidateColumnCount(schemaTable);

               ValidateColumn(schemaTable, 0, InterfaceBucketHelper.EnvironmentColumn, "nvarchar");
               ValidateColumn(schemaTable, 1, InterfaceBucketHelper.InterfaceColumn, "nvarchar");
               ValidateColumn(schemaTable, 2, InterfaceBucketHelper.TitleColumn, "int");
               ValidateColumn(schemaTable, 3, InterfaceBucketHelper.BucketColumn, "int");
               ValidateColumn(schemaTable, 4, InterfaceBucketHelper.ServerColumn, "nvarchar");
               ValidateColumn(schemaTable, 5, InterfaceBucketHelper.NextServerColumn, "nvarchar");
               ValidateColumn(schemaTable, 6, InterfaceBucketHelper.MigrationDateColumn, "datetime");
               ValidateColumn(schemaTable, 7, InterfaceBucketHelper.Info1Column, "nvarchar");
               ValidateColumn(schemaTable, 8, InterfaceBucketHelper.Info2Column, "nvarchar");
               ValidateColumn(schemaTable, 9, InterfaceBucketHelper.Info3Column, "nvarchar");
               ValidateColumn(schemaTable, 10, InterfaceBucketHelper.Info4Column, "nvarchar");
            }
         }
      }

      private void ValidateColumnCount(DataTable schemaTable) {
         int columns = schemaTable.Rows.Count;

         if (columns != 11)
            throw new Exception(string.Format("t_interface_buckets contains {0} columns, when 11 were expected.", columns));
      }

      private void ValidateColumn(DataTable schemaTable, int ordinal, string name, string dataTypeName) {
         string columnName = schemaTable.Rows[ordinal].Field<string>("ColumnName");
         string columnDataTypeName = schemaTable.Rows[ordinal].Field<string>("DataTypeName");

         if (columnName != name)
            throw new Exception(string.Format("t_interface_buckets contains column named {0} in ordinal {1}, but {2} is expected.", columnName, ordinal, name));

         if (columnDataTypeName != dataTypeName)
            throw new Exception(string.Format("t_interface_buckets column named {0} has data type {1}, but {2} is expected.", name, columnDataTypeName, dataTypeName));
      }
   }

   // Schema Assumed, Get Challenged
   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class GetInterfaceBucket : UnitTest {
      static string TestName = "Query Interface Bucket";
      static string Description = "Verifies the interface bucket apis ability to query interface buckets.  This unit test will allow others to consume interface bucket query functionality.";

      public GetInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            StringBuilder insertQuery = new StringBuilder();

            insertQuery.AppendLine("INSERT INTO t_interface_buckets");
            insertQuery.AppendLine("(vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server, dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4)");
            insertQuery.AppendFormat("VALUES (N'{0}', N'{1}', 1, 2, N'{2}', N'{2}', N'{3}', N'3', N'4', N'5', N'6')", Environment, Interface, NpdbServer, SqlDateTime.MinValue.Value);

            // Clear the interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert the test interface bucket
            ExecuteNonQuery(connection, insertQuery.ToString());

            using (SqlDataReader reader = InterfaceBucketControl.GetBucketReader(connection, null, Environment, Interface, 1, 2)) {
               if (!reader.Read())
                  NewException("interface bucket was not added.");

               InterfaceBucketHelper.ValidateInterfaceBucket(
                  reader, 
                  NpdbServer, NpdbServer, 
                  SqlDateTime.MinValue.Value, 
                  "3", "4", "5", "6");
            }

            // Clear the interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);
         }
      }
   }

   // Schema Assumed, Get Assumed, Insert Challenged
   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class InsertInterfaceBucket : UnitTest {
      static string TestName    = "Insert Interface Bucket";
      static string Description = "Verifies the interface bucket apis ability to create interface buckets.  This unit test will allow others to consume interface bucket add functionality.";
      static int    Title       = 3;

      public InsertInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear the interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert a test interface
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "1", "2", "", "", false);

            // Select and validate the record
            using (SqlDataReader reader = InterfaceBucketControl.GetBucketReader(connection, null, Environment, Interface, Title, 0)) {
               if (!reader.Read())
                  throw new Exception("interface bucket was not added.");

               InterfaceBucketHelper.ValidateInterfaceBucket(
                  reader,
                  NpdbServer, NpdbServer,
                  SqlDateTime.MinValue.Value,
                  "1", "2", "", "");
            }

            // Replace a test interface
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "3", "4", true);

            // Select and validate the record
            using (SqlDataReader reader = InterfaceBucketControl.GetBucketReader(connection, null, Environment, Interface, Title, 0)) {
               if (!reader.Read())
                  throw new Exception("interface bucket was lost.");

               InterfaceBucketHelper.ValidateInterfaceBucket(
                  reader,
                  NpdbServer, NpdbServer,
                  SqlDateTime.MinValue.Value,
                  "", "", "3", "4");
            }

            // Cleanup test interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);
         }
      }
   }

   // Schema Assumed, Insert Assumed, Exists Challenged
   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class ExistInterfaceBucket : UnitTest {
      static string TestName    = "Existential Interface Bucket";
      static string Description = "Verifies the interface bucket controller's ability to clear interface buckets.";
      static int    Title       = 4;

      public ExistInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // There should be no buckets present
            if (InterfaceBucketControl.DoesBucketExist(connection, null, Environment, Interface, Title, 0))
               NewException("the bucket is not expected to be present.");

            // Insert buckets
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);

            // There should be buckets present
            if (!InterfaceBucketControl.DoesBucketExist(connection, null, Environment, Interface, Title, 0))
               NewException("the bucket is expected to be present.");

            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);
         }
      }
   }

   // Schema Assumed, Insert Assumed, Clear Challenged
   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class ClearInterfaceBucket : UnitTest {
      static string TestName    = "Clear Interface Bucket";
      static string Description = "Verifies the interface bucket controller's ability to clear interface buckets.";
      static int    Title       = 5;

      public ClearInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            int count;

            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert buckets
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 1, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);

            count = InterfaceBucketHelper.GetInterfaceBucketCount(connection, Environment, Interface);

            // Make sure the correct number of interface buckets are present
            if (2 != count)
               InterfaceBucketHelper.NewException("exactly 2 interface buckets should have been inserted ({0} were found).", count);

            InterfaceBucketControl.ClearBuckets(connection, null, Environment, Interface);

            count = InterfaceBucketHelper.GetInterfaceBucketCount(connection, Environment, Interface);

            // Make sure all buckets were removed
            if (0 != count)
               InterfaceBucketHelper.NewException("not all interface buckets were cleared ({0} remain).", count);
         }
      }
   }

   // Schema Assumed, Insert Assumed, Get Assumed, Delete Challenged
   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class DeleteInterfaceBucket : UnitTest {
      static string TestName    = "Delete Interface Bucket";
      static string Description = "Verifies the interface bucket controller's ability to delete an interface bucket.";
      static int    Title       = 6;

      public DeleteInterfaceBucket() 
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert buckets
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 1, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);

            using (SqlDataReader reader = InterfaceBucketControl.GetBucketReader(connection, null, Environment, Interface, Title, 0)) {
               if (!reader.Read())
                  NewException("failed to add bucket 0.");
            }

            using (SqlDataReader reader = InterfaceBucketControl.GetBucketReader(connection, null, Environment, Interface, Title, 1)) {
               if (!reader.Read())
                  NewException("failed to add bucket 1.");
            }

            // Delete bucket 0
            InterfaceBucketControl.DeleteBucket(connection, null, Environment, Interface, Title, 0);

            using (SqlDataReader reader = InterfaceBucketControl.GetBucketReader(connection, null, Environment, Interface, Title, 0)) {
               if (reader.Read())
                  NewException("failed to remove bucket 0.");

               
            }

            using (SqlDataReader reader = InterfaceBucketControl.GetBucketReader(connection, null,Environment, Interface, Title, 1)) {
               if (!reader.Read())
                  NewException("removal of bucket 0 resulted in bucket 1 being removed as well.");
            }

            // Delete bucket 1
            InterfaceBucketControl.DeleteBucket(connection, null, Environment, Interface, Title, 1);

            using (SqlDataReader reader = InterfaceBucketControl.GetBucketReader(connection, null, Environment, Interface, Title, 1)) {
               if (reader.Read())
                  NewException("failed to remove bucket 1.");
            }
         }
      }
   }

   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class SimpleQueryInterfaceBucket : UnitTest {
      static string TestName    = "Simple Interface Bucket Query";
      static string Description = "Verifies the interface bucket controller's ability to perform simple queries involving only environment and interface.";
      static int    Title       = 7;

      public SimpleQueryInterfaceBucket() 
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert buckets
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, 0, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 1, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 2, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);

            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface)) {
               int count;

               count = InterfaceBucketHelper.GetInterfaceBucketCount(reader);
               if (4 != count)
                  NewException("{0} buckets found in the environment/interface query, but 4 are exected", count);
            }

            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);
         }
      }
   }

   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class TitleQueryInterfaceBucket : UnitTest {
      static string TestName    = "Title Interface Bucket Query";
      static string Description = "Verifies the interface bucket controller's ability to perform simple queries involving only environment, interface, and title.";
      static int Title          = 8;

      public TitleQueryInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert buckets
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, 0, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 1, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 2, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);

            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface, 0)) {
               int count;

               count = InterfaceBucketHelper.GetInterfaceBucketCount(reader);
               if (1 != count)
                  NewException("{0} buckets found in the environment/interface/title=0 query, but 1 are exected", count);
            }

            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface, Title)) {
               int count;

               count = InterfaceBucketHelper.GetInterfaceBucketCount(reader);
               if (3 != count)
                  NewException("{0} buckets found in the environment/interface/title={1} query, but 3 are exected", count, Title);
            }

            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);
         }
      }
   }

   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class BucketQueryInterfaceBucket : UnitTest {
      static string TestName    = "Bucket Interface Bucket Query";
      static string Description = "Verifies the interface bucket controller's ability to perform simple queries involving only environment, interface, and title.";
      static int Title          = 9;

      public BucketQueryInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert buckets
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, 0, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 1, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 2, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);

            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface, null, 0, 0, null)) {
               int count;

               count = InterfaceBucketHelper.GetInterfaceBucketCount(reader);
               if (2 != count)
                  NewException("{0} buckets found in the environment/interface/bucket=(0 to 0) query, but 2 are exected", count);
            }

            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface, null, 1, null, null)) {
               int count;

               count = InterfaceBucketHelper.GetInterfaceBucketCount(reader);
               if (2 != count)
                  NewException("{0} buckets found in the environment/interface/bucket=(1 to 2) query, but 2 are exected", count);
            }

            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);
         }
      }
   }

   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class ServerQueryInterfaceBucket : UnitTest {
      static string TestName = "Server Interface Bucket Query";
      static string Description = "Verifies the interface bucket controller's ability to perform simple queries involving only environment, interface, and server names.";
      static int Title = 10;

      public ServerQueryInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert buckets
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, 0, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 1, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 2, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);

            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface, null, null, null, NpdbServer)) {
               int count;

               count = InterfaceBucketHelper.GetInterfaceBucketCount(reader);
               if (4 != count)
                  NewException("{0} buckets found in the environment/interface/server={1} query, but 4 are exected", count, NpdbServer);
            }

            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);
         }
      }
   }

   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class RangedServerQueryInterfaceBucket : UnitTest {
      static string TestName = "Ranged Server Interface Bucket Query";
      static string Description = "Verifies the interface bucket controller's ability to perform simple queries involving only environment, interface, server names, against bucket ranges.";
      static int Title = 11;

      public RangedServerQueryInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            // Insert buckets
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, 0, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 1, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);
            InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 2, NpdbServer, NpdbServer, SqlDateTime.MinValue.Value, "", "", "", "", false);

            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface, null, 0, null, NpdbServer)) {
               int count;

               count = InterfaceBucketHelper.GetInterfaceBucketCount(reader);
               if (4 != count)
                  NewException("{0} buckets found in the environment/interface/bucket=0 and up/server={1} query, but 4 are exected", count, NpdbServer);
            }

            using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface, null, 0, 1, NpdbServer)) {
               int count;

               count = InterfaceBucketHelper.GetInterfaceBucketCount(reader);
               if (3 != count)
                  NewException("{0} buckets found in the environment/interface/bucket=0 to 1/server={1} query, but 3 are exected", count, NpdbServer);
            }

            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);
         }
      }
   }

   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class StripingInterfaceBucket : UnitTest {
      static string TestName = "Stripe interface buckets";
      static string Description = "Verifies the interface bucket controller's ability to stripe servers across interface buckets.";
      static int Title = 12;

      public StripingInterfaceBucket()
         : base(TestName, Description) { }

      protected override void Unit() {
         string[] servers = new string[3];
         int count;

         servers[0] = "TestXblConfigure1";
         servers[1] = "TestXblConfigure2";
         servers[2] = "TestXblConfigure3";

         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            try {
               InterfaceBucketHelper.DeleteTestServer(connection, Environment, servers);
               InterfaceBucketHelper.InsertTestServer(connection, Environment, servers, Config.MainSiteId);

               // Stripe buckets
               InterfaceBucketControl.ApplyStriping(connection, null, Environment, Interface, Title, servers, 9);

               // Add the interface buckets
               count = InterfaceBucketHelper.GetInterfaceBucketCount(connection, Environment, Interface);

               // Verify that the 9 Interface buckets were added
               if (9 != count)
                  NewException("{0} interface buckets found, but 9 were supposed to be inserted.", count);

               // Verify that these buckets have been created and in the expected order
               using (SqlDataReader reader = InterfaceBucketControl.QueryBuckets(connection, null, Environment, Interface)) {
                  for (int c = 0; c < 0; c++) {
                     if (!reader.Read())
                        NewException("failed to read bucket {0}.", c);

                     InterfaceBucketHelper.ValidateInterfaceBucket(
                        reader,
                        servers[c % servers.Length], servers[c % servers.Length],
                        SqlDateTime.MinValue.Value,
                        "", "", "", "");
                  }
               }
            }
            finally {
               // Clear interface buckets
               InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

               InterfaceBucketHelper.DeleteTestServer(connection, Environment, servers);
            }
         }
      }
   }

   [Owner("jojohn"), TestFrequency("Daily"), EnvRequirement("DVT")]
   public class QueryInterfaceBucketLogs : UnitTest {
      static string TestName = "Query interface bucket logs";
      static string Description = "Verifies the interface bucket controller's ability to query interface bucket logs.";
      static int Title = 13;

      public QueryInterfaceBucketLogs()
         : base(TestName, Description) { }

      // Determine if two dates are near each other.
      // This is neccessary to accomodate the precision difference between .net platform and sqlserver
      protected bool Near(DateTime date1, DateTime date2) {
         TimeSpan span;

         if (date1 > date2)
            span = date1 - date2;
         else
            span = date2 - date1;

         return span.TotalMilliseconds < 500.0;
      }

      protected override void Unit() {
         InterfaceBucketLog[] logs;
         string[] servers = new string[2];
         DateTime now;
         DateTime future;
         DateTime d1, d2;

         servers[0] = "TestXblConfigure1";
         servers[1] = "TestXblConfigure2";

         d1 = DateTime.Now;
         d2 = DateTime.Now + TimeSpan.FromHours(12.0);

         using (SqlConnection connection = GetNpdbConnection()) {
            // Clear interface buckets
            InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

            try {
               InterfaceBucketHelper.DeleteTestServer(connection, Environment, servers);
               InterfaceBucketHelper.InsertTestServer(connection, Environment, servers, Config.MainSiteId);

               // Create an interface bucket
               InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, servers[0], servers[0], d1, "1", "2", "3", "4", false);

               System.Threading.Thread.Sleep(100);

               // Figure out the time
               now = DateTime.UtcNow;
               future = DateTime.UtcNow + TimeSpan.FromMinutes(1.0);

               System.Threading.Thread.Sleep(750);

               // Update the interface bucket
               InterfaceBucketControl.CreateBucket(connection, null, Environment, Interface, Title, 0, servers[1], servers[1], d2, "9", "8", "7", "6", true);

               // Add the interface buckets
               logs = InterfaceBucketControl.QueryBucketLogs(connection, null, Environment, new string[] { Interface }, new int[] { Title }, servers, null, now, future);

               // Verify the count
               if (logs.Length != 1)
                  NewException("{0} log entries found, but 1 is expected.", logs.Length);

               // Verify the history is present for new and old
               if (null == logs[0].m_new)
                  NewException("the new interface bucket entry should not be null.");
               if (null == logs[0].m_old)
                  NewException("the old interface bucket entry should not be null.");

               // Verify old settings
               if (Environment != logs[0].m_old.m_environment)
                  NewException("the old environment '{0}' does not match expectations '{1}'.", logs[0].m_old.m_environment, Environment);
               if (Interface != logs[0].m_old.m_interface)
                  NewException("the old interface '{0}' does not match expectations '{1}'.", logs[0].m_old.m_interface, Interface);
               if (Title != logs[0].m_old.m_titleid)
                  NewException("the old title {0} does not match expectations {1}.", logs[0].m_old.m_titleid, Title);
               if (servers[0] != logs[0].m_old.m_server)
                  NewException("the old interface name '{0}' does not match expectations '{1}'.", logs[0].m_old.m_server, servers[0]);
               if (servers[0] != logs[0].m_old.m_nextServer)
                  NewException("the old interface name '{0}' does not match expectations '{1}'.", logs[0].m_old.m_nextServer, servers[0]);
               if (!Near(d1, logs[0].m_old.m_migrationStart))
                  NewException("the old date {0} does not match expectations {1}.", logs[0].m_old.m_migrationStart, d1);
               if (0 != logs[0].m_old.m_bucket)
                  NewException("the old bucket {0} does not match expectations 0.", logs[0].m_old.m_bucket);
               if ("1" != logs[0].m_old.m_info1)
                  NewException("the old info1 '{0}' does not match expectation '1'.", logs[0].m_old.m_info1);
               if ("2" != logs[0].m_old.m_info2)
                  NewException("the old info2 '{0}' does not match expectation '2'.", logs[0].m_old.m_info2);
               if ("3" != logs[0].m_old.m_info3)
                  NewException("the old info3 '{0}' does not match expectation '3'.", logs[0].m_old.m_info3);
               if ("4" != logs[0].m_old.m_info4)
                  NewException("the old info4 '{0}' does not match expectation '4'.", logs[0].m_old.m_info4);

               // Verify new settings
               if (Environment != logs[0].m_new.m_environment)
                  NewException("the new environment '{0}' does not match expectations '{1}'.", logs[0].m_new.m_environment, Environment);
               if (Interface != logs[0].m_new.m_interface)
                  NewException("the new interface '{0}' does not match expectations '{1}'.", logs[0].m_new.m_interface, Interface);
               if (Title != logs[0].m_new.m_titleid)
                  NewException("the new title {0} does not match expectations {1}.", logs[0].m_new.m_titleid, Title);
               if (servers[1] != logs[0].m_new.m_server)
                  NewException("the new interface name '{0}' does not match expectations '{1}'.", logs[0].m_new.m_server, servers[1]);
               if (servers[1] != logs[0].m_new.m_nextServer)
                  NewException("the new interface name '{0}' does not match expectations '{1}'.", logs[0].m_new.m_nextServer, servers[1]);
               if (!Near(d2, logs[0].m_new.m_migrationStart))
                  NewException("the new date {0} does not match expectations {1}.", logs[0].m_new.m_migrationStart, d2);
               if (0 != logs[0].m_new.m_bucket)
                  NewException("the new bucket {0} does not match expectations 0.", logs[0].m_new.m_bucket);
               if ("9" != logs[0].m_new.m_info1)
                  NewException("the new info1 '{0}' does not match expectation '9'.", logs[0].m_new.m_info1);
               if ("8" != logs[0].m_new.m_info2)
                  NewException("the new info2 '{0}' does not match expectation '8'.", logs[0].m_new.m_info2);
               if ("7" != logs[0].m_new.m_info3)
                  NewException("the new info3 '{0}' does not match expectation '7'.", logs[0].m_new.m_info3);
               if ("6" != logs[0].m_new.m_info4)
                  NewException("the new info4 '{0}' does not match expectation '6'.", logs[0].m_new.m_info4);
            }
            finally {
               // Clear interface buckets
               InterfaceBucketHelper.ClearInterfaceBucket(connection, Environment, Interface);

               InterfaceBucketHelper.DeleteTestServer(connection, Environment, servers);
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\cchkcli.cpp ===
// cchkcli.cpp : Implementation of DLL Exports.

#include "stdafx.h"
#include "resource.h"
#include "cchkcli.h"
#include "cchkcli_i.c"

class CcchkcliModule : public CAtlDllModuleT< CcchkcliModule >
{
public :
	DECLARE_LIBID(LIBID_cchkcliLib)
	DECLARE_REGISTRY_APPID_RESOURCEID(IDR_CCHKCLI, "{96E6CC6C-E977-406B-A3C1-2D6BE610E384}")
};

CcchkcliModule _AtlModule;


// DLL Entry Point
extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
	hInstance;
    return _AtlModule.DllMain(dwReason, lpReserved); 
}


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hr = PrxDllCanUnloadNow();
    if (FAILED(hr))
        return hr;
#endif
    return _AtlModule.DllCanUnloadNow();
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _AtlModule.DllGetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _AtlModule.DllRegisterServer();
#ifdef _MERGE_PROXYSTUB
    if (FAILED(hr))
        return hr;
    hr = PrxDllRegisterServer();
#endif
	return hr;
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
	HRESULT hr = _AtlModule.DllUnregisterServer();
#ifdef _MERGE_PROXYSTUB
    if (FAILED(hr))
        return hr;
    hr = PrxDllRegisterServer();
    if (FAILED(hr))
        return hr;
    hr = PrxDllUnregisterServer();
#endif
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\func\Func.cs ===
using System;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace xonline.tools.configuration.test {
   public abstract class FuncTest : TestBase {
      public static string Interface {
         get { return "wcdebugtest"; }
      }

      public static string Environment {
         get { return xonline.common.config.Config.Environment; }
      }

      public static string NpdbServer {
         get { return xonline.common.config.Config.NpdbServer; }
      }

      protected FuncTest(string name, string description) { 
         Name = name;
         Desc = description;
      }

      protected abstract void Functional();

      protected override void Execute() {
         ResultCode = TEST_RESULTS.FAILED;

         Functional();

         ResultCode = TEST_RESULTS.PASSED;
      }

      protected SqlConnection GetNpdbConnection() {
         SqlConnection connection = new SqlConnection(xonline.common.config.Config.NpdbConnectionString);

         connection.Open();

         return connection;
      }

      public static T ExecuteScalar<T>(SqlConnection connection, string query) {
         SqlCommand command;

         command = new SqlCommand(query, connection);

         return (T)command.ExecuteScalar();
      }

      public static void ExecuteNonQuery(SqlConnection connection, string query) {
         SqlCommand command;

         command = new SqlCommand(query, connection);

         command.ExecuteNonQuery();
      }

      public static SqlDataReader ExecuteQuery(SqlConnection connection, string query) {
         SqlCommand command;

         command = new SqlCommand(query, connection);

         return command.ExecuteReader();
      }

      protected static void NewException(string message, params object[] args) {
         throw new Exception(string.Format(message, args));
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\cconncheckclient.cpp ===
// CConnCheckClient.cpp : Implementation of CCConnCheckClient
#include "stdafx.h"
#include "CConnCheckClient.h"


// CCConnCheckClient


STDMETHODIMP CCConnCheckClient::get_Address(BSTR* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.get_Address(pVal);
}

STDMETHODIMP CCConnCheckClient::put_Address(BSTR newVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
    {
        HRESULT hr;

        hr = m_NATTestImpl.put_Address(newVal);
        if(hr == S_OK)
            hr = m_ICMPTestImpl.put_Address(newVal);

        return hr;
    }
}

STDMETHODIMP CCConnCheckClient::get_Port(USHORT* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.get_Port(pVal);
}

STDMETHODIMP CCConnCheckClient::put_Port(USHORT newVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
    {
        HRESULT hr;

        hr = m_NATTestImpl.put_Port(newVal);
        if(hr == S_OK)
            hr = m_ICMPTestImpl.put_Port(newVal);

        return hr;
    }
}

STDMETHODIMP CCConnCheckClient::get_Timeout(LONG* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.get_Timeout(pVal);
}

STDMETHODIMP CCConnCheckClient::put_Timeout(LONG newVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
    {
        HRESULT hr;

        hr = m_NATTestImpl.put_Timeout(newVal);
        if(hr == S_OK)
            hr = m_ICMPTestImpl.put_Timeout(newVal);

        return hr;
    }
}

STDMETHODIMP CCConnCheckClient::get_MaxHops(LONG* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_ICMPTestImpl.get_MaxHops(pVal);
}

STDMETHODIMP CCConnCheckClient::put_MaxHops(LONG newVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_ICMPTestImpl.put_MaxHops(newVal);
}

// EOF
STDMETHODIMP CCConnCheckClient::get_ClientUID(BSTR* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.get_ClientUID(pVal);
}

STDMETHODIMP CCConnCheckClient::get_DHCP(VARIANT_BOOL* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.get_DHCP(pVal);
}

STDMETHODIMP CCConnCheckClient::get_USBModem(VARIANT_BOOL* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.get_USBModem(pVal);
}

STDMETHODIMP CCConnCheckClient::get_ProxySettings(BSTR* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.get_ProxySettings(pVal);
}

STDMETHODIMP CCConnCheckClient::get_UPnPNAT(BSTR* pVal)
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.get_UPnPNAT(pVal);
}

STDMETHODIMP CCConnCheckClient::DoNATTest(
    BSTR*   pResults
    )
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return m_NATTestImpl.DoNATTest(pResults);
}

STDMETHODIMP CCConnCheckClient::DoICMPTest(
    BSTR*   pResults
    )
{
    if(!m_bInitialized)
        return E_UNEXPECTED;
    else
        return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\unit\InterfaceBucketHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;

namespace xonline.tools.configuration.test {
	public static class InterfaceBucketHelper {
      public const string EnvironmentColumn = "vc_environment";
      public const string InterfaceColumn = "vc_interface";
      public const string TitleColumn = "i_title_id";
      public const string BucketColumn = "i_bucket";
      public const string ServerColumn = "vc_server";
      public const string NextServerColumn = "vc_next_server";
      public const string MigrationDateColumn = "dt_migration_start";
      public const string Info1Column = "vc_info1";
      public const string Info2Column = "vc_info2";
      public const string Info3Column = "vc_info3";
      public const string Info4Column = "vc_info4";


      public static void NewException(string message, params object[] args) {
         throw new Exception(string.Format(message, args));
      }

      public static void ExecuteNonQuery(SqlConnection connection, string query) {
         SqlCommand command;

         command = new SqlCommand(query, connection);

         command.ExecuteNonQuery();
      }

      public static SqlDataReader ExecuteQuery(SqlConnection connection, string query) {
         SqlCommand command;

         command = new SqlCommand(query, connection);

         return command.ExecuteReader();
      }

      public static int GetBuckets(SqlConnection connection, string environmentName, string interfaceName) {
         SqlCommand command;
         string query;

         query = string.Format("SELECT * FROM t_interface_buckets WHERE vc_environment=N'{0}' AND vc_interface=N'{1}'", environmentName, interfaceName);
         command = new SqlCommand(query, connection);

         return (int)command.ExecuteScalar();
      }

      public static void InsertTestServer(SqlConnection connection, string environmentName, string[] serverNames, int siteId) {
         foreach (string server in serverNames)
            InsertTestServer(connection, environmentName, server, siteId);
      }

      public static void InsertTestServer(SqlConnection connection, string environmentName, string serverName, int siteId) {
         string query;

         query = string.Format("INSERT INTO t_servers VALUES(N'{0}', N'{1}', {2}, N'offline')", environmentName, serverName, siteId);

         ExecuteNonQuery(connection, query);
      }

      public static void DeleteTestServer(SqlConnection connection, string environmentName, string[] serverNames) {
         foreach (string server in serverNames)
            DeleteTestServer(connection, environmentName, server);
      }

      public static void DeleteTestServer(SqlConnection connection, string environmentName, string serverName) {
         string query;

         query = string.Format("DELETE FROM t_servers WHERE vc_environment=N'{0}' AND vc_server=N'{1}'", environmentName, serverName);

         ExecuteNonQuery(connection, query);
      }

      public static int GetInterfaceBucketCount(SqlConnection connection, string environmentName, string interfaceName) {
         SqlCommand command;
         string     query;

         query   = string.Format("SELECT COUNT(*) FROM t_interface_buckets WHERE vc_environment=N'{0}' AND vc_interface=N'{1}'", environmentName, interfaceName);
         command = new SqlCommand(query, connection);

         return (int)command.ExecuteScalar();
      }

      public static int GetInterfaceBucketCount(SqlDataReader reader) {
         int count = 0;

         while (reader.Read())
            count++;

         return count;
      }

      public static void ClearInterfaceBucket(SqlConnection connection, string environmentName, string interfaceName) {
         ExecuteNonQuery(connection, GetClearQuery(environmentName, interfaceName));
      }

      private static string GetClearQuery(string environmentName, string interfaceName) {
         return string.Format(
            "DELETE FROM t_interface_buckets WHERE vc_environment=N'{0}' AND vc_interface=N'{1}'", 
            environmentName, 
            interfaceName);
      }

      public static void ValidateInterfaceBucket(
         SqlDataReader reader,
         string server,
         string nextServer,
         DateTime date,
         string info1,
         string info2,
         string info3,
         string info4)
      {
         if (server != (string)reader[ServerColumn])
            NewException("interface bucket server mismatch {0} != {1}", server, reader[ServerColumn]);
         if (nextServer != (string)reader[NextServerColumn])
            NewException("interface bucket next server mismatch {0} != {1}", nextServer, reader[nextServer]);
         if (date != (DateTime)reader[MigrationDateColumn])
            NewException("interface bucket migration date mismatch {0} != {1}", date, reader[MigrationDateColumn]);
         if (info1 != (string)reader[Info1Column])
            NewException("interface bucket info1 mismatch {0} != {1}", info1, reader[Info1Column]);
         if (info2 != (string)reader[Info2Column])
            NewException("interface bucket info1 mismatch {0} != {1}", info1, reader[Info2Column]);
         if (info3 != (string)reader[Info3Column])
            NewException("interface bucket info1 mismatch {0} != {1}", info1, reader[Info3Column]);
         if (info4 != (string)reader[Info4Column])
            NewException("interface bucket info1 mismatch {0} != {1}", info1, reader[Info4Column]);
      }

      public static void ValidateInterfaceBucket(
         SqlDataReader reader, 
         string environment, 
         string iface,
         int title,
         int bucket,
         string server,
         string nextServer,
         DateTime date,
         string info1,
         string info2,
         string info3,
         string info4)
      {
         if (environment != (string)reader[EnvironmentColumn])
            NewException("interface bucket environment mismatch {0} != {1}", environment, reader[EnvironmentColumn]);
         if (iface != (string)reader[InterfaceColumn])
            NewException("interface bucket interface mismatch {0} != {1}", iface, reader[InterfaceColumn]);
         if (title != (int)reader[TitleColumn])
            NewException("interface bucket title mismatch {0} != {1}", title, reader[TitleColumn]);
         if (bucket != (int)reader[BucketColumn])
            NewException("interface bucket bucket mismatch {0} != {1}", bucket, reader[BucketColumn]);
         
         ValidateInterfaceBucket(reader, server, nextServer, date, info1, info2, info3, info4);
      }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\clientimpl.cpp ===
#include "StdAfx.h"
#include "clientimpl.h"

LARGE_INTEGER CClientImpl::s_liCounterFreq = {0, 0};

CClientImpl::CClientImpl(void) : m_nPort(0), 
                                 m_nInternetPort(0), 
                                 m_lTimeout(60),
                                 m_hDoneEvent(NULL),
                                 m_lResponses(0),
                                 m_pSendSocket(NULL),
                                 m_pRecvSocket(NULL),
                                 m_pIOCP(NULL)
{
    CRegKey reg;

    QueryPerformanceFrequency(&s_liCounterFreq);

    if(reg.Open(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\ISPChecker Client")) != ERROR_SUCCESS)
    {
        reg.Create(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\ISPChecker Client"));

        CoCreateGuid(&m_ClientID);

        reg.SetGUIDValue(_T("ClientID"), m_ClientID);
    }
    else
    {
        reg.QueryGUIDValue(_T("ClientID"), m_ClientID);
    }
}

CClientImpl::~CClientImpl(void)
{
    if(m_hDoneEvent != NULL)
        CloseHandle(m_hDoneEvent);

    if(m_pSendSocket != NULL)
    {
        m_pSendSocket->Close();
    }

    if(m_pRecvSocket != NULL)
    {
        m_pRecvSocket->Close();
    }

    if(m_pIOCP != NULL)
    {
        m_pIOCP->Shutdown();
    }

    SAFE_RELEASE(m_pSendSocket);
    SAFE_RELEASE(m_pRecvSocket);
    SAFE_RELEASE(m_pIOCP);

    WSACleanup();
}

HRESULT CClientImpl::Init()
{
    HRESULT             hr;
    WSADATA             wsaData;
    CHAR                szHostName[MAX_PATH];
    hostent*            pHostEntry;
    sockaddr_in         sendAddr;
    sockaddr_in         recvAddr;

    // create event if necessary
    if(m_hDoneEvent == NULL)
    {
        m_hDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(m_hDoneEvent == NULL)
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            goto Cleanup;
        }
    }
    else
    {
        if(!ResetEvent(m_hDoneEvent))
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            goto Cleanup;
        }
    }

    // initialize winsock
    hr = WSAStartup(WINSOCK_VERSION, &wsaData);
    if(hr != 0)
    {
        hr = HRESULT_FROM_WIN32(hr);
        goto Cleanup;
    }

    hr = gethostname(szHostName, sizeof(szHostName));
    if(hr != S_OK)
    {
        hr = HRESULT_FROM_WIN32(hr);
        goto Cleanup;
    }

    pHostEntry = gethostbyname(szHostName);
    if(pHostEntry == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if(pHostEntry->h_addr_list[0] == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Now create the IO completion port and the sockets (only one if there's just one IP)
    //

	hr = CCompletionPort::CreateInstance(0, 0, THREAD_PRIORITY_NORMAL, &m_pIOCP);
	if(FAILED(hr))
	{
		goto Cleanup;
	}

    //
    //  Initialize the send socket
    //

	hr = CClientSocket::CreateInstance(&m_pSendSocket, m_pIOCP, m_pIOCP);
	if(FAILED(hr))
	{
		goto Cleanup;
	}

    sendAddr.sin_family = AF_INET;
    sendAddr.sin_addr.S_un.S_addr = *(PULONG)(pHostEntry->h_addr_list[0]);
    sendAddr.sin_port = 0;
    memset(&(sendAddr.sin_zero), 0, sizeof(sendAddr.sin_zero));

	hr = m_pSendSocket->Init(IPPROTO_UDP, &sendAddr, FALSE);

	if(FAILED(hr))
	{
		goto Cleanup;
	}

    //
    //  Initialize the receive socket
    //

	hr = CClientSocket::CreateInstance(&m_pRecvSocket, m_pIOCP, m_pIOCP);
	if(FAILED(hr))
	{
		goto Cleanup;
	}

    recvAddr.sin_family = AF_INET;
    recvAddr.sin_addr.S_un.S_addr = *(PULONG)(pHostEntry->h_addr_list[0]);
    recvAddr.sin_port = 0;
    memset(&(recvAddr.sin_zero), 0, sizeof(recvAddr.sin_zero));

	hr = m_pRecvSocket->Init(IPPROTO_UDP, &recvAddr, FALSE, &recvAddr);

	if(FAILED(hr))
		goto Cleanup;

Cleanup:

    return hr;
}


STDMETHODIMP CClientImpl::get_Address(BSTR* pVal)
{
    *pVal = m_cszAddress.AllocSysString();

    return S_OK;
}

STDMETHODIMP CClientImpl::put_Address(BSTR newVal)
{
    m_cszAddress = newVal;

    return S_OK;
}

STDMETHODIMP CClientImpl::get_Port(USHORT* pVal)
{
    *pVal = m_nPort;

    return S_OK;
}

STDMETHODIMP CClientImpl::put_Port(USHORT newVal)
{
    m_nPort = newVal;

    return S_OK;
}

STDMETHODIMP CClientImpl::get_Timeout(LONG* pVal)
{
    *pVal = m_lTimeout;

    return S_OK;
}

STDMETHODIMP CClientImpl::put_Timeout(LONG newVal)
{
    m_lTimeout = newVal;

    return S_OK;
}

STDMETHODIMP CClientImpl::get_ClientUID(BSTR* pVal)
{
    HRESULT hr;
    WCHAR   szGUID[64];

    if(StringFromGUID2(m_ClientID, szGUID, 64) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pVal = SysAllocString(szGUID);
    if(*pVal == NULL)
        hr = E_OUTOFMEMORY;
    else
        hr = S_OK;

Cleanup:

    return hr;
}

STDMETHODIMP CClientImpl::get_DHCP(VARIANT_BOOL* pVal)
{
    *pVal = VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CClientImpl::get_USBModem(VARIANT_BOOL* pVal)
{
    *pVal = VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CClientImpl::get_ProxySettings(BSTR* pVal)
{
    HRESULT                 hr;
    HINTERNET               hInet;
    INTERNET_PROXY_INFO*    pProxyInfo = NULL;
    DWORD                   dwBufLen;
    CStringW                cszProxySettings;

    USES_CONVERSION;

    //
    //  Get the proxy info
    //

    InternetQueryOption(NULL, INTERNET_OPTION_PROXY, NULL, &dwBufLen);

    pProxyInfo = (INTERNET_PROXY_INFO*)malloc(dwBufLen);
    if(pProxyInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if(!InternetQueryOption(NULL, INTERNET_OPTION_PROXY, pProxyInfo, &dwBufLen))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  Format the proxy info into XML
    //

    if(pProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
    {
        m_cszResults.Format(L"<PROXYSETTINGS ACCESSTYPE=\"%s\"/>",
            pProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_DIRECT ? L"DIRECT" : L"PROXY");
    }
    else
    {
        m_cszResults.Format(L"<PROXYSETTINGS ACCESSTYPE=\"%s\" SERVER=\"%s\" BYPASS=\"%s\"/>",
            pProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_DIRECT ? L"DIRECT" : L"PROXY",
            A2W((LPSTR)(pProxyInfo->lpszProxy)),
            A2W((LPSTR)(pProxyInfo->lpszProxyBypass)));
    }

    //
    //  Allocate output string
    //

    *pVal = SysAllocString(m_cszResults);
    if(*pVal == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = S_OK;

Cleanup:

    if(pProxyInfo != NULL)
        free(pProxyInfo);

    m_cszResults.Empty();

    return hr;
}

HRESULT CClientImpl::DoNATTest(
    BSTR*   pResults
    )
{
    HRESULT             hr;
    CLIENT_PACKET       ClientPacket;
    sockaddr_in         sendAddr;
    sockaddr_in         recvAddr;
    sockaddr_in         serverAddr;
    LPBYTE              pBuffer;
    LARGE_INTEGER       liTickCount;
    PSOCKET_CALLBACK    pSocketCallback;

    m_lResponses = 0;

    if(pResults == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pResults = NULL;

    //
    // destination address
    //

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.S_un.S_addr = inet_addr(m_cszAddress);
    serverAddr.sin_port = m_nPort;
    memset(&(serverAddr.sin_zero), 0, sizeof(serverAddr.sin_zero));

    //
    //  Allocate receive buffers and set both sockets to listening
    //

    pBuffer = (LPBYTE)malloc(256);
    if(pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pSocketCallback = (PSOCKET_CALLBACK)malloc(sizeof(SOCKET_CALLBACK));
    pSocketCallback->pSocket = m_pSendSocket;
    QueryPerformanceCounter(&(pSocketCallback->liStartTickCount));

    hr = m_pSendSocket->ReceiveFrom(pBuffer, 256, this, MAKEQWORD((DWORD)pSocketCallback, 0));
    if(FAILED(hr))
        goto Cleanup;

    pBuffer = (LPBYTE)malloc(256);
    if(pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pSocketCallback = (PSOCKET_CALLBACK)malloc(sizeof(SOCKET_CALLBACK));
    pSocketCallback->pSocket = m_pRecvSocket;
    QueryPerformanceCounter(&(pSocketCallback->liStartTickCount));

    hr = m_pRecvSocket->ReceiveFrom(pBuffer, 256, this, MAKEQWORD((DWORD)pSocketCallback, 0));
    if(FAILED(hr))
        goto Cleanup;

    // send packet to server and wait for completion or timeout, doesn't matter
    m_pRecvSocket->GetLocalAddress(&recvAddr);
    ClientPacket.nAltPort = recvAddr.sin_port;
    hr = m_pSendSocket->SendTo((LPBYTE)&ClientPacket, sizeof(CLIENT_PACKET), &serverAddr, this, 0);
    if(FAILED(hr))
        goto Cleanup;

    m_pSendSocket->GetLocalAddress(&sendAddr);

    // initialize results string
    m_cszResults.Format(L"<NATTEST><REQUEST CLIENTADDR=\"%u.%u.%u.%u\" CLIENTPORT=\"%u\" SERVERADDR=\"%u.%u.%u.%u\" SERVERPORT=\"%u\"/>",
        sendAddr.sin_addr.S_un.S_un_b.s_b1,
        sendAddr.sin_addr.S_un.S_un_b.s_b2,
        sendAddr.sin_addr.S_un.S_un_b.s_b3,
        sendAddr.sin_addr.S_un.S_un_b.s_b4,
        sendAddr.sin_port,
        serverAddr.sin_addr.S_un.S_un_b.s_b1,
        serverAddr.sin_addr.S_un.S_un_b.s_b2,
        serverAddr.sin_addr.S_un.S_un_b.s_b3,
        serverAddr.sin_addr.S_un.S_un_b.s_b4,
        serverAddr.sin_port);

    WaitForSingleObject(m_hDoneEvent, m_lTimeout * 1000);

    m_cszResults += L"</NATTEST>";

    OutputDebugStringW(m_cszResults);

    *pResults = m_cszResults.AllocSysString();
    if(*pResults == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    m_cszResults.Empty();

    return hr;
}

HRESULT CClientImpl::DoICMPTest(
    BSTR*   pResults
    )
{
    HRESULT             hr;

    *pResults = SysAllocString(L"");
    if(*pResults == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    
    return S_OK;
}


// CClientSocketCallback methods

HRESULT CClientImpl::OnSocketConnect(
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CClientImpl::OnSocketAccept(
                    CClientSocket *pListenSocket,
                    CClientSocket *pAcceptedSocket,
                    sockaddr_in *pLocalAddr,
                    sockaddr_in *pRemoteAddr,
                    HRESULT hrCallback,
                    QWORD qwCallbackArg )
{
    return E_NOTIMPL;
}

HRESULT CClientImpl::OnSocketSend(
                    BYTE *pbBufferSent,
                    DWORD cbToSend,
                    DWORD cbSent,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CClientImpl::OnSocketSendTo(
                    BYTE *pbBufferSent,
                    DWORD cbToSend,
                    DWORD cbSent,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CClientImpl::OnSocketReceive(
                    BYTE *pbFilledInBuffer,
                    DWORD cbRead,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CClientImpl::OnSocketReceiveFrom(
                    BYTE *pbFilledInBuffer,
                    DWORD cbRead,
                    sockaddr_in *pFilledInFrom,
                    HRESULT hrRecv,
                    QWORD qwCallbackArg )
{
    HRESULT                 hr;
    LPBYTE                  pBuffer;
    sockaddr_in             altAddr = *pFilledInFrom;
    sockaddr_in             clientAddr;
    int                     i;
    PSOCKET_CALLBACK        pSocketCallback = (PSOCKET_CALLBACK)LODWORD(qwCallbackArg);
    LARGE_INTEGER           liEndTickCount;
    DWORD                   dwLatency;
    DWORD                   cbProcessed;

    QueryPerformanceCounter(&liEndTickCount);
    dwLatency = (DWORD)(((liEndTickCount.QuadPart - pSocketCallback->liStartTickCount.QuadPart) * 1000)/s_liCounterFreq.QuadPart);

    CHAR szOutput[256];
    sprintf(szOutput, "start = %I64u, end = %I64u, freq = %I64u, latency = %u\r\n",
        pSocketCallback->liStartTickCount.QuadPart,
        liEndTickCount.QuadPart,
        s_liCounterFreq.QuadPart,
        dwLatency);
    OutputDebugStringA(szOutput);

    //
    //  Immediately submit another buffer for receiving.
    //

    pBuffer = (LPBYTE)malloc(256);
    if(pBuffer != NULL)
    {
        pSocketCallback->pSocket->ReceiveFrom(pBuffer, 256, this, qwCallbackArg);
    }

    //
    //  Process the buffer we received
    //

    if(hrRecv != 0)
    {
        // TODO handle returned socket error
        /*
        m_cszResults.AppendFormat(
            L"<RESPONSE ERROR=\"0x%08X\"/>",
            hrRecv);
        */
        SetEvent(m_hDoneEvent);
        hr = hrRecv;
        goto Cleanup;
    }

    pSocketCallback->pSocket->GetLocalAddress(&clientAddr);

    cbProcessed = 0;
    while(cbProcessed < cbRead)
    {
        PSERVER_PACKET pPacket = (PSERVER_PACKET)(pbFilledInBuffer + cbProcessed);

        m_cszResults.AppendFormat(
            L"<RESPONSE CLIENTADDRACTUAL=\"%u.%u.%u.%u\" "
                      L"CLIENTPORTACTUAL=\"%u\" "
                      L"CLIENTADDRSEEN=\"%u.%u.%u.%u\" "
                      L"CLIENTPORTSEEN=\"%u\" "
                      L"SERVERADDR=\"%u.%u.%u.%u\" "
                      L"SERVERPORT=\"%u\" "
                      L"LATENCY=\"%u\"/>",
            clientAddr.sin_addr.S_un.S_un_b.s_b1,
            clientAddr.sin_addr.S_un.S_un_b.s_b2,
            clientAddr.sin_addr.S_un.S_un_b.s_b3,
            clientAddr.sin_addr.S_un.S_un_b.s_b4,
            clientAddr.sin_port,
            pPacket->inaClientAddr.S_un.S_un_b.s_b1,
            pPacket->inaClientAddr.S_un.S_un_b.s_b2,
            pPacket->inaClientAddr.S_un.S_un_b.s_b3,
            pPacket->inaClientAddr.S_un.S_un_b.s_b4,
            pPacket->nClientPort,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b1,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b2,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b3,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b4,
            pFilledInFrom->sin_port,
            dwLatency);

        cbProcessed += sizeof(SERVER_PACKET);
    }

    if(InterlockedIncrement(&m_lResponses) == 24)
        SetEvent(m_hDoneEvent);

    //
    //  Free the buffer
    //

    free(pbFilledInBuffer);

    hr = S_OK;

Cleanup:

	return hr;
}

HRESULT CClientImpl::OnSocketClose(
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\cconncheckclient.h ===
// CConnCheckClient.h : Declaration of the CCConnCheckClient
#pragma once
#include "resource.h"       // main symbols
#include <atlctl.h>
#include "cchkcli.h"
#include "atlcomcli.h"
#include "nattestimpl.h"
#include "icmptestimpl.h"

// CCConnCheckClient
class ATL_NO_VTABLE CCConnCheckClient : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ICConnCheckClient, &IID_ICConnCheckClient, &LIBID_cchkcliLib, /*wMajor =*/ 1, /*wMinor =*/ 0>,
	public IPersistStreamInitImpl<CCConnCheckClient>,
	public IOleControlImpl<CCConnCheckClient>,
	public IOleObjectImpl<CCConnCheckClient>,
	public IOleInPlaceActiveObjectImpl<CCConnCheckClient>,
	public IViewObjectExImpl<CCConnCheckClient>,
	public IOleInPlaceObjectWindowlessImpl<CCConnCheckClient>,
	public CComCoClass<CCConnCheckClient, &CLSID_CConnCheckClient>,
	public CComControl<CCConnCheckClient>
{
private:
    CNATTestImpl    m_NATTestImpl;
    CICMPTestImpl   m_ICMPTestImpl;
    bool            m_bInitialized;

public:

    CCConnCheckClient()
	{
        m_bInitialized = (m_NATTestImpl.Init() == S_OK) && (m_ICMPTestImpl.Init() == S_OK);
	}

DECLARE_OLEMISC_STATUS(OLEMISC_RECOMPOSEONRESIZE | 
	OLEMISC_INVISIBLEATRUNTIME |
	OLEMISC_CANTLINKINSIDE | 
	OLEMISC_INSIDEOUT | 
	OLEMISC_ACTIVATEWHENVISIBLE | 
	OLEMISC_SETCLIENTSITEFIRST
)

DECLARE_REGISTRY_RESOURCEID(IDR_CCONNCHECKCLIENT)

DECLARE_NOT_AGGREGATABLE(CCConnCheckClient)

BEGIN_CATEGORY_MAP(CCConnCheckClient)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

BEGIN_COM_MAP(CCConnCheckClient)
	COM_INTERFACE_ENTRY(ICConnCheckClient)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CCConnCheckClient)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()


BEGIN_MSG_MAP(CCConnCheckClient)
	CHAIN_MSG_MAP(CComControl<CCConnCheckClient>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

// ICConnCheckClient
public:
		HRESULT OnDrawAdvanced(ATL_DRAWINFO& di)
		{
		RECT& rc = *(RECT*)di.prcBounds;
		// Set Clip region to the rectangle specified by di.prcBounds
		HRGN hRgnOld = NULL;
		if (GetClipRgn(di.hdcDraw, hRgnOld) != 1)
			hRgnOld = NULL;
		bool bSelectOldRgn = false;

		HRGN hRgnNew = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);

		if (hRgnNew != NULL)
		{
			bSelectOldRgn = (SelectClipRgn(di.hdcDraw, hRgnNew) != ERROR);
		}

		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
		SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL 7.0 : CConnCheckClient");
		TextOut(di.hdcDraw, 
			(rc.left + rc.right) / 2, 
			(rc.top + rc.bottom) / 2, 
			pszText, 
			lstrlen(pszText));

		if (bSelectOldRgn)
			SelectClipRgn(di.hdcDraw, hRgnOld);

		return S_OK;
	}


	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

public:

    STDMETHOD(get_Address)(BSTR* pVal);
    STDMETHOD(put_Address)(BSTR newVal);
    STDMETHOD(get_Port)(USHORT* pVal);
    STDMETHOD(put_Port)(USHORT newVal);
    STDMETHOD(get_Timeout)(LONG* pVal);
    STDMETHOD(put_Timeout)(LONG newVal);
    STDMETHOD(get_MaxHops)(LONG* pVal);
    STDMETHOD(put_MaxHops)(LONG newVal);
    STDMETHOD(get_ClientUID)(BSTR* pVal);
    STDMETHOD(get_DHCP)(VARIANT_BOOL* pVal);
    STDMETHOD(get_USBModem)(VARIANT_BOOL* pVal);
    STDMETHOD(get_ProxySettings)(BSTR* pVal);
    STDMETHOD(get_UPnPNAT)(BSTR* pVal);

    STDMETHOD(DoNATTest)(BSTR* pVal);
    STDMETHOD(DoICMPTest)(BSTR* pVal);

};

OBJECT_ENTRY_AUTO(__uuidof(CConnCheckClient), CCConnCheckClient)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\clisock.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"
#include "mswsock.h"

static CClientSocketConnectWatchdog g_SocketConnectWatchdog;

//////////////////////////////////////////////////////////////////////////////
#define ACCEPT_ADDRESS_LEN          ( 16 + sizeof(sockaddr_in) )
#define ACCEPT_ADDRESS_BUFFER_SIZE  ( 2 * ACCEPT_ADDRESS_LEN )

//////////////////////////////////////////////////////////////////////////////
HRESULT __stdcall CClientSocket::CreateInstance( 
                            CClientSocket **ppSocket, 
                            CCompletionPort *pIOCP, 
                            CCompletionPort *pAcceptIOCP, 
                            SOCKET s )
{
    //
    // Validate arguments
    //
    if( NULL == ppSocket )
    {
        return( E_INVALIDARG );
    }

    HRESULT hr;
    
    do
    {
        *ppSocket = new CClientSocket;

        if( NULL == *ppSocket )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = (*ppSocket)->InternalInit( pIOCP, pAcceptIOCP, s );

        if( FAILED( hr ) )
        {
            break;
        }
    
        hr = S_OK;
    }
    while( FALSE );

    if( FAILED( hr ) )
    {
        SAFE_RELEASE( *ppSocket );
    }
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
CClientSocket::CClientSocket() :
    m_cRef( 1 ),
    m_Socket( INVALID_SOCKET ),
    m_protocol( IPPROTO_MAX ),
    m_fBlockingIO( FALSE ),
    m_fHavePeerAddr( FALSE ),
    m_pIOCP( NULL ),
    m_pAcceptIOCP( NULL )
{
}


//////////////////////////////////////////////////////////////////////////////
CClientSocket::~CClientSocket()
{
    Close();

    SAFE_RELEASE( m_pIOCP );
    SAFE_RELEASE( m_pAcceptIOCP );
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::InternalInit(
                        CCompletionPort *pIOCP, 
                        CCompletionPort *pAcceptIOCP, 
                        SOCKET s )
{
    m_pIOCP = pIOCP;
    
    if( NULL == m_pIOCP )
    {
        return( E_INVALIDARG );
    }

    SAFE_ADDREF( m_pIOCP );

    m_pAcceptIOCP = pAcceptIOCP;
    SAFE_ADDREF( m_pAcceptIOCP );

    m_Socket = s;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::Init( 
                int protocol,
                const sockaddr_in *pAddress,
                BOOL fReuseAddr,
                sockaddr_in *pAddressUsed )
{
    //
    // Validate arguments
    //
    if( NULL == pAddress )
    {
        return( E_INVALIDARG );
    }

    if( pAddress->sin_family != AF_INET )
    {
        return( E_INVALIDARG );
    }

    if( ( IPPROTO_TCP != protocol ) && ( IPPROTO_UDP != protocol ) && ( IPPROTO_ICMP != protocol ) )
    {
        return( E_INVALIDARG );
    }

    HRESULT hr;
    
    do
    {
        //
        // If we had already been inited before, close the socket first
        //
        if( INVALID_SOCKET != m_Socket )
        {
            hr = Close();

            if( FAILED( hr ) )
            {
                break;
            }
        }

        //
        // Allocate a new overlapped IO socket
        //
        int socketType = ( IPPROTO_TCP == protocol ) ? SOCK_STREAM : 
                         ( IPPROTO_ICMP == protocol ) ? SOCK_RAW : SOCK_DGRAM;

        m_Socket = WSASocket(
                        pAddress->sin_family,
                        socketType,
                        protocol,
                        NULL,
                        0,
                        WSA_FLAG_OVERLAPPED );

        if( INVALID_SOCKET == m_Socket )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError( ) );
            break;
        }

        //
        // Configure the socket for proper address reuse
        //
        int rc = setsockopt(
                    m_Socket,
                    SOL_SOCKET,
                    SO_REUSEADDR,
                    (char *) &fReuseAddr,
                    sizeof(BOOL) );

        if( SOCKET_ERROR == rc )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError( ) );        
            break;
        }

        //
        // Bind the socket to a local address
        //
        rc = bind( m_Socket, (sockaddr *) pAddress, sizeof(sockaddr_in) );

        if( SOCKET_ERROR == rc )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError( ) );        
            break;
        }

        //
        // Get the address that we are bound to and optionally return to
        // the caller.
        //
        int addrLen = sizeof(sockaddr_in);

        rc = getsockname( m_Socket, (sockaddr *) &m_saddrLocal, &addrLen );

        if( SOCKET_ERROR == rc )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError( ) );        
            break;
        }

        if( NULL != pAddressUsed )
        {
            memcpy( pAddressUsed, &m_saddrLocal, sizeof(sockaddr_in) );
        }

        //
        // Handle common init code for regular and accepted sockets.
        //
        hr = FinishInit( protocol );

        if( FAILED( hr ) )
        {
            break;
        }

        hr = S_OK;
    }
    while( FALSE );

    //
    // Clean up
    //
    if( FAILED( hr ) )
    {
        closesocket( m_Socket );
        m_Socket = INVALID_SOCKET;
    }
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::FinishInit( int protocol )
{
    HRESULT hr;
    
    do
    {
        m_protocol = protocol;

        //
        // Set the proper blocking status for this socket (non-blocking
        // is the default)
        //
        u_long arg = m_fBlockingIO ? 0 : 1;

        int rc = ioctlsocket( m_Socket, FIONBIO, &arg );

        if( SOCKET_ERROR == rc )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError( ) );        
            break;
        }

        //
        // Attach this socket to the designated I/O completion port
        //
        hr = m_pIOCP->Attach( (HANDLE) m_Socket );

        if( FAILED( hr ) )
        {
            break;
        }

        hr = S_OK;
    }
    while( FALSE );
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::GetLocalAddress( sockaddr_in *pLocalAddress )
{
    //
    // Validate arguments
    //
    if( NULL == pLocalAddress )
    {
        return( E_INVALIDARG );
    }

    if( INVALID_SOCKET == m_Socket )
    {
        return( E_HANDLE );
    }

    memcpy( pLocalAddress, &m_saddrLocal, sizeof(sockaddr_in) );

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::GetPeerAddress( sockaddr_in *pPeerAddress )
{
    if( INVALID_SOCKET == m_Socket )
    {
        return( E_HANDLE );
    }

    if( !m_fHavePeerAddr )
    {
        int addrLen = sizeof(sockaddr_in);

        int rc = getpeername( m_Socket, (sockaddr *) &m_saddrPeer, &addrLen );

        if( SOCKET_ERROR == rc )
        {
            return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
        }

        m_fHavePeerAddr = TRUE;
    }

    memcpy( pPeerAddress, &m_saddrPeer, sizeof(sockaddr_in) );

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::Connect( 
                            const sockaddr_in *pAddr,
                            CClientSocketCallback *pCallback,
                            QWORD qwCallbackArg )
{
    HRESULT hr = S_OK;
    
    CSocketIoContext* pContext = NULL;

    int iErr;

    //
    // Validate arguments
    //
    
    if(NULL == pAddr)
    {
        return E_INVALIDARG;
    }

    if(NULL == pCallback)
    {
        return E_INVALIDARG;
    }

    if( IPPROTO_TCP != m_protocol )
    {
        //
        // Actually we can, but it's not supported right now
        //

        return( E_INVALIDARG );
    }
    
    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    //
    // Register this socket in the connect watchdog list. 
    //

    pContext = new CSocketIoContext;

    if(NULL == pContext)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    pContext->Init(this, CSocketIoContext::IoConnect, NULL, 0, m_Socket, pCallback, qwCallbackArg);
    
    hr = g_SocketConnectWatchdog.AddConnectingSocket(pContext);

    if(FAILED(hr))
    {
        goto lDone;
    }

    //
    // Start connect operation
    //

    iErr = connect(m_Socket, (sockaddr*) pAddr, sizeof(sockaddr_in));

    if(SOCKET_ERROR != iErr)
    {
        hr = E_FAIL;
        goto lDone;
    }

    iErr = WSAGetLastError();

    if(WSAEWOULDBLOCK != iErr)
    {   
        hr = HRESULT_FROM_WIN32(iErr);

        goto lDone;
    }

lDone:

    if(FAILED(hr))
    {
        if(pContext)
        {
            //
            // We failed. No notifications are required. Remove context object
            // from the watchdog list.
            //

            g_SocketConnectWatchdog.Remove(pContext);
        }
    }

    SAFE_RELEASE(pContext);
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::Listen( DWORD dwConnectionBacklog )
{
    //
    // Don't need to check incoming parameters, listen() will do it for us
    // 
    if( SOCKET_ERROR == listen( m_Socket, dwConnectionBacklog ) )
    {
        return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::Accept(
                            CClientSocketCallback *pCallback,
                            QWORD qwCallbackArg )
{
    //
    // Validate arguments
    //
    if( NULL == pCallback )
    {
        return( E_INVALIDARG );
    }

    if( IPPROTO_TCP != m_protocol )
    {
        return( E_INVALIDARG );
    }

    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    HRESULT hr;
    SOCKET sockAccept = INVALID_SOCKET;
    BYTE *pbAcceptBuffer = NULL;
    CSocketIoContext *pCtx = NULL;
    
    do
    {
        //
        // Pool allocate an accept buffer
        //
        pbAcceptBuffer = new BYTE[ACCEPT_ADDRESS_BUFFER_SIZE];
        if( pbAcceptBuffer == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        
        //
        // Create a new overlapped I/O TCP socket
        //
        sockAccept = WSASocket(
                            AF_INET,
                            SOCK_STREAM,
                            IPPROTO_TCP,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED );

        if( INVALID_SOCKET == sockAccept ) 
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            break;
        }

        //
        // Initialize a new I/O context struct
        //
        pCtx = new CSocketIoContext;

        if( NULL == pCtx )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pCtx->Init(
                this,
                CSocketIoContext::IoAccept,
                pbAcceptBuffer,
                0,
                sockAccept,
                pCallback,
                qwCallbackArg );
    
        //
        // Attempt to queue an async accept
        //
        DWORD cbReceived;

        BOOL fSync = AcceptEx(
                        m_Socket,
                        sockAccept,
                        pbAcceptBuffer,
                        0,
                        ACCEPT_ADDRESS_LEN,
                        ACCEPT_ADDRESS_LEN,
                        &cbReceived,
                        pCtx );

        if( fSync )
        {
            hr = E_FAIL;
            break;
        }

        DWORD dwError = WSAGetLastError();

        if( ERROR_IO_PENDING != dwError )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            break;
        }

        hr = S_OK;
    }
    while( FALSE );

    //
    // Clean up on failure
    //
    if( FAILED( hr ) )
    {
        closesocket( sockAccept );

        if (pbAcceptBuffer != NULL)
        {
            delete [] pbAcceptBuffer;
        }

        SAFE_RELEASE( pCtx );
    }
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::Send(
                            BYTE *pbBuffer,
                            DWORD cbToSend, 
                            CClientSocketCallback *pCallback,
                            QWORD qwCallbackArg )
{
    //
    // Validate arguments
    //
    if( ( NULL == pbBuffer ) || ( NULL == pCallback ) )
    {
        return( E_INVALIDARG );
    }

    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    HRESULT hr;
    CSocketIoContext *pCtx = NULL;
    
    do
    {
        //
        // Initialize a new I/O context struct
        //
        pCtx = new CSocketIoContext;

        if( NULL == pCtx )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pCtx->Init(
                this,
                CSocketIoContext::IoSend,
                pbBuffer,
                cbToSend,
                m_Socket,
                pCallback,
                qwCallbackArg );

        //
        // Send the data asynchronously
        //
        WSABUF wsa;

        wsa.len = cbToSend;
        wsa.buf = (char *) pbBuffer;

        DWORD cbSent = 0;

        int rc = WSASend( m_Socket, &wsa, 1, &cbSent, 0, pCtx, NULL );

        hr = HandleWSAReturnValue( CSocketIoContext::IoSend, rc );

        if( FAILED( hr ) )
        {
            break;
        }
    
        hr = S_OK;
    }
    while( FALSE );

    //
    // Clean up on failure
    //
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCtx );
    }
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::SendEx(
                            WSABUF *rgBuffers,
                            DWORD cBuffers, 
                            CClientSocketCallback *pCallback,
                            QWORD qwCallbackArg )
{
    //
    // Validate arguments
    //
    if( ( NULL == rgBuffers ) || ( NULL == pCallback ) || (cBuffers == 0) )
    {
        return( E_INVALIDARG );
    }

    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    HRESULT hr;
    CSocketIoContext *pCtx = NULL;
    
    do
    {
        //
        // Initialize a new I/O context struct
        //
        pCtx = new CSocketIoContext;

        if( NULL == pCtx )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pCtx->Init(
                this,
                CSocketIoContext::IoSend,
                (BYTE *) rgBuffers,
                cBuffers,
                m_Socket,
                pCallback,
                qwCallbackArg );

        //
        // Send the data asynchronously
        //
        DWORD cbSent = 0;

        int rc = WSASend( m_Socket, rgBuffers, cBuffers, &cbSent, 0, pCtx, NULL );

        hr = HandleWSAReturnValue( CSocketIoContext::IoSend, rc );

        if( FAILED( hr ) )
        {
            break;
        }
    
        hr = S_OK;
    }
    while( FALSE );

    //
    // Clean up on failure
    //
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCtx );
    }
    
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::SendTo( 
                            BYTE *pbBuffer,
                            DWORD cbToSend, 
                            const sockaddr_in *pSendToAddr,
                            CClientSocketCallback *pCallback,
                            QWORD qwCallbackArg )
{
    //
    // Validate arguments
    //
    if( ( NULL == pbBuffer ) || ( NULL == pCallback ) )
    {
        return( E_INVALIDARG );
    }

    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    if( IPPROTO_UDP != m_protocol )
    {
        return( E_NOTIMPL );
    }

    HRESULT hr;
    CSocketIoContext *pCtx = NULL;
    
    do
    {
        //
        // Initialize a new I/O context struct
        //
        pCtx = new CSocketIoContext;

        if( NULL == pCtx )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pCtx->Init(
                this,
                CSocketIoContext::IoSendTo,
                pbBuffer,
                cbToSend,
                m_Socket,
                pCallback,
                qwCallbackArg );

        //
        // Send the data asynchronously
        //
        WSABUF wsa;

        wsa.len = cbToSend;
        wsa.buf = (char *) pbBuffer;

        DWORD cbSent = 0;

        int rc = WSASendTo(
                        m_Socket,
                        &wsa,
                        1,
                        &cbSent,
                        0,
                        (sockaddr *) pSendToAddr,
                        sizeof(sockaddr_in),
                        pCtx,
                        NULL );

        hr = HandleWSAReturnValue( CSocketIoContext::IoSend, rc );

        if( FAILED( hr ) )
        {
            break;
        }
    
        hr = S_OK;
    }
    while( FALSE );

    //
    // Clean up on failure
    //
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCtx );
    }
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::Receive( 
                            BYTE *pbBuffer,
                            DWORD cbBuffer,
                            CClientSocketCallback *pCallback,
                            QWORD qwCallbackArg )
{
    //
    // Validate arguments
    //
    if( ( NULL == pbBuffer ) || ( NULL == pCallback ) )
    {
        return( E_INVALIDARG );
    }

    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    HRESULT hr;
    CSocketIoContext *pCtx = NULL;
    
    do
    {
        //
        // Initialize a new I/O context struct
        //
        pCtx = new CSocketIoContext;

        if( NULL == pCtx )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pCtx->Init(
                this,
                CSocketIoContext::IoReceive,
                pbBuffer,
                cbBuffer,
                m_Socket,
                pCallback,
                qwCallbackArg );

        //
        // Receive the data asynchronously
        //
        WSABUF wsa;

        wsa.len = cbBuffer;
        wsa.buf = (char *) pbBuffer;

        DWORD dwFlags = 0;
        DWORD cbReceived = 0;

        int rc = WSARecv(
                        m_Socket,
                        &wsa,
                        1,
                        &cbReceived,
                        &dwFlags,
                        pCtx,
                        NULL );

        hr = HandleWSAReturnValue( CSocketIoContext::IoSend, rc );

        if( FAILED( hr ) )
        {
            break;
        }
    
        hr = S_OK;
    }
    while( FALSE );

    //
    // Clean up on failure
    //
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCtx );
    }
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::ReceiveFrom( 
                            BYTE *pbBuffer,
                            DWORD cbBuffer,
                            CClientSocketCallback *pCallback,
                            QWORD qwCallbackArg )
{
    //
    // Validate arguments
    //
    if( ( NULL == pbBuffer ) || ( NULL == pCallback ) )
    {
        return( E_INVALIDARG );
    }

    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    HRESULT hr;
    CSocketIoContext *pCtx = NULL;
    
    do
    {
        //
        // Initialize a new I/O context struct
        //
        pCtx = new CSocketIoContext;

        if( NULL == pCtx )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pCtx->Init(
                this,
                CSocketIoContext::IoReceiveFrom,
                pbBuffer,
                cbBuffer,
                m_Socket,
                pCallback,
                qwCallbackArg );

        //
        // Receive the data asynchronously
        //
        WSABUF wsa;

        wsa.len = cbBuffer;
        wsa.buf = (char *) pbBuffer;

        DWORD dwFlags = 0;
        DWORD cbReceived = 0;

        int rc = WSARecvFrom(
                        m_Socket,
                        &wsa,
                        1,
                        &cbReceived,
                        &dwFlags,
                        (sockaddr*) pCtx->GetAddr(),
                        (int*) pCtx->GetAddrLen(),
                        pCtx,
                        NULL );

        hr = HandleWSAReturnValue( CSocketIoContext::IoSend, rc );

        if( FAILED( hr ) )
        {
            break;
        }
    
        hr = S_OK;
    }
    while( FALSE );

    //
    // Clean up on failure
    //
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCtx );
    }
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::Close()
{
    //
    // Check if we are already closed
    //
    if( INVALID_SOCKET == m_Socket ) 
    {
        return( S_OK );
    }

    shutdown( m_Socket, SD_SEND );
    closesocket( m_Socket );

    m_pIOCP-> Leave( (HANDLE) m_Socket );

    m_Socket = INVALID_SOCKET;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::GetSocket( SOCKET *pSocket )
{
    //
    // Validate arguments
    //
    if( NULL == pSocket )
    {
        return( E_INVALIDARG );
    }

    *pSocket = m_Socket;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::SetBlockingIO( BOOL fBlockingIO )
{
    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }
    
    u_long arg = fBlockingIO ? 0L : 1L;

    int rc = ioctlsocket( m_Socket, FIONBIO, &arg );

    if( SOCKET_ERROR == rc )
    {
        return( E_FAIL );
    }

    m_fBlockingIO = fBlockingIO;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::SetDisableNagle( BOOL fDisable )
{
    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    int rc = setsockopt(
                    m_Socket,
                    IPPROTO_TCP,
                    TCP_NODELAY,
                    (char *) &fDisable,
                    sizeof(BOOL) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::SetReceiveBufferSize( DWORD dwBufferSize )
{
    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    int iBufSize = (int) dwBufferSize;

    int rc = setsockopt(
                    m_Socket,
                    SOL_SOCKET,
                    SO_RCVBUF,
                    (char *) &iBufSize,
                    sizeof(int) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::SetSendBufferSize( DWORD dwBufferSize )
{
    if( INVALID_SOCKET == m_Socket ) 
    {
        return( E_HANDLE );
    }

    int iBufSize = (int) dwBufferSize;

    int rc = setsockopt(
                    m_Socket,
                    SOL_SOCKET,
                    SO_SNDBUF,
                    (char *) &iBufSize,
                    sizeof(int) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::GetMaxMessageSize( DWORD *pdwMaxMessageSize )
{
    //
    // Validate arguments
    //
    if( NULL == pdwMaxMessageSize )
    {
        return( E_INVALIDARG );
    }

    *pdwMaxMessageSize = 0;

    unsigned int uiMsgSize;
    int iParamSize = sizeof(uiMsgSize);

    int rc = getsockopt(
                    m_Socket,
                    SOL_SOCKET,
                    SO_MAX_MSG_SIZE,
                    (char *) &uiMsgSize,
                    &iParamSize );

    if( SOCKET_ERROR == rc )
    {
        return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    *pdwMaxMessageSize = uiMsgSize;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
void CClientSocket::OnIoCompletion( 
                        DWORD dwError, 
                        DWORD cbTransferred, 
                        ULONG_PTR ulpKey,
                        CCompletionContext *pCompCtx )
{
    //
    // Check everything is ok
    //
    if( NULL == pCompCtx )
    {
        return;
    }

    CSocketIoContext *pCtx = (CSocketIoContext *) pCompCtx;

#if DBG
    if( dwError )
    {
    }
#endif

    //
    //  Get the callback
    //
    CClientSocketCallback *pCallback = pCtx->GetCallback();

    if( NULL == pCallback )
    {
        return;
    }

#ifdef ICECAP_BUILD
	StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif

    //
    // Call the corresponding callback. 
    // pCtx keeps a reference to us, so we won't get deleted if the 
    // callback calls Release()
    //
    HRESULT hr;

    switch( pCtx->GetIoType() )
    {
    case CSocketIoContext::IoConnect:

        hr = pCallback->OnSocketConnect(
            pCtx->GetHRESULT(),
            pCtx->GetCallbackArg() );
        break;
    
    case CSocketIoContext::IoAccept:

        hr = CallOnAccept( dwError, cbTransferred, pCtx );
        break;
    
    case CSocketIoContext::IoSend:
      
        hr = pCallback->OnSocketSend(
                            pCtx->GetBuffer(),
                            pCtx->GetBufferSize(),
                            cbTransferred,
                            HRESULT_FROM_WIN32( dwError ),
                            pCtx->GetCallbackArg() );
        break;

    case CSocketIoContext::IoSendTo:

        hr = pCallback->OnSocketSendTo(
                            pCtx->GetBuffer(),
                            pCtx->GetBufferSize(),
                            cbTransferred,
                            HRESULT_FROM_WIN32( dwError ),
                            pCtx->GetCallbackArg() );
        break;

    case CSocketIoContext::IoReceive:

        hr = pCallback->OnSocketReceive(
                            pCtx->GetBuffer(),
                            cbTransferred,
                            HRESULT_FROM_WIN32( dwError ),
                            pCtx->GetCallbackArg() );
        break;

    case CSocketIoContext::IoReceiveFrom:

        hr = pCallback->OnSocketReceiveFrom(
                            pCtx->GetBuffer(),
                            cbTransferred,
                            pCtx->GetAddr(),
                            HRESULT_FROM_WIN32( dwError ),
                            pCtx->GetCallbackArg() );
        break;
    
    default:

        break;
    }

    SAFE_RELEASE( pCtx );

#ifdef ICECAP_BUILD
	StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif

}


/////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::CallOnAccept(
                            DWORD dwError,
                            DWORD cbTransferred,
                            CSocketIoContext *pCtx )
{
    HRESULT hr;
    CClientSocket *pSocket = NULL;
    sockaddr *psaddrLocal = NULL;
    sockaddr *psaddrRemote = NULL;
    int iLocalAddrLen;
    int iRemoteAddrLen;

    do
    {
        //
        // Get out quick on obvious failures
        //
        if( INVALID_SOCKET == pCtx->GetSocket() )
        {
            hr = E_INVALIDARG;
            break;
        }

        if( 0 != dwError )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            break;
        }
        
        //
        // Parse the accept buffer for addresses
        //
        GetAcceptExSockaddrs(
                pCtx->GetBuffer(),
                pCtx->GetBufferSize(),
                ACCEPT_ADDRESS_LEN,
                ACCEPT_ADDRESS_LEN,
                &psaddrLocal,
                &iLocalAddrLen,
                &psaddrRemote,
                &iRemoteAddrLen );
 
        //
        // Be sure to inherit the attributes from the listen socket
        //
        int rc = setsockopt( 
                        pCtx->GetSocket(),     
                        SOL_SOCKET,     
                        SO_UPDATE_ACCEPT_CONTEXT, 
                        (char *) &m_Socket,     
                        sizeof(m_Socket) );

        if( SOCKET_ERROR == rc )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            break;
        }

        //
        // Allocate and initialize a new socket class to represent the
        // new connection
        //
        pSocket = new CClientSocket;
    
        if( NULL == pSocket )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = pSocket->InternalInit( m_pAcceptIOCP, m_pAcceptIOCP, pCtx->GetSocket() );
        
        if( FAILED( hr ) )
        {
            break;
        }

        //
        // Store local and remote address in the newly created socket (since getpeername
        // wouldn't work because it was created with AcceptEx)
        //
        if( NULL != psaddrLocal )
        {
            memcpy( &pSocket->m_saddrLocal, psaddrLocal, sizeof(sockaddr_in) );
        }

        if( NULL != psaddrRemote )
        {
            memcpy( &pSocket->m_saddrPeer, psaddrRemote, sizeof(sockaddr_in) );
            pSocket->m_fHavePeerAddr = TRUE;
        }

        //
        // Hook the socket up to the appropriate completion port, etc.
        //
        hr = pSocket->FinishInit( m_protocol );

        if( FAILED( hr ) )
        {
            break;
        }

        hr = S_OK;
    }
    while( FALSE );

    //
    // we receive this error in case the listen socket is being closed,
    // so we need to close the accept socket as well.
    //
    if( hr == HRESULT_FROM_WIN32( WSA_OPERATION_ABORTED ) )
    {
        shutdown( pCtx->GetSocket(), SD_SEND );
        closesocket( pCtx->GetSocket() );
    }

    //
    // Call the callback in all cases to prevent memory leaks
    // The caller should addref the socket if they want to keep it
    //
    CClientSocketCallback *pCallback = pCtx->GetCallback();

    hr = pCallback->OnSocketAccept(
                            this,
                            pSocket,
                            (sockaddr_in *) psaddrLocal,
                            (sockaddr_in *) psaddrRemote,
                            hr,
                            pCtx->GetCallbackArg() );
    
    if( NULL != pCtx->GetBuffer() )
    {
        HRESULT hr2;

        delete [] pCtx->GetBuffer();
    }

    SAFE_RELEASE( pSocket );

    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocket::HandleWSAReturnValue(
                            CSocketIoContext::IoType Operation, 
                            int iRet )
{
    if( SOCKET_ERROR == iRet )
    {
        int iWSAError = WSAGetLastError();
    
        //
        // WSA_IO_PENDING is not an error, it just means that the I/O operation
        // will complete later.  But the same is also true for WSAEMSGSIZE, if
        // we were calling WSARecv or WSAReceiveFrom.  Don't believe what the NT documentation
        // for WSARecv says.  The IO completion port will be signalled if we get an WSAEMSGSIZE.
        //
        if( ( WSA_IO_PENDING != iWSAError ) && 
            ( ( WSAEMSGSIZE != iWSAError ) || 
              ( CSocketIoContext::IoReceive != Operation && 
                CSocketIoContext::IoReceiveFrom != Operation ) ) )
        {
            HRESULT hr = HRESULT_FROM_WIN32( iWSAError );

            return( hr );
        }

        return( S_OK );
    }    
    else if( 0 == iRet )
    {
        //
        // Synchronous operation, completion already scheduled by the system
        //
        return( S_OK );
    }
    else 
    {
        return( E_FAIL );
    }
}


/////////////////////////////////////////////////////////////////////////////
CClientSocketConnectWatchdog::CClientSocketConnectWatchdog()
{
    InitializeCriticalSection(&m_cs);
    m_hWatchdogThread = NULL;
    m_dwWatchdogThreadId = 0;
    m_bLazyInit = FALSE;
    ZeroMemory(m_rghChangeEvent, sizeof(m_rghChangeEvent));
    m_dwNextList = 0;
}

/////////////////////////////////////////////////////////////////////////////
CClientSocketConnectWatchdog::~CClientSocketConnectWatchdog()
{
    if(m_hWatchdogThread)
    {
        //
        // Shutdown watchdog thread
        //
    
        SetEvent(m_rghChangeEvent[CONNECT_LIST_COUNT]);

        int iRes = WaitForSingleObject(m_hWatchdogThread, 5000);

        CloseHandle(m_hWatchdogThread);
        m_hWatchdogThread = NULL;

    }
    
    DeleteCriticalSection(&m_cs);
    
    //
    // Clean up connecting socket list
    //
    
    for(int nList=0; nList < CONNECT_LIST_COUNT; nList++)
    {
        CSocketIoContext* pSC = NULL;

        while(m_rgSocketList[nList].GetCount() != 0)
        {
            pSC = (CSocketIoContext*)m_rgSocketList[nList].RemoveTail();
            pSC->Release();
        }

        if(m_rghChangeEvent[nList] != NULL)
        {
            CloseHandle(m_rghChangeEvent[nList]);
        }
    }

    if(m_rghChangeEvent[CONNECT_LIST_COUNT] != NULL)
    {
        CloseHandle(m_rghChangeEvent[CONNECT_LIST_COUNT]);
    }
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocketConnectWatchdog::Init()
{
    HRESULT hr = S_OK;
    
    //
    // Initialize notification events and socket lists
    //
    
    for(int nList=0; nList < CONNECT_LIST_COUNT; nList++)
    {
        m_rghChangeEvent[nList] = CreateEvent(NULL, FALSE, FALSE, NULL);

        if(NULL == m_rghChangeEvent[nList])
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            goto lDone;
        }
    }

    //
    // This last event will be the shutdown event
    //

    m_rghChangeEvent[CONNECT_LIST_COUNT] = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(NULL == m_rghChangeEvent[CONNECT_LIST_COUNT])
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        goto lDone;
    }

    //
    // Create the watchdog thread
    //

    m_hWatchdogThread = CreateThread(NULL, 0, ConnectionWatchdogThreadProc, (LPVOID) this, 0, &m_dwWatchdogThreadId);

    if(NULL == m_hWatchdogThread)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        goto lDone;
    }

    m_bLazyInit = TRUE;

lDone:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CClientSocketConnectWatchdog::ConnectionWatchdogThreadProc(
    LPVOID pThisRaw
)
{
    ((CClientSocketConnectWatchdog*) pThisRaw)->ConnectionWatchdog();

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CClientSocketConnectWatchdog::ConnectionWatchdog()
{

    for(;;)
    {
        
        DWORD dwSleep;

        //
        // Sleep until we get connect notifications or until we shutdown
        //
        
        DWORD dwRes = WaitForMultipleObjects(sizeof(m_rghChangeEvent)/sizeof(m_rghChangeEvent[0]), 
            m_rghChangeEvent, FALSE, INFINITE);

        if(dwRes >= WAIT_OBJECT_0 + CONNECT_LIST_COUNT)
        {
            //
            // Shutdown
            //
          
            break;
        }

        Lock();

        //
        // Each event has a corresponding list.
        //
        
        DWORD nList = dwRes - WAIT_OBJECT_0;

        if(m_rgSocketList[nList].IsEmpty())
        {
            Unlock();

            continue;
        }

        CSocketIoContext* pSC = NULL;
        POSITION pos = m_rgSocketList[nList].GetHeadPosition();
        POSITION posN = pos;
        
        for(;;)
        {
            pos = posN;

            if(!(pSC = (CSocketIoContext*)m_rgSocketList[nList].GetNext(posN)))
            {
                break;
            }
            
            //
            // Check if it connected or failed
            //
            
            fd_set writefds;
            FD_ZERO(&writefds);
            FD_SET(pSC->GetSocket(), &writefds);

            fd_set exceptfds;
            FD_ZERO(&exceptfds);
            FD_SET(pSC->GetSocket(), &exceptfds);

            TIMEVAL sTimeout = {0, 0}; 

            int iRes = select(0, NULL, &writefds, &exceptfds, &sTimeout);

            if(iRes > 0)
            {
                if(FD_ISSET(pSC->GetSocket(), &writefds))
                {
                    //
                    // This socket connected successfully
                    //

                    m_rgSocketList[nList].RemoveAt(pos);

                    ((CClientSocket*)pSC->GetHandler())->GetIOCP()->PostCompletion(pSC);
                }
                else
                {
                   
                    //
                    // This socket failed to connect
                    //

                    pSC->SetHRESULT(E_FAIL);
                    m_rgSocketList[nList].RemoveAt(pos);

                    ((CClientSocket*)pSC->GetHandler())->GetIOCP()->PostCompletion(pSC);
                }
            }
        }

        Unlock();
    }
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CClientSocketConnectWatchdog::AddConnectingSocket(
    CSocketIoContext* pContext
)
{
    HRESULT hr = S_OK;

    hr = EnsureInit();

    if(FAILED(hr))
    {
        goto lDone;
    }

    Lock();

    //
    // We want to be notified when this socket finishes connecting.
    //

    int iErr = WSAEventSelect(pContext->GetSocket(), m_rghChangeEvent[m_dwNextList], FD_CONNECT);

    if(SOCKET_ERROR == iErr)
    {    
        hr = HRESULT_FROM_WIN32(iErr);

        Unlock();

        goto lDone;
    }

    //
    // Add context object to one of our lists.
    //

    POSITION pos = m_rgSocketList[m_dwNextList].AddTail((void*) pContext);
    pContext->AddRef();

    //
    // Next list is determined by round robin.
    //
    
    m_dwNextList = (m_dwNextList + 1) % CONNECT_LIST_COUNT;


    Unlock();

lDone:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
void CClientSocketConnectWatchdog::Remove(
    CSocketIoContext* pContext
)
{
    for(DWORD nList=0; nList < CONNECT_LIST_COUNT; nList++)
    {
        CSocketIoContext* pSC = NULL;
        POSITION pos = m_rgSocketList[nList].GetHeadPosition();
        POSITION posN = pos;
        
        while((pos = posN, pSC = (CSocketIoContext*)m_rgSocketList[nList].GetNext(posN)))
        {
            if(pSC == pContext)
            {
                m_rgSocketList[nList].RemoveAt(pos);
                pSC->Release();
                return;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\clisock.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef CLISOCK_H_INCLUDED
#define CLISOCK_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "compport.h"

class CClientSocket;
class CClientSocketConnectWatchdog;

//////////////////////////////////////////////////////////////////////////////
__forceinline
char *GetIPDisplayString( DWORD dwIP )
{
    in_addr a;

    a.S_un.S_addr = htonl( dwIP );

    return( inet_ntoa( a ) );
}


//////////////////////////////////////////////////////////////////////////////
class CClientSocketCallback
{
public:
    virtual ULONG AddRef() = 0;

    virtual ULONG Release() = 0;

    virtual HRESULT OnSocketConnect(
                        HRESULT hr,
                        QWORD qwCallbackArg ) = 0;

    virtual HRESULT OnSocketAccept(
                        CClientSocket *pListenSocket,
                        CClientSocket *pAcceptedSocket,
                        sockaddr_in *pLocalAddr,
                        sockaddr_in *pRemoteAddr,
                        HRESULT hr,
                        QWORD qwCallbackArg ) = 0;

    virtual HRESULT OnSocketSend(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg ) = 0;

    virtual HRESULT OnSocketSendTo(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg ) = 0;

    virtual HRESULT OnSocketReceive(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        HRESULT hr,
                        QWORD qwCallbackArg ) = 0;

    virtual HRESULT OnSocketReceiveFrom(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        sockaddr_in *pFilledInFrom,
                        HRESULT hr,
                        QWORD qwCallbackArg ) = 0;

    virtual HRESULT OnSocketClose(
                        HRESULT hr,
                        QWORD qwCallbackArg ) = 0;
};


//////////////////////////////////////////////////////////////////////////////
//
// I/O completion context for sockets
//
class CSocketIoContext : public CCompletionContext
{
public:
    enum IoType
    { 
        IoInvalidType = 0,
        IoConnect,
        IoAccept,
        IoSend,
        IoSendTo,
        IoReceive,
        IoReceiveFrom
    };

    CSocketIoContext()
    {
        m_cRef = 1;
    }

    ~CSocketIoContext()  
    { 
        Destroy();
    }


    ULONG AddRef()
    {
        LONG lResult = InterlockedIncrement( &m_cRef );

        return( lResult );
    }

    ULONG Release()
    {
        LONG lResult = InterlockedDecrement( &m_cRef );

        if( 0 == lResult )
        {
            delete this;
            return( 0 );
        }

        return( 0xbad );
    }

    void Init(
            CCompletionHandler *pHandler,
            IoType ioType,
            BYTE *pbBuffer,
            DWORD cbBuffer,
            SOCKET socket,
            CClientSocketCallback *pCallback,
            QWORD qwCallbackArg )
    {
        m_pHandler = pHandler;
        m_ioType = ioType;        
        m_pbBuffer = pbBuffer;
        m_cbBuffer = cbBuffer;
        m_Socket = socket;
        m_pCallback = pCallback;
        m_qwCallbackArg = qwCallbackArg;
        m_addrlen = sizeof(sockaddr);
        m_hr = S_OK;

        SAFE_ADDREF( pHandler );
        SAFE_ADDREF( pCallback );
    }

    void Destroy()
    {
        SAFE_RELEASE( m_pCallback );
        SAFE_RELEASE( m_pHandler );
        m_ioType = IoInvalidType;
        m_pbBuffer = NULL;
        m_cbBuffer = 0;
        m_Socket = INVALID_SOCKET;
        m_qwCallbackArg = 0;
    }
    

    CCompletionHandler *GetHandler()        { return( m_pHandler ); }
    IoType GetIoType()                      { return( m_ioType ); }
    BYTE *GetBuffer()                       { return( m_pbBuffer ); }
    DWORD GetBufferSize()                   { return( m_cbBuffer ); }
    SOCKET GetSocket()                      { return( m_Socket ); }
    CClientSocketCallback *GetCallback()    { return( m_pCallback ); }
    QWORD GetCallbackArg()                  { return( m_qwCallbackArg ); }
    sockaddr_in *GetAddr()                  { return( &m_addr ); }
    int* GetAddrLen()                       { return( &m_addrlen ); }
    HRESULT GetHRESULT()                    { return( m_hr ); }

    void SetAddr( const sockaddr_in *pAddr )
    {
        if( NULL != pAddr )
        {
            memcpy( &m_addr, pAddr, sizeof(sockaddr_in) );
        }
    }

    void SetHRESULT( HRESULT hr )
    {
        m_hr = hr;
    }

private:
    LONG m_cRef;
    CCompletionHandler *m_pHandler;
    IoType m_ioType;
    BYTE *m_pbBuffer;
    DWORD m_cbBuffer;
    SOCKET m_Socket;
    CClientSocketCallback *m_pCallback;
    QWORD m_qwCallbackArg;
    sockaddr_in m_addr;
    int m_addrlen;
    HRESULT m_hr;
};

//////////////////////////////////////////////////////////////////////////////
class CClientSocket : public CCompletionHandler
{
public:

    static HRESULT __stdcall CreateInstance( 
                                CClientSocket **ppSocket, 
                                CCompletionPort *pIOCP, 
                                CCompletionPort *pAcceptIOCP, 
                                SOCKET s = INVALID_SOCKET );

    ULONG AddRef()
    {
        LONG lResult = InterlockedIncrement( &m_cRef );

        return( lResult );
    }

    ULONG Release()
    {
        LONG lResult = InterlockedDecrement( &m_cRef );

        if( 0 == lResult )
        {
            delete this;
            return( 0 );
        }

        return( 0xbad );
    }

    //
    // Synchronous. Must be called before any other function.
    // SO_REUSEADDR is set by default before the implicit call to Bind()
    //
    HRESULT Init( 
                int protocol,                   // IPPROTO_TCP, IPPROTO_UDP 
                const sockaddr_in *pAddress,    // IP address to bind to
                BOOL fReuseAddr,
                sockaddr_in *pAddressUsed = NULL );

    //
    // Synchronous.
    //
    HRESULT GetLocalAddress( sockaddr_in *pLocalAddress );

    HRESULT GetPeerAddress( sockaddr_in *pPeerAddress );

    //
    // TCP: Asynchronous
    // UDP: Synchronous
    //
    HRESULT Connect( 
                const sockaddr_in *pAddr,
                CClientSocketCallback *pCallback,
                QWORD qwCallbackArg );

    //
    // Synchronous.
    //
    HRESULT Listen( DWORD dwConnectionBacklog );

    //
    // Always asynchronous.
    //
    HRESULT Accept(
                CClientSocketCallback *pCallback,
                QWORD qwCallbackArg );

    //
    // TCP: Asynchronous. OnSocketSend is called on completion
    // UDP: Synchronous. If success, cbToSend is guaranteed to be the
    //      number of bytes sent.
    //
    HRESULT Send(
                BYTE *pbBuffer,
                DWORD cbToSend, 
                CClientSocketCallback *pCallback,
                QWORD qwCallbackArg );

    //
    // TCP: Asynchronous. OnSocketSend is called on completion
    // UDP: Synchronous. If success, cbToSend is guaranteed to be the
    //      number of bytes sent.
    //
    HRESULT SendEx(
                WSABUF *rgBuffers,
                DWORD cBuffers, 
                CClientSocketCallback *pCallback,
                QWORD qwCallbackArg );


    //
    // TCP: Not supported.
    // UDP: Synchronous. If success, cbToSend is guaranteed to be the
    //      number of bytes sent.
    //
    HRESULT SendTo( 
                BYTE *pbBuffer,
                DWORD cbToSend, 
                const sockaddr_in *pSendToAddr,
                CClientSocketCallback *pCallback,
                QWORD qwCallbackArg );

    //
    // Asynchronous. OnSocketReceive is called on completion
    //
    HRESULT Receive( 
                BYTE *pbBuffer,
                DWORD cbBuffer,
                CClientSocketCallback *pCallback,
                QWORD qwCallbackArg );

    //
    // Asynchronous. OnSocketReceiveFrom is called on completion
    //
    HRESULT ReceiveFrom( 
                BYTE *pbBuffer,
                DWORD cbBuffer,
                CClientSocketCallback *pCallback,
                QWORD qwCallbackArg );

    //
    // Synchronous.
    //
    HRESULT Close();

    //
    // Synchronous.
    //
    HRESULT GetSocket( SOCKET *pSocket );

    //
    // Synchronous. Sets I/O type.
    //
    HRESULT SetBlockingIO( BOOL fBlockingIO );

    //
    // Synchronous. TRUE disables TCP Nagle. FALSE enables.
    //
    HRESULT SetDisableNagle( BOOL fDisable );

    //
    // Synchronous. Sets the socket receive buffer size.
    //
    HRESULT SetReceiveBufferSize( DWORD dwBufferSize );

    //
    // Synchronous. Sets the socket send buffer size.
    //
    HRESULT SetSendBufferSize( DWORD dwBufferSize );

    //
    // TCP: Not supported.
    // UDP: Synchronous. Gets the maximum message size that is allowed on
    // the socket.
    //
    HRESULT GetMaxMessageSize( DWORD *pdwMaxMessageSize );

    //
    // CCompletionHandler impl
    //
    virtual void OnIoCompletion( 
                    DWORD dwError, 
                    DWORD cbTransferred, 
                    ULONG_PTR ulpKey,
                    CCompletionContext *pCtx );

    
    CCompletionPort* GetIOCP() { return ( m_pIOCP ); }

protected:
    CClientSocket();

    virtual ~CClientSocket();

    HRESULT InternalInit( CCompletionPort *pIOCP, CCompletionPort *pAcceptIOCP, SOCKET s );

    //
    // Common init code between Init() and sockets created with Accept()
    // 
    HRESULT FinishInit( int protocol );

    //
    // Helper function to call OnAccept()
    //
    HRESULT CallOnAccept( DWORD dwError, DWORD cbTransferred, CSocketIoContext *pCtx );

    //
    // Winsock error processing helper
    //
    static HRESULT HandleWSAReturnValue(
                            CSocketIoContext::IoType Operation, 
                            int iRet );

private:
    LONG m_cRef;

    SOCKET m_Socket;
    int m_protocol;

    BOOL m_fBlockingIO;
    BOOL m_fHavePeerAddr;

    sockaddr_in m_saddrLocal;
    sockaddr_in m_saddrPeer;

    CCompletionPort *m_pIOCP;
    CCompletionPort *m_pAcceptIOCP;
};


//////////////////////////////////////////////////////////////////////////////
class CClientSocketConnectWatchdog
{
public:

    enum
    {
        CONNECT_TIMEOUT = 20000,
        CONNECT_LIST_COUNT = 3,
        INITIAL_LIST_ALLOC = 64
    };
    
    CClientSocketConnectWatchdog();

    ~CClientSocketConnectWatchdog();

    HRESULT AddConnectingSocket(
        CSocketIoContext* pContext );

    void Remove(
        CSocketIoContext* pContext );
    
protected:

    void Lock()
    {
        EnterCriticalSection(&m_cs);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_cs);
    }

    static DWORD WINAPI ConnectionWatchdogThreadProc(
        LPVOID pThisRaw );

    void ConnectionWatchdog();

    HRESULT EnsureInit()
    {
        HRESULT hr = S_OK;
        
        if(! m_bLazyInit)
        {
            Lock();

            if(! m_bLazyInit)
            {
                hr = Init();
            }

            Unlock();
        }
    
        return hr;
    }

    HRESULT Init();

    CRITICAL_SECTION m_cs;

    HANDLE m_hWatchdogThread;

    DWORD m_dwWatchdogThreadId;

    BOOL m_bLazyInit;

    HANDLE m_hChangeEvent;
    
    CAtlList<void*> m_rgSocketList[CONNECT_LIST_COUNT];

    HANDLE m_rghChangeEvent[CONNECT_LIST_COUNT + 1];

    DWORD m_dwNextList;
};


#endif  // CLISOCK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\confnpdb\test\unit\Unit.cs ===
using System;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace xonline.tools.configuration.test {
   public abstract class UnitTest : TestBase {
      protected static string Interface {
         get { return "wcdebugtest"; }
      }

      protected static string Environment {
         get { return xonline.common.config.Config.Environment; }
      }

      protected static string NpdbServer {
         get { return xonline.common.config.Config.NpdbServer; }
      }

      protected UnitTest(string name, string description) { 
         Name = name;
         Desc = description;
      }

      protected abstract void Unit();

      protected override void Execute() {
         ResultCode = TEST_RESULTS.FAILED;

         Unit();

         ResultCode = TEST_RESULTS.PASSED;
      }

      protected SqlConnection GetNpdbConnection() {
         SqlConnection connection = new SqlConnection(xonline.common.config.Config.NpdbConnectionString);

         connection.Open();

         return connection;
      }

      protected void ExecuteNonQuery(SqlConnection connection, string query) {
         InterfaceBucketHelper.ExecuteNonQuery(connection, query);
      }

      protected SqlDataReader ExecuteQuery(SqlConnection connection, string query) {
         return InterfaceBucketHelper.ExecuteQuery(connection, query);
      }

      protected static void NewException(string message, params object[] args) {
         throw new Exception(string.Format(message, args));
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\ClientImpl.h ===
#pragma once

typedef struct _tagSOCKET_CALLBACK
{
    CClientSocket*  pSocket;
    LARGE_INTEGER   liStartTickCount;
} SOCKET_CALLBACK, *PSOCKET_CALLBACK;

class CClientImpl :
    public CClientSocketCallback
{
private:
    CStringA            m_cszAddress;
    CStringA            m_cszInternetAddress;
    USHORT              m_nPort;
    USHORT              m_nInternetPort;
    LONG                m_lTimeout;
    GUID                m_ClientID;
    CStringW            m_cszResults;
    HANDLE              m_hDoneEvent;
    LONG                m_lResponses;
    CClientSocket*      m_pSendSocket;
    CClientSocket*      m_pRecvSocket;
	CCompletionPort*    m_pIOCP;

    static LARGE_INTEGER    s_liCounterFreq;

public:
    CClientImpl(void);
    ~CClientImpl(void);

    HRESULT Init(void);

// ICConnCheckClient
public:

    ULONG AddRef()
    {
		return 0;
    }

    ULONG Release()
    {
        return 0;
    } 

    // properties
    STDMETHOD(get_Address)(BSTR* pVal);
    STDMETHOD(put_Address)(BSTR newVal);
    STDMETHOD(get_Port)(USHORT* pVal);
    STDMETHOD(put_Port)(USHORT newVal);
    STDMETHOD(get_Timeout)(LONG* pVal);
    STDMETHOD(put_Timeout)(LONG newVal);
    STDMETHOD(get_ClientUID)(BSTR* pVal);
    STDMETHOD(get_DHCP)(VARIANT_BOOL* pVal);
    STDMETHOD(get_USBModem)(VARIANT_BOOL* pVal);
    STDMETHOD(get_ProxySettings)(BSTR* pVal);

    // methods
    STDMETHOD(DoNATTest)(BSTR* pVal);
    STDMETHOD(DoICMPTest)(BSTR* pVal);

// CClientSocketCallback
protected:

    virtual HRESULT OnSocketConnect(
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketAccept(
                        CClientSocket *pListenSocket,
                        CClientSocket *pAcceptedSocket,
                        sockaddr_in *pLocalAddr,
                        sockaddr_in *pRemoteAddr,
                        HRESULT hrCallback,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketSend(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketSendTo(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketReceive(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketReceiveFrom(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        sockaddr_in *pFilledInFrom,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketClose(
                        HRESULT hr,
                        QWORD qwCallbackArg );

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\compport.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef COMPPORT_H_INCLUDED
#define COMPPORT_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
    
class CCompletionContext;
class CCompletionHandler;
class CCompletionPort;


/////////////////////////////////////////////////////////////////////////////
class CCompletionHandler
{
public:
    virtual ULONG AddRef() = 0;

    virtual ULONG Release() = 0;

    virtual void OnIoCompletion( 
                    DWORD dwError, 
                    DWORD cbTransferred, 
                    ULONG_PTR ulpKey,
                    CCompletionContext *pCtx ) = 0;
};
    
/////////////////////////////////////////////////////////////////////////////
class CCompletionContext : public OVERLAPPED
{
public:
    CCompletionContext() 
    {
        ZeroMemory( (OVERLAPPED*)this, sizeof(OVERLAPPED) );
    }
    
    virtual CCompletionHandler* GetHandler() = 0;
};
    
/////////////////////////////////////////////////////////////////////////////
class CCompletionPort
{
public:
    static STDMETHODIMP CreateInstance( 
                                DWORD dwConcurrancy, 
                                DWORD dwThreadPoolSize, 
                                DWORD dwThreadPriority,
                                CCompletionPort **ppPort );

    STDMETHODIMP_(ULONG) AddRef()
    {
        return( INC_REF( m_cRef ) );
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if( 0 == DEC_REF( m_cRef ) )
        {
            delete this;
            return( 0 );
        }
        
        return( 0xbad );
    }

    HRESULT Attach( HANDLE hParam, ULONG_PTR upKey = 0 );

    HRESULT Leave( HANDLE hParam );

    HRESULT PostCompletion(
                    CCompletionContext *pCtx,
                    DWORD cbTransferred = 0,
                    ULONG_PTR upKey = 0 );

    void Shutdown();

private:

    CCompletionPort( DWORD dwConcurrancy, 
                     DWORD dwThreadPoolSize, 
                     DWORD dwThreadPriority, 
                     HRESULT *phr );

    ~CCompletionPort();

    static DWORD WINAPI ThreadBase( LPVOID pvThis );
    void ThreadProc();

    HANDLE m_hPort;
    HANDLE *m_hThreads;
    DWORD m_cThreads;
    DWORD m_dwThreadPriority;
    DWORD m_dwConcurrancy;
    DWORD m_cRef;
    CRITICAL_SECTION m_cs;
};


#endif  // COMPPORT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\compport.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"
#include "compport.h"

/////////////////////////////////////////////////////////////////////////////
#define CP_SHUTDOWN_KEY     ((ULONG_PTR) ~0)


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCompletionPort::CreateInstance( 
                                        DWORD dwConcurrancy, 
                                        DWORD dwThreadPoolSize, 
                                        DWORD dwThreadPriority,
                                        CCompletionPort **ppPort )
{
    HRESULT hr = S_OK;

    *ppPort = new CCompletionPort( 
                    dwConcurrancy, 
                    dwThreadPoolSize, 
                    dwThreadPriority, 
                    &hr );

    if( NULL == *ppPort )
    {
        return( E_OUTOFMEMORY );
    }

    if( FAILED( hr ) )
    {
        (*ppPort)->Release();
        *ppPort = NULL;
        return( hr );
    }

    return( S_OK );
}


/////////////////////////////////////////////////////////////////////////////
CCompletionPort::CCompletionPort( 
                    DWORD dwConcurrancy, 
                    DWORD dwThreadPoolSize, 
                    DWORD dwThreadPriority, 
                    HRESULT *phr )
{
    InitializeCriticalSection( &m_cs );

    m_hPort = NULL;
    m_cThreads = 0;
    m_hThreads = NULL;
    m_cRef = 1;

    m_dwConcurrancy = dwConcurrancy;
    m_dwThreadPriority = dwThreadPriority;
        
    m_hPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, 0, dwConcurrancy );

    if( NULL == m_hPort )
    {
        *phr = E_UNEXPECTED;
        return;
    }

    m_cThreads = dwThreadPoolSize;
    
    if( 0 == m_cThreads )
    {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        m_cThreads = 1 + si.dwNumberOfProcessors;
    }

    m_hThreads = new HANDLE[m_cThreads];

    if( NULL == m_hThreads )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    ZeroMemory( m_hThreads, sizeof(m_hThreads) );

    DWORD tid;

    for( int i = 0; i < (int)m_cThreads; i++ )
    {
        m_hThreads[i] = CreateThread( NULL, 0, ThreadBase, (LPVOID)this, 0, &tid );
       
        if( NULL == m_hThreads[i] )
        {
            *phr = E_UNEXPECTED;
            return;
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
CCompletionPort::~CCompletionPort()
{
    Shutdown();

    DeleteCriticalSection( &m_cs );
}


/////////////////////////////////////////////////////////////////////////////
void CCompletionPort::Shutdown()
{
    CStackBoundCriticalSection cs(m_cs);

    if( NULL != m_hPort )
    {
        for( int i = 0; i < (int)m_cThreads; i++ )
        {
            PostQueuedCompletionStatus( m_hPort, 0, CP_SHUTDOWN_KEY, NULL );
        }

        if( NULL != m_hThreads )
        {
            for( i = 0; ( i < (int)m_cThreads ) && m_hThreads[i]; i++ );

            if( i )
            {
                WaitForMultipleObjects( i, m_hThreads, TRUE, INFINITE );
            }

            SAFE_CLOSEHANDLE( m_hPort );

            for( i = 0; i < (int)m_cThreads; i++ )
            {
                SAFE_CLOSEHANDLE( m_hThreads[i] );
            }

            SAFE_ARRAYDELETE( m_hThreads );
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
void CCompletionPort::ThreadProc()
{
    CCompletionContext *pContext;
    OVERLAPPED *po;
    DWORD cbTransferred;
    ULONG_PTR upKey;
    BOOL fSuccess;

    SetThreadPriority( GetCurrentThread(), m_dwThreadPriority );

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

#if defined(ICECAP) && !defined(USE_DLP)
    ( void ) NameProfile( "CCompletionPort::ThreadProc", PROFILE_THREADLEVEL, PROFILE_CURRENTID );
#endif

    //SetThreadDebugName( "CCompletionPort::ThreadProc" );

    for(;;)
    {
        fSuccess = GetQueuedCompletionStatus( m_hPort, &cbTransferred, &upKey, &po, INFINITE );

        if( !fSuccess && ( NULL == po ) )
        {
            break;
        }
    
        if( NULL != po )
        {
            pContext = (CCompletionContext*) po;

            pContext->GetHandler()->OnIoCompletion(
                        ( fSuccess ? NO_ERROR : GetLastError() ), 
                        cbTransferred, 
                        upKey,
                        pContext );
        }
        else if( CP_SHUTDOWN_KEY == upKey )
        {
            break;
        }
    }

    CoUninitialize();
}


/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CCompletionPort::ThreadBase( LPVOID pvThis )
{
    ((CCompletionPort*)pvThis)->ThreadProc();

    return( 0xDEAD );
} 


/////////////////////////////////////////////////////////////////////////////
HRESULT CCompletionPort::Attach( HANDLE hParam, ULONG_PTR upKey )
{
    CStackBoundCriticalSection cs(m_cs);
    
    HANDLE hPort = CreateIoCompletionPort( hParam, m_hPort, upKey, m_dwConcurrancy );

    if( NULL == hPort )
    {
        return( E_FAIL );
    }

    return( S_OK );
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CCompletionPort::Leave( HANDLE hParam )
{
    //
    // You can't unjoin a completion port on NT!!!
    //
    return( S_OK );
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CCompletionPort::PostCompletion( 
                            CCompletionContext *pCtx, 
                            DWORD cbTransferred, 
                            ULONG_PTR upKey )
{
    CStackBoundCriticalSection cs(m_cs);

    if( PostQueuedCompletionStatus( m_hPort, cbTransferred, upKey, (LPOVERLAPPED)pCtx ) )
    {
        return( S_OK );
    }

    return( E_FAIL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\icmptestimpl.h ===
#pragma once

// ICMP header
//
typedef struct _icmpHeader
{
  BYTE		i_type;
  BYTE		i_code;
  USHORT	i_cksum;
  USHORT	i_id;
  USHORT	i_seq;

} ICMPHEADER;


class CSeqMapper
{

public:

    CSeqMapper()			{}
	virtual ~CSeqMapper()	{}
	int		Init()			{}

	
	int	GenSeqNumber(u_short *seq, u_short target, u_short hop, u_short test)
	{
		_ASSERT(target >=0 && target < 8);		// 8
		_ASSERT(hop    >=0 && hop    < 128);	// 128
		_ASSERT(test   >=0 && test   < 64);		// 64

		*seq = target<<13 | hop<<6 | test;

		return 0;
	}


	int MapSeqNumber(u_short seq, u_short* thread, u_short* hop, u_short* test)
	{
		u_short	mask = 0xFFFF;

		*thread = (seq & 0xE000) >> 13;
		*hop    = (seq & 0x1FC0) >> 6;
		*test   = (seq & 0x003F);

		return 0;
	}
};


class CICMPTestImpl :
    public CClientSocketCallback
{
public:
    typedef struct _tagSOCKET_CALLBACK
    {
        CClientSocket*  pSocket;
        LARGE_INTEGER   liStartTickCount;
    } SOCKET_CALLBACK, *PSOCKET_CALLBACK;

private:
    CStringA            m_cszAddress;
    CStringA            m_cszInternetAddress;
    USHORT              m_nPort;
    USHORT              m_nInternetPort;
    LONG                m_lTimeout;
    LONG                m_lMaxHops;
    GUID                m_ClientID;
    CStringW            m_cszResults;
    HANDLE              m_hDoneEvent;
    LONG                m_lResponses;
    CClientSocket*      m_pSocket;
	CCompletionPort*    m_pIOCP;
    bool                m_bDone;

    static LARGE_INTEGER    s_liCounterFreq;

public:
    CICMPTestImpl(void);
    ~CICMPTestImpl(void);

    HRESULT Init(void);

// ICConnCheckClient
public:

    ULONG AddRef()
    {
		return 0;
    }

    ULONG Release()
    {
        return 0;
    } 

    // properties
    STDMETHOD(put_Address)(BSTR newVal);
    STDMETHOD(put_Port)(USHORT newVal);
    STDMETHOD(put_Timeout)(LONG newVal);
    STDMETHOD(get_MaxHops)(LONG* pVal);
    STDMETHOD(put_MaxHops)(LONG newVal);

    // methods
    STDMETHOD(DoICMPTest)(BSTR* pVal);

protected:

    HRESULT BuildPingPacket(char**, USHORT);

// CClientSocketCallback
protected:

    virtual HRESULT OnSocketConnect(
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketAccept(
                        CClientSocket *pListenSocket,
                        CClientSocket *pAcceptedSocket,
                        sockaddr_in *pLocalAddr,
                        sockaddr_in *pRemoteAddr,
                        HRESULT hrCallback,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketSend(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketSendTo(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketReceive(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketReceiveFrom(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        sockaddr_in *pFilledInFrom,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketClose(
                        HRESULT hr,
                        QWORD qwCallbackArg );

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\nattestimpl.cpp ===
#include "StdAfx.h"
#include <iphlpapi.h>
#include "natupnp.h"
#include "natupnp_i.c"
#include "nattestimpl.h"


LARGE_INTEGER CNATTestImpl::s_liCounterFreq = {0, 0};

CNATTestImpl::CNATTestImpl(void) : m_nPort(0), 
                                   m_nInternetPort(0), 
                                   m_lTimeout(60),
                                   m_hDoneEvent(NULL),
                                   m_lResponses(0),
                                   m_pSendSocket(NULL),
                                   m_pRecvSocket(NULL),
                                   m_pIOCP(NULL)
{
    CRegKey reg;

    QueryPerformanceFrequency(&s_liCounterFreq);

    if(reg.Open(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\ISPChecker Client")) != ERROR_SUCCESS)
    {
        reg.Create(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\ISPChecker Client"));

        CoCreateGuid(&m_ClientID);

        reg.SetGUIDValue(_T("ClientID"), m_ClientID);
    }
    else
    {
        reg.QueryGUIDValue(_T("ClientID"), m_ClientID);
    }
}

CNATTestImpl::~CNATTestImpl(void)
{
    if(m_hDoneEvent != NULL)
        CloseHandle(m_hDoneEvent);

    if(m_pSendSocket != NULL)
    {
        m_pSendSocket->Close();
    }

    if(m_pRecvSocket != NULL)
    {
        m_pRecvSocket->Close();
    }

    if(m_pIOCP != NULL)
    {
        m_pIOCP->Shutdown();
    }

    SAFE_RELEASE(m_pSendSocket);
    SAFE_RELEASE(m_pRecvSocket);
    SAFE_RELEASE(m_pIOCP);

    WSACleanup();
}

HRESULT CNATTestImpl::Init()
{
    HRESULT             hr;
    WSADATA             wsaData;
    CHAR                szHostName[MAX_PATH];
    hostent*            pHostEntry;
    sockaddr_in         sendAddr;
    sockaddr_in         recvAddr;

    // create event if necessary
    if(m_hDoneEvent == NULL)
    {
        m_hDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(m_hDoneEvent == NULL)
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            goto Cleanup;
        }
    }
    else
    {
        if(!ResetEvent(m_hDoneEvent))
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            goto Cleanup;
        }
    }

    // initialize winsock
    hr = WSAStartup(WINSOCK_VERSION, &wsaData);
    if(hr != 0)
    {
        hr = HRESULT_FROM_WIN32(hr);
        goto Cleanup;
    }

    hr = gethostname(szHostName, sizeof(szHostName));
    if(hr != S_OK)
    {
        hr = HRESULT_FROM_WIN32(hr);
        goto Cleanup;
    }

    pHostEntry = gethostbyname(szHostName);
    if(pHostEntry == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if(pHostEntry->h_addr_list[0] == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Now create the IO completion port and the sockets (only one if there's just one IP)
    //

	hr = CCompletionPort::CreateInstance(0, 0, THREAD_PRIORITY_NORMAL, &m_pIOCP);
	if(FAILED(hr))
	{
		goto Cleanup;
	}

    //
    //  Initialize the send socket
    //

	hr = CClientSocket::CreateInstance(&m_pSendSocket, m_pIOCP, m_pIOCP);
	if(FAILED(hr))
	{
		goto Cleanup;
	}

    sendAddr.sin_family = AF_INET;
    sendAddr.sin_addr.S_un.S_addr = *(PULONG)(pHostEntry->h_addr_list[0]);
    sendAddr.sin_port = 0;
    memset(&(sendAddr.sin_zero), 0, sizeof(sendAddr.sin_zero));

	hr = m_pSendSocket->Init(IPPROTO_UDP, &sendAddr, FALSE);

	if(FAILED(hr))
	{
		goto Cleanup;
	}

    //
    //  Initialize the receive socket
    //

	hr = CClientSocket::CreateInstance(&m_pRecvSocket, m_pIOCP, m_pIOCP);
	if(FAILED(hr))
	{
		goto Cleanup;
	}

    recvAddr.sin_family = AF_INET;
    recvAddr.sin_addr.S_un.S_addr = *(PULONG)(pHostEntry->h_addr_list[0]);
    recvAddr.sin_port = 0;
    memset(&(recvAddr.sin_zero), 0, sizeof(recvAddr.sin_zero));

	hr = m_pRecvSocket->Init(IPPROTO_UDP, &recvAddr, FALSE, &recvAddr);

	if(FAILED(hr))
		goto Cleanup;

Cleanup:

    return hr;
}


STDMETHODIMP CNATTestImpl::get_Address(BSTR* pVal)
{
    *pVal = m_cszAddress.AllocSysString();

    return S_OK;
}

STDMETHODIMP CNATTestImpl::put_Address(BSTR newVal)
{
    m_cszAddress = newVal;

    return S_OK;
}

STDMETHODIMP CNATTestImpl::get_Port(USHORT* pVal)
{
    *pVal = m_nPort;

    return S_OK;
}

STDMETHODIMP CNATTestImpl::put_Port(USHORT newVal)
{
    m_nPort = newVal;

    return S_OK;
}

STDMETHODIMP CNATTestImpl::get_Timeout(LONG* pVal)
{
    *pVal = m_lTimeout;

    return S_OK;
}

STDMETHODIMP CNATTestImpl::put_Timeout(LONG newVal)
{
    m_lTimeout = newVal;

    return S_OK;
}

STDMETHODIMP CNATTestImpl::get_ClientUID(BSTR* pVal)
{
    HRESULT hr;
    WCHAR   szGUID[64];

    if(StringFromGUID2(m_ClientID, szGUID, 64) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pVal = SysAllocString(szGUID);
    if(*pVal == NULL)
        hr = E_OUTOFMEMORY;
    else
        hr = S_OK;

Cleanup:

    return hr;
}

STDMETHODIMP CNATTestImpl::get_DHCP(VARIANT_BOOL* pVal)
{
    HRESULT             hr;
    ULONG               ulBufLen;
    DWORD               dwErr;
    PIP_ADAPTER_INFO    pIpAdapterInfo = NULL;
    PIP_ADAPTER_INFO    pIpInfoCur;

    if(pVal == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pVal = VARIANT_FALSE;

    ulBufLen = 0;
    dwErr = GetAdaptersInfo(NULL, &ulBufLen);
    if(dwErr != ERROR_BUFFER_OVERFLOW)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Cleanup;
    }

    pIpAdapterInfo = (PIP_ADAPTER_INFO)LocalAlloc(LPTR, ulBufLen);
    if(pIpAdapterInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    dwErr = GetAdaptersInfo(pIpAdapterInfo, &ulBufLen);
    if(dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Cleanup;
    }

    pIpInfoCur = pIpAdapterInfo;
    while(pIpInfoCur != NULL)
    {
        if(pIpInfoCur->DhcpEnabled != 0)
        {
            *pVal = VARIANT_TRUE;
            break;
        }

        pIpInfoCur = pIpInfoCur->Next;
    }

    hr = S_OK;

Cleanup:

    if(pIpAdapterInfo != NULL)
        LocalFree(pIpAdapterInfo);

    return hr;
}

STDMETHODIMP CNATTestImpl::get_USBModem(VARIANT_BOOL* pVal)
{
    *pVal = VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CNATTestImpl::get_ProxySettings(BSTR* pVal)
{
    HRESULT                 hr;
    HINTERNET               hInet;
    INTERNET_PROXY_INFO*    pProxyInfo = NULL;
    DWORD                   dwBufLen;
    CStringW                cszProxySettings;

    USES_CONVERSION;

    //
    //  Get the proxy info
    //

    InternetQueryOption(NULL, INTERNET_OPTION_PROXY, NULL, &dwBufLen);

    pProxyInfo = (INTERNET_PROXY_INFO*)malloc(dwBufLen);
    if(pProxyInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if(!InternetQueryOption(NULL, INTERNET_OPTION_PROXY, pProxyInfo, &dwBufLen))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  Format the proxy info into XML
    //

    if(pProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
    {
        m_cszResults = L"<PROXYSETTINGS ACCESSTYPE=\"DIRECT\"/>";
    }
    else
    {
        LPWSTR  pwszProxy = A2W((LPCSTR)(pProxyInfo->lpszProxy));
        LPWSTR  pwszProxyBypass = A2W((LPCSTR)(pProxyInfo->lpszProxyBypass));

        ULONG   ulProxyEncodedLen = wcslen(pwszProxy) * 2;
        ULONG   ulProxyBypassEncodedLen = wcslen(pwszProxyBypass) * 2;

        LPWSTR  pwszProxyEncoded = (LPWSTR)malloc(ulProxyEncodedLen * sizeof(WCHAR));
        LPWSTR  pwszProxyBypassEncoded = (LPWSTR)malloc(ulProxyBypassEncodedLen * sizeof(WCHAR));

        if(pwszProxyEncoded != NULL && pwszProxyBypassEncoded != NULL)
        {
            memset(pwszProxyEncoded, 0, ulProxyEncodedLen * sizeof(WCHAR));
            memset(pwszProxyBypassEncoded, 0, ulProxyBypassEncodedLen * sizeof(WCHAR));

            EscapeXML(pwszProxy, 
                      wcslen(pwszProxy), 
                      pwszProxyEncoded, 
                      ulProxyEncodedLen, 
                      ATL_ESC_FLAG_ATTR);
            EscapeXML(pwszProxyBypass, 
                      wcslen(pwszProxyBypass), 
                      pwszProxyBypassEncoded, 
                      ulProxyBypassEncodedLen, 
                      ATL_ESC_FLAG_ATTR);

            m_cszResults.Format(L"<PROXYSETTINGS ACCESSTYPE=\"PROXY\" SERVER=\"%s\" BYPASS=\"%s\"/>",
                pwszProxyEncoded,
                pwszProxyBypassEncoded);

            free(pwszProxyEncoded);
            free(pwszProxyBypassEncoded);
        }
    }

    //
    //  Allocate output string
    //

    *pVal = SysAllocString(m_cszResults);
    if(*pVal == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = S_OK;

Cleanup:

    if(pProxyInfo != NULL)
        free(pProxyInfo);

    m_cszResults.Empty();

    return hr;
}

HRESULT CNATTestImpl::get_UPnPNAT(
    BSTR*   pVal
    )
{
    HRESULT                                 hr;
    CComPtr<IUPnPNAT>                       piUPnPNAT;
    CComPtr<IStaticPortMappingCollection>   piSPMs;

    if(pVal == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = CoCreateInstance(CLSID_UPnPNAT, NULL, CLSCTX_SERVER, IID_IUPnPNAT, (void**)&piUPnPNAT);
    if(FAILED(hr))
    {
        *pVal = SysAllocString(L"?");
        hr = S_OK;
        goto Cleanup;
    }

    hr = piUPnPNAT->get_StaticPortMappingCollection(&piSPMs);
    if(FAILED(hr))
    {
        *pVal = SysAllocString(L"N");
        hr = S_OK;
        goto Cleanup;
    }

    *pVal = SysAllocString(L"Y");

Cleanup:

    if(hr == S_OK && *pVal == NULL)
        hr = E_OUTOFMEMORY;

    return hr;
}


HRESULT CNATTestImpl::DoNATTest(
    BSTR*   pResults
    )
{
    HRESULT             hr;
    CLIENT_PACKET       ClientPacket;
    sockaddr_in         sendAddr;
    sockaddr_in         recvAddr;
    sockaddr_in         serverAddr;
    LPBYTE              pBuffer;
    LARGE_INTEGER       liTickCount;
    PSOCKET_CALLBACK    pSocketCallback;

    m_lResponses = 0;

    if(pResults == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pResults = NULL;

    //
    // destination address
    //

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.S_un.S_addr = inet_addr(m_cszAddress);
    serverAddr.sin_port = m_nPort;
    memset(&(serverAddr.sin_zero), 0, sizeof(serverAddr.sin_zero));

    //
    //  Allocate receive buffers and set both sockets to listening
    //

    pBuffer = (LPBYTE)malloc(256);
    if(pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pSocketCallback = (PSOCKET_CALLBACK)malloc(sizeof(SOCKET_CALLBACK));
    pSocketCallback->pSocket = m_pSendSocket;
    QueryPerformanceCounter(&(pSocketCallback->liStartTickCount));

    hr = m_pSendSocket->ReceiveFrom(pBuffer, 256, this, MAKEQWORD((DWORD)pSocketCallback, 0));
    if(FAILED(hr))
        goto Cleanup;

    pBuffer = (LPBYTE)malloc(256);
    if(pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pSocketCallback = (PSOCKET_CALLBACK)malloc(sizeof(SOCKET_CALLBACK));
    pSocketCallback->pSocket = m_pRecvSocket;
    QueryPerformanceCounter(&(pSocketCallback->liStartTickCount));

    hr = m_pRecvSocket->ReceiveFrom(pBuffer, 256, this, MAKEQWORD((DWORD)pSocketCallback, 0));
    if(FAILED(hr))
        goto Cleanup;

    // send packet to server and wait for completion or timeout, doesn't matter
    m_pRecvSocket->GetLocalAddress(&recvAddr);
    ClientPacket.nAltPort = recvAddr.sin_port;
    hr = m_pSendSocket->SendTo((LPBYTE)&ClientPacket, sizeof(CLIENT_PACKET), &serverAddr, this, 0);
    if(FAILED(hr))
        goto Cleanup;

    m_pSendSocket->GetLocalAddress(&sendAddr);

    // initialize results string
    m_cszResults.Format(L"<NATTEST><REQUEST CLIENTADDR=\"%u.%u.%u.%u\" CLIENTPORT=\"%u\" SERVERADDR=\"%u.%u.%u.%u\" SERVERPORT=\"%u\"/>",
        sendAddr.sin_addr.S_un.S_un_b.s_b1,
        sendAddr.sin_addr.S_un.S_un_b.s_b2,
        sendAddr.sin_addr.S_un.S_un_b.s_b3,
        sendAddr.sin_addr.S_un.S_un_b.s_b4,
        sendAddr.sin_port,
        serverAddr.sin_addr.S_un.S_un_b.s_b1,
        serverAddr.sin_addr.S_un.S_un_b.s_b2,
        serverAddr.sin_addr.S_un.S_un_b.s_b3,
        serverAddr.sin_addr.S_un.S_un_b.s_b4,
        serverAddr.sin_port);

    WaitForSingleObject(m_hDoneEvent, m_lTimeout * 1000);

    m_cszResults += L"</NATTEST>";

    OutputDebugStringW(m_cszResults);

    *pResults = m_cszResults.AllocSysString();
    if(*pResults == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    m_cszResults.Empty();

    return hr;
}

// CClientSocketCallback methods

HRESULT CNATTestImpl::OnSocketConnect(
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CNATTestImpl::OnSocketAccept(
                    CClientSocket *pListenSocket,
                    CClientSocket *pAcceptedSocket,
                    sockaddr_in *pLocalAddr,
                    sockaddr_in *pRemoteAddr,
                    HRESULT hrCallback,
                    QWORD qwCallbackArg )
{
    return E_NOTIMPL;
}

HRESULT CNATTestImpl::OnSocketSend(
                    BYTE *pbBufferSent,
                    DWORD cbToSend,
                    DWORD cbSent,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CNATTestImpl::OnSocketSendTo(
                    BYTE *pbBufferSent,
                    DWORD cbToSend,
                    DWORD cbSent,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CNATTestImpl::OnSocketReceive(
                    BYTE *pbFilledInBuffer,
                    DWORD cbRead,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CNATTestImpl::OnSocketReceiveFrom(
                    BYTE *pbFilledInBuffer,
                    DWORD cbRead,
                    sockaddr_in *pFilledInFrom,
                    HRESULT hrRecv,
                    QWORD qwCallbackArg )
{
    HRESULT                 hr;
    LPBYTE                  pBuffer;
    sockaddr_in             altAddr = *pFilledInFrom;
    sockaddr_in             clientAddr;
    int                     i;
    PSOCKET_CALLBACK        pSocketCallback = (PSOCKET_CALLBACK)LODWORD(qwCallbackArg);
    LARGE_INTEGER           liEndTickCount;
    DWORD                   dwLatency;
    DWORD                   cbProcessed;

    QueryPerformanceCounter(&liEndTickCount);
    dwLatency = (DWORD)(((liEndTickCount.QuadPart - pSocketCallback->liStartTickCount.QuadPart) * 1000)/s_liCounterFreq.QuadPart);

    CHAR szOutput[256];
    sprintf(szOutput, "start = %I64u, end = %I64u, freq = %I64u, latency = %u\r\n",
        pSocketCallback->liStartTickCount.QuadPart,
        liEndTickCount.QuadPart,
        s_liCounterFreq.QuadPart,
        dwLatency);
    OutputDebugStringA(szOutput);

    //
    //  Immediately submit another buffer for receiving.
    //

    pBuffer = (LPBYTE)malloc(256);
    if(pBuffer != NULL)
    {
        pSocketCallback->pSocket->ReceiveFrom(pBuffer, 256, this, qwCallbackArg);
    }

    //
    //  Process the buffer we received
    //

    if(hrRecv != 0)
    {
        // TODO handle returned socket error
        /*
        m_cszResults.AppendFormat(
            L"<RESPONSE ERROR=\"0x%08X\"/>",
            hrRecv);
        */
        SetEvent(m_hDoneEvent);
        hr = hrRecv;
        goto Cleanup;
    }

    pSocketCallback->pSocket->GetLocalAddress(&clientAddr);

    cbProcessed = 0;
    while(cbProcessed < cbRead)
    {
        PSERVER_PACKET pPacket = (PSERVER_PACKET)(pbFilledInBuffer + cbProcessed);

        m_cszResults.AppendFormat(
            L"<RESPONSE CLIENTADDRACTUAL=\"%u.%u.%u.%u\" "
                      L"CLIENTPORTACTUAL=\"%u\" "
                      L"CLIENTADDRSEEN=\"%u.%u.%u.%u\" "
                      L"CLIENTPORTSEEN=\"%u\" "
                      L"SERVERADDR=\"%u.%u.%u.%u\" "
                      L"SERVERPORT=\"%u\" "
                      L"LATENCY=\"%u\"/>",
            clientAddr.sin_addr.S_un.S_un_b.s_b1,
            clientAddr.sin_addr.S_un.S_un_b.s_b2,
            clientAddr.sin_addr.S_un.S_un_b.s_b3,
            clientAddr.sin_addr.S_un.S_un_b.s_b4,
            clientAddr.sin_port,
            pPacket->inaClientAddr.S_un.S_un_b.s_b1,
            pPacket->inaClientAddr.S_un.S_un_b.s_b2,
            pPacket->inaClientAddr.S_un.S_un_b.s_b3,
            pPacket->inaClientAddr.S_un.S_un_b.s_b4,
            pPacket->nClientPort,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b1,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b2,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b3,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b4,
            pFilledInFrom->sin_port,
            dwLatency);

        cbProcessed += sizeof(SERVER_PACKET);
    }

    if(InterlockedIncrement(&m_lResponses) == 24)
        SetEvent(m_hDoneEvent);

    //
    //  Free the buffer
    //

    free(pbFilledInBuffer);

    hr = S_OK;

Cleanup:

	return hr;
}

HRESULT CNATTestImpl::OnSocketClose(
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkdb\makefile.inc ===
$(O)\MiscFilesList.txt $(O)\Placefil.txt : makefile.inc *.sql *.txt *.js
    -del $(O)\MiscFilesList.txt $(O)\Placefil.txt
    for /f %i in ('dir /b *.sql') do @echo MyMISCFILES=$$(MyMISCFILES) %i>> $(O)\MiscFilesList.txt
    for /f %i in ('dir /b *.sql') do @echo %i conncheck\db>> $(O)\Placefil.txt
    for /f %i in ('dir /b *.txt') do @echo MyMISCFILES=$$(MyMISCFILES) %i>> $(O)\MiscFilesList.txt
    for /f %i in ('dir /b *.txt') do @echo %i conncheck\db>> $(O)\Placefil.txt
    for /f %i in ('dir /b *.js') do @echo MyMISCFILES=$$(MyMISCFILES) %i>> $(O)\MiscFilesList.txt
    for /f %i in ('dir /b *.js') do @echo %i conncheck\db>> $(O)\Placefil.txt
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\icmptestimpl.cpp ===
#include "StdAfx.h"
#include "icmptestimpl.h"

LARGE_INTEGER CICMPTestImpl::s_liCounterFreq = {0, 0};

CSeqMapper		g_SeqMap;

CICMPTestImpl::CICMPTestImpl(void) : m_nPort(0), 
                                     m_nInternetPort(0), 
                                     m_lTimeout(60),
                                     m_lMaxHops(0),
                                     m_hDoneEvent(NULL),
                                     m_lResponses(0),
                                     m_pSocket(NULL),
                                     m_pIOCP(NULL),
                                     m_bDone(FALSE)
{
    CRegKey reg;

    QueryPerformanceFrequency(&s_liCounterFreq);

    if(reg.Open(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\ISPChecker Client")) != ERROR_SUCCESS)
    {
        reg.Create(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\ISPChecker Client"));

        CoCreateGuid(&m_ClientID);

        reg.SetGUIDValue(_T("ClientID"), m_ClientID);
    }
    else
    {
        reg.QueryGUIDValue(_T("ClientID"), m_ClientID);
    }
}

CICMPTestImpl::~CICMPTestImpl(void)
{
    if(m_hDoneEvent != NULL)
        CloseHandle(m_hDoneEvent);

    if(m_pSocket != NULL)
    {
        m_pSocket->Close();
    }

    if(m_pIOCP != NULL)
    {
        m_pIOCP->Shutdown();
    }

    SAFE_RELEASE(m_pSocket);
    SAFE_RELEASE(m_pIOCP);

    WSACleanup();
}

HRESULT CICMPTestImpl::Init()
{
    HRESULT             hr;
    WSADATA             wsaData;
    CHAR                szHostName[MAX_PATH];
    hostent*            pHostEntry;
    sockaddr_in         sendAddr;
    sockaddr_in         recvAddr;

    // create event if necessary
    if(m_hDoneEvent == NULL)
    {
        m_hDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(m_hDoneEvent == NULL)
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            goto Cleanup;
        }
    }
    else
    {
        if(!ResetEvent(m_hDoneEvent))
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            goto Cleanup;
        }
    }

    // initialize winsock
    hr = WSAStartup(WINSOCK_VERSION, &wsaData);
    if(hr != 0)
    {
        hr = HRESULT_FROM_WIN32(hr);
        goto Cleanup;
    }

    //
    //  Now create the IO completion port and the sockets (only one if there's just one IP)
    //

	hr = CCompletionPort::CreateInstance(0, 0, THREAD_PRIORITY_NORMAL, &m_pIOCP);
	if(FAILED(hr))
	{
		goto Cleanup;
	}

    //
    //  Initialize the send socket
    //

	hr = CClientSocket::CreateInstance(&m_pSocket, m_pIOCP, m_pIOCP);
	if(FAILED(hr))
	{
		goto Cleanup;
	}

    sendAddr.sin_family = AF_INET;
    sendAddr.sin_addr.S_un.S_addr = INADDR_ANY;
    sendAddr.sin_port = 0;
    memset(&(sendAddr.sin_zero), 0, sizeof(sendAddr.sin_zero));

	hr = m_pSocket->Init(IPPROTO_UDP, &sendAddr, FALSE);

Cleanup:

    return hr;
}


STDMETHODIMP CICMPTestImpl::put_Address(BSTR newVal)
{
    m_cszAddress = newVal;

    return S_OK;
}

STDMETHODIMP CICMPTestImpl::put_Port(USHORT newVal)
{
    m_nPort = newVal;

    return S_OK;
}

STDMETHODIMP CICMPTestImpl::put_Timeout(LONG newVal)
{
    m_lTimeout = newVal;

    return S_OK;
}

STDMETHODIMP CICMPTestImpl::get_MaxHops(LONG* pVal)
{
    *pVal = m_lMaxHops;

    return S_OK;
}

STDMETHODIMP CICMPTestImpl::put_MaxHops(LONG newVal)
{
    m_lMaxHops = newVal;

    return S_OK;
}

HRESULT CICMPTestImpl::DoICMPTest(
    BSTR*   pResults
    )
{
    HRESULT             hr;
    sockaddr_in         sendAddr;
    sockaddr_in         serverAddr;
    LPBYTE              pBuffer;
    LARGE_INTEGER       liTickCount;
    PSOCKET_CALLBACK    pSocketCallback;

    m_lResponses = 0;

    if(pResults == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pResults = NULL;

    //
    // destination address
    //

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.S_un.S_addr = inet_addr(m_cszAddress);
    serverAddr.sin_port = m_nPort;
    memset(&(serverAddr.sin_zero), 0, sizeof(serverAddr.sin_zero));

    //
    //  Allocate receive buffers and set both sockets to listening
    //

    pBuffer = (LPBYTE)malloc(256);
    if(pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pSocketCallback = (PSOCKET_CALLBACK)malloc(sizeof(SOCKET_CALLBACK));
    pSocketCallback->pSocket = m_pSocket;
    QueryPerformanceCounter(&(pSocketCallback->liStartTickCount));

    hr = m_pSocket->ReceiveFrom(pBuffer, 256, this, MAKEQWORD((DWORD)pSocketCallback, 0));
    if(FAILED(hr))
        goto Cleanup;

    hr = BuildPingPacket((char**)&pBuffer, 0);
    if(FAILED(hr))
        goto Cleanup;

    // send packet to server and wait for completion or timeout, doesn't matter
    hr = m_pSocket->SendTo(pBuffer, sizeof(ICMPHEADER), &serverAddr, this, 0);
    if(FAILED(hr))
        goto Cleanup;

    m_pSocket->GetLocalAddress(&sendAddr);

    // initialize results string
    m_cszResults.Format(L"<ICMPTEST><REQUEST CLIENTADDR=\"%u.%u.%u.%u\" CLIENTPORT=\"%u\" SERVERADDR=\"%u.%u.%u.%u\" SERVERPORT=\"%u\"/>",
        sendAddr.sin_addr.S_un.S_un_b.s_b1,
        sendAddr.sin_addr.S_un.S_un_b.s_b2,
        sendAddr.sin_addr.S_un.S_un_b.s_b3,
        sendAddr.sin_addr.S_un.S_un_b.s_b4,
        sendAddr.sin_port,
        serverAddr.sin_addr.S_un.S_un_b.s_b1,
        serverAddr.sin_addr.S_un.S_un_b.s_b2,
        serverAddr.sin_addr.S_un.S_un_b.s_b3,
        serverAddr.sin_addr.S_un.S_un_b.s_b4,
        serverAddr.sin_port);

    //
    //  The event gets signalled everytime an icmp response is received.  If we timeout,
    //  that means we didn't get a response back in time.  And the host is unreachable.
    //  If we found the host, then the event will be signalled AND m_bDone will be set to true.
    //

    while(WaitForSingleObject(m_hDoneEvent, m_lTimeout * 1000) == WAIT_OBJECT_0 && !m_bDone) {}

    m_cszResults += L"</ICMPTEST>";

    *pResults = m_cszResults.AllocSysString();
    if(*pResults == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    m_cszResults.Empty();

    return hr;
}

HRESULT CICMPTestImpl::BuildPingPacket(char **ppbPacket, USHORT uPing)
{
    HRESULT     hr;
	USHORT		seq = 0;
	LPSTR       pbPayload = NULL;
	ICMPHEADER* pICMPHdr  = NULL;

	//-------------------------------------------------------------------------
	// 
	// 
	//
	*ppbPacket = (char *)malloc(sizeof(ICMPHEADER));
	if (!*ppbPacket)
	{
        hr = HRESULT_FROM_WIN32(GetLastError());
		goto Cleanup;
	}



	//-------------------------------------------------------------------------
	// Clear out the ICMP header portion of the buffer and initialize the rest
	// of the packet to something slightly less boring
	//
	pICMPHdr = (ICMPHEADER *)*ppbPacket;
	memset(pICMPHdr, 0, sizeof(ICMPHEADER));

	//-------------------------------------------------------------------------
	// Fill out the ICMP header information
	//
	//g_SeqMap.GenSeqNumber(&seq, 0, m_uHop, uPing);

	pICMPHdr->i_type  = 0x08;				// 0x08	= ICMP ECHO REQUEST
	pICMPHdr->i_code  = 0x00;
	pICMPHdr->i_id    = (USHORT)GetCurrentProcessId();
	pICMPHdr->i_seq   = seq;


	//-------------------------------------------------------------------------
	// Checksum must be calculated after the all portions of the ICMP request
	// are filled out
	//
	//pICMPHdr->i_cksum = CalcChecksum((USHORT*)(*ppbPacket), *pcbPacket);

	hr = S_OK;

Cleanup:

	return	hr;	
}

// CClientSocketCallback methods

HRESULT CICMPTestImpl::OnSocketConnect(
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CICMPTestImpl::OnSocketAccept(
                    CClientSocket *pListenSocket,
                    CClientSocket *pAcceptedSocket,
                    sockaddr_in *pLocalAddr,
                    sockaddr_in *pRemoteAddr,
                    HRESULT hrCallback,
                    QWORD qwCallbackArg )
{
    return E_NOTIMPL;
}

HRESULT CICMPTestImpl::OnSocketSend(
                    BYTE *pbBufferSent,
                    DWORD cbToSend,
                    DWORD cbSent,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CICMPTestImpl::OnSocketSendTo(
                    BYTE *pbBufferSent,
                    DWORD cbToSend,
                    DWORD cbSent,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CICMPTestImpl::OnSocketReceive(
                    BYTE *pbFilledInBuffer,
                    DWORD cbRead,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CICMPTestImpl::OnSocketReceiveFrom(
                    BYTE *pbFilledInBuffer,
                    DWORD cbRead,
                    sockaddr_in *pFilledInFrom,
                    HRESULT hrRecv,
                    QWORD qwCallbackArg )
{
    HRESULT                 hr;
    LPBYTE                  pBuffer;
    sockaddr_in             altAddr = *pFilledInFrom;
    sockaddr_in             clientAddr;
    int                     i;
    PSOCKET_CALLBACK        pSocketCallback = (PSOCKET_CALLBACK)LODWORD(qwCallbackArg);
    LARGE_INTEGER           liEndTickCount;
    DWORD                   dwLatency;
    DWORD                   cbProcessed;

    QueryPerformanceCounter(&liEndTickCount);
    dwLatency = (DWORD)(((liEndTickCount.QuadPart - pSocketCallback->liStartTickCount.QuadPart) * 1000)/s_liCounterFreq.QuadPart);

    CHAR szOutput[256];
    sprintf(szOutput, "start = %I64u, end = %I64u, freq = %I64u, latency = %u\r\n",
        pSocketCallback->liStartTickCount.QuadPart,
        liEndTickCount.QuadPart,
        s_liCounterFreq.QuadPart,
        dwLatency);
    OutputDebugStringA(szOutput);

    //
    //  Immediately submit another buffer for receiving.
    //

    pBuffer = (LPBYTE)malloc(256);
    if(pBuffer != NULL)
    {
        pSocketCallback->pSocket->ReceiveFrom(pBuffer, 256, this, qwCallbackArg);
    }

    //
    //  Process the buffer we received
    //

    if(hrRecv != 0)
    {
        // TODO handle returned socket error
        /*
        m_cszResults.AppendFormat(
            L"<RESPONSE ERROR=\"0x%08X\"/>",
            hrRecv);
        */
        SetEvent(m_hDoneEvent);
        hr = hrRecv;
        goto Cleanup;
    }

    pSocketCallback->pSocket->GetLocalAddress(&clientAddr);

    cbProcessed = 0;
    while(cbProcessed < cbRead)
    {
        PSERVER_PACKET pPacket = (PSERVER_PACKET)(pbFilledInBuffer + cbProcessed);

        m_cszResults.AppendFormat(
            L"<RESPONSE CLIENTADDRACTUAL=\"%u.%u.%u.%u\" "
                      L"CLIENTPORTACTUAL=\"%u\" "
                      L"CLIENTADDRSEEN=\"%u.%u.%u.%u\" "
                      L"CLIENTPORTSEEN=\"%u\" "
                      L"SERVERADDR=\"%u.%u.%u.%u\" "
                      L"SERVERPORT=\"%u\" "
                      L"LATENCY=\"%u\"/>",
            clientAddr.sin_addr.S_un.S_un_b.s_b1,
            clientAddr.sin_addr.S_un.S_un_b.s_b2,
            clientAddr.sin_addr.S_un.S_un_b.s_b3,
            clientAddr.sin_addr.S_un.S_un_b.s_b4,
            clientAddr.sin_port,
            pPacket->inaClientAddr.S_un.S_un_b.s_b1,
            pPacket->inaClientAddr.S_un.S_un_b.s_b2,
            pPacket->inaClientAddr.S_un.S_un_b.s_b3,
            pPacket->inaClientAddr.S_un.S_un_b.s_b4,
            pPacket->nClientPort,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b1,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b2,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b3,
            pFilledInFrom->sin_addr.S_un.S_un_b.s_b4,
            pFilledInFrom->sin_port,
            dwLatency);

        cbProcessed += sizeof(SERVER_PACKET);
    }

    if(InterlockedIncrement(&m_lResponses) == 24)
        SetEvent(m_hDoneEvent);

    //
    //  Free the buffer
    //

    free(pbFilledInBuffer);

    hr = S_OK;

Cleanup:

	return hr;
}

HRESULT CICMPTestImpl::OnSocketClose(
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by cchkcli.rc
//
#define IDS_PROJNAME                    100
#define IDR_CCHKCLI                     101
#define IDB_CCONNCHECKCLIENT            102
#define IDR_CCONNCHECKCLIENT            103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef STRICT
#define STRICT
#endif

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400	// Change this to the appropriate value to target Windows 2000 or later.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off ATL's hiding of some common and often safely ignored warning messages
#define _ATL_ALL_WARNINGS


#include "resource.h"
#include <atlbase.h>
#include <atlcom.h>
#include <atlconv.h>
#include <atlstr.h>
#include <atlcoll.h>
#include <atlenc.h>

using namespace ATL;

#include <wininet.h>
#include <wmsstd.h>
#include <conncheck.h>
#include "clisock.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchkcli\nattestimpl.h ===
#pragma once

typedef struct _tagSOCKET_CALLBACK
{
    CClientSocket*  pSocket;
    LARGE_INTEGER   liStartTickCount;
} SOCKET_CALLBACK, *PSOCKET_CALLBACK;

class CNATTestImpl :
    public CClientSocketCallback
{
private:
    CStringA            m_cszAddress;
    CStringA            m_cszInternetAddress;
    USHORT              m_nPort;
    USHORT              m_nInternetPort;
    LONG                m_lTimeout;
    GUID                m_ClientID;
    CStringW            m_cszResults;
    HANDLE              m_hDoneEvent;
    LONG                m_lResponses;
    CClientSocket*      m_pSendSocket;
    CClientSocket*      m_pRecvSocket;
	CCompletionPort*    m_pIOCP;

    static LARGE_INTEGER    s_liCounterFreq;

public:
    CNATTestImpl(void);
    ~CNATTestImpl(void);

    HRESULT Init(void);

// ICConnCheckClient
public:

    ULONG AddRef()
    {
		return 0;
    }

    ULONG Release()
    {
        return 0;
    } 

    // properties
    STDMETHOD(get_Address)(BSTR* pVal);
    STDMETHOD(put_Address)(BSTR newVal);
    STDMETHOD(get_Port)(USHORT* pVal);
    STDMETHOD(put_Port)(USHORT newVal);
    STDMETHOD(get_Timeout)(LONG* pVal);
    STDMETHOD(put_Timeout)(LONG newVal);
    STDMETHOD(get_ClientUID)(BSTR* pVal);
    STDMETHOD(get_DHCP)(VARIANT_BOOL* pVal);
    STDMETHOD(get_USBModem)(VARIANT_BOOL* pVal);
    STDMETHOD(get_ProxySettings)(BSTR* pVal);
    STDMETHOD(get_UPnPNAT)(BSTR* pVal);

    // methods
    STDMETHOD(DoNATTest)(BSTR* pVal);

// CClientSocketCallback
protected:

    virtual HRESULT OnSocketConnect(
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketAccept(
                        CClientSocket *pListenSocket,
                        CClientSocket *pAcceptedSocket,
                        sockaddr_in *pLocalAddr,
                        sockaddr_in *pRemoteAddr,
                        HRESULT hrCallback,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketSend(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketSendTo(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketReceive(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketReceiveFrom(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        sockaddr_in *pFilledInFrom,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketClose(
                        HRESULT hr,
                        QWORD qwCallbackArg );

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\consoleid\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchksvc\cchksvc.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xmgmtsrv.h

Abstract:


--*/

#pragma once

#ifndef _CCHKSVC_H_
#define _CCHKSVC_H_

class CChkSvc : 
	public CServerSocketCallback
{
public:

	IMPLEMENT_REFCOUNT;

	CChkSvc();

	~CChkSvc();

	HRESULT Init();

    void Shutdown();

	HRESULT Go();

protected:

    virtual HRESULT OnSocketConnect(
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketAccept(
                        CServerSocket *pListenSocket,
                        CServerSocket *pAcceptedSocket,
                        sockaddr_in *pLocalAddr,
                        sockaddr_in *pRemoteAddr,
                        HRESULT hrCallback,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketSend(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketSendTo(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketReceive(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketReceiveFrom(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        sockaddr_in *pFilledInFrom,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual HRESULT OnSocketClose(
                        HRESULT hr,
                        QWORD qwCallbackArg );

	HRESULT CreateSocket(CServerSocket* &, sockaddr_in&);

	CCompletionPort*    m_pIOCP;
	
    CServerSocket**     m_pListenSocketArray;
    DWORD               m_dwNumListenSockets;

    CServerSocket**     m_pSendSocketArray;
    DWORD               m_dwNumSendSockets;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchksvc\cchksvc.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xmgmtsrv.cpp

Abstract:

--*/

#include "precomp.h"
#include "cchksvc.h"

XomDefineArea(DefaultTrace);
XomDefineArea(Log);

CXomSettingEx g_ListenAddrs(CXomOption(CXomSetting::O_NAME, "Settings.ListenAddresses"));
CXomSettingEx g_ListenPorts(CXomOption(CXomSetting::O_NAME, "Settings.ListenPorts"  ));
CXomSettingEx g_SendAddr   (CXomOption(CXomSetting::O_NAME, "Settings.SendAddress"  ));

CChkSvc::CChkSvc()
{
	m_pIOCP = NULL;
	m_pSendSocketArray = NULL;
    m_pListenSocketArray = NULL;
    m_dwNumListenSockets = 0;
    m_dwNumSendSockets = 0;
}

CChkSvc::~CChkSvc()
{
    Shutdown();
}

HRESULT CChkSvc::CreateSocket(
    CServerSocket* &    pSocket,
    sockaddr_in&        addr
    )
{
    HRESULT hr;

    // create socket

    hr = CServerSocket::CreateInstance(&pSocket, m_pIOCP, m_pIOCP);
    if(FAILED(hr))
        goto Cleanup;

    // initialize socket

    hr = pSocket->Init(IPPROTO_UDP, &addr, FALSE);
    if(FAILED(hr))
        goto Cleanup;

    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT CChkSvc::Init()
{
	HRESULT             hr = S_OK;
    sockaddr_in         sendAddr;
    CXomParamList       addrList;
    CXomParamList       portList;
    DWORD               dwCur;

    //
    //  First initialize configuration and logging
    //

    hr = g_xomcentral.Init("cchksvc", "cchksvc.ini");
    if(FAILED(hr))
        goto Cleanup;

    hr = addrList.Parse(g_ListenAddrs.GetStr());
    if(FAILED(hr))
        goto Cleanup;

    hr = portList.Parse(g_ListenPorts.GetStr());
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Allocate socket arrays
    //

    m_dwNumListenSockets = addrList.GetCount() * portList.GetCount();
    m_dwNumSendSockets = addrList.GetCount() + portList.GetCount() + 1;
    m_pListenSocketArray = (CServerSocket**)XAllocZ(sizeof(CServerSocket*) * m_dwNumListenSockets);
    m_pSendSocketArray = (CServerSocket**)XAllocZ(sizeof(CServerSocket*) * m_dwNumSendSockets);
    if(m_pListenSocketArray == NULL || m_pSendSocketArray == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    //  Now create the IO completion port and the sockets (only one if there's just one IP)
    //

	hr = CCompletionPort::CreateInstance(
		0, 0, THREAD_PRIORITY_NORMAL, &m_pIOCP);

	if(FAILED(hr))
	{
		goto Cleanup;
	}

    //
    //  Create an initialize all listen sockets
    //

    for(dwCur = 0; dwCur < m_dwNumListenSockets; ++dwCur)
    {
        sockaddr_in     listenAddr;
        CServerSocket*  pSocket;

        listenAddr.sin_family = AF_INET;
        listenAddr.sin_addr.S_un.S_addr = inet_addr(addrList.GetParam(dwCur / addrList.GetCount()));
        listenAddr.sin_port = (USHORT)(strtoul(portList.GetParam(dwCur % portList.GetCount()), NULL, 10));

        hr = CreateSocket(pSocket, listenAddr);
        if(FAILED(hr))
            goto Cleanup;

        // put socket into array

        m_pListenSocketArray[dwCur] = pSocket;
    }

    //  Now create and initialize the send sockets.
    memset(&sendAddr, 0, sizeof(sockaddr_in));
    sendAddr.sin_family = AF_INET;
    for(dwCur = 0; dwCur < addrList.GetCount(); ++dwCur)
    {
        CServerSocket*  pSocket;

        sendAddr.sin_addr.S_un.S_addr = inet_addr(addrList.GetParam(dwCur));
        sendAddr.sin_port = 0;
        hr = CreateSocket(pSocket, sendAddr);
        if(FAILED(hr))
            goto Cleanup;

        m_pSendSocketArray[dwCur] = pSocket;
    }

    for(dwCur = 0; dwCur < portList.GetCount(); ++dwCur)
    {
        CServerSocket*  pSocket;

        sendAddr.sin_addr.S_un.S_addr = inet_addr(g_SendAddr.GetStr());
        sendAddr.sin_port = (USHORT)(strtoul(portList.GetParam(dwCur % portList.GetCount()), NULL, 10));
        hr = CreateSocket(pSocket, sendAddr);
        if(FAILED(hr))
            goto Cleanup;

        m_pSendSocketArray[dwCur + addrList.GetCount()] = pSocket;
    }

    //
    //  Final socket is send addr and different port
    //

    {
        CServerSocket*  pSocket;

        sendAddr.sin_addr.S_un.S_addr = inet_addr(g_SendAddr.GetStr());
        sendAddr.sin_port = 0;
        hr = CreateSocket(pSocket, sendAddr);
        if(FAILED(hr))
            goto Cleanup;
        // put socket into array

        m_pSendSocketArray[addrList.GetCount() + portList.GetCount()] = pSocket;
    }

Cleanup:

	return hr;
}

void CChkSvc::Shutdown()
{
    DWORD dwCur;
    if(m_pListenSocketArray != NULL)
    {
        for(dwCur = 0; dwCur < m_dwNumListenSockets; ++dwCur)
        {
            if(m_pListenSocketArray[dwCur] != NULL)
            {
                m_pListenSocketArray[dwCur]->Close();
                m_pListenSocketArray[dwCur]->Release();
            }
        }

        XFree(m_pListenSocketArray);
        m_pListenSocketArray = NULL;
    }

    if(m_pSendSocketArray != NULL)
    {
        for(dwCur = 0; dwCur < m_dwNumSendSockets; ++dwCur)
        {
            if(m_pSendSocketArray[dwCur] != NULL)
            {
                m_pSendSocketArray[dwCur]->Close();
                m_pSendSocketArray[dwCur]->Release();
            }
        }

        XFree(m_pSendSocketArray);
        m_pSendSocketArray = NULL;
    }

    if(m_pIOCP != NULL)
    {
        m_pIOCP->Shutdown();
    }

    SAFE_RELEASE(m_pIOCP);

    g_xomcentral.Term();
}

HRESULT CChkSvc::Go()
{
	HRESULT hr = S_OK;
	LPBYTE  pBuffer;
    DWORD   dwCur;

    for(dwCur = 0; dwCur < m_dwNumListenSockets; ++dwCur)
    {
        pBuffer = (LPBYTE)XAlloc(256);
        hr = m_pListenSocketArray[dwCur]->ReceiveFrom(
                    pBuffer, 
                    256, 
                    this, 
                    MAKEQWORD( (DWORD)m_pListenSocketArray[dwCur], 0 ));

	    if(FAILED(hr))
	    {
            XFree(pBuffer);
		    goto Cleanup;
	    }
    }
    

Cleanup:

	return hr;
}

HRESULT CChkSvc::OnSocketConnect(
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CChkSvc::OnSocketAccept(
                    CServerSocket *pListenSocket,
                    CServerSocket *pAcceptedSocket,
                    sockaddr_in *pLocalAddr,
                    sockaddr_in *pRemoteAddr,
                    HRESULT hrCallback,
                    QWORD qwCallbackArg )
{
    return E_NOTIMPL;
}

HRESULT CChkSvc::OnSocketSend(
                    BYTE *pbBufferSent,
                    DWORD cbToSend,
                    DWORD cbSent,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CChkSvc::OnSocketSendTo(
                    BYTE *pbBufferSent,
                    DWORD cbToSend,
                    DWORD cbSent,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CChkSvc::OnSocketReceive(
                    BYTE *pbFilledInBuffer,
                    DWORD cbRead,
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}

HRESULT CChkSvc::OnSocketReceiveFrom(
                    BYTE *pbFilledInBuffer,
                    DWORD cbRead,
                    sockaddr_in *pFilledInFrom,
                    HRESULT hrRecv,
                    QWORD qwCallbackArg )
{
    HRESULT         hr;
    LPBYTE          pBuffer;
    PCLIENT_PACKET  pClientPacket;
    SERVER_PACKET   ServerPacket;
    sockaddr_in     recvAddr;
    sockaddr_in     altAddr = *pFilledInFrom;
    int             i;
    CServerSocket*  pSocket = (CServerSocket*)LODWORD(qwCallbackArg);
    CServerSocket*  pSendSocket;
    DWORD           dwCurSock;

    //
    //  Immediately submit another buffer for receiving.
    //

    pBuffer = (LPBYTE)XAlloc(256);
    if(pBuffer != NULL)
    {
        pSocket->ReceiveFrom(pBuffer, 256, this, qwCallbackArg);
    }

    //
    //  Process the buffer we received
    //

    if(hrRecv != 0)
    {
        // TODO handle returned socket error
        hr = hrRecv;
        goto Cleanup;
    }

    if(cbRead < sizeof(CLIENT_PACKET))
    {
        // TODO not enough data in packet
        hr = E_FAIL;
        goto Cleanup;
    }

    pSocket->GetLocalAddress(&recvAddr);

    pClientPacket = (PCLIENT_PACKET)pbFilledInBuffer;
    altAddr.sin_port = pClientPacket->nAltPort;

    ServerPacket.inaClientAddr.S_un.S_addr = pFilledInFrom->sin_addr.S_un.S_addr;
    ServerPacket.nClientPort               = pFilledInFrom->sin_port;

    //
    //  Send packets back on same socket.
    //

    for(i = 0; i < 3; ++i)
    {
        pSocket->SendTo((LPBYTE)&ServerPacket, sizeof(SERVER_PACKET), pFilledInFrom, this, qwCallbackArg);
    }

    for(i = 0; i < 3; ++i)
    {
        pSocket->SendTo((LPBYTE)&ServerPacket, sizeof(SERVER_PACKET), &altAddr, this, qwCallbackArg);
    }

    //
    //  Send packets back on socket with same addr, different port
    //

    pSendSocket = NULL;
    for(dwCurSock = 0; dwCurSock < m_dwNumSendSockets; ++dwCurSock)
    {
        sockaddr_in addr;

        m_pSendSocketArray[dwCurSock]->GetLocalAddress(&addr);

        if(addr.sin_addr.S_un.S_addr == recvAddr.sin_addr.S_un.S_addr &&
            addr.sin_port            != recvAddr.sin_port)
            pSendSocket = m_pSendSocketArray[dwCurSock];
    }

    if(pSendSocket != NULL)
    {
        for(i = 0; i < 3; ++i)
        {
            pSendSocket->SendTo((LPBYTE)&ServerPacket, sizeof(SERVER_PACKET), pFilledInFrom, this, qwCallbackArg);
        }

        for(i = 0; i < 3; ++i)
        {
            pSendSocket->SendTo((LPBYTE)&ServerPacket, sizeof(SERVER_PACKET), &altAddr, this, qwCallbackArg);
        }
    }

    //
    //  Send packets back on socket with different addr, same port
    //

    pSendSocket = NULL;
    for(dwCurSock = 0; dwCurSock < m_dwNumSendSockets; ++dwCurSock)
    {
        sockaddr_in addr;

        m_pSendSocketArray[dwCurSock]->GetLocalAddress(&addr);

        if(addr.sin_addr.S_un.S_addr != recvAddr.sin_addr.S_un.S_addr &&
            addr.sin_port            == recvAddr.sin_port)
            pSendSocket = m_pSendSocketArray[dwCurSock];
    }

    if(pSendSocket != NULL)
    {
        for(i = 0; i < 3; ++i)
        {
            pSendSocket->SendTo((LPBYTE)&ServerPacket, sizeof(SERVER_PACKET), pFilledInFrom, this, qwCallbackArg);
        }

        for(i = 0; i < 3; ++i)
        {
            pSendSocket->SendTo((LPBYTE)&ServerPacket, sizeof(SERVER_PACKET), &altAddr, this, qwCallbackArg);
        }
    }

    //
    //  Send packets back on socket with different addr, different port
    //

    pSendSocket = NULL;
    for(dwCurSock = 0; dwCurSock < m_dwNumSendSockets; ++dwCurSock)
    {
        sockaddr_in addr;

        m_pSendSocketArray[dwCurSock]->GetLocalAddress(&addr);

        if(addr.sin_addr.S_un.S_addr != recvAddr.sin_addr.S_un.S_addr &&
            addr.sin_port            != recvAddr.sin_port)
            pSendSocket = m_pSendSocketArray[dwCurSock];
    }

    if(pSendSocket != NULL)
    {
        for(i = 0; i < 3; ++i)
        {
            pSendSocket->SendTo((LPBYTE)&ServerPacket, sizeof(SERVER_PACKET), pFilledInFrom, this, qwCallbackArg);
        }

        for(i = 0; i < 3; ++i)
        {
            pSendSocket->SendTo((LPBYTE)&ServerPacket, sizeof(SERVER_PACKET), &altAddr, this, qwCallbackArg);
        }
    }

    //
    //  Free the buffer
    //

    XFree(pbFilledInBuffer);

    hr = S_OK;

Cleanup:

	return hr;
}

HRESULT CChkSvc::OnSocketClose(
                    HRESULT hr,
                    QWORD qwCallbackArg )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchksvc\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Service handler and entry point

--*/

#include "precomp.h"

#include "cchksvc.h"

CChkSvc g_oSrv;

class CService : public CNTService
{
public:

    CService() :
        CNTService(
            "cchksvc",
            "XBox Connectivity Check Service",
            "Receives and echoes connectivity check traffic.",
            "")
    {
    }

    virtual HRESULT InitService (
        DWORD dwArgc, 
        LPTSTR* ppszArgv
    )
    {
        HRESULT hr = S_OK;

        //
        // Initialize Winsock
        //

        WSADATA wsaData;

        int rc = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
        if( 0 != rc )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            goto lDone;
        }
        
    lDone:

        return hr;
    }

    virtual HRESULT RunService(
        BOOL* pfServiceRan
    )
    {
        HRESULT hr;

		hr = g_oSrv.Init();
        if(FAILED(hr))
        {
            *pfServiceRan = FALSE;
            return hr;
        }

		hr = g_oSrv.Go();
        if(FAILED(hr))
        {
            *pfServiceRan = FALSE;
            return hr;
        }
		
		WaitForSingleObject(ShutdownEvent(), INFINITE);
		
        *pfServiceRan = TRUE;

        g_oSrv.Shutdown();

        return S_OK;
    }
};

// The instance of our service

CService g_Service;

// The CNTService library depends on the following global

CNTService* g_pService = &g_Service;

void __cdecl main(
    int argc, 
    char** argv
)
/*++

Routine Description:

    entry point. Hands execution control over to the NT service class.

Arguments:

    arc - count of arguments
    argv - array of arguments

Return Value:

    None

--*/ 
{
    g_Service.ProcessMain(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\consoleid\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\cchksvc\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <wsockntp.h>
#include <Iphlpapi.h>
#include <Sddl.h>

#include <wmsstd.h>

#if defined(_DEBUG)
#if defined(USE_PAGE_HEAP)
#include "pageheap.hpp"
#else
#include "debugheap.hpp"
#endif
#else
#include "blendedheap.hpp"
#endif

#include <xalloc.h>
#include <ntservice.h>
#include <servsock.h>
#include <vptrarr.h>
#include <xlocks.h>
#include <tcpcnt.h>
#include <xmgmt.h>

#include <conncheck.h>

#ifndef ASSERT
#define ASSERT XONASSERT
#endif

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x)/sizeof(x[0]))
#endif

using namespace xlocks;

#endif // #ifndef _XCSSERVER_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\consoleid\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\connchck\inc\conncheck.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once
#ifndef __CONNCHECK_H
#define __CONNCHECK_H

#pragma pack(push, 1)

typedef struct _CLIENT_PACKET
{
    USHORT  nAltPort;
} CLIENT_PACKET, *PCLIENT_PACKET;

typedef struct _SERVER_PACKET
{
    IN_ADDR inaClientAddr;
    USHORT  nClientPort;
} SERVER_PACKET, *PSERVER_PACKET;

#pragma pack(pop)


#endif // __CONNCHECK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CreditCardGenerator\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\consoleid\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_consoleid_none_12.4.56.0_none_e3fe0a6b5a053947
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=consoleid
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35.manifest
XP_MANIFEST_PATH=manifests\msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35.cat
XP_CATALOG_PATH=manifests\msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35.cat
XP_PAYLOAD_PATH=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=consoleid,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\consoleid\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_consoleid_none_12.4.56.0_none_e3fe0a6b5a053947
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=consoleid
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35.manifest
XP_MANIFEST_PATH=manifests\msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35.cat
XP_CATALOG_PATH=manifests\msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35.cat
XP_PAYLOAD_PATH=msil_consoleid_no-public-key_12.4.56.0_x-ww_97abae35
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=consoleid,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\consoleid\consoleid.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.consoleid
{
    public class ConsoleID
    {
        static void Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine();
            Console.WriteLine("Full output for a single value:");
            Console.WriteLine("  consoleid -direction:[fromdash|todash] -value:<consoleid-to-be-converted>");
            Console.WriteLine("  consoleid -d:[fd|td] -v:<consoleid-to-be-converted>");
            Console.WriteLine();
            Console.WriteLine("Short output for multiple values, reads input from standard input:");
            Console.WriteLine("  consoleid -direction:[fromdash|todash]");
            Console.WriteLine();
        }

        public static string ConsoleIDFromDash(string s)
        {
            uint lastDigit = UInt32.Parse(s.Substring(s.Length - 1, 1));

            string srest = s.Substring(0, s.Length - 1);
            ulong rest = UInt64.Parse(srest);

            ulong id = (rest << 4) | lastDigit;

            return id.ToString("d");
        }

        public static string ConsoleIDToDash(string s)
        {
            ulong i;
            if (s.StartsWith("0x"))
            {
                i = UInt64.Parse(s.Substring(2), NumberStyles.HexNumber);
            }
            else
            {
                i = UInt64.Parse(s);
            }
            
            // only 40 bits are used
            i &= 0xFFFFFFFFFF;

            ulong lastFour = i & 0xF;
            ulong rest = i >> 4;

            string dash = rest.ToString("d") + lastFour.ToString("d");
            return dash.PadLeft(12, '0');
        }

        public static void DisplayConsoleIDFromDash(string s)
        {
            string cid = ConsoleIDFromDash(s);
            byte[] bin = BitConverter.GetBytes(ulong.Parse(cid));
            Console.WriteLine("Decimal  : {0}", cid);
            Console.WriteLine("Binary   : {0:X2} {1:X2} {2:X2} {3:X2} {4:X2}", bin[0], bin[1], bin[2], bin[3], bin[4]);
            Console.WriteLine("Dash     : {0}", s);
            Console.WriteLine("Gamertag : XE.{0}", s);
        }

        static void Main(string [] rawArgs)
        {
            NamedArgParser args = new NamedArgParser();
            args.Parse(rawArgs);

            string value = args["value"];
            if (value == null)
                value = args["v"];

            string action = args["direction"];
            if (action == null)
                action = args["d"];
            if (action == null)
                action = "";

            try
            {
                switch(action.ToLower())
                {
                    case "fromdash":
                    case "fd":
                        if (value != null)
                        {
                            DisplayConsoleIDFromDash(value);
                        }
                        else
                        {
                            string s;
                            while ((s = Console.ReadLine()) != null)
                                Console.WriteLine(ConsoleIDFromDash(s));
                        }
                        break;

                    case "todash":
                    case "td":
                        if (value != null)
                        {
                            DisplayConsoleIDFromDash(ConsoleIDToDash(value));
                        }
                        else
                        {
                            string s;
                            while ((s = Console.ReadLine()) != null)
                                Console.WriteLine(ConsoleIDToDash(s));
                        }
                        break;
                        
                    default:
                        Usage();
                        break;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                Usage();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolcrldump.h ===
/*******************************************************************
*
*    DESCRIPTION: crltoolcrldump.h
*                   Dump a crl to verify it.
*
*******************************************************************/

#pragma once;

class CrlDumper: public UnCopyable
{
public:
    CrlDumper(void);
    ~CrlDumper();
    HRESULT Init(wchar_t const * wzCrlFileName);
    HRESULT DumpCrl(void);

private:
    HRESULT LoadEncodedCrl(void);
    HRESULT DecodeCrl(void);
    HRESULT DumpCrlBasics(void) const;
    static char const * GetCrlVersionString(DWORD dwVer);
    static void InlinePrintFileTime(FILETIME const ft);
    HRESULT DumpCrlExtensions(void) const;
    HRESULT DumpCrlEntries(void) const;

    CTinyWStr _wstrCrlFileName;
    BYTE * _pbEncodedCrl;
    UINT _cbEncodedCrl;
    CRL_INFO * _pCrlInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolcrldump.cpp ===
/*******************************************************************
*
*    DESCRIPTION: crltoolcrldump.cpp
*                   Dump a crl to verify it.
*
*******************************************************************/

#include "stdafx.h"
#include "crltoolcrldump.h"


//
// Set up our memory management for the crypto api.
//
static CRYPT_DECODE_PARA CrlToolMemMgr =
{
    sizeof(CRYPT_DECODE_PARA),
    CrlToolAlloc,
    CrlToolFree
};



//
// Simple constructor/destructor.
//
CrlDumper::CrlDumper(void)
    : _pbEncodedCrl(NULL)
    , _cbEncodedCrl(0)
    , _pCrlInfo(NULL)
{}

CrlDumper::~CrlDumper()
{
    CrlToolMemMgr.pfnFree(_pbEncodedCrl);
    CrlToolMemMgr.pfnFree(_pCrlInfo);
}


//
// Straight-forward init function.
//
HRESULT CrlDumper::Init(wchar_t const * const wzCrlFileName)
{
    return CopyToStr(_wstrCrlFileName, wzCrlFileName);
}


//
// Actually dump the crl.
//
HRESULT CrlDumper::DumpCrl(void)
{
    HRESULT hr = S_OK;

    ON_ERROR_GOTO(this->LoadEncodedCrl());

    ON_ERROR_GOTO(this->DecodeCrl());

    ON_ERROR_GOTO(this->DumpCrlBasics());

    ON_ERROR_GOTO(this->DumpCrlExtensions());

    ON_ERROR_GOTO(this->DumpCrlEntries());

Error:
    return hr;
}


//
// Loads the encoded/signed crl into a memory buffer.
//
HRESULT CrlDumper::LoadEncodedCrl(void)
{
    HRESULT hr = S_OK;

    UINT cbFile = 0;
    BYTE * pbFile = NULL;

    // Load the buffer.
    (HRESULT)LoadBufferFromFile(_wstrCrlFileName.cstr(), pbFile, &cbFile);
    pbFile = reinterpret_cast<BYTE*>(CrlToolMemMgr.pfnAlloc(cbFile));
    ON_NO_MEM_GOTO(pbFile);
    ON_ERROR_GOTO(LoadBufferFromFile(_wstrCrlFileName.cstr(), pbFile, &cbFile));

    // Hand off the data.
    _pbEncodedCrl = pbFile;
    pbFile = NULL;
    _cbEncodedCrl = cbFile;

Error:
    CrlToolMemMgr.pfnFree(pbFile);
    return hr;
}


//
// Decodes our buffer of data into a CRL_INFO.
//
HRESULT CrlDumper::DecodeCrl(void)
{
    HRESULT hr = S_OK;
    CERT_SIGNED_CONTENT_INFO * pSignedContent = NULL;
    DWORD cbSignedContent = 0;
    CRL_INFO * pCrlInfo = NULL;
    DWORD cbCrlInfo = 0;

    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptDecodeObjectEx(
                                        X509_ASN_ENCODING,
                                        X509_CERT,
                                        _pbEncodedCrl,
                                        _cbEncodedCrl,
                                        CRYPT_DECODE_ALLOC_FLAG,
                                        &CrlToolMemMgr,
                                        &pSignedContent,
                                        &cbSignedContent));

    // TODO: Best to verify the signature, but I'm not.

    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptDecodeObjectEx(
                                        X509_ASN_ENCODING,
                                        X509_CERT_CRL_TO_BE_SIGNED,
                                        pSignedContent->ToBeSigned.pbData,
                                        pSignedContent->ToBeSigned.cbData,
                                        CRYPT_DECODE_ALLOC_FLAG,
                                        &CrlToolMemMgr,
                                        &pCrlInfo,
                                        &cbCrlInfo));

    _pCrlInfo = pCrlInfo;
    pCrlInfo = NULL;

Error:
    FreeCrl(pCrlInfo, CrlToolMemMgr.pfnFree);

    return hr;
}


//
// Dump the basic properties of the CRL. But don't dump the CRL_ENTRYs.
//
HRESULT CrlDumper::DumpCrlBasics(void) const
{
    HRESULT hr = S_OK;

    printf("CRL_INFO:\n");
    printf("    dwVersion:          %s\n", this->GetCrlVersionString(_pCrlInfo->dwVersion));
    printf("    SignatureAlgorithm:\n");
    printf("        pszObjId:       %s\n", _pCrlInfo->SignatureAlgorithm.pszObjId);
    if (strcmp(_pCrlInfo->SignatureAlgorithm.pszObjId, szOID_RSA_SHA1RSA) == 0)
    {
        printf("                            This is szOID_RSA_SHA1RSA.\n");
    }
    else
    {
        printf("                            This is *NOT* szOID_RSA_SHA1RSA.\n");
    }
    printf("        Parameters:\n");
    printf("            cbData:     0x%X\n", _pCrlInfo->SignatureAlgorithm.Parameters.cbData);
    printf("            pbData:     0x%X\n", *(_pCrlInfo->SignatureAlgorithm.Parameters.pbData));
    printf("            pbData:     (should be unused--verify that cbData is 0)\n");
    printf("    Issuer:\n");
    printf("        cbData:         0x%X\n", _pCrlInfo->Issuer.cbData);
    printf("        pbData:         (not sure how to print this)\n");
    printf("    ThisUpdate:         ");
    this->InlinePrintFileTime(_pCrlInfo->ThisUpdate);
    printf("\n");
    printf("    NextUpdate:         ");
    this->InlinePrintFileTime(_pCrlInfo->NextUpdate);
    printf("\n");

    return hr;
}


//
// Get a string version of a CRL version.
//
char const * CrlDumper::GetCrlVersionString(DWORD const dwVer)
{
    switch (dwVer)
    {
        case CRL_V1: return "CRL_V1";
        case CRL_V2: return "CRL_V2";
        default: return "Uknown Version";
    }
}


//
// Prints a filetime, but not a carrige return.
//
void CrlDumper::InlinePrintFileTime(FILETIME const ft)
{
    char sz[1024] = {0};
    SYSTEMTIME st;

    if (!FileTimeToSystemTime(&ft, &st))
    {
        printf("Invalid FILETIME");
    }

    GetDateFormatA(NULL /*Locale*/, 0 /*dwFlags*/, &st, NULL /*lpformat*/, sz, array_size(sz));
    printf("%s : ", sz);
    GetTimeFormatA(NULL /*Locale*/, 0 /*dwFlags*/, &st, NULL /*lpFormat*/, sz, array_size(sz));
    printf(sz);
}


//
// Loop through all the extensions in the CRL and dump then.
//
HRESULT CrlDumper::DumpCrlExtensions(void) const
{
    HRESULT hr = S_OK;

    printf("    cExtension:         %d\n", _pCrlInfo->cExtension);
    for (DWORD idx = 0; idx < _pCrlInfo->cExtension; ++idx)
    {
        printf("    rgExtension[%d]:\n", idx);
        printf("        fCritical:      %s\n", _pCrlInfo->rgExtension[idx].fCritical ? "TRUE" : "FALSE");
        printf("        pszObjId:       %s\n", _pCrlInfo->rgExtension[idx].pszObjId);
        if (strcmp(szOID_ISSUING_DIST_POINT, _pCrlInfo->rgExtension[idx].pszObjId) == 0)
        {
            printf("                        This is a distribution point extension.\n");
            printf("                        (I should add code to decode the distribution point itself.)\n");
        }
        else
        {
            printf("            Unknown extension.\n");
        }
    }
    return hr;
}


//
// Loop through all the entries in our CRL and dump them.
//
HRESULT CrlDumper::DumpCrlEntries(void) const
{
    HRESULT hr = S_OK;
    printf("    cCRLEntry:          %d\n", _pCrlInfo->cCRLEntry);
    for (DWORD idx = 0; idx < _pCrlInfo->cCRLEntry; ++idx)
    {
        printf("    rgCRLEntry[%d]:\n", idx);
        printf("        RevocationDate: ");
        this->InlinePrintFileTime(_pCrlInfo->rgCRLEntry[idx].RevocationDate);
        printf("\n");
        printf("        SerialNumber:\n");
        printf("            cbData: %d\n", _pCrlInfo->rgCRLEntry[idx].SerialNumber.cbData);
        printf("            pbData: 0x");
        for (DWORD idxByte = 0; idxByte < _pCrlInfo->rgCRLEntry[idx].SerialNumber.cbData; ++idxByte)
        {
            printf("%02X", static_cast<unsigned int>(_pCrlInfo->rgCRLEntry[idx].SerialNumber.pbData[idxByte]));
        }
        printf("\n");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolcrlgen.cpp ===
/*******************************************************************
*
*    DESCRIPTION: crltoolcrlgen.h
*                   Code to actually generate a crl.
*
*******************************************************************/

#include "stdafx.h"
#include "crltoolcrlgen.h"
// defined but not used for cryptohelper.h include
struct XKERB_PA_XBOX_PPA;
#include "cryptohelper.h"


//
// Wrapper to get a string setting.
//
static HRESULT GetSetting(wchar_t const * const wzName, BSTR * pbstrValue)
{
    using namespace XblConfig;

    HRESULT hr = S_OK;

    CComPtr<XblConfig::IConfig> spiConfig;
    CComBSTR bstrName;
    CComBSTR bstrValue;

    // RUNCODE
    ON_NO_MEM_GOTO(bstrName = wzName);
    ON_ERROR_GOTO(spiConfig.CoCreateInstance(__uuidof(XblConfig::ConfigInterop)));
    ON_ERROR_GOTO(spiConfig->GetSetting(bstrName, &bstrValue));

    *pbstrValue = bstrValue.Detach();

Error:
    return hr;
}


//
// Set up our memory management for the crypto api.
//
static CRYPT_ENCODE_PARA CrlToolMemMgr =
{
    sizeof(CRYPT_ENCODE_PARA),
    CrlToolAlloc,
    CrlToolFree
};



//
// Simple constructor/destructor.
//
CrlGenerator::CrlGenerator(void)
    : _pCrlEntries(NULL)
    , _cCrlEntries(0)
    , _callocCrlEntries(0)
    , _pbSignedCrl(NULL)
    , _cbSignedCrl(0)
    , _pIssuerCert(NULL)
{
    memset(&_crlInfo, 0, sizeof(_crlInfo));
}

CrlGenerator::~CrlGenerator()
{
    this->ResetCrl();
}


//
// Reset our CRL (and actually our cert as well...)
//
void CrlGenerator::ResetCrl(void)
{
    FreeCrl(&_crlInfo, CrlToolMemMgr.pfnFree);

    if (_pIssuerCert != NULL)
    {
        CertFreeCertificateContext(_pIssuerCert);
    }

    memset(&_crlInfo, 0, sizeof(_crlInfo));
}


//
// Straight-forward init function.
//
HRESULT CrlGenerator::Init(wchar_t const * const wzCrlFileName, FILETIME const * const pftNextCrl)
{
    HRESULT hr = S_OK;

    ON_BAD_ARG_GOTO(pftNextCrl != NULL);
    ON_ERROR_GOTO(CopyToStr(_wstrCrlFileName, wzCrlFileName));
    _ftNextCrl = *pftNextCrl;

Error:
    return hr;
}


//
// Actually do the work to generate the CRL.
//
HRESULT CrlGenerator::GenerateCrl(void)
{
    HRESULT hr = S_OK;

    ON_ERROR_GOTO(this->InitCrl());

    ON_ERROR_GOTO(this->AddCrlEntries());

    ON_ERROR_GOTO(this->SignCrl());

    ON_ERROR_GOTO(this->WriteCrlToFile());

Error:
    return hr;
}


//
// Initializes the basic elements of the CRL.
//
HRESULT CrlGenerator::InitCrl(void)
{
    static wchar_t const * const XBL_CERT_ISSUER_STORE = L"MY";
    static DWORD const XBL_CERT_ISSUER_STORE_FLAGS = (CERT_STORE_OPEN_EXISTING_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE);
    static DWORD const ENCODING_TYPE = (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING);
    static wchar_t const * const ISSUER_CERT_NAME = L"xmstv_issuerCertName";

    HRESULT hr = S_OK;
    CComBSTR bstrIssuerName;
    SYSTEMTIME st;

    // Super-simple crl members.
    _crlInfo.dwVersion = CRL_V2;
    _crlInfo.SignatureAlgorithm.pszObjId = szOID_RSA_SHA1RSA;

    // Get the Issuer information for our crl.
    ON_ERROR_GOTO(GetSetting(ISSUER_CERT_NAME, &bstrIssuerName));
    PCCERT_CONTEXT pIssuerCert = FindCertificate(
                        bstrIssuerName,
                        XBL_CERT_ISSUER_STORE,
                        XBL_CERT_ISSUER_STORE_FLAGS,
                        ENCODING_TYPE);
    if (pIssuerCert == NULL)
    {
        ON_ERROR_GOTO(E_FAIL);
    }
    _pIssuerCert = pIssuerCert;
    pIssuerCert = NULL;
    _crlInfo.Issuer = _pIssuerCert->pCertInfo->Subject;

    // Time-related properties. Note that we are declaring that
    // the next update will come out in a year. Whatev.
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &(_crlInfo.ThisUpdate));
    _crlInfo.NextUpdate = CompareFileTime(&_ftNextCrl, &_pIssuerCert->pCertInfo->NotAfter) < 0 ? _ftNextCrl : _pIssuerCert->pCertInfo->NotAfter;

    ON_ERROR_GOTO(AddDistributionPoint());

Out:
    return hr;
Error:
    this->ResetCrl();
    if (pIssuerCert != NULL)
    {
        CertFreeCertificateContext(pIssuerCert);
    }
    goto Out;
}


//
// Adds the distribution point (as an extension) to the CRL.
// Fairly straight-forward, even though there's more code than you'd think.
//
HRESULT CrlGenerator::AddDistributionPoint(void)
{
    static wchar_t const * const DISTRIBUTION_POINT_NAME = L"xmstv_crldp";

    HRESULT hr = S_OK;
    CERT_ALT_NAME_ENTRY name = {0};
    CComBSTR bstrDistPointUrl;
    BYTE * pbDistPoint = NULL;
    DWORD cbDistPoint = 0;
    CERT_EXTENSION * pExtensions = NULL;
    CRL_ISSUING_DIST_POINT distPoint = {0};

    // Setup the name of the distribution point.
    name.dwAltNameChoice = CERT_ALT_NAME_URL;
    ON_ERROR_GOTO(GetSetting(DISTRIBUTION_POINT_NAME, &bstrDistPointUrl));
    name.pwszURL = static_cast<wchar_t *>(bstrDistPointUrl);

    // Setup the distribution point itself.
    distPoint.fIndirectCRL = FALSE;
    distPoint.fOnlyContainsCACerts = FALSE;
    distPoint.fOnlyContainsUserCerts = TRUE;
    distPoint.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;
    distPoint.DistPointName.FullName.cAltEntry = 1;
    distPoint.DistPointName.FullName.rgAltEntry = &name;

    // Encode the distribution point as some bytes.
    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptEncodeObjectEx(
                                        X509_ASN_ENCODING,
                                        szOID_ISSUING_DIST_POINT,
                                        &distPoint,
                                        CRYPT_ENCODE_ALLOC_FLAG,
                                        &CrlToolMemMgr,
                                        &pbDistPoint,
                                        &cbDistPoint));

    // Create the extension array.
    ON_NO_MEM_GOTO(pExtensions = reinterpret_cast<CERT_EXTENSION *>(CrlToolMemMgr.pfnAlloc(sizeof(CERT_EXTENSION))));
    pExtensions->fCritical = FALSE;
    pExtensions->pszObjId = szOID_ISSUING_DIST_POINT;
    pExtensions->Value.cbData = cbDistPoint;
    pExtensions->Value.pbData = pbDistPoint;
    pbDistPoint = NULL;

    // Hand everything off to our member.
    _crlInfo.cExtension = 1;
    _crlInfo.rgExtension = pExtensions;
    pExtensions = NULL;

Error:
    CrlToolMemMgr.pfnFree(pExtensions);
    CrlToolMemMgr.pfnFree(pbDistPoint);
    return hr;
}


//
// This is really the point of this file--add a bunch of CRL_ENTRYs to the CRL.
// This function is responsible for finding all the serial number/date combinations
// and passing them allong to AddCrlEntry.
//
HRESULT CrlGenerator::AddCrlEntries(void)
{
    HRESULT hr = S_OK;

    CrlEntry * pCrlEntries = NULL;
    unsigned long cCrlEntries = 0;

    CComPtr<ICrlToolManagedProxy> spiCrlToolManagedProxy;
    ON_ERROR_GOTO(spiCrlToolManagedProxy.CoCreateInstance(__uuidof(CrlToolManagedProxyImpl)));

    ON_ERROR_GOTO(spiCrlToolManagedProxy->GetCrlEntries(&pCrlEntries, &cCrlEntries));

    for (unsigned long idx = 0; idx < cCrlEntries; ++idx)
    {
        ON_ERROR_GOTO(this->AddCrlEntry(pCrlEntries[idx].SerialNumber, pCrlEntries[idx].RevokedDate));
    }

    // At this point we have built our crl-ist. Hand it
    // off to our member.
    _crlInfo.cCRLEntry = _cCrlEntries;
    _crlInfo.rgCRLEntry = _pCrlEntries;
    _cCrlEntries = 0;
    _pCrlEntries = NULL;

Error:
    for (size_t idx = 0; idx < _cCrlEntries; ++idx)
    {
        for (DWORD idxExt = 0; idxExt < _pCrlEntries[idxExt].cExtension; ++idxExt)
        {
            CrlToolMemMgr.pfnFree(_pCrlEntries[idx].rgExtension[idxExt].Value.pbData);
        }
        CrlToolMemMgr.pfnFree(_pCrlEntries[idx].rgExtension);
    }
    CrlToolMemMgr.pfnFree(_pCrlEntries);

    CoTaskMemFree(pCrlEntries);

    return hr;
}


//
// Converts a serial number and a date into a CRL_ENTRY and adds it to our crl-entry list.
// Note that this is poorly coupled with the list itself, which should actually be it's own class.
//
HRESULT CrlGenerator::AddCrlEntry(BYTE const (&abSerialNumber)[CrlEntrySerialNumberSize_Size], DATE dtRevoked)
{
    HRESULT hr = S_OK;
    BYTE * pbSerialNumberData = NULL;
    CERT_EXTENSION * pExtension = NULL;
    BYTE * pbCrlReason = NULL;
    DWORD cbCrlReason = 0;

    ON_ERROR_GOTO(this->EnsureCrlEntries(_cCrlEntries + 1));

    // Serial Number...
    pbSerialNumberData = reinterpret_cast<BYTE*>((*CrlToolMemMgr.pfnAlloc)(sizeof(abSerialNumber)));
    ON_NO_MEM_GOTO(pbSerialNumberData);
    _pCrlEntries[_cCrlEntries].SerialNumber.cbData = sizeof(abSerialNumber);
    _pCrlEntries[_cCrlEntries].SerialNumber.pbData = pbSerialNumberData;
    pbSerialNumberData = NULL;
    memcpy(_pCrlEntries[_cCrlEntries].SerialNumber.pbData, abSerialNumber, sizeof(abSerialNumber));

    // Date...
    ON_ERROR_GOTO(GetFILETIMEFromDATE(dtRevoked, &(_pCrlEntries[_cCrlEntries].RevocationDate)));
    pExtension = reinterpret_cast<CERT_EXTENSION*>(CrlToolMemMgr.pfnAlloc(sizeof(*pExtension)));
    _pCrlEntries[_cCrlEntries].cExtension = 1;
    _pCrlEntries[_cCrlEntries].rgExtension = pExtension;
    pExtension = NULL;

    // Reason...
    ON_ERROR_GOTO(this->CreateCrlReason(&pbCrlReason, &cbCrlReason));
    _pCrlEntries[_cCrlEntries].rgExtension[0].Value.pbData = pbCrlReason;
    _pCrlEntries[_cCrlEntries].rgExtension[0].Value.cbData = cbCrlReason;
    pbCrlReason = NULL;
    _pCrlEntries[_cCrlEntries].rgExtension[0].fCritical = FALSE;
    _pCrlEntries[_cCrlEntries].rgExtension[0].pszObjId = szOID_CRL_REASON_CODE;

    ++_cCrlEntries;

Error:
    CrlToolMemMgr.pfnFree(pbSerialNumberData);
    CrlToolMemMgr.pfnFree(pExtension);
    CrlToolMemMgr.pfnFree(pbCrlReason);
    return hr;
}


//
// Make sure our crl-entry list will accomdate the number of entries passed in.
//
HRESULT CrlGenerator::EnsureCrlEntries(size_t const cEntriesRequired)
{
    HRESULT hr = S_OK;
    CRL_ENTRY * pCrlEntriesNew = NULL;

    if (cEntriesRequired > _callocCrlEntries)
    {
        size_t const cCrlEntriesNew = cEntriesRequired * 2;
        size_t const cbcrlEntries = cCrlEntriesNew * sizeof (CRL_ENTRY);
        pCrlEntriesNew = reinterpret_cast<CRL_ENTRY*>(CrlToolMemMgr.pfnAlloc(cbcrlEntries));
        ON_NO_MEM_GOTO(pCrlEntriesNew);
        if (_pCrlEntries != NULL)
        {
            memcpy_s(pCrlEntriesNew, cbcrlEntries, _pCrlEntries, _cCrlEntries * sizeof(*_pCrlEntries));
        }
        CrlToolMemMgr.pfnFree(_pCrlEntries);
        _pCrlEntries = pCrlEntriesNew;
        _callocCrlEntries = cCrlEntriesNew;
        pCrlEntriesNew = NULL;
    }

Error:
    CrlToolMemMgr.pfnFree(pCrlEntriesNew);
    return hr;
}


//
// Creates a super-generric CRL reason.
//
HRESULT CrlGenerator::CreateCrlReason(BYTE * * const ppbCrlReason, DWORD * pcbCrlReason) const
{
    static int const iReason = CRL_REASON_UNSPECIFIED;

    HRESULT hr = S_OK;
    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptEncodeObjectEx(
                                        X509_ASN_ENCODING,
                                        X509_ENUMERATED,
                                        &iReason,
                                        CRYPT_ENCODE_ALLOC_FLAG,
                                        &CrlToolMemMgr,
                                        (void *) ppbCrlReason,
                                        pcbCrlReason
                                        ));

Error:
    return hr;
}


//
// Sign the CRL using our private key.
//
HRESULT CrlGenerator::SignCrl(void)
{
    HRESULT hr = S_OK;
    BYTE * pbCrlEncoded = NULL;
    DWORD cbCrlEncoded = 0;
    BYTE * pbSignature = NULL;
    DWORD cbSignature = 0;
    BYTE * pbCrlSigned = NULL;
    DWORD cbCrlSigned = 0;
    CERT_SIGNED_CONTENT_INFO sigInfo = {0};
    HCRYPTPROV hProv;
    DWORD dwKeySpec = 0;
    BOOL bCallerFreeProv = FALSE;
    CRYPT_ALGORITHM_IDENTIFIER sigAlgorithm = {0};

    // Serialize the CRL...
    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptEncodeObjectEx(
                                        X509_ASN_ENCODING,
                                        X509_CERT_CRL_TO_BE_SIGNED,
                                        &_crlInfo,
                                        CRYPT_ENCODE_ALLOC_FLAG,
                                        &CrlToolMemMgr,
                                        &pbCrlEncoded,
                                        &cbCrlEncoded));

    // Get our private key...
    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptAcquireCertificatePrivateKey(
                                        _pIssuerCert,
                                        0 /*dwFlags*/,
                                        NULL /*pvReserved*/,
                                        &hProv,
                                        &dwKeySpec,
                                        &bCallerFreeProv));

    // Determine the size of the signature, allocate, and get the signature.
    sigAlgorithm.pszObjId = szOID_RSA_SHA1RSA;
    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptSignCertificate(
                                        hProv,
                                        dwKeySpec,
                                        X509_ASN_ENCODING,
                                        pbCrlEncoded,
                                        cbCrlEncoded,
                                        &sigAlgorithm,
                                        NULL /*pvHashAuxInfo*/,
                                        NULL /*getting the byte count*/,
                                        &cbSignature));
    ON_NO_MEM_GOTO(pbSignature = reinterpret_cast<BYTE *>(CrlToolMemMgr.pfnAlloc(cbSignature)));
    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptSignCertificate(
                                        hProv,
                                        dwKeySpec,
                                        X509_ASN_ENCODING,
                                        pbCrlEncoded,
                                        cbCrlEncoded,
                                        &sigAlgorithm,
                                        NULL /*pvHashAuxInfo*/,
                                        pbSignature /*getting the byte count*/,
                                        &cbSignature));

    // Init the sign-info and actually sign.
    sigInfo.ToBeSigned.pbData = pbCrlEncoded;
    sigInfo.ToBeSigned.cbData = cbCrlEncoded;
    sigInfo.Signature.pbData = pbSignature;
    sigInfo.Signature.cbData = cbSignature;
    sigInfo.SignatureAlgorithm = sigAlgorithm;
    ON_BOOL_HANDLE_WIN32_ERROR_GOTO(CryptEncodeObjectEx(
                                        X509_ASN_ENCODING,
                                        X509_CERT,
                                        &sigInfo,
                                        CRYPT_ENCODE_ALLOC_FLAG,
                                        &CrlToolMemMgr,
                                        &pbCrlSigned,
                                        &cbCrlSigned));

    // Hand of to our member.
    _pbSignedCrl = pbCrlSigned;
    _cbSignedCrl = cbCrlSigned;
    pbCrlSigned = NULL;

Error:
    CrlToolMemMgr.pfnFree(pbCrlEncoded);
    CrlToolMemMgr.pfnFree(pbCrlSigned);
    CrlToolMemMgr.pfnFree(pbSignature);
    if (bCallerFreeProv)
    {
        (void)CryptDestroyKey(hProv);
    }
    return hr;
}


//
// Serialize the crl to a file.
//
HRESULT CrlGenerator::WriteCrlToFile(void) const
{
    HRESULT hr = S_OK;

    ON_ERROR_GOTO(WriteBufferToFile(_wstrCrlFileName.cstr(),_pbSignedCrl, _cbSignedCrl));

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\CreditCardGenerator\Program.cs ===
﻿using System;
using System.Text;

namespace CreditCardGenerator
{
    /// <summary>
    /// A tool to automatically generate fake credit card numbers. For testing purpose only.
    /// 
    /// Before Madrid, when user add a credit card to his Xbox Live account, he can enter 4111111111111111 as the credit card number, 
    /// and the Xbox Live serivce will intercept this number and automatically generate one, then pass that to CTP (our billing partner). 
    /// But with Madrid, all Credit Card number passed to Xbox Live is encrypted, Xbox Live service can no longer see the clear text 
    /// credit card number anymore. Thus, the generation logic need to move to console. The internal (debug) build of console software
    /// will generate a card number (using LB, RB combo). But for takehome (retail) build, user have to enter the card number by himself.
    /// Hence, this tool is created to generate a card number that will work for CTP. 
    /// </summary>
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Help();
                return;
            }
            string accountNumber = CardGenerator.GenerateAccountNumber(args[0]);
            if (accountNumber != null)
            {
                Console.WriteLine("Generated card number : " + accountNumber);
            }
            else
            {
                Console.WriteLine("Unknown card type.");
                Help();
            }
        }

        static void Help()
        {
            Console.WriteLine();
            Console.WriteLine("Usage: CreditCardGenerator <CardType>");
            Console.WriteLine();
            Console.WriteLine("   <CardType> can be one of the following values:");
            Console.WriteLine("   Visa, Master, Discover, Amex, Diners, Jcb");
            Console.WriteLine();
        }
    }

    /// <summary>
    /// Generate random credit card numbers. Ported from STF. 
    /// </summary>
    public static class CardGenerator
    {
        static Random random = new Random();

        static public string GenerateAccountNumber(string creditCardType)
        {
            string accountNumber;

            creditCardType = creditCardType.ToLower();
            switch (creditCardType)
            {
                case "amex":
                case "americanexpress":
                case "american express":
                    accountNumber = GenerateAmericanExpress();
                    break;
                case "discover":
                    accountNumber = GenerateDiscover();
                    break;
                case "jcb":
                    accountNumber = GenerateJcb();
                    break;
                case "mc":
                case "master":
                case "mastercard":
                case "master card":
                    accountNumber = GenerateMasterCard();
                    break;
                case "visa":
                    accountNumber = GenerateVisa();
                    break;
                case "diners":
                    accountNumber = GenerateDiners();
                    break;
                default:
                    accountNumber = null;
                    break;
            }

            return accountNumber;
        }

        static string GenerateDiscover()
        {
            return GenerateCardNumber(6011, 16);
        }

        static string GenerateVisa()
        {
            return GenerateCardNumber(4, 16);
        }

        static string GenerateMasterCard()
        {
            return GenerateCardNumber(51, 16);
        }

        static string GenerateAmericanExpress()
        {
            Int32 prefix = 0;
            random.Next(1, 3);
            switch (random.Next(1, 3))
            {
                case 1:
                    prefix = 34;
                    break;
                case 2:
                    prefix = 37;
                    break;
                default:
                    prefix = 34;
                    break;
            }
            return GenerateCardNumber(prefix, 15);
        }

        static string GenerateDiners()
        {
            Int32 prefix = 0;
            random.Next(1, 5);
            switch (random.Next(1, 5))
            {
                case 1:
                    prefix = 30;
                    break;
                case 2:
                    prefix = 36;
                    break;
                case 3:
                    prefix = 38;
                    break;
                case 4:
                    prefix = 39;
                    break;
                default:
                    prefix = 30;
                    break;
            }
            return GenerateCardNumber(prefix, 14);
        }

        static string GenerateKlcc()
        {
            Int32 prefix = 0;
            random.Next(1, 5);
            switch (random.Next(1, 5))
            {
                case 1:
                    prefix = 2;
                    break;
                case 2:
                    prefix = 4;
                    break;
                case 3:
                    prefix = 5;
                    break;
                case 4:
                    prefix = 9;
                    break;
                default:
                    prefix = 9;
                    break;
            }
            return GenerateCardNumber(prefix, 16);
        }

        static string GenerateJcb()
        {
            Int32 prefix = 0;
            prefix = random.Next(3528, 3589);
            return GenerateCardNumber(prefix, 16);
        }

        /// <summary>
        /// Constructs the actual random credit card number. All credit cards follow the same checksum, the only difference being the prefix and length of the number
        /// </summary>
        /// <param name="prefix">The prefix of the credit card type. For example, Visa cards start with a 4</param>
        /// <param name="length">The length of the credit card type. For example, Visa cards are all 16 digits in length</param>
        /// <returns>A random credit card number in string format</returns>
        static string GenerateCardNumber(Int32 prefix, Int32 length)
        {
            StringBuilder accountString = new StringBuilder();
            Int32 sumOfAllDigits = 0;

            // Use the prefix if provided
            if (prefix != 0)
            {
                accountString.Append(prefix.ToString());
            }

            // Create a random string until the last digit ( reserved for checksum )
            while (accountString.Length < (length - 1))
            {
                accountString.Append(random.Next(0, 9).ToString());
            }

            // Count up the string, 
            for (Int32 stringPosition = 0; stringPosition < accountString.Length; stringPosition++)
            {
                Int32 digit = Convert.ToInt32(accountString.ToString().Substring(stringPosition, 1));

                // Take the odd positions in the string and perform a checksum on them
                // Odd positions are the 1st, 3rd, 5th, etc., starting from the right
                // Even positioned numbers are used as is
                if (((accountString.Length - stringPosition) % 2) != 0)
                {
                    digit = digit * 2;

                    if (digit >= 10)
                    {
                        digit = digit - 9;
                    }
                }

                // Take the resulting number and sum it to the others.
                sumOfAllDigits = sumOfAllDigits + digit;
            }

            // Perform the checksum on the sum.
            sumOfAllDigits = (10 - (sumOfAllDigits % 10));

            if (sumOfAllDigits == 10)
            {
                sumOfAllDigits = 0;
            }

            // Append the checksum digit to the end of the string
            accountString.Append(sumOfAllDigits.ToString());

            // Return the random credit card number
            return accountString.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolcrlgen.h ===
/*******************************************************************
*
*    DESCRIPTION: crltoolcrlgen.h
*                   Code to actually generate a crl.
*
*******************************************************************/

#pragma once;

class CrlGenerator: public UnCopyable
{
public:
    CrlGenerator(void);
    ~CrlGenerator();
    HRESULT Init(wchar_t const * const wzCrlFileName, FILETIME const * pftNextCrl);
    HRESULT GenerateCrl(void);

private:
    // Core steps of creating the CRL.
    HRESULT InitCrl(void);
    HRESULT AddCrlEntries(void);
    HRESULT SignCrl(void);
    HRESULT WriteCrlToFile(void) const;

    // Helper functions.
    HRESULT AddDistributionPoint(void);
    HRESULT CreateCrlReason(BYTE ** ppbCrlReason, DWORD * pcbCrlReason) const;

    // Clear out our CRL.
    void ResetCrl(void);

    // NOTE: The reason I keep so many data members here is that it isn't always clear
    // what parts of allocated memory the crypto-api still wants to have available.
    // So I just keep everything around and nuke it at destruction.
    CTinyWStr _wstrCrlFileName;
    FILETIME _ftNextCrl;
    CRL_INFO _crlInfo;
    BYTE * _pbSignedCrl;
    DWORD _cbSignedCrl;
    PCCERT_CONTEXT _pIssuerCert;

    // This block of functions of members is really about growing an array of
    // CRL_ENTRIES. Ideally they would be in their own class, but
    // I don't feel like doing that.
    // I guess super-ideally I would just use a std::vector but I decided
    // not to get my head around that.
    HRESULT AddCrlEntry(BYTE const (&abSerialNumber)[CrlEntrySerialNumberSize_Size], DATE dtRevoked);
    HRESULT EnsureCrlEntries(size_t cEntriesRequired);
    CRL_ENTRY * _pCrlEntries;
    size_t _cCrlEntries;
    size_t _callocCrlEntries;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolmain.cpp ===
/*******************************************************************
*
*    DESCRIPTION: crltoolmain.cpp
*                   Command-line tool to handle CRL generation and
*                   certificate revocation.
*
*******************************************************************/

#include "stdafx.h"
#include "crltoolrevoke.h"
#include "crltoolcrlgen.h"
#include "crltoolcrldump.h"

//
// Shocking, I know, but this displays the so-called 'usage' of this tool.
//
static void DisplayUsage(void)
{
    printf("Usage: crltool (revoke consoleid) (generate filename next_crl_date) (dump filename)\n");
    printf("All commands are mutually exclusive.\n");
    printf("    revoke:     Revoke all xmstv certificates for the consoleid (format: XE.DDDDDDDDDDDC).\n");
    printf("    generate:   Generate a signed CRL into the filename specified.\n");
    printf("                next_crl_date should be expressed as month/date/year as in 4/5/2008.\n");
    printf("    dump:       Dumps a CRL file to standard output so you can verify it.\n");
}


//
// Wrap the com-release function so we can use it with atexit.
//
static inline void __cdecl ReleaseCom(void)
{
    CoUninitialize();
}


static HRESULT HrParseDateString(wchar_t const * const wzDate, FILETIME * const pft)
{
    HRESULT hr = S_OK;

    DATE date = 0.0;
    memset(pft, 0, sizeof(*pft));
    ON_ERROR_GOTO(VarDateFromStr(const_cast<wchar_t *>(wzDate), 0, LOCALE_NOUSEROVERRIDE | VAR_DATEVALUEONLY, &date));
    ON_ERROR_GOTO(GetFILETIMEFromDATE(date, pft));

Error:
    return hr;
}

//
// Entry function. This parses our arguments takes the appropriate action.
//
int __cdecl wmain(int argc, LPWSTR argv[])
{
    static unsigned int const MIN_NUM_ARGS = 3;
    static unsigned int const MAX_NUM_ARGS = 4;
    static unsigned int const COMMAND_ARG = 1;
    static unsigned int const FILE_ARG = 2;
    static unsigned int const DATE_ARG = 3;
    static wchar_t const * const REVOKE_COMMAND = L"revoke";
    static wchar_t const * const GENERATE_COMMAND = L"generate";
    static wchar_t const * const DUMP_COMMAND = L"dump";

    HRESULT hr = S_OK;

    if (argc < MIN_NUM_ARGS || argc > MAX_NUM_ARGS)
    {
        goto Error;
    }

    ON_ERROR_GOTO(CoInitialize(NULL));
    atexit(ReleaseCom);

    if (wcsicmp(argv[COMMAND_ARG], REVOKE_COMMAND) == 0)
    {
        Revoker revoker;
        ON_ERROR_GOTO(revoker.Init(argv[FILE_ARG]));
        ON_ERROR_GOTO(revoker.DoRevoke());
    }

    else if (wcsicmp(argv[COMMAND_ARG], GENERATE_COMMAND) == 0)
    {
        if (argc != MAX_NUM_ARGS)
        {
            goto Error;
        }

        CrlGenerator generator;
        FILETIME ft = {0};
        ON_ERROR_GOTO(HrParseDateString(argv[DATE_ARG], &ft));
        ON_ERROR_GOTO(generator.Init(argv[FILE_ARG], &ft));
        ON_ERROR_GOTO(generator.GenerateCrl());
    }

    else if (wcsicmp(argv[COMMAND_ARG], DUMP_COMMAND) == 0)
    {
        CrlDumper dumper;
        ON_ERROR_GOTO(dumper.Init(argv[FILE_ARG]));
        ON_ERROR_GOTO(dumper.DumpCrl());
    }

    else
    {
        ON_ERROR_GOTO(E_INVALIDARG);
    }

Out:
    return 0;
Error:
    DisplayUsage();
    goto Out;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolrevoke.h ===
/*******************************************************************
*
*    DESCRIPTION: crltoolrevoke.h
*                   Handles revoking console-ids.
*
*******************************************************************/

#pragma once

class Revoker: public UnCopyable
{
public:
    Revoker() {}
    HRESULT Init(wchar_t const * const wzConsoleId);
    HRESULT DoRevoke(void) const;

private:
    CComBSTR _bstrConsoleId;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolrevoke.cpp ===
/*******************************************************************
*
*    DESCRIPTION: crltoolrevoke.cpp
*                   Handles revoking console-ids.
*
*******************************************************************/

#include "stdafx.h"
#include "crltoolrevoke.h"


//
// Simple init function.
//
HRESULT Revoker::Init(wchar_t const * const wzConsoleId)
{
    HRESULT hr = S_OK;

    ON_NO_MEM_GOTO(_bstrConsoleId = wzConsoleId);

Error:
    return hr;
}


//
// Revokes all certificates associated with the machine puid we allready have.
//
HRESULT Revoker::DoRevoke(void) const
{
    HRESULT hr = S_OK;

    unsigned long cCertificatesPairsRevoked = 0;
    CComPtr<ICrlToolManagedProxy> spiCrlToolManagedProxy;

    ON_BAD_ARG_GOTO(_bstrConsoleId.Length() != 0);

    ON_ERROR_GOTO(spiCrlToolManagedProxy.CoCreateInstance(__uuidof(CrlToolManagedProxyImpl)));
    ON_ERROR_GOTO(spiCrlToolManagedProxy->Revoke(_bstrConsoleId, &cCertificatesPairsRevoked));

    // If we didn't actually revoke anything, tell the user.
    if (cCertificatesPairsRevoked == 0)
    {
        printf("No non-revoked certificates exist for this machine.\n");
        ON_ERROR_GOTO(E_UNEXPECTED);
    }

    // Otherwise, tell the user how maney we revoked.
    else
    {
        printf("Revoked %d A/V + non-A/V pairs.\n", cCertificatesPairsRevoked);
    }

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolstd.h ===
/*******************************************************************
*
*    DESCRIPTION: crltoolstd.h
*                   Global stuff for crltool.
*
*******************************************************************/

#import "CrlToolManagedProxy.tlb" raw_interfaces_only, no_smart_pointers
using namespace CrlToolManagedProxy;


#define ON_ERROR_GOTO(_hr)                                                                                                                      \
    do {                                                                                                                                        \
        hr = (_hr);                                                                                                                               \
        if (FAILED(hr)) {                                                                                                                       \
            printf("CrlTool failed.\n\tFailure:\t0x%08X\tFile:\t\t%s\n\tFunction:\t%s\n\t\tLine:\t%d\n", hr, __FILE__, __FUNCTION__, __LINE__); \
            goto Error;                                                                                                                         \
        }                                                                                                                                       \
    } while (FALSE)                                                                                                                             \


#define ON_NO_MEM_GOTO(_p) ON_ERROR_GOTO((_p) ? S_OK : E_OUTOFMEMORY)

#define ON_WIN32_ERROR_GOTO(_dw) ON_ERROR_GOTO(HRESULT_FROM_WIN32(_dw))

#define ON_BOOL_HANDLE_WIN32_ERROR_GOTO(_b) ON_ERROR_GOTO((_b) ? S_OK : HRESULT_FROM_WIN32(GetLastError()))

#define ON_BAD_ARG_GOTO(_a) ON_ERROR_GOTO((_a) ? S_OK : E_INVALIDARG)


// Tempated version of ARRAY_SIZE
// I should move this to something like cu_base.h and remove other ones.
template <typename T, size_t N> size_t array_size(T (&a)[N]) { return N; }


//
// Read/Write files.
//
HRESULT WriteBufferToFile(wchar_t const * pwzFile, BYTE const * pBuffer, size_t cbBuffer);
HRESULT LoadBufferFromFile(wchar_t const * pwzFile, BYTE * pbBuffer, size_t * pcbBuffer);


//
// HRESULT-return wrapper for initializing a str
//
HRESULT CopyToStr(CTinyWStr & wstr, wchar_t const * wz);


//
// Memory functions for Crypto APIs.
//
LPVOID WINAPI CrlToolAlloc(size_t cbBytes);
VOID WINAPI CrlToolFree(LPVOID pv);


//
// Free a CRL and all related structures.
//
void FreeCrl(CRL_INFO * pcrlInfo, PFN_CRYPT_FREE pfnFree);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <commonconfig.h>
#include "cutil.h"
#include <strsafe.h>
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers

// declarations (for this project)
#include "crltoolstd.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\crltoolstd.cpp ===
/*******************************************************************
*
*    DESCRIPTION: crltoolstd.h
*                   Global stuff for crltool.
*
*******************************************************************/

#include "stdafx.h"


//
// Dump a binary blob to a file.
//
HRESULT WriteBufferToFile(wchar_t const * const pwzFile, BYTE const * const pBuffer, size_t const cbBuffer)
{
    HRESULT hr = S_OK;
    DWORD dwWritten=0;
    CHandle handle;

    handle.Attach(CreateFile(pwzFile,
                      GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL));

    if (handle == INVALID_HANDLE_VALUE)
    {
        ON_WIN32_ERROR_GOTO(GetLastError());
    }

    else
    {
        ON_BOOL_HANDLE_WIN32_ERROR_GOTO(WriteFile(handle, reinterpret_cast<void const *>(pBuffer), cbBuffer, &dwWritten, NULL));
    }

Error:
    return hr;
}


//
// Read a file into a binary blob.
//
HRESULT LoadBufferFromFile(wchar_t const * const pwzFile, BYTE * const pbBuffer, size_t * const pcbBuffer)
{
    HRESULT hr = S_OK;
    CHandle handle;
    DWORD cbFileSize = 0;

    ON_BAD_ARG_GOTO(pcbBuffer != NULL);
    ON_BAD_ARG_GOTO(pwzFile != NULL);

    handle.Attach(CreateFile(
                    pwzFile,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL));

    if (handle == INVALID_HANDLE_VALUE)
    {
        ON_WIN32_ERROR_GOTO(GetLastError());
    }

    // Get the file size. If the byte-count is too small, set the desired byte count.
    // If they didn't pass in a buffer, then they only wanted the size so we
    // shouldn't fail.
    cbFileSize = GetFileSize(handle, NULL);
    if(cbFileSize > *pcbBuffer )
    {
        *pcbBuffer = cbFileSize;
        if (pbBuffer != NULL)
        {
            ON_WIN32_ERROR_GOTO(ERROR_MORE_DATA);
        }
        else
        {
            hr = S_OK;
            goto Error;
        }
    }

   ON_BOOL_HANDLE_WIN32_ERROR_GOTO(ReadFile(
                                    handle,
                                    pbBuffer,
                                    *pcbBuffer,
                                    &cbFileSize,
                                    NULL));

    *pcbBuffer = cbFileSize;

Error:
    return hr;
}


//
// Wrap copying to a CTinyWstr with an HRESULT-return function.
// I'd like to do this in more generic way, but I decided
// not to figure out the template syntax for that.
//
HRESULT CopyToStr(CTinyWStr & wstr, wchar_t const * const wz)
{
    HRESULT hr = S_OK;
    (void)wstr.CopyFrom(wz);
    if (wstr.HasTruncated())
    {
        ON_ERROR_GOTO(E_OUTOFMEMORY);
    }
    if(wstr.HasFailed())
    {
        // Why don't we have more information in CTinyWstr???
        ON_ERROR_GOTO(E_FAIL);
    }

Out:
    return hr;
Error:
    wstr.Reset();
    goto Out;
}


//
// Some of the Crypto API functions take an allocation structure as a parameter.
// We should generally use these when we want to allocate.
//
LPVOID WINAPI CrlToolAlloc(IN size_t const cbBytes)
{
    LPVOID const pv = malloc(cbBytes);
    if (pv == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return pv;
}

VOID WINAPI CrlToolFree(IN LPVOID const pv)
{
    if (pv != NULL)
    {
        free(pv);
    }
}


//
// Deep-free a CRL_INFO structure.
//
void FreeCrl(CRL_INFO * const pcrlInfo, PFN_CRYPT_FREE const pfnFree)
{
    if (pcrlInfo != NULL && pfnFree != NULL)
    {
        for (size_t idx = 0; idx < pcrlInfo->cExtension; ++idx)
        {
            pfnFree(pcrlInfo->rgExtension[idx].Value.pbData);
        }
        pfnFree(pcrlInfo->rgExtension);

        for (size_t idx = 0; idx < pcrlInfo->cCRLEntry; ++idx)
        {
            for(size_t idxExt = 0; idxExt < pcrlInfo->rgCRLEntry[idx].cExtension; ++idxExt)
            {
                pfnFree(pcrlInfo->rgCRLEntry[idx].rgExtension[idxExt].Value.pbData);
            }
            pfnFree(pcrlInfo->rgCRLEntry[idx].rgExtension);
        }
        pfnFree(pcrlInfo->rgCRLEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_crltool_none_12.4.56.0_none_8f8b81de088f0147
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=crltool
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab.manifest
XP_MANIFEST_PATH=manifests\x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab.cat
XP_CATALOG_PATH=manifests\x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab.cat
XP_PAYLOAD_PATH=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=crltool,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmanaged\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// NOTE: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmanaged\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmain\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_crltool_none_12.4.56.0_none_8f8b81de088f0147
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=crltool
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab.manifest
XP_MANIFEST_PATH=manifests\x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab.cat
XP_CATALOG_PATH=manifests\x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab.cat
XP_PAYLOAD_PATH=x86_crltool_no-public-key_12.4.56.0_x-ww_b206e0ab
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=crltool,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\crltool\crltoolmanaged\CrlToolManagedProxy.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.machine;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.crltool.ManagedProxy
{
    [ComVisible(true)]
    public enum CrlEntrySerialNumberSize
    {
        Size = 16,
    }

    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct CrlEntry
    {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = (int)CrlEntrySerialNumberSize.Size)]
        public byte[] SerialNumber;
        public DateTime RevokedDate;
    }


    [ComVisible(true)]
    [Guid("8CF0B731-E788-40f5-8330-536B1914B2DC")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ICrlToolManagedProxy
    {
        void GetCrlEntries(
            [MarshalAs(UnmanagedType.LPArray)] out CrlEntry[] crlEntries,
            out UInt32 cCrlEntries);

        void Revoke(string consoleId, out UInt32 cCertificatesPairsRevoked);
    }


    [ComVisible(true)]
    [Guid("FC81A0CA-746B-43dd-9B8B-404D4AF07357")]
    [ClassInterface(ClassInterfaceType.None)]
    public class CrlToolManagedProxyImpl : ICrlToolManagedProxy
    {
        public void GetCrlEntries(
            [MarshalAs(UnmanagedType.LPArray)] out CrlEntry[] crlEntries,
            out UInt32 cCrlEntries)
        {
            GetCrlEntriesImpl.GetCrlEntries(out crlEntries, out cCrlEntries);
        }

        public void Revoke(string consoleId, out UInt32 cCertificatesPairsRevoked)
        {
            RevokeImpl.Revoke(consoleId, out cCertificatesPairsRevoked);
        }
    }

    internal static class GetCrlEntriesImpl
    {
        public static void GetCrlEntries(out CrlEntry[] crlEntries, out UInt32 cCrlEntries)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_xmstv_get_all_revoked";
                ws.Partition = WSClient.ANY_PARTITION;

                using (WstDataReader response = ws.Execute())
                {
                    crlEntries = ReadCrlEntries(response);
                    cCrlEntries = (uint)crlEntries.Length;
                }
            }
        }

        private static CrlEntry[] ReadCrlEntries(WstDataReader reader)
        {
            List<CrlEntry> crlEntryList = new List<CrlEntry>();
            while (reader.Read())
            {
                DateTime revoked = reader.GetDateTime(2);
                crlEntryList.Add(ReadCrlEntry(reader, "bin_av_serial_number", revoked));
                crlEntryList.Add(ReadCrlEntry(reader, "bin_nonav_serial_number", revoked));
            }

            return crlEntryList.ToArray();
        }

        private static CrlEntry ReadCrlEntry(WstDataReader reader, string column, DateTime revoked)
        {
            CrlEntry crlEntry = new CrlEntry();
            crlEntry.SerialNumber = WSClient.GetBytes(reader, column);
            crlEntry.RevokedDate = revoked;

            return crlEntry;
        }
    }


    internal static class RevokeImpl
    {
        public static void Revoke(string consoleId, out UInt32 cCertificatesPairsRevoked)
        {
            cCertificatesPairsRevoked = 0;
            Puid[] machinePuids       = MachinePuidUtil.GetXbox360MachineIdsFromConsoleId(consoleId);
            
            foreach (Puid puid in machinePuids)
            {
                cCertificatesPairsRevoked += DoRevoke(puid);
            }
        }

        private static uint DoRevoke(ulong machinePuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "p_xmstv_revoke";
                ws.SetHashVal(machinePuid);

                ws.AddParameter("@puid", machinePuid);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                ws.ExecuteNonQuery();

                return (uint)ws.GetIntParameter("@RETVAL");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cspp\cspp\cspp.cs ===
#define NO_CSPP

using System;
using System.Collections;
using System.Text;
using System.IO;
using Microsoft.CSharp;

namespace xonline.tools
{
    class cspp
    {
        static string _file;
        static int _line;

        static string _keepFilesPath = null;

        static int Main(string[] args)
        {
            string[] sourceFiles;
            string target;
            string[] imports;
            IDictionary options;

            if (args.Length == 0)
            {
                Console.WriteLine("cspp: The CSharp PreCompiler");
                Console.WriteLine("See csc /? for options");
                return -1;
            }


            try
            {
                GetCompilerOptions(args,
                    out sourceFiles,
                    out target,
                    out imports,
                    out options
                );

                string[] sources = new string[sourceFiles.Length];

                for (int i = 0; i < sourceFiles.Length; i++)
                {
                    sources[i] = LoadSource(sourceFiles[i]);
                    sources[i] = FixTraces(sourceFiles[i], sources[i]);

                    if (_keepFilesPath != null)
                    {
                        KeepSource(sourceFiles[i], sources[i]);
                    }
                }

                CompilerError[] errors = Compiler.Compile(sources, sourceFiles, target, imports, options);
                foreach (CompilerError err in errors)
                {
                    Console.WriteLine(err.ToString());
                }

                return (errors.Length);

            }
            catch (CsppException ce)
            {
                Console.WriteLine(ce.ToString());
            }
            catch (Exception e)
            {
                // todo: format this better
                Console.WriteLine(e.ToString());
            }

            return -1;

        }

        public static void GetCompilerOptions(
            string[] args,
            out string[] sourceFiles,
            out string target,
            out string[] imports,
            out IDictionary options
            )
        {
            target = "";
            imports = new string[] { };
            options = new Hashtable();

            ArrayList sourceFileList = new ArrayList();
            ArrayList importList = new ArrayList();

            foreach (string arg in args)
            {
                if (!arg.StartsWith("/") && !arg.StartsWith("-"))
                {
                    sourceFileList.AddRange(GetFilesFromMask(arg));
                    continue;
                }

                string option = "";
                string val = "";

                int sepIndex = arg.IndexOf(':');

                if (sepIndex == -1)
                {
                    option = arg.Substring(1).ToLower();
                }
                else
                {
                    option = arg.Substring(1, sepIndex - 1).ToLower();
                    val = arg.Substring(sepIndex + 1);
                }

                switch(option)
                {
                case "checked+":
                case "checked-":
                    options["checked"] = option.EndsWith("+");
                    break;

                case "debug+":
                case "debug-":
                    options["debug"] = option.EndsWith("+");
                    break;

                case "define":
                case "d":
                    if (options["d"] == null)
                        options["d"] = val;
                    else
                        options["d"] += ";" + val;
                    break;

                case "incremental+":
                case "incremental-":
                case "incr+":
                case "incr-":
                    options["incr"] = option.EndsWith("+");
                    break;


                case "main":
                case "m":
                    options["m"] = val;
                    break;

                case "nostdlib+":
                case "nostdlib-":
                    options["nostdlib"] = option.EndsWith("+");
                    break;

                case "nowarn":
                    if (options["nowarn"] == null)
                        options["nowarn"] = val;
                    else
                        options["nowarn"] += ";" + val;
                    break;

                case "optimize+":
                case "optimize-":
                case "o+":
                case "o-":
                    options["o"] = option.EndsWith("+");
                    break;

                case "out":
                    target = val;
                    break;

                case "r":
                case "reference":
                    importList.Add(val);
                    break;

                case "resource":
                case "res":
                    options["res"] = val;
                    break;

                case "unsafe+":
                case "unsafe-":
                    options["unsafe"] = option.EndsWith("+");
                    break;

                case "warn":
                case "w":
                    options["w"] = val;
                    break;

                case "warnaserror+":
                case "warnaserror-":
                    options["warnaserror"] = option.EndsWith("+");
                    break;

                case "target":
                case "win32icon":
                case "win32res":
                    options[option] = val;
                    break;

                case "keepfiles":
                    _keepFilesPath = val;
                    break;
                }
            }

            sourceFiles = new string[sourceFileList.Count];
            sourceFileList.CopyTo(sourceFiles);

            imports = new string[importList.Count];
            importList.CopyTo(imports);
        }

        private static string[] GetFilesFromMask(string fileMask)
        {
            string dir = Path.GetDirectoryName(fileMask);
            if (dir == "")
                dir = ".";

            if (dir == null)
                dir = "\\";

            return Directory.GetFiles(dir, Path.GetFileName(fileMask));
        }

        public static string LoadSource(string filename)
        {
            string source = "";
            using (StreamReader file = File.OpenText(filename))
            {
                source = file.ReadToEnd();
                file.Close();
            }

            return source;
        }

        public static void KeepSource(string codepath, string code)
        {
            string fullCodePath = Path.GetFullPath(codepath);

            // build the temp file source, dropping the root of the codepath 
            string filepath = Path.Combine(_keepFilesPath, fullCodePath.Substring(3));

            Directory.CreateDirectory(Path.GetDirectoryName(filepath));

            using (StreamWriter file = File.CreateText(filepath))
            {
                file.Write(code);
                file.Close();
            }
        }

        public static string FixTraces(string filepath, string code)
        {
            int numTrace = 0;
            int traceidx = 0; 
            int lastidx = 0;
            StringBuilder retcode = null;
            string filename = null;
            ArrayList defineAreas = null;

            _file = filepath;
            _line = 1;

            if (code.StartsWith("#define NO_CSPP"))
            {
                // dont process this file!
                return code;
            }
            
            // find the traces
            //
            traceidx = code.IndexOf("Xom");
            while (traceidx != -1)
            {
                int iEnd = 0;
                int iEol = 0;

                string traceline;
                int numLinesInTrace = 0;

                string method;
                string[] args;

                string area;
                int level;
                string message;

                if (code.Substring(traceidx).StartsWith("XomDefineArea(") == false &&
                    code.Substring(traceidx).StartsWith("XomTrace(") == false &&
                    code.Substring(traceidx).StartsWith("XomLog(") == false
                    )
                {
                    traceidx = code.IndexOf("Xom", traceidx + 1);
                    continue;
                }


                if (retcode == null)
                {
                    retcode = new StringBuilder(code.Length + 100);
                    filename = Path.GetFileNameWithoutExtension(filepath);
                }

                retcode.Append(code.Substring(lastidx, traceidx - lastidx));

                _line += CountLines(code, lastidx, traceidx) - 1;

                
                // todo: make sure there's no single-line comment marks between the trace and newline

                // find the whole statement
                iEol = traceidx;
                do
                {
                    iEnd = code.IndexOf(");", iEol);
                    if (iEnd == -1)
                        throw new CsppException(_file, _line, "Failed to parse Xom* line, couldn't find ');'!");

                    // verify it's really at the end of the line
                    iEol = iEnd + 2;
                    while (code[iEol] != '\n')
                    {
                        if (code[iEol] != ' ' &&
                            code[iEol] != '\t' &&
                            code[iEol] != '\r')
                        {
                            // not there, have another go
                            iEnd = -1;
                            break;
                        }

                        iEol++;
                    }
                }
                while (iEnd == -1);

                // skip past the );
                iEnd += 2;

                traceline = code.Substring(traceidx, iEnd - traceidx);

                // traceline now contains the entire trace statment..
                
                method = ParseMethod(traceline);
                if (method != null)
                {
                    // Count and remove all the newlines.
                    numLinesInTrace = CountLines(traceline, 0, traceline.Length);
                    traceline = traceline.Replace('\r', ' ');
                    traceline = traceline.Replace('\n', ' ');
                }

                switch(method)
                {
                case "XomDefineArea":
                    if (defineAreas == null)
                        defineAreas = new ArrayList();

                    args = ParseArgs(traceline, 1);
                    defineAreas.Add(args[0].Trim());

                    retcode.Append("/* ");
                    retcode.Append(traceline);
                    retcode.Append(" */");

                    break;

                case "XomTrace":
                    args = ParseArgs(traceline, 3);

                    area = args[0];
                    level = LevelStringToInt(args[1]);
                    if (level == -1)
                        throw new CsppException(filepath, _line, "Failed to parse XomTrace line, couldn't understand level '" + args[1]);
                            

                    message = args[2];
                    
                    numTrace++;

                    WriteTraceLine(retcode, traceline, filename, filepath, numTrace, area, level, message, _line);
                    break;

                case "XomLog":
                    args = ParseArgs(traceline, 2);
                    area = args[0];
                    message = args[1];
                    level = 1;

                    numTrace++;

                    WriteTraceLine(retcode, traceline, filename, filepath, numTrace, area, level, message, _line);
                    break;

                default:
                    // don't know what this is, just write it back out
                    retcode.Append(traceline);
                    break;
                }
                
                for (int l = 0; l < numLinesInTrace - 1; l++)
                {
                    retcode.Append("\r\n");
                }

                lastidx = iEnd;
                traceidx = code.IndexOf("Xom", lastidx);
            }

            if (numTrace > 0 || defineAreas != null)
            {
                retcode.Append(code.Substring(lastidx));
            }

            if (numTrace > 0)
            {
                retcode.Append("\r\nnamespace xonline.traces\r\n" +
                    "{\r\n" + 
                    "    [System.Runtime.InteropServices.ComVisible(false)]\r\n" + 
                    "    public class ");
                retcode.Append(filename);
                retcode.Append("\r\n    {\r\n");
                for (int t = 0; t < numTrace; t++)
                {
                    retcode.Append("        public static uint Trace");
                    retcode.Append(t+1);
                    retcode.Append(" = 0;\r\n");
                }
                retcode.Append("    }\r\n}\r\n");
            }

            if (defineAreas != null)
            {
                retcode.Append("\r\nnamespace xonline.trace\r\n" +
                    "{\r\n");

                foreach (string area in defineAreas)
                {
                    retcode.Append(
                        "    [System.Runtime.InteropServices.ComVisible(false)]\r\n" +
                        "    public class ");
                    retcode.Append(area);
                    retcode.Append("\r\n" +
                        "    {\r\n" +
                        "        public static void Register()\r\n" +
                        "        {\r\n" +
                        "            XomLoggingControl.RegisterArea( theArea );\r\n" +
                        "        }\r\n" +
                        "\r\n" +
                        "        public static XomLogArea theArea = new XomLogArea( \"");
                    retcode.Append(area);
                    retcode.Append("\", xonline.common.config.Setting.xmgmt_area_");
                    retcode.Append(area);
                    retcode.Append(");\r\n" +
                        "    }\r\n");
                }
                retcode.Append("}\r\n");
            }
                
            return (retcode == null ? code : retcode.ToString());    
        }

        private static int CountLines(string str, int start, int end)
        {
            int idx = 0;
            int c = 1;

            // simply count the number of \n's:
            idx = str.IndexOf('\n', start, end-start);
            while (idx != -1)
            {
                c++;
                idx = str.IndexOf('\n', idx + 1, end - (idx + 1));
            }
             
            return c;
        }

        private static string ParseMethod(string traceline)
        {
            int i = traceline.IndexOf('(', 0);
            if (i == -1)
                return null;

            return traceline.Substring(0, i).Trim();
        }   
        
        private static string[] ParseArgs(string traceline, int numArgs)
        {
            int idx = traceline.IndexOf('(', 0);
            if (idx == -1)
                throw new CsppException(_file, _line, "Couldn't find opening parathensies!");

            string[] args = new string[numArgs];
            for (int i = 0; i < numArgs; i++)
            {
                int lastIdx = idx + 1;

                if (i == numArgs - 1)
                    idx = traceline.LastIndexOf(')');
                else
                    idx = traceline.IndexOf(',', lastIdx);

                if (idx == -1)
                    throw new CsppException(_file, _line, "Failed to parse argument " + i + "!");
                    
                args[i] = traceline.Substring(lastIdx, idx - lastIdx);
            }

            return args;
        }
            
        private static int LevelStringToInt(string level)
        {
            int iLevel = 0;

            switch( level.Trim() )
            {
            case "L_ON":
            case "L_LOW":
                iLevel = 0;
                break;

            case "L_INFO":
            case "L_NORMAL":
                iLevel = 1;
                break;

            case "L_WARNING":
            case "L_HIGH":
                iLevel = 2;
                break;

            case "L_ERROR":
                iLevel = 3;
                break;

            case "L_MUTED":
            case "L_OFF":
                iLevel = 4;
                break;

            default:
                iLevel = -1;
                break;
            }

            return iLevel;
        }

        private static void WriteTraceLine(
            StringBuilder retcode, 
            string traceline,
            string filename,
            string filepath,
            int numTrace,
            string area,
            int level,
            string message,
            int curLine
            )
        {
            // now write the newly generated code
            retcode.Append("/* ");
            retcode.Append(traceline);
            retcode.Append(" */  if( xonline.traces.");
            retcode.Append(filename);
            retcode.Append(".Trace");
            retcode.Append(numTrace);
            retcode.Append(" != XomLoggingControl.LastChangeSignature  ) { xonline.trace.");
            retcode.Append(area.Trim());
            retcode.Append(".theArea.Log( ");
            retcode.Append(level);
            retcode.Append(", 0, null, ");
            retcode.Append(message);
            retcode.Append(", "); 
            retcode.Append(curLine);
            retcode.Append(", \"");
            retcode.Append(filepath.Replace("\\", "\\\\"));
            retcode.Append("\", ref  xonline.traces.");
            retcode.Append(filename);
            retcode.Append(".Trace");
            retcode.Append(numTrace);
            retcode.Append(" ); }");
        }



    }

    public class CsppException : ApplicationException
    {
        public string File;
        public int Line;

        public CsppException(string file, int line, string message) :
            base(message)
        {
            File = file;
            Line = line;
        }

        public override string ToString()
        {
            return "C0000000: " + File + "(" + Line + ", 1): " + Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cryptall\cryptall.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Security.Cryptography;
using System.IO;
using System.Text;

namespace xonline.tools.cryptall 
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class CryptAll : System.Windows.Forms.Form
	{
		//private ArrayList cryptos = new ArrayList();
		private ArrayList cryptos;
		private object curcrypto = null;
		private System.Windows.Forms.ComboBox AlgoCombo;
		private System.Windows.Forms.TextBox InputText;
		private System.Windows.Forms.TextBox OutputText;
		private System.Windows.Forms.TextBox KeyText;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.CheckBox HexInputCheck;
		private System.Windows.Forms.CheckBox EncryptCheck;
		private System.Windows.Forms.CheckBox HexOutputCheck;
		private System.Windows.Forms.ComboBox BlockSizeCombo;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label KeyLabel;
		private System.Windows.Forms.Label IVLabel;
		private System.Windows.Forms.TextBox IVText;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.ComboBox KeySizeCombo;
		private System.Windows.Forms.Button RandomButton;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public CryptAll()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			cryptos = new ArrayList();

			cryptos.Add(new DESCryptoServiceProvider());
			//cryptos.Add(new DSACryptoServiceProvider());
			cryptos.Add(new HMACSHA1());
			cryptos.Add(new MACTripleDES());
			cryptos.Add(new MD5CryptoServiceProvider());
			cryptos.Add(new RC2CryptoServiceProvider());
			cryptos.Add(new RijndaelManaged());
			cryptos.Add(new RNGCryptoServiceProvider());
			//cryptos.Add(new RSACryptoServiceProvider());
			cryptos.Add(new SHA1CryptoServiceProvider());
			cryptos.Add(new SHA1Managed());
			cryptos.Add(new SHA256Managed());
			cryptos.Add(new SHA384Managed());
			cryptos.Add(new SHA512Managed());
			cryptos.Add(new TripleDESCryptoServiceProvider());

			for (int i = 0; i < cryptos.Count; i++)
			{
				string s = cryptos[i].ToString();
				AlgoCombo.Items.Add(s.Substring(s.LastIndexOf('.')+1));
			}

			AlgoCombo.SelectedItem = "RijndaelManaged";
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.AlgoCombo = new System.Windows.Forms.ComboBox();
			this.InputText = new System.Windows.Forms.TextBox();
			this.OutputText = new System.Windows.Forms.TextBox();
			this.KeyText = new System.Windows.Forms.TextBox();
			this.label1 = new System.Windows.Forms.Label();
			this.HexInputCheck = new System.Windows.Forms.CheckBox();
			this.EncryptCheck = new System.Windows.Forms.CheckBox();
			this.HexOutputCheck = new System.Windows.Forms.CheckBox();
			this.BlockSizeCombo = new System.Windows.Forms.ComboBox();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.IVText = new System.Windows.Forms.TextBox();
			this.KeyLabel = new System.Windows.Forms.Label();
			this.IVLabel = new System.Windows.Forms.Label();
			this.label4 = new System.Windows.Forms.Label();
			this.KeySizeCombo = new System.Windows.Forms.ComboBox();
			this.RandomButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// AlgoCombo
			// 
			this.AlgoCombo.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.AlgoCombo.Location = new System.Drawing.Point(8, 8);
			this.AlgoCombo.Name = "AlgoCombo";
			this.AlgoCombo.Size = new System.Drawing.Size(216, 21);
			this.AlgoCombo.TabIndex = 0;
			this.AlgoCombo.SelectedIndexChanged += new System.EventHandler(this.AlgoCombo_SelectedIndexChanged);
			// 
			// InputText
			// 
			this.InputText.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.InputText.Location = new System.Drawing.Point(8, 200);
			this.InputText.Multiline = true;
			this.InputText.Name = "InputText";
			this.InputText.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.InputText.Size = new System.Drawing.Size(472, 176);
			this.InputText.TabIndex = 1;
			this.InputText.Text = "";
			this.InputText.TextChanged += new System.EventHandler(this.InputText_TextChanged);
			// 
			// OutputText
			// 
			this.OutputText.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.OutputText.Location = new System.Drawing.Point(8, 408);
			this.OutputText.Multiline = true;
			this.OutputText.Name = "OutputText";
			this.OutputText.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.OutputText.Size = new System.Drawing.Size(472, 176);
			this.OutputText.TabIndex = 2;
			this.OutputText.Text = "";
			// 
			// KeyText
			// 
			this.KeyText.Font = new System.Drawing.Font("Courier New", 7.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.KeyText.Location = new System.Drawing.Point(40, 64);
			this.KeyText.Name = "KeyText";
			this.KeyText.Size = new System.Drawing.Size(440, 19);
			this.KeyText.TabIndex = 3;
			this.KeyText.Text = "0000000000000000000000000000000000000000000000000000000000000000";
			this.KeyText.TextChanged += new System.EventHandler(this.KeyText_TextChanged);
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(8, 64);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(32, 16);
			this.label1.TabIndex = 4;
			this.label1.Text = "Key:";
			// 
			// HexInputCheck
			// 
			this.HexInputCheck.Checked = true;
			this.HexInputCheck.CheckState = System.Windows.Forms.CheckState.Checked;
			this.HexInputCheck.Location = new System.Drawing.Point(384, 176);
			this.HexInputCheck.Name = "HexInputCheck";
			this.HexInputCheck.Size = new System.Drawing.Size(96, 16);
			this.HexInputCheck.TabIndex = 5;
			this.HexInputCheck.Text = "Input in hex";
			this.HexInputCheck.CheckedChanged += new System.EventHandler(this.HexInputCheck_CheckedChanged);
			// 
			// EncryptCheck
			// 
			this.EncryptCheck.Checked = true;
			this.EncryptCheck.CheckState = System.Windows.Forms.CheckState.Checked;
			this.EncryptCheck.Location = new System.Drawing.Point(304, 176);
			this.EncryptCheck.Name = "EncryptCheck";
			this.EncryptCheck.Size = new System.Drawing.Size(64, 16);
			this.EncryptCheck.TabIndex = 6;
			this.EncryptCheck.Text = "Encrypt";
			this.EncryptCheck.CheckedChanged += new System.EventHandler(this.EncryptCheck_CheckedChanged_1);
			// 
			// HexOutputCheck
			// 
			this.HexOutputCheck.Checked = true;
			this.HexOutputCheck.CheckState = System.Windows.Forms.CheckState.Checked;
			this.HexOutputCheck.Location = new System.Drawing.Point(384, 384);
			this.HexOutputCheck.Name = "HexOutputCheck";
			this.HexOutputCheck.Size = new System.Drawing.Size(96, 16);
			this.HexOutputCheck.TabIndex = 7;
			this.HexOutputCheck.Text = "Output in hex";
			this.HexOutputCheck.CheckedChanged += new System.EventHandler(this.HexOutputCheck_CheckedChanged);
			// 
			// BlockSizeCombo
			// 
			this.BlockSizeCombo.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.BlockSizeCombo.Location = new System.Drawing.Point(392, 8);
			this.BlockSizeCombo.Name = "BlockSizeCombo";
			this.BlockSizeCombo.Size = new System.Drawing.Size(88, 21);
			this.BlockSizeCombo.TabIndex = 8;
			this.BlockSizeCombo.SelectedIndexChanged += new System.EventHandler(this.BlockSizeCombo_SelectedIndexChanged);
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(328, 8);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(64, 16);
			this.label2.TabIndex = 9;
			this.label2.Text = "Block size:";
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(8, 120);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(32, 16);
			this.label3.TabIndex = 11;
			this.label3.Text = "IV:";
			// 
			// IVText
			// 
			this.IVText.Font = new System.Drawing.Font("Courier New", 7.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.IVText.Location = new System.Drawing.Point(40, 120);
			this.IVText.Name = "IVText";
			this.IVText.Size = new System.Drawing.Size(440, 19);
			this.IVText.TabIndex = 10;
			this.IVText.Text = "0000000000000000000000000000000000000000000000000000000000000000";
			this.IVText.TextChanged += new System.EventHandler(this.IVText_TextChanged);
			// 
			// KeyLabel
			// 
			this.KeyLabel.Font = new System.Drawing.Font("Courier New", 7.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.KeyLabel.Location = new System.Drawing.Point(40, 88);
			this.KeyLabel.Name = "KeyLabel";
			this.KeyLabel.Size = new System.Drawing.Size(440, 24);
			this.KeyLabel.TabIndex = 12;
			// 
			// IVLabel
			// 
			this.IVLabel.Font = new System.Drawing.Font("Courier New", 7.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.IVLabel.Location = new System.Drawing.Point(40, 144);
			this.IVLabel.Name = "IVLabel";
			this.IVLabel.Size = new System.Drawing.Size(440, 24);
			this.IVLabel.TabIndex = 13;
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(328, 32);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(64, 16);
			this.label4.TabIndex = 15;
			this.label4.Text = "Key size:";
			// 
			// KeySizeCombo
			// 
			this.KeySizeCombo.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.KeySizeCombo.Location = new System.Drawing.Point(392, 32);
			this.KeySizeCombo.Name = "KeySizeCombo";
			this.KeySizeCombo.Size = new System.Drawing.Size(88, 21);
			this.KeySizeCombo.TabIndex = 14;
			this.KeySizeCombo.SelectedIndexChanged += new System.EventHandler(this.KeySizeCombo_SelectedIndexChanged);
			// 
			// RandomButton
			// 
			this.RandomButton.Location = new System.Drawing.Point(8, 168);
			this.RandomButton.Name = "RandomButton";
			this.RandomButton.Size = new System.Drawing.Size(96, 24);
			this.RandomButton.TabIndex = 16;
			this.RandomButton.Text = "Random Key/IV";
			this.RandomButton.Visible = false;
			// 
			// CryptAll
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(486, 590);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.RandomButton,
																		  this.label4,
																		  this.KeySizeCombo,
																		  this.IVLabel,
																		  this.label3,
																		  this.IVText,
																		  this.label2,
																		  this.BlockSizeCombo,
																		  this.HexOutputCheck,
																		  this.EncryptCheck,
																		  this.HexInputCheck,
																		  this.label1,
																		  this.KeyText,
																		  this.OutputText,
																		  this.InputText,
																		  this.AlgoCombo,
																		  this.KeyLabel});
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.Fixed3D;
			this.MaximizeBox = false;
			this.Name = "CryptAll";
			this.Text = "CryptAll";
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new CryptAll());
		}

		private void DisableAll()
		{
			KeyLabel.Text = "";
			IVLabel.Text = "";
			KeyText.Enabled = false;
			IVText.Enabled = false;
			EncryptCheck.Enabled = false;
			BlockSizeCombo.Enabled = false;
			KeySizeCombo.Enabled = false;
		}
		
		private void UpdateUI()
		{
			DisableAll();
			if (curcrypto is SymmetricAlgorithm)
			{
				SymmetricAlgorithm sa = curcrypto as SymmetricAlgorithm;

				KeyText.Enabled = true;
				IVText.Enabled = true;
				EncryptCheck.Enabled = true;
				BlockSizeCombo.Enabled = true;
				KeySizeCombo.Enabled = true;

				int keylengthhex = sa.KeySize/4;
				int ivlengthhex = sa.BlockSize/4;

				if (IVText.Text.Length >= ivlengthhex)
					IVLabel.Text = IVText.Text.Substring(0, ivlengthhex);
				else
					IVLabel.Text = IVText.Text.Substring(0, IVText.Text.Length / 2 * 2).PadRight(ivlengthhex, '0');

				if (KeyText.Text.Length >= keylengthhex)
					KeyLabel.Text = KeyText.Text.Substring(0, keylengthhex);
				else
					KeyLabel.Text = KeyText.Text.Substring(0, KeyText.Text.Length / 2 * 2).PadRight(keylengthhex, '0');
			}
			else if (curcrypto is KeyedHashAlgorithm)
			{
				KeyedHashAlgorithm kha = curcrypto as KeyedHashAlgorithm;

				KeyText.Enabled = true;
				int keylengthhex = kha.Key.Length*2;

				if (KeyText.Text.Length >= keylengthhex)
					KeyLabel.Text = KeyText.Text.Substring(0, keylengthhex);
				else
					KeyLabel.Text = KeyText.Text.Substring(0, KeyText.Text.Length / 2 * 2).PadRight(keylengthhex, '0');
			}
		}

		private void Crypt()
		{
			UpdateUI();
			try
			{
				byte[] inputdata, outputdata;
				if (HexInputCheck.Checked)
				{
					inputdata = unhex(InputText.Text);
				}
				else
				{
					inputdata = new ASCIIEncoding().GetBytes(InputText.Text);
				}

				if (curcrypto is SymmetricAlgorithm)
				{
					SymmetricAlgorithm sa = curcrypto as SymmetricAlgorithm;

					sa.Padding = PaddingMode.None;
					sa.FeedbackSize = 0;

					byte[] Key = unhex(KeyLabel.Text);
					byte[] IV = unhex(IVLabel.Text);

					byte[] paddedinputdata = new byte[inputdata.Length + ((sa.BlockSize/8) - ((inputdata.Length-1) % (sa.BlockSize/8))-1)];
					inputdata.CopyTo(paddedinputdata, 0);

					outputdata = new byte[paddedinputdata.Length];
					MemoryStream keystream = new MemoryStream(outputdata);

					ICryptoTransform encdec;
					if (EncryptCheck.Checked)
						encdec = sa.CreateEncryptor(Key, IV);
					else
						encdec = sa.CreateDecryptor(Key, IV);

					CryptoStream cs = new CryptoStream(keystream, encdec, CryptoStreamMode.Write);
					cs.Write(paddedinputdata, 0, paddedinputdata.Length);
					cs.Close();

					//outputdata = keystream.GetBuffer();
				}
				else if (curcrypto is KeyedHashAlgorithm)
				{
					KeyedHashAlgorithm kha = curcrypto as KeyedHashAlgorithm;
					kha.Initialize();

					kha.Key = unhex(KeyLabel.Text);

					outputdata = kha.ComputeHash(inputdata);
				}
				else if (curcrypto is HashAlgorithm)
				{
					outputdata = (curcrypto as HashAlgorithm).ComputeHash(inputdata);
				}
				else if (curcrypto is RandomNumberGenerator)
				{
					outputdata = new byte[inputdata.Length];
					(curcrypto as RandomNumberGenerator).GetBytes(outputdata);
				}
				else
				{
					outputdata = new byte[0];
				}

				if (HexOutputCheck.Checked)
				{
					OutputText.Text = tohex(outputdata);
				}
				else
				{
					OutputText.Text = new ASCIIEncoding().GetString(outputdata);
				}
			}
			catch(CryptographicException e)
			{
				OutputText.Text = e.Message;
			}
		}
		
		private void InputText_TextChanged(object sender, System.EventArgs e)
		{
			Crypt();
		}

		private static byte[] unhex(string s)
		{
			if (s.StartsWith("0x"))
				s = s.Substring(2);

			if (s.Length % 2 == 1)
				s = "0" + s;

			byte[] hex = new byte[s.Length / 2];
			for (int i = 0; i < s.Length / 2; i++)
			{
				hex[i] = (byte)((unhex(s[i*2]) << 4) + unhex(s[i*2+1]));
			}

			return hex;
		}

		private static byte unhex(char c)
		{
			if (c >= '0' && c <= '9')
				return (byte)(c - '0');
			else if (c >= 'a' && c <= 'z')
				return (byte)(c - 'a' + 10);
			else if (c >= 'A' && c <= 'Z')
				return (byte)(c - 'A' + 10);
			return 0;
		}

		private static string tohex(byte[] bytes)
		{
			ASCIIEncoding ascii = new ASCIIEncoding();
			char[] charsascii = new char[bytes.Length*2];
			for (int i = 0; i < bytes.Length; i++)
			{
				charsascii[i*2] = tohex((byte)(bytes[i] >> 4));
				charsascii[i*2+1] = tohex((byte)(bytes[i] & 15));
			}
			return new String(charsascii);
		}

		private static char tohex(byte b)
		{
			if (b < 10)
				return (char)('0' + b);
			return (char)('A' + b - 10);
		}

		private void ComboKeySizesChange(ComboBox cb, KeySizes[] ks, int cursize)
		{
			cb.Items.Clear();
			for (int i = 0; i < ks.Length; i++)
			{
				for (int j = ks[i].MinSize; j <= ks[i].MaxSize; j += ks[i].SkipSize > 0 ? ks[i].SkipSize : 1)
				{
					cb.Items.Add(j);
				}
			}
			cb.SelectedItem = cursize;
		}

		private void AlgoCombo_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			curcrypto = cryptos[AlgoCombo.SelectedIndex];
			if (curcrypto is SymmetricAlgorithm)
			{
				SymmetricAlgorithm sa = curcrypto as SymmetricAlgorithm;
				ComboKeySizesChange(BlockSizeCombo, sa.LegalBlockSizes, sa.BlockSize);
				ComboKeySizesChange(KeySizeCombo, sa.LegalKeySizes, sa.KeySize);
			}
			Crypt();
		}

		private void HexInputCheck_CheckedChanged(object sender, System.EventArgs e)
		{
			Crypt();
		}

		private void KeyText_TextChanged(object sender, System.EventArgs e)
		{
			Crypt();
			KeyText.Focus();
		}

		private void IVText_TextChanged(object sender, System.EventArgs e)
		{
			Crypt();
			IVText.Focus();
		}
		
		private void EncryptCheck_CheckedChanged(object sender, System.EventArgs e)
		{
			Crypt();
		}

		private void HexOutputCheck_CheckedChanged(object sender, System.EventArgs e)
		{
			Crypt();
		}

		private void EncryptCheck_CheckedChanged_1(object sender, System.EventArgs e)
		{
			Crypt();
		}

		private void BlockSizeCombo_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			curcrypto = cryptos[AlgoCombo.SelectedIndex];
			SymmetricAlgorithm sa = curcrypto as SymmetricAlgorithm;
			if (sa != null)
			{
				sa.BlockSize = int.Parse(BlockSizeCombo.SelectedItem.ToString());
			}
			Crypt();
		}

		private void KeySizeCombo_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			curcrypto = cryptos[AlgoCombo.SelectedIndex];
			SymmetricAlgorithm sa = curcrypto as SymmetricAlgorithm;
			if (sa != null)
			{
				sa.KeySize = int.Parse(KeySizeCombo.SelectedItem.ToString());
			}
			Crypt();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cspp\csppDevTest\GetCompilerOptions.cs ===
using System;
using System.Collections;
using System.Text;
using System.IO;


using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace xonline.tools
{
    [TestClass]
    public class CsppDevTest_GetCompilerOptions
    {
        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        static string _tempFilePath;
        static string[] _tempSourceFiles;

        string[] _sourceFiles;
        string _target;
        string[] _imports;
        IDictionary _options;

        [ClassInitialize]
        public static void Init(TestContext ctx)
        {
            // create a temporary directory
            _tempFilePath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
            Directory.CreateDirectory(_tempFilePath);

            // create 3 temp files
            _tempSourceFiles = new string[3];
            for (int i = 0; i < 3; i++)
            {
                _tempSourceFiles[i] = Path.Combine(_tempFilePath, Path.GetRandomFileName() + ".cs");
                FileStream file = File.Create(_tempSourceFiles[i]);
                file.Close();
            }
        }

        [ClassCleanup]
        public static void Cleanup()
        {
            Directory.Delete(_tempFilePath, true);
        }

        #region GetCsppCompilerOptions
        public void GetCsppCompilerOptions(string arg1)
        {
            GetCsppCompilerOptions(new string[] { arg1 });
        }
        public void GetCsppCompilerOptions(string arg1, string arg2)
        {
            GetCsppCompilerOptions(new string[] { arg1, arg2 } );
        }
        public void GetCsppCompilerOptions(string arg1, string arg2, string arg3)
        {
            GetCsppCompilerOptions(new string[] { arg1, arg2, arg3 } );
        }
        public void GetCsppCompilerOptions(string arg1, string arg2, string arg3, string arg4)
        {
            GetCsppCompilerOptions(new string[] { arg1, arg2, arg3, arg4 } );
        }
        public void GetCsppCompilerOptions(string arg1, string arg2, string arg3, string arg4, string arg5)
        {
            GetCsppCompilerOptions(new string[] { arg1, arg2, arg3, arg4, arg5 } );
        }
        public void GetCsppCompilerOptions(string[] args)
        {
            cspp.GetCompilerOptions(args, out _sourceFiles, out _target, out _imports, out _options);
        }
        #endregion

        [TestMethod]
        public void ReturnSourceTexts()
        {
            GetCsppCompilerOptions(_tempSourceFiles[0], _tempSourceFiles[1], "/out:bar.exe" );

            Assert.AreEqual(_sourceFiles.Length, 2);
            Assert.AreEqual(_sourceFiles[0], _tempSourceFiles[0]);
            Assert.AreEqual(_sourceFiles[1], _tempSourceFiles[1]);
        }

        [TestMethod]
        public void ReturnSourceTextsFromMask()
        {
            GetCsppCompilerOptions(_tempSourceFiles[0], _tempSourceFiles[1], Path.Combine(_tempFilePath, "*.cs"), "/out:bar.exe" );

            Assert.AreEqual(_sourceFiles.Length, 5);
            Assert.AreEqual(_sourceFiles[0], _tempSourceFiles[0]);
            Assert.AreEqual(_sourceFiles[1], _tempSourceFiles[1]);
            Assert.AreNotEqual(Array.IndexOf(_sourceFiles, _tempSourceFiles[0]), -1);
            Assert.AreNotEqual(Array.IndexOf(_sourceFiles, _tempSourceFiles[1]), -1);
            Assert.AreNotEqual(Array.IndexOf(_sourceFiles, _tempSourceFiles[2]), -1);
        }

        [TestMethod]
        public void Target()
        {
            GetCsppCompilerOptions(_tempSourceFiles[0], "/out:foo.exe" );
            
            Assert.AreEqual("foo.exe", _target);
        }

        [TestMethod]
        public void Import()
        {
            GetCsppCompilerOptions("/r:1.dll", "/reference:2.dll" );

            Assert.AreEqual(2, _imports.Length);
            Assert.AreEqual("1.dll", _imports[0]);
            Assert.AreEqual("2.dll", _imports[1]);
        }

        [TestMethod]
        public void CheckedOn()
        {
            GetCsppCompilerOptions("/checked+" );

            Assert.IsTrue((bool)_options["checked"]);
        }

        [TestMethod]
        public void CheckedOff()
        {
            GetCsppCompilerOptions("/checked-" );

            Assert.IsFalse((bool)_options["checked"]);
        }

        [TestMethod]
        public void IncrOn()
        {
            GetCsppCompilerOptions("/incr+" );
            Assert.IsTrue((bool)_options["incr"]);
        }

        [TestMethod]
        public void IncrOff()
        {
            GetCsppCompilerOptions("/incremental-" );
            Assert.IsFalse((bool)_options["incr"]);
        }

        [TestMethod]
        public void Main()
        {
            GetCsppCompilerOptions("/main:MyMain");
            Assert.AreEqual("MyMain", (string)_options["m"]);
        }

        [TestMethod]
        public void Defines()
        {
            GetCsppCompilerOptions("/d:DEBUG", "/define:TRACE" );
            Assert.AreEqual("DEBUG;TRACE", (string)_options["d"]);
        }

        [TestMethod]
        public void NoWarn()
        {
            GetCsppCompilerOptions("/nowarn:1234", "/nowarn:5678");
            Assert.AreEqual("1234;5678", (string)_options["nowarn"]);
        }

        [TestMethod]
        public void OptimizeOn()
        {
            GetCsppCompilerOptions("/optimize+");
            Assert.IsTrue((bool)_options["o"]);
        }

        [TestMethod]
        public void OptimizeOff()
        {
            GetCsppCompilerOptions("/o-");
            Assert.IsFalse((bool)_options["o"]);
        }

        [TestMethod]
        public void Resource()
        {
            GetCsppCompilerOptions("/res:foo.res");
            Assert.AreEqual("foo.res", (string)_options["res"]);
        }

        [TestMethod]
        public void NoStdLibOn()
        {
            GetCsppCompilerOptions("/nostdlib+");
            Assert.IsTrue((bool)_options["nostdlib"]);
        }

        [TestMethod]
        public void NoStdLibOff()
        {
            GetCsppCompilerOptions("/nostdlib-");
            Assert.IsFalse((bool)_options["nostdlib"]);
        }

        [TestMethod]
        public void TargetTypeExe()
        {
            GetCsppCompilerOptions("/target:winexe");
            Assert.AreEqual("winexe", (string)_options["target"]);
        }

        [TestMethod]
        public void TargetTypeConsole()
        {
            GetCsppCompilerOptions("/target:exe");
            Assert.AreEqual("exe", (string)_options["target"]);
        }

        [TestMethod]
        public void TargetTypeLibrary()
        {
            GetCsppCompilerOptions("/target:library");
            Assert.AreEqual("library", (string)_options["target"]);
        }

        [TestMethod]
        public void UnsafeOn()
        {
            GetCsppCompilerOptions("/unsafe+");
            Assert.IsTrue((bool)_options["unsafe"]);
        }

        [TestMethod]
        public void UnsafeOff()
        {
            GetCsppCompilerOptions("/unsafe-");
            Assert.IsFalse((bool)_options["unsafe"]);
        }

        [TestMethod]
        public void WarnLevel()
        {
            GetCsppCompilerOptions("/warn:4");
            Assert.AreEqual("4", (string)_options["w"]);
        }

        [TestMethod]
        public void WarnAsErrorOn()
        {
            GetCsppCompilerOptions("/warnaserror+");
            Assert.IsTrue((bool)_options["warnaserror"]);
        }

        [TestMethod]
        public void WarnAsErrorOff()
        {
            GetCsppCompilerOptions("/warnaserror-");
            Assert.IsFalse((bool)_options["warnaserror"]);
        }

        [TestMethod]
        public void Win32Icon()
        {
            GetCsppCompilerOptions("/win32icon:foo.ico");
            Assert.AreEqual("foo.ico", (string)_options["win32icon"]);
        }

        [TestMethod]
        public void Win32Res()
        {
            GetCsppCompilerOptions("/win32res:foo.res");
            Assert.AreEqual("foo.res", (string)_options["win32res"]);
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cspp\csppDevTest\FixUpTracing.cs ===
using System;
using System.Collections;
using System.Text;
using System.IO;


using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace xonline.tools
{
    [TestClass]
    public class CsppDevTest_FixTraces
    {
        [TestMethod]
        public void SingleLineTrace()
        {
            string code =
@"using System;
namespace foo.bar
{
    XomTrace( apptrace, L_LOW, ""this is trace.."");
}
";

            string expected =
@"using System;
namespace foo.bar
{
    /* XomTrace( apptrace, L_LOW, ""this is trace..""); */  if( xonline.traces.myfile.Trace1 != XomLoggingControl.LastChangeSignature  ) { xonline.trace.apptrace.theArea.Log( 0, 0, null,  ""this is trace.."", 4, ""e:\\foo\\bar\\myfile.cs"", ref  xonline.traces.myfile.Trace1 ); }
}

namespace xonline.traces
{
    [System.Runtime.InteropServices.ComVisible(false)]
    public class myfile
    {
        public static uint Trace1 = 0;
    }
}
";
            string result = cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);

            Assert.AreEqual(expected, result);
        }

        [TestMethod]
        public void TwoTraceLines()
        {
            string code =
@"using System;
namespace foo.bar
{
    XomTrace( apptrace, L_LOW, ""this is a trace.."");
    // some code
    XomTrace( apptrace, L_LOW, ""this is another trace.."");
}
";

            string expected =
@"using System;
namespace foo.bar
{
    /* XomTrace( apptrace, L_LOW, ""this is a trace..""); */  if( xonline.traces.myfile.Trace1 != XomLoggingControl.LastChangeSignature  ) { xonline.trace.apptrace.theArea.Log( 0, 0, null,  ""this is a trace.."", 4, ""e:\\foo\\bar\\myfile.cs"", ref  xonline.traces.myfile.Trace1 ); }
    // some code
    /* XomTrace( apptrace, L_LOW, ""this is another trace..""); */  if( xonline.traces.myfile.Trace2 != XomLoggingControl.LastChangeSignature  ) { xonline.trace.apptrace.theArea.Log( 0, 0, null,  ""this is another trace.."", 6, ""e:\\foo\\bar\\myfile.cs"", ref  xonline.traces.myfile.Trace2 ); }
}

namespace xonline.traces
{
    [System.Runtime.InteropServices.ComVisible(false)]
    public class myfile
    {
        public static uint Trace1 = 0;
        public static uint Trace2 = 0;
    }
}
";
            string result = cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);

            Assert.AreEqual(expected, result);
        }


        [TestMethod]
        public void TwoLineTrace()
        {
            string code =
@"using System;
namespace foo.bar
{
    XomTrace( apptrace, L_LOW, 
        ""this is trace.."");
}
";

            string expected =
@"using System;
namespace foo.bar
{
    /* XomTrace( apptrace, L_LOW,           ""this is trace..""); */  if( xonline.traces.myfile.Trace1 != XomLoggingControl.LastChangeSignature  ) { xonline.trace.apptrace.theArea.Log( 0, 0, null,            ""this is trace.."", 4, ""e:\\foo\\bar\\myfile.cs"", ref  xonline.traces.myfile.Trace1 ); }

}

namespace xonline.traces
{
    [System.Runtime.InteropServices.ComVisible(false)]
    public class myfile
    {
        public static uint Trace1 = 0;
    }
}
";
            string result = cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);

            Assert.AreEqual(expected, result);
        }

        [TestMethod]
        public void DefineArea()
        {
            string code =
@"using System;
XomDefineArea( apptrace );
// this is some code
    XomTrace( apptrace, L_LOW, ""this is trace.."");
// and some more code

";

            string expected =
@"using System;
/* XomDefineArea( apptrace ); */
// this is some code
    /* XomTrace( apptrace, L_LOW, ""this is trace..""); */  if( xonline.traces.myfile.Trace1 != XomLoggingControl.LastChangeSignature  ) { xonline.trace.apptrace.theArea.Log( 0, 0, null,  ""this is trace.."", 4, ""e:\\foo\\bar\\myfile.cs"", ref  xonline.traces.myfile.Trace1 ); }
// and some more code


namespace xonline.traces
{
    [System.Runtime.InteropServices.ComVisible(false)]
    public class myfile
    {
        public static uint Trace1 = 0;
    }
}

namespace xonline.trace
{
    [System.Runtime.InteropServices.ComVisible(false)]
    public class apptrace
    {
        public static void Register()
        {
            XomLoggingControl.RegisterArea( theArea );
        }

        public static XomLogArea theArea = new XomLogArea( ""apptrace"", xonline.common.config.Setting.xmgmt_area_apptrace);
    }
}
";

            string result = cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);
            Assert.AreEqual(expected, result);
        }

        [TestMethod]
        public void DefineTwoAreas()
        {
            string code =
@"using System;
XomDefineArea( apptrace );
XomDefineArea( apptrace2 );
// this is some code
    XomTrace( apptrace, L_LOW, ""this is trace.."");
// and some more code

";

            string expected =
@"using System;
/* XomDefineArea( apptrace ); */
/* XomDefineArea( apptrace2 ); */
// this is some code
    /* XomTrace( apptrace, L_LOW, ""this is trace..""); */  if( xonline.traces.myfile.Trace1 != XomLoggingControl.LastChangeSignature  ) { xonline.trace.apptrace.theArea.Log( 0, 0, null,  ""this is trace.."", 5, ""e:\\foo\\bar\\myfile.cs"", ref  xonline.traces.myfile.Trace1 ); }
// and some more code


namespace xonline.traces
{
    [System.Runtime.InteropServices.ComVisible(false)]
    public class myfile
    {
        public static uint Trace1 = 0;
    }
}

namespace xonline.trace
{
    [System.Runtime.InteropServices.ComVisible(false)]
    public class apptrace
    {
        public static void Register()
        {
            XomLoggingControl.RegisterArea( theArea );
        }

        public static XomLogArea theArea = new XomLogArea( ""apptrace"", xonline.common.config.Setting.xmgmt_area_apptrace);
    }
    [System.Runtime.InteropServices.ComVisible(false)]
    public class apptrace2
    {
        public static void Register()
        {
            XomLoggingControl.RegisterArea( theArea );
        }

        public static XomLogArea theArea = new XomLogArea( ""apptrace2"", xonline.common.config.Setting.xmgmt_area_apptrace2);
    }
}
";

            string result = cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);
            Assert.AreEqual(expected, result);
        }

        [TestMethod]
        public void NoOpeningParenThrows()
        {
            string code = "using System;\r\nXomTrace\r\n";

            try
            {
                cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);
                Assert.Fail("Bad code didn't throw!");
            }
            catch (CsppException e)
            {
                Assert.AreEqual(e.File, "e:\\foo\\bar\\myfile.cs");
                Assert.AreEqual(e.Line, 2);
                Assert.IsTrue(e.Message.IndexOf("Failed to parse Xom* line") != -1);
            }
        }

        [TestMethod]
        public void NoCspp()
        {
            string code = "#define NO_CSPP\r\nusing System;\r\nXomTrace( apptrace, L_LOW, \"this is trace..\");\r\n";

            string result = cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);
            Assert.AreEqual(code, result);
        }

        [TestMethod]
        public void NonsenseXomOnly()
        {
            string code = "using System;\r\nXomNonsense( apptrace, L_LOW, \"this is trace..\");\r\n";

            string result = cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);
            Assert.AreEqual(code, result);
        }

        [TestMethod]
        public void NonsenseXomFollowedByTrace()
        {
            string code =
@"using System;
namespace foo.bar
{
    XomNonsense(bla bla bla);
    XomTrace( apptrace, L_LOW, ""this is trace.."");
}
";

            string expected =
@"using System;
namespace foo.bar
{
    XomNonsense(bla bla bla);
    /* XomTrace( apptrace, L_LOW, ""this is trace..""); */  if( xonline.traces.myfile.Trace1 != XomLoggingControl.LastChangeSignature  ) { xonline.trace.apptrace.theArea.Log( 0, 0, null,  ""this is trace.."", 5, ""e:\\foo\\bar\\myfile.cs"", ref  xonline.traces.myfile.Trace1 ); }
}

namespace xonline.traces
{
    [System.Runtime.InteropServices.ComVisible(false)]
    public class myfile
    {
        public static uint Trace1 = 0;
    }
}
";
            string result = cspp.FixTraces("e:\\foo\\bar\\myfile.cs", code);

            Assert.AreEqual(expected, result);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Deactivator\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Deactivator\billingprovider.cs ===
//
// BillingProvider.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Wrapper Class
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.IO;
using System.Web;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System.Text;
using System.Xml;
using System.Globalization;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Runtime.InteropServices;
using xonline.common.service;
using System.Security.Permissions;
using System.Security.Principal;
using xonline.common.config;
using xonline.common.crypto;



namespace xonline.tools.deactivator
{


public class BillingProvider : bdk
{

    //
    // Stuff for impersonation to get public key
    //

    [DllImport("c:\\winnt\\system32\\advapi32.dll", EntryPoint="LogonUser", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword,
            int dwLogonType, int dwLogonProvider, out int phToken);

    [DllImport("c:\\winnt\\system32\\Kernel32.dll")]
    public static extern int GetLastError();

    //
    // BillingProvider
    //

    private static string _server;
    private static string _iisuser;

    // data that persists across all connections
    public static string Username
    {
        get
        {
            if (!_initalized) Init();
            return _username;
        }

        set { _username = value; }
    }

    public static string Password
    {
        get
        {
            if (!_initalized) Init();
            return _password;
        }
        set { _password = value; }
    }

    public static string WsdlLocation
    {
        get
        {
            if (!_initalized) Init();
            return _wsdlLocation;
        }
        set { _wsdlLocation = value; }
    }


    private static string _username;
    private static string _password;
    private static string _wsdlLocation;
    private static bool _initalized = false;

    public static void Init()
    {
        GetPartnerInfo(_server, _iisuser);

        Output.WriteDebug("BillingProvider: Username=" + _username);
        Output.WriteDebug("BillingProvider: WSDL=" + _wsdlLocation);

        _initalized = true;
    }

    // constructor
    public BillingProvider(string server, string iisuser) : base()
    {
        _server = server;
        _iisuser = iisuser;

        // set up the bdk that we inherit from
        this.Url     = WsdlLocation;

        this.Credentials = new NetworkCredential(Username, Password);
        this.Timeout     = 20000;
    }



    /// <summary>
    /// Gets the partner key info from UODB.
    /// </summary>
    private static void GetPartnerInfo(string server, string iisuser)
    {
        SqlCommand cmd;
        SqlConnection cxn;
        SqlDataReader reader;
        int masterkeyver;
        byte[] encPassword = null;

        Output.WriteDebug("Opening connection to " + server + "...");
        cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
        //cxn = new SqlConnection("server="+ server + ";uid=sa;password=Suck!H3ad;database=uodb");
        cxn.Open();


        Output.WriteDebug("Getting service keys...");
        cmd = new SqlCommand("p_xbos_get_raw_sps_info", cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        SqlParameter sqlUsername = cmd.Parameters.Add("@username", SqlDbType.NVarChar, 200);
        SqlParameter sqlPassword = cmd.Parameters.Add("@password", SqlDbType.VarBinary, 256);
        SqlParameter sqlWsdlLocation = cmd.Parameters.Add("@wsdllocation", SqlDbType.NVarChar, 200);
        SqlParameter sqlKeyVer = cmd.Parameters.Add("@i_masterkeyversion", SqlDbType.Int);
        sqlUsername.Direction = ParameterDirection.Output;
        sqlPassword.Direction = ParameterDirection.Output;
        sqlWsdlLocation.Direction = ParameterDirection.Output;
        sqlKeyVer.Direction = ParameterDirection.Output;

        reader = cmd.ExecuteReader();
        reader.Close();

        Username = (string)sqlUsername.Value;
        encPassword = (byte[])sqlPassword.Value;
        WsdlLocation = (string)sqlWsdlLocation.Value;
        masterkeyver = (int)sqlKeyVer.Value;

        cxn.Close();

        // check the master key version
        if ( masterkeyver == 0 )
        {
            UnicodeEncoding UE = new UnicodeEncoding();
            Password = UE.GetString(encPassword);
        }
        else
        {

            ASCIIEncoding AE = new ASCIIEncoding();
            Password = AE.GetString(KEKCryptoMgr.DecryptWithMasterKeyWrp( (uint)masterkeyver, (uint)encPassword.Length, encPassword ));
        }


    /***** CODE BELOW IS LEGACY FOR WEBSTORE USE.  IT CAN BE REVIVED IF NECESSARY/DESIRABLE. ***

        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
        int masterkeyver = 0;

        ws.ClearParameters();
        // TODO:  RENAME THIS STORED PROC.
        ws.StoredProc = "p_xbos_get_raw_sps_info";

        // intput and output params
        ws.AddParameter(ParamType.OUTPUT, "", 200);     // partner username
        ws.AddParameter(ParamType.OUTPUT, (byte[])null, 256);     // partner key
        ws.AddParameter(ParamType.OUTPUT, "", 200);     // partner WSDL location
        ws.AddParameter(ParamType.OUTPUT, 0);           // master key version to do decryption

        // call the procedure
        ws.ExecuteNonQuery();


        Username = ws.GetStringParameter(0);
        masterkeyver = ws.GetIntParameter(3);
        WsdlLocation = ws.GetStringParameter(2);

        // check the master key version
        if ( masterkeyver == 0 )
        {
            UnicodeEncoding UE = new UnicodeEncoding();
            Password = UE.GetString(ws.GetByteArrayParameter(1) );
        }
        else
        {
            ASCIIEncoding AE = new ASCIIEncoding();
            byte[] encPassword = ws.GetByteArrayParameter(1);
            Password = AE.GetString(KEKCryptoMgr.DecryptWithMasterKeyWrp( (uint)masterkeyver, (uint)encPassword.Length, encPassword ));
        }
        */
    }


}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Deactivator\ConsoleEx.cs ===
// ConsoleEx V1.02 - Tim Sneath <tims@microsoft.com>

// ReadHiddenLine: Ben Zotto (benzotto@xbox.com)

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace xonline.tools.deactivator 
{
	/// <summary>
	/// This class provides supplemental functionality to that available in the System.Console class. It 
	/// allows a developer to control the cursor location, size and visibility, to manipulate the color
	/// used for writing text on the screen, to read characters individually from the input buffer, to 
	/// manipulate the console window title, to clear the screen and to draw rectangles on the screen. It 
	/// does not replace traditional functions supplied in the System.Console class such as WriteLine() 
	/// and ReadLine(), but is intended to be use in conjunction with calls to that class.
	/// </summary>
	/// <remarks>
	/// This class is largely built using information from the Platform SDK. Documentation on the 
	/// Console APIs within kernel32 can be found at the following location:
	///       http://msdn.microsoft.com/library/en-us/dllproc/base/character_mode_applications.asp
	///
	/// Several of the functions within this class are reworked and expanded versions of those
	/// found in KnowledgeBase articles Q319883 and Q319257.
	/// </remarks>
	public class ConsoleEx
	{	

		#region API and Structure Declarations

		// Standard structures used for interop with kernel32
		[StructLayout(LayoutKind.Sequential)]
			struct COORD
		{
			public short x;
			public short y;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct SMALL_RECT
		{
			public short Left;
			public short Top;
			public short Right;
			public short Bottom;
		}
		
		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_SCREEN_BUFFER_INFO
		{
			public COORD dwSize;
			public COORD dwCursorPosition;
			public int wAttributes;
			public SMALL_RECT srWindow;
			public COORD dwMaximumWindowSize;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_CURSOR_INFO 
		{
			public int dwSize;  
			public bool bVisible;
		} 


		// External function declarations
		[DllImport("kernel32.dll", EntryPoint="GetStdHandle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetStdHandle(int nStdHandle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleScreenBufferInfo", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput,
			ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTextAttribute", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleTextAttribute(int hConsoleOutput,
			int wAttributes);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputCharacter", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputCharacter(int hConsoleOutput, 
			byte cCharacter, int nLength, COORD dwWriteCoord, ref int lpNumberOfCharsWritten);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputAttribute", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputAttribute(int hConsoleOutput,
			int wAttribute, int nLength, COORD dwWriteCoord, ref int lpNumberOfAttrsWritten);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorPosition", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorPosition(int hConsoleOutput, 
			COORD dwCursorPosition);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleTitle(string lpConsoleTitle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleTitle(StringBuilder lpConsoleTitle, 
			int nSize);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);
		
		[DllImport("kernel32.dll", EntryPoint="ReadConsole", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool ReadConsole(int hConsoleInput,
			StringBuilder buf, int nNumberOfCharsToRead, ref int lpNumberOfCharsRead, int lpReserved);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleMode(int hConsoleHandle,
			int dwMode);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool GetConsoleMode(int hConsoleHandle,
			ref int dwMode);

		#endregion


		// Const variables
		private const int  INVALID_HANDLE_VALUE    = -1;
		private const int  STD_INPUT_HANDLE        = -10;
		private const int  STD_OUTPUT_HANDLE       = -11;
		private const byte EMPTY                   = 32;
		private const int  TITLE_LENGTH            = 1024;

		// Internal variables
		private static int hConsoleOutput;	// handle to output buffer
		private static int hConsoleInput;	// handle to input buffer
        //private static COORD ConsoleOutputLocation;
		private static CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
		private static int OriginalConsolePen;
		private static int CurrentConsolePen;

		
		// Constructors
		static ConsoleEx()
		{
			// Grab input and output buffer handles
			hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
			hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
			if (hConsoleOutput == INVALID_HANDLE_VALUE || hConsoleInput == INVALID_HANDLE_VALUE)
				throw new ApplicationException("Unable to obtain buffer handle during initialization.");

			// Get information about the console window characteristics.
			ConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
            //ConsoleOutputLocation = new COORD();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref ConsoleInfo);
			OriginalConsolePen = ConsoleInfo.wAttributes;

			// Disable wrapping at the end of a line (ENABLE_WRAP_AT_EOL_INPUT); this enables rectangles 
			// to be drawn that fill the screen without the window scrolling.
			SetConsoleMode(hConsoleOutput, 
				(int) OutputModeFlags.ENABLE_PROCESSED_OUTPUT);
		}

		private ConsoleEx() : base()
		{
			throw new NotSupportedException("This object may not be instantiated. Use static methods instead.");
		}


		/// <summary>
		/// Sets or gets the console window title.
		/// </summary>
		public static string Title 
		{
			get
			{
				StringBuilder title = new StringBuilder(TITLE_LENGTH);
				int ret = GetConsoleTitle(title, TITLE_LENGTH);
				return title.ToString(0, ret);
			}
			set 
			{	
				if (value.Length < TITLE_LENGTH)
					SetConsoleTitle(value);
				else
					throw new ArgumentOutOfRangeException(
						"Title", 
						value, 
						"Console window title must be no more than " + TITLE_LENGTH +  " characters.");
			}
		}


		/// <summary>
		/// Gets or sets the visibility of the cursor.
		/// </summary>
		public static bool CursorVisible
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.bVisible;
			}
			set
			{
				// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
				// also contains information on the shape of the cursor.
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

				ConsoleCursorInfo.bVisible = value;
				SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
			}
		}


		/// <summary>
		/// Gets or sets the height of the cursor, as a percentage of the overall character cell.
		/// The value must be a number between 1 and 100, otherwise an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		public static int CursorHeight
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.dwSize;
			}
			set
			{
				if (value >= 1 && value <= 100)
				{
					// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
					// also contains information on the visibility of the cursor.
					CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
					GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

					ConsoleCursorInfo.dwSize = value;
					SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				}
				else
					throw new ArgumentOutOfRangeException(
						"CursorHeight", 
						value, 
						"Cursor height must be a percentage of the character cell between 1 and 100.");
			}
		}


		/// <summary>
		/// Sets the console pen color to that specified.
		/// </summary>
		/// <param name="foreground">A foreground color specified from the 
		/// ConsoleForeground enumeration</param>
		/// <param name="background">A background color specified from the 
		/// ConsoleBackground enumeration</param>
		public static void TextColor(ConsoleForeground foreground, ConsoleBackground background)
		{
			CurrentConsolePen = (int)foreground + (int)background;
			SetConsoleTextAttribute(hConsoleOutput, CurrentConsolePen);
		}
	

		/// <summary>
		/// Resets the console pen color to the original default at the time 
		/// the class was originally initialised.
		/// </summary>
		public static void ResetColor()
		{
			SetConsoleTextAttribute(hConsoleOutput, OriginalConsolePen);
		}
	

		/// <summary>
		/// Clears screen.
		/// </summary>
		public static void Clear()
		{
			int hWrittenChars = 0;
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();			
			COORD Home;		
			Home.x = Home.y = 0;
			
			if (GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo) == 0)
			{
				// If the device does not support GetConsoleScreenBufferInfo, then try just
				// writing ^L (ASCII control code for Form Feed) to the screen. This may 
				// work for some scenarios such as using telnet to access a remote console.
				Console.Write('\x0c');	// ^L
				return;
			}
			
			FillConsoleOutputCharacter(hConsoleOutput, EMPTY, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			
			SetConsoleCursorPosition(hConsoleOutput, Home);
		}


		/// <summary>
		/// Moves the console cursor to the specified location on the screen.
		/// </summary>
		/// <param name="x">X co-ordinate for desired location (typically 0 to 79)</param>
		/// <param name="y">Y co-ordinate for desired location (typically 0 to 24)</param>
		public static void Move(int x, int y)
		{
			// Check that parameters specified are sane
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo);

			if (x >= strConsoleInfo.dwSize.x ||  x < 0)
				throw new ArgumentOutOfRangeException("x", x, 
					"The co-ordinates specified must be within the dimensions of the window.");

			if (y >= strConsoleInfo.dwSize.y || y < 0)
				throw new ArgumentOutOfRangeException("y", y, 
					"The co-ordinates specified must be within the dimensions of the window.");

			COORD Location;
			Location.x = (short)x;
			Location.y = (short)y;

			SetConsoleCursorPosition(hConsoleOutput, Location);
		}


		/// <summary>
		/// Writes the specified text at the given location.
		/// </summary>
		/// <remarks>
		/// This is a wrapper function that provides a shorthand for moving to a location and 
		/// writing there. The cursor will be left in the position immediately succeeding the 
		/// rightmost character of the text written to the screen.
		/// </remarks>
		/// <param name="x">X co-ordinate for leftmost character of text</param>
		/// <param name="y">Y co-ordinate for location of text</param>
		/// <param name="text">String to be written to the screen</param>
		public static void WriteAt(int x, int y, string text)
		{
			// No need to validate x and y co-ordinates as they will be tested by Move()
			Move(x, y);

			Console.Write(text);
		}


		/// <summary>
		/// Draws a rectangle on the console window using either 7-bit ASCII characters or
		/// line drawing characters, depending on the style specified. If the dimensions of 
		/// the rectangle exceed the boundaries of the screen, an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		/// <remarks>
		/// Note that the sides of the rectangle themselves are one character wide,
		/// so, for example, a width and height of 2 will result in a 3-by-3 character rectangle.
		/// This matches the behavior of the equivalent Windows Forms DrawRectangle() method.
		/// </remarks>
		/// <param name="style">A border style specified from the BorderStyle enumeration</param>
		/// <param name="x">X co-ordinate of upper left corner of rectangle</param>
		/// <param name="y">Y co-ordinate of upper left corner of rectangle</param>
		/// <param name="cx">Width of the rectangle</param>
		/// <param name="cy">Height of the rectangle</param>
		public static void DrawRectangle(BorderStyle style, int x, int y, int cx, int cy, bool fill)
		{
			if (style != BorderStyle.None)
			{
				// Set rectangle frame appropriately for the style chosen. Unicode 
				// characters represent horizontal and vertical lines, then NW, NE,
				// SW and SE corners of the rectangle in that order.
				string frame;
				switch(style)
				{
					case BorderStyle.LineSingle:
						frame = "\u2500\u2502\u250c\u2510\u2514\u2518";
						break;
					case BorderStyle.LineDouble:
						frame = "\u2550\u2551\u2554\u2557\u255A\u255D";
						break;
					default:
						frame = @"-|/\\/";
						break;
				}

				// Create top line of box
				StringBuilder line = new StringBuilder(cx+1);
				line.Append(frame[2]);
				for (int i=1; i < cx; i++) line.Append(frame[0]);
				line.Append(frame[3]);
				Move(x, y);
				Console.Write(line);

				// Create sides of box
				for (int i=1; i < cy; i++)
				{
					Move(x, y+i);
					Console.Write(frame[1]);
					Move(x+cx, y+i);
					Console.Write(frame[1]);
				}

				// Create bottom line of box
				line[0] = frame[4];
				line[cx] = frame[5];
				Move(x, y+cy);
				Console.Write(line);
			}
		
			// Fill rectangle with current console pen
			if (fill)
			{
				int hWrittenChars = 0;
				COORD c = new COORD();
				c.x = (short)x;
			
				for (int i=0; i<=cy; i++)
				{
					c.y = (short)(y + i);
					FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
						cx + 1, c, ref hWrittenChars);
				}
			}
		}

		
		/// <summary>
		/// Read a single character from the input buffer. Unlike Console.Read(), which 
		/// only reads from the buffer when the read operation has terminated (e.g. by
		/// pressing Enter), this method reads as soon as the character has been entered.
		/// </summary>
		/// <returns>The character read by the system</returns>
		public static char ReadChar()
		{
			// Temporarily disable character echo (ENABLE_ECHO_INPUT) and line input
			// (ENABLE_LINE_INPUT) during this operation
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));

			int lpNumberOfCharsRead = 0;
			StringBuilder buf = new StringBuilder(1);

			bool success = ReadConsole(hConsoleInput, buf, 1, ref lpNumberOfCharsRead, 0);
			
			// Reenable character echo and line input
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_ECHO_INPUT |
				InputModeFlags.ENABLE_LINE_INPUT |
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));
			
			if (success)
				return Convert.ToChar(buf[0]);
			else 
				throw new ApplicationException("Attempt to call ReadConsole API failed.");
		}
        
        ///
        /// BenZotto wrote this for BillingXCheck
        ///
        public static string ReadHiddenLine()
        {
            StringBuilder sb = new StringBuilder();
            char c;
            
            while((c = ReadChar()) != '\r' && c != '\n')
            {
                sb.Append(c);
            }
            
            return sb.ToString();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\cspp\csppDevTest\LoadSource.cs ===
using System;
using System.Collections;
using System.Text;
using System.IO;


using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace xonline.tools
{
    [TestClass]
    public class CsppDevTest_LoadSource
    {
        [TestMethod]
        public void LoadSource()
        {
            // create a temporary directory
            string sourcePath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
            Directory.CreateDirectory(sourcePath);

            // create a temp file
            string sourceFile = Path.Combine(sourcePath, Path.GetRandomFileName() + ".cs");
            StreamWriter file = File.CreateText(sourceFile);

            string expected = "some code goes here.";

            file.Write(expected);
            file.Close();

            // now load it
            string source = cspp.LoadSource(sourceFile);

            Assert.AreEqual(expected, source);

            // clean up
            Directory.Delete(sourcePath, true);

        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\accCmdTool\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by acccmdtool.rc
//
#define IDS_PROJNAME                    100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\accCmdTool\md4ms.cpp ===
/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Modelled after MD5 and SHA-1.

    Scott Field (sfield)    21-Oct-97

*/


#include "stdafx.h"

#include "md4.h"

#ifndef RSA32API 
#define RSA32API
#endif

/* Compile-time macro declarations for MD4.
*/

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

void MD4Transform (UINT4 state[4], unsigned char block[64]);


#define S11 3
#define S12 7
#define S13 11
#define S14 19
#define S21 3
#define S22 5
#define S23 9
#define S24 13
#define S31 3
#define S32 9
#define S33 11
#define S34 15


static const unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


/* F, G and H are basic MD4 functions.
 */

#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
#define G(x, y, z) (((x) & (y)) | ((z) & ((x) | (y))))
#define H(x, y, z) ((x) ^ (y) ^ (z))


/* FF, GG and HH are MD4 transformations for rounds 1, 2 and 3 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s) \
  {(a) += F ((b), (c), (d)) + (x); \
   (a) = ROTATE_LEFT ((a), (s));}
#define GG(a, b, c, d, x, s) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)013240474631; \
   (a) = ROTATE_LEFT ((a), (s));}
#define HH(a, b, c, d, x, s) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)015666365641; \
   (a) = ROTATE_LEFT ((a), (s));}


#ifdef KMODE_RSA32
#pragma alloc_text(PAGER32C, MD4Init)
#pragma alloc_text(PAGER32C, MD4Update)
#pragma alloc_text(PAGER32C, MD4Transform)
#pragma alloc_text(PAGER32C, MD4Final)
#endif  // KMODE_RSA32

/* MD4 initialization. Begins an MD4 operation, writing a new context.
 */
void
RSA32API
MD4Init (
    MD4_CTX *context                                         /* context */
    )
{
    context->count[0] = 0;
    context->count[1] = 0;

    /* Load magic initialization constants.
     */

    context->state[0] = 0x67452301;
    context->state[1] = 0xefcdab89;
    context->state[2] = 0x98badcfe;
    context->state[3] = 0x10325476;
}

/* MD4 block update operation. Continues an MD4 message-digest
     operation, processing another message block, and updating the
     context.
 */

void
RSA32API
MD4Update (
    MD4_CTX *context,                                        /* context */
    unsigned char *input,                                /* input block */
    unsigned int inputLen                      /* length of input block */
    )
{

  unsigned int bufferLen;

  /* Compute number of bytes mod 64 */
  bufferLen = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((DWORD)inputLen << 3)) < ((DWORD)inputLen << 3))
    context->count[1]++;

  context->count[1] += ((DWORD)inputLen >> 29);

  /* If previous input in buffer, buffer new input and transform if
       possible.
   */
  if (bufferLen > 0 && bufferLen + inputLen >= 64) {
    memcpy(context->buffer+bufferLen, input, 64-bufferLen);
    input += (64-bufferLen);
    inputLen -= (64-bufferLen);
    MD4Transform (context->state, context->buffer);
    bufferLen = 0;
  }

    if( (DWORD_PTR)input & (sizeof(DWORD_PTR) - 1) ) {
        /* Copy input to aligned temporary buffer
         */
        while (inputLen >= 64) {
            memcpy( context->buffer, input, 64 );
            MD4Transform (context->state, context->buffer);
            input += 64;
            inputLen -= 64;
        }
    } else {
        /* Transform directly from input.
         */
        while (inputLen >= 64) {
            MD4Transform (context->state, input);
            input += 64;
            inputLen -= 64;
        }
    }

  /* Buffer remaining input */
  if (inputLen)
    memcpy(context->buffer+bufferLen, input, inputLen);

}

/* MD4 finalization. Ends an MD4 message-digest operation, writing the
     message digest and zeroizing the context.
 */
void
RSA32API
MD4Final (
    MD4_CTX *context                                         /* context */
    )
{
    unsigned int index, padLen;

    /* Save number of bits */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->count[0];
    ((unsigned long *)context->digest)[1] = context->count[1];
#else
  DWORDToLittleEndian (context->digest, context->count, 8);
#endif

    /* Pad out to 56 mod 64. */

    index = (unsigned int)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD4Update (context, (unsigned char *)PADDING, padLen);

    /* Append length (before padding) */

    MD4Update (context, context->digest, 8);

    /* Store state in digest */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->state[0];
    ((unsigned long *)context->digest)[1] = context->state[1];
    ((unsigned long *)context->digest)[2] = context->state[2];
    ((unsigned long *)context->digest)[3] = context->state[3];
#else
  DWORDToLittleEndian (context->digest, context->state, 16);
#endif

}

/* MD4 basic transformation. Transforms state based on block.
 */

//#ifndef _X86_ // use optimized .asm version of MD4Transform on x86

void
MD4Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3];

#if !defined(BIGENDIAN) || !BIGENDIAN
  unsigned long *x = (unsigned long*)block;
#else
  unsigned long x[16];
  DWORDFromLittleEndian (x, (unsigned char *)block, 64);
#endif

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11); /* 1 */
  FF (d, a, b, c, x[ 1], S12); /* 2 */
  FF (c, d, a, b, x[ 2], S13); /* 3 */
  FF (b, c, d, a, x[ 3], S14); /* 4 */
  FF (a, b, c, d, x[ 4], S11); /* 5 */
  FF (d, a, b, c, x[ 5], S12); /* 6 */
  FF (c, d, a, b, x[ 6], S13); /* 7 */
  FF (b, c, d, a, x[ 7], S14); /* 8 */
  FF (a, b, c, d, x[ 8], S11); /* 9 */
  FF (d, a, b, c, x[ 9], S12); /* 10 */
  FF (c, d, a, b, x[10], S13); /* 11 */
  FF (b, c, d, a, x[11], S14); /* 12 */
  FF (a, b, c, d, x[12], S11); /* 13 */
  FF (d, a, b, c, x[13], S12); /* 14 */
  FF (c, d, a, b, x[14], S13); /* 15 */
  FF (b, c, d, a, x[15], S14); /* 16 */

  /* Round 2 */
  GG (a, b, c, d, x[ 0], S21); /* 17 */
  GG (d, a, b, c, x[ 4], S22); /* 18 */
  GG (c, d, a, b, x[ 8], S23); /* 19 */
  GG (b, c, d, a, x[12], S24); /* 20 */
  GG (a, b, c, d, x[ 1], S21); /* 21 */
  GG (d, a, b, c, x[ 5], S22); /* 22 */
  GG (c, d, a, b, x[ 9], S23); /* 23 */
  GG (b, c, d, a, x[13], S24); /* 24 */
  GG (a, b, c, d, x[ 2], S21); /* 25 */
  GG (d, a, b, c, x[ 6], S22); /* 26 */
  GG (c, d, a, b, x[10], S23); /* 27 */
  GG (b, c, d, a, x[14], S24); /* 28 */
  GG (a, b, c, d, x[ 3], S21); /* 29 */
  GG (d, a, b, c, x[ 7], S22); /* 30 */
  GG (c, d, a, b, x[11], S23); /* 31 */
  GG (b, c, d, a, x[15], S24); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 0], S31); /* 33 */
  HH (d, a, b, c, x[ 8], S32); /* 34 */
  HH (c, d, a, b, x[ 4], S33); /* 35 */
  HH (b, c, d, a, x[12], S34); /* 36 */
  HH (a, b, c, d, x[ 2], S31); /* 37 */
  HH (d, a, b, c, x[10], S32); /* 38 */
  HH (c, d, a, b, x[ 6], S33); /* 39 */
  HH (b, c, d, a, x[14], S34); /* 40 */
  HH (a, b, c, d, x[ 1], S31); /* 41 */
  HH (d, a, b, c, x[ 9], S32); /* 42 */
  HH (c, d, a, b, x[ 5], S33); /* 43 */
  HH (b, c, d, a, x[13], S34); /* 44 */
  HH (a, b, c, d, x[ 3], S31); /* 45 */
  HH (d, a, b, c, x[11], S32); /* 46 */
  HH (c, d, a, b, x[ 7], S33); /* 47 */
  HH (b, c, d, a, x[15], S34); /* 48 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
}

//#endif // !_X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\accCmdTool\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	AccCmdTool.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Deactivator\Enum.cs ===
// Enumerations used for setting console window colors.
using System;

namespace xonline.tools.deactivator 
{
	/// <summary>
	/// Color definitions for the console foreground.
	/// </summary>
	public enum ConsoleForeground
	{	
		Black      = 0x00,
		Navy       = 0x01,
		DarkGreen  = 0x02,
		Aquamarine = 0x03,
		Maroon     = 0x04,
		Purple     = 0x05,
		Olive      = 0x06,
		LightGray  = 0x07,
		DarkGray   = 0x08,
		Blue       = 0x09,
		Green      = 0x0A,
		Cyan       = 0x0B,
		Red        = 0x0C,
		Magenta    = 0x0D,
		Yellow     = 0x0E,
		White      = 0x0F
	}


	/// <summary>
	/// Color definitions for the console background.
	/// </summary>
	public enum ConsoleBackground
	{	
		Black      = 0x00,
		Navy       = 0x10,
		DarkGreen  = 0x20,
		Aquamarine = 0x30,
		Maroon     = 0x40,
		Purple     = 0x50,
		Olive      = 0x60,
		LightGray  = 0x70,
		DarkGray   = 0x80,
		Blue       = 0x90,
		Green      = 0xA0,
		Cyan       = 0xB0,
		Red        = 0xC0,
		Magenta    = 0xD0,
		Yellow     = 0xE0,
		White      = 0xF0
	}


	/// <summary>
	/// Border styles used for drawing rectangles on the console output window.
	/// </summary>
	public enum BorderStyle
	{
		None,
		Text,
		LineSingle,
		LineDouble
	}


	[Flags]
	public enum InputModeFlags
	{
		ENABLE_PROCESSED_INPUT = 0x01,
		ENABLE_LINE_INPUT      = 0x02,
		ENABLE_ECHO_INPUT      = 0x04,
		ENABLE_WINDOW_INPUT    = 0x08,
		ENABLE_MOUSE_INPUT     = 0x10
	}

	[Flags]
	public enum OutputModeFlags
	{
		ENABLE_PROCESSED_OUTPUT   = 0x01,
		ENABLE_WRAP_AT_EOL_OUTPUT = 0x02
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\accCmdTool\AccCmdTool.cpp ===
//---------------------------------------------------------------------------------
// AccCmdTool.cpp 
//
// Dev:  Lawrence Ohab (lohab)
// Date:  Oct. 1, 2001
// Comments:  This tool reads the command line for a user name and string.  It will
//    use this name to create a user account on passport, then return the details in 
//    a formatted line of text.
//
//    Copyright (C) Microsoft Corporation.  All Rights Reserved.
//---------------------------------------------------------------------------------


//------------------------------------------------------------------
//  INCLUDES
//------------------------------------------------------------------
#include "stdafx.h"

#include <stdlib.h>
#include <malloc.h>
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#include <wincrypt.h>
#include <md4.h>

// include deladmin tool
#include "DelAdmin.h"
#include "DelAdmin_i.c"

#ifdef __cplusplus
extern "C" {
#endif

//------------------------------------------------------------------
//  DEFINITIONS
//------------------------------------------------------------------
// this should be declared in an ini file  THIS IS FOR xboxtest.com
const int SIGNIN_NAME_INDEX = 1;
const int SIGNIN_KINGDOM_INDEX = 2;
const int SIGNIN_DOMAIN_INDEX = 3;
const int DEFAULT_PASSWORD_SIZE = 17;

//------------------------------------------------------------------
//  FUNCTIONS
//------------------------------------------------------------------

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','_','-'
};

//------------------------------------------------------------------
//  GenerateRandomString:  generates a valid password for a user.
//
//------------------------------------------------------------------
BOOL GenerateRandomString( char *szBuf, int nBufSize )
{
    HCRYPTPROV hCryptProv;
    int i;
    BOOL bRet = TRUE;
  
	_ASSERT( szBuf != NULL );
    //--------------------------------------------------------------------
    // Get a handle to the default PROV_RSA_FULL provider.

    if( !CryptAcquireContext( &hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)) 
    {
        if(!CryptAcquireContext( &hCryptProv,  NULL,  NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) 
        {
            bRet = FALSE;
            goto Exit;
        }
    }

    // Generate random bytes.
    if( !CryptGenRandom( hCryptProv, sizeof(char) *nBufSize,  (BYTE*)szBuf)) 
    {
        bRet = FALSE;
        goto Exit;    
    }

    for ( i = 0; i < nBufSize; i++ )
    {
        szBuf[i] = g_achBase64EncodeTable[((unsigned int)(szBuf[i]))%sizeof(g_achBase64EncodeTable)];
    }

    if ( !CryptReleaseContext( hCryptProv, NULL ) )
    {
        // memory leak
        bRet = FALSE;
        goto Exit;
    }
    
Exit:
    
    return bRet;
}

//------------------------------------------------------------------
//  CreateUser:  Creates a user on passport for xboxtest.com.
//
//------------------------------------------------------------------
BOOL CreateUser( char *szName, char *szKingdom, char *szDomain, ULONGLONG &ullNewId, char *szPassword)
{
	BOOL bRes = TRUE;
    CComBSTR bszPassword = NULL;
    CComBSTR bszUserId = CComBSTR();
    CComBSTR bszError = CComBSTR();
    HRESULT hr;
	char username[64];
    char secretAns[64];
    
    char szUserId[24];
    IDAdmin    *pDAdmin = NULL;
    IUser      *pDAUser = NULL;

    // clean out these buffers
    ZeroMemory(szUserId, sizeof(szUserId));
    
    sprintf(username, "%s.%s@%s", szName, szKingdom, szDomain);

    // initialize DA tool.
    hr = CoCreateInstance( CLSID_CDAdmin, 
                                 NULL, 
                                 CLSCTX_ALL, 
                                 IID_IDAdmin, 
                                 (VOID**)&pDAdmin ); 
    if ( FAILED(hr) )
    {
        bRes = FALSE;
		fprintf(stderr, "Failed to create DelAdmin object.  Result = %u\n", hr );
        goto Cleanup;             
    }

    // load the configuration file.
    hr = pDAdmin->LoadConfig();
    if ( FAILED(hr) )
    {
        bRes = FALSE;
		fprintf(stderr, "Failed to load the config file.  Result = %u\n", hr );
        goto Cleanup;             
    }
    
	// init the object,
    hr = pDAdmin->Init( FALSE );
    if ( FAILED(hr) )
    {
        bRes = FALSE;
		fprintf(stderr, "Failed to Initialize DelAdmin object. Result = %u\n", hr );
		fprintf(stderr, "The cause may be that we cannot contact passport or the config file is invalid.  Please check the config file and partner dependencies(Passport).", hr );
        goto Cleanup;             
    }

    
    // set up a passport user node
    hr = CoCreateInstance( CLSID_CUser, 
                                    NULL, 
                                    CLSCTX_ALL, 
                                    IID_IUser,
                                    (VOID**)&pDAUser );

    if ( FAILED(hr) )
    {
        bRes = FALSE;
		fprintf(stderr, "Failed to create User DelAdmin object.  Result = %u\n", hr );
        goto Cleanup;             
    }
    
    // generate the answer
    if ( !GenerateRandomString( secretAns, sizeof(secretAns)-1 ) )
	{
        bRes = FALSE;
		fprintf(stderr, "Failed to genereate a secret answer.\n");
        goto Cleanup;             
	}
	secretAns[sizeof(secretAns)-1] = '\0';

    // generate the password
    if ( !GenerateRandomString( szPassword, DEFAULT_PASSWORD_SIZE-1 ) )
	{
        bRes = FALSE;
		fprintf(stderr, "Failed to genereate a password.\n");
        goto Cleanup;             
	}

    szPassword[DEFAULT_PASSWORD_SIZE-1] = '\0';

    // TODO:  (LOHAB)  how do we handle special fields.
    bszPassword = CComBSTR(szPassword);
    pDAUser->put_Password( bszPassword.m_str );
    pDAUser->put_SignInName( CComBSTR(username).m_str );
    pDAUser->put_SecretQuestion( CComBSTR(L"What is your favorite ASCII string").m_str );
    pDAUser->put_SecretAnswer( CComBSTR(secretAns).m_str );
    pDAUser->put_Country( CComBSTR(L"US").m_str );
    pDAUser->put_PostalCode( CComBSTR(L"98007").m_str );
    pDAUser->put_Region( CComBSTR(L"35841").m_str );


    // contact passport and create a new account for this machine.
    hr = pDAdmin->NameSpaceSignUpRequest(pDAUser, &(bszError.m_str));
    if ( FAILED( hr ) || !( wcscmp( bszError.m_str, L"TRUE" ) == 0 ))
    {
		fwprintf( stderr, bszError );
		fwprintf( stderr, L"\n" );

		// try to evict the user.
		hr = pDAdmin->NameSpaceRemoveMemberRequest( pDAUser, &(bszError.m_str) );
		if ( FAILED( hr ) || !( wcscmp( bszError.m_str, L"TRUE" ) == 0 ))
	    {
			fwprintf( stderr, bszError );
			fwprintf( stderr, L"\n" );

			bRes = FALSE;
			goto Cleanup;                      
		}

		// now try to create the user again..
		hr = pDAdmin->NameSpaceSignUpRequest(pDAUser, &(bszError.m_str));
		if ( FAILED( hr ) || !( wcscmp( bszError.m_str, L"TRUE" ) == 0 ))
	    {
			fwprintf( stderr, bszError );
			fwprintf( stderr, L"\n" );

			bRes = FALSE;
			goto Cleanup;                      
		}
    }

    // get any necessary information.  Place it in  the return node
    pDAUser->get_UserPUID(&(bszUserId.m_str));

    // change the bstr id into a number
    swscanf(bszUserId.m_str, L"%I64u", &(ullNewId) );

Cleanup:
    // zero password memory
    bszPassword.Empty();
	bszUserId.Empty();

    if ( pDAUser )
    {
        // close up del admin
        pDAUser->Release();
    }

	// init the object,
    if ( pDAdmin != NULL )
    {
        hr = pDAdmin->Close();
        if ( FAILED(hr) )
        {
            bRes = FALSE;
		    fprintf(stderr, "Failed to Initialize DelAdmin object.  Result = %u\n", hr );
        }

        pDAdmin->Release();
    }

    
    
    return bRes;
}

//------------------------------------------------------------------
//  PrintInHex()  : prints out a character string in HEX format.
//------------------------------------------------------------------
void PrintInHex( int nSize, unsigned char *szBuf )
{
	int nX = 0;

	for ( nX = 0; nX < nSize; nX++ )
	{
		printf("%2.2X", szBuf[nX] );
	}
}

//------------------------------------------------------------------
//  PrintInHex()  : prints out a character string in HEX format.
//------------------------------------------------------------------
unsigned int 
KerbPasswordToKey(
    char *pszPassword,
    unsigned char *Key
    )
{
	USES_CONVERSION;
    unsigned int Status;
    MD4_CTX md4Ctx;
    DWORD dwPasswordLen;
    WCHAR* pwcUnicodePassword;

	dwPasswordLen = strlen( pszPassword );
    pwcUnicodePassword = A2W( pszPassword );

    if (pwcUnicodePassword == NULL) {
        Status = 1;
        goto Cleanup;
    }
    
    MD4Init( &md4Ctx );
    MD4Update( &md4Ctx, (unsigned char *)pwcUnicodePassword, dwPasswordLen * sizeof(WCHAR) );
    MD4Final( &md4Ctx );

    RtlCopyMemory( Key, md4Ctx.digest, MD4_LEN );
    
    Status = 0;

Cleanup:
    if (Status != 0)
    {
        fprintf( stderr, "KerbPasswordToKey failure status with insufficient resources.  Status=0x%X\n", Status );
    }
    return(Status);
}


//------------------------------------------------------------------
//  main()  : program main exe path.
//------------------------------------------------------------------
int __cdecl main(int argc, char* argv[])
{
	char szPassword[DEFAULT_PASSWORD_SIZE];
	ULONGLONG ullId;
	int nRet = 0;
	int nLoop = 0;
	unsigned char key[MD4_LEN];

	CoInitialize(NULL);
	// ensure the requirements.
	if (argc != 4 && argc != 5) 
	{
		fprintf(stderr, "Usage: AccCmdTool <name> <kingdom> <domain> [<tailString>]\n");
		nRet = 1;
		goto Exit;
	}

	// print out the necesary info.
	if ( CreateUser( argv[SIGNIN_NAME_INDEX], argv[SIGNIN_KINGDOM_INDEX], argv[SIGNIN_DOMAIN_INDEX], ullId, szPassword ) )
	{
		KerbPasswordToKey( szPassword, key );
		// print the PUID
		printf("%.16I64x,%s,%s,%s,", ullId, argv[SIGNIN_NAME_INDEX], argv[SIGNIN_KINGDOM_INDEX], argv[SIGNIN_DOMAIN_INDEX]); 
		PrintInHex( MD4_LEN, key);

		// print the string.
		if (4 < argc)
		{	
			printf(",%s", argv[4]);
		}
		printf("\n");
	}
	else
	{
		fprintf( stderr, "Failed to create a user.  \n");
		nRet = 1;
		goto Exit;
	}

Exit:
	CoUninitialize();
	return nRet;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Deactivator\sps.cs ===
//
//  SPS.cs
//
//  Ben Zotto (benzotto), October 2002
//
//
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions;
                                  
                                     
namespace xonline.tools.deactivator 
{

    class SPS
    {
        private static BillingProvider _bdk = null;
        public static string Server;
        public static string IISUser;
                        
        public static int CheckOfferInBilling(string offeringID, string serviceComponentID, string opd)
        {
            if(_bdk == null) { _bdk = new BillingProvider(Server, IISUser); }
            
            int errorCount = 0;
            string errorText;
            int    offeringInfoCount, serviceComponentCount;
            string offeringInfoSet, serviceComponentSet;
            
            try
            {
                _bdk.GetBaseOfferings(offeringID, "", "", "en-US", "", out errorText, out offeringInfoCount, out offeringInfoSet);
            }
            catch (Exception e)
            {                
                if(e.Message.StartsWith("<ErrorPackage><ErrorHResult>0x80049E84"))
                {
                    errorCount++;
                    Output.WriteLine("FAIL: SPS doesn't know about offering " + offeringID + " (in expected en-US locale, anyways)");
                    return errorCount;
                }
                else
                    throw;
            }
            
            if(offeringInfoCount != 1)
            {
                    errorCount++;
                    Output.WriteLine("FAIL: SPS reports " + offeringInfoCount + " offerings matching " + offeringID + "!");
                    Output.WriteVerbose("\t(in en-US locale, anyways)");
                    return errorCount;                
            }
            
            //
            // get info set            
            //             
            if(opd != null && opd != "")
            {            
                OfferingInfoSet ois = new OfferingInfoSet();
                ois.FromXml(offeringInfoSet);            
                
                if(opd != ois.OfferingPriceDescription.Trim())
                {
                    errorCount++;
                    Output.WriteLine("WARNING: Offer " + offeringID + " has mismatching OPD set!");
                    Output.WriteVerbose("\tin SPS: \"" + ois.OfferingPriceDescription + "\" expecting: \"" + opd + "\"");                            
                }
            }
            
            //
            // Get Service Compoent info
            //                                 
            if(serviceComponentID != null && serviceComponentID != "")
            {
                try
                {
                    _bdk.GetServiceComponents(offeringID, out errorText, out serviceComponentCount, out serviceComponentSet);
                }
                catch (Exception e)
                {                
                    if(e.Message.StartsWith("<ErrorPackage><ErrorHResult>0x80049E84"))
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: SPS doesn't know about offering " + offeringID);
                        return errorCount;
                    }
                    else
                        throw;
                }
                
                if(serviceComponentCount != 1)
                {
                        errorCount++;
                        Output.WriteLine("FAIL: SPS reports " + serviceComponentCount + " components matching " + offeringID + "!");
                        Output.WriteVerbose("\t(in en-US locale, anyways)");
                        return errorCount;                
                }
                
                ServiceComponentSet scs = new ServiceComponentSet();
                scs.FromXml(serviceComponentSet);            
                
                if(serviceComponentID.ToUpper() != scs.ServiceComponentId.ToUpper())
                {
                    errorCount++;
                    Output.WriteLine("WARNING: Offer " + offeringID + " has mismatching Service Component!");
                    Output.WriteVerbose("\tin SPS: \"" + scs.ServiceComponentId + "\" expecting: \"" + serviceComponentID + "\"");                            
                }
                
            }                                 
                                        
            return errorCount; 
        }
                
    }
    
    
    public class OfferingInfoSet
    {
        public string   OfferingGUID;
        public string   OfferingDescription;
        public string   OfferingPriceDescription;
        public string   InternalOfferingDescription;
        public string   LastAvailableDate;
        public string   FirstAvailableDate;
        public string   BaseOffering;
        public string   TermLocation;
        public string   CommitmentTerms;
        public string   MutuallyExclusiveGroupIdSet;
        public string   SignUpURL;
        public string   PaymentInstrumentRequired;                
        public string   PaymentTypeSet;
        public string   PaymentType;
            
        public OfferingInfoSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "OfferingInfoSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "OfferingGUID":
                       OfferingGUID = xmlReader.ReadElementString();
                       break;
    
                    case "OfferingDescription":
                        OfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "OfferingPriceDescription":
                        OfferingPriceDescription = xmlReader.ReadElementString();
                        break;
    
                    case "InternalOfferingDescription":
                        InternalOfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "LastAvailableDate":
                        LastAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "FirstAvailableDate":
                        FirstAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "BaseOffering":
                        BaseOffering = xmlReader.ReadElementString();
                        break;
    
                    case "TermLocation":
                        TermLocation = xmlReader.ReadElementString();
                        break;
    
                    case "CommitmentTerms":
                        CommitmentTerms = xmlReader.ReadElementString();
                        break;
    
                    case "MutuallyExclusiveGroupIdSet":
                        MutuallyExclusiveGroupIdSet = xmlReader.ReadElementString();
                        break;
    
                    case "SignUpURL":
                        SignUpURL = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentInstrumentRequired":
                        PaymentInstrumentRequired = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentType":
                        if(PaymentType == null)
                        {
                            PaymentType = xmlReader.ReadElementString();
                        }
                        else
                        {   
                            Output.WriteLine("WARNING: Offering " + OfferingGUID + " has multiple payment types defined.");
                            xmlReader.ReadElementString();
                        }
                        break;   
    
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "OfferingInfo")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "PaymentTypeSet")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        

                        
                        xmlReader.Skip();
                        break;
                }
            }
        }        
    }    
    
    public class ServiceComponentSet
    {                
        public string   ServiceComponentId;
        public string   InstanceCount;
        public string   ServiceComponentName;
        public string   MaxRoles;
            
        public ServiceComponentSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "ServiceComponentSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "ServiceComponentId":
                       ServiceComponentId = xmlReader.ReadElementString();
                       break;
    
                    case "InstanceCount":
                        InstanceCount = xmlReader.ReadElementString();
                        break;
    
                    case "ServiceComponentName":
                        ServiceComponentName = xmlReader.ReadElementString();
                        break;
    
                    case "MaxRoles":
                        MaxRoles = xmlReader.ReadElementString();
                        break;
    
       
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "ServiceComponent")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }                                                
                        
                        xmlReader.Skip();
                        break;
                }
            }
        }
        
    
        
    
            
    }      
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\md4ms.cpp ===
/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Modelled after MD5 and SHA-1.

    Scott Field (sfield)    21-Oct-97

*/


#include "stdafx.h"

#include "md4.h"

#ifndef RSA32API 
#define RSA32API
#endif

/* Compile-time macro declarations for MD4.
*/

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

void MD4Transform (UINT4 state[4], unsigned char block[64]);


#define S11 3
#define S12 7
#define S13 11
#define S14 19
#define S21 3
#define S22 5
#define S23 9
#define S24 13
#define S31 3
#define S32 9
#define S33 11
#define S34 15


static const unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


/* F, G and H are basic MD4 functions.
 */

#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
#define G(x, y, z) (((x) & (y)) | ((z) & ((x) | (y))))
#define H(x, y, z) ((x) ^ (y) ^ (z))


/* FF, GG and HH are MD4 transformations for rounds 1, 2 and 3 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s) \
  {(a) += F ((b), (c), (d)) + (x); \
   (a) = ROTATE_LEFT ((a), (s));}
#define GG(a, b, c, d, x, s) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)013240474631; \
   (a) = ROTATE_LEFT ((a), (s));}
#define HH(a, b, c, d, x, s) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)015666365641; \
   (a) = ROTATE_LEFT ((a), (s));}


#ifdef KMODE_RSA32
#pragma alloc_text(PAGER32C, MD4Init)
#pragma alloc_text(PAGER32C, MD4Update)
#pragma alloc_text(PAGER32C, MD4Transform)
#pragma alloc_text(PAGER32C, MD4Final)
#endif  // KMODE_RSA32

/* MD4 initialization. Begins an MD4 operation, writing a new context.
 */
void
RSA32API
MD4Init (
    MD4_CTX *context                                         /* context */
    )
{
    context->count[0] = 0;
    context->count[1] = 0;

    /* Load magic initialization constants.
     */

    context->state[0] = 0x67452301;
    context->state[1] = 0xefcdab89;
    context->state[2] = 0x98badcfe;
    context->state[3] = 0x10325476;
}

/* MD4 block update operation. Continues an MD4 message-digest
     operation, processing another message block, and updating the
     context.
 */

void
RSA32API
MD4Update (
    MD4_CTX *context,                                        /* context */
    unsigned char *input,                                /* input block */
    unsigned int inputLen                      /* length of input block */
    )
{

  unsigned int bufferLen;

  /* Compute number of bytes mod 64 */
  bufferLen = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((DWORD)inputLen << 3)) < ((DWORD)inputLen << 3))
    context->count[1]++;

  context->count[1] += ((DWORD)inputLen >> 29);

  /* If previous input in buffer, buffer new input and transform if
       possible.
   */
  if (bufferLen > 0 && bufferLen + inputLen >= 64) {
    memcpy(context->buffer+bufferLen, input, 64-bufferLen);
    input += (64-bufferLen);
    inputLen -= (64-bufferLen);
    MD4Transform (context->state, context->buffer);
    bufferLen = 0;
  }

    if( (DWORD_PTR)input & (sizeof(DWORD_PTR) - 1) ) {
        /* Copy input to aligned temporary buffer
         */
        while (inputLen >= 64) {
            memcpy( context->buffer, input, 64 );
            MD4Transform (context->state, context->buffer);
            input += 64;
            inputLen -= 64;
        }
    } else {
        /* Transform directly from input.
         */
        while (inputLen >= 64) {
            MD4Transform (context->state, input);
            input += 64;
            inputLen -= 64;
        }
    }

  /* Buffer remaining input */
  if (inputLen)
    memcpy(context->buffer+bufferLen, input, inputLen);

}

/* MD4 finalization. Ends an MD4 message-digest operation, writing the
     message digest and zeroizing the context.
 */
void
RSA32API
MD4Final (
    MD4_CTX *context                                         /* context */
    )
{
    unsigned int index, padLen;

    /* Save number of bits */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->count[0];
    ((unsigned long *)context->digest)[1] = context->count[1];
#else
  DWORDToLittleEndian (context->digest, context->count, 8);
#endif

    /* Pad out to 56 mod 64. */

    index = (unsigned int)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD4Update (context, (unsigned char *)PADDING, padLen);

    /* Append length (before padding) */

    MD4Update (context, context->digest, 8);

    /* Store state in digest */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->state[0];
    ((unsigned long *)context->digest)[1] = context->state[1];
    ((unsigned long *)context->digest)[2] = context->state[2];
    ((unsigned long *)context->digest)[3] = context->state[3];
#else
  DWORDToLittleEndian (context->digest, context->state, 16);
#endif

}

/* MD4 basic transformation. Transforms state based on block.
 */

//#ifndef _X86_ // use optimized .asm version of MD4Transform on x86

void
MD4Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3];

#if !defined(BIGENDIAN) || !BIGENDIAN
  unsigned long *x = (unsigned long*)block;
#else
  unsigned long x[16];
  DWORDFromLittleEndian (x, (unsigned char *)block, 64);
#endif

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11); /* 1 */
  FF (d, a, b, c, x[ 1], S12); /* 2 */
  FF (c, d, a, b, x[ 2], S13); /* 3 */
  FF (b, c, d, a, x[ 3], S14); /* 4 */
  FF (a, b, c, d, x[ 4], S11); /* 5 */
  FF (d, a, b, c, x[ 5], S12); /* 6 */
  FF (c, d, a, b, x[ 6], S13); /* 7 */
  FF (b, c, d, a, x[ 7], S14); /* 8 */
  FF (a, b, c, d, x[ 8], S11); /* 9 */
  FF (d, a, b, c, x[ 9], S12); /* 10 */
  FF (c, d, a, b, x[10], S13); /* 11 */
  FF (b, c, d, a, x[11], S14); /* 12 */
  FF (a, b, c, d, x[12], S11); /* 13 */
  FF (d, a, b, c, x[13], S12); /* 14 */
  FF (c, d, a, b, x[14], S13); /* 15 */
  FF (b, c, d, a, x[15], S14); /* 16 */

  /* Round 2 */
  GG (a, b, c, d, x[ 0], S21); /* 17 */
  GG (d, a, b, c, x[ 4], S22); /* 18 */
  GG (c, d, a, b, x[ 8], S23); /* 19 */
  GG (b, c, d, a, x[12], S24); /* 20 */
  GG (a, b, c, d, x[ 1], S21); /* 21 */
  GG (d, a, b, c, x[ 5], S22); /* 22 */
  GG (c, d, a, b, x[ 9], S23); /* 23 */
  GG (b, c, d, a, x[13], S24); /* 24 */
  GG (a, b, c, d, x[ 2], S21); /* 25 */
  GG (d, a, b, c, x[ 6], S22); /* 26 */
  GG (c, d, a, b, x[10], S23); /* 27 */
  GG (b, c, d, a, x[14], S24); /* 28 */
  GG (a, b, c, d, x[ 3], S21); /* 29 */
  GG (d, a, b, c, x[ 7], S22); /* 30 */
  GG (c, d, a, b, x[11], S23); /* 31 */
  GG (b, c, d, a, x[15], S24); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 0], S31); /* 33 */
  HH (d, a, b, c, x[ 8], S32); /* 34 */
  HH (c, d, a, b, x[ 4], S33); /* 35 */
  HH (b, c, d, a, x[12], S34); /* 36 */
  HH (a, b, c, d, x[ 2], S31); /* 37 */
  HH (d, a, b, c, x[10], S32); /* 38 */
  HH (c, d, a, b, x[ 6], S33); /* 39 */
  HH (b, c, d, a, x[14], S34); /* 40 */
  HH (a, b, c, d, x[ 1], S31); /* 41 */
  HH (d, a, b, c, x[ 9], S32); /* 42 */
  HH (c, d, a, b, x[ 5], S33); /* 43 */
  HH (b, c, d, a, x[13], S34); /* 44 */
  HH (a, b, c, d, x[ 3], S31); /* 45 */
  HH (d, a, b, c, x[11], S32); /* 46 */
  HH (c, d, a, b, x[ 7], S33); /* 47 */
  HH (b, c, d, a, x[15], S34); /* 48 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
}

//#endif // !_X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\accCmdTool\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__6DB68289_7739_4843_9B89_3191C0DBCC13__INCLUDED_)
#define AFX_STDAFX_H__6DB68289_7739_4843_9B89_3191C0DBCC13__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6DB68289_7739_4843_9B89_3191C0DBCC13__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Deactivator\bdk.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://sps25tiexbox1.tiexbox1.ssd.extest.microsoft.com/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReplacePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReplacePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Deactivator\Deactivator.cs ===
using System;
using System.IO;
using System.Text;
using System.Globalization;
using System.Collections;
using System.Collections.Specialized;
using System.Security.Cryptography;
using System.Data;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using System.Xml;
using xonline.common.service;

using xonline.common.tools.console;
//using XBOX.Billing.MSProvider;

namespace xonline.tools.deactivator 
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class CDeactivator
    {
        public static EventLog _eventlog   = null;
        //static int HASHLINELENGTH = 54;

        static BillingProvider _sps = null;

        static SHA1CryptoServiceProvider _sha;
        static UnicodeEncoding _enc;

        static long _userPuid = 0;
        static int _used = 0;
        static int _canceled = 0;

        static ArrayList _servers = null;
        static ArrayList _hashBuckets = null;
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] rawArgs)
        {
            // Input:
            // /can (Cancellations with subscription codes)
            // /ref (Refunds for subscription codes with price > 0)
            // /ret (Returns to retail, has serial numbers which need to be converted to sub codes)
            // /file (Loose sub codes, 1 per line)

            // all of these inputs lead to one thing, getting a subscription code.
            // once we have the subscription codes we see if that sub code has been used to make an account

            // if it has, we mark the code as used and set use_count to 0

            // if not we get the user_puid.  if the puid is in the billing queue, we delete it from the queue
            // else (the user is in sps) we delete all subscriptions in sps that the user purchased
            // finally, we go into UODB and mark the account as deactivated
            try
            {

                ArrayList subs = new ArrayList();
                ArrayList hashes = new ArrayList();
                
                
                _eventlog = new EventLog();
                _eventlog.Source = "Deactivator";

                _eventlog.WriteEntry("Deactivator ran with the following arguments: \n" + 
                    Environment.CommandLine, EventLogEntryType.Information);

                Output.Level = Output.NORMAL;

                NamedArgParser args;
                string [] tags = {
                                     "can",
                                     "ref",
                                     "ret",
                                     "file",
                                     "serial",
                                     "test",
                                     "server",
                                     "user",
                                     "output",
                                     "?"
                                 };

                args = new NamedArgParser(tags);

                if (!args.Parse(rawArgs))
                {
                    Help();
                    return 1;
                }

                if (args["?"] != null)
                {
                    Help();
                    return 1;
                }

                if (args["output"] != null && args["output"].ToUpper() == "DEBUG")
                    Output.Level = Output.DEBUG;

                string line;
                _servers = new ArrayList();
                _hashBuckets = new ArrayList();
                StreamReader sReader = new StreamReader("servers.ini");
                while ((line = sReader.ReadLine()) != null)
                {
                    if (line.IndexOf(';') < 0)
                    {
                        WriteLine("Please make sure your servers.ini file looks like SERVER;HASHBUCKET on each line");
                        return 1;
                    }
                    string []lineParts = line.Split(';');
                    _servers.Add(lineParts[0]);
                    _hashBuckets.Add(lineParts[1]);
                }

                if (_servers.Count == 0)
                {
                    WriteLine("Please create a servers.ini file (SERVER;HashBucket on each line)");
                    return 1;
                }

                string uodb_user = "uodb_admin";
                if (args["user"] != null)
                {
                    uodb_user = args["user"];
                }

                string uodb_server = (string)_servers[0];
                if (args["server"] != null)
                {
                    uodb_server = args["server"];
                }


                if (args["can"] != null)
                {
                    subs = ExtractCancelled(args["can"]);
                }
                else if (args["ref"] != null)
                {
                    subs = ExtractRefunded(args["ref"]);
                }
                else if (args["ret"] != null)
                {
                    if (args["serial"] == null)
                    {
                        Help();
                        WriteLine("If you do /ret you must have a corresponding /serial file");
                        return 1;
                    }
                    hashes = ExtractReturned(args["ret"], args["serial"]);
                }
                else if (args["file"] != null)
                {
                    subs = ExtractFile(args["file"]);
                }

                //initialize billing provider
                _sha = new SHA1CryptoServiceProvider();
                _enc = new UnicodeEncoding();

                SPS.Server = (string)_servers[0];
                SPS.IISUser = "uodb_admin";
                _sps = new BillingProvider(uodb_server, uodb_user);

                string outStr;

                // run the simplest test
                try 
                {                
                    _sps.TestConnection( "Testing 1, 2, 3..!", out outStr );
                } 
                catch (Exception e) 
                {
                    WriteLine( "Error: " + e );
                    _eventlog.WriteEntry(Environment.CommandLine + "\r\nDeactivator Error connecting to SPS: " + e.Message, 
                        EventLogEntryType.Error);
                    return 1;
                }

                if (args["test"] != null)
                {
                    //test the user_puid passed in
                    _userPuid = Int64.Parse(args["test"]);

                    ProcessHash(null, "test");
                }

                //process each sub
                foreach(string sub in subs)
                {
                    if (sub == null || sub.Length == 0)
                        continue;
                    byte [] hash = GetHashFromKey(sub); //SubToHash(sub);
                    ProcessHash(hash, sub);
                }

                //process each hash
                foreach(string hash_serial in hashes)
                {
                    if (hash_serial == null || hash_serial.Length == 0)
                        continue;
                    
                    string [] parts = hash_serial.Split(';');

                    if (parts.Length != 2)
                        continue;

                    string hash = parts[0];
                    string serial = parts[1];
                    byte [] hashb = HexStrToByte(hash);
                    Console.WriteLine("Processing " + serial + " with " + hash);
                    ProcessHash(hashb, serial);
                }

                WriteLine("Marked " + _used + " vouchers as used.");
                WriteLine("Cancelled " + _canceled + " accounts.");
            }
            catch (Exception e)
            {
                WriteLine(e.ToString());
                _eventlog.WriteEntry(Environment.CommandLine + "\r\nDeactivator Error: " + e.Message, 
                    EventLogEntryType.Error);
                return 1;
            }
            finally
            {
                /*if (null != _sps)
                    _sps.Close();
                    */


            }

            return 0;
        }

        private static void Help()
        {
            WriteLine("Deactivator");
            WriteLine("This will deactivate subscription codes");
            WriteLine("Usage: Deactivator.exe [/user:<defaults to uodb_admin>] [/server:<default server 0>] /<options>");
            WriteLine("     /can:<file>   Cancelled subscriptions");
            WriteLine("     /ret:<file> /serial:<file>  Returned subscriptions");
            WriteLine("     /ref:<file>   Refunded subscriptions");
            WriteLine("     /file:<file>  Flat file (1 sub / line)");
            WriteLine("");
        }

        private static void ProcessHash(
            byte [] hash, string strSub)
        {
            try
            {
                long puid;

                if (hash != null)
                {
                    puid = HashToPuid(hash, strSub);

                    if (puid == 0)
                    {
                        return;
                    }
                }
                else
                {
                    if (_userPuid == 0)
                    {
                        WriteLine("Error: trying to process a blank hash.");
                        goto Done;
                    }
                    puid = _userPuid; //testing purposes
                }

                WriteLine("Puid: " + puid.ToString());

                if (PuidIsInBillingQ(puid))
                {
                    WriteLine("There is a user still in the queue. Please run the tool again later. " + puid);
                    goto Done;
                }

                long owner_puid = 0;
                string acct = PuidToAccount(puid, out owner_puid);

                if (acct == "")
                {
                    WriteLine("Bad account for puid " + puid.ToString());
                    goto Done;
                }
                string xmlSubList = GetXmlSubscriptions(owner_puid, acct);
                Queue subList;

                if (xmlSubList == "")
                    goto Done;

                Console.WriteLine("Cancelling user: " + acct);

                int cancel = GetSubscriptions(xmlSubList, out subList);

                if (cancel == -1)
                {
                    WriteLine("Error lookup failed for hash " + hash.ToString());
                    goto Done;
                }

                foreach (string sub in subList)
                {
                    try
                    {
                        string [] fields = sub.Split(':'); //0 = sub, 1 = guid
                        if (fields.Length != 2)
                            continue;
                        CancelSubscription(owner_puid, fields[1], fields[0]);
                    }
                    catch(Exception e)
                    {
                        Console.WriteLine("Error cancelling subscription " + sub + " for " + puid + ": " + e.Message);
                        _eventlog.WriteEntry(Environment.CommandLine + "\r\nError cancelling subscription " + sub + " for " + puid + ": " + e.Message, 
                            EventLogEntryType.Error);
                    }
                }

                _canceled++;

            Done:
                WriteLine("");
                return;
            }
            catch (Exception e)
            {
                WriteLine("FAIL: " + e.ToString());
                _eventlog.WriteEntry(Environment.CommandLine + "\r\nError in ProcessHash for " + strSub + ": " + e.Message, 
                    EventLogEntryType.Error);
            }
        }

        private static bool CancelSubscription(
            long puid, 
            string guid,
            string sub)
        {
        /*
            HRESULT CancelSubscription(
            [in]  LONG lDelegateIdHigh,
            [in]  LONG lDelegateIdLow,
            [in]  LONG lRequesterIdHigh,
            [in]  LONG lRequesterIdLow,
            [in]  BSTR bstrTrackingGUID,
            [in]  VARIANT_BOOL fComputeOnly,
            [in]  BSTR bstrSubscriptionId,
            [in]  BSTR bstrCancelDate,
            [in]  BSTR bstrCommentInfoXML,
            [out] BSTR *pbstrResultXML,
            [out] BSTR *pbstrAmountChargedXML,
            [out] BSTR *pbstrSubscriptionStatusInfoXML,
            [out] LONG *plRemovedServiceInstanceCount,
            [out] BSTR *pbstrRemovedServiceInstanceSetXML
            );
        */
            int high = (int)(puid >> 32);
            int low  = (int)(puid & 0xFFFFFFFF);

            string result = "", charged = "", status = "", instance = "";
            int count = 0;

            string comment = "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">";
            comment += "<CommentCode>5</CommentCode>";
            comment += "<CommentText>Returned Xbox Live</CommentText>";
            comment += "</CommentInfo>";

            guid = Guid.NewGuid().ToString();

            
            _sps.CancelSubscription(
                        1,
                        1,
                        high,
                        low,
                        guid,
                        false,
                        sub,
                        "",
                        comment,
                        out result,
                        out charged,
                        out status,
                        out count,
                        out instance);

            /*
            WriteLine("result: " + result);
            WriteLine("status: " + status);
            WriteLine("Guid - " + guid + " Sub - " + sub);
            WriteLine("High: " + high.ToString());
            WriteLine("Low: " + low.ToString());
            */
            return true;
        }


        private static int GetSubscriptions(
            string xml,
            out Queue subList)
        {
            int hr = 0; //success

            int i;
            XmlDocument doc = new XmlDocument();

            doc.LoadXml(xml);

            // need to see this before parsing can begin
            subList = new Queue();

            
            XmlNodeList mainNodes = doc.ChildNodes;
            XmlNodeList nodes = null;


            for (i = 0; i < mainNodes.Count; i++)
            {
                XmlNode tempNode = mainNodes.Item(i);
                if (tempNode.Name == "SubscriptionInfoSet")
                {
                    nodes = tempNode.ChildNodes;
                    break;
                }
            }

            if (nodes == null)
            {
                hr = -1; //failed
                return hr; 
            }

            for(int nCurNode = 0; nCurNode < nodes.Count; ++nCurNode)
            {
                //this node now contains all the data about this single subscription
                XmlNode node = nodes.Item(nCurNode);

                if (node.Name != "SubscriptionInfo")
                {
                    continue;
                }

                string desc = null, sub = null, guid = null, expired = null;
                //the info is in the first childnode
                for (i = 0; i < node.ChildNodes.Count; i++)
                {
                    XmlNode data = node.ChildNodes.Item(i);

                    if (data.Name == "SubscriptionDescription")
                        desc = data.InnerText;
                    else if (data.Name == "SubscriptionId")
                        sub = data.InnerText;
                    else if (data.Name == "OfferingGUID")
                        guid = data.InnerText;
                    else if (data.Name == "SubscriptionStatusInfo")
                    {
                        XmlNode innerData = data.ChildNodes.Item(0);
                        expired = innerData.InnerText;
                    }
                        
                    if (desc != null && sub != null && guid != null && expired != null)
                        break;

                }

                //make sure we find a description of the subscription, an id, and it's xbox
                if (sub != null && desc != null && guid != null && expired != null)
                {
                    WriteLine("Expired - " + expired);
                    if (desc.IndexOf("Xbox") >= 0)
                    {
                        if (expired == "EXPIRED")
                        {
                         //   WriteLine("Skipping expired subscription");
                        }
                        else
                        {
                            //WriteLine("Adding " + desc + ": " + sub);
                            subList.Enqueue(sub + ":" + guid);
                        }
                    }
                    else
                        hr = 1; //1 means that we are keeping at least 1 subscription
                }

            }

            return hr;
        }
    

        private static string GetXmlSubscriptions(
            long puid, string acct)
        {
            string xml = "";

            int high = (int)(puid >> 32);
            int low  = (int)(puid & 0xFFFFFFFF);
            
            int count = 0;
            string xmlset = "";

            Console.WriteLine("puid: " + puid.ToString() + " acct: " + acct);
            _sps.GetSubscriptions(1, 1, high, low, acct, out xml, out count, out xmlset);

            //WriteLine("set: " + xmlset);

            return xmlset;
        }

        public static byte[] GetHashFromKey(string key)
        {
            key = key.ToUpper();
        
            if (key[5] != '-')
            {
                // insert dashes (thank you windows.net)
                key = key.Insert(20, "-");
                key = key.Insert(15, "-");
                key = key.Insert(10, "-");
                key = key.Insert(5,  "-");
            }
        
            // extra null is again, thanks to windows.net
            byte [] hashb = _sha.ComputeHash(_enc.GetBytes(key + "\0"));
            return hashb;
        }

        private static byte[] SubToHash(
            ulong sub)
        {
            byte[] keyBytes;

            // extra null is to be compatible with windows.net way of doing things. 
            keyBytes = _enc.GetBytes(sub + "\0");
        
            return _sha.ComputeHash(keyBytes);

        }

        private static long HashToPuid(
            byte [] hash, string sub)
        {
            uint    hr = HResult.S_OK;

            long puid = 0;
/*
 *  CREATE procedure dbo.p_xcsr_get_voucher_info 
(
     @bin_voucher_hash  binary(20)
    ,@ti_is_valid       tinyint     output
    ,@ti_used           tinyint     output
    ,@ti_used_max_times tinyint     output
    ,@bi_last_user      bigint      output
    ,@dt_last_used      datetime    output
    ,@bi_offer_id       bigint      output
)
as
 */
            for (int i = 0; i < _servers.Count; i++)
            {
                string server = (string)_servers[i];
                string hashBucket = (string)_hashBuckets[i];

                SqlConnection cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
                cxn.Open();
        
                SqlCommand cmd = new SqlCommand("p_xcsr_get_voucher_info", cxn);
                cmd.CommandType = CommandType.StoredProcedure;
                SqlParameter sqlHash = cmd.Parameters.AddWithValue("@bin_voucher_hash", hash); //owner_puid
                SqlParameter a = cmd.Parameters.AddWithValue("@ti_is_valid", 0); //owner_puid
                SqlParameter sqlUsed = cmd.Parameters.AddWithValue("@ti_used", SqlDbType.TinyInt); //country
                SqlParameter b = cmd.Parameters.AddWithValue("@ti_used_max_times", 0); //owner_puid
                SqlParameter sqlPuid = cmd.Parameters.AddWithValue("@bi_last_user", SqlDbType.BigInt); //puid
                SqlParameter c = cmd.Parameters.AddWithValue("@dt_last_used", DateTime.Now); //owner_puid
                SqlParameter sqlOffer = cmd.Parameters.AddWithValue("@bi_offer_id", SqlDbType.BigInt); //acct_id
                
                //Console.WriteLine("H2P: " + ByteToHexStr((byte[])sqlHash.Value));

                a.Direction = ParameterDirection.Output;
                b.Direction = ParameterDirection.Output;
                c.Direction = ParameterDirection.Output;
                sqlUsed.Direction = ParameterDirection.Output;
                sqlPuid.Direction = ParameterDirection.Output;
                sqlOffer.Direction = ParameterDirection.Output;
                
                cmd.ExecuteNonQuery();

                cxn.Close();

                if((long)sqlOffer.Value == 0)
                {
                    continue;
                }

                if (sqlUsed.Value.ToString() == "0") //has the voucher been used?
                {
                    long offer_id = Int64.Parse(sqlOffer.Value.ToString());
                    MarkCodeAsUsed(hash, offer_id, server, hashBucket);
                    return 0;
                }

                puid = Int64.Parse(sqlPuid.Value.ToString());
                if (puid != 0)
                    return puid;
            }

            WriteLine("Unable to locate " + sub + " in uodb.  Error = " + hr.ToString("X"));
            _eventlog.WriteEntry(Environment.CommandLine + "\r\nUnable to locate " + sub + " in uodb.  Error = " + hr.ToString("X"),
                EventLogEntryType.Error);
            
            return 0;
        }

        private static string PuidToAccount(
            long puid, out long owner_puid)
        {
            foreach (string server in _servers)
            {
                string acct = "";
                DateTime dt = DateTime.Now;
           
                SqlDataReader reader = null;
            
                SqlConnection cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
                cxn.Open();
        
                try
                {
                    //WriteLine("Adding params");

                    SqlCommand cmd = new SqlCommand("p_xuacs_get_user_acct", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;
                    SqlParameter sqlPuid = cmd.Parameters.AddWithValue("@bi_user_puid", SqlDbType.BigInt); //puid
                    SqlParameter sqlOwner = cmd.Parameters.AddWithValue("@bi_owner_puid", 0); //owner_puid
                    SqlParameter sqlCountry = cmd.Parameters.AddWithValue("@ti_country_id", 0); //country
                    SqlParameter sqlAcct = cmd.Parameters.Add("@vc_billing_account_id", SqlDbType.NVarChar, 255); //acct_id
                    SqlParameter b = cmd.Parameters.AddWithValue("@vc_billing_payinfo_id", acct); //payinfo_id
                    SqlParameter c = cmd.Parameters.AddWithValue("@vc_gamertag", acct); //nick
                    SqlParameter d = cmd.Parameters.AddWithValue("@dt_birthdate", SqlDbType.DateTime); //birthdate
                    SqlParameter f = cmd.Parameters.AddWithValue("@si_ticket_flags", 0); //ticket_flags
                    SqlParameter h = cmd.Parameters.AddWithValue("@dt_acct_resume_date", SqlDbType.DateTime); //acct_resume
                    SqlParameter i = cmd.Parameters.AddWithValue("@i_suspension_length", 0); //ban_length
                    SqlParameter j = cmd.Parameters.AddWithValue("@dt_voice_resume_date", SqlDbType.DateTime); //voice_resume
                    SqlParameter k = cmd.Parameters.AddWithValue("@i_voice_ban_length", 0); //voic_ban_length
                    SqlParameter l = cmd.Parameters.AddWithValue("@ti_name_change_required", 0); //name_change
                    SqlParameter m = cmd.Parameters.AddWithValue("@dt_accepted_tos", SqlDbType.DateTime); //accepted_tos
                    SqlParameter n = cmd.Parameters.AddWithValue("@dt_reset_date", SqlDbType.DateTime); //reset_date
                    SqlParameter o = cmd.Parameters.AddWithValue("@i_billing_account_status", 0); //acct_status
                    SqlParameter p = cmd.Parameters.AddWithValue("@bin_acct_pin", 0); //acct_pin
                    SqlParameter q = cmd.Parameters.AddWithValue("@f_ms_opt_in", 0); //msspam
                    SqlParameter r = cmd.Parameters.AddWithValue("@f_partner_opt_in", 0); //partnerspam
                    SqlParameter s = cmd.Parameters.AddWithValue("@dt_change_datetime", SqlDbType.DateTime); //change
                    SqlParameter t = cmd.Parameters.AddWithValue("@i_tier_id", 0);
                    SqlParameter u = cmd.Parameters.AddWithValue("@f_has_musicnet_account", 0);

                    sqlPuid.Value = puid;
                    sqlCountry.Direction = ParameterDirection.Output;
                    sqlAcct.Direction = ParameterDirection.Output;
                    sqlOwner.Direction = ParameterDirection.Output;
                    b.Direction = ParameterDirection.Output;
                    c.Direction = ParameterDirection.Output;
                    d.Direction = ParameterDirection.Output;
                    f.Direction = ParameterDirection.Output;
                    h.Direction = ParameterDirection.Output;
                    i.Direction = ParameterDirection.Output;
                    j.Direction = ParameterDirection.Output;
                    k.Direction = ParameterDirection.Output;
                    l.Direction = ParameterDirection.Output;
                    m.Direction = ParameterDirection.Output;
                    n.Direction = ParameterDirection.Output;
                    o.Direction = ParameterDirection.Output;
                    p.Direction = ParameterDirection.Output;
                    q.Direction = ParameterDirection.Output;
                    r.Direction = ParameterDirection.Output;
                    s.Direction = ParameterDirection.Output;
                    t.Direction = ParameterDirection.Output;
                    u.Direction = ParameterDirection.Output;


                    //WriteLine("Running query " + puid.ToString());
                    //WriteLine(cmd.CommandText);

                    reader = cmd.ExecuteReader();
                   
                    if (sqlAcct.Value != null)
                        acct = sqlAcct.Value.ToString();

                    if (acct != "")
                    {
                        owner_puid = (long)sqlOwner.Value;
                        return acct;
                    }
                }
                finally
                {
                    if (reader != null)
                        reader.Close();
        
                    cxn.Close();
                }
            }

            owner_puid = 0;
            return "";
        }

        public static ArrayList ExtractCancelled(string file)
        {
            ArrayList subs = new ArrayList();

            if (!File.Exists(file))
            {
                WriteLine("Can't find " + file);
                return subs;
            }
            StreamReader reader = new StreamReader(file);

            string line;

            while ((line = reader.ReadLine()) != null)
            {
                if (line.Trim().Length == 0)
                    continue;

                string sub_code;
                string [] fields = line.Split('|');

                if (fields.Length < 11)
                    continue;

                sub_code = fields[10];

                subs.Add(sub_code);        
            }

            reader.Close();

            return subs;
        }

        public static ArrayList ExtractRefunded(string file)
        {
            ArrayList subs = new ArrayList();

            if (!File.Exists(file))
            {
                WriteLine("Can't find " + file);
                return subs;
            }
            

            StreamReader reader = new StreamReader(file);

            string line;

            while ((line = reader.ReadLine()) != null)
            {
                if (line.Trim().Length == 0)
                    continue;

                string sub_code;
                string [] fields = line.Split('|');

                if (fields.Length < 19)
                    continue;

                sub_code = fields[10];
                string price = fields[18];

                price = price.Replace("$", "");
                Decimal dPrice;
                try
                {
                    dPrice = Decimal.Parse(price);
                }
                catch(Exception)
                {
                    continue;
                }
                if (dPrice != 0)
                    subs.Add(sub_code);        
            }

            reader.Close();

            return subs;
        }

        public static ArrayList ExtractFile(string file)
        {
            ArrayList subs = new ArrayList();

            if (!File.Exists(file))
            {
                WriteLine("Can't find " + file);
                return subs;
            }
            

            StreamReader reader = new StreamReader(file);

            string line;

            while ((line = reader.ReadLine()) != null)
            {
                if (line.Trim().Length == 0)
                    continue;

                subs.Add(line.Trim());        
            }

            reader.Close();

            return subs;
        }

        public static ArrayList ExtractReturned(string file, string serialFile)
        {
            ArrayList hashes = new ArrayList();

            if (!File.Exists(file))
            {
                WriteLine("Can't find " + file);
                return hashes;
            }
            
            if (!File.Exists(serialFile))
            {
                WriteLine("Can't find " + serialFile);
                return hashes;
            }

            //load up the ret file
            ArrayList rets = new ArrayList();
            StreamReader reader = new StreamReader(file);
           
            //ignore first line
            reader.ReadLine();
            
            string line;

            while ((line = reader.ReadLine()) != null)
            {
                if (line.Trim().Length == 0)
                    continue;

                string serial;
                string [] fields = line.Split(',');
                if (fields.Length == 0 || fields[0] == null || fields[0].Length != 11)
                {
                    WriteLine("Skipping Line: " + line);
                    continue;
                }

                serial = fields[0];

                //ignore the first two bytes
                serial = serial.Substring(2);
               
                rets.Add(Int64.Parse(serial));
            }

            reader.Close();

            FileStream fs = new FileStream(serialFile, FileMode.OpenOrCreate,
                FileAccess.Read);

            StreamReader serialReader = new StreamReader(fs);

            long size = fs.Length;

            line = serialReader.ReadLine();
            serialReader.ReadLine();

            long lineLength = (long)line.Length + 2; //+2 for \r\n

            string []lineParts = line.Split(',');
            if (lineParts.Length < 2)
                throw new Exception("Serial file is malformed.");

            if (lineParts[1].Length != 9)
                throw new Exception("Serial: " + lineParts[1] + " on first line is not 9 digits.");

            long minserial;
            try
            {
                minserial = Int64.Parse(lineParts[1]);
            }
            catch (Exception)
            {
                throw new Exception("Can't convert " + lineParts[1] + " to a serial.");
            }

            long numlines = size / lineLength;
            Console.WriteLine("minserial: " + minserial + " length: " + lineLength);
            foreach(long ret in rets)
            {
                try
                {
                    long jump = (ret - minserial) * lineLength;
                
                    long newpos = fs.Seek(jump, SeekOrigin.Begin);

                    serialReader = new StreamReader(fs); //for some odd reason you have to do this
                    if (newpos < 0 || fs == null || serialReader == null || 
                        ret - minserial > numlines + 1)
                        throw new Exception("Serial file is too small for ret.");
                    line = serialReader.ReadLine();

                    Console.WriteLine("Jump: " + jump + " New pos: " + newpos);

                    lineParts = line.Split(',');
                    if (lineParts.Length < 4)
                        throw new Exception("Serial file is malformed on line: " + line);

                    if (lineParts[1].Length != 9)
                        throw new Exception("Serial: " + lineParts[1] + " is not 9 digits in: " + line);

                    long serial;
                    try
                    {
                        serial = Int64.Parse(lineParts[1]);
                    }
                    catch (Exception)
                    {
                        throw new Exception("Can't convert " + lineParts[1] + " to a serial on line: " + line);
                    }

                    if (serial != ret)
                        throw new Exception("Jump problem with serial: " + serial + " and ret " + ret);
    
                    string hash = lineParts[3];

                    hashes.Add(hash + ";" + serial);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Fail on finding hash for " + ret + " : " + e.Message);
                }
            }

            Output.WriteLine("Finished extracting rets.");

            serialReader.Close();
            fs.Close();

            
            return hashes;
        }


        public static bool PuidIsInBillingQ(long puid)
        {
            /*CREATE procedure dbo.p_kmgr_get_billing_queue_info
                @bi_user_puid   bigint
                ,@si_kek_version smallint
            */
            foreach (string server in _servers)
            {
                try
                {
                               
                    SqlDataReader reader;
            
                    SqlConnection cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
                    cxn.Open();
        
                    SqlCommand cmd = new SqlCommand("p_kmgr_get_billing_queue_info " + puid.ToString() + ", 1", cxn);
                    
                    reader = cmd.ExecuteReader();

                    if (reader.Read())
                    {
                        cxn.Close();
                        return true;
                    }
                    cxn.Close();
                }
                catch (Exception e)
                {
                    WriteLine(e.ToString());
                    _eventlog.WriteEntry(Environment.CommandLine + "\r\nError in billing queue lookup for " + puid +
                        ": " + e.Message, EventLogEntryType.Error);
                }
            }
            return false;
        }

        public static void MarkCodeAsUsed(byte [] hash, long offer_id, string server, string partition)
        {
            /*
                CREATE procedure dbo.p_xuacs_use_voucher (@bin_voucher_hash binary(20), 
                                         @bi_user_puid bigint,
                                         @si_hash_bucket smallint)
            */

            try
            {
                //p_svc_add_voucher(@bin_voucher_hash binary(20), @bi_offer_id bigint, @i_use_count int, @si_hash_bucket smallint)

                SqlConnection cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
                cxn.Open();

                string strHash = ByteToHexStr(hash);
                string query = "p_svc_add_voucher 0x" + strHash + ", " +
                    offer_id.ToString() + ", " +
                    "0, " +
                    partition;


                Console.WriteLine("Query: " + query);
                SqlCommand cmd = new SqlCommand(query, cxn);
                
                cmd.ExecuteNonQuery();

                cxn.Close();

                //hashtopuid has already marked the hash as used
                _used++;

            }
            catch (Exception e)
            {
                WriteLine(e.Message);
                _eventlog.WriteEntry(Environment.CommandLine + "\r\nError marking hash as used for " + hash.ToString() +
                    ": " + e.Message, EventLogEntryType.Error);
            }
        }

        public static string ByteToHexStr(byte [] bHash)
        {
            string strHash = "";

            for (int j = 0; j < bHash.Length; j++)
                strHash += bHash[j].ToString("X2");

            return strHash;
        }

        public static byte [] HexStrToByte(string strHash)
        {
            byte [] bHash = new byte[strHash.Length / 2];

            for (int j = 0; j < bHash.Length; j++)
            {
                bHash[j] = Byte.Parse(strHash.Substring(j * 2, 2), NumberStyles.HexNumber);
            }

            return bHash;
        }

        public static void WriteLine(string s)
        {
            Console.WriteLine(s);
        }

    }


    public class Output
    {
        public static int Level = NORMAL;
                                        
        public const int SILENT  = 0;
        public const int NORMAL  = 1;
        public const int VERBOSE = 2;
        public const int DEBUG   = 3;

        
        public static void WriteLine(string s)
        {
            if(Level >= NORMAL)
            {
                Console.WriteLine(s);
            }
        }
        
        public static void WriteVerbose(string s)
        {
            if(Level >= VERBOSE)
            {
                Console.WriteLine(s);
            }
        }
        
        public static void WriteDebug(string s)
        {
            if(Level >= DEBUG)
            {
                Console.WriteLine(s);
            }
        }
                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\DAdmin.cpp ===
//---------------------------------------------------------
// DAdmin.cpp : Implementation of CDelAdminApp and DLL registration.
//
//	Date: 08/17/01
//	Modified:  lohab  -- Creation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------

//---------------------------------------------------------
// INCLUDES
//---------------------------------------------------------

#include "stdafx.h"
#include "DelAdmin.h"
#include "DAdmin.h"

#include <malloc.h>
#include <stdio.h>
#include <string.h>

#include <wincrypt.h>
#include <md4.h>

// used for logging and tracing.
#include <xmgmt.h>

//---------------------------------------------------------
// TYPES
//---------------------------------------------------------

// used for error logging.
XomDefineArea(DelAdminLog);
XomDefineArea(DelAdminDebug);

// NT logging messages -- associated to error codes.
XomNtLogMsg( DAInitError,						59019, L_ERROR,		"DelAdmin:  Failed to Load DelAdmin."); 
XomNtLogMsg( DAInitSuccess,						59018, L_INFO,		"DelAdmin:  Dll successfully loaded.");

//---------------------------------------------------------
// LOCAL FUNCTION DECLARATIONS
//---------------------------------------------------------
DWORD ReadRegistryString( const char* szKey, const char* szValueName, char *szRetBuf, DWORD dwBufSize );
void OutputDebug( char *szErr , HRESULT hr = S_FALSE , int nLevel = 2);
HRESULT MapStringToHResult(  const WCHAR *wszString  );
void GeneratePUID( BSTR *bstrPUID );
BOOL GenerateRandomBinary( char *szBuf, int nBufSize );


//---------------------------------------------------------
//	DEFINITIIONS
//---------------------------------------------------------
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x) / sizeof(x[0]))
#endif

#define COMMON_MSG_URL						L"http://tempuri.org/message/"
#define PASSPORT_REG_KEY_PATH				"Software\\Microsoft\\Passport"
#define PASSPORT_NAMESPACE_URL				L"http://www.passport.com/NameSpace.xsd"

#define NAMESPACE_RESERVE_RESPONSE			L"NameSpaceReserveResponse"
#define NAMESPACE_RESERVE_ERROR				"Error: (DelAdmin)  Failed to reserve a namespace."
#define NAMESPACE_SIGNUP_RESPONSE			L"NameSpaceSignupResponse"
#define NAMESPACE_SIGNUP_ERROR				"Error: (DelAdmin)  The new account signup has failed."
#define NAMESPACE_RELEASE_RESPONSE			L"NameSpaceReleaseResponse"
#define NAMESPACE_RELEASE_ERROR				"Error: (DelAdmin)  Failed to release the namespace."
#define NAMESPACE_RESET_PASSWORD_RESPONSE	L"NameSpaceResetPasswordResponse"
#define NAMESPACE_RESET_PASSWORD_ERROR		"Error: (DelAdmin)  Failed to reset the password."
#define NAMESPACE_REMOVE_RESPONSE			L"NameSpaceRemoveMemberResponse"

#define NAMESPACE_ALTSIGNUP_RESPONSE        L"NameSpaceSignupAltCredRequest"
#define NAMESPACE_ALTSIGNUP_ERROR           "Error: (DelAdmin)  The new account signup with alternate credentials has failed."
#define NAMESPACE_RESETALT_PASSWORD_RESPONSE L"NameSpaceResetPasswordAltCredResponse"
#define NAMESPACE_ALTDELETE_RESPONSE        L"NameSpaceDeleteAltCredResponse"
#define NAMESPACE_CHANGENAME_RESPONSE       L"NameSpaceChangeMemberNameResponse"

const   int THREAD_ERROR_SLEEP_TIME         = 25000;   // sleep for 25 secs between connection failures.

const   WCHAR SEND_METHOD[] =               L"POST";
#define MSG_HEADER                          L"Content-Type"
#define MSG_VALUE                           L"text/xml"
#define LOGINXML                            L"<LoginRequest><ClientInfo name=\"PassportClient\" version=\"1.35\"/><User><SignInName>%s</SignInName><Password>%s</Password><SavePassword>false</SavePassword></User></LoginRequest>"
#define PASSPORTURL                         L"https://next-login.passporttest.com/ppsecure/clientpost.srf?id=0x%X"

// 30 second SOAP timeout  !
const long SOAP_CONNECTOR_TIMEOUT           = 30000;

// fields in ini file.
const CHAR c_szAppName[]                    = "DelAdmin";
const CHAR c_szEcrNameSpace[]               = "DelAdmin.EncryptedNameSpace";
const CHAR c_szNameSpace[]                  = "DelAdmin.NameSpace";
const CHAR c_szAdminName[]                  = "DelAdmin.AdminName";
const CHAR c_szPassword[]                   = "DelAdmin.Password";
const CHAR c_szPassportURL[]                = "DelAdmin.PassportURL";
const CHAR c_szSiteId[]                     = "DelAdmin.SiteId";
const CHAR c_szAdminTicketURL[]             = "DelAdmin.AdminTicketURL";
const CHAR c_szTimeInterval[]               = "DelAdmin.TimeInterval";
const CHAR c_szVersion[]                    = "DelAdmin.Version";
const CHAR c_szClientInfo[]                 = "DelAdmin.ClientInfo";
const CHAR c_szGenPUID[]					= "DelAdmin.GenPUID";
const CHAR c_szXboxType[]                   = "Console";

// log file extension.
const WCHAR LOG_FILE_NAME_EXT[]             = L".log";

const DELADMIN_ERROR_STRING_SIZE			= 256;

// expected passport return strings.
const WCHAR c_wszPEUserExists[]				= L"User Already Present";
const WCHAR c_wszPETicketExpired[]			= L"Admin Ticket has expired - need to revalidate";

// logging values
const CHAR c_szRegPath[]                    = "CLSID\\{75D51B8E-F954-4FEC-AB25-4BE17EA4588D}\\InprocServer32";
const CHAR c_szRegValue[]                   = "";


//---------------------------------------------------------
//  CLASS/METHOD IMPLEMENTATIONS
//---------------------------------------------------------

// CONSTRUCTOR
CDAdmin::CDAdmin() : m_lSiteId(-1), m_dwTicketThreadId(-1)
{
	int nLen = 0;
	HRESULT hr;
	char szFile[MAX_PATH];

    // initialize the critical section for the admin ticket.
    InitializeCriticalSection( &m_csAdminTicket);

    // init the cs for all data.
    InitializeCriticalSection( &m_csProperties );

	// get the location of the ini file from the registry.
    nLen = ReadRegistryString( c_szRegPath, c_szRegValue, szFile, MAX_PATH );
    if ( nLen >= 4 ) {
	    lstrcpynA( szFile + nLen-4, "ini", 5 );
	} else {
		XomNtLog0( DAInitError, "DelAdmin:(ERROR) Registry read failed.  Check registry access permissions on executing program.  Cannot start logging.");
		XOMASSERT( 0 );
	}
	// attach the debugging information.
	hr = g_xomcentral.Init( "DelAdmin",	szFile );
	if ( FAILED( hr ) )
	{
		XomNtLog1( DAInitError, "DelAdmin:(ERROR) XOM Init failed.  RESULT=0x%X", hr);
	}

	XomNtLog0( DAInitSuccess, "-------------------------\nDelAdmin:  Init Successful, Dll has been loaded.-------------------------\n");	
	m_nGenPUID = 0;
	m_bAdminTicketActive = FALSE;
}

//---------------------------------------------------------
//  CDAdmin Property management methods

STDMETHODIMP CDAdmin::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
	    &IID_IDAdmin,
	};

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CDAdmin::get_SiteID(long *pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    EnterCriticalSection( &m_csProperties );
    // get the site id for the delegated admin.
    *pVal = m_lSiteId;
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::put_SiteID(long newVal)
{
    EnterCriticalSection( &m_csProperties );
    // set the site id.
    m_lSiteId = newVal;
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_SiteID) New Value = %d", m_lSiteId );
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::get_EncryptedNameSpace(BSTR *pVal)
{
	// send back the encrypted name space.
    if (pVal == NULL)
        return E_POINTER;
    EnterCriticalSection( &m_csProperties );
    *pVal = m_bszEncrNameSpace.Copy();
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::put_EncryptedNameSpace(BSTR newVal)
{
	USES_CONVERSION;

    EnterCriticalSection( &m_csProperties );    
	// receive a new value for the encrypted namespace.
	m_bszEncrNameSpace = newVal;
	
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_EncryptedNameSpace) New Value = %s", W2A(m_bszEncrNameSpace) );
    
	LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::get_NameSpace(BSTR *pVal)
{
	// send back the name space.
    if (pVal == NULL)
        return E_POINTER;
    EnterCriticalSection( &m_csProperties );
    *pVal = m_bszNameSpace.Copy();
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::put_NameSpace(BSTR newVal)
{
	USES_CONVERSION;
	// receive a new value for the namespace.

    EnterCriticalSection( &m_csProperties );
	m_bszNameSpace = newVal;
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_NameSpace) New Value = %s", W2A(m_bszNameSpace) );
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::get_AdminTicket(BSTR *pVal )
{

	// return the admin ticket.
    if (pVal == NULL)
        return E_POINTER;
    
    EnterCriticalSection( &m_csAdminTicket );
    *pVal = m_AdminTicket.m_bszTicket.Copy();
    LeaveCriticalSection( &m_csAdminTicket );

    return S_OK;
}

STDMETHODIMP CDAdmin::put_AdminTicket(BSTR newVal )
{
	USES_CONVERSION;
	// set the new admin ticket
    EnterCriticalSection( &m_csAdminTicket );
    m_AdminTicket.m_bszTicket = newVal;
    m_AdminTicket.m_lStamp = 0;
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_AdminTicket) New Value = %s", W2A(m_AdminTicket.m_bszTicket) );
    LeaveCriticalSection( &m_csAdminTicket );

    return S_OK;
}

STDMETHODIMP CDAdmin::get_ClientInfo(BSTR *pVal)
{
	// return the data for the client info.
    if (pVal == NULL)
        return E_POINTER;

    EnterCriticalSection( &m_csProperties );
    *pVal = m_bszClientInfo.Copy();
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::put_ClientInfo(BSTR newVal)
{
	USES_CONVERSION;
    EnterCriticalSection( &m_csProperties );
	// set the client info to the given
	m_bszClientInfo = newVal;
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_ClientInfo) New Value = %s", W2A(m_bszClientInfo) );
    LeaveCriticalSection( &m_csProperties );

	return S_OK;
}

STDMETHODIMP CDAdmin::get_Version(BSTR *pVal)
{
    if (pVal == NULL)
        return E_POINTER;

	EnterCriticalSection( &m_csProperties );
    *pVal = m_bszVersion.Copy();
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::put_Version(BSTR newVal)
{
	USES_CONVERSION;
    EnterCriticalSection( &m_csProperties );
    m_bszVersion = newVal;
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_Version) New Value = %s", W2A(m_bszVersion) );
    LeaveCriticalSection( &m_csProperties );

	return S_OK;
}

STDMETHODIMP CDAdmin::get_EndPointURL(BSTR *pVal)
{
	// return the current endpoint URL
    if (pVal == NULL)
        return E_POINTER;

    EnterCriticalSection( &m_csProperties );
    *pVal = m_bszEndPointURL.Copy();
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::put_EndPointURL(BSTR newVal)
{
	USES_CONVERSION;
    // set the new end point URL
    EnterCriticalSection( &m_csProperties );
    m_bszEndPointURL = newVal;
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_EndPointURL) New Value = %s", W2A(m_bszEndPointURL) );
    LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::get_ThreadTimeInterval(long *pVal)
{
    if (pVal == NULL)
        return E_POINTER;

	EnterCriticalSection( &m_csProperties );
	*pVal = m_lThreadTimeInterval;
    LeaveCriticalSection( &m_csProperties );

	return S_OK;
}

STDMETHODIMP CDAdmin::put_ThreadTimeInterval(long newVal)
{
	USES_CONVERSION;
    EnterCriticalSection( &m_csProperties );
	m_lThreadTimeInterval = newVal;
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_ThreadTimeInterval) New Value = %d", m_lThreadTimeInterval );
    LeaveCriticalSection( &m_csProperties );

	return S_OK;
}

STDMETHODIMP CDAdmin::get_AdminTicketURL(BSTR *pVal)
{
    // return the current endpoint URL
    if (pVal == NULL)
        return E_POINTER;

    EnterCriticalSection( &m_csProperties );
    *pVal = m_bszAdminTicketURL.Copy();
    LeaveCriticalSection( &m_csProperties );

	return S_OK;
}

STDMETHODIMP CDAdmin::put_AdminTicketURL(BSTR newVal)
{
	USES_CONVERSION;
    EnterCriticalSection( &m_csProperties );
	m_bszAdminTicketURL = newVal;
	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(put_AdminTicketURL) New Value = %s", W2A(m_bszAdminTicketURL) );
    LeaveCriticalSection( &m_csProperties );

	return S_OK;
}

STDMETHODIMP CDAdmin::SetAdminProperties(BSTR bszAdminName, BSTR bszPassword)
{
	USES_CONVERSION;

    EnterCriticalSection( &m_csProperties );
    // set the admins username and password
    m_bszUserName = bszAdminName;
    m_bszPassword = bszPassword;

	XomTrace1( DelAdminLog, L_LOW, "DelAdmin:(GetAdminProperties) Username = %s  Password = ASSIGNED", W2A(m_bszUserName)  );

	LeaveCriticalSection( &m_csProperties );

    return S_OK;
}

STDMETHODIMP CDAdmin::GetAdminProperties(BSTR *pbszUsername, BSTR *pbszPassword)
{
    // set the values.
    if (pbszUsername == NULL)
        return E_POINTER;
    // set the values.
    if (pbszPassword == NULL)
        return E_POINTER;

    EnterCriticalSection( &m_csProperties );
    *pbszUsername = m_bszUserName.Copy();
    *pbszPassword = m_bszPassword.Copy();
    LeaveCriticalSection( &m_csProperties );


	return S_OK;
}

HRESULT CDAdmin::GetErrorString( ISoapReaderPtr pSoapReader, BSTR* pbszError )
{
    CComBSTR bszRetVal;
	HRESULT hr = S_OK;
    char szErr[DELADMIN_ERROR_STRING_SIZE];

    try 
	{
        CComPtr<MSXML2::IXMLDOMElement> pFString;
        bszRetVal.Empty();

	    // get the error string.
		hr = pSoapReader->get_faultstring(&pFString);
		if ( FAILED( hr ) )
		{
			safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(GetErrorString) Failed to attain the fault string.  Result = 0x%X", hr);
            goto Exit;
		}
        
        hr = pFString->get_text(&bszRetVal);
		if ( FAILED( hr ) )
		{
			safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(GetErrorString) Failed to attain an error string.  Result = 0x%X", hr );
            goto Exit;
		}

Exit:
        // check the status
        if ( FAILED( hr ) )
        {
            OutputDebug(szErr, hr);
        }
	}
    catch(...)
    {
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(GetErrorString)Unknown exception thrown.");
        hr = E_FAIL;
        OutputDebug( szErr, hr );
    }
        
    *pbszError = bszRetVal.Detach();

    return hr ;
}

//---------------------------------------------------------
//  CDAdmin functional methods

//---------------------------------------------------------
// NamespaceReserve :  sets up and sends message to reserve
//		a namespace with passport.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceReserve(BSTR bszPartnerAdmin, IUser *pAdmin, BSTR *pRes )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    BSTR    bszTemp;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode> pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;

	OutputDebug("DelAdmin: Executing NameSpaceReserve.", S_OK, 0);

	try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        // add the msg header to the data.
        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceReserveRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Failed to generate header.  Result = 0x%X", hr);
            goto Exit;
        }
        
        // set up the entry of the partner admin
        hr = pSoapSerializer->startElement(L"PartnerAdmin", L"", L"", L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.  ");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszPartnerAdmin);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        
        // Admin information  (sign in name)
        hr = pSoapSerializer->startElement(L"NameSpaceAdmin", L"", L"", L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->startElement( L"SignInName", L"", L"", L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        hr = pAdmin->get_SignInName( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Failed to get Sign-In name from given user.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString( bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
        
        // password
        hr = pSoapSerializer->startElement(L"Password",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        hr = pAdmin->get_Password( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Failed to get password from given user.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString( bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
        
        // ConfirmedPassword
        pSoapSerializer->startElement(L"ConfirmedPassword",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        pSoapSerializer->writeString( bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
        
           
        // gets the USER node.
        hr = GenerateUserNode( pSoapConnector, pSoapSerializer, pSoapReader, pAdmin );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        
        // end the admin node
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        
        // close the namespace request message
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        
        // end the body and message
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve) Message format error.");
            goto Exit;
        }
        	
        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve)  An error has occured in message transfer.");
            goto Exit;
        }
        
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream**)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve)  Error loading output stream to reader.");
            goto Exit;
        }
        
        
        hr = pSoapReader->get_BodyEntry(NAMESPACE_RESERVE_RESPONSE, COMMON_MSG_URL, &pXmlDocEle);
        if (FAILED(hr) || pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReserve)  Passport transaction failed:  Result = %s.", W2A(*pRes));
            goto Exit;
        }
        
Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr, hr );
        }

    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        hr = E_FAIL;
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceReserve)Unknown exception thrown.");
        OutputDebug( szErr, hr );        
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    if ( pSoapReader != NULL )
    {
        pSoapReader->Release();
        pSoapReader = NULL;
    }
    
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }
    
    return hr;
}

//---------------------------------------------------------
// NameSpaceReleaseRequest :  sets up and sends message to 
//		release a namespace with passport.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceReleaseRequest( BSTR *pRes )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode>	pXmlNode;
    VARIANT_BOOL bSucceed;
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    IUnknown *pOutStream;

	OutputDebug("DelAdmin: Executing NameSpaceReleaseRequest.", S_OK, 0);

	try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceReleaseRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReleaseRequest) Failed to generate header.");
            goto Exit;
        }
        
        // close NameSpaceReleaseRequest
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReleaseRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReleaseRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReleaseRequest) Message format error.");
            goto Exit;
        }
        
        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReleaseRequest) Message format error.");
            goto Exit;
        }
        
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReleaseRequest)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReleaseRequest)  Error loading output stream to reader.");
            goto Exit;
        }
        
        hr = pSoapReader->get_BodyEntry(NAMESPACE_RELEASE_RESPONSE,COMMON_MSG_URL, &pXmlDocEle);
        if ( FAILED(hr) ||pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceReleaseRequest) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceReleaseRequest)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));
            goto Exit;
        }

Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr, hr );
        }
    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceReleaseRequest)Unknown exception thrown.");
        hr = E_FAIL;
        OutputDebug( szErr, hr );        
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    if ( pSoapReader != NULL )
    {
        pSoapReader->Release();
        pSoapReader = NULL;
    }
    
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }
    
    return hr;
}

//---------------------------------------------------------
// NameSpaceSignUpRequest :  sets up and sends message to 
//		create a new account on this name space.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceSignUpRequest(IUser *pNewUser, BSTR *pRes)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    BSTR    bszTemp;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode> pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;

	OutputDebug("DelAdmin: Executing NameSpaceSignUpRequest.", S_OK, 0);

    try
	{
		if ( m_nGenPUID == 2 )
		{
			// if 2 don't talk to passport... just directly generate a PUID.
			hr = E_FAIL;
			goto Exit;
		}
		//
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        // genereate the message header.
        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceSignupRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Failed to generate header.");
            goto Exit;
        }

		// generate the user node information.
        hr = pSoapSerializer->startElement(L"User",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        
        // set up the user signin name
        hr = pSoapSerializer->startElement(L"SignInName",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        hr = pNewUser->get_SignInName(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Failed to get a signin name from given user.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );

        
        // set up teh user password.
        hr = pSoapSerializer->startElement(L"Password",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        
        hr = pNewUser->get_Password(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Failed to get a password from given user.");
            goto Exit;
        }
            
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
        
        // generate the rest of the node data.
        hr = GenerateUserNode( pSoapConnector, pSoapSerializer, pSoapReader, pNewUser );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        
        // close the user element.
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        
        //Close NameSpaceSignupRequest
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest) Message format error.");
            goto Exit;
        }

        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest)  An error has occured in message transfer.");
            goto Exit;
        }
                
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest)  Failed to get the output stream.");
            goto Exit;
        }
        
        
#if 0
        // @@slamb -- invaluable for debugging errors from passport.   
        // unfortunately, Seek always E_FAILs, so nothing after it works.
        //
        {
            CHAR chBuf[1024];
            ULONG cbRead = 0;

            hr = ((IStream*)pOutStream)->Read(&chBuf, 1024, &cbRead);
            while (SUCCEEDED(hr))
            {
                OutputDebug(chBuf, S_OK, 0);
                if (cbRead < 1024)
                {
                    break;
                }
                hr = ((IStream*)pOutStream)->Read(&chBuf, 1024, &cbRead);
            }

            LARGE_INTEGER li;
            li.QuadPart = 0;
            hr = ((IStream*)pOutStream)->Seek(li, 0, NULL);
        }

#endif        

        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest)  Error loading output stream to reader.");
            goto Exit;
        }
                	
        hr = pSoapReader->get_BodyEntry(NAMESPACE_SIGNUP_RESPONSE, COMMON_MSG_URL, &pXmlDocEle );
        if ( FAILED(hr) ||pXmlDocEle == NULL)
        {
            CComPtr<MSXML2::IXMLDOMDocument> pXmlDoc;
            HRESULT hrRet = S_OK;

            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );

			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceSignUpRequest) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));

            hrRet = pSoapReader->get_DOM(&pXmlDoc);
            if (FAILED(hrRet))
            {
                OutputDebug("DelAdmin:(NameSpaceSignUpRequest) Failed to get pXmlDoc from SoapReader!", hrRet);
            }
            else
            {
                BSTR bstrXml;
                if (SUCCEEDED(pXmlDoc->get_xml(&bstrXml)))
                {
                    OutputDebug("DelAdmin:(NameSpaceSignUpRequest)RESPONSE DOCUMENT:", S_OK, 0);
                    OutputDebug(W2A(bstrXml), S_OK, 0);

                    SysFreeString(bstrXml);
                }
            }

            goto Exit;
        }
        else
        {
            //Yes we were successful.
            CComBSTR bszPUID;
            HRESULT hrRet = S_OK;
        
            hrRet = pXmlDocEle->selectSingleNode(L"PUID", &pXmlNode );
            if ( FAILED(hrRet) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpRequest)  Failed to get PUID entry from response.");
                goto Exit;
            }
            if ( pXmlNode != NULL)
            {
                pXmlNode->get_text (&(bszPUID.m_str));
                pNewUser->put_UserPUID( bszPUID.m_str );
            }
        
        }

Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];

            if ( m_nGenPUID == 1 )
			{
				BSTR bstrNewPUID;
				hr = S_OK;

				// we have an error from somewhere in the code.  Return the proper error.
			    safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
		        OutputDebug( szErr, hr );

				// generates a fake puid
				GeneratePUID( &bstrNewPUID );
                pNewUser->put_UserPUID( bstrNewPUID );
				safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"Generating a FAKE PUID: PUID = %s", W2A(bstrNewPUID) );
				OutputDebug( szErr, hr );
                SysFreeString( bstrNewPUID );
			}
			else if ( m_nGenPUID == 2 )
			{
				BSTR bstrNewPUID;
				hr = S_OK;

				// generates a fake puid
				GeneratePUID( &bstrNewPUID );
                pNewUser->put_UserPUID( bstrNewPUID );
				safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"Generating a FAKE PUID: PUID = %s", W2A(bstrNewPUID) );
				OutputDebug( szErr, hr, 0 );
                SysFreeString( bstrNewPUID );
			}
			else
			{
				// don't generate PUID... just error.
				safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
				OutputDebug( szErr, hr );
			}
        }

    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceSignUpRequest)Unknown exception thrown.");
        hr = E_FAIL;
        OutputDebug( szErr , hr );
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }
    
    return hr;
}

//---------------------------------------------------------
// NameSpaceRemoveMemberRequest :  sets up and sends message 
//      remove a users account 
//
//	REVIEW: (lohab)  Should this be credentials only?
//---------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceRemoveMemberRequest(IUser *pUser, BSTR *pRes)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    BSTR    bszTemp;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode>	pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;

	OutputDebug("DelAdmin: Executing NameSpaceRemoveMemberRequest.", S_OK, 0);

    try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceRemoveMemberRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest) Failed to generate header.");
            goto Exit;
        }
    
        // start the node.
        hr = pSoapSerializer->startElement(L"User",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest) Message format error.");
            goto Exit;
        }

        // set up the user signin name
        hr = pUser->get_SignInName( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
    
        // close NameSpaceRemoveMemberRequest
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest) Message format error.");
            goto Exit;
        }
    
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest) Message format error.");
            goto Exit;
        }
    
        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest)  An error has occured in message transfer.");
            goto Exit;
        }
    
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest)  Error loading output stream to reader.");
            goto Exit;
        }
                	    
        hr = pSoapReader->get_BodyEntry(NAMESPACE_REMOVE_RESPONSE, COMMON_MSG_URL, &pXmlDocEle );
        if ( FAILED(hr) ||pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceRemoveMemberRequest) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceRemoveMemberRequest)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));

            goto Exit;
        }

Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr , hr );
        }
    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceRemoveMemberRequest)Unknown exception thrown.");
        hr = E_FAIL;
        OutputDebug( szErr , hr );
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }
    
    return hr;
}

//---------------------------------------------------------
// NameSpaceResetPassword :  sets up and sends a request to
//		reset a password to the given.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceResetPassword(BSTR bszSignInName, BSTR bszNewPassword, BSTR *pRes)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode> pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;
    
	OutputDebug("DelAdmin: Executing NameSpaceResetPassword.", S_OK, 0);

	try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        // genereate the message header.
        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceResetPasswordRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Failed to generate header.");
            goto Exit;
        }
        
        // set up user information.
        hr = pSoapSerializer->startElement(L"User",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszSignInName);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->startElement(L"Password",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszNewPassword);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        
        // close the message
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword) Message format error.");
            goto Exit;
        }
        
        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword)  An error has occured in message transfer.");
            goto Exit;
        }
        
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword)  Error loading output stream to reader.");
            goto Exit;
        }
                	    
        hr = pSoapReader->get_BodyEntry(NAMESPACE_RESET_PASSWORD_RESPONSE, COMMON_MSG_URL, &pXmlDocEle );
        if ( FAILED(hr) ||pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET  && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceResetPassword) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPassword)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));
            goto Exit;
        }
        	        
Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr , hr );
        }
    
    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceResetPassword)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr , hr );
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }
    
    return hr;
}


//------------------------------------------------------------
// NameSpaceSignUpAltCredRequest: 
//      Creates a passport account with alternate credentials.
//------------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceSignUpAltCredRequest(IUser *pNewUser, BSTR *pRes)
{
	USES_CONVERSION;
    HRESULT hr = S_OK;
    BSTR    bszTemp;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode> pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;
    
	OutputDebug("DelAdmin: Executing NameSpaceSignUpAltCredRequest.", S_OK, 0);

	try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        // genereate the message header.
        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceSignupAltCredRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Failed to generate header.");
            goto Exit;
        }
        
        // generate the user node information.
        hr = pSoapSerializer->startElement(L"User",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // set up the user signin name
        hr = pSoapSerializer->startElement(L"SignInName",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        hr = pNewUser->get_SignInName(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Failed to get a signin name from given user.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
        
        // set up teh user password.
        hr = pSoapSerializer->startElement(L"Password",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pNewUser->get_Password(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Failed to get a password from given user.");
            goto Exit;
        }
            
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );

        
        // generate the rest of the node data.
        hr = GenerateUserNode( pSoapConnector, pSoapSerializer, pSoapReader, pNewUser );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // close the user element.
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        //   TODO:  Add alt here!!!!!
        // generate the AltCredential node information.
        hr = pSoapSerializer->startElement(L"AltCredential",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // notify that this is a console type.
        hr = pSoapSerializer->startElement(L"Type",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(CComBSTR(c_szXboxType).m_str);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }

        // set up the XBox signin name
        hr = pSoapSerializer->startElement(L"SignInName",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        hr = pNewUser->get_XCred_Name(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Failed to get a signin name from given user.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
      
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // set up the XBox user password.
        hr = pSoapSerializer->startElement(L"Password",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pNewUser->get_XCred_Password(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Failed to get a password from given user.");
            goto Exit;
        }
            
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
       
        // close the AltCredential element.
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }


        //Close NameSpaceSignupRequest
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest) Message format error.");
            goto Exit;
        }
        

        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest)  An error has occured in message transfer.");
            goto Exit;
        }
        
        
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest)  Error loading output stream to reader.");
            goto Exit;
        }
                	    
        hr = pSoapReader->get_BodyEntry(NAMESPACE_ALTSIGNUP_RESPONSE, COMMON_MSG_URL, &pXmlDocEle );
        if ( FAILED(hr) ||pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceSignUpAltCredRequest) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));
            goto Exit;
        }
       	
        else
        {
            //Yes we were successful.
            CComBSTR bszPUID;
        
            hr = pXmlDocEle->selectSingleNode ( L"PUID", &pXmlNode);
            if ( !FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceSignUpAltCredRequest)  Failed to get PUID from response.");
                goto Exit;
            }
            if ( pXmlNode != NULL )
            {
                pXmlNode->get_text (&bszPUID);
                pNewUser->put_UserPUID( bszPUID.Copy () );
            }
        
        }

Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr , hr );
        }

    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];

        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceSignUpAltCredRequest)Unknown exception thrown.");
        hr = E_FAIL;
        OutputDebug( szErr , hr );
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }
    
    return hr;
}

//------------------------------------------------------------
// NameSpaceAddAltCredRequest: 
//      Creates a alternate credentials to a passport.
//   NOTE:  THIS MODIFIES THE GIVEN PUID!!!!!
//------------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceAddAltCredRequest(IUser *pExitingUser, BSTR *pRes)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    BSTR    bszTemp;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode> pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;
    
	OutputDebug("DelAdmin: Executing NameSpaceAddAltCredRequest.", S_OK, 0);

	try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        // genereate the message header.
        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceSignupAltCredRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Failed to generate header.");
            goto Exit;
        }
        
        // generate the user node information.
        hr = pSoapSerializer->startElement(L"User",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // set up the user signin name
        hr = pSoapSerializer->startElement(L"PUID",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }

        hr = pExitingUser->get_UserPUID(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Failed to get the PUID from given user.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
        
        // set up teh user password.
        hr = pSoapSerializer->startElement(L"Existing",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->writeString(CComBSTR("1").m_str);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
                
        // close the user element.
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        //   TODO:  Add alt here!!!!!
        // generate the AltCredential node information.
        hr = pSoapSerializer->startElement(L"AltCredential",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // notify that this is a console type.
        hr = pSoapSerializer->startElement(L"Type",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(CComBSTR(c_szXboxType).m_str);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }

        // set up the XBox signin name
        hr = pSoapSerializer->startElement(L"SignInName",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        hr = pExitingUser->get_XCred_Name(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Failed to get the XBox name from given user.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
        
        // set up the XBox user password.
        hr = pSoapSerializer->startElement(L"Password",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pExitingUser->get_XCred_Password(&bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Failed to get the XBox password from given user.");
            goto Exit;
        }
            
        hr = pSoapSerializer->writeString(bszTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        ::SysFreeString( bszTemp );
        
        // close the AltCredential element.
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }


        //Close NameSpaceSignUpAltCredRequest
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest)  An error has occured in message transfer.");
            goto Exit;
        }
        
        
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest)  Error loading output stream to reader.");
            goto Exit;
        }
                	    
        hr = pSoapReader->get_BodyEntry(NAMESPACE_ALTSIGNUP_RESPONSE, COMMON_MSG_URL, &pXmlDocEle);
        if ( FAILED(hr) ||pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET  && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceAddAltCredRequest) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));
            goto Exit;
        }
        else
        {
            //Yes we were successful.
            CComBSTR bszPUID;
                
            hr = pXmlDocEle->selectSingleNode ( L"PUID", &pXmlNode);
            if ( !FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest)  Failed to get PUID from response.");
                goto Exit;
            }
            if ( pXmlNode != NULL )
            {
                pXmlNode->get_text (&bszPUID);
                pExitingUser->put_UserPUID( bszPUID.Copy () );
            }
        
        }

Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr , hr);
        }

    }

    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceAddAltCredRequest)Unknown exception thrown.");
        hr = E_FAIL;
        OutputDebug( szErr, hr );
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }
    
    return hr;
}

//------------------------------------------------------------
// NameSpaceResetPasswordAltCredRequest: 
//      Resets the password alt credentials of a passport.
//------------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceResetPasswordAltCredRequest(BSTR bszXName, BSTR bszNewPassword, BSTR *pRes)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode> pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;
    
	OutputDebug("DelAdmin: Executing NameSpaceResetPasswordAltCredRequest.", S_OK, 0);

	try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        // genereate the message header.
        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceResetPasswordAltCredRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Failed to generate header.");
            goto Exit;
        }
        
        // set up user information.
        hr = pSoapSerializer->startElement(L"User",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }

        // notify that this is a console type.
        hr = pSoapSerializer->startElement(L"Type",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(CComBSTR(c_szXboxType).m_str);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }

        // sign in name
        hr = pSoapSerializer->startElement(L"SignInName",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(bszXName);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }

        // new password
        hr = pSoapSerializer->startElement(L"Password",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszNewPassword);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }

        // end user
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }

        // close the message
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest)  An error has occured in message transfer.");
            goto Exit;
        }
        
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest)  Error loading output stream to reader.");
            goto Exit;
        }
                	    
        hr = pSoapReader->get_BodyEntry(NAMESPACE_RESETALT_PASSWORD_RESPONSE, COMMON_MSG_URL, &pXmlDocEle);
        if ( FAILED(hr) ||pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET  && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceResetPasswordAltCredRequest) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceResetPasswordAltCredRequest)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));
            goto Exit;
        }
        else
        {
            //Yes we were successful.
            CComBSTR bszPUID;
                
            hr = pXmlDocEle->selectSingleNode ( L"PUID", &pXmlNode);
            if ( !FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceAddAltCredRequest)  Failed to get PUID from response.");
                goto Exit;
            }
            if ( pXmlNode != NULL )
            {
                pXmlNode->get_text (&bszPUID);
                *pRes = bszPUID.Detach();
            }
        
        }
        
Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr , hr);
        }
    
    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceResetPasswordAltCredRequest)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr , hr);
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    
    return hr;
}

//------------------------------------------------------------
// NameSpaceDeleteAltCredRequest: 
//      Deletes alternate credentials on a passport account.
//------------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceDeleteAltCredRequest(BSTR bszXName, BSTR *pRes)
{
	USES_CONVERSION;
    HRESULT hr = S_OK;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode> pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;
    
	OutputDebug("DelAdmin: Executing NameSpaceDeleteAltCredRequest.", S_OK, 0);

	try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        // genereate the message header.
        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceDeleteAltCredRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Failed to generate header.");
            goto Exit;
        }
        
        // set up user information.
        hr = pSoapSerializer->startElement(L"User",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }

        // notify that this is a console type.
        hr = pSoapSerializer->startElement(L"Type",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(CComBSTR(c_szXboxType).m_str);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }

        // sign in name
        hr = pSoapSerializer->startElement(L"SignInName",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(bszXName);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }

        // end user
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }

        // close the message
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest) Message format error.");
            goto Exit;
        }
        
        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest)  An error has occured in message transfer.");
            goto Exit;
        }
        
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest)  Error loading output stream to reader.");
            goto Exit;
        }
                	    
        hr = pSoapReader->get_BodyEntry(NAMESPACE_ALTDELETE_RESPONSE, COMMON_MSG_URL, &pXmlDocEle);
        if ( FAILED(hr) || pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET  && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceDeleteAltCredRequest) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));
            goto Exit;
        }
                
Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr, hr );
        }
    
    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceDeleteAltCredRequest)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr, hr );
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
    
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }
    
    return hr;
}

//------------------------------------------------------------
// NameSpaceChangeNameRequest: 
//      Changes a users naem in the database. (for AltCreds or
//      Passport itself.)
//------------------------------------------------------------
STDMETHODIMP CDAdmin::NameSpaceChangeNameRequest(BSTR bszType, BSTR bszOldName, BSTR bszNewName, BSTR *pRes)
{	
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComPtr<MSXML2::IXMLDOMElement> pXmlDocEle;
    CComPtr<MSXML2::IXMLDOMNode> pXmlNode;
    VARIANT_BOOL bSucceed;
    char szError[DELADMIN_ERROR_STRING_SIZE];
    ISoapReaderPtr pSoapReader;
	ISoapSerializerPtr pSoapSerializer;
	ISoapConnectorPtr pSoapConnector;
    IUnknown *pOutStream;
    
	OutputDebug("DelAdmin: Executing NameSpaceChangeNameRequest.", S_OK, 0);

	try 
	{
        // set the default result string.
        *pRes = CComBSTR(L"").Detach();

        // genereate the message header.
        hr = GenerateMsgHeader( pSoapConnector, pSoapSerializer, pSoapReader, "NameSpaceChangeMemberNameRequest");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Failed to generate header.");
            goto Exit;
        }
        
        // set up user information.
        hr = pSoapSerializer->startElement(L"User",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }

        // notify that this is a console type.
        hr = pSoapSerializer->startElement(L"Type",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(CComBSTR(c_szXboxType).m_str);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }

        // sign in name
        hr = pSoapSerializer->startElement(L"SignInNameL",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(bszOldName);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }

        // new password
        hr = pSoapSerializer->startElement(L"NewSignInName",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->writeString(bszNewName);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }

        // end user
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }

        // close the message
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endBody();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endEnvelope();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest) Message format error.");
            goto Exit;
        }
        
        // Send the message to the web service
        hr = pSoapConnector->EndMessage();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest)  An error has occured in message transfer.");
            goto Exit;
        }
        
        // get the output stream
        hr = pSoapConnector->get_OutputStream((IStream **)&pOutStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest)  Failed to get the output stream.");
            goto Exit;
        }
            
        // Connect the reader to the output stream of the connector
        hr = pSoapReader->Load( _variant_t(pOutStream), L"", &bSucceed);
        if ( FAILED(hr) || !bSucceed )
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest)  Error loading output stream to reader.");
            goto Exit;
        }
                	    
        hr = pSoapReader->get_BodyEntry(NAMESPACE_CHANGENAME_RESPONSE, COMMON_MSG_URL, &pXmlDocEle);
        if ( FAILED(hr) || pXmlDocEle == NULL)
        {
            SysFreeString(*pRes);
            GetErrorString( pSoapReader, pRes );
			hr = MapStringToHResult( *pRes );
			if ( hr == E_PASSPORT_INVALIDTICKET  && m_nGenPUID == 0 )
			{
				// set the event
				if ( SetEvent(m_hTicketEvent) )
				{
					OutputDebug( "DelAdmin:(NameSpaceChangeNameRequest) The Passport Admin Ticket is invalid and DelAdmin tool could not wake up Admin Ticket Thread.", hr, 3);
				}
			}
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest)  Passport Operation Failed.  Passport returned: %s.", W2A(*pRes));
            goto Exit;
        }
        else
        {
            //Yes we were successful.
            CComBSTR bszPUID;
                
            hr = pXmlDocEle->selectSingleNode ( L"PUID", &pXmlNode);
            if ( !FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceChangeNameRequest)  Failed to get PUID from response.");
                goto Exit;
            }
            if ( pXmlNode != NULL )
            {
                pXmlNode->get_text(&bszPUID);
                *pRes = bszPUID.Detach();
            }
        
        }
        
Exit:
        if ( FAILED(hr) )
        {
            char szErr[DELADMIN_ERROR_STRING_SIZE];
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr, hr );
        }
    
    }
    catch(...)
    {
        char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(NameSpaceChangeNameRequest)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr, hr );
    }
    
    // clean up the connections and deallocate.
    if ( pSoapSerializer != NULL )
    {
        pSoapSerializer->reset ();
        pSoapSerializer = NULL;
    }
    if ( pSoapConnector != NULL )
    {
        pSoapConnector->reset();
        pSoapConnector = NULL;
    }
        
    // set the result string.
    if ( hr == S_OK )
    {
        SysFreeString(*pRes);
        *pRes = SysAllocString(L"TRUE");
    }

    return hr;	
}


//---------------------------------------------------------
//	Init:  Initializes the delegated admin tool.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::Init( BOOL bCreateAdminTicketThread )
{
	USES_CONVERSION;
	CRegKey		SiteRegKey;							// for the site reg key.
	DWORD       dwBufLen=0;
	BOOL		bSiteIdIsSet = false;
	HRESULT hr = S_OK;
    char szErr[DELADMIN_ERROR_STRING_SIZE];
    char szError[DELADMIN_ERROR_STRING_SIZE];

	OutputDebug("-------------------------\nDelAdmin:(Init)  Initializing DelAdmin object...\n-------------------------\n", S_OK, 1);

	EnterCriticalSection( &m_csProperties );

	try 
	{
        // ensure that we've got at least the AdminTicket URL before operating.
        if ( m_bszAdminTicketURL.Length() == 0 )
        {
            hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(Init)  The config has not been loaded.  Please set up DelAdmin before Init.");
            goto Exit;
        }

		// create the need ticket event.
        if ( (m_hNeedTicket = CreateEvent( NULL, TRUE, !bCreateAdminTicketThread, NULL )) == NULL )
        {
			hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
			safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(Init)  Failed to create event for ticket needs. ");
			goto Exit;
		}
		
        if ( !bCreateAdminTicketThread && m_nGenPUID != 2 )
		{
			// just get a one time admin ticket.
			hr = RequestAdminTicket( &(m_AdminTicket.m_bszTicket.m_str), &(m_AdminTicket.m_lStamp ) );
			if ( FAILED(hr) )
			{
	            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(Init) Failed to get an AdminTicket for this session. ");
				// we have an error from somewhere in the code.  Return the proper error.
				safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
				OutputDebug( szErr, hr, 3 );
	
				// do not exit here... 
				if ( !bCreateAdminTicketThread )
				{
		            goto Exit;
	            }
				hr = S_OK;
			}
		}
        else if ( bCreateAdminTicketThread && m_nGenPUID != 2)
        {
			// check to see if the admin ticket thread is wanted.

            // create send ready event.
            if ( (m_hTicketEvent = CreateEvent( NULL, TRUE, FALSE, NULL )) == NULL )
            {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(Init)  Failed to create the Admin Ticket Ready Event. ");
                goto Exit;
            }

            // create and start admin ticket thread.  LOG IT
            if ( (m_hTicketThread = CreateThread( NULL, NULL, AdminTicketThread, this, 0, &m_dwTicketThreadId ) ) == NULL )
            {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
	            OutputDebug( "DelAdmin:(Init)  Failed to create the Admin Ticket thread.", E_DELADMIN_ADMINTICKETTHREADFAIL, 3 );
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(Init)  Failed to create the Admin Ticket thread.");
                goto Exit;
            }

        }

Exit:
        if ( FAILED(hr) )
        {
			if ( m_nGenPUID == 1 )
			{
				// we have an error from somewhere in the code.  Return the proper error.
				safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
				OutputDebug( szErr, hr );

				// continue anyways since we don't need passport.
				hr = S_OK;
			}
			else if ( m_nGenPUID == 2 )
			{
				// continue anyways since we don't need passport.
				hr = S_OK;
			}
			else
			{
				// we have an error from somewhere in the code.  Return the proper error.
				safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
				OutputDebug( szErr, hr );
			}
        }
    }
    catch(...)
    {
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(Init)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr, hr );
    }

    LeaveCriticalSection( &m_csProperties );

	return hr;
}


//---------------------------------------------------------
//  Generate Msg Header:  Performs necessary tasks to 
//		generate the message header.
//---------------------------------------------------------
// generates SOAP message headers.	
HRESULT CDAdmin::GenerateMsgHeader(  ISoapConnectorPtr &pSoapConnector, 
                            ISoapSerializerPtr &pSoapSerializer, 
                            ISoapReaderPtr &pSoapReader, 
                            char *szSoapAction )
{
    USES_CONVERSION;
	char szTemp[64];
	HRESULT	hr;
    char szErr[DELADMIN_ERROR_STRING_SIZE];
    CComBSTR bszATCopy;
    char szError[DELADMIN_ERROR_STRING_SIZE];

    CComBSTR bszEndPointURL;
    CComBSTR bszClientInfo;
    CComBSTR bszVersion;
    long lSiteId;
    CComBSTR bszEncrNameSpace;
    IUnknown *pInStream;
	time_t curTime;

    try 
	{
        EnterCriticalSection( &m_csProperties );
        
        // make a local copy of the information        
        bszEndPointURL.Attach(m_bszEndPointURL.Copy());
        bszClientInfo.Attach(m_bszClientInfo.Copy());
        bszVersion.Attach(m_bszVersion.Copy());
        lSiteId          = m_lSiteId;
        bszEncrNameSpace.Attach(m_bszEncrNameSpace.Copy());
        
        LeaveCriticalSection( &m_csProperties );

		WaitForSingleObject( m_hNeedTicket , INFINITE );

        // block, copy the ticket unblock and continue.
        EnterCriticalSection( &m_csAdminTicket );
        
		time( &curTime );
		XomTrace2( DelAdminLog, L_LOW, "DelAdmin:(GenerateMsgHeader)  Using Admin Ticket from TIME=%s at current TIME=%s", ctime( &m_AdminTicket.m_lStamp), ctime( &curTime ) );
        bszATCopy.Attach(m_AdminTicket.m_bszTicket.Copy());
		//OutputDebug( W2A(m_AdminTicket.m_bszTicket.m_str ) );
        //bszATCopy.Attach(CComBSTR("1PawxSQUkDEsfb6bOUvI6kVspnGK9I281U5zte9Xf3loA6EC1Fr*1*!KccIpiwGEfVq89z95aI8e7Ifj!GIMuPfw$$").Detach());
        
        LeaveCriticalSection( &m_csAdminTicket );

        // if not created... create a soap connector object.
        //The connector should be NULL by now. Check for that.
        if (pSoapConnector == NULL)
        {
        	hr = pSoapConnector.CreateInstance(__uuidof(HttpConnector));
        	if (hr == S_OK && pSoapConnector != NULL)
        	{
        		hr = pSoapConnector->put_Property(CComBSTR("EndPointURL").m_str, _variant_t(bszEndPointURL.m_str) );
                if ( FAILED(hr) )
                {
            		safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Failed to set the end point URL for the connector.");
                    goto Exit;
                }
                pSoapConnector->put_Property(CComBSTR("Timeout").m_str, _variant_t(SOAP_CONNECTOR_TIMEOUT));
                if ( FAILED(hr) )
                {
            		safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Failed to set the Timeout for the connector.");
                    goto Exit;
                }
        	}
        	else if (hr != ERROR_SUCCESS)
        	{
        		safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Failed to create a SOAP connector object.");
                goto Exit;
        	}
        	

        	hr = pSoapSerializer.CreateInstance(__uuidof(SoapSerializer));
        	if (hr != ERROR_SUCCESS)
        	{
        		safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Failed to create a SOAP serializer object.");
                goto Exit;
        	}

        
        	hr = pSoapReader.CreateInstance(__uuidof(SoapReader));
        	if (hr != ERROR_SUCCESS)
        	{
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Failed to create a SOAP reader object.");
                goto Exit;
        	}
        
        }
        
        // set up the soap connector to send the message
        hr = pSoapConnector->reset();      
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) SOAP connector failed to reset.");
            goto Exit;
        }

        hr = pSoapConnector->put_Property(CComBSTR("Timeout"), _variant_t(SOAP_CONNECTOR_TIMEOUT));
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) SOAP connector failed to connect.");
            goto Exit;
        }
        hr = pSoapConnector->Connect();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) SOAP connector failed to connect.");
            goto Exit;
        }

        hr = pSoapConnector->put_Property(CComBSTR("SoapAction").m_str, _variant_t(CComBSTR(szSoapAction).m_str) );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Failed to set the SOAP action.");
            goto Exit;
        }

        hr = pSoapConnector->BeginMessage();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader)  Begin Message failed.");
            goto Exit;
        }
        
        // get the input stream
        hr = pSoapConnector->get_InputStream((IStream **)&pInStream);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(NameSpaceDeleteAltCredRequest)  Failed to get the input stream.");
            goto Exit;
        }

        // Connect the serializer to the input stream of the connector
        hr = pSoapSerializer->Init(_variant_t(pInStream));
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Failed to init the SOAP serializer.");
            goto Exit;
        }
        
        // Build the SOAP Message
        hr = pSoapSerializer->startEnvelope(L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }

        // start the body
        hr = pSoapSerializer->startBody(L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        // start the soap element.
        hr = pSoapSerializer->startElement(CComBSTR(szSoapAction), PASSPORT_NAMESPACE_URL,L"", L"m");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }

        // set the client info
        hr = pSoapSerializer->startElement(L"ClientInfo",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->writeString( bszClientInfo.m_str );

        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->startElement(L"Version",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(bszVersion.m_str);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        

        // start the authorization node.
        hr = pSoapSerializer->startElement(L"Authorization",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        
        // set up the site id
        hr = pSoapSerializer->startElement(L"SiteID",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }

        safe_snprintf( szTemp, sizeof(szTemp),"%d", lSiteId );
        hr = pSoapSerializer->writeBuffer( strlen(szTemp), (unsigned char*)szTemp);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        
        
        // send the encrypted name space string.
        hr = pSoapSerializer->startElement(L"Domain",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }

        hr = pSoapSerializer->writeString(bszEncrNameSpace);
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        
        // write out the AdminTicket  
        hr = pSoapSerializer->startElement(L"AdminTicket",L"",L"",L"");
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }


        hr = pSoapSerializer->writeString( bszATCopy.m_str );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }
        
        // end the authorization
        hr = pSoapSerializer->endElement();
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateMsgHeader) Message format error.");
            goto Exit;
        }

Exit:
        if ( FAILED(hr) )
        {
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr );
            if ( pSoapConnector != NULL )
            {
                pSoapConnector->reset();
                pSoapConnector = NULL;
            }
            
            if ( pSoapSerializer != NULL )
            {
                pSoapSerializer->reset();
                pSoapSerializer = NULL;
            }
            
        }
    }
    catch(...)
    {
        if ( pSoapConnector != NULL )
        {
            pSoapConnector->reset();
            pSoapConnector = NULL;
        }
    
        if ( pSoapSerializer != NULL )
        {
            pSoapSerializer->reset();
            pSoapSerializer = NULL;
        }
    
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(GenerateMsgHeader)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr, hr );
    }

    // clean up the memory because it's leaking somewhere...
    SysFreeString( bszEndPointURL.Detach() );
    SysFreeString( bszClientInfo.Detach() );   
    SysFreeString( bszVersion.Detach() );
    SysFreeString( bszEncrNameSpace.Detach() );

    return hr;
}


//---------------------------------------------------------
//  GenerateUserNode:  Creates SOAP instruction encapsulating
//		given user information
//---------------------------------------------------------
HRESULT CDAdmin::GenerateUserNode( ISoapConnectorPtr pSoapConnector, 
                                    ISoapSerializerPtr pSoapSerializer, 
                                    ISoapReaderPtr pSoapReader, 
                                    IUser *pUser )
{
	BSTR bszTemp;
    HRESULT hr = S_OK;
    char szErr[DELADMIN_ERROR_STRING_SIZE];
    char szError[DELADMIN_ERROR_STRING_SIZE];
    //-------------------------------------------------------------------------------------------
    // REVIEW:  (lohab)  Is any of this stuff necessary?   Do we care about passport credentials?
    // TODO:    (lohab)  Add features for the following properties:
    //														AllowEmailInProfile
    //														Allow Passport Network email
    //														Email
    //														First name
    //														Flags
    //														Gender
    //														Last Name
    //														NickName
    //														Occupation

    try 
	{
        // Accessibility
        hr = pUser->get_Accessibility( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Accessiblility from given user.");
            goto Exit;
        }
        if ( CComBSTR( bszTemp ).Length() )
        {
        	hr = pSoapSerializer->startElement(L"Accessibility",L"",L"",L"");
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->writeString( bszTemp );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        }
        ::SysFreeString( bszTemp );
        
        // birthday
        hr = pUser->get_Birthday( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Birthday from given user.");
            goto Exit;
        }
        if ( CComBSTR( bszTemp ).Length() )
        {
            hr = pSoapSerializer->startElement(L"Birthday",L"",L"",L"");
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->writeString( bszTemp );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        }
        ::SysFreeString( bszTemp );
        
        // country  ** NEEDED
        hr = pUser->get_Country( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Country from given user.");
            goto Exit;
        }

        if ( CComBSTR( bszTemp ).Length() )
        {
        	hr = pSoapSerializer->startElement(L"Country",L"",L"",L"");
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }

        	hr = pSoapSerializer->writeString( bszTemp );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }

        	hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }

        }
        ::SysFreeString( bszTemp );
        
        // language
        hr = pUser->get_LanguagePreference( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Language from given user.");
            goto Exit;
        }

        if ( CComBSTR( bszTemp ).Length() )
        {
        	hr = pSoapSerializer->startElement(L"LanguagePreference",L"",L"",L"");
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->writeString( bszTemp );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        }
        ::SysFreeString( bszTemp );
        
        // secret question ** NEEDED
        hr = pUser->get_SecretQuestion( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Secret Question from given user.");
            goto Exit;
        }
        if ( CComBSTR( bszTemp ).Length() )
        {
        	hr = pSoapSerializer->startElement(L"SecretQuestion",L"",L"",L"");
        	if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
            hr = pSoapSerializer->writeString( bszTemp );
        	if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
            hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        }
        ::SysFreeString( bszTemp );
        
        // secret answer  ** NEEDED
        hr = pUser->get_SecretAnswer( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Secret Answer from given user.");
            goto Exit;
        }
        if ( CComBSTR( bszTemp ).Length() )
        {
        	hr = pSoapSerializer->startElement(L"SecretAnswer",L"",L"",L"");
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->writeString( bszTemp );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        }
        ::SysFreeString( bszTemp );
        
        // region
        hr = pUser->get_Region( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Region from given user.");
            goto Exit;
        }
        if ( CComBSTR( bszTemp ).Length() )
        {
        	hr = pSoapSerializer->startElement(L"Region",L"",L"",L"");
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->writeString( bszTemp );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        }
        ::SysFreeString( bszTemp );
        
        // postal code
        hr = pUser->get_PostalCode( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Postal Code from given user.");
            goto Exit;
        }

        if ( CComBSTR( bszTemp ).Length() )
        {
        	hr = pSoapSerializer->startElement(L"PostalCode",L"",L"",L"");
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->writeString( bszTemp );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        }
        ::SysFreeString( bszTemp );
        
        // TimeZone	
        hr = pUser->get_TimeZone( &bszTemp );
        if ( FAILED(hr) )
        {
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Failed to get Time Zone from given user.");
            goto Exit;
        }

        if ( CComBSTR( bszTemp ).Length() )
        {
        	hr = pSoapSerializer->startElement(L"TimeZone",L"",L"",L"");
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->writeString( bszTemp );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        	hr = pSoapSerializer->endElement();
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(GenerateUserNode) Message format error.");
                goto Exit;
            }
        }
        ::SysFreeString( bszTemp );

	//-------------------------------------------------------------------------------------------
Exit:
        if ( FAILED(hr) )
        {
            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr, hr );
        }

    }
    catch(...)
    {
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(GenerateUserNode)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr, hr );
    }

	return hr;
}


//---------------------------------------------------------
//  RequestAdminTicket():  requests an Admin ticket from 
//		Passport.  
//
//	REQUIRES that passport always returns the same result.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::RequestAdminTicket( BSTR *pszAdminTicket, long *plTimeStamp )
{
	HRESULT hr = S_OK;
	CComBSTR bszBody;
	VARIANT  vMsg;
	VARIANT  vAsyncSetting;
	WCHAR    *wszStart;
	WCHAR    *wszFinish;
	WCHAR    wszLoginXML[512];
	WCHAR    wszPassportURL[256];
    char szErr[DELADMIN_ERROR_STRING_SIZE];
    BOOL bHasError = FALSE;
    CComBSTR bszAdminTicketURL;
    long     lSiteId;
    CComBSTR bszPassword;
    CComBSTR bszUserName;
	int nOutputLevel = 0;

	MSXML::IXMLHttpRequestPtr pxmlHTTP = NULL;
    
	OutputDebug( "DelAdmin:(RequestAdminTicket) Requesting an Admin Ticket", S_OK, 0);

    try 
	{

        // make a local copy of necessary values.
        EnterCriticalSection( &m_csProperties );

        bszAdminTicketURL.Attach( m_bszAdminTicketURL.Copy() );
        lSiteId = m_lSiteId;
        bszUserName.Attach(m_bszUserName.Copy());
        bszPassword.Attach(m_bszPassword.Copy());

        LeaveCriticalSection( &m_csProperties );

        // set some default value
        *plTimeStamp = 0;

		// attain a new XMLHTTP object.
		OutputDebug( "DelAdmin:(RequestAdminTicket) Creating a new XMLHTTP reference...", S_OK, 0);

		// initialize XML HTTP object
        hr = CoCreateInstance( MSXML::CLSID_XMLHTTPRequest, 
                               NULL, 
                               CLSCTX_INPROC_SERVER, 
        					   MSXML::IID_IXMLHttpRequest, 
                               (VOID**)&pxmlHTTP ); 
        if ( FAILED(hr) )
        {
            pxmlHTTP = NULL;
			safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(RequestAdminTicket) Failed to create XML HTTP object.  Failed to attain a Passport Admin Ticket.");
			if ( m_bAdminTicketActive )
			{
				nOutputLevel = 3;
				m_bAdminTicketActive = FALSE;
			}
			else
			{
				nOutputLevel = 0;
				m_bAdminTicketActive = FALSE;
			}
            bHasError = TRUE;
            goto Exit;
        }

        // open the connection
        vAsyncSetting.vt = VT_BOOL;
        vAsyncSetting.boolVal = false;

        // don't let the admin ticket be modified while we set up.
        if ( bszAdminTicketURL.Length() == 0 )
        {
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket) Invalid Admin Ticket URL.  Failed to attain a Passport Admin Ticket.");
			if ( m_bAdminTicketActive )
			{
				nOutputLevel = 3;
				m_bAdminTicketActive = FALSE;
			}
			else
			{
				nOutputLevel = 0;
				m_bAdminTicketActive = FALSE;
			}
            bHasError = TRUE;
            goto Exit;
        }
        _snwprintf( wszPassportURL, ARRAYSIZE(wszPassportURL), bszAdminTicketURL, lSiteId );

		OutputDebug( "DelAdmin:(RequestAdminTicket) Opening connection to Passport site.", S_OK, 0);
        hr = pxmlHTTP->open( CComBSTR(SEND_METHOD), CComBSTR(wszPassportURL), vAsyncSetting);
        if ( FAILED(hr) )
        {
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket) XML HTTP object failed to open a connection to the given site.  Failed to attain a Passport Admin Ticket.  Result = 0x%X", hr);
			if ( m_bAdminTicketActive )
			{
				nOutputLevel = 3;
				m_bAdminTicketActive = FALSE;
			}
			else
			{
				nOutputLevel = 0;
				m_bAdminTicketActive = FALSE;
			}
            bHasError = TRUE;
            goto Exit;
        }
        
        // set up the request header
        hr = pxmlHTTP->setRequestHeader(CComBSTR(MSG_HEADER), CComBSTR(MSG_VALUE) );
        if ( FAILED(hr) )
        {
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket) XML HTTP object failed to set request header.  Failed to attain a Passport Admin Ticket.  Result = 0x%X");
			if ( m_bAdminTicketActive )
			{
				nOutputLevel = 3;
				m_bAdminTicketActive = FALSE;
			}
			else
			{
				nOutputLevel = 0;
				m_bAdminTicketActive = FALSE;
			}
            bHasError = TRUE;
            goto Exit;
        }
        
        // send the data
        _snwprintf( wszLoginXML, ARRAYSIZE(wszLoginXML), LOGINXML, bszUserName, bszPassword );

		OutputDebug( "DelAdmin:(RequestAdminTicket) Sending Admin Ticket Information", S_OK, 0);
        vMsg.bstrVal = CComBSTR(wszLoginXML).Copy();
        vMsg.vt = VT_BSTR;
        hr = pxmlHTTP->send(vMsg);
        if ( FAILED(hr) )
        {
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket) XML HTTP object failed to send login information.    Failed to attain a Passport Admin Ticket.  Result = 0x%X", hr);
			if ( m_bAdminTicketActive )
			{
				nOutputLevel = 3;
				m_bAdminTicketActive = FALSE;
			}
			else
			{
				nOutputLevel = 0;
				m_bAdminTicketActive = FALSE;
			}
            bHasError = TRUE;
            goto Exit;
        }
        
        // get the response to the send.
        hr = pxmlHTTP->get_responseText( &(bszBody.m_str) );
        if ( FAILED(hr) )
        {
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket) XML HTTP object failed to get the response message.  Result = 0x%X", hr );
			if ( m_bAdminTicketActive )
			{
				nOutputLevel = 3;
				m_bAdminTicketActive = FALSE;
			}
			else
			{
				nOutputLevel = 0;
				m_bAdminTicketActive = FALSE;
			}
            bHasError = TRUE;
            goto Exit;
        }
        
        // extract the ticket string.
        wszStart = wcsstr( bszBody.m_str, L"t=" );
        if ( wszStart == NULL )
        {
            hr = E_ADMINTICKET_INVALIDTICKET;
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket) Response message format not valid.  Failed to attain a Passport Admin Ticket.");
			if ( m_bAdminTicketActive )
			{
				nOutputLevel = 3;
				m_bAdminTicketActive = FALSE;
			}
			else
			{
				nOutputLevel = 0;
				m_bAdminTicketActive = FALSE;
			}
            bHasError = TRUE;
            goto Exit;
        }
        wszStart = wszStart + 2;
        
        // find the ending of the ticket.
        wszFinish = wcsstr( wszStart, L"&" );
        if ( wszFinish == NULL )
        {
            hr = E_ADMINTICKET_INVALIDTICKET;
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket) Response message format not valid.  Failed to attain a Passport Admin Ticket.");
			if ( m_bAdminTicketActive )
			{
				nOutputLevel = 3;
				m_bAdminTicketActive = FALSE;
			}
			else
			{
				nOutputLevel = 0;
				m_bAdminTicketActive = FALSE;
			}
            bHasError = TRUE;
            goto Exit;
        }
        *wszFinish = L'\0';
        
        // get the ticket and set it's time stamp.
        *pszAdminTicket = CComBSTR(wszStart).Copy();
        time(plTimeStamp);
        
        *wszFinish = L'&';
        
        bszBody.Empty();
        ::SysFreeString(vMsg.bstrVal);

		safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(RequestAdminTicket) We have attained a new Admin Ticket from Passport.TIME = %s", ctime(plTimeStamp) );
		if ( !m_bAdminTicketActive )
		{
			nOutputLevel = 1;
			m_bAdminTicketActive = TRUE;
		}
		else
		{
			nOutputLevel = 0;
			m_bAdminTicketActive = TRUE;
		}

		OutputDebug( szErr, S_OK, nOutputLevel);
Exit:
        if ( bHasError )
        {
            OutputDebug( szErr, hr, nOutputLevel );
        }
	//-------------------------------------------------------------------------------------------
    }
    catch( _com_error ce )
    {
        // handle strange COM errors.
        hr = ce.Error();
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket)(COM)%s  Result = 0x%X", ce.ErrorMessage(), hr );
        OutputDebug( szErr );
    }
    catch(...)
    {
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(RequestAdminTicket)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr );

    }

	return hr;
}


//---------------------------------------------------------
//  LoadConfig():  Load configuration from DelAdmin.ini file.
//
//	REQUIRES DelAdmin.ini is in the proper place.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::LoadConfig()
{
	USES_CONVERSION;
	int nRead = 0;
	HRESULT hr = S_OK;
    char szError[DELADMIN_ERROR_STRING_SIZE];
	CXomSetting *pSet = NULL;

	OutputDebug("-------------------------\nDelAdmin:(LoadConfig) Config information.\n-------------------------", S_OK, 0);

    EnterCriticalSection( &m_csProperties );
    try 
	{        
        // read the encrypted namespace	
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szEcrNameSpace, &pSet)))
		{
			m_bszEncrNameSpace.Attach( CComBSTR( pSet->GetStr() ).Detach() );
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  EncryptedNameSpace=%s", W2A(m_bszEncrNameSpace.m_str) );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for encrypted namespace in ini file.");
            goto Exit;
		}

        // read the namespace
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szNameSpace, &pSet)))
		{
			m_bszNameSpace.Attach( CComBSTR( pSet->GetStr() ).Detach() );
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  NameSpace=%s", W2A(m_bszNameSpace.m_str) );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for namespace in ini file.");
            goto Exit;
		}

        // read the admin name
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szAdminName, &pSet)))
		{
			m_bszUserName.Attach( CComBSTR( pSet->GetStr() ).Detach() );
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  Admin Username=%s", W2A(m_bszUserName.m_str) );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for admin name in ini file.");
            goto Exit;
		}
        
        // read the password -- TODO:(lohab) REMOVE THIS ... the password should be given.
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szPassword, &pSet)))
		{
			m_bszPassword.Attach( CComBSTR( pSet->GetStr() ).Detach() );
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  Password=%s", W2A(m_bszPassword.m_str) );
		}
		else
		{
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for admin password in ini file.");
		}
        
        // read the passportURL
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szPassportURL, &pSet)))
		{
			m_bszEndPointURL.Attach( CComBSTR( pSet->GetStr() ).Detach() );
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  End Point URL=%s", W2A(m_bszEndPointURL.m_str) );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for passport URL in ini file.");
            goto Exit;
		}
        
        // read the siteid
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szSiteId, &pSet)))
		{
			m_lSiteId = pSet->GetDw();
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  SiteId = %l", m_lSiteId );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for Site ID within given ini file.");
            goto Exit;
		}
        
        // read admin ticket URL
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szAdminTicketURL, &pSet)))
		{
			m_bszAdminTicketURL.Attach( CComBSTR( pSet->GetStr() ).Detach() );
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  Admin Ticket URL = %s", W2A(m_bszAdminTicketURL.m_str) );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for admin ticket URL in ini file.");
            goto Exit;
		}

        // read admin ticket thread time interval
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szTimeInterval, &pSet)))
		{
			m_lThreadTimeInterval = pSet->GetDw();
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  Admin ticket thread time interval = %l", m_lThreadTimeInterval );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for the time interval in ini file.");
            goto Exit;
		}

        // read client info
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szClientInfo, &pSet)))
		{
			m_bszClientInfo.Attach( CComBSTR( pSet->GetStr() ).Detach() );
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  Client Info = %s", W2A(m_bszClientInfo.m_str) );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for the client info in ini file.");
            goto Exit;
		}

		// read version
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szVersion, &pSet)))
		{
			m_bszVersion.Attach( CComBSTR( pSet->GetStr() ).Detach() );
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  Version = %s", W2A(m_bszVersion.m_str) );
		}
		else
		{
			hr = E_DELADMIN_NOTCONFIG;
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find extry for the version in ini file.");
            goto Exit;
		}

		// read the generate PUID setting.
		if(SUCCEEDED(g_xomcentral.GetSetting( c_szGenPUID, &pSet)))
		{
			m_nGenPUID = pSet->GetDw();
			XomLog1(DelAdminLog, "DelAdmin: (Setting)  GenPUID = %d", m_nGenPUID );
		}
		else
		{
            safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(LoadConfig) Failed to find GenPUID flag.  Not a problem, continuing with default setting.");
			m_nGenPUID = 0;
 		}

Exit:
        if ( FAILED(hr) )
        {
		    char szErr[DELADMIN_ERROR_STRING_SIZE];

            // we have an error from somewhere in the code.  Return the proper error.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"%sResult = 0x%X", szError, hr );
            OutputDebug( szErr, hr, 2 );
        }

    }
    catch( _com_error ce )
    {
		char szErr[DELADMIN_ERROR_STRING_SIZE];

        hr = ce.Error();
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(LoadConfig)(COM)%s  Result = 0x%X", ce.ErrorMessage(), hr );
        OutputDebug( szErr, hr, 2 );
    }
    catch(...)
    {
		char szErr[DELADMIN_ERROR_STRING_SIZE];
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(LoadConfig)Unknown exception thrown.  Result = 0x%X");
        hr = E_FAIL;
        OutputDebug( szErr, hr, 2 );
    }

    LeaveCriticalSection( &m_csProperties );
	OutputDebug("-------------------------\nDelAdmin:(LoadConfig) Config information Complete.\n-------------------------", S_OK, 0);

    return hr;            
}


//---------------------------------------------------------
// KerbPasswordToKey:  Not really DelAdmin related but
//          modifies a kerb password to a key.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::KerbPasswordToKey(BSTR pwd, SAFEARRAY **ppByteArray)
{
	USES_CONVERSION;
    HRESULT hr = S_OK;
    CComSafeArray<BYTE> *psa = NULL;
    MD4_CTX md4Ctx;
    DWORD dwPasswordLen;

	dwPasswordLen = wcslen( pwd );

    MD4Init( &md4Ctx );
    MD4Update( &md4Ctx, (unsigned char *)pwd, dwPasswordLen * sizeof(WCHAR) );
    MD4Final( &md4Ctx );

    psa = new CComSafeArray<BYTE>(MD4_LEN);
    CopyMemory(psa->m_psa->pvData, md4Ctx.digest, MD4_LEN);
    *ppByteArray = *(psa->GetSafeArrayPtr());

	return hr;
}


//---------------------------------------------------------
// AdminTicketThread:  The Admin ticket thread function.
//---------------------------------------------------------
DWORD WINAPI CDAdmin::AdminTicketThread( LPVOID pThis )
{
    char szErr[DELADMIN_ERROR_STRING_SIZE];
    try
    {
        ((CDAdmin*)(pThis))->AdminTicketThreadInternal();
    }
    catch (...)
    {
        // so error has been thrown... but how do I know what it is... and what to I do with it.
        safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(AdminTicketThread)Unknown exception thrown.  AdminTicket Thread has been stopped.");
        OutputDebug( szErr, E_DELADMIN_ADMINTICKETTHREADPROBLEM, 3 );
    }

    return 0;
}

//---------------------------------------------------------
// AdminTicketThreadInternal:  The internal admin thread process.
//---------------------------------------------------------
void CDAdmin::AdminTicketThreadInternal()
{
    HRESULT hr = S_OK;  
    AdminTicketNode atNode;
    char szError[DELADMIN_ERROR_STRING_SIZE];
	DWORD dwRet;

	OutputDebug( "-------------------------\nDelAdmin:(AdminTicketThreadInternal)  DelAdmin Admin Ticket Thread has started.\n-------------------------", S_OK, 1 );

	m_bAdminTicketActive = TRUE;
    m_bEndTicketThread = FALSE;

	// continue until exit.
    while ( m_bEndTicketThread == FALSE )
    {
        try 
        {
            // just get a one time admin ticket.
            hr = RequestAdminTicket( &(atNode.m_bszTicket), &(atNode.m_lStamp) );
            if ( FAILED(hr) )
            {
                safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(AdminTicketThreadInternal) Failed to get an AdminTicket for this session. ");
                goto Exit;
            }

            // if we've got an admin ticket.
            EnterCriticalSection( &m_csAdminTicket );

                // set the global admin ticket.
                SysFreeString(m_AdminTicket.m_bszTicket.Detach());
                m_AdminTicket.m_bszTicket.Attach( atNode.m_bszTicket.Detach() );
                m_AdminTicket.m_lStamp    = atNode.m_lStamp;

            LeaveCriticalSection( &m_csAdminTicket );

			// wake up all the lonely threads.
			SetEvent( m_hNeedTicket );

			ResetEvent(m_hTicketEvent);
            dwRet = WaitForSingleObject( m_hTicketEvent, m_lThreadTimeInterval);

			switch ( dwRet )
			{
			case WAIT_TIMEOUT:
				{
					// we woke up.. get a ticket now... nothing special.
					OutputDebug( "DelAdmin:  Admin Ticket thread is awake, now getting an admin ticket.", S_OK, 1 );	
				}
				break;
			case WAIT_OBJECT_0:
				{
					// someone woke us up... apparently no admin tickets exist....  reset the event and get a ticket.
					if ( ResetEvent( m_hNeedTicket ) )
					{
						hr = E_DELADMIN_ADMINTICKETTHREADPROBLEM;
						OutputDebug( "DelAdmin:(AdminTicketThreadInternal) Failed to reset the NeedTicket Event, all subsequent calls will continue to fail without an admin ticket.", hr, 2 );
						safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE, "DelAdmin:(AdminTicketThreadInternal) Failed to reset the NeedTicket Event, all subsequent calls will continue to fail without an admin ticket." );
						goto Exit;
					}
				}
				break;
			case WAIT_ABANDONED:
				{
					hr = E_DELADMIN_ADMINTICKETTHREADPROBLEM;
					OutputDebug( "DelAdmin:(AdminTicketThreadInternal) Main Application has gone away, Admin Ticket Thread now shutting down.", S_OK, 0 );
					goto Exit;
				}
				break;
			default:
				{
					// this is probably WAIT_FAIL find the error, log it and kill this thread
					safe_snprintf( szError, DELADMIN_ERROR_STRING_SIZE,"", szError, hr );
					goto Exit;
				}
				break;
			}
Exit:
            if ( FAILED(hr) )
            {
			    char szErr[DELADMIN_ERROR_STRING_SIZE+15];

                // we have an error from somewhere in the code.  Return the proper error.
                safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE+15,"%sResult = 0x%X", szError, hr );
                OutputDebug( szErr, hr, 0 );

                // sleep for a timeout period.
                Sleep( THREAD_ERROR_SLEEP_TIME );
            }
        }
        catch(...)
        {
		    char szErr[DELADMIN_ERROR_STRING_SIZE];
            // so error has been thrown... but how do I know what it is... and what to I do with it.
            safe_snprintf( szErr, DELADMIN_ERROR_STRING_SIZE,"DelAdmin:(AdminTicketThreadInternal)Unknown exception thrown. ");
            OutputDebug( szErr, E_FAIL );

            // sleep for a timeout period.
            Sleep( THREAD_ERROR_SLEEP_TIME );
        }
    }

	OutputDebug("DelAdmin:(AdminTicketThreadInternal)  Admin Ticket Thread is ending...", S_OK, 1);
}

//---------------------------------------------------------
// TerminateAdminTicketThread:  terminates a thread process.
//---------------------------------------------------------
void CDAdmin::TerminateAdminTicketThread()
{
    // ensure this thread is still running.
    if ( m_dwTicketThreadId == -1 )
    {
        return;
    }

	OutputDebug("DelAdmin:(TerminateAdminTicketThread)  Terminating Admin Ticket Thread.", S_OK, 1);

	// tell the thread to terminate.
    m_bEndTicketThread = TRUE;

    // signal the sender thread.
    SetEvent( m_hTicketEvent );

    //$ PERF (lohab) This will wait for Send thread to wake up.
    WaitForSingleObject( m_hTicketThread, 1000 );
    CloseHandle( m_hTicketThread );
    CloseHandle( m_hTicketEvent );
    
    m_dwTicketThreadId = -1;

}


//---------------------------------------------------------
// Close():  Closes up the DelAdmin object.
//---------------------------------------------------------
STDMETHODIMP CDAdmin::Close()
{
	OutputDebug("-------------------------\nDelAdmin:(Close)  Closing DelAdmin object...-------------------------\n", S_OK, 1);

	// terminate all thread values.
	TerminateAdminTicketThread();
    DeleteCriticalSection( &m_csAdminTicket );

    DeleteCriticalSection( &m_csProperties );

    m_lSiteId = -1;

	// terminate the logging and debugging.
	g_xomcentral.Term();

	return S_OK;
}

//---------------------------------------------------------
// LOCAL FUNCTIONS
//---------------------------------------------------------

//---------------------------------------------------------
// ReadRegistryString:  Reads a local reg string.
//---------------------------------------------------------
DWORD ReadRegistryString( const char* szKey, const char* szValueName, char *szRetBuf, DWORD dwBufSize )
{  
	//open key
	HKEY hKey;	
	DWORD dwSize  = 0;
	
	// ensure the buffer is not NULL
	if ( szRetBuf == NULL )
	{
		return 0;
	}

	//create or open template key
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT,
	                              szKey, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return 0;
	}
	

	//get its value
	DWORD Type;
	BYTE tmpbuffer[255];
	LPBYTE Data = &tmpbuffer[0];
	DWORD cbData = 255;
				
	lResult=RegQueryValueExA(hKey,szValueName, NULL, &Type, Data, &cbData);

	if (lResult != ERROR_SUCCESS || Type != REG_SZ)
	{
        RegCloseKey( hKey );
		return 0;
	} 

	if ( dwBufSize < cbData ) 
	{
		dwSize = dwBufSize;
	}
	else
	{
		dwSize = cbData;
	}

    // close the key after.
    lResult = RegCloseKey( hKey );
	if (lResult != ERROR_SUCCESS)
	{
		return 0;
	}

	// copy the data to the local buffer.
	memcpy( (VOID*)szRetBuf, (VOID*)Data, dwSize );
	return dwSize;

}


//---------------------------------------------------------
// OutputDebug:  Outputs a debugging string to the 
//      debugger and the given file.
//---------------------------------------------------------
void OutputDebug( char *szErr , HRESULT hr/* = S_FALSE*/, int nLevel /*=2*/)
{
	switch ( nLevel )
	{
	case 0:
		{
			// trace... that's it...
			XomTrace0( DelAdminDebug, L_LOW, szErr );
		}
		break;
	case 1:
		{
			// trace it... but don't worry about it....  
			XomTrace0(DelAdminDebug, L_NORMAL, szErr);
			XomInfo0( HRESULT_CODE(hr), szErr );
		}
		break;
	case 2:
		{
			// log the problem -- something went wrong... but not the end of the world.
			XomLog0( DelAdminLog, szErr );
			XomTrace0( DelAdminDebug, L_WARNING, szErr);
			XomWarn0( HRESULT_CODE(hr), szErr );

		    // report the error atl style.
		    AtlReportError(CLSID_CDAdmin, (LPCSTR) szErr, IID_IDAdmin, hr );		
		}
		break;
	case 3:
		{
			// error time!!!! --- something bad happened... make note and do what you can.
			XomError0( HRESULT_CODE(hr), szErr );
			XomTrace0( DelAdminDebug, L_ERROR, szErr);
			XomLog0( DelAdminLog, szErr );
		
			// report the error atl style.
		    AtlReportError(CLSID_CDAdmin, (LPCSTR) szErr, IID_IDAdmin, hr );
		}
		break;
	default:
		{
			XomTrace0( DelAdminDebug, L_ERROR, "DelAdmin:  Unknown error level.");
			XOMASSERT( 0 );
		}
	}

}

//---------------------------------------------------------
// MapStringToHResult:  Maps a passport string to some H
//		HResult defined for deladmin.
//---------------------------------------------------------
HRESULT MapStringToHResult(  const WCHAR *wszString  )
{
	HRESULT hr = S_OK;

	if ( wcscmp( wszString, c_wszPEUserExists ) == 0 )
	{
		hr = E_PASSPORT_USEREXISTS;
	}
	else if ( wcscmp( wszString, c_wszPETicketExpired ) == 0 )
	{
		hr = E_PASSPORT_INVALIDTICKET;
	}
	else
	{
		hr = E_PASSPORT_FAIL;
	}

	return hr;
}

//------------------------------------------------------------------
//  GenerateRandomBinary:  generates a valid string for a user name/password.
//
//------------------------------------------------------------------
BOOL GenerateRandomBinary( char *szBuf, int nBufSize )
{
    HCRYPTPROV hCryptProv;
    BOOL bRet = TRUE;
  
    _ASSERT( szBuf != NULL );
    //--------------------------------------------------------------------
    // Get a handle to the default PROV_RSA_FULL provider.

    if( !CryptAcquireContext( &hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)) 
    {
        if(!CryptAcquireContext( &hCryptProv,  NULL,  NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) 
        {
            bRet = FALSE;
            goto Exit;
        }
    }

    // Generate random bytes.
    if( !CryptGenRandom( hCryptProv, sizeof(char) *nBufSize,  (BYTE*)szBuf)) 
    {
        bRet = FALSE;
        goto Exit;    
    }

    if ( !CryptReleaseContext( hCryptProv, NULL ) )
    {
        // memory leak
        bRet = FALSE;
        goto Exit;
    }
    
Exit:
    
    return bRet;
}

//---------------------------------------------------------
// GeneratePUID:  Generates a puid and places it in the
//		given bstr
//---------------------------------------------------------
void GeneratePUID( BSTR *pbstrPUID )
{
	USES_CONVERSION;	
	char  szGenBuf[8];
	WCHAR wszPUID[24];
	ULONGLONG qwFakePUID = 0;

	XOMASSERT( pbstrPUID != NULL );

	if ( !GenerateRandomBinary( szGenBuf, 8 ) )
	{
		//ok.. if we fail... just rand and set the high bit.
		qwFakePUID = (ULONGLONG)rand();
	}
	else
	{	
		qwFakePUID = *((ULONGLONG*)(szGenBuf));		
	}

	qwFakePUID &= ( 0x0000FFFFFFFFFFFF );
	qwFakePUID |= ( 0x0004000000000000 );
	
	// alloc the space required.
	_snwprintf( wszPUID, ARRAYSIZE(wszPUID) , L"%I64u", qwFakePUID );
	*pbstrPUID = SysAllocString( wszPUID );
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DelAdmin.rc
//
#define IDS_PROJNAME                    100
#define IDS_DADMIN_DESC                 101
#define IDR_DAdmin                      102
#define IDS_USER_DESC                   103
#define IDR_User                        104



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\DelAdmin.cpp ===
// DelAdmin.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for DelAdmin.idl by adding the following 
//      files to the Outputs.
//          DelAdmin_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f DelAdminps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DelAdmin.h"
//#include "dlldatax.h"

#include "DelAdmin_i.c"
#include "DAdmin.h"
#include "User.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CDAdmin, CDAdmin)
OBJECT_ENTRY(CLSID_CUser, CUser)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DELADMINLib);
        DisableThreadLibraryCalls(hInstance);

    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
	}


    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif

    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\reg\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\DAdmin.h ===
//---------------------------------------------------------
// DAdmin.h: Definition of the DAdmin class
//
//	Date: 08/17/01
//	Modified:  lohab  -- Creation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------

#if !defined(AFX_DADMIN_H__BA338521_C51F_4DF9_BAEB_A1A99E6FE509__INCLUDED_)
#define AFX_DADMIN_H__BA338521_C51F_4DF9_BAEB_A1A99E6FE509__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//---------------------------------------------------------
// INCLUDES
//---------------------------------------------------------
#include "resource.h"       // main symbols
#include <time.h>

//---------------------------------------------------------
// TYPES
//---------------------------------------------------------
typedef struct _AdminTicketNode
{
    time_t      m_lStamp;
    CComBSTR    m_bszTicket; 
} AdminTicketNode;

//---------------------------------------------------------
// ERROR CODES
//---------------------------------------------------------
const HRESULT E_PASSPORT_USEREXISTS					= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59000);
const HRESULT E_PASSPORT_INVALIDTICKET				= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59001);
const HRESULT E_PASSPORT_FAIL						= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59002);

const HRESULT E_ADMINTICKET_CONNECTIONFAILED		= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59003);
const HRESULT E_ADMINTICKET_REQUESTFAILED			= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59004);
const HRESULT E_ADMINTICKET_INVALIDTICKET			= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59005);

const HRESULT E_SOAPTOOLKIT_NOOUTPUTSTREAM			= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59006);
const HRESULT E_SOAPTOOLKIT_NORESPONSE				= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59007);
const HRESULT E_SOAPTOOLKIT_NOPASSPORT				= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59008);
const HRESULT E_SOAPTOOLKIT_CANNOTFORMAT			= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59009);

const HRESULT E_DELADMIN_ADMINTICKETTHREADPROBLEM	= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59010);
const HRESULT E_DELADMIN_NOTCONFIG					= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59011);
const HRESULT E_DELADMIN_ADMINTICKETTHREADFAIL		= MAKE_HRESULT( SEVERITY_ERROR, FACILITY_NULL, 59012);


//---------------------------------------------------------
// Global Functions
//---------------------------------------------------------

//---------------------------------------------------------
// DAdmin

class CDAdmin : 
	public IDispatchImpl<IDAdmin, &IID_IDAdmin, &LIBID_DELADMINLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CDAdmin,&CLSID_CDAdmin>
{
public:
	CDAdmin();

BEGIN_COM_MAP(CDAdmin)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IDAdmin)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(DAdmin) 

DECLARE_REGISTRY_RESOURCEID(IDR_DAdmin)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IDAdmin
public:
	STDMETHOD(KerbPasswordToKey)(/*[in]*/BSTR pwd, /*[out, retval]*/SAFEARRAY** ppByteArray);
	STDMETHOD(NameSpaceChangeNameRequest)(BSTR bszType, BSTR bszOldName, BSTR bszNewName, BSTR *pRes);
	STDMETHOD(NameSpaceDeleteAltCredRequest)(BSTR bszXName, BSTR *pRes);
	STDMETHOD(NameSpaceResetPasswordAltCredRequest)(BSTR bszXName, BSTR bszNewPassword, BSTR *pRes);
	STDMETHOD(NameSpaceAddAltCredRequest)(IUser *pExitingUser, BSTR *pRes);
	STDMETHOD(NameSpaceSignUpAltCredRequest)(IUser *newUser, BSTR *pRes);
	STDMETHOD(get_Version)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Version)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ClientInfo)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ClientInfo)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_AdminTicketURL)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_AdminTicketURL)(/*[in]*/ BSTR newVal);
	STDMETHOD(GetAdminProperties)(BSTR *pbszUsername, BSTR *pbszPassword);
    // COM attribute interface methods.
	STDMETHOD(SetAdminProperties)(BSTR bszAdminName, BSTR bszPassword);
	STDMETHOD(get_AdminTicket)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_AdminTicket)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_EncryptedNameSpace)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EncryptedNameSpace)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_NameSpace)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_NameSpace)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SiteID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SiteID)(/*[in]*/ long newVal);
	STDMETHOD(get_EndPointURL)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EndPointURL)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThreadTimeInterval)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_ThreadTimeInterval)(/*[in]*/ long newVal);

	// COM interface methods
	STDMETHOD(Init)( BOOL bCreateAdminTicketThread );
	STDMETHOD(Close)();
	STDMETHOD(NameSpaceResetPassword)(BSTR bszSignInName, BSTR bszNewPassword, BSTR *pRes);
	STDMETHOD(NameSpaceRemoveMemberRequest)(IUser *pUser, BSTR *pRes);
	STDMETHOD(NameSpaceSignUpRequest)(IUser *pNewUser, BSTR *pRes);
	STDMETHOD(NameSpaceReleaseRequest)( BSTR *pRes );
	STDMETHOD(NameSpaceReserve)(BSTR bszPartnerAdmin, IUser *pAdmin, BSTR *pRes );
	STDMETHOD(LoadConfig)();


	STDMETHOD(RequestAdminTicket)( BSTR *pszAdminTicket, long *lTimeStamp );

protected:

	// config protected properties.
	CComBSTR			m_bszEndPointURL;
	CComBSTR			m_bszEncrNameSpace;
	CComBSTR			m_bszNameSpace;
	CComBSTR			m_bszUserName;
	CComBSTR			m_bszPassword;
	long				m_lSiteId;
    CComBSTR			m_bszAdminTicketURL;
	CComBSTR			m_bszVersion;
	CComBSTR			m_bszClientInfo;

	int					m_nGenPUID;
	BOOL				m_bAdminTicketActive;

    // admin ticket properties
    AdminTicketNode		m_AdminTicket;
    long				m_lThreadTimeInterval;

    // thread variables.
    CRITICAL_SECTION    m_csAdminTicket;        // the critical section for this admin ticket.
    CRITICAL_SECTION    m_csProperties;         // the critical section for data properties.
    HANDLE              m_hTicketThread;        // handle for the admin ticket thread.
    DWORD               m_dwTicketThreadId;     // id of the ticket thread.
    BOOL                m_bEndTicketThread;     // notifies thread if it should exit.
    HANDLE              m_hTicketEvent;         // a handle used to wake up the thread.
	HANDLE				m_hNeedTicket;			// a handle to halt things when a ticket is required.

	// error return methods.
	HRESULT GetErrorString( ISoapReaderPtr pSoapReader, BSTR* pbszError );

private:
    // admin thread
	static DWORD WINAPI AdminTicketThread( LPVOID pThis );
    void AdminTicketThreadInternal();
	void TerminateAdminTicketThread();

	HRESULT GenerateUserNode(   ISoapConnectorPtr pSoapConnector, 
                                ISoapSerializerPtr pSoapSerializer, 
                                ISoapReaderPtr pSoapReader, 
                                IUser *pUser );

	// generates SOAP message headers.	
	HRESULT GenerateMsgHeader(  ISoapConnectorPtr &pSoapConnector, 
                                ISoapSerializerPtr &pSoapSerializer, 
                                ISoapReaderPtr &pSoapReader, 
                                char *szSoapAction );
	
};

#endif // !defined(AFX_DADMIN_H__BA338521_C51F_4DF9_BAEB_A1A99E6FE509__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__09F03D5D_44E4_4378_A80B_3FA71D5EB375__INCLUDED_)
#define AFX_STDAFX_H__09F03D5D_44E4_4378_A80B_3FA71D5EB375__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlsafe.h>

#include <msxml.h>
#import "msxml.dll" named_guids raw_interfaces_only

#import "msxml3.dll" raw_interfaces_only
using namespace MSXML2;

#import "mssoap1.dll" raw_interfaces_only exclude("IStream", "ISequentialStream", "_LARGE_INTEGER", "_ULARGE_INTEGER", "tagSTATSTG", "_FILETIME")
using namespace MSSOAPLib;


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__09F03D5D_44E4_4378_A80B_3FA71D5EB375__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\User.h ===
//---------------------------------------------------------
// User.h: Definition of the User class
//
//	Date: 08/17/01
//	Modified:  lohab  -- Creation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------

#if !defined(AFX_USER_H__5CA32133_3F7F_4338_9734_D57F3B7187B9__INCLUDED_)
#define AFX_USER_H__5CA32133_3F7F_4338_9734_D57F3B7187B9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// User

class CUser : 
	public IDispatchImpl<IUser, &IID_IUser, &LIBID_DELADMINLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CUser,&CLSID_CUser>
{
public:
	CUser() {}
BEGIN_COM_MAP(CUser)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IUser)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(User) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_User)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IUser
public:
	STDMETHOD(get_XCred_Password)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_XCred_Password)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_XCred_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_XCred_Name)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_UserPUID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_UserPUID)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Password)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Password)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Flags)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Flags)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Occupation)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Occupation)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_TimeZone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TimeZone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_LastName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_LastName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Accessibility)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Accessibility)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FirstName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FirstName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_LanguagePreference)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_LanguagePreference)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_AllowPassportNetworkEmail)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_AllowPassportNetworkEmail)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_AllowEmailInProfile)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_AllowEmailInProfile)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_SecretAnswer)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SecretAnswer)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SecretQuestion)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SecretQuestion)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Birthday)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Birthday)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_PostalCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_PostalCode)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Region)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Region)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Country)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Country)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Gender)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Gender)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Email)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Email)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_NickName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_NickName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SignInName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SignInName)(/*[in]*/ BSTR newVal);
protected:
	CComBSTR m_bszXCred_Password;
	CComBSTR m_bszXCred_Name;
	CComBSTR m_bszPassword;
	CComBSTR m_bszUserPUID;
	CComBSTR m_bszGender;
	CComBSTR m_bszFirstName;
	CComBSTR m_bszAccessibility;
	CComBSTR m_bszLastName;
	CComBSTR m_bszTimeZone;
	CComBSTR m_bszOccupation;
	CComBSTR m_bszFlags;
	CComBSTR m_bszLanguage;
	BOOL m_bAllowPassportNetworkEmail;
	BOOL m_bAllowEmailInProfile;
	CComBSTR m_bszSecretAnswer;
	CComBSTR m_bszSecretQuestion;
	CComBSTR m_bszBirthday;
	CComBSTR m_bszPostalCode;
	CComBSTR m_bszRegion;
	CComBSTR m_bszCountry;
	CComBSTR m_bszEmail;
	CComBSTR m_bszNickName;
	CComBSTR m_bszSignInName;
};

#endif // !defined(AFX_USER_H__5CA32133_3F7F_4338_9734_D57F3B7187B9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\dll\User.cpp ===
// User.cpp : Implementation of CDelAdminApp and DLL registration.

#include "stdafx.h"
#include "DelAdmin.h"
#include "User.h"

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CUser::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IUser,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CUser::get_SignInName(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszSignInName.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_SignInName(BSTR newVal)
{
	 

	m_bszSignInName = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_NickName(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszNickName.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_NickName(BSTR newVal)
{
	 
	m_bszNickName = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Email(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszEmail.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Email(BSTR newVal)
{
	 
	m_bszEmail = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Gender(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszGender.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Gender(BSTR newVal)
{
	 
	m_bszGender = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Country(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszCountry.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Country(BSTR newVal)
{
	 

	m_bszCountry = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Region(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszRegion.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Region(BSTR newVal)
{
	 

	m_bszRegion = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_PostalCode(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszPostalCode.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_PostalCode(BSTR newVal)
{
	 
	m_bszPostalCode = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Birthday(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszBirthday.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Birthday(BSTR newVal)
{
	 

	m_bszBirthday = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_SecretQuestion(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;

	*pVal = m_bszSecretQuestion.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_SecretQuestion(BSTR newVal)
{
	 

	m_bszSecretQuestion = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_SecretAnswer(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszSecretAnswer.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_SecretAnswer(BSTR newVal)
{
	 
	
	m_bszSecretAnswer = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_AllowEmailInProfile(BOOL *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bAllowEmailInProfile;

	return S_OK;
}

STDMETHODIMP CUser::put_AllowEmailInProfile(BOOL newVal)
{
	 

	m_bAllowEmailInProfile = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_AllowPassportNetworkEmail(BOOL *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;

	*pVal = m_bAllowPassportNetworkEmail;

	return S_OK;
}

STDMETHODIMP CUser::put_AllowPassportNetworkEmail(BOOL newVal)
{
	 

	m_bAllowPassportNetworkEmail = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_LanguagePreference(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszLanguage.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_LanguagePreference(BSTR newVal)
{
	 

	m_bszLanguage = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_FirstName(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszFirstName.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_FirstName(BSTR newVal)
{
	 
	m_bszFirstName = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Accessibility(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszAccessibility.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Accessibility(BSTR newVal)
{
	 
	m_bszAccessibility = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_LastName(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszLastName.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_LastName(BSTR newVal)
{
	 
	m_bszLastName = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_TimeZone(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszTimeZone.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_TimeZone(BSTR newVal)
{
	 
	m_bszTimeZone = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Occupation(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszOccupation.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Occupation(BSTR newVal)
{
	 
	m_bszOccupation = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Flags(BSTR *pVal)
{
	 
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszFlags.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Flags(BSTR newVal)
{
	m_bszFlags = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_Password(BSTR *pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszPassword.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_Password(BSTR newVal)
{
	m_bszPassword =  newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_UserPUID(BSTR *pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszUserPUID.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_UserPUID(BSTR newVal)
{
	m_bszUserPUID = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_XCred_Name(BSTR *pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszXCred_Name.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_XCred_Name(BSTR newVal)
{
    m_bszXCred_Name = newVal;

	return S_OK;
}

STDMETHODIMP CUser::get_XCred_Password(BSTR *pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	*pVal = m_bszXCred_Password.Copy();

	return S_OK;
}

STDMETHODIMP CUser::put_XCred_Password(BSTR newVal)
{
    m_bszXCred_Password = newVal;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\CmdMgr.h ===
//---------------------------------------------------------
// CmdMgr.h: interface for the CCmdMgr class.
//
//	Date: 11/5/01
//	Modified:  lohab  -- Creation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------

#if !defined(AFX_CMDMGR_H__1421453A_8072_4923_A543_CB32F46A12B5__INCLUDED_)
#define AFX_CMDMGR_H__1421453A_8072_4923_A543_CB32F46A12B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//---------------------------------------------------------
// INCLUDES
//---------------------------------------------------------
#include "deladmin.h"

//---------------------------------------------------------
// CONSTANTS and DEFINITIONS
//---------------------------------------------------------
#define NUMBER_OF_CMD_CALLS     8

//---------------------------------------------------------
// TYPES
//---------------------------------------------------------
typedef struct _CmdThread
{
    DWORD       m_dwThreadId;
    HANDLE      m_hThread;
    DWORD       m_dwMgrId;
    BOOL        m_bIsDone;

    IUser      *m_pUser;
} CmdThread;

//---------------------------------------------------------
// CLASS DEFINITION
//---------------------------------------------------------

class CCmdMgr  
{
public:
	BOOL IsDone();
	CCmdMgr();
	virtual ~CCmdMgr();

    // set up threads.
    void ExecuteAll();
	void SetUpProcesses( int nOperation, IUser *pUserTemplate );
	void SignalWorkerDone( int nId );

    // property access methods.
    int GetNumOfProcesses();
	void SetNumOfProcesses( int nProcesses );

  	IDAdmin* GetDelAdminObj();
    void SetDelAdminObj( IDAdmin *pObj );

   	HWND GetMainWnd();
	void SetMainWnd( HWND hWnd );

    static CString AssociatedRequest( int nRequestIdx );

protected:
	HWND m_hWnd;
	IDAdmin* m_pDAdmin;
	int m_nNumOfProcesses;                  // number of processes.

    // thread management methods.
	static DWORD WINAPI WorkerThread( LPVOID pItem );
	void TerminateThreadList();


private:
	int m_nNumCompleted;
	void CopyUser( IUser *pFrom, IUser *pTo );

    // thread list varaibles.
	CRITICAL_SECTION m_csThreadList;
    CmdThread *m_pThreadList;               // list of processes.

    // used to start all worker threads.
	HANDLE m_hStartEvent;

    void WorkerThreadInternal(int nId, int nOperation, IUser *pUser);
	BOOL CmdCreateThread( int nOperation, CmdThread &obj );
    BOOL CallCmd( int nId, int nAction, IUser* pUser);

};

#endif // !defined(AFX_CMDMGR_H__1421453A_8072_4923_A543_CB32F46A12B5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\DAProperties.cpp ===
// DAProperties.cpp : implementation file
//

#include "stdafx.h"
#include "DelAdminTester.h"
#include "DAProperties.h"

#include "DelAdmin.h"

#include <Rpcdce.h>
#include <string.h>
#include <atlbase.h>
#include <wincrypt.h>

#import "c:\winnts\system32\MicrosoftPassport\msppmgr.dll" named_guids raw_interfaces_only no_namespace

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define CHECK_HR(hr) {if (FAILED(hr)) goto Exit; }
/////////////////////////////////////////////////////////////////////////////
// CDAProperties dialog


CDAProperties::CDAProperties(CWnd* pParent /*=NULL*/)
	: CDialog(CDAProperties::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDAProperties)
	m_strAdminPassword = _T("");
	m_strAdminTicket = _T("");
	m_bUseAdminTicket = FALSE;
	m_strAdminUsername = _T("");
	m_strATURL = _T("");
	m_strNS = _T("");
	m_strEncryptedNS = _T("");
	m_strPassportURL = _T("");
	m_lSiteId = 6455;
	m_lThreadInterval = 0;
	m_strClientInfo = _T("");
	m_strVersion = _T("");
	//}}AFX_DATA_INIT
    m_pDAdmin = NULL;

}


void CDAProperties::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDAProperties)
   	DDX_Text(pDX, IDC_ADMIN_PASSWORD, m_strAdminPassword);
	DDX_Text(pDX, IDC_ADMIN_TICKET, m_strAdminTicket);
	DDX_Check(pDX, IDC_ADMIN_TICKET_THREAD, m_bUseAdminTicket);
	DDX_Text(pDX, IDC_ADMIN_USERNAME, m_strAdminUsername);
	DDX_Text(pDX, IDC_AT_URL, m_strATURL);
	DDX_Text(pDX, IDC_DA_NAMESPACE, m_strNS);
	DDX_Text(pDX, IDC_ENCRYPTED_NS, m_strEncryptedNS);
	DDX_Text(pDX, IDC_PASSPORT_URL, m_strPassportURL);
  	DDX_Text(pDX, IDC_SITEID, m_lSiteId);
	DDX_Text(pDX, IDC_AT_INTERVAL, m_lThreadInterval);
	DDX_Text(pDX, IDC_CLIENTINFO, m_strClientInfo);
	DDX_Text(pDX, IDC_VERSION, m_strVersion);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDAProperties, CDialog)
	//{{AFX_MSG_MAP(CDAProperties)
	ON_BN_CLICKED(IDC_ADMIN_MORE, OnAdminMore)
	ON_BN_CLICKED(IDC_ENCRYPT, OnEncrypt)
	ON_BN_CLICKED(IDC_GET_NEW_TICKET, OnGetNewTicket)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDAProperties message handlers

void CDAProperties::OnOK() 
{
    UpdateData(TRUE);
    // set these values into DelAdmin.
    SetDataToDA();

	CDialog::OnOK();
}

BOOL CDAProperties::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // we should definitely have the DelAdmin object at this point or don't 
    // worry about showing this dialog.
    ASSERT( m_pDAdmin );

    GetDataFromDA();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//-----------------------------------------------------------
// GetDataFromDA() - gets delegated admin information from the
//     object.
//-----------------------------------------------------------
HRESULT CDAProperties::GetDataFromDA()
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComBSTR bszHolder;
    CComBSTR bszHolder2;

    // admin ticket
    hr = m_pDAdmin->get_AdminTicket( &(bszHolder.m_str) );
    CHECK_HR(hr);
    m_strAdminTicket = CString(W2A(bszHolder.m_str) );
    SysFreeString(bszHolder.Detach());

    // site id
    hr = m_pDAdmin->get_SiteID( &m_lSiteId );
    CHECK_HR(hr);

    // name space
    hr = m_pDAdmin->get_NameSpace( &(bszHolder.m_str) );
    CHECK_HR(hr);
    m_strNS = CString(W2A(bszHolder.m_str) );
    SysFreeString(bszHolder.Detach());

    // encrypted namespace
    hr = m_pDAdmin->get_EncryptedNameSpace( &(bszHolder.m_str) );
    CHECK_HR(hr);
    m_strEncryptedNS = CString(W2A(bszHolder.m_str) );
    SysFreeString(bszHolder.Detach());

    // passport URL
    hr = m_pDAdmin->get_EndPointURL( &(bszHolder.m_str) );
    CHECK_HR(hr);
    this->m_strPassportURL = CString(W2A(bszHolder.m_str) );
    SysFreeString(bszHolder.Detach());

    // time interval
    hr = m_pDAdmin->get_ThreadTimeInterval( &m_lThreadInterval );
    CHECK_HR(hr);

    // admin ticket URL
    hr = m_pDAdmin->get_AdminTicketURL( &(bszHolder.m_str) );
    CHECK_HR(hr);
    this->m_strATURL = CString(W2A(bszHolder.m_str) );
    SysFreeString(bszHolder.Detach());

    // admin ticket URL
    hr = m_pDAdmin->get_Version( &(bszHolder.m_str) );
    CHECK_HR(hr);
    m_strVersion = CString(W2A(bszHolder.m_str) );
    SysFreeString(bszHolder.Detach());

    // admin ticket URL
    hr = m_pDAdmin->get_ClientInfo( &(bszHolder.m_str) );
    CHECK_HR(hr);
    m_strClientInfo = CString(W2A(bszHolder.m_str) );
    SysFreeString(bszHolder.Detach());

    // admin properties.
    hr = m_pDAdmin->GetAdminProperties( &(bszHolder.m_str), &(bszHolder2.m_str) );
    CHECK_HR(hr);
    this->m_strAdminUsername = CString(W2A(bszHolder.m_str) );
    this->m_strAdminPassword = CString(W2A(bszHolder2.m_str) );
    SysFreeString(bszHolder.Detach());
    SysFreeString(bszHolder2.Detach());


    UpdateData(FALSE);
Exit:

    UpdateData(TRUE);
    return hr;
}

//-----------------------------------------------------------
// SetDataToDA() - sets delegated admin information from the
//     object.
//-----------------------------------------------------------
HRESULT CDAProperties::SetDataToDA()
{
    HRESULT hr = S_OK;

    // DON't EVER SET THE ADMIN TICKET!!!!!

    // site id
    hr = m_pDAdmin->put_SiteID( m_lSiteId );
    CHECK_HR(hr);

    // name space
    hr = m_pDAdmin->put_NameSpace( CComBSTR(m_strNS) );
    CHECK_HR(hr);

    // encrypted namespace
    hr = m_pDAdmin->put_EncryptedNameSpace( CComBSTR(m_strEncryptedNS));
    CHECK_HR(hr);

    // passport URL
    hr = m_pDAdmin->put_EndPointURL( CComBSTR(m_strPassportURL) );
    CHECK_HR(hr);
 
    // time interval
    hr = m_pDAdmin->put_ThreadTimeInterval( m_lThreadInterval );
    CHECK_HR(hr);

    // admin ticket URL
    hr = m_pDAdmin->put_AdminTicketURL( CComBSTR(m_strATURL) );
    CHECK_HR(hr);

    // version
    hr = m_pDAdmin->put_Version( CComBSTR(m_strVersion) );
    CHECK_HR(hr);

    // clientinfo
    hr = m_pDAdmin->put_ClientInfo( CComBSTR(m_strVersion) );
    CHECK_HR(hr);

    // admin properties.
    hr = m_pDAdmin->SetAdminProperties( CComBSTR(m_strAdminUsername), CComBSTR(m_strAdminPassword) );
    CHECK_HR(hr);


Exit:
    return hr;
}

void CDAProperties::SetDAObj(IDAdmin *pAdmin)
{
    // ensure the admin pointer is valid.
    _ASSERT( pAdmin );

    // set the value. 
    m_pDAdmin = pAdmin;
}

void CDAProperties::OnAdminMore() 
{
	// TODO: Add your control notification handler code here
	
}

void CDAProperties::OnEncrypt() 
{
    USES_CONVERSION;
    HRESULT hr;
    IPassportCrypt *piPassCrypt;
    CComBSTR bszEncrypt;
    CString strTempENS;

    UpdateData(TRUE);

    // create a passport crypt object	
    hr = CoCreateInstance( CLSID_Crypt, 
                           NULL, 
                           CLSCTX_INPROC_SERVER, 
                           IID_IPassportCrypt, 
                           (void**)&piPassCrypt);

    if ( FAILED(hr) )
    {
        OutputDebugString( "CDAProperties::OnEncrypt():  Failed to create the crypto object." );
        goto Exit;
    }
    
    // give it the string and get teh result.
    hr = piPassCrypt->Encrypt( CComBSTR( m_strNS ), &(bszEncrypt.m_str) );
    CHECK_HR(hr);

    // set the result.
    m_strEncryptedNS = W2A(bszEncrypt);

    UpdateData(FALSE);
Exit:

    if ( piPassCrypt != NULL )
    {
        piPassCrypt->Release();
    }

    UpdateData(TRUE);
}

void CDAProperties::OnGetNewTicket() 
{
    USES_CONVERSION;
    HRESULT hr;
    CComBSTR bszHolder;
    long lStamp;
    
    UpdateData(TRUE);
    hr = SetDataToDA();
    CHECK_HR(hr);

    hr = m_pDAdmin->RequestAdminTicket( &bszHolder, &lStamp );
    // admin ticket
    hr = m_pDAdmin->put_AdminTicket( bszHolder );
    CHECK_HR(hr);
    m_strAdminTicket = CString(W2A(bszHolder.m_str) );
	
    UpdateData(FALSE);
Exit:
    UpdateData(TRUE);
}

void CDAProperties::OnRefresh() 
{
    GetDataFromDA();	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\DelAdminTester.cpp ===
// DelAdminTester.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "DelAdminTester.h"
#include "DelAdminTesterDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDelAdminTesterApp

BEGIN_MESSAGE_MAP(CDelAdminTesterApp, CWinApp)
	//{{AFX_MSG_MAP(CDelAdminTesterApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDelAdminTesterApp construction

CDelAdminTesterApp::CDelAdminTesterApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDelAdminTesterApp object

CDelAdminTesterApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDelAdminTesterApp initialization

BOOL CDelAdminTesterApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

    CoInitialize( NULL );
#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CDelAdminTesterDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
        
	}
	else if (nResponse == IDCANCEL)
	{
	}

    CoUninitialize();
	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\CmdMgr.cpp ===
//---------------------------------------------------------
// CmdMgr.cpp: implementation of the CCmdMgr class.
//
//	Date: 11/5/01
//	Modified:  lohab  -- Creation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------

//---------------------------------------------------------
// INCLUDES
//---------------------------------------------------------
#include "stdafx.h"
#include "DelAdminTester.h"
#include "CmdMgr.h"
#include "DelAdminTesterDlg.h"

#include "DelAdmin.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//---------------------------------------------------------
// CONSTANTS and DEFINITIONS
//---------------------------------------------------------

//---------------------------------------------------------
// TYPES
//---------------------------------------------------------
class ThreadContainer
{
public:
    int m_nId;
    int m_nOperation;
    CCmdMgr *m_pThis;
    IUser *m_pUser;

};

/*typedef struct _ThreadContainer
{
    int m_nId;
    int m_nOperation;
    CCmdMgr *m_pThis;
    IUser *m_pUser;

} ThreadContainer;
*/
//---------------------------------------------------------
// Construction/Destruction
//---------------------------------------------------------

CCmdMgr::CCmdMgr()
{
    m_nNumOfProcesses = 0;

    // create the critical section.
    InitializeCriticalSection( &m_csThreadList );

    // create the start event.
    m_hStartEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    // don't continue if this fails.
    _ASSERT( m_hStartEvent );

    m_pThreadList = NULL;
    m_hWnd = 0;
    m_nNumCompleted = 0;
}

CCmdMgr::~CCmdMgr()
{
    BOOL bRes = FALSE;

    // destroy the critical section
    EnterCriticalSection( &m_csThreadList );
    if ( m_pThreadList != NULL )
    {
        TerminateThreadList();
        m_pThreadList = NULL;
    }
    LeaveCriticalSection( &m_csThreadList );

    m_nNumOfProcesses = 0;

    // destroy the critical section.
    DeleteCriticalSection( &m_csThreadList );
    
    // close the handle
    bRes = CloseHandle( m_hStartEvent );
    _ASSERT( bRes );
}

//---------------------------------------------------------
// The Number of processes access methods.
void CCmdMgr::SetNumOfProcesses(int nProcesses)
{
    _ASSERT( nProcesses > 0 );

    m_nNumOfProcesses = nProcesses;
}

int CCmdMgr::GetNumOfProcesses()
{
    return m_nNumOfProcesses;
}

//---------------------------------------------------------
// The DelAdmin access methods.
void CCmdMgr::SetDelAdminObj(IDAdmin *pObj)
{
    _ASSERT( pObj );

    m_pDAdmin = pObj;
}

IDAdmin* CCmdMgr::GetDelAdminObj()
{
    return m_pDAdmin;
}


//---------------------------------------------------------
// The main window access methods.
void CCmdMgr::SetMainWnd(HWND hWnd)
{
    _ASSERT(hWnd > 0);
    m_hWnd = hWnd;
}

HWND CCmdMgr::GetMainWnd()
{
    return m_hWnd;
}


//---------------------------------------------------------
// SetUpProcesses: set up the list with the necessary 
//      threads.
//---------------------------------------------------------
void CCmdMgr::SetUpProcesses( int nOperation, IUser *pUserTemplate )
{
    USES_CONVERSION;
    int nX = 0;
    CComBSTR bszName;
    WCHAR *wszFmtPos = 0;
    WCHAR  wszBuf[64];
    HRESULT hr;
    
    _ASSERT( m_nNumOfProcesses > 0 );
    _ASSERT( m_hWnd );
    
    EnterCriticalSection( &m_csThreadList );

    // create the list for the number of processes.
    m_pThreadList = new CmdThread[m_nNumOfProcesses];

    // for each entry in the list create a thread and give it an id.
    for ( nX = 0; nX < m_nNumOfProcesses; nX++ )
    {
        m_pThreadList[nX].m_dwMgrId = nX;
        m_pThreadList[nX].m_bIsDone = FALSE;

        // create a user for this process.
        hr = CoCreateInstance( CLSID_CUser, 
                                    NULL, 
                                    CLSCTX_ALL, 
                                    IID_IUser,
                                    (VOID**)&(m_pThreadList[nX].m_pUser) );

        _ASSERT( !FAILED(hr) );

        // copy the user information over.
        CopyUser( pUserTemplate, m_pThreadList[nX].m_pUser );

        // check the name... modify the format.
        m_pThreadList[nX].m_pUser->get_SignInName( &(bszName.m_str) );

        wszFmtPos = wcsstr ( bszName.m_str, L"#" );
        if ( wszFmtPos != NULL )
        {
            *wszFmtPos = 0;
            wszFmtPos++;
            wsprintfW( wszBuf, L"%s%i%s", bszName.m_str, nX, wszFmtPos );
        }
        else
        {
            wsprintfW(wszBuf, L"%s", bszName.m_str );
        }

        m_pThreadList[nX].m_pUser->put_SignInName( CComBSTR( wszBuf ) );

        CmdCreateThread( nOperation, m_pThreadList[nX] );
    }
    LeaveCriticalSection( &m_csThreadList );

}

//---------------------------------------------------------
//  ExecuteAll:  Starts all the set up threads.
//---------------------------------------------------------
void CCmdMgr::ExecuteAll()
{
    // set the start event to active.
    SetEvent( m_hStartEvent );
}

//---------------------------------------------------------
//  TerminateThreadList:  Treminates all threads in the 
//     list.
//---------------------------------------------------------
void CCmdMgr::TerminateThreadList()
{
    int nX = 0;

    // go through the list of processes and clean up.
    for ( nX = 0; nX < m_nNumOfProcesses ; nX++ )
    {
        // stop the thread.  Wait 5 secs
        WaitForSingleObject( m_pThreadList[nX].m_hThread, 5000 );
        
        CloseHandle( m_pThreadList[nX].m_hThread );    
        m_pThreadList[nX].m_dwThreadId = -1;

        // delete the node from the list.
        m_pThreadList[nX].m_bIsDone = TRUE;
        
       
    }

    // wipe the list.
    delete[] m_pThreadList;

}

//---------------------------------------------------------
//  CmdCreateThread:  Creates a thread with proper params
//---------------------------------------------------------
BOOL CCmdMgr::CmdCreateThread( int nOperation, CmdThread &obj)
{
    // create a pointer for the MgrId
    ThreadContainer *pTC = (ThreadContainer*)malloc(sizeof(ThreadContainer));

    if ( pTC == NULL )
    {
        return FALSE;
    }
    
    pTC->m_nId = obj.m_dwMgrId;
    pTC->m_pThis = this;
    pTC->m_pUser = obj.m_pUser;
    pTC->m_nOperation = nOperation;

    // create the thread.
    if ( (obj.m_hThread = CreateThread( NULL, NULL, WorkerThread, pTC, 0, &obj.m_dwThreadId ) ) == NULL )
    {
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------
//  WorkerThread:  The main processing thread of workers
//---------------------------------------------------------
DWORD WINAPI CCmdMgr::WorkerThread( LPVOID pItem )
{
    ((ThreadContainer*)pItem)->m_pThis->WorkerThreadInternal( 
                            ((ThreadContainer*)pItem)->m_nId,
                            ((ThreadContainer*)pItem)->m_nOperation,
                            ((ThreadContainer*)pItem)->m_pUser
                            );

    // clean up thread stuff.
    ((ThreadContainer*)pItem)->m_pThis->SignalWorkerDone(((ThreadContainer*)pItem)->m_nId );
    ((ThreadContainer*)pItem)->m_pUser->Release();
    ((ThreadContainer*)pItem)->m_pThis = NULL;
    free(pItem);

    return 0;
}

//---------------------------------------------------------
//  WorkerThreadInternal:  Actions of worker thread.
//---------------------------------------------------------
void CCmdMgr::WorkerThreadInternal(int nId, int nOperation, IUser *pUser)
{
    USES_CONVERSION;

    // wait for the go signal.  ONLY 5 mins
    WaitForSingleObject( m_hStartEvent, 300000 );

    CallCmd( nId, nOperation, pUser );
}

//---------------------------------------------------------
//  SignalWorkerDone:  Tells object that worker is complete.
//---------------------------------------------------------
void CCmdMgr::SignalWorkerDone(int nId)
{
    _ASSERT( ( nId >= 0 ) & (nId < m_nNumOfProcesses ) );
    _ASSERT( m_hWnd > 0 );

    EnterCriticalSection( &m_csThreadList );
    if ( m_pThreadList != NULL )
    {
        m_pThreadList[nId].m_bIsDone = TRUE;
        m_pThreadList[nId].m_pUser = NULL;
    }
    LeaveCriticalSection( &m_csThreadList );

    PostMessage( m_hWnd, THREAD_COMPLETE_MSG, nId, NULL );
}

//---------------------------------------------------------
//  CopyUser: Copies user data from one to the other.
//---------------------------------------------------------
void CCmdMgr::CopyUser(IUser *pFrom, IUser *pTo)
{
    CComBSTR bszHolder;

    // TODO:  (lohab) Since I know that I'm only setting certain values... 
    //     I've only added those values...   MORE VALUES SHOULD BE ADDED
    //     FOR COMPLETE access.

    // signin name
    pFrom->get_SignInName( &(bszHolder.m_str) );
    pTo->put_SignInName( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // password
    pFrom->get_Password( &(bszHolder.m_str) );
    pTo->put_Password( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // SecretQuestion
    pFrom->get_SecretQuestion( &(bszHolder.m_str) );
    pTo->put_SecretQuestion( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // SecretAnswer
    pFrom->get_SecretAnswer( &(bszHolder.m_str) );
    pTo->put_SecretAnswer( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // Country
    pFrom->get_Country( &(bszHolder.m_str) );
    pTo->put_Country( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // postal code
    pFrom->get_PostalCode( &(bszHolder.m_str) );
    pTo->put_PostalCode( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // region
    pFrom->get_Region( &(bszHolder.m_str) );
    pTo->put_Region( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // birthday
    pFrom->get_Birthday( &(bszHolder.m_str) );
    pTo->put_Birthday( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // Xbox credential name
    pFrom->get_XCred_Name( &(bszHolder.m_str) );
    pTo->put_XCred_Name( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

    // XBox password name
    pFrom->get_XCred_Password( &(bszHolder.m_str) );
    pTo->put_XCred_Password( bszHolder.m_str );
    SysFreeString( bszHolder.Detach() );

}


//---------------------------------------------------------
//  AssociatedRequest: Returns request associated with a 
//      number.
//---------------------------------------------------------
CString CCmdMgr::AssociatedRequest( int nRequestIdx )
{
    CString strResult;

    switch( nRequestIdx )
    {
    case 0:
        {
            strResult = CString("NameSpaceSignupAltCredRequest");
        }
        break;
    case 1:
        {
            strResult = CString("NameSpaceSignupRequest");
        }
        break;
    case 2:
        {
            strResult = CString("NameSpaceAddAltCredRequest");
        }
        break;
    case 3:
        {
            strResult = CString("NameSpaceResetPasswordAltCredRequest");
        }
        break;
    case 4:
        {
            strResult = CString("NameSpaceResetPassword");
        }
        break;
    case 5:
        {
            strResult = CString("NameSpaceChangeNameRequest");
        }
        break;
    case 6:
        {
            strResult = CString("NameSpaceDeleteAltCredRequest");
        }
        break;
    case 7:
        {
            strResult = CString("NameSpaceRemoveMemberRequest");
        }
        break;
    case 8:
        {
            strResult = CString("NameSpaceReserve");
        }
        break;
    case 9:
        {
            strResult = CString("NameSpaceReleaseRequest");
        }
        break;
    default:
        break;
    }

    return strResult;
}

BOOL CCmdMgr::IsDone()
{
    m_nNumCompleted++;

    if ( m_nNumCompleted == m_nNumOfProcesses )
        return TRUE;

//    ASSERT( m_nNumCompleted > m_nNumOfProcesses );
    return FALSE;

}

BOOL CCmdMgr::CallCmd( int nId, int nAction, IUser* pUser)
{
    USES_CONVERSION;
    HRESULT hr;
    CComBSTR bszResult;
    BOOL bRes = TRUE;
    char *szMsg = new char[128];

    switch(nAction)
    {
    case 0:
        {
            hr = m_pDAdmin->NameSpaceSignUpAltCredRequest( pUser, &(bszResult.m_str) );
        }
        break;
    case 1:
        {
            hr = m_pDAdmin->NameSpaceSignUpRequest( pUser, &(bszResult.m_str) );
        }
        break;
    case 2:
        {
            hr = m_pDAdmin->NameSpaceAddAltCredRequest( pUser, &(bszResult.m_str) );
        }
        break;
    case 3:
        {
            CComBSTR bszName;
            CComBSTR bszPassword;

            hr = pUser->get_SignInName( &(bszName.m_str) );
            if ( FAILED(hr) )
            {
                break;
            }
            hr = pUser->get_Password( &(bszPassword.m_str) );
            if ( FAILED(hr) )
            {
                break;
            }

            hr = m_pDAdmin->NameSpaceResetPasswordAltCredRequest( bszName, bszPassword, &(bszResult.m_str) );
        }
        break;
    case 4:
        {
            CComBSTR bszName;
            CComBSTR bszPassword;

            hr = pUser->get_SignInName( &(bszName.m_str) );
            if ( FAILED(hr) )
            {
                break;
            }
            hr = pUser->get_Password( &(bszPassword.m_str) );
            if ( FAILED(hr) )
            {
                break;
            }

            hr = m_pDAdmin->NameSpaceResetPassword( bszName, bszPassword, &(bszResult.m_str) );

        }
        break;
    case 5:
        {
            CComBSTR bszOldName;
            CComBSTR bszNewName;

            hr = pUser->get_SignInName( &(bszOldName.m_str) );
            if ( FAILED(hr) )
            {
                break;
            }
            // NOTE:(lohab) ok I cheated... use the password to hold the name for in this case.
            hr = pUser->get_Password( &(bszNewName.m_str) );
            if ( FAILED(hr) )
            {
                break;
            }

            hr = m_pDAdmin->NameSpaceChangeNameRequest( CComBSTR("Console"), bszOldName, bszNewName, &(bszResult.m_str) );

            
        }
        break;
    case 6:
        {            
            CComBSTR bszName;

            hr = pUser->get_SignInName( &(bszName.m_str) );
            if ( FAILED(hr) )
            {
                break;
            }

            hr = m_pDAdmin->NameSpaceDeleteAltCredRequest( bszName, &(bszResult.m_str) );

        }
        break;
    case 7:
        {
            hr = m_pDAdmin->NameSpaceRemoveMemberRequest( pUser, &(bszResult.m_str) );            
        }
        break;
    default:
        break;
    }	

    if ( FAILED(hr) )
    {
        sprintf( szMsg, 
                 "Thread %i failed %s with hr = 0x%X \r\nResponse:  %s\r\n\r\n", 
                 nId, 
                 (AssociatedRequest(nAction)).GetBuffer(0),
                 hr,
                 W2A( bszResult.m_str )
               );

        bRes = FALSE;
    } 
    else
    {
        sprintf( szMsg, 
                 "Thread %i succeeded with %s\r\n", 
                 nId, 
                 (AssociatedRequest(nAction)).GetBuffer(0)
               );        
    }

    // post an output message.
    PostMessage( m_hWnd, OUTPUT_ERR_MSG, NULL, (LPARAM)szMsg );
    
    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\DelAdminTester.h ===
// DelAdminTester.h : main header file for the DELADMINTESTER application
//

#if !defined(AFX_DELADMINTESTER_H__CF7158F3_C8D2_4D1D_80E3_6F73AB5C67E1__INCLUDED_)
#define AFX_DELADMINTESTER_H__CF7158F3_C8D2_4D1D_80E3_6F73AB5C67E1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDelAdminTesterApp:
// See DelAdminTester.cpp for the implementation of this class
//

class CDelAdminTesterApp : public CWinApp
{
public:
	CDelAdminTesterApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDelAdminTesterApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDelAdminTesterApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DELADMINTESTER_H__CF7158F3_C8D2_4D1D_80E3_6F73AB5C67E1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\DAProperties.h ===
#if !defined(AFX_DAPROPERTIES_H__0E67CE59_AC8E_4A1D_B9CE_702616306A4E__INCLUDED_)
#define AFX_DAPROPERTIES_H__0E67CE59_AC8E_4A1D_B9CE_702616306A4E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DAProperties.h : header file
//
#include "DelAdmin.h"

/////////////////////////////////////////////////////////////////////////////
// CDAProperties dialog

class CDAProperties : public CDialog
{
// Construction
public:
	CDAProperties(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDAProperties)
	enum { IDD = IDD_DA_PROPERTIES };
   	CString	m_strAdminPassword;
	CString	m_strAdminTicket;
	BOOL	m_bUseAdminTicket;
	CString	m_strAdminUsername;
	CString	m_strATURL;
	CString	m_strNS;
	CString	m_strEncryptedNS;
	CString	m_strPassportURL;
	long	m_lSiteId;
   	long	m_lThreadInterval;
	CString	m_strClientInfo;
	CString	m_strVersion;
	//}}AFX_DATA

	void SetDAObj( IDAdmin *pAdmin );
   	HRESULT SetDataToDA();
	HRESULT GetDataFromDA();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDAProperties)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Implementation
protected:


	// Generated message map functions
	//{{AFX_MSG(CDAProperties)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnAdminMore();
	afx_msg void OnEncrypt();
	afx_msg void OnGetNewTicket();
	afx_msg void OnRefresh();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    IDAdmin *m_pDAdmin;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DAPROPERTIES_H__0E67CE59_AC8E_4A1D_B9CE_702616306A4E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\DelAdminTesterDlg.h ===
//---------------------------------------------------------
// DelAdminTesterDlg.h : header file
//
//	Date: 11/5/01
//	Modified:  lohab  -- Creation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------

#if !defined(AFX_DELADMINTESTERDLG_H__41045893_5A35_4BAF_A313_4C822FB41C06__INCLUDED_)
#define AFX_DELADMINTESTERDLG_H__41045893_5A35_4BAF_A313_4C822FB41C06__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//---------------------------------------------------------
// INCLUDES
//---------------------------------------------------------
#include "DelAdmin.h"

//---------------------------------------------------------
// DEFINES
//---------------------------------------------------------
#define  OUTPUT_ERR_MSG                     9001
#define  THREAD_COMPLETE_MSG                9002

//---------------------------------------------------------
// PRE-DECLARATIONS
//---------------------------------------------------------
class CCmdMgr;
class CPassportUser;

//---------------------------------------------------------
// CDelAdminTesterDlg dialog

class CDelAdminTesterDlg : public CDialog
{
// Construction
public:
	CDelAdminTesterDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CDelAdminTesterDlg)
	enum { IDD = IDD_DELADMINTESTER_DIALOG };
	CComboBox	m_ctrlCallList;
	CEdit	m_ctrlResults;
	CString	m_strCmdUsername;
	CString	m_strCmdPassword;
	CString	m_strStaticCmdPassword;
	CString	m_strStaticCmdUsername;
	int		m_nProcesses;
	CString	m_strResult;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDelAdminTesterDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdateDlgOnList( int nAction );
	void OutputResult( CString strOut );
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CDelAdminTesterDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnExeCommand();
	afx_msg void OnDeltaposSpin1(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	afx_msg void OnDaProperties();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeCallList();
	afx_msg void OnPuParams();
	afx_msg void OnClear();
	//}}AFX_MSG
    afx_msg LRESULT OutputMessage(WPARAM, LPARAM);
    afx_msg LRESULT ThreadCompleteMessage(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

private:
	CPassportUser* m_pPUDlg;
	CCmdMgr* m_pCmdMgr;
    IDAdmin *m_pDAdmin;
    BOOL    m_bUseAdminTicket;

    CRITICAL_SECTION    m_csDAdmin;        // the critical section for the DelAdmin object.

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DELADMINTESTERDLG_H__41045893_5A35_4BAF_A313_4C822FB41C06__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\passport.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sat Mar 24 11:18:07 2001
 */
/* Compiler settings for passport.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __passport_h__
#define __passport_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPassportTicket_FWD_DEFINED__
#define __IPassportTicket_FWD_DEFINED__
typedef interface IPassportTicket IPassportTicket;
#endif 	/* __IPassportTicket_FWD_DEFINED__ */


#ifndef __IPassportProfile_FWD_DEFINED__
#define __IPassportProfile_FWD_DEFINED__
typedef interface IPassportProfile IPassportProfile;
#endif 	/* __IPassportProfile_FWD_DEFINED__ */


#ifndef __IPassportManager_FWD_DEFINED__
#define __IPassportManager_FWD_DEFINED__
typedef interface IPassportManager IPassportManager;
#endif 	/* __IPassportManager_FWD_DEFINED__ */


#ifndef __IPassportManager2_FWD_DEFINED__
#define __IPassportManager2_FWD_DEFINED__
typedef interface IPassportManager2 IPassportManager2;
#endif 	/* __IPassportManager2_FWD_DEFINED__ */


#ifndef __IPassportCrypt_FWD_DEFINED__
#define __IPassportCrypt_FWD_DEFINED__
typedef interface IPassportCrypt IPassportCrypt;
#endif 	/* __IPassportCrypt_FWD_DEFINED__ */


#ifndef __IPassportAdmin_FWD_DEFINED__
#define __IPassportAdmin_FWD_DEFINED__
typedef interface IPassportAdmin IPassportAdmin;
#endif 	/* __IPassportAdmin_FWD_DEFINED__ */


#ifndef __IPassportAdminEx_FWD_DEFINED__
#define __IPassportAdminEx_FWD_DEFINED__
typedef interface IPassportAdminEx IPassportAdminEx;
#endif 	/* __IPassportAdminEx_FWD_DEFINED__ */


#ifndef __IPassportFastAuth_FWD_DEFINED__
#define __IPassportFastAuth_FWD_DEFINED__
typedef interface IPassportFastAuth IPassportFastAuth;
#endif 	/* __IPassportFastAuth_FWD_DEFINED__ */


#ifndef __IPassportFastAuth2_FWD_DEFINED__
#define __IPassportFastAuth2_FWD_DEFINED__
typedef interface IPassportFastAuth2 IPassportFastAuth2;
#endif 	/* __IPassportFastAuth2_FWD_DEFINED__ */


#ifndef __IPassportFactory_FWD_DEFINED__
#define __IPassportFactory_FWD_DEFINED__
typedef interface IPassportFactory IPassportFactory;
#endif 	/* __IPassportFactory_FWD_DEFINED__ */


#ifndef __Manager_FWD_DEFINED__
#define __Manager_FWD_DEFINED__

#ifdef __cplusplus
typedef class Manager Manager;
#else
typedef struct Manager Manager;
#endif /* __cplusplus */

#endif 	/* __Manager_FWD_DEFINED__ */


#ifndef __Ticket_FWD_DEFINED__
#define __Ticket_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ticket Ticket;
#else
typedef struct Ticket Ticket;
#endif /* __cplusplus */

#endif 	/* __Ticket_FWD_DEFINED__ */


#ifndef __Profile_FWD_DEFINED__
#define __Profile_FWD_DEFINED__

#ifdef __cplusplus
typedef class Profile Profile;
#else
typedef struct Profile Profile;
#endif /* __cplusplus */

#endif 	/* __Profile_FWD_DEFINED__ */


#ifndef __Crypt_FWD_DEFINED__
#define __Crypt_FWD_DEFINED__

#ifdef __cplusplus
typedef class Crypt Crypt;
#else
typedef struct Crypt Crypt;
#endif /* __cplusplus */

#endif 	/* __Crypt_FWD_DEFINED__ */


#ifndef __Admin_FWD_DEFINED__
#define __Admin_FWD_DEFINED__

#ifdef __cplusplus
typedef class Admin Admin;
#else
typedef struct Admin Admin;
#endif /* __cplusplus */

#endif 	/* __Admin_FWD_DEFINED__ */


#ifndef __FastAuth_FWD_DEFINED__
#define __FastAuth_FWD_DEFINED__

#ifdef __cplusplus
typedef class FastAuth FastAuth;
#else
typedef struct FastAuth FastAuth;
#endif /* __cplusplus */

#endif 	/* __FastAuth_FWD_DEFINED__ */


#ifndef __PassportFactory_FWD_DEFINED__
#define __PassportFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class PassportFactory PassportFactory;
#else
typedef struct PassportFactory PassportFactory;
#endif /* __cplusplus */

#endif 	/* __PassportFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_passport_0000 */
/* [local] */ 

//  Size definitions
#define	PASSPORT_COOKIES_MAXLEN	( 512 )

#define	PASSPORT_COOKIES_BUFSIZE	( PASSPORT_COOKIES_MAXLEN + 1 )

#define	PASSPORT_EMAIL_MAXLEN	( 64 + 1 + 64 )

#define	PASSPORT_EMAIL_BUFSIZE	( PASSPORT_EMAIL_MAXLEN + 1 )

#define	PASSPORT_NICKNAME_MAXLEN	( 30 )

#define	PASSPORT_NICKNAME_BUFSIZE	( PASSPORT_NICKNAME_MAXLEN + 1 )

#define	MSPP_PROF_MEMBER_NAME	( "membername" )

#define	MSPP_PROF_HI_UID	( "memberidhigh" )

#define	MSPP_PROF_LO_UID	( "memberidlow" )

#define	MSPP_PROF_VERSION	( "profileVersion" )

#define	MSPP_PROF_COUNTRY	( "country" )

#define	MSPP_PROF_POSTALCODE	( "postalCode" )

#define	MSPP_PROF_REGION	( "region" )

#define	MSPP_PROF_CITY	( "city" )

#define	MSPP_PROF_LANGPREF	( "lang_preference" )

#define	MSPP_PROF_BDAYPREC	( "bday_precision" )

#define	MSPP_PROF_BDATE	( "birthdate" )

#define	MSPP_PROF_GENDER	( "gender" )

#define	MSPP_PROF_PREF_EMAIL	( "preferredEmail" )

#define	MSPP_PROF_NICKNAME	( "nickname" )

#define	MSPP_PROF_ACCESS	( "accessibility" )

#define	MSPP_PROF_WALLET	( "wallet" )

#define	MSPP_PROF_DIRECTORY	( "directory" )

#define	MSPP_PROF_MSNIA	( "inetaccess" )

#define	MSPP_PROF_FLAGS	( "flags" )



extern RPC_IF_HANDLE __MIDL_itf_passport_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_passport_0000_v0_0_s_ifspec;

#ifndef __IPassportTicket_INTERFACE_DEFINED__
#define __IPassportTicket_INTERFACE_DEFINED__

/* interface IPassportTicket */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportTicket;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF1-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportTicket : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_unencryptedTicket( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_unencryptedTicket( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsAuthenticated( 
            /* [in] */ ULONG TimeWindow,
            /* [in] */ VARIANT_BOOL ForceLogin,
            /* [optional][in] */ VARIANT SecureCheck,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketAge( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeSinceSignIn( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberId( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberIdLow( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberIdHigh( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasSavedPassword( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignInServer( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketTime( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignInTime( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoSecureCheck( 
            /* [in] */ BSTR bstrSec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportTicketVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportTicket __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportTicket __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportTicket __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportTicket __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportTicket __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportTicket __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportTicket __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unencryptedTicket )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_unencryptedTicket )( 
            IPassportTicket __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsAuthenticated )( 
            IPassportTicket __RPC_FAR * This,
            /* [in] */ ULONG TimeWindow,
            /* [in] */ VARIANT_BOOL ForceLogin,
            /* [optional][in] */ VARIANT SecureCheck,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TicketAge )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TimeSinceSignIn )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MemberId )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MemberIdLow )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MemberIdHigh )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasSavedPassword )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SignInServer )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TicketTime )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SignInTime )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Error )( 
            IPassportTicket __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoSecureCheck )( 
            IPassportTicket __RPC_FAR * This,
            /* [in] */ BSTR bstrSec);
        
        END_INTERFACE
    } IPassportTicketVtbl;

    interface IPassportTicket
    {
        CONST_VTBL struct IPassportTicketVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportTicket_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportTicket_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportTicket_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportTicket_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportTicket_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportTicket_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportTicket_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportTicket_get_unencryptedTicket(This,pVal)	\
    (This)->lpVtbl -> get_unencryptedTicket(This,pVal)

#define IPassportTicket_put_unencryptedTicket(This,newVal)	\
    (This)->lpVtbl -> put_unencryptedTicket(This,newVal)

#define IPassportTicket_get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureCheck,pVal)	\
    (This)->lpVtbl -> get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureCheck,pVal)

#define IPassportTicket_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportTicket_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportTicket_get_MemberId(This,pVal)	\
    (This)->lpVtbl -> get_MemberId(This,pVal)

#define IPassportTicket_get_MemberIdLow(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdLow(This,pVal)

#define IPassportTicket_get_MemberIdHigh(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdHigh(This,pVal)

#define IPassportTicket_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportTicket_get_SignInServer(This,pVal)	\
    (This)->lpVtbl -> get_SignInServer(This,pVal)

#define IPassportTicket_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportTicket_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportTicket_get_Error(This,pVal)	\
    (This)->lpVtbl -> get_Error(This,pVal)

#define IPassportTicket_DoSecureCheck(This,bstrSec)	\
    (This)->lpVtbl -> DoSecureCheck(This,bstrSec)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_unencryptedTicket_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_unencryptedTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportTicket_put_unencryptedTicket_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportTicket_put_unencryptedTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_IsAuthenticated_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [in] */ ULONG TimeWindow,
    /* [in] */ VARIANT_BOOL ForceLogin,
    /* [optional][in] */ VARIANT SecureCheck,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TicketAge_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_TicketAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TimeSinceSignIn_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_TimeSinceSignIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberId_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_MemberId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberIdLow_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_MemberIdLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberIdHigh_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_MemberIdHigh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_HasSavedPassword_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_HasSavedPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_SignInServer_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_SignInServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TicketTime_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_TicketTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_SignInTime_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_SignInTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_Error_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IPassportTicket_get_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket_DoSecureCheck_Proxy( 
    IPassportTicket __RPC_FAR * This,
    /* [in] */ BSTR bstrSec);


void __RPC_STUB IPassportTicket_DoSecureCheck_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportTicket_INTERFACE_DEFINED__ */


#ifndef __IPassportProfile_INTERFACE_DEFINED__
#define __IPassportProfile_INTERFACE_DEFINED__

/* interface IPassportProfile */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF3-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportProfile : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attribute( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ByIndex( 
            /* [in] */ int index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ByIndex( 
            /* [in] */ int index,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SchemaName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SchemaName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_unencryptedProfile( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_unencryptedProfile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_updateString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportProfile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportProfile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportProfile __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attribute )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attribute )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ByIndex )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ByIndex )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsValid )( 
            IPassportProfile __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SchemaName )( 
            IPassportProfile __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SchemaName )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unencryptedProfile )( 
            IPassportProfile __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_unencryptedProfile )( 
            IPassportProfile __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_updateString )( 
            IPassportProfile __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IPassportProfileVtbl;

    interface IPassportProfile
    {
        CONST_VTBL struct IPassportProfileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportProfile_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportProfile_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportProfile_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportProfile_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportProfile_get_Attribute(This,name,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,name,pVal)

#define IPassportProfile_put_Attribute(This,name,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,name,newVal)

#define IPassportProfile_get_ByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ByIndex(This,index,pVal)

#define IPassportProfile_put_ByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ByIndex(This,index,newVal)

#define IPassportProfile_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportProfile_get_SchemaName(This,pVal)	\
    (This)->lpVtbl -> get_SchemaName(This,pVal)

#define IPassportProfile_put_SchemaName(This,newVal)	\
    (This)->lpVtbl -> put_SchemaName(This,newVal)

#define IPassportProfile_get_unencryptedProfile(This,pVal)	\
    (This)->lpVtbl -> get_unencryptedProfile(This,pVal)

#define IPassportProfile_put_unencryptedProfile(This,newVal)	\
    (This)->lpVtbl -> put_unencryptedProfile(This,newVal)

#define IPassportProfile_get_updateString(This,pVal)	\
    (This)->lpVtbl -> get_updateString(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_Attribute_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IPassportProfile_get_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_Attribute_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportProfile_put_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_ByIndex_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [in] */ int index,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IPassportProfile_get_ByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_ByIndex_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [in] */ int index,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportProfile_put_ByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_IsValid_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportProfile_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_SchemaName_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportProfile_get_SchemaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_SchemaName_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportProfile_put_SchemaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_unencryptedProfile_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportProfile_get_unencryptedProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_unencryptedProfile_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportProfile_put_unencryptedProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_updateString_Proxy( 
    IPassportProfile __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportProfile_get_updateString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportProfile_INTERFACE_DEFINED__ */


#ifndef __IPassportManager_INTERFACE_DEFINED__
#define __IPassportManager_INTERFACE_DEFINED__

/* interface IPassportManager */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BEF-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportManager : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown __RPC_FAR *piUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStartPageECB( 
            /* [in] */ BYTE __RPC_FAR *pECB,
            /* [out][in] */ DWORD __RPC_FAR *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE _Ticket( 
            /* [out] */ IPassportTicket __RPC_FAR *__RPC_FAR *piTicket) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE _Profile( 
            /* [out] */ IPassportProfile __RPC_FAR *__RPC_FAR *piProfile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pAuthVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsAuthenticated( 
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT CheckSecure,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HasProfile( 
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasTicket( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FromNetworkServer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HasFlag( 
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketAge( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeSinceSignIn( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDomainAttribute( 
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR __RPC_FAR *pAttrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DomainFromMemberName( 
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR __RPC_FAR *pDomainName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProfileByIndex( 
            /* [in] */ int index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProfileByIndex( 
            /* [in] */ int index,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPageManual( 
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPProfCCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT __RPC_FAR *pSetCookieArray) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasSavedPassword( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Commit( 
            /* [retval][out] */ BSTR __RPC_FAR *pNewProfileCookieHeader) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Profile( 
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_TicketTime( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_SignInTime( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Domains( 
            /* [retval][out] */ VARIANT __RPC_FAR *pArrayVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ long __RPC_FAR *pErrorVal) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE OnStartPageFilter( 
            /* [in] */ BYTE __RPC_FAR *pPFC,
            /* [out][in] */ DWORD __RPC_FAR *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPageASP( 
            /* [in] */ IDispatch __RPC_FAR *pdispRequest,
            /* [in] */ IDispatch __RPC_FAR *pdispResponse) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE GetServerInfo( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HaveConsent( 
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveConsent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportManager __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPage )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndPage )( 
            IPassportManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPageECB )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pECB,
            /* [out][in] */ DWORD __RPC_FAR *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_Ticket )( 
            IPassportManager __RPC_FAR * This,
            /* [out] */ IPassportTicket __RPC_FAR *__RPC_FAR *piTicket);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_Profile )( 
            IPassportManager __RPC_FAR * This,
            /* [out] */ IPassportProfile __RPC_FAR *__RPC_FAR *piProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AuthURL )( 
            IPassportManager __RPC_FAR * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAuthenticated )( 
            IPassportManager __RPC_FAR * This,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT CheckSecure,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogoTag )( 
            IPassportManager __RPC_FAR * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HasProfile )( 
            IPassportManager __RPC_FAR * This,
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasTicket )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FromNetworkServer )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HasFlag )( 
            IPassportManager __RPC_FAR * This,
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TicketAge )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TimeSinceSignIn )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDomainAttribute )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR __RPC_FAR *pAttrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DomainFromMemberName )( 
            IPassportManager __RPC_FAR * This,
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR __RPC_FAR *pDomainName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProfileByIndex )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProfileByIndex )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPageManual )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPProfCCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT __RPC_FAR *pSetCookieArray);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasSavedPassword )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pNewProfileCookieHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Profile )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Profile )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TicketTime )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SignInTime )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Domains )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pArrayVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Error )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pErrorVal);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPageFilter )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pPFC,
            /* [out][in] */ DWORD __RPC_FAR *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPageASP )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pdispRequest,
            /* [in] */ IDispatch __RPC_FAR *pdispResponse);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            IPassportManager __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HaveConsent )( 
            IPassportManager __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveConsent);
        
        END_INTERFACE
    } IPassportManagerVtbl;

    interface IPassportManager
    {
        CONST_VTBL struct IPassportManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportManager_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportManager_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define IPassportManager_OnStartPageECB(This,pECB,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageECB(This,pECB,pBufSize,pCookieHeader)

#define IPassportManager__Ticket(This,piTicket)	\
    (This)->lpVtbl -> _Ticket(This,piTicket)

#define IPassportManager__Profile(This,piProfile)	\
    (This)->lpVtbl -> _Profile(This,piProfile)

#define IPassportManager_AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,bUseSecureAuth,pAuthVal)	\
    (This)->lpVtbl -> AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,bUseSecureAuth,pAuthVal)

#define IPassportManager_IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)	\
    (This)->lpVtbl -> IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)

#define IPassportManager_LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,bUseSecureAuth,pVal)	\
    (This)->lpVtbl -> LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,bUseSecureAuth,pVal)

#define IPassportManager_HasProfile(This,ProfileName,pVal)	\
    (This)->lpVtbl -> HasProfile(This,ProfileName,pVal)

#define IPassportManager_get_HasTicket(This,pVal)	\
    (This)->lpVtbl -> get_HasTicket(This,pVal)

#define IPassportManager_get_FromNetworkServer(This,pVal)	\
    (This)->lpVtbl -> get_FromNetworkServer(This,pVal)

#define IPassportManager_HasFlag(This,flagMask,pVal)	\
    (This)->lpVtbl -> HasFlag(This,flagMask,pVal)

#define IPassportManager_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportManager_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportManager_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IPassportManager_DomainFromMemberName(This,memberName,pDomainName)	\
    (This)->lpVtbl -> DomainFromMemberName(This,memberName,pDomainName)

#define IPassportManager_get_ProfileByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ProfileByIndex(This,index,pVal)

#define IPassportManager_put_ProfileByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ProfileByIndex(This,index,newVal)

#define IPassportManager_OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPProfCCookie,vMSPSecCookie,pSetCookieArray)	\
    (This)->lpVtbl -> OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPProfCCookie,vMSPSecCookie,pSetCookieArray)

#define IPassportManager_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportManager_Commit(This,pNewProfileCookieHeader)	\
    (This)->lpVtbl -> Commit(This,pNewProfileCookieHeader)

#define IPassportManager_get_Profile(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Profile(This,attributeName,pVal)

#define IPassportManager_put_Profile(This,attributeName,newVal)	\
    (This)->lpVtbl -> put_Profile(This,attributeName,newVal)

#define IPassportManager_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportManager_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportManager_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IPassportManager_get_Error(This,pErrorVal)	\
    (This)->lpVtbl -> get_Error(This,pErrorVal)

#define IPassportManager_OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)

#define IPassportManager_OnStartPageASP(This,pdispRequest,pdispResponse)	\
    (This)->lpVtbl -> OnStartPageASP(This,pdispRequest,pdispResponse)

#define IPassportManager_GetServerInfo(This,pbstrOut)	\
    (This)->lpVtbl -> GetServerInfo(This,pbstrOut)

#define IPassportManager_HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)	\
    (This)->lpVtbl -> HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPage_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piUnk);


void __RPC_STUB IPassportManager_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPassportManager_OnEndPage_Proxy( 
    IPassportManager __RPC_FAR * This);


void __RPC_STUB IPassportManager_OnEndPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageECB_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pECB,
    /* [out][in] */ DWORD __RPC_FAR *pBufSize,
    /* [size_is][out] */ LPSTR pCookieHeader);


void __RPC_STUB IPassportManager_OnStartPageECB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager__Ticket_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [out] */ IPassportTicket __RPC_FAR *__RPC_FAR *piTicket);


void __RPC_STUB IPassportManager__Ticket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager__Profile_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [out] */ IPassportProfile __RPC_FAR *__RPC_FAR *piProfile);


void __RPC_STUB IPassportManager__Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_AuthURL_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT bUseSecureAuth,
    /* [retval][out] */ BSTR __RPC_FAR *pAuthVal);


void __RPC_STUB IPassportManager_AuthURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_IsAuthenticated_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT CheckSecure,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_LogoTag_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT bSecure,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT bUseSecureAuth,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_LogoTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HasProfile_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [optional][in] */ VARIANT ProfileName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_HasProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_HasTicket_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_HasTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_FromNetworkServer_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_FromNetworkServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HasFlag_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [optional][in] */ VARIANT flagMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_HasFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TicketAge_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_TicketAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TimeSinceSignIn_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_TimeSinceSignIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_GetDomainAttribute_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ BSTR attributeName,
    /* [optional][in] */ VARIANT lcid,
    /* [optional][in] */ VARIANT domain,
    /* [retval][out] */ BSTR __RPC_FAR *pAttrVal);


void __RPC_STUB IPassportManager_GetDomainAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_DomainFromMemberName_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [optional][in] */ VARIANT memberName,
    /* [retval][out] */ BSTR __RPC_FAR *pDomainName);


void __RPC_STUB IPassportManager_DomainFromMemberName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_ProfileByIndex_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ int index,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_ProfileByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportManager_put_ProfileByIndex_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ int index,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportManager_put_ProfileByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageManual_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ BSTR queryStringT,
    /* [in] */ BSTR queryStringP,
    /* [in] */ BSTR MSPAuthCookie,
    /* [in] */ BSTR MSPProfCookie,
    /* [in] */ BSTR MSPProfCCookie,
    /* [optional][in] */ VARIANT vMSPSecCookie,
    /* [retval][out] */ VARIANT __RPC_FAR *pSetCookieArray);


void __RPC_STUB IPassportManager_OnStartPageManual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_HasSavedPassword_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_HasSavedPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_Commit_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pNewProfileCookieHeader);


void __RPC_STUB IPassportManager_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Profile_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ BSTR attributeName,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportManager_put_Profile_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ BSTR attributeName,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportManager_put_Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TicketTime_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_TicketTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_SignInTime_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IPassportManager_get_SignInTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Domains_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pArrayVal);


void __RPC_STUB IPassportManager_get_Domains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Error_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pErrorVal);


void __RPC_STUB IPassportManager_get_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageFilter_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pPFC,
    /* [out][in] */ DWORD __RPC_FAR *pBufSize,
    /* [size_is][out] */ LPSTR pCookieHeader);


void __RPC_STUB IPassportManager_OnStartPageFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageASP_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pdispRequest,
    /* [in] */ IDispatch __RPC_FAR *pdispResponse);


void __RPC_STUB IPassportManager_OnStartPageASP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_GetServerInfo_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOut);


void __RPC_STUB IPassportManager_GetServerInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HaveConsent_Proxy( 
    IPassportManager __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bNeedFullConsent,
    /* [in] */ VARIANT_BOOL bNeedBirthdate,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveConsent);


void __RPC_STUB IPassportManager_HaveConsent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportManager_INTERFACE_DEFINED__ */


#ifndef __IPassportManager2_INTERFACE_DEFINED__
#define __IPassportManager2_INTERFACE_DEFINED__

/* interface IPassportManager2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ca48d6a-0b51-4f7a-9475-b0a8b59c3999")
    IPassportManager2 : public IPassportManager
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoginUser( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT UseSecureAuth,
            /* [optional][in] */ VARIANT ExtraParams) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL2( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pAuthVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag2( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportManager2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportManager2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPage )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndPage )( 
            IPassportManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPageECB )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pECB,
            /* [out][in] */ DWORD __RPC_FAR *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_Ticket )( 
            IPassportManager2 __RPC_FAR * This,
            /* [out] */ IPassportTicket __RPC_FAR *__RPC_FAR *piTicket);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_Profile )( 
            IPassportManager2 __RPC_FAR * This,
            /* [out] */ IPassportProfile __RPC_FAR *__RPC_FAR *piProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AuthURL )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAuthenticated )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT CheckSecure,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogoTag )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HasProfile )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasTicket )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FromNetworkServer )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HasFlag )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TicketAge )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TimeSinceSignIn )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDomainAttribute )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR __RPC_FAR *pAttrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DomainFromMemberName )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR __RPC_FAR *pDomainName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProfileByIndex )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProfileByIndex )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPageManual )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPProfCCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT __RPC_FAR *pSetCookieArray);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasSavedPassword )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pNewProfileCookieHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Profile )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Profile )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TicketTime )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SignInTime )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Domains )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pArrayVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Error )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pErrorVal);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPageFilter )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pPFC,
            /* [out][in] */ DWORD __RPC_FAR *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPageASP )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pdispRequest,
            /* [in] */ IDispatch __RPC_FAR *pdispResponse);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            IPassportManager2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HaveConsent )( 
            IPassportManager2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveConsent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoginUser )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT UseSecureAuth,
            /* [optional][in] */ VARIANT ExtraParams);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AuthURL2 )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogoTag2 )( 
            IPassportManager2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IPassportManager2Vtbl;

    interface IPassportManager2
    {
        CONST_VTBL struct IPassportManager2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportManager2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportManager2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportManager2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportManager2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportManager2_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportManager2_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define IPassportManager2_OnStartPageECB(This,pECB,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageECB(This,pECB,pBufSize,pCookieHeader)

#define IPassportManager2__Ticket(This,piTicket)	\
    (This)->lpVtbl -> _Ticket(This,piTicket)

#define IPassportManager2__Profile(This,piProfile)	\
    (This)->lpVtbl -> _Profile(This,piProfile)

#define IPassportManager2_AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,bUseSecureAuth,pAuthVal)	\
    (This)->lpVtbl -> AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,bUseSecureAuth,pAuthVal)

#define IPassportManager2_IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)	\
    (This)->lpVtbl -> IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)

#define IPassportManager2_LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,bUseSecureAuth,pVal)	\
    (This)->lpVtbl -> LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,bUseSecureAuth,pVal)

#define IPassportManager2_HasProfile(This,ProfileName,pVal)	\
    (This)->lpVtbl -> HasProfile(This,ProfileName,pVal)

#define IPassportManager2_get_HasTicket(This,pVal)	\
    (This)->lpVtbl -> get_HasTicket(This,pVal)

#define IPassportManager2_get_FromNetworkServer(This,pVal)	\
    (This)->lpVtbl -> get_FromNetworkServer(This,pVal)

#define IPassportManager2_HasFlag(This,flagMask,pVal)	\
    (This)->lpVtbl -> HasFlag(This,flagMask,pVal)

#define IPassportManager2_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportManager2_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportManager2_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IPassportManager2_DomainFromMemberName(This,memberName,pDomainName)	\
    (This)->lpVtbl -> DomainFromMemberName(This,memberName,pDomainName)

#define IPassportManager2_get_ProfileByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ProfileByIndex(This,index,pVal)

#define IPassportManager2_put_ProfileByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ProfileByIndex(This,index,newVal)

#define IPassportManager2_OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPProfCCookie,vMSPSecCookie,pSetCookieArray)	\
    (This)->lpVtbl -> OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPProfCCookie,vMSPSecCookie,pSetCookieArray)

#define IPassportManager2_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportManager2_Commit(This,pNewProfileCookieHeader)	\
    (This)->lpVtbl -> Commit(This,pNewProfileCookieHeader)

#define IPassportManager2_get_Profile(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Profile(This,attributeName,pVal)

#define IPassportManager2_put_Profile(This,attributeName,newVal)	\
    (This)->lpVtbl -> put_Profile(This,attributeName,newVal)

#define IPassportManager2_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportManager2_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportManager2_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IPassportManager2_get_Error(This,pErrorVal)	\
    (This)->lpVtbl -> get_Error(This,pErrorVal)

#define IPassportManager2_OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)

#define IPassportManager2_OnStartPageASP(This,pdispRequest,pdispResponse)	\
    (This)->lpVtbl -> OnStartPageASP(This,pdispRequest,pdispResponse)

#define IPassportManager2_GetServerInfo(This,pbstrOut)	\
    (This)->lpVtbl -> GetServerInfo(This,pbstrOut)

#define IPassportManager2_HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)	\
    (This)->lpVtbl -> HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)


#define IPassportManager2_LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,UseSecureAuth,ExtraParams)	\
    (This)->lpVtbl -> LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,UseSecureAuth,ExtraParams)

#define IPassportManager2_AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,bUseSecureAuth,pAuthVal)	\
    (This)->lpVtbl -> AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,bUseSecureAuth,pAuthVal)

#define IPassportManager2_LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,bUseSecureAuth,pVal)	\
    (This)->lpVtbl -> LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,bUseSecureAuth,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_LoginUser_Proxy( 
    IPassportManager2 __RPC_FAR * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandTemplate,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT UseSecureAuth,
    /* [optional][in] */ VARIANT ExtraParams);


void __RPC_STUB IPassportManager2_LoginUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_AuthURL2_Proxy( 
    IPassportManager2 __RPC_FAR * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT bUseSecureAuth,
    /* [retval][out] */ BSTR __RPC_FAR *pAuthVal);


void __RPC_STUB IPassportManager2_AuthURL2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_LogoTag2_Proxy( 
    IPassportManager2 __RPC_FAR * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT bSecure,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT bUseSecureAuth,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportManager2_LogoTag2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportManager2_INTERFACE_DEFINED__ */


#ifndef __IPassportCrypt_INTERFACE_DEFINED__
#define __IPassportCrypt_INTERFACE_DEFINED__

/* interface IPassportCrypt */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportCrypt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF9-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportCrypt : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt( 
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR __RPC_FAR *pEncrypted) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt( 
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR __RPC_FAR *pUnencrypted) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_keyVersion( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_keyVersion( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_keyMaterial( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Compress( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decompress( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOut) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_site( 
            /* [in] */ BSTR bstrSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown __RPC_FAR *piUnk) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_host( 
            /* [in] */ BSTR bstrHostName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportCryptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportCrypt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportCrypt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportCrypt __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Encrypt )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR __RPC_FAR *pEncrypted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Decrypt )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR __RPC_FAR *pUnencrypted);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_keyVersion )( 
            IPassportCrypt __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_keyVersion )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsValid )( 
            IPassportCrypt __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_keyMaterial )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Compress )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Decompress )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOut);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_site )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ BSTR bstrSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPage )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piUnk);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_host )( 
            IPassportCrypt __RPC_FAR * This,
            /* [in] */ BSTR bstrHostName);
        
        END_INTERFACE
    } IPassportCryptVtbl;

    interface IPassportCrypt
    {
        CONST_VTBL struct IPassportCryptVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportCrypt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportCrypt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportCrypt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportCrypt_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportCrypt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportCrypt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportCrypt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportCrypt_Encrypt(This,rawData,pEncrypted)	\
    (This)->lpVtbl -> Encrypt(This,rawData,pEncrypted)

#define IPassportCrypt_Decrypt(This,rawData,pUnencrypted)	\
    (This)->lpVtbl -> Decrypt(This,rawData,pUnencrypted)

#define IPassportCrypt_get_keyVersion(This,pVal)	\
    (This)->lpVtbl -> get_keyVersion(This,pVal)

#define IPassportCrypt_put_keyVersion(This,newVal)	\
    (This)->lpVtbl -> put_keyVersion(This,newVal)

#define IPassportCrypt_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportCrypt_put_keyMaterial(This,newVal)	\
    (This)->lpVtbl -> put_keyMaterial(This,newVal)

#define IPassportCrypt_Compress(This,bstrIn,pbstrOut)	\
    (This)->lpVtbl -> Compress(This,bstrIn,pbstrOut)

#define IPassportCrypt_Decompress(This,bstrIn,pbstrOut)	\
    (This)->lpVtbl -> Decompress(This,bstrIn,pbstrOut)

#define IPassportCrypt_put_site(This,bstrSiteName)	\
    (This)->lpVtbl -> put_site(This,bstrSiteName)

#define IPassportCrypt_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportCrypt_put_host(This,bstrHostName)	\
    (This)->lpVtbl -> put_host(This,bstrHostName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Encrypt_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ BSTR rawData,
    /* [retval][out] */ BSTR __RPC_FAR *pEncrypted);


void __RPC_STUB IPassportCrypt_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Decrypt_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ BSTR rawData,
    /* [retval][out] */ BSTR __RPC_FAR *pUnencrypted);


void __RPC_STUB IPassportCrypt_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_get_keyVersion_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IPassportCrypt_get_keyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_keyVersion_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IPassportCrypt_put_keyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_get_IsValid_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportCrypt_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_keyMaterial_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportCrypt_put_keyMaterial_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Compress_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOut);


void __RPC_STUB IPassportCrypt_Compress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Decompress_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOut);


void __RPC_STUB IPassportCrypt_Decompress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_site_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ BSTR bstrSiteName);


void __RPC_STUB IPassportCrypt_put_site_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_OnStartPage_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piUnk);


void __RPC_STUB IPassportCrypt_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_host_Proxy( 
    IPassportCrypt __RPC_FAR * This,
    /* [in] */ BSTR bstrHostName);


void __RPC_STUB IPassportCrypt_put_host_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportCrypt_INTERFACE_DEFINED__ */


#ifndef __IPassportAdmin_INTERFACE_DEFINED__
#define __IPassportAdmin_INTERFACE_DEFINED__

/* interface IPassportAdmin */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0082CF5-AFF5-11D2-95E3-00C04F8E7A70")
    IPassportAdmin : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addKey( 
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteKey( 
            /* [in] */ int version) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setKeyTime( 
            /* [in] */ int version,
            /* [in] */ int fromNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_currentKeyVersion( 
            /* [retval][out] */ int __RPC_FAR *pCur) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_currentKeyVersion( 
            /* [in] */ int cur) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportAdmin __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportAdmin __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportAdmin __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsValid )( 
            IPassportAdmin __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorDescription )( 
            IPassportAdmin __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addKey )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteKey )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ int version);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setKeyTime )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ int version,
            /* [in] */ int fromNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentKeyVersion )( 
            IPassportAdmin __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pCur);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentKeyVersion )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ int cur);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IPassportAdmin __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess);
        
        END_INTERFACE
    } IPassportAdminVtbl;

    interface IPassportAdmin
    {
        CONST_VTBL struct IPassportAdminVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportAdmin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportAdmin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportAdmin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportAdmin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportAdmin_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportAdmin_get_ErrorDescription(This,pVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pVal)

#define IPassportAdmin_addKey(This,keyMaterial,version,expires,ok)	\
    (This)->lpVtbl -> addKey(This,keyMaterial,version,expires,ok)

#define IPassportAdmin_deleteKey(This,version)	\
    (This)->lpVtbl -> deleteKey(This,version)

#define IPassportAdmin_setKeyTime(This,version,fromNow)	\
    (This)->lpVtbl -> setKeyTime(This,version,fromNow)

#define IPassportAdmin_get_currentKeyVersion(This,pCur)	\
    (This)->lpVtbl -> get_currentKeyVersion(This,pCur)

#define IPassportAdmin_put_currentKeyVersion(This,cur)	\
    (This)->lpVtbl -> put_currentKeyVersion(This,cur)

#define IPassportAdmin_Refresh(This,bWait,pbSuccess)	\
    (This)->lpVtbl -> Refresh(This,bWait,pbSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_IsValid_Proxy( 
    IPassportAdmin __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportAdmin_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_ErrorDescription_Proxy( 
    IPassportAdmin __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportAdmin_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_addKey_Proxy( 
    IPassportAdmin __RPC_FAR * This,
    /* [in] */ BSTR keyMaterial,
    /* [in] */ int version,
    /* [in] */ long expires,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok);


void __RPC_STUB IPassportAdmin_addKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_deleteKey_Proxy( 
    IPassportAdmin __RPC_FAR * This,
    /* [in] */ int version);


void __RPC_STUB IPassportAdmin_deleteKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_setKeyTime_Proxy( 
    IPassportAdmin __RPC_FAR * This,
    /* [in] */ int version,
    /* [in] */ int fromNow);


void __RPC_STUB IPassportAdmin_setKeyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_currentKeyVersion_Proxy( 
    IPassportAdmin __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pCur);


void __RPC_STUB IPassportAdmin_get_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_put_currentKeyVersion_Proxy( 
    IPassportAdmin __RPC_FAR * This,
    /* [in] */ int cur);


void __RPC_STUB IPassportAdmin_put_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_Refresh_Proxy( 
    IPassportAdmin __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bWait,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess);


void __RPC_STUB IPassportAdmin_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportAdmin_INTERFACE_DEFINED__ */


#ifndef __IPassportAdminEx_INTERFACE_DEFINED__
#define __IPassportAdminEx_INTERFACE_DEFINED__

/* interface IPassportAdminEx */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportAdminEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("876181A0-3B05-11d3-9ACD-0080C712D19C")
    IPassportAdminEx : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addKey( 
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteKey( 
            /* [in] */ int version) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setKeyTime( 
            /* [in] */ int version,
            /* [in] */ int fromNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_currentKeyVersion( 
            /* [retval][out] */ int __RPC_FAR *pCur) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_currentKeyVersion( 
            /* [in] */ int cur) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addKeyEx( 
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int nVersion,
            /* [in] */ long expires,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteKeyEx( 
            /* [in] */ int nVersion,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setKeyTimeEx( 
            /* [in] */ int nVersion,
            /* [in] */ int fromNow,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getCurrentKeyVersionEx( 
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ int __RPC_FAR *pCur) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE putCurrentKeyVersionEx( 
            /* [in] */ int cur,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setNexusPassword( 
            /* [in] */ BSTR bstrPwd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportAdminExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportAdminEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportAdminEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsValid )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorDescription )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addKey )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteKey )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ int version);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setKeyTime )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ int version,
            /* [in] */ int fromNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentKeyVersion )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pCur);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentKeyVersion )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ int cur);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addKeyEx )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int nVersion,
            /* [in] */ long expires,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteKeyEx )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ int nVersion,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setKeyTimeEx )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ int nVersion,
            /* [in] */ int fromNow,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getCurrentKeyVersionEx )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ int __RPC_FAR *pCur);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putCurrentKeyVersionEx )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ int cur,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setNexusPassword )( 
            IPassportAdminEx __RPC_FAR * This,
            /* [in] */ BSTR bstrPwd);
        
        END_INTERFACE
    } IPassportAdminExVtbl;

    interface IPassportAdminEx
    {
        CONST_VTBL struct IPassportAdminExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportAdminEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportAdminEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportAdminEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportAdminEx_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportAdminEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportAdminEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportAdminEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportAdminEx_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportAdminEx_get_ErrorDescription(This,pVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pVal)

#define IPassportAdminEx_addKey(This,keyMaterial,version,expires,ok)	\
    (This)->lpVtbl -> addKey(This,keyMaterial,version,expires,ok)

#define IPassportAdminEx_deleteKey(This,version)	\
    (This)->lpVtbl -> deleteKey(This,version)

#define IPassportAdminEx_setKeyTime(This,version,fromNow)	\
    (This)->lpVtbl -> setKeyTime(This,version,fromNow)

#define IPassportAdminEx_get_currentKeyVersion(This,pCur)	\
    (This)->lpVtbl -> get_currentKeyVersion(This,pCur)

#define IPassportAdminEx_put_currentKeyVersion(This,cur)	\
    (This)->lpVtbl -> put_currentKeyVersion(This,cur)

#define IPassportAdminEx_Refresh(This,bWait,pbSuccess)	\
    (This)->lpVtbl -> Refresh(This,bWait,pbSuccess)

#define IPassportAdminEx_addKeyEx(This,keyMaterial,nVersion,expires,vSiteName,ok)	\
    (This)->lpVtbl -> addKeyEx(This,keyMaterial,nVersion,expires,vSiteName,ok)

#define IPassportAdminEx_deleteKeyEx(This,nVersion,vSiteName)	\
    (This)->lpVtbl -> deleteKeyEx(This,nVersion,vSiteName)

#define IPassportAdminEx_setKeyTimeEx(This,nVersion,fromNow,vSiteName)	\
    (This)->lpVtbl -> setKeyTimeEx(This,nVersion,fromNow,vSiteName)

#define IPassportAdminEx_getCurrentKeyVersionEx(This,vSiteName,pCur)	\
    (This)->lpVtbl -> getCurrentKeyVersionEx(This,vSiteName,pCur)

#define IPassportAdminEx_putCurrentKeyVersionEx(This,cur,vSiteName)	\
    (This)->lpVtbl -> putCurrentKeyVersionEx(This,cur,vSiteName)

#define IPassportAdminEx_setNexusPassword(This,bstrPwd)	\
    (This)->lpVtbl -> setNexusPassword(This,bstrPwd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_get_IsValid_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IPassportAdminEx_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_get_ErrorDescription_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IPassportAdminEx_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_addKey_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ BSTR keyMaterial,
    /* [in] */ int version,
    /* [in] */ long expires,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok);


void __RPC_STUB IPassportAdminEx_addKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_deleteKey_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ int version);


void __RPC_STUB IPassportAdminEx_deleteKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_setKeyTime_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ int version,
    /* [in] */ int fromNow);


void __RPC_STUB IPassportAdminEx_setKeyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_get_currentKeyVersion_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pCur);


void __RPC_STUB IPassportAdminEx_get_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_put_currentKeyVersion_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ int cur);


void __RPC_STUB IPassportAdminEx_put_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_Refresh_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bWait,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess);


void __RPC_STUB IPassportAdminEx_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_addKeyEx_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ BSTR keyMaterial,
    /* [in] */ int nVersion,
    /* [in] */ long expires,
    /* [optional][in] */ VARIANT vSiteName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *ok);


void __RPC_STUB IPassportAdminEx_addKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_deleteKeyEx_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ int nVersion,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_deleteKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_setKeyTimeEx_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ int nVersion,
    /* [in] */ int fromNow,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_setKeyTimeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_getCurrentKeyVersionEx_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [optional][in] */ VARIANT vSiteName,
    /* [retval][out] */ int __RPC_FAR *pCur);


void __RPC_STUB IPassportAdminEx_getCurrentKeyVersionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_putCurrentKeyVersionEx_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ int cur,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_putCurrentKeyVersionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_setNexusPassword_Proxy( 
    IPassportAdminEx __RPC_FAR * This,
    /* [in] */ BSTR bstrPwd);


void __RPC_STUB IPassportAdminEx_setNexusPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportAdminEx_INTERFACE_DEFINED__ */


#ifndef __IPassportFastAuth_INTERFACE_DEFINED__
#define __IPassportFastAuth_INTERFACE_DEFINED__

/* interface IPassportFastAuth */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFastAuth;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74EB2513-E239-11D2-95E9-00C04F8E7A70")
    IPassportFastAuth : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsAuthenticated( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbIsAuthenticated) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLogoTag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL( 
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAuthURL) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTicketAndProfilePFC( 
            /* [in] */ BYTE __RPC_FAR *pbPFC,
            /* [in] */ BYTE __RPC_FAR *pbPPH,
            /* [out] */ BSTR __RPC_FAR *pbstrTicket,
            /* [out] */ BSTR __RPC_FAR *pbstrProfile,
            /* [out] */ BSTR __RPC_FAR *pbstrSecure,
            /* [out] */ BSTR __RPC_FAR *pbstrSiteName) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTicketAndProfileECB( 
            /* [in] */ BYTE __RPC_FAR *pbECB,
            /* [out] */ BSTR __RPC_FAR *pbstrTicket,
            /* [out] */ BSTR __RPC_FAR *pbstrProfile,
            /* [out] */ BSTR __RPC_FAR *pbstrSecure,
            /* [out] */ BSTR __RPC_FAR *pbstrSiteName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFastAuthVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportFastAuth __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportFastAuth __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAuthenticated )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbIsAuthenticated);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogoTag )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AuthURL )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAuthURL);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTicketAndProfilePFC )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbPFC,
            /* [in] */ BYTE __RPC_FAR *pbPPH,
            /* [out] */ BSTR __RPC_FAR *pbstrTicket,
            /* [out] */ BSTR __RPC_FAR *pbstrProfile,
            /* [out] */ BSTR __RPC_FAR *pbstrSecure,
            /* [out] */ BSTR __RPC_FAR *pbstrSiteName);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTicketAndProfileECB )( 
            IPassportFastAuth __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbECB,
            /* [out] */ BSTR __RPC_FAR *pbstrTicket,
            /* [out] */ BSTR __RPC_FAR *pbstrProfile,
            /* [out] */ BSTR __RPC_FAR *pbstrSecure,
            /* [out] */ BSTR __RPC_FAR *pbstrSiteName);
        
        END_INTERFACE
    } IPassportFastAuthVtbl;

    interface IPassportFastAuth
    {
        CONST_VTBL struct IPassportFastAuthVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFastAuth_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFastAuth_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFastAuth_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFastAuth_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFastAuth_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFastAuth_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFastAuth_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFastAuth_IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)	\
    (This)->lpVtbl -> IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)

#define IPassportFastAuth_LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrLogoTag)

#define IPassportFastAuth_AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrAuthURL)

#define IPassportFastAuth_GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#define IPassportFastAuth_GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_IsAuthenticated_Proxy( 
    IPassportFastAuth __RPC_FAR * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT vDoSecureCheck,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbIsAuthenticated);


void __RPC_STUB IPassportFastAuth_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_LogoTag_Proxy( 
    IPassportFastAuth __RPC_FAR * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT bUseSecureAuth,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrLogoTag);


void __RPC_STUB IPassportFastAuth_LogoTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_AuthURL_Proxy( 
    IPassportFastAuth __RPC_FAR * This,
    /* [optional][in] */ VARIANT vTicket,
    /* [optional][in] */ VARIANT vProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vReserved1,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT bUseSecureAuth,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrAuthURL);


void __RPC_STUB IPassportFastAuth_AuthURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_GetTicketAndProfilePFC_Proxy( 
    IPassportFastAuth __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pbPFC,
    /* [in] */ BYTE __RPC_FAR *pbPPH,
    /* [out] */ BSTR __RPC_FAR *pbstrTicket,
    /* [out] */ BSTR __RPC_FAR *pbstrProfile,
    /* [out] */ BSTR __RPC_FAR *pbstrSecure,
    /* [out] */ BSTR __RPC_FAR *pbstrSiteName);


void __RPC_STUB IPassportFastAuth_GetTicketAndProfilePFC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_GetTicketAndProfileECB_Proxy( 
    IPassportFastAuth __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pbECB,
    /* [out] */ BSTR __RPC_FAR *pbstrTicket,
    /* [out] */ BSTR __RPC_FAR *pbstrProfile,
    /* [out] */ BSTR __RPC_FAR *pbstrSecure,
    /* [out] */ BSTR __RPC_FAR *pbstrSiteName);


void __RPC_STUB IPassportFastAuth_GetTicketAndProfileECB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFastAuth_INTERFACE_DEFINED__ */


#ifndef __IPassportFastAuth2_INTERFACE_DEFINED__
#define __IPassportFastAuth2_INTERFACE_DEFINED__

/* interface IPassportFastAuth2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFastAuth2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb41a7d8-3739-4468-bdf1-e5b4b2eaeb4b")
    IPassportFastAuth2 : public IPassportFastAuth
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag2( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLogoTag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL2( 
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAuthURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFastAuth2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportFastAuth2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportFastAuth2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAuthenticated )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbIsAuthenticated);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogoTag )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AuthURL )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAuthURL);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTicketAndProfilePFC )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbPFC,
            /* [in] */ BYTE __RPC_FAR *pbPPH,
            /* [out] */ BSTR __RPC_FAR *pbstrTicket,
            /* [out] */ BSTR __RPC_FAR *pbstrProfile,
            /* [out] */ BSTR __RPC_FAR *pbstrSecure,
            /* [out] */ BSTR __RPC_FAR *pbstrSiteName);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTicketAndProfileECB )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbECB,
            /* [out] */ BSTR __RPC_FAR *pbstrTicket,
            /* [out] */ BSTR __RPC_FAR *pbstrProfile,
            /* [out] */ BSTR __RPC_FAR *pbstrSecure,
            /* [out] */ BSTR __RPC_FAR *pbstrSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogoTag2 )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AuthURL2 )( 
            IPassportFastAuth2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAuthURL);
        
        END_INTERFACE
    } IPassportFastAuth2Vtbl;

    interface IPassportFastAuth2
    {
        CONST_VTBL struct IPassportFastAuth2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFastAuth2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFastAuth2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFastAuth2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFastAuth2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFastAuth2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFastAuth2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFastAuth2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFastAuth2_IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)	\
    (This)->lpVtbl -> IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)

#define IPassportFastAuth2_LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrLogoTag)

#define IPassportFastAuth2_AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrAuthURL)

#define IPassportFastAuth2_GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#define IPassportFastAuth2_GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)


#define IPassportFastAuth2_LogoTag2(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag2(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrLogoTag)

#define IPassportFastAuth2_AuthURL2(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL2(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,bUseSecureAuth,pbstrAuthURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth2_LogoTag2_Proxy( 
    IPassportFastAuth2 __RPC_FAR * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT bUseSecureAuth,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrLogoTag);


void __RPC_STUB IPassportFastAuth2_LogoTag2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth2_AuthURL2_Proxy( 
    IPassportFastAuth2 __RPC_FAR * This,
    /* [optional][in] */ VARIANT vTicket,
    /* [optional][in] */ VARIANT vProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vReserved1,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT bUseSecureAuth,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrAuthURL);


void __RPC_STUB IPassportFastAuth2_AuthURL2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFastAuth2_INTERFACE_DEFINED__ */


#ifndef __IPassportFactory_INTERFACE_DEFINED__
#define __IPassportFactory_INTERFACE_DEFINED__

/* interface IPassportFactory */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5602E147-27F6-11d3-94DD-00C04F72DC08")
    IPassportFactory : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePassportManager( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispPassportManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPassportFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPassportFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPassportFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPassportFactory __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPassportFactory __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPassportFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPassportFactory __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePassportManager )( 
            IPassportFactory __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispPassportManager);
        
        END_INTERFACE
    } IPassportFactoryVtbl;

    interface IPassportFactory
    {
        CONST_VTBL struct IPassportFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFactory_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFactory_CreatePassportManager(This,ppdispPassportManager)	\
    (This)->lpVtbl -> CreatePassportManager(This,ppdispPassportManager)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPassportFactory_CreatePassportManager_Proxy( 
    IPassportFactory __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispPassportManager);


void __RPC_STUB IPassportFactory_CreatePassportManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFactory_INTERFACE_DEFINED__ */



#ifndef __PASSPORTLib_LIBRARY_DEFINED__
#define __PASSPORTLib_LIBRARY_DEFINED__

/* library PASSPORTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PASSPORTLib;

EXTERN_C const CLSID CLSID_Manager;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF0-A5C8-11D2-95DF-00C04F8E7A70")
Manager;
#endif

EXTERN_C const CLSID CLSID_Ticket;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF2-A5C8-11D2-95DF-00C04F8E7A70")
Ticket;
#endif

EXTERN_C const CLSID CLSID_Profile;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF4-A5C8-11D2-95DF-00C04F8E7A70")
Profile;
#endif

EXTERN_C const CLSID CLSID_Crypt;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BFA-A5C8-11D2-95DF-00C04F8E7A70")
Crypt;
#endif

EXTERN_C const CLSID CLSID_Admin;

#ifdef __cplusplus

class DECLSPEC_UUID("A0082CF6-AFF5-11D2-95E3-00C04F8E7A70")
Admin;
#endif

EXTERN_C const CLSID CLSID_FastAuth;

#ifdef __cplusplus

class DECLSPEC_UUID("5602E146-27F6-11d3-94DD-00C04F72DC08")
FastAuth;
#endif

EXTERN_C const CLSID CLSID_PassportFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("74EB2514-E239-11D2-95E9-00C04F8E7A70")
PassportFactory;
#endif
#endif /* __PASSPORTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\PassportUser.h ===
#if !defined(AFX_PASSPORTUSER_H__A7562903_B9B3_44AB_B68D_E56629B0114D__INCLUDED_)
#define AFX_PASSPORTUSER_H__A7562903_B9B3_44AB_B68D_E56629B0114D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PassportUser.h : header file
//

#include <deladmin.h>
/////////////////////////////////////////////////////////////////////////////
// CPassportUser dialog

class CPassportUser : public CDialog
{
// Construction
public:
	CPassportUser(CWnd* pParent = NULL);   // standard constructor

  	BOOL PopulateUser( IUser* pUser );

// Dialog Data
	//{{AFX_DATA(CPassportUser)
	enum { IDD = IDD_PASSPORT_USER };
	CString	m_strCountry;
	CString	m_strName;
	CString	m_strPassword;
	CString	m_strPostalCode;
	CString	m_strRegion;
	CString	m_strSecretAnswer;
	CString	m_strSecretQuestion;
	CString	m_strXName;
	CString	m_strXPassword;
	CString	m_strBirthday;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPassportUser)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPassportUser)
	afx_msg void OnPuGenpassword();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PASSPORTUSER_H__A7562903_B9B3_44AB_B68D_E56629B0114D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\DelAdminTesterDlg.cpp ===
//---------------------------------------------------------
// DelAdminTesterDlg.cpp : implementation file
//
//	Date: 11/5/01
//	Modified:  lohab  -- Creation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------

//---------------------------------------------------------
// INCLUDES
//---------------------------------------------------------
#include "stdafx.h"
#include "DelAdminTester.h"
#include "DelAdminTesterDlg.h"
#include "DAProperties.h"
#include "CmdMgr.h"
#include "PassportUser.h"

#include "DelAdmin.h"
#include "DelAdmin_i.c"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//---------------------------------------------------------
// DEFINITIONS
//---------------------------------------------------------
#define CHECK_HR(hr) {if (FAILED(hr)) goto Exit; }

//---------------------------------------------------------
// Constants
//---------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDelAdminTesterDlg dialog

CDelAdminTesterDlg::CDelAdminTesterDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDelAdminTesterDlg::IDD, pParent)
{
    HRESULT hr;

	//{{AFX_DATA_INIT(CDelAdminTesterDlg)
	m_strCmdUsername = _T("larry#");
	m_strCmdPassword = _T("some");
	m_strStaticCmdPassword = _T("Password");
	m_strStaticCmdUsername = _T("Username:");
	m_nProcesses = 1;
	m_strResult = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

     // initialize DA tool.
    hr = CoCreateInstance( CLSID_CDAdmin, 
                                 NULL, 
                                 CLSCTX_ALL, 
                                 IID_IDAdmin, 
                                 (VOID**)&m_pDAdmin ); 

    // failed to get a del admin object.
    ASSERT( !FAILED(hr) );

    // don't start a thread as default for now.
    m_bUseAdminTicket = FALSE;

    InitializeCriticalSection( &m_csDAdmin );
    m_pCmdMgr = NULL;
    m_pPUDlg = NULL;
}

void CDelAdminTesterDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDelAdminTesterDlg)
	DDX_Control(pDX, IDC_CALL_LIST, m_ctrlCallList);
	DDX_Control(pDX, IDC_RESULTS, m_ctrlResults);
	DDX_Text(pDX, IDC_CMD_NAME, m_strCmdUsername);
	DDX_Text(pDX, IDC_CMD_PASS, m_strCmdPassword);
	DDX_Text(pDX, IDC_CMD_PASSWORD, m_strStaticCmdPassword);
	DDX_Text(pDX, IDC_CMD_USERNAME, m_strStaticCmdUsername);
	DDX_Text(pDX, IDC_PROCESSES, m_nProcesses);
	DDV_MinMaxInt(pDX, m_nProcesses, 1, 500);
	DDX_Text(pDX, IDC_RESULTS, m_strResult);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDelAdminTesterDlg, CDialog)
	//{{AFX_MSG_MAP(CDelAdminTesterDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_EXE_COMMAND, OnExeCommand)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN1, OnDeltaposSpin1)
	ON_BN_CLICKED(IDC_DA_PROPERTIES, OnDaProperties)
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_CALL_LIST, OnSelchangeCallList)
	ON_BN_CLICKED(IDC_PU_PARAMS, OnPuParams)
	ON_BN_CLICKED(IDC_CLEAR, OnClear)
	//}}AFX_MSG_MAP
    ON_MESSAGE(OUTPUT_ERR_MSG, OutputMessage )
    ON_MESSAGE(THREAD_COMPLETE_MSG, ThreadCompleteMessage )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDelAdminTesterDlg message handlers

BOOL CDelAdminTesterDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
    HRESULT hr;
    int nX = 0;

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	

    // load in the proper config.
    hr = m_pDAdmin->LoadConfig();
    CHECK_HR(hr);

    // init DelAdmin Configuration here.
    // as a default don't init with thread
    hr = m_pDAdmin->Init( m_bUseAdminTicket );
    CHECK_HR(hr);

    m_pPUDlg = new CPassportUser;

    // build the command list
    for ( nX = 0; nX < NUMBER_OF_CMD_CALLS; nX++ )
    {
        m_ctrlCallList.AddString(CCmdMgr::AssociatedRequest(nX));
    }
    m_ctrlCallList.SetCurSel( 0 );

    UpdateDlgOnList( 0 );
    
    UpdateData(FALSE);
Exit:
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDelAdminTesterDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDelAdminTesterDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDelAdminTesterDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CDelAdminTesterDlg::OnExeCommand() 
{
    HRESULT hr;	
    IUser   *pDAUser = NULL;
    int nOperation = -1;

    UpdateData(TRUE);

    if ( m_pCmdMgr != NULL )
    {
        delete m_pCmdMgr;
    } 

    m_pCmdMgr = new CCmdMgr();

    // create a template user for the executor.
    hr = CoCreateInstance( CLSID_CUser, 
                                    NULL, 
                                    CLSCTX_ALL, 
                                    IID_IUser,
                                    (VOID**)&(pDAUser) );

    if (FAILED(hr))
    {
        OutputResult(CString("CDelAdminTesterDlg::OnExeCommand():  Failed to create template user.\r\n"));
        goto Exit;
    }

    // set up the command manager.
    m_pCmdMgr->SetNumOfProcesses( m_nProcesses );
    m_pCmdMgr->SetDelAdminObj( m_pDAdmin );
    m_pCmdMgr->SetMainWnd( this->m_hWnd );

    // get the selected action
    nOperation = m_ctrlCallList.GetCurSel();

    // set up the user template.
    if ( ! m_pPUDlg->PopulateUser( pDAUser ) )
    {
        OutputResult(CString("CDelAdminTesterDlg::OnExeCommand():  Failed to populate template user.\r\n"));
        ASSERT(0);
        goto Exit;
    }

    switch( nOperation )
    {
    case 2:
        {
            hr = pDAUser->put_UserPUID( CComBSTR( m_strCmdUsername ).m_str );
            if ( FAILED(hr) )
            {
                OutputResult(CString("CDelAdminTesterDlg::OnExeCommand():  Failed to enter a UserPUID for command.\r\n"));
                ASSERT(0);
                goto Exit;
            }
        }
        break;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
        {
            hr = pDAUser->put_SignInName( CComBSTR( m_strCmdUsername ).m_str );
            if ( FAILED(hr) )
            {
                OutputResult(CString("CDelAdminTesterDlg::OnExeCommand():  Failed to enter a data for command.\r\n"));
                ASSERT(0);
                goto Exit;
            }

            hr = pDAUser->put_Password( CComBSTR( m_strCmdPassword ).m_str );
            if ( FAILED(hr) )
            {
                OutputResult(CString("CDelAdminTesterDlg::OnExeCommand():  Failed to enter a data for command.\r\n"));
                ASSERT(0);
                goto Exit;
            }

        }
        break;
    default:
        break;
    }

    // enable the proper buttons.
    GetDlgItem(IDC_EXE_COMMAND)->EnableWindow( FALSE );

    // don't allow delete of the admin till all threads are done
    EnterCriticalSection( &m_csDAdmin );

    // set up the processes
    m_pCmdMgr->SetUpProcesses( nOperation, pDAUser );

	// execute the processes.
    m_pCmdMgr->ExecuteAll();

Exit:
    pDAUser->Release();
}

void CDelAdminTesterDlg::OnDeltaposSpin1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

    // TODO: Add your control notification handler code here
    

	*pResult = 0;
}

void CDelAdminTesterDlg::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

void CDelAdminTesterDlg::OnClear() 
{
    UpdateData(TRUE);
    m_strResult = CString("");
	UpdateData(FALSE);
}

void CDelAdminTesterDlg::OnDaProperties() 
{
    CDAProperties daProp;
    HRESULT hr;

    EnterCriticalSection( &m_csDAdmin );

    _ASSERT(m_pDAdmin );

    // set the deladmin object up.
    daProp.SetDAObj( m_pDAdmin );
    daProp.m_bUseAdminTicket = m_bUseAdminTicket;

    //TODO: modal for now... check the resutls later.
    daProp.DoModal();

    // restart DelAdmin with or without a thread.
    if ( m_bUseAdminTicket != daProp.m_bUseAdminTicket )
    {
        m_bUseAdminTicket = daProp.m_bUseAdminTicket;
        m_pDAdmin->Close();
        m_pDAdmin->Release();
        m_pDAdmin = NULL;

        // initialize DA tool.
        hr = CoCreateInstance( CLSID_CDAdmin, 
                                     NULL, 
                                     CLSCTX_ALL, 
                                     IID_IDAdmin, 
                                     (VOID**)&m_pDAdmin ); 

        // failed to get a del admin object.
        ASSERT( !FAILED(hr) );

        daProp.SetDAObj( m_pDAdmin );
        
        hr = daProp.SetDataToDA();
        ASSERT( !FAILED(hr) );

        m_pDAdmin->Init( m_bUseAdminTicket );

    }

    LeaveCriticalSection( &m_csDAdmin );
}

void CDelAdminTesterDlg::OutputResult(CString strOut)
{
    UpdateData(TRUE);

    // output to the debugger.
    OutputDebugString( strOut );

    // output to the control.
    m_strResult+= strOut;

    UpdateData(FALSE);
}

void CDelAdminTesterDlg::OnDestroy() 
{
	CDialog::OnDestroy();

    if ( m_pPUDlg )
    {
        delete m_pPUDlg;
        m_pPUDlg = NULL;
    }

    if ( m_pCmdMgr )
    {
        delete m_pCmdMgr;
        m_pCmdMgr = NULL;
    }
	
    // make sure to stop all threads first.
    EnterCriticalSection( &m_csDAdmin );

    _ASSERT( m_pDAdmin );
	
    // close the DelAdmin object.
    m_pDAdmin->Close();
    m_pDAdmin->Release();
    m_pDAdmin = NULL;

    LeaveCriticalSection( &m_csDAdmin );

    DeleteCriticalSection( &m_csDAdmin );
}

void CDelAdminTesterDlg::OnSelchangeCallList() 
{
    int nRequest = 0;

    UpdateData(TRUE);

    nRequest = m_ctrlCallList.GetCurSel();

    UpdateDlgOnList( nRequest );
    UpdateData(FALSE);
}

void CDelAdminTesterDlg::OnPuParams() 
{
    m_pPUDlg->DoModal();
}

void CDelAdminTesterDlg::UpdateDlgOnList(int nAction)
{
    switch( nAction )
    {
    case 0:
        {
            GetDlgItem(IDC_CMD_NAME)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_USERNAME)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_PASS)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_PASSWORD)->EnableWindow(FALSE);
            GetDlgItem(IDC_PU_PARAMS)->EnableWindow(TRUE);
        }
        break;
    case 1:
        {
            GetDlgItem(IDC_CMD_NAME)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_USERNAME)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_PASS)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_PASSWORD)->EnableWindow(FALSE);
            GetDlgItem(IDC_PU_PARAMS)->EnableWindow(TRUE);
        }
        break;
    case 2:
        {
            GetDlgItem(IDC_CMD_NAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_USERNAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_PASS)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_PASSWORD)->EnableWindow(FALSE);
            GetDlgItem(IDC_PU_PARAMS)->EnableWindow(TRUE);
            
            m_strStaticCmdUsername = "UserPUID";
            m_strStaticCmdPassword = "";
        }
        break;
    case 3:
    case 4:
        {
            GetDlgItem(IDC_CMD_NAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_USERNAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_PASS)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_PASSWORD)->EnableWindow(TRUE);
            GetDlgItem(IDC_PU_PARAMS)->EnableWindow(FALSE);
            
            m_strStaticCmdUsername = "Username";
            m_strStaticCmdPassword = "New Password";
        }
        break;
    case 5:
        {
            GetDlgItem(IDC_CMD_NAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_USERNAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_PASS)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_PASSWORD)->EnableWindow(TRUE);
            GetDlgItem(IDC_PU_PARAMS)->EnableWindow(FALSE);
            
            m_strStaticCmdUsername = "Old Name";
            m_strStaticCmdPassword = "New Name";
        }
        break;
    case 6:
        {
            
            GetDlgItem(IDC_CMD_NAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_USERNAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_PASS)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_PASSWORD)->EnableWindow(FALSE);
            GetDlgItem(IDC_PU_PARAMS)->EnableWindow(TRUE);
            
            m_strStaticCmdUsername = "XBox Name";
            m_strStaticCmdPassword = "";
        }
        break;
    case 7:
        {            
            GetDlgItem(IDC_CMD_NAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_USERNAME)->EnableWindow(TRUE);
            GetDlgItem(IDC_CMD_PASS)->EnableWindow(FALSE);
            GetDlgItem(IDC_CMD_PASSWORD)->EnableWindow(FALSE);
            GetDlgItem(IDC_PU_PARAMS)->EnableWindow(TRUE);
            
            m_strStaticCmdUsername = "SignIn Name";
            m_strStaticCmdPassword = "";
        }
        break;
    case 8:
        {
            
        }
        break;
    case 9:
        {
        }
        break;
    default:
        break;
    }	


}

//---------------------------------------------------------
// SPECIAL MESSAGE MANAGERS
//---------------------------------------------------------
LRESULT CDelAdminTesterDlg::OutputMessage(WPARAM wParam, LPARAM lParam) 
{
    OutputResult( CString( ((char*)lParam) ) );
//    delete[] (char*)lParam;
    return 0;
}

LRESULT CDelAdminTesterDlg::ThreadCompleteMessage(WPARAM wParam, LPARAM lParam ) 
{
    CString strMsg;
    strMsg.Format( "CmdMgr:  Thread %i is complete.\r\n", (int)wParam );
    OutputResult( strMsg );

    if ( m_pCmdMgr->IsDone() )
    {
        // don't allow delete of the admin till all threads are done
        LeaveCriticalSection( &m_csDAdmin );

        // clean up the cmd mgr.
        delete m_pCmdMgr;
        m_pCmdMgr = NULL;

        // enable the proper buttons.
        GetDlgItem(IDC_EXE_COMMAND)->EnableWindow( TRUE );
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DelAdminTester.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_DELADMINTESTER_DIALOG       102
#define IDR_MAINFRAME                   128
#define IDD_DA_PROPERTIES               129
#define IDD_PASSPORT_USER               130
#define IDC_ADMIN_USERNAME              1000
#define IDC_ADMIN_PASSWORD              1001
#define IDC_ADMIN_MORE                  1002
#define IDC_DA_NAMESPACE                1005
#define IDC_SITEID                      1006
#define IDC_EXE_COMMAND                 1007
#define IDC_ENCRYPTED_NS                1008
#define IDC_ENCRYPT                     1009
#define IDC_RESULTS                     1010
#define IDC_AT_URL                      1011
#define IDC_ADMIN_TICKET                1012
#define IDC_GET_NEW_TICKET              1013
#define IDC_ADMIN_TICKET_THREAD         1014
#define IDC_PASSPORT_URL                1015
#define IDC_CALL_LIST                   1016
#define IDC_PROCESSES                   1017
#define IDC_SPIN1                       1019
#define IDC_CMD_USERNAME                1020
#define IDC_CMD_PASSWORD                1021
#define IDC_CMD_NAME                    1022
#define IDC_CMD_PASS                    1023
#define IDC_AT_INTERVAL                 1024
#define IDC_DA_PROPERTIES               1025
#define IDC_REFRESH                     1026
#define IDC_VERSION                     1027
#define IDC_CLIENTINFO                  1028
#define IDC_PU_NAME                     1029
#define IDC_PU_PASSWORD                 1030
#define IDC_PU_SECRETQUESTION           1031
#define IDC_PU_SECRETANSWER             1032
#define IDC_PU_COUNTRY                  1033
#define IDC_PU_POSTALCODE               1034
#define IDC_PU_REGION                   1035
#define IDC_PU_BIRTHDAY                 1036
#define IDC_PU_XNAME                    1037
#define IDC_PU_XPASSWORD                1038
#define IDC_PU_GENPASSWORD              1039
#define IDC_PU_PARAMS                   1040
#define IDC_CLEAR                       1041

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1042
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DelAdminTester.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\PassportUser.cpp ===
//---------------------------------------------------------
// PassportUser.cpp : implementation file
//
//	Date: 11/5/01
//	Modified:  lohab  -- Creation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------

//---------------------------------------------------------
// INCLUDES
//---------------------------------------------------------

#include "stdafx.h"
#include "DelAdminTester.h"
#include "PassportUser.h"

#include "DelAdmin.h"

#include <Rpcdce.h>
#include <string.h>
#include <atlbase.h>

#include <Wincrypt.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//---------------------------------------------------------
// LOCAL FUNCTIONS
//---------------------------------------------------------
//BOOL GeneratePassword( char *szBuf, int nBufSize );


//---------------------------------------------------------
// CPassportUser dialog
//---------------------------------------------------------

CPassportUser::CPassportUser(CWnd* pParent /*=NULL*/)
	: CDialog(CPassportUser::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPassportUser)
	m_strCountry = _T("US");
	m_strName = _T("lohab.p52@xboxtest.com");
	m_strPassword = _T("showtime");
	m_strPostalCode = _T("98007");
	m_strRegion = _T("35841");
	m_strSecretAnswer = _T("XBOX");
	m_strSecretQuestion = _T("Who's your Daddy?");
	m_strXName = _T("");
	m_strXPassword = _T("xsome");
	m_strBirthday = _T("11/05/2000");
	//}}AFX_DATA_INIT
}


void CPassportUser::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPassportUser)
	DDX_Text(pDX, IDC_PU_COUNTRY, m_strCountry);
	DDX_Text(pDX, IDC_PU_NAME, m_strName);
	DDX_Text(pDX, IDC_PU_PASSWORD, m_strPassword);
	DDX_Text(pDX, IDC_PU_POSTALCODE, m_strPostalCode);
	DDX_Text(pDX, IDC_PU_REGION, m_strRegion);
	DDX_Text(pDX, IDC_PU_SECRETANSWER, m_strSecretAnswer);
	DDX_Text(pDX, IDC_PU_SECRETQUESTION, m_strSecretQuestion);
	DDX_Text(pDX, IDC_PU_XNAME, m_strXName);
	DDX_Text(pDX, IDC_PU_XPASSWORD, m_strXPassword);
	DDX_Text(pDX, IDC_PU_BIRTHDAY, m_strBirthday);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPassportUser, CDialog)
	//{{AFX_MSG_MAP(CPassportUser)
	ON_BN_CLICKED(IDC_PU_GENPASSWORD, OnPuGenpassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//------------------------------------------------------------------
//  GeneratePassword:  generates a valid password for a user.
//
//------------------------------------------------------------------
BOOL GeneratePassword( char *szBuf, int nBufSize )
{
    HCRYPTPROV hCryptProv;
    int i;
    BOOL bRet = TRUE;
  
	_ASSERT( szBuf != NULL );
    //--------------------------------------------------------------------
    // Get a handle to the default PROV_RSA_FULL provider.

    if( !CryptAcquireContext( &hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)) 
    {
        if(!CryptAcquireContext( &hCryptProv,  NULL,  NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) 
        {
            bRet = FALSE;
            goto Exit;
        }
    }

    // Generate random bytes.
    if( !CryptGenRandom( hCryptProv, sizeof(char) *nBufSize,  (BYTE*)szBuf)) 
    {
        bRet = FALSE;
        goto Exit;    
    }

    for ( i = 0; i < nBufSize; i++ )
    {
		int val = ((unsigned int)(szBuf[i]))%32;
        szBuf[i] = (char)(( val )+65);
    }

    if ( !CryptReleaseContext( hCryptProv, NULL ) )
    {
        // memory leak
        bRet = FALSE;
        goto Exit;
    }
    
Exit:
    
    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// CPassportUser message handlers

void CPassportUser::OnPuGenpassword() 
{
	char szBuf[128];
    BOOL bRes = TRUE;

    UpdateData(TRUE);

    bRes = GeneratePassword( szBuf, 128 );
    ASSERT(bRes);
    
    m_strXPassword = CString( szBuf );

    UpdateData(FALSE);
	
}

BOOL CPassportUser::PopulateUser(IUser *pDAUser)
{
    BOOL bRes = TRUE;
    HRESULT hr;

    if ( m_strName.IsEmpty() )
    {
        bRes = FALSE;
        goto Exit;
    }

    hr = pDAUser->put_Password( CComBSTR(m_strPassword).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

    // set the signin name
    hr = pDAUser->put_SignInName( CComBSTR(m_strName).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

    // set the secret question
    hr = pDAUser->put_SecretQuestion( CComBSTR(m_strSecretQuestion).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

    // set the secret answer.
    hr = pDAUser->put_SecretAnswer( CComBSTR(m_strSecretAnswer).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

    // set the country
    hr = pDAUser->put_Country( CComBSTR(m_strCountry).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }


    // set the postal code
    hr = pDAUser->put_PostalCode( CComBSTR(m_strPostalCode).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

    // set the region
    hr = pDAUser->put_Region( CComBSTR(m_strRegion).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

    // set the birthday
    hr = pDAUser->put_Birthday( CComBSTR(m_strBirthday).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

    // set the xbox credential name
    hr = pDAUser->put_XCred_Name( CComBSTR(m_strXName).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

    // set the Xbox credential password
    hr = pDAUser->put_XCred_Password( CComBSTR(m_strXPassword).m_str );
    if ( FAILED(hr) ) 
    {
        bRes = FALSE;
        goto Exit;
    }

Exit:
    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\CheckUser\main.cpp ===
#include "StdAfx.h"

void usage()
{
		wprintf(L"CheckUser <username> <password>\n");
		wprintf(L"  <username> a fully qualified user name (i.e. DOMAIN\\USERNAME).\n");
		wprintf(L"  <password> user\'s password to verify.\n");
}

int __cdecl wmain(int argc, wchar_t *argv[])
{
	if( argc != 3 )
	{
		usage();

		return -1;
	}

	wchar_t *szUser = wcschr(argv[1], L'\\');
	if( !szUser )
	{
		usage();

		return -1;
	}
	*szUser ++ = NULL;
	wchar_t *szDomain = argv[1];
	wchar_t *szPassword = argv[2];

	HANDLE hToken;
	BOOL bSuccess = LogonUser(szUser, szDomain, szPassword, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &hToken);
	DWORD dwErrorCode = GetLastError();
	CloseHandle(hToken);

	if( !bSuccess )
	{
		wprintf(L"Failed with error %d\n", dwErrorCode);
	}
	else
	{
		wprintf(L"Success\n");
	}

	return bSuccess?0:-1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deladmin\Test\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F7839C74_33DE_4C18_A43C_1856775FC934__INCLUDED_)
#define AFX_STDAFX_H__F7839C74_33DE_4C18_A43C_1856775FC934__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <crtdbg.h>

#include <Rpcdce.h>
#include <string.h>
#include <atlbase.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F7839C74_33DE_4C18_A43C_1856775FC934__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\CheckUser\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_checkuser_none_12.4.56.0_none_72ab4756568506d9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=checkuser
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149.manifest
XP_MANIFEST_PATH=manifests\x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149.cat
XP_CATALOG_PATH=manifests\x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149.cat
XP_PAYLOAD_PATH=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=checkuser,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\CheckUser\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_checkuser_none_12.4.56.0_none_72ab4756568506d9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=checkuser
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149.manifest
XP_MANIFEST_PATH=manifests\x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149.cat
XP_CATALOG_PATH=manifests\x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149.cat
XP_PAYLOAD_PATH=x86_checkuser_no-public-key_12.4.56.0_x-ww_05f88149
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=checkuser,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\CheckVersion\Main.cpp ===
// GetFileVersion.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <Winver.h>
#include <stdio.h>
#include <tchar.h>

BOOL ParseVersionInfo(LPTSTR szVersionInfo, WORD *lpFileVersion)
{
	int fileVersion[4];

	int count = _stscanf_s(szVersionInfo, TEXT("%d.%d.%d.%d"), 
		&fileVersion[0], 
		&fileVersion[1],
		&fileVersion[2],
		&fileVersion[3]);

	lpFileVersion[0] = (WORD)fileVersion[0];
	lpFileVersion[1] = (WORD)fileVersion[1];
	lpFileVersion[2] = (WORD)fileVersion[2];
	lpFileVersion[3] = (WORD)fileVersion[3];

	return ( count == 4 );
}

HRESULT GetFileVersion(LPTSTR szFileName, WORD *lpFileVersion)
{
	DWORD dwReserved, dwVersionInfoSize;
	VS_FIXEDFILEINFO *lpFileInfo;
	LPVOID lpBuffer;
	UINT uiLength;

	dwVersionInfoSize = ::GetFileVersionInfoSize(szFileName, &dwReserved);
	if( dwVersionInfoSize == 0 )
	{
		HRESULT hrErrorCode = HRESULT_FROM_WIN32(GetLastError());

		return hrErrorCode;
	}

	lpBuffer = HeapAlloc(GetProcessHeap(), 0, dwVersionInfoSize);
	if( lpBuffer == NULL )
	{
		HRESULT hrErrorCode = HRESULT_FROM_WIN32(GetLastError());

		return hrErrorCode;
	}

	if( !GetFileVersionInfo(szFileName, dwReserved, dwVersionInfoSize, lpBuffer) )
	{
		HRESULT hrErrorCode = HRESULT_FROM_WIN32(GetLastError());
		HeapFree(GetProcessHeap(), 0, lpBuffer);

		return hrErrorCode;
	}

	if( !VerQueryValue( lpBuffer, TEXT("\\"), (LPVOID *)&lpFileInfo, &uiLength) )
	{
		HRESULT hrErrorCode = HRESULT_FROM_WIN32(GetLastError());
		HeapFree(GetProcessHeap(), 0, lpBuffer);

		return hrErrorCode;
	}

	lpFileVersion[0] = HIWORD(lpFileInfo->dwFileVersionMS);
	lpFileVersion[1] = LOWORD(lpFileInfo->dwFileVersionMS);
	lpFileVersion[2] = HIWORD(lpFileInfo->dwFileVersionLS);
	lpFileVersion[3] = LOWORD(lpFileInfo->dwFileVersionLS);

	HeapFree(GetProcessHeap(), 0, lpBuffer);

	return S_OK;
}

int __cdecl _tmain(int argc, _TCHAR* argv[])
{
	WORD fileVersion[4];
	WORD expectedVersion[4];
	int index;

	if( argc != 3 )
	{
		_tprintf(TEXT("%s <FileName> <MinimumVersion>\n"), argv[0]);
		_tprintf(TEXT("  FileName        - Name of the file to check version information for.\n"));
		_tprintf(TEXT("  MinimumVersion  - Minimum acceptable version number.\n"));

		return -1;
	}

	if( !ParseVersionInfo(argv[2], expectedVersion ) )
	{
		_tprintf(TEXT("Expected version was an invalid version number."));

		return -1;
	}
	
	HRESULT hr = GetFileVersion(argv[1], fileVersion);
	if( FAILED(hr) )
	{
		_tprintf(TEXT("Unable to retrieve version information from %s.  The error code is 0x%08X.\n"), 
			argv[1], hr);

		return -1;
	}

	for( index = 0; index < 4 && fileVersion[index] == expectedVersion[index]; index ++)
		;

	if( index == 4 || fileVersion[index] > expectedVersion[index] )
	{
		_tprintf( TEXT("File version %d.%d.%d.%d is greater than or equal to the expected %d.%d.%d.%d.\n"),
			fileVersion[0], fileVersion[1], fileVersion[2], fileVersion[3], 
			expectedVersion[0], expectedVersion[1], expectedVersion[2], expectedVersion[3] );

		return 0;
	}
	
	_tprintf( TEXT("File version %d.%d.%d.%d is lower than the expected %d.%d.%d.%d.  Please install a later version.\n"),
			fileVersion[0], fileVersion[1], fileVersion[2], fileVersion[3], 
			expectedVersion[0], expectedVersion[1], expectedVersion[2], expectedVersion[3] );

	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\CheckUser\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows XP or later.
#define WINVER 0x0501		// Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 6.0 or later.
#define _WIN32_IE 0x0600	// Change this to the appropriate value to target other versions of IE.
#endif

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>



// TODO: reference additional headers your program requires here
#include <tchar.h>
#include <msiquery.h>
#include <msi.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\CheckVersion\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_checkversion_none_12.4.56.0_none_1480038411142cb2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=checkversion
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46.manifest
XP_MANIFEST_PATH=manifests\x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46.cat
XP_CATALOG_PATH=manifests\x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46.cat
XP_PAYLOAD_PATH=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=checkversion,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\CheckVersion\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_checkversion_none_12.4.56.0_none_1480038411142cb2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=checkversion
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46.manifest
XP_MANIFEST_PATH=manifests\x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46.cat
XP_CATALOG_PATH=manifests\x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46.cat
XP_PAYLOAD_PATH=x86_checkversion_no-public-key_12.4.56.0_x-ww_41f9af46
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=checkversion,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\configgenerator\ConfigGenerator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using System.IO;

namespace xonline.tools.configgenerator
{
    public class ConfigGenerator
    {
        public const string OctopusNamespace = "http://schemas.microsoft.com/Octopus/2005/01/Service";

        string _serviceXmlRootDir;

        HashSet<string> _serverRoles;
        HashSet<string> _serviceProperties;
        Dictionary<string, HashSet<string>> _componentProperties;

        HashSet<string> _rolesToRemove;
        string _defaultMachine;
        Dictionary<string, string> _roleServerMap = new Dictionary<string, string>();

        string _configTemplateFile;

        string _outputFile;

        public ConfigGenerator(string outputFile)
        {
            _outputFile = outputFile;
            ClearConfigRoles = false;
        }

        public bool ClearConfigRoles { get; set; }

        public string DeploymentShareLocation { get; set; }

        public string LogsLocation { get; set; }

        public string TopologyName { get; set; }

        public string ReleaseName { get; set; }

        public string DeploymentAccount { get; set; }

        public string ControllerMachine { get; set; }

        public void SetDefaultServer(string serverName)
        {
            _defaultMachine = serverName;
        }

        public void SetConfigTemplate(string configTemplateFile)
        {
            _configTemplateFile = configTemplateFile;
        }

        public void AddServerMap(string role, string server)
        {
            _roleServerMap.Add(role, server);
        }

        public void AddRolesToRemove(HashSet<string> roles)
        {
            _rolesToRemove = roles;
        }

        public void AddServiceXmlSource(string serviceXmlRootDir)
        {
            _serviceXmlRootDir = serviceXmlRootDir;
        }

        public void GenerateConfig()
        {
            XDocument configurationXml = null;

            _serverRoles = new HashSet<string>();
            _serviceProperties = new HashSet<string>();
            _componentProperties = new Dictionary<string, HashSet<string>>();

            // Read from service.xml(s) if specified
            CollectFromServiceXmls();

            // If the target config file already exists, try to use it, if it's not a config file, back it up and replace it
            configurationXml = ReadTargetConfigIfExists(configurationXml);
            
            // If there is a template file, use the template file as base document
            if (!String.IsNullOrEmpty(_configTemplateFile))
            {
                configurationXml = XDocument.Load(_configTemplateFile);
            }
            
            // If we still don't have a configuration file, just create a blank one
            if (configurationXml == null)
            {
                configurationXml = new XDocument();
                configurationXml.AddElement("DeploymentInstance");
            }

            // Root deploymentInstance node
            var deploymentInstance = configurationXml.Element("DeploymentInstance");

            // Set DeploymentInstance attribute values
            SetDeploymentInstanceAttributes(deploymentInstance);

            // If we are suppose to clear the server-role assignments, remove all Server nodes
            if (ClearConfigRoles)
            {
                deploymentInstance.Elements("Server").ToList().ForEach(s => s.Remove());
            }

            // Add server-role assignments based on roles from service.xml
            AddServerElements(deploymentInstance);

            // Remove server-role assignments as specified from RemoveRoles argument
            RemoveRoleAssignment(deploymentInstance);

            Directory.CreateDirectory(Path.GetDirectoryName(_outputFile));

            configurationXml.Save(_outputFile);
        }

        private void CollectFromServiceXmls()
        {
            if (!String.IsNullOrEmpty(_serviceXmlRootDir))
            {
                if (Path.GetExtension(_serviceXmlRootDir) == ".xml" && File.Exists(_serviceXmlRootDir))
                {
                    CollectFromServiceXml(_serviceXmlRootDir);
                }
                else
                {
                    foreach (var serviceXmlFile in Directory.GetFiles(_serviceXmlRootDir, "service.xml", SearchOption.AllDirectories))
                    {
                        CollectFromServiceXml(serviceXmlFile);
                    }
                }
            }
        }

        private void CollectFromServiceXml(string serviceXmlPath)
        {
            var serviceXmlDoc = XDocument.Load(serviceXmlPath);

            CollectRoles(serviceXmlDoc);
            CollectProperties(serviceXmlDoc);
        }

        private void CollectRoles(XDocument serviceXmlDoc)
        {
            var roles = from r in serviceXmlDoc.Descendants()
                        where r.Name.LocalName == "role"
                        select r.Attribute("name").Value;

            _serverRoles.UnionWith(roles);
        }

        private void CollectProperties(XDocument serviceXmlDoc)
        {
            var propertyElements = from p in serviceXmlDoc.Descendants()
                                   where p.Name.LocalName == "property"
                                   select p;


            foreach (var property in propertyElements)
            {
                // Check if it has a property already

                var propertyName = property.Attribute("name").Value;

                if (!String.IsNullOrEmpty(propertyName))
                {
                    switch (property.Parent.Name.LocalName)
                    {
                        case "service":
                            _serviceProperties.Add(propertyName);
                            break;
                        case "component":
                            var componentName = property.Attribute("name").Value;

                            if (!_componentProperties.ContainsKey(componentName))
                            {
                                _componentProperties.Add(componentName, new HashSet<string>());
                            }

                            _componentProperties[componentName].Add(propertyName);
                            break;
                    }
                }
            }
        }

        private XDocument ReadTargetConfigIfExists(XDocument configurationXml)
        {
            // If there's a file as the output already, try to use it if possible, if not, move it and create a new file
            if (File.Exists(_outputFile))
            {
                try
                {
                    configurationXml = XDocument.Load(_outputFile);
                }
                catch (Exception)
                {
                    // File is not a proper xml, configurationXml will be null and the rest of the code will handle
                    // moving the file
                }

                // Rename the file if the xml file is not a configuration file
                if (configurationXml == null || configurationXml.Root.Name.LocalName != "DeploymentInstance")
                {
                    Program.WriteLine("Target output file '{0}' is not a valid Octopus configuration file.", _outputFile);
                    Program.WriteLine("Attempting to backup file and overwrite with output configuation file");
                    Program.WriteLine();

                    try
                    {
                        var dir = Path.GetDirectoryName(_outputFile);
                        var extension = Path.GetExtension(_outputFile);
                        var fileName = Path.GetFileNameWithoutExtension(_outputFile);

                        var randomFileName = Path.GetRandomFileName();
                        randomFileName = Path.Combine(dir, fileName + "-" + Path.GetFileNameWithoutExtension(randomFileName) + extension);

                        File.Move(_outputFile, randomFileName);

                        Console.WriteLine("File renamed to '{0}'", randomFileName);
                        Console.WriteLine();
                    }
                    catch (IOException e)
                    {
                        Console.WriteLine("Failed to create backup file for '{0}', file is untouched.", _outputFile);
                        Console.WriteLine(e);
                    }
                }
            }
            return configurationXml;
        }

        private void SetDeploymentInstanceAttributes(XElement deploymentInstance)
        {
            if (DeploymentShareLocation != null)
            {
                deploymentInstance.AddOrReplaceAttribute("deploymentShareLocation", DeploymentShareLocation);
            }

            if (LogsLocation != null)
            {
                deploymentInstance.AddOrReplaceAttribute("logsLocation", LogsLocation);
            }

            if (TopologyName != null)
            {
                deploymentInstance.AddOrReplaceAttribute("topologyName", TopologyName);
            }

            if (ReleaseName != null)
            {
                deploymentInstance.AddOrReplaceAttribute("releaseName", ReleaseName);
            }

            if (DeploymentAccount != null)
            {
                deploymentInstance.AddOrReplaceAttribute("deploymentAccount", DeploymentAccount);
            }

            if (ControllerMachine != null)
            {
                deploymentInstance.AddOrReplaceAttribute("controllerMachine", ControllerMachine);
            }

            // Ensure required attributes are there with default values or empty values
            deploymentInstance.AddAttributeIfNotExist("deploymentShareLocation", String.IsNullOrEmpty(_serviceXmlRootDir) ? "" : Path.GetFullPath(_serviceXmlRootDir));
            deploymentInstance.AddAttributeIfNotExist("logsLocation", "");
            deploymentInstance.AddAttributeIfNotExist("topologyName", "");
            deploymentInstance.AddAttributeIfNotExist("releaseName", "");
        }

        private void RemoveRoleAssignment(XElement deploymentInstance)
        {
            if (_rolesToRemove != null && _rolesToRemove.Count > 0)
            {
                // Find all PublishComponentName nodes where the name is in _rolesToRemove and remove them
                deploymentInstance.Descendants("PublishedComponentName")
                    .Where(c => c.Attribute("name") != null && _rolesToRemove.Contains(c.Attribute("name").Value))
                    .ToList().ForEach(c => c.Remove());

                // Clean up Server nodes and remove all empty ones
                deploymentInstance.Descendants("Server")
                    .Where(s => !s.HasElements).ToList().ForEach(s => s.Remove());
            }
        }
        
        private void AddServerElements(XElement deploymentInstance)
        {
            // Get all roles already exist in deploymentInstance
            var assignedRoles = new HashSet<string>(deploymentInstance.Descendants("PublishedComponentName")
                .Select(c => c.Attribute("name") != null ? c.Attribute("name").Value : ""));

            // Get all server nodes into a dictionary
            var serverElements = new Dictionary<string, XElement>();
            foreach (var server in deploymentInstance.Elements("Server"))
            {
                var serverName = server.Attribute("name");
                if (serverName != null)
                {
                    if (!serverElements.ContainsKey(serverName.Value))
                    {
                        serverElements.Add(serverName.Value, server);
                    }
                }
            }

            // Go through all the nodes and add them to the configuration if it does not already exist
            foreach (var role in _serverRoles)
            {
                // Already assigned, we can skip this
                if (assignedRoles.Contains(role))
                {
                    continue;
                }

                // Use the default machine if none is found in the roleServer mapping
                // Otherwise, skip this role
                string serverName;

                if (_roleServerMap.ContainsKey(role))
                {
                    serverName = _roleServerMap[role];
                }
                else if (!String.IsNullOrEmpty(_defaultMachine))
                {
                    serverName = _defaultMachine;
                }
                else
                {
                    continue;
                }

                // Create a Server XElement node if it none exist for the server
                if (!serverElements.ContainsKey(serverName))
                {
                    var serverElement = deploymentInstance.AddFirstElement("Server");
                    serverElement.Add(new XAttribute("name", serverName));
                    serverElements.Add(serverName, serverElement);
                }

                // Add component to server node
                var publishedComponentName = serverElements[serverName].AddElement("PublishedComponentName");
                publishedComponentName.Add(new XAttribute("name", role));
            }
        }
    }

    public static class XDocumentExtentions
    {
        public static XElement AddElement(this XDocument xDoc, string name)
        {
            var newElement = new XElement(name);
            xDoc.Add(newElement);

            return newElement;
        }

        public static XElement AddElement(this XElement xElement, string name)
        {
            var newElement = new XElement(name);
            xElement.Add(newElement);

            return newElement;
        }

        public static XElement AddFirstElement(this XElement xElement, string name)
        {
            var newElement = new XElement(name);
            xElement.AddFirst(newElement);

            return newElement;
        }

        public static XAttribute AddOrReplaceAttribute(this XElement xElement, string name, string value)
        {
            var xAttribute = xElement.Attribute(name);

            if (xAttribute == null)
            {
                xAttribute = new XAttribute(name, value);
                xElement.Add(xAttribute);
            }
            else
            {
                xAttribute.Value = value;
            }

            return xAttribute;
        }

        public static XAttribute AddAttributeIfNotExist(this XElement xElement, string name, string value)
        {
            var xAttribute = xElement.Attribute(name);

            if (xAttribute == null)
            {
                xAttribute = new XAttribute(name, value);
                xElement.Add(xAttribute);
            }

            return xAttribute;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\CommandInstallStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using DL = www.xboxlive.com.Deployment.Language.XMLSchema.xsd;
using DeploymentLanguageTests.Octopus;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// Variant of Install Step which represents an install command. These don't have any direct
    /// correspondence to the input schema -- they're created dynamically by the test cases
    /// to track run commands consistently
    /// </summary>
    public class CommandInstallStep : IInstallStep
    {
        /// <summary>
        /// The basic name for install commands
        /// </summary>
        public const string GlobalName = "com.xboxlive.deployment.test.CommandInstallStep";

        /// <summary>
        /// The command which will be run
        /// </summary>
        private DL.RunCommandType _runCommand;

        /// <summary>
        /// The suffix for the name of this install step
        /// </summary>
        private int _nameSuffix;

        /// <summary>
        /// Used by other parts of the system to determine when loading has completed.
        /// </summary>
        public event Action OnFinishedLoading
        {
            add
            {
                // we don't ever try to load anything
                value();
            }
            remove
            {
            }
        }

        /// <summary>
        /// Constructs a new install step based off of an XML element
        /// </summary>
        /// <param name="runCommand">The command that this installStep represents</param>
        /// <param name="nameSuffix">The suffix that will be appended to the name of this component</param>
        public CommandInstallStep(DL.RunCommandType runCommand, int nameSuffix)
        {
            _runCommand = runCommand;
            _nameSuffix = nameSuffix;
 
            foreach (var property in _runCommand.property)
            {
                AddProperty(property);
            }
        }

        /// <summary>
        /// The automatically generated name for this component
        /// </summary>
        public string Name
        {
            get { return GlobalName + " " + _nameSuffix; }
        }


        /// <summary>
        /// The XML element which contains the install command
        /// </summary>
        public DL.CommandType InstallCommand
        {
            get {
                return _runCommand.installCommand.FirstOrDefault();
            }
        }

        /// <summary>
        /// The XML element which contains the uninstall command
        /// </summary>
        public DL.CommandType UninstallCommand
        {
            get
            {
                return _runCommand.uninstallCommand.FirstOrDefault();
            }
        }

        /// <summary>
        /// The run command XML element
        /// </summary>
        public DL.RunCommandType XmlElement
        {
            get { return _runCommand; }
        }

        /// <summary>
        /// A list of all the children of this command.
        /// This class never has children.
        /// </summary>
        public IEnumerable<ShadowInstallStep> Children
        {
            get
            {
                return new List<ShadowInstallStep>();
            }
        }

        /// <summary>
        /// This class never names dependencies.
        /// </summary>
        public IEnumerable<string> DependencyNames
        {
            get { return new List<string>(); }
        }


        /// <summary>
        /// This class never has dependencies.
        /// </summary>
        public IEnumerable<Component> Dependencies
        {
            get { return new List<Component>(); }
        }

        /// <summary>
        /// Adds a property to this command. Properties which have user inputs get
        /// normalized with pipes to denote this.
        /// </summary>
        /// <param name="type">The property XML element</param>
        public void AddProperty(DL.PropertyType type)
        {
            if (type.userInput != null)
            {
                AddProperty(type.name, "|" + type.name + "|");
            }
            else
            {
                AddProperty(type.name, type.value);
            }
        }

        /// <summary>
        /// Adds a property to this command. The property is assumed to
        /// have been normalized. If the value is null, it is changed to empty string.
        /// </summary>
        /// <param name="name">property name</param>
        /// <param name="value">property value</param>
        public void AddProperty(string name, string value)
        {
            value = value ?? "";
            _properties.Add(name, value);
        }

        /// <summary>
        /// Returns the properties for this component. Properties that
        /// correspond to user input have already been normalized.
        /// </summary>
        public Dictionary<string, string> Properties
        {
            get
            {
                return new Dictionary<string, string>(_properties);
            }
        }

        /// <summary>
        /// Returns the properties that were passed to this component. Only
        /// properties that correspond to user input are normalized.
        /// </summary>
        public Dictionary<string, string> PassedProperties
        {
            get
            {
                return _runCommand.property.ToDictionary(x => x.name, y => y.value);
            }
        }
        Dictionary<string, string> _properties = new Dictionary<string, string>();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\configgenerator\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.IO;
using System.Xml;
using System.Diagnostics;
using xonline.common.tools.console;

namespace xonline.tools.configgenerator
{
    public class Program
    {
        public static int Main(string[] args)
        {
            WriteLine();
            WriteLine("Octopus Configuration File Generator");
            WriteLine();
            
            var namedArgs = new NamedArgParser();
            namedArgs.Parse(args);

            string outputPath = namedArgs["configoutput"];

            if (string.IsNullOrEmpty(outputPath))
            {
                Console.WriteLine("Missing config output path");
                Console.WriteLine();
                Usage();
                return 1;
            }

            try
            {
                WriteLine("  Beginning creating configuration file in {0}", outputPath);
                WriteLine();

                if (String.IsNullOrEmpty(Path.GetExtension(outputPath)))
                {
                    outputPath = Path.Combine(outputPath, "configuration.xml");
                }

                var configGenerator = new ConfigGenerator(outputPath);

                if (!String.IsNullOrEmpty(namedArgs["servicexmlpath"]))
                {
                    WriteLine("Octopus service.xml path used: '{0}'", namedArgs["servicexmlpath"]);
                    WriteLine();

                    configGenerator.AddServiceXmlSource(namedArgs["servicexmlpath"]);
                }

                if (!String.IsNullOrEmpty(namedArgs["configtemplate"]))
                {
                    WriteLine("Configuration template used: '{0}'", namedArgs["configtemplate"]);
                    WriteLine();

                    configGenerator.SetConfigTemplate(namedArgs["configtemplate"]);
                }

                if (!String.IsNullOrEmpty(namedArgs["defaultserver"]))
                {
                    WriteLine("Default server for all components: '{0}'", namedArgs["defaultserver"]);
                    WriteLine();

                    configGenerator.SetDefaultServer(namedArgs["defaultserver"]);
                }

                if (!String.IsNullOrEmpty(namedArgs["removeroles"]))
                {
                    string[] roles = namedArgs["removeroles"].Split(';');

                    WriteLine("Removing Roles:");
                    roles.ToList().ForEach(r => WriteLine(r));
                    WriteLine();

                    configGenerator.AddRolesToRemove(new HashSet<string>(roles.Select(r => r.Trim())));
                }

                if (namedArgs.ContainsKey("clearallroles"))
                {
                    WriteLine("Clearing all roles in existing config before assigning new ones");
                    WriteLine();

                    configGenerator.ClearConfigRoles = true;
                }

                if (namedArgs.ContainsKey("deploymentshare"))
                {
                    configGenerator.DeploymentShareLocation = namedArgs["deploymentshare"];

                    WriteLine("DeploymentShareLocation: '{0}'", configGenerator.DeploymentShareLocation);
                }

                if (namedArgs.ContainsKey("logslocation"))
                {
                    configGenerator.LogsLocation = namedArgs["logslocation"];

                    WriteLine("LogsLocation: '{0}'", configGenerator.LogsLocation);
                }
                
                if (namedArgs.ContainsKey("topologyname"))
                {
                    configGenerator.TopologyName = namedArgs["topologyname"];

                    WriteLine("TopologyName: '{0}'", configGenerator.TopologyName);
                }

                if (namedArgs.ContainsKey("releasename"))
                {
                    configGenerator.ReleaseName = namedArgs["releasename"];

                    WriteLine("ReleaseName: '{0}'", configGenerator.ReleaseName);
                }

                if (namedArgs.ContainsKey("deploymentaccount"))
                {
                    configGenerator.DeploymentAccount = namedArgs["deploymentaccount"];

                    WriteLine("DeploymentAccount: '{0}'", configGenerator.DeploymentAccount);
                }

                if (namedArgs.ContainsKey("controllermachine"))
                {
                    configGenerator.ControllerMachine = namedArgs["controllermachine"];

                    WriteLine("ControllerMachine: '{0}'", configGenerator.ControllerMachine);
                }

                // Create config
                configGenerator.GenerateConfig();

                WriteLine(ConsoleColor.Green, "  configuation file created with no errors at {0}", outputPath);
                WriteLine();

                return 0;
            }
            catch (Exception e)
            {
                WriteLine(e.ToString());

                return 1;
            }
        }

        private static void Usage()
        {
            Console.WriteLine("  Generates a configuation.xml for roles and properties found in service.xml(s)");
            Console.WriteLine();
            Console.WriteLine("  Usage:");
            Console.WriteLine("\t{0} /configoutput configurationXmlOutput [/servicexmlpath pathToServiceXmls]", typeof(Program).Assembly.ManifestModule.Name);
            Console.WriteLine("\t\t[/configtemplate configTemplate.xml>] [/defaultserver computerName>]");
            Console.WriteLine("\t\t[/removecomponent componentA;componentB] [/clearallroles]");
            Console.WriteLine();
            Console.WriteLine("  Required:");
            Console.WriteLine("\t/configoutput - Location for configuration.xml output");
            Console.WriteLine();
            Console.WriteLine("  Optional:");
            Console.WriteLine("\t[/servicexmlpath] - Directory containing service.xmls");
            Console.WriteLine("\t[/configtemplate] - Template to be used to create configuration.xml");
            Console.WriteLine("\t[/defaultserver] - Default server to assign for all components");
            Console.WriteLine("\t[/removecomponent] - Remove component assignment from all server");
            Console.WriteLine("\t                     Multiple components can be separated by ;");
            Console.WriteLine("\t                       e.g. SG Server;Xds");
            Console.WriteLine("\t[/clearallroles] - Clear all roles in config before assigning new ones");
            Console.WriteLine();
            Console.WriteLine("  DeploymentInstance attributes:");
            Console.WriteLine("\t[/deploymentshare] - Location of deployment share");
            Console.WriteLine("\t[/logslocation] - Location for storing Octopus logs");
            Console.WriteLine("\t[/topologyname] - Name of topology to be deployed");
            Console.WriteLine("\t[/releasename] - Name of release to be deployed");
            Console.WriteLine("\t[/deploymentaccount] - Account used for deployment");
            Console.WriteLine("\t[/controllermachine] - Machine running Octopus on");
            Console.WriteLine();
        }

        public static void WriteLine()
        {
            Console.WriteLine();
        }

        public static void WriteLine(string text, params string[] args)
        {
            Console.WriteLine(text, args);
        }

        public static void WriteLine(ConsoleColor color, string text, params string[] args)
        {
            ConsoleColor originalColor = Console.ForegroundColor;
            Console.ForegroundColor = color;
            Console.WriteLine(text, args);
            Console.ForegroundColor = originalColor;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\ExtensionMethods.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests
{
    static class ExtensionMethods
    {
        public static void Merge<T, U>(this Dictionary<T, U> dict, Dictionary<T, U> otherDict)
        {
            foreach (var pair in otherDict)
            {
                dict.Replace(pair.Key, pair.Value);
            }
        }

        public static void Replace<T, U>(this Dictionary<T, U> dict, T key, U value)
        {
            if (dict.ContainsKey(key))
            {
                dict.Remove(key);

            }
            dict.Add(key, value);
        }
        public static Dictionary<T, U> Replace<T, U>(this Dictionary<T, U> dict, Func<Dictionary<T, U>, T, U> replacementFunction)
        {
            Dictionary<T, U> tempDictionary = new Dictionary<T, U>(dict);
            foreach (var pair in dict)
            {
                tempDictionary.Replace(pair.Key, replacementFunction(tempDictionary, pair.Key));
            }

            return tempDictionary;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\Component.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Xml.Linq;

using DL = www.xboxlive.com.Deployment.Language.XMLSchema.xsd;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// This class corresponds to a top level component in the input language
    /// </summary>
    public class Component
    {
        private DL.components.componentLocalType _component;
        private List<ShadowInstallStep> _children = new List<ShadowInstallStep>();

        public Component(DL.components.componentLocalType component, DLLookup lookup)
        {
            _component = component;
            _lookup = lookup;

            foreach (var property in _component.property)
            {
                AddProperty(property);
            }

            Lookup.OnLoaded += BuildChildren;
        }

        /// <summary>
        /// Loads shadow install steps to track the usage of install steps.
        /// </summary>
        void BuildChildren()
        {
            Lookup.OnLoaded -= BuildChildren;

            foreach (var shadow in Lookup.ShadowsForElements(_component.Untyped.Elements()))
            {
                shadow.ParentComponent = this;
                _children.Add(shadow);
            }
        }

        public IEnumerable<ShadowInstallStep> Children
        {
            get
            {
                return _children.AsReadOnly();
            }
        }

        public string Name
        {
            get
            {
                return _component.name;
            }
        }

        public decimal? MaxServers
        {
            get
            {
                return _component.maxServers;
            }
        }

        public decimal? MinServers
        {
            get
            {
                return _component.minServers;
            }
        }

        public bool? AllServers
        {
            get
            {
                return _component.servers.ToLowerInvariant() == "all";
            }
        }

        public IEnumerable<string> DependencyNames
        {
            get
            {
                return _component.dependsOn.Select(x => x.componentName).ToList();
            }
        }

        public IEnumerable<Component> Dependencies
        {
            get
            {
                return DependencyNames.Select(x => Lookup.GetComponent(x)).ToList();
            }
        }

        public bool? DependsOnAllComponents
        {
            get
            {
                return _component.dependsOnAllComponents;
            }
        }



        public bool? DependedOnByAllComponents
        {
            get
            {
                return _component.dependedByAllComponents;
            }
        }

        public DeploymentPhase DeploymentPhase
        {
            get
            {
                DeploymentPhase deploymentPhase = Lookup.GetDeploymentPhases().Where(x => x.ComponentNames.Contains(Name)).FirstOrDefault();
                if (deploymentPhase == null)
                {
                    deploymentPhase = Lookup.GetDeploymentPhases().Where(x => x.IsDefault).FirstOrDefault();
                }
                return deploymentPhase;
            }
        }

        public DLLookup Lookup
        {
            get
            {
                return _lookup;
            }
        }

        public void AddDependency(Component component) 
        {
            _dependencies.Add(component);
        }

        /// <summary>
        /// Returns the full list of normalized properties.
        /// Normalized properties are resolved until there are no more non-constant or non-user input
        /// properties remaining. Normalized property values appear uniquely in the input and output documents.
        /// </summary>
        public Dictionary<string, string> NormalizedProperties
        {
            get
            {
                Dictionary<string, string> properties = Properties;

                Dictionary<string, string> updatedProperties = new Dictionary<string, string>(properties);
                foreach (var pair in properties)
                {
                    updatedProperties.Replace(pair.Key, GetNormalizedPropertyValue(pair.Value, updatedProperties, 0));
                }
                return updatedProperties;
            }
        }

        /// <summary>
        /// Helper method to normalize property value strings. Only used in recursion.
        /// </summary>
        /// <param name="valueString">A string containing properties.</param>
        /// <param name="properties">The properties used to resolve properties. If passed properties are to be considered
        /// they must be included in this dictionary</param>
        /// <param name="recursionCount">Counter used to prevent stack overflow</param>
        /// <returns>string with all property values replaced</returns>
        public string GetNormalizedPropertyValue(string valueString, Dictionary<string, string> properties, int recursionCount)
        {
            if (recursionCount > 20)
            {
                throw new Exception(String.Format("Component {0} has an infinite property evaluation loop involving: {1}",
                    Name, valueString));
            }

            StringBuilder plainString = new StringBuilder();
            string[] pieces = Regex.Split(valueString, "\\[([^]]*)\\]");
            for (int index = 0; index < pieces.Length; index++)
            {
                if (index % 2 == 0)
                {
                    plainString.Append(pieces[index]);
                }
                else
                {
                    string value = null;
                    if (Lookup.NormalizedProperties.ContainsKey(pieces[index]))
                    {
                        value = Lookup.NormalizedProperties[pieces[index]];
                    }
                    else if (properties.ContainsKey(pieces[index]))
                    {
                        value = GetNormalizedPropertyValue(properties[pieces[index]], properties, recursionCount + 1);
                    }

                    //Debug.Assert(value != null, "Couldn't find property {0} in component {1}",
                    //    pieces[index], Name);
                    //Debug.Assert(!value.Contains('[') && !value.Contains(']'), "Property {0} from component {1} contains a [ or ] as normal character illegally",
                    //    pieces[index], Name);

                    plainString.Append(value);
                }
            }
            return plainString.ToString();
        }

        /// <summary>
        /// Returns the properties for this component. Properties that
        /// correspond to user input have already been normalized.
        /// </summary>
        public Dictionary<string, string> Properties
        {
            get
            {
                return new Dictionary<string, string>(_properties);
            }
        }

        /// <summary>
        /// Adds a property to this command. Properties which have user inputs get
        /// normalized with pipes to denote this.
        /// </summary>
        /// <param name="type">The property XML element</param>
        public void AddProperty(DL.PropertyType type)
        {
            if (type.userInput != null)
            {
                AddProperty(type.name, "|" + type.name + "|");
            }
            else
            {
                AddProperty(type.name, type.value);
            }
        }

        /// <summary>
        /// Adds a property to this command. The property is assumed to
        /// have been normalized. If the value is null, it is changed to empty string.
        /// </summary>
        /// <param name="name">property name</param>
        /// <param name="value">property value</param>
        public void AddProperty(string name, string value)
        {
            value = value ?? "";
            _properties.Add(name, value);
        }

        /// <summary>
        /// A list of all of the descendant Install Steps, sorted to be
        /// in the order that they'll install in.
        /// </summary>
        public IEnumerable<ShadowInstallStep> OrderedSteps
        {
            get
            {
                return Children.SelectMany(x => x.OrderedSteps).Concat(Children.Where(x => !(x.InstallStep is InstallStep))).ToList();
            }
        }

        Dictionary<string, string> _properties = new Dictionary<string,string>();
        private List<Component> _dependencies = new List<Component>();
        private DLLookup _lookup;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\DefaultRelease.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// The default release. This class contains all components available
    /// under the lookup
    /// </summary>
    public class DefaultRelease : IRelease
    {

        DLLookup _lookup;

        public static readonly string DefaultReleaseName = "DefaultRelease";

        public DefaultRelease(DLLookup lookup)
        {
            _lookup = lookup;
        }

        public string Name
        {
            get
            {
                return DefaultReleaseName;
            }
        }

        public IEnumerable<Component> Components
        {
            get
            {
                return _lookup.GetComponents();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\IRelease.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    public interface IRelease
    {
        string Name
        {
            get;
        }

        IEnumerable<Component> Components
        {
            get;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\DeploymentPhase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;

using DL = www.xboxlive.com.Deployment.Language.XMLSchema.xsd;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// Represents a deployment phase in the input language.
    /// </summary>
    public class DeploymentPhase
    {
        private DL.deploymentPhases.deploymentPhaseLocalType _deploymentPhase;
        private List<Component> _components = new List<Component>();
        private DLLookup _lookup;


        /// <summary>
        /// Constructs a deployment phase
        /// </summary>
        /// <param name="deploymentPhase">The xml element which this instance represents</param>
        /// <param name="lookup">The service lookup object</param>
        public DeploymentPhase(DL.deploymentPhases.deploymentPhaseLocalType deploymentPhase, DLLookup lookup)
        {
            _deploymentPhase = deploymentPhase;
            _lookup = lookup;

        }

        public string Name
        {
            get
            {
                return _deploymentPhase.name;
            }
        }

        public bool IsDefault
        {
            get
            {
                return _deploymentPhase.@default;
            }
        }

        public DLLookup Lookup
        {
            get;
            set;
        }

        public IEnumerable<string> ComponentNames
        {
            get
            {
                return _deploymentPhase.componentRef.Select(x => x.name).ToList();
            }
        }

        public IEnumerable<Component> Components
        {
            get
            {
                return _components.AsReadOnly();
            }
        }

        public void AddComponent(Component component)
        {
            _components.Add(component);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\InstallStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using DL = www.xboxlive.com.Deployment.Language.XMLSchema.xsd;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// Represents an install step which possibly contains other install steps.
    /// </summary>
    public class InstallStep : IInstallStep
    {
        private DL.installSteps.installStepLocalType _installStep;
        private DLLookup _lookup;
        bool _isLoaded = false;
        Action _onFinishedLoading;

        public InstallStep (DL.installSteps.installStepLocalType installStep, DLLookup lookup)
        {
            _installStep = installStep;
            _lookup = lookup;

            foreach (var property in _installStep.property)
            {
                AddProperty(property);
            }

            Lookup.OnLoaded += BuildChildren;
        }

        /// <summary>
        /// Fired when the install step has finished loading.
        /// If the install step has already finished loading,
        /// this event fires immediately on add.
        /// </summary>
        public event Action OnFinishedLoading
        {
            add
            {
                if (_isLoaded)
                {
                    value();
                }
                else
                {
                    _onFinishedLoading += value;
                }
            }
            remove
            {

            }
        }

        public void BuildChildren()
        {
            if (_isLoaded)
            {
                return;
            }

            Lookup.OnLoaded -= BuildChildren;

            foreach (var shadow in Lookup.ShadowsForElements(_installStep.Untyped.Elements()))
            {
                shadow.InstallStepParent = this;
                _children.Add(shadow);
            }

            _isLoaded = true;
            _onFinishedLoading();
            _onFinishedLoading = null;
        }

        public DLLookup Lookup
        {
            get
            {
                return _lookup;
            }
        }

        public DL.installSteps.installStepLocalType XmlElement {
            get
            {
                return _installStep;
            }
        }

        public IEnumerable<string> DependencyNames
        {
            get
            {
                return _installStep.dependsOn.Select(x => x.componentName).ToList();
            }
        }

        public IEnumerable<Component> Dependencies
        {
            get
            {
                return _dependencies.ToList();
            }
        }

        public void AddDependency(Component component)
        {
            _dependencies.Add(component);
        }

        public string Name
        {
            get
            {
                return _installStep.name;
            }
        }

        public void AddProperty(DL.PropertyType type)
        {
            if (type.userInput != null)
            {
                AddProperty(type.name, "|" + type.name + "|");
            }
            else
            {
                AddProperty(type.name, type.value);
            }
        }

        public void AddProperty(string name, string value)
        {
            value = value ?? "";
            _properties.Add(name, value);
        }

        public Dictionary<string, string> Properties
        {
            get
            {
                return new Dictionary<string, string>(_properties);
            }
        }

        public Dictionary<string, string> PassedProperties
        {
            get
            {
                return new Dictionary<string, string>(_properties);
            }
        }

        public IEnumerable<ShadowInstallStep> Children
        {
            get
            {
                return _children.AsReadOnly();
            }
        }

        private List<ShadowInstallStep> _children = new List<ShadowInstallStep>();
        private Dictionary<string, string> _properties = new Dictionary<string, string>();
        private List<Component> _dependencies = new List<Component>();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\IInstallStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// Interface used to abstract away the differences between the concrete install steps (Msi and Command)
    /// and the install steps which just contain children (InstallStep)
    /// </summary>
    public interface IInstallStep
    {

        event Action OnFinishedLoading;
        string Name
        {
            get;
        }

        IEnumerable<string> DependencyNames
        {
            get;
        }

        IEnumerable<Component> Dependencies
        {
            get;
        }

        Dictionary<string, string> Properties
        {
            get;
        }

        Dictionary<string, string> PassedProperties
        {
            get;
        }

        IEnumerable<ShadowInstallStep> Children
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\MsiInstallStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using DL = www.xboxlive.com.Deployment.Language.XMLSchema.xsd;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// Variant of Install Step which represents an msi command. These don't have any direct
    /// correspondence to the input schema -- they're created dynamically by the test cases
    /// to track run commands consistently
    /// </summary>
    public class MsiInstallStep : IInstallStep
    {
        /// <summary>
        /// The basic name for msi commands
        /// </summary>
        public const string GlobalName = "com.xboxlive.deployment.test.MsiInstallStep";

        #region IInstallStep Members

        /// <summary>
        /// Information about which msi to run
        /// </summary>
        private DL.RunMsiType _runMsi;


        /// <summary>
        /// the suffix for the name of this install step
        /// </summary>
        private int _nameSuffix;

        /// <summary>
        /// Used by other parts of the system to determine when loading has completed
        /// </summary>
        public event Action OnFinishedLoading
        {
            add
            {
                // we don't ever try to load anything
                value();
            }
            remove
            {
            }
        }

        public MsiInstallStep(DL.RunMsiType runMsi, int nameSuffix )
        {
            _runMsi = runMsi;
            _nameSuffix = nameSuffix;
            foreach (var property in runMsi.property)
            {
                AddProperty(property);
            }
        }

        /// <summary>
        /// The automatically generated name for this component
        /// </summary>
        public string Name
        {
            get
            {
                return GlobalName + " " + _nameSuffix;
            }
        }

        /// <summary>
        /// The path to the MSI
        /// </summary>
        public string Path
        {
            get
            {
                return _runMsi.msi.Select(x=>x.path).FirstOrDefault();
            }
        }

        /// <summary>
        /// Whether or not a reboot should occur after this component gets installed
        /// </summary>
        public bool RebootOnInstall
        {
            get
            {
                return _runMsi.reboot.Select(x => x.onInstall).FirstOrDefault();
            }
        }

        /// <summary>
        /// Whether or not a reboot should occur after this component is uninstalled.
        /// </summary>
        public bool RebootOnUninstall
        {
            get
            {
                return _runMsi.reboot.Select(x => x.onUninstall).FirstOrDefault();
            }
        }

        /// <summary>
        /// Whether or not a component should pass properties on uninstall.
        /// </summary>
        public bool PassPropertiesOnUninstall
        {
            get
            {
                return _runMsi.msi.Select(x => x.passPropertiesOnUninstall).FirstOrDefault() ?? false;
            }
        }

        /// <summary>
        /// No dependencies are ever named.
        /// </summary>
        public IEnumerable<string> DependencyNames
        {
            get { return new List<string>(); }
        }

        /// <summary>
        /// The dependencies of this install step. Always empty.
        /// </summary>
        public IEnumerable<Component> Dependencies
        {
            get { return new List<Component>(); }
        }

        /// <summary>
        /// Children of this install step. Always empty.
        /// </summary>
        public IEnumerable<ShadowInstallStep> Children
        {
            get
            {
                return new List<ShadowInstallStep>();
            }
        }

        public Dictionary<string, string> Properties
        {
            get { return new Dictionary<string, string>(_properties); }
        }

        public Dictionary<string, string> PassedProperties
        {
            get
            {
                return _runMsi.property.ToDictionary(x => x.name, y => y.value);
            }
        }

        public void AddProperty(DL.PropertyType type)
        {
            if (type.userInput != null)
            {
                AddProperty(type.name, "|" + type.name + "|");
            }
            else
            {
                AddProperty(type.name, type.value);
            }
        }

        public void AddProperty(string name, string value)
        {
            value = value ?? "";
            _properties.Add(name, value);
        }

        /// <summary>
        /// The raw RunMsi element
        /// </summary>
        public DL.RunMsiType Element
        {
            get
            {
                return _runMsi;
            }
        }
        Dictionary<string, string> _properties = new Dictionary<string, string>();
        private string _msi;
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\DLLookup.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;

using System.Xml.Linq;

using DL = www.xboxlive.com.Deployment.Language.XMLSchema.xsd;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    public class DLLookup
    {
        /// <summary>
        /// Event fired when the service lookup is done loading all
        /// of the top level elements
        /// </summary>
        public event Action OnLoaded;

        /// <summary>
        /// Load the service lookup tables using all of the different kinds of documents
        /// </summary>
        /// <param name="documents">Documents corresponding to each of the 4/5 root nodes</param>
        public DLLookup(IEnumerable<DL.XRoot> documents)
        {
            foreach (var document in documents)
            {
                if (document.releases != null && document.releases.release != null)
                {
                    foreach (var release in document.releases.release)
                    {
                        _releaseLookup.Add(release.name, new Release(release, this));
                    }
                }

                if (document.installSteps != null && document.installSteps.installStep != null)
                {
                    foreach (var installStep in document.installSteps.installStep)
                    {
                        _installStepLookup.Add(installStep.name, new InstallStep(installStep, this));
                    }
                }

                if (document.deploymentPhases != null && document.deploymentPhases.deploymentPhase != null)
                {
                    foreach (var deploymentPhase in document.deploymentPhases.deploymentPhase)
                    {
                        _deploymentPhaseLookup.Add(deploymentPhase.name, new DeploymentPhase(deploymentPhase, this));
                    }
                }

                if (document.components != null && document.components.component != null)
                {
                    foreach (var component in document.components.component)
                    {
                        _componentLookup.Add(component.name, new Component(component, this));
                    }
                }

                if (document.properties != null && document.properties.property != null)
                {
                    foreach (var property in document.properties.property)
                    {
                        AddProperty(property);
                    }
                }
            }


            _releaseLookup.Add(DefaultRelease.DefaultReleaseName, new DefaultRelease(this));

            if (OnLoaded != null)
            {
                OnLoaded();
            }
        }


        public void AddProperty(DL.PropertyType type)
        {
            if (type.userInput != null)
            {
                AddProperty(type.name, "|" + type.name + "|");
            }
            else
            {
                AddProperty(type.name, type.value);
            }
        }

        public void AddProperty(string name, string value)
        {
            value = value ?? "";
            _properties.Add(name, value);
        }

        /// <summary>
        /// Variable used to ensure generated msi install steps have unique names
        /// </summary>
        static int _msiStepCount = 0;

        /// <summary>
        /// variable used to ensure that generated command install steps have unique names
        /// </summary>
        static int _commandStepCount = 0;


        /// <summary>
        /// Synthesizes an Install Step / Shadow Step pair for an
        /// runMsi element
        /// </summary>
        /// <param name="type">the runMsi element</param>
        /// <returns>the shadow install step for the element</returns>
        public ShadowInstallStep CreateLoweredStep(DL.RunMsiType type)
        {
            IInstallStep step = new MsiInstallStep(type, _msiStepCount++);
            _installStepLookup.Add(step.Name, step);
            return new ShadowInstallStep(step);
        }

        /// <summary>
        /// Synthesizes an Install Step / Shadow Step pair for an
        /// runCommand element
        /// </summary>
        /// <param name="type">the runMsi element</param>
        /// <returns>the shadow install step for the element</returns>
        public ShadowInstallStep CreateLoweredStep(DL.RunCommandType type)
        {
            IInstallStep step = new CommandInstallStep(type, _msiStepCount++);
            _installStepLookup.Add(step.Name, step);
            return new ShadowInstallStep(step);
        }

        /// <summary>
        /// Creates a shadow install step to mirror an already existing install step
        /// </summary>
        /// <param name="type">the element specifying which install step to shadow</param>
        /// <returns>the shadow install step</returns>
        public ShadowInstallStep CreateLoweredStep(DL.InstallType type)
        {
            IInstallStep step = GetInstallStep(type.step);
            return new ShadowInstallStep(step);
        }

        /// <summary>
        /// Decides whether to instantiate an MSI or Command InstallStep or a normal Install Step shadow
        /// for each element in the list. This is used because our schema breaks any sense of ordering and
        /// ordering is significant
        /// </summary>
        /// <param name="elements">the elements to test</param>
        /// <returns>shadow install steps corresponding to each appropriate element in elements</returns>
        public IEnumerable<ShadowInstallStep> ShadowsForElements(IEnumerable<XElement> elements)
        {
            List<ShadowInstallStep> installSteps = new List<ShadowInstallStep>();

            foreach (var element in elements)
            {
                ShadowInstallStep s = null;
                switch (element.Name.LocalName)
                {
                    case "runMsi":
                        s = CreateLoweredStep((DL.RunMsiType)element);
                        break;

                    case "runCommand":
                        s = CreateLoweredStep((DL.RunCommandType)element);
                        break;

                    case "install":
                        s = CreateLoweredStep((DL.InstallType)element);
                        break;
                }
                if (s != null)
                {
                    installSteps.Add(s);
                }
            }
            return installSteps;
        }

        public Component GetComponent(string name)
        {
            Component component;
            _componentLookup.TryGetValue(name, out component);
            return component;
        }

        public IEnumerable<Component> GetComponents()
        {
            return _componentLookup.Values;
        }

        public DeploymentPhase GetDeploymentPhase(string name)
        {
            DeploymentPhase phase;
            _deploymentPhaseLookup.TryGetValue(name, out phase);
            return phase;
        }

        public IEnumerable<DeploymentPhase> GetDeploymentPhases()
        {
            return _deploymentPhaseLookup.Values;
        }

        public IInstallStep GetInstallStep(string name)
        {
            IInstallStep step;
            _installStepLookup.TryGetValue(name, out step);
            return step;
        }

        public IEnumerable<IRelease> GetReleases()
        {
            return _releaseLookup.Values;
        }


        /// <summary>
        /// Gets the global properties. All userInput properties have been normalized already.
        /// </summary>
        public Dictionary<string, string> Properties
        {
            get
            {
                return new Dictionary<string, string>(_properties);
            }
        }


        private Dictionary<string, string> _properties = new Dictionary<string, string>();

        /// <summary>
        /// Returns the full list of normalized properties.
        /// Normalized properties are resolved until there are no more non-constant or non-user input
        /// properties remaining. Normalized property values appear uniquely in the input and output documents.
        /// </summary>
        public Dictionary<string, string> NormalizedProperties
        {
            get
            {
                Dictionary<string, string> properties = Properties;

                Dictionary<string, string> updatedProperties = new Dictionary<string, string>(properties);
                foreach (var pair in properties)
                {
                    updatedProperties.Replace(pair.Key, GetNormalizedPropertyValue(pair.Value, updatedProperties, 0));
                }
                return updatedProperties;
            }
        }

        /// <summary>
        /// Helper method to normalize property value strings. Only used in recursion.
        /// </summary>
        /// <param name="valueString">A string containing properties.</param>
        /// <param name="properties">The properties used to resolve properties. If passed properties are to be considered
        /// they must be included in this dictionary</param>
        /// <param name="recursionCount">Counter used to prevent stack overflow</param>
        /// <returns>string with all property values replaced</returns>
        public string GetNormalizedPropertyValue(string valueString, Dictionary<string, string> properties, int recursionCount)
        {
            if (recursionCount > 20)
            {
                throw new Exception(String.Format("The Global Service has an infinite property evaluation loop involving: {0}",
                    valueString));
            }

            StringBuilder plainString = new StringBuilder();
            string[] pieces = Regex.Split(valueString, "\\[([^]]*)\\]");
            for (int index = 0; index < pieces.Length; index++)
            {
                if (index % 2 == 0)
                {
                    plainString.Append(pieces[index]);
                }
                else
                {
                    string value = null;
                    if (properties.ContainsKey(pieces[index]))
                    {
                        value = GetNormalizedPropertyValue(properties[pieces[index]], properties, recursionCount + 1);
                    }

                    Debug.Assert(value != null, "Couldn't find property {0} in Global Service",
                        pieces[index]);
                    Debug.Assert(!value.Contains('[') && !value.Contains(']'), "Property {0} from Global Service contains a [ or ] as normal character illegally",
                        pieces[index]);

                    plainString.Append(value);
                }
            }
            return plainString.ToString();
        }
        Dictionary<string, IRelease> _releaseLookup = new Dictionary<string, IRelease>();
        Dictionary<string, IInstallStep> _installStepLookup = new Dictionary<string, IInstallStep>();
        Dictionary<string, DeploymentPhase> _deploymentPhaseLookup = new Dictionary<string, DeploymentPhase>();
        Dictionary<string, Component> _componentLookup = new Dictionary<string, Component>();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\Release.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using DL = www.xboxlive.com.Deployment.Language.XMLSchema.xsd;


namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// Class which represents releases in the input service releases
    /// </summary>
    public class Release : IRelease
    {
        private DL.releases.releaseLocalType _release;
        private List<Component> _containedComponents = new List<Component>();
        private DLLookup _lookup;

        public Release(DL.releases.releaseLocalType release, DLLookup lookup)
        {
            _release = release;
            _lookup = lookup;
        }


        public string Name
        {
            get
            {
                return _release.name;
            }
        }

        public IEnumerable<string> ContainedComponentNames
        {
            get
            {
                return _release.componentRef.Select(x => x.name).ToList();
            }
        }

        public IEnumerable<Component> Components
        {
            get
            {
                return ContainedComponentNames.Select(x => _lookup.GetComponent(x)).ToList();
            }
        }

        void Add(Component component)
        {
            _containedComponents.Add(component);
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Model\Component.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.Model
{
    class Component
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Model\Check.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.Model
{
    class Check
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Model\Property.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.Model
{
    public class Property
    {
        public string Name { get; set; }
        public string Value { get; set; }
        public string MergeSeparator { get; set; }

        public string ServerList { get; set; }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\DeploymentLanguage\ShadowInstallStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace DeploymentLanguageTests.DeploymentLanguage
{
    /// <summary>
    /// ShadowInstallSteps represent the usage of an install step. They're connected back
    /// to the actual install step from which it was instantiated. Property resolution occurs primarily
    /// through this class.
    /// 
    /// Objects of this class are organized into trees and can either lead to a Component or an Install step as the root.
    /// </summary>
    public class ShadowInstallStep
    {
        public ShadowInstallStep(IInstallStep installStep) 
        {
            InstallStep = installStep;
            InstallStep.OnFinishedLoading += BuildChildren;
        }

        public IInstallStep InstallStep
        {
            get;
            private set;
        }


        /// <summary>
        /// The parent install step in the tree.
        /// Null if this at the top of the tree.
        /// </summary>
        public ShadowInstallStep Parent
        {
            get;
            set;
        }

        /// <summary>
        /// The parent component.
        /// Null if this this element is not at the top
        /// of the tree or if it is part of an InstallStep tree.
        /// </summary>
        public Component ParentComponent
        {
            get;
            set;
        }

        /// <summary>
        /// The parent install step.
        /// Null if this element is not at the top of the tree
        /// or if it is part of a component tree.
        /// </summary>
        public InstallStep InstallStepParent
        {
            get;
            set;
        }

        public List<ShadowInstallStep> _children = new List<ShadowInstallStep>();
        public IEnumerable<ShadowInstallStep> Children
        {
            get
            {
                return _children;
            }
        }
        public DeploymentPhase DeploymentPhase
        {
            get
            {
                if (Parent != null)
                {
                    return Parent.DeploymentPhase;
                }
                else
                {
                    return ParentComponent.DeploymentPhase;
                }
            }
        }

        public Component TopLevelComponent
        {
            get
            {
                if (ParentComponent != null)
                {
                    return ParentComponent;
                }
                else if (Parent != null)
                {
                    return Parent.TopLevelComponent;
                }
                else
                {
                    return null;
                }
            }
        }

        public DLLookup Lookup
        {
            get
            {
                return TopLevelComponent.Lookup;
            }
        }

        /// <summary>
        /// A list of all the descendant shadow steps in the order they'll actually be installed
        /// </summary>
        public IEnumerable<ShadowInstallStep> OrderedSteps
        {
            get
            {
                return Children.SelectMany(x => x.OrderedSteps).Concat(Children.Where(x=>!(x.InstallStep is InstallStep))).ToList();
            }
        }

        public void BuildChildren()
        {
            InstallStep.OnFinishedLoading -= BuildChildren;

            foreach (var child in InstallStep.Children)
            {
                _children.Add(child.CloneWithParent(this));
            }
        }

        /// <summary>
        /// Clones an install step tree
        /// </summary>
        /// <param name="shadowStep">The shadow step to use as the new parent</param>
        /// <returns>a deep-copied clone of this object</returns>
        public ShadowInstallStep CloneWithParent(ShadowInstallStep shadowStep)
        {
            ShadowInstallStep step = new ShadowInstallStep(InstallStep);
            step.Parent = shadowStep;
            step.InstallStepParent = null;
            step.ParentComponent = null;

            foreach (var child in Children)
            {
                step._children.Add(child.CloneWithParent(step));
            }

            return step;
        }

        /// <summary>
        /// Returns the full list of normalized properties.
        /// Normalized properties are resolved until there are no more non-constant or non-user input
        /// properties remaining. Normalized property values appear uniquely in the input and output documents.
        /// </summary>
        public Dictionary<string, string> NormalizedProperties
        {
            get
            {
                Dictionary<string, string> properties = InstallStep.Properties;
                Dictionary<string, string> passedProperties = InstallStep.PassedProperties; /*(Parent != null) ? Parent.PassedPropertiesForChild(this) : ParentComponent.PassedPropertiesForChild(this);*/
                Dictionary<string, string> normalizedProperties = (Parent != null) ? Parent.NormalizedProperties : ParentComponent.NormalizedProperties;

                properties.Merge(passedProperties.Replace((dict, key) => GetNormalizedPropertyValue(dict[key], normalizedProperties, 0)));

                Dictionary<string, string> updatedProperties = new Dictionary<string, string>(properties);
                foreach (var pair in properties)
                {
                    updatedProperties.Replace(pair.Key, GetNormalizedPropertyValue(pair.Value, updatedProperties, 0));
                }
                return updatedProperties;
            }
        }

        /// <summary>
        /// Helper method to normalize property value strings. Only used in recursion.
        /// </summary>
        /// <param name="valueString">A string containing properties.</param>
        /// <param name="properties">The properties used to resolve properties. If passed properties are to be considered
        /// they must be included in this dictionary</param>
        /// <param name="recursionCount">Counter used to prevent stack overflow</param>
        /// <returns>string with all property values replaced</returns>
        public string GetNormalizedPropertyValue(string valueString, Dictionary<string, string> properties, int recursionCount)
        {
            if (recursionCount > 20)
            {
                throw new Exception(String.Format("Component {0} has an infinite property evaluation loop involving: {1}",
                    InstallStep.Name, valueString));
            }

            StringBuilder plainString = new StringBuilder();
            string[] pieces = Regex.Split(valueString, "\\[([^]]*)\\]");
            for (int index = 0; index < pieces.Length; index++)
            {
                if (index % 2 == 0)
                {
                    plainString.Append(pieces[index]);
                }
                else
                {
                    string value = null;
                    if (Lookup.NormalizedProperties.ContainsKey(pieces[index]))
                    {
                        value = Lookup.NormalizedProperties[pieces[index]];
                    }
                    else if (properties.ContainsKey(pieces[index]))
                    {
                        value = GetNormalizedPropertyValue(properties[pieces[index]], properties, recursionCount + 1);
                    }

                    //Debug.Assert(value != null, "Couldn't find property {0} in component {1}",
                    //    pieces[index], InstallStep.Name);
                    //Debug.Assert(!value.Contains('[') && !value.Contains(']'), "Property {0} from component {1} contains a [ or ] as normal character illegally",
                    //    pieces[index], InstallStep.Name);

                    plainString.Append(value);
                }
            }
            return plainString.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Model\ServerList.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.Model
{
    public class ServerList
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Model\Topology.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.Model
{
    class Topology
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Model\Service.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.Model
{
    public class Service
    {
        public Service()
        {
            PassPropertiesOnUninstall = false;
            RequiredReleases = new List<string>();
            Properties = new List<Property>();
            Topologies = new List<Topology>();
            Components = new List<Component>();
            DomainChecks = new List<Check>();
        }
        public string Name { set; get; }
        public string Release { set; get; }
        public bool PassPropertiesOnUninstall { get; set; }
        public string DeploymentNotesPath { set; get; }

        public ICollection<string> RequiredReleases { get; set; }
        public ICollection<Property> Properties { get; set; }
        public ICollection<Topology> Topologies { get; set; }
        public ICollection<Component> Components { get; set; }
        public ICollection<Check> DomainChecks { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Model\UserInput.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeploymentLanguageTests.Model
{
    public class UserInput
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\service.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace schemas.microsoft.com.Octopus.Item2005.Item01.Service {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    
    
    /// <summary>
    /// <para>
    /// Regular expression: (requireRelease* | property* | topologies | components | domainChecks?)+
    /// </para>
    /// </summary>
    public partial class service : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<requireReleaseLocalType> requireReleaseField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PropertyType> propertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<topologiesLocalType> topologiesField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<componentsLocalType> componentsField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<DomainChecksType> domainChecksField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator service(XElement xe) { return XTypedServices.ToXTypedElement<service>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static service() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (requireRelease* | property* | topologies | components | domainChecks?)+
        /// </para>
        /// </summary>
        public service() {
        }
        
        /// <summary>
        /// <para>
        /// A prerequisite release that must be installed before this release.
        /// </para>
        /// <para>
        /// 
        ///The <requireRelease> element names another release of the current service that must have been installed completely before the current release will be deployed.
        ///The requireRelease element is particularly useful in upgrade scenarios. In Operational environments, it is typical to scale out some server types as needed as well as periodically install small patches and far-reaching service upgrades. As the service becomes more mature, it becomes more difficult to build a test topology that reflects the state of the live service.
        ///
        ///A developer can automate the process of installing and upgrading by naming a required release for the current service element. If the Octopus Deployment Framework detects that one or more required releases (or nested required releases) have not been installed, then it will attempt to install those releases before executing the current release of the service.
        ///
        ///This technology can also be used to combine upgrades with scale out work. In an upgrade situation, some servers may be added to improve service capacity. For example, additional web servers may be added prior to the upgrade. This puts the service in an unusual state since some of the servers have previously been installed with all prior versions and patches, while other servers are brand new. The Octopus Deployment Framework can recognize this condition and will first upgrade the new servers to the most recent required release before upgrading the entire service to the newest version.
        ///
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (requireRelease* | property* | topologies | components | domainChecks?)+
        /// </para>
        /// </summary>
        public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.requireReleaseLocalType> requireRelease {
            get {
                if ((this.requireReleaseField == null)) {
                    this.requireReleaseField = new XTypedList<requireReleaseLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("requireRelease", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.requireReleaseField;
            }
            set {
                if ((value == null)) {
                    this.requireReleaseField = null;
                }
                else {
                    if ((this.requireReleaseField == null)) {
                        this.requireReleaseField = XTypedList<requireReleaseLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("requireRelease", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<requireReleaseLocalType>(this.requireReleaseField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A "global" property to which multiple topologies and components defined within the service may refer.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (requireRelease* | property* | topologies | components | domainChecks?)+
        /// </para>
        /// </summary>
        public IList<PropertyType> property {
            get {
                if ((this.propertyField == null)) {
                    this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.propertyField;
            }
            set {
                if ((value == null)) {
                    this.propertyField = null;
                }
                else {
                    if ((this.propertyField == null)) {
                        this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<PropertyType>(this.propertyField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A list of the supported topologies for the service.
        /// </para>
        /// <para>
        /// The <topologies> element is a simple collection of topology elements.
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (requireRelease* | property* | topologies | components | domainChecks?)+
        /// </para>
        /// </summary>
        public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.topologiesLocalType> topologies {
            get {
                if ((this.topologiesField == null)) {
                    this.topologiesField = new XTypedList<topologiesLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("topologies", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.topologiesField;
            }
            set {
                if ((value == null)) {
                    this.topologiesField = null;
                }
                else {
                    if ((this.topologiesField == null)) {
                        this.topologiesField = XTypedList<topologiesLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("topologies", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<topologiesLocalType>(this.topologiesField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A list of the components of the service.
        /// </para>
        /// <para>
        /// The components element is a simple collection of component elements.
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (requireRelease* | property* | topologies | components | domainChecks?)+
        /// </para>
        /// </summary>
        public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.componentsLocalType> components {
            get {
                if ((this.componentsField == null)) {
                    this.componentsField = new XTypedList<componentsLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("components", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.componentsField;
            }
            set {
                if ((value == null)) {
                    this.componentsField = null;
                }
                else {
                    if ((this.componentsField == null)) {
                        this.componentsField = XTypedList<componentsLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("components", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<componentsLocalType>(this.componentsField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A set of checks to be performed at the domain level for all topologies before beginning deployment.
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (requireRelease* | property* | topologies | components | domainChecks?)+
        /// </para>
        /// </summary>
        public IList<DomainChecksType> domainChecks {
            get {
                if ((this.domainChecksField == null)) {
                    this.domainChecksField = new XTypedList<DomainChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("domainChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.domainChecksField;
            }
            set {
                if ((value == null)) {
                    this.domainChecksField = null;
                }
                else {
                    if ((this.domainChecksField == null)) {
                        this.domainChecksField = XTypedList<DomainChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("domainChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<DomainChecksType>(this.domainChecksField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A friendly name to uniquely identify this service.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A friendly name to uniquely identify this release of this service. Release names must start and end with a letter or digit; and may include letters, digits, underscores, spaces, periods or dashes between the first and last character.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string release {
            get {
                XAttribute x = this.Attribute(XName.Get("release", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("release", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Normally properties are not passed to MSI files when uninstalling. Set this attribute to "true" to specify that all MSI files in this service require properties for uninstall. This option can also be set for an individual MSI files by setting the attribute on the <msi> element.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<bool> passPropertiesOnUninstall {
            get {
                XAttribute x = this.Attribute(XName.Get("passPropertiesOnUninstall", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("passPropertiesOnUninstall", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A path to a deployment notes document. This can be an absolute path, a path relative to the serice.xml file or a URL. This will be available via the Notes button on the Configuration page in Octopus GUI.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string deploymentNotesPath {
            get {
                XAttribute x = this.Attribute(XName.Get("deploymentNotesPath", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("deploymentNotesPath", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("service", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static service Load(string xmlFile) {
            return XTypedServices.Load<service>(xmlFile);
        }
        
        public static service Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<service>(xmlFile);
        }
        
        public static service Parse(string xml) {
            return XTypedServices.Parse<service>(xml);
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<service>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("requireRelease", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(requireReleaseLocalType));
            localElementDictionary.Add(XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(PropertyType));
            localElementDictionary.Add(XName.Get("topologies", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(topologiesLocalType));
            localElementDictionary.Add(XName.Get("components", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(componentsLocalType));
            localElementDictionary.Add(XName.Get("domainChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(DomainChecksType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        public partial class requireReleaseLocalType : XTypedElement, IXMetaData {
            
         public static explicit operator requireReleaseLocalType(XElement xe) { return XTypedServices.ToXTypedElement<requireReleaseLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            public requireReleaseLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// The name of the release that must be completely installed before the current release is installed.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("requireRelease", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<requireReleaseLocalType>(this);
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (topology+)+
        /// </para>
        /// </summary>
        public partial class topologiesLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<topologyLocalType> topologyField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator topologiesLocalType(XElement xe) { return XTypedServices.ToXTypedElement<topologiesLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static topologiesLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (topology+)+
            /// </para>
            /// </summary>
            public topologiesLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// One of the possible logical topologies for deploying the service.
            /// </para>
            /// <para>
            /// The topology element defines a collection of published components that can be assigned to physical servers for execution.A topology is a supported configuration of a service in terms of which components are installed together on a single machine. All topologies within a service element are expected to represent the same software, but in different configurations. This is useful in cases where a service is large and not all development and test participants can afford to build complete services. Usually the primary topology will be an "Expanded" topology with the complete set of roles to be used in production. For convenience a service may define a "One Box" topology with all of the components of the service in a single role, for ease of installing the whole service on a single machine.
            /// </para>
            /// <para>
            /// Occurrence: required, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (topology+)+
            /// </para>
            /// </summary>
            public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.topologiesLocalType.topologyLocalType> topology {
                get {
                    if ((this.topologyField == null)) {
                        this.topologyField = new XTypedList<topologyLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("topology", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    return this.topologyField;
                }
                set {
                    if ((value == null)) {
                        this.topologyField = null;
                    }
                    else {
                        if ((this.topologyField == null)) {
                            this.topologyField = XTypedList<topologyLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("topology", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        else {
                            XTypedServices.SetList<topologyLocalType>(this.topologyField, value);
                        }
                    }
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("topologies", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<topologiesLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("topology", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(topologyLocalType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (property* | (publishComponent* | role*)+|domainChecks?)+
            /// </para>
            /// </summary>
            public partial class topologyLocalType : XTypedElement, IXMetaData {
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<PropertyType> propertyField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<RoleType> publishComponentField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<RoleType> roleField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<DomainChecksType> domainChecksField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
                
         public static explicit operator topologyLocalType(XElement xe) { return XTypedServices.ToXTypedElement<topologyLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                static topologyLocalType() {
                    BuildElementDictionary();
                }
                
                /// <summary>
                /// <para>
                /// Regular expression: (property* | (publishComponent* | role*)+|domainChecks?)+
                /// </para>
                /// </summary>
                public topologyLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// A property specific to this topology.
                /// </para>
                /// <para>
                /// Occurrence: optional, repeating, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | (publishComponent* | role*)+|domainChecks?)+
                /// </para>
                /// </summary>
                public IList<PropertyType> property {
                    get {
                        if ((this.propertyField == null)) {
                            this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.propertyField;
                    }
                    set {
                        if ((value == null)) {
                            this.propertyField = null;
                        }
                        else {
                            if ((this.propertyField == null)) {
                                this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<PropertyType>(this.propertyField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A reference to a component that should be published as a server role. <publishComponent> is deprecated, use <role> instead.
                /// </para>
                /// <para>
                /// 
                ///The <publishComponent> element references a component that should be published as a role that can be assigned to one or more physical servers.
                /// </para>
                /// <para>
                /// Occurrence: optional, repeating, choice
                /// </para>
                /// <para>
                /// Setter: Appends
                /// </para>
                /// <para>
                /// Regular expression: (property* | (publishComponent* | role*)+|domainChecks?)+
                /// </para>
                /// </summary>
                public IList<RoleType> publishComponent {
                    get {
                        if ((this.publishComponentField == null)) {
                            this.publishComponentField = new XTypedList<RoleType>(this, LinqToXsdTypeManager.Instance, XName.Get("publishComponent", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.publishComponentField;
                    }
                    set {
                        if ((value == null)) {
                            this.publishComponentField = null;
                        }
                        else {
                            if ((this.publishComponentField == null)) {
                                this.publishComponentField = XTypedList<RoleType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("publishComponent", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<RoleType>(this.publishComponentField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A reference to a component that should be exposed as a server role.
                /// </para>
                /// <para>
                /// 
                ///The <role> element references a component that should be exposed as a role that can be assigned to one or more physical servers.
                /// </para>
                /// <para>
                /// Occurrence: optional, repeating, choice
                /// </para>
                /// <para>
                /// Setter: Appends
                /// </para>
                /// <para>
                /// Regular expression: (property* | (publishComponent* | role*)+|domainChecks?)+
                /// </para>
                /// </summary>
                public IList<RoleType> role {
                    get {
                        if ((this.roleField == null)) {
                            this.roleField = new XTypedList<RoleType>(this, LinqToXsdTypeManager.Instance, XName.Get("role", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.roleField;
                    }
                    set {
                        if ((value == null)) {
                            this.roleField = null;
                        }
                        else {
                            if ((this.roleField == null)) {
                                this.roleField = XTypedList<RoleType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("role", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<RoleType>(this.roleField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A set of checks to be performed at the domain level for this topology before beginning deployment.
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | (publishComponent* | role*)+|domainChecks?)+
                /// </para>
                /// </summary>
                public IList<DomainChecksType> domainChecks {
                    get {
                        if ((this.domainChecksField == null)) {
                            this.domainChecksField = new XTypedList<DomainChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("domainChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.domainChecksField;
                    }
                    set {
                        if ((value == null)) {
                            this.domainChecksField = null;
                        }
                        else {
                            if ((this.domainChecksField == null)) {
                                this.domainChecksField = XTypedList<DomainChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("domainChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<DomainChecksType>(this.domainChecksField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// Occurrence: required
                /// </para>
                /// </summary>
                public string name {
                    get {
                        XAttribute x = this.Attribute(XName.Get("name", ""));
                        return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                    set {
                        this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                    get {
                        return localElementDictionary;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("topology", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<topologyLocalType>(this);
                }
                
                private static void BuildElementDictionary() {
                    localElementDictionary.Add(XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(PropertyType));
                    localElementDictionary.Add(XName.Get("publishComponent", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(RoleType));
                    localElementDictionary.Add(XName.Get("role", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(RoleType));
                    localElementDictionary.Add(XName.Get("domainChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(DomainChecksType));
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (component+)+
        /// </para>
        /// </summary>
        public partial class componentsLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<componentLocalType> componentField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator componentsLocalType(XElement xe) { return XTypedServices.ToXTypedElement<componentsLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static componentsLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (component+)+
            /// </para>
            /// </summary>
            public componentsLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// A single deployment action with its dependencies, or a collection of other components.
            /// </para>
            /// <para>
            /// The component element specifies an action to be performed and/or an aggregation of other components. The component element is one of the most important pieces of a service manifest. Using aggregation, components can be hierarchical in nature, ultimately reducing to components containing a single msi or command action. Published components are the primary constituents of topology elements, and are available to deployment Operators for assignment to servers.The publishInterface and requireInterface elements are the means by which authors can impose ordering upon the installation of their components. Natively, XML does not support the notion of ordering and the list of aggregateComponent elements under a component is considered an unordered collection, meaning that there are no guarantees about the order in which two peer components execute. A developer can require that another component be installed before the current one by requiring an interface that is correspondingly published by the prerequisite component.If a component contains an msi, it may not contain an installCommand or an uninstallCommand.Aggregation can also be used to impose ordering within a component. Aggregated components are always executed before the msi or command in the parent component.
            /// </para>
            /// <para>
            /// Occurrence: required, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (component+)+
            /// </para>
            /// </summary>
            public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.componentsLocalType.componentLocalType> component {
                get {
                    if ((this.componentField == null)) {
                        this.componentField = new XTypedList<componentLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("component", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    return this.componentField;
                }
                set {
                    if ((value == null)) {
                        this.componentField = null;
                    }
                    else {
                        if ((this.componentField == null)) {
                            this.componentField = XTypedList<componentLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("component", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        else {
                            XTypedServices.SetList<componentLocalType>(this.componentField, value);
                        }
                    }
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("components", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<componentsLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("component", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(componentLocalType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
            /// </para>
            /// </summary>
            public partial class componentLocalType : XTypedElement, IXMetaData {
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<PropertyType> propertyField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<ChecksType> conditionChecksField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<ChecksType> prerequisiteChecksField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<publishInterfaceLocalType> publishInterfaceField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<requireInterfaceLocalType> requireInterfaceField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<AggregateComponentType> aggregateComponentField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<ChecksType> checksField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<msiLocalType> msiField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<ChecksType> installedChecksField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<CommandType> installCommandField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<CommandType> uninstallCommandField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<rebootLocalType> rebootField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<ChecksType> postDeploymentChecksField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
                
         public static explicit operator componentLocalType(XElement xe) { return XTypedServices.ToXTypedElement<componentLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                static componentLocalType() {
                    BuildElementDictionary();
                }
                
                /// <summary>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public componentLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// Defines a configurable parameter for this component.
                /// </para>
                /// <para>
                /// Occurrence: optional, repeating, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<PropertyType> property {
                    get {
                        if ((this.propertyField == null)) {
                            this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.propertyField;
                    }
                    set {
                        if ((value == null)) {
                            this.propertyField = null;
                        }
                        else {
                            if ((this.propertyField == null)) {
                                this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<PropertyType>(this.propertyField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A set of checks which determine whether this component should be included in the deployment.
                /// </para>
                /// <para>
                /// 
                ///The <conditionChecks> element defines a set of checks that determine whether the component should be included in the current deployment. This could be used, for example, for a patch that should only be installed on Windows 2000. If the machine is not Windows 2000, the component would be skipped without any error.
                ///
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<ChecksType> conditionChecks {
                    get {
                        if ((this.conditionChecksField == null)) {
                            this.conditionChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("conditionChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.conditionChecksField;
                    }
                    set {
                        if ((value == null)) {
                            this.conditionChecksField = null;
                        }
                        else {
                            if ((this.conditionChecksField == null)) {
                                this.conditionChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("conditionChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<ChecksType>(this.conditionChecksField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A set of checks which determine whether prerequisite conditions are met before this component can be installed.
                /// </para>
                /// <para>
                /// The <prerequisiteChecks> element describes one or more atomic checks that will be performed before the Octopus Deployment Framework acts upon the rest of the component. All of the child elements of the check must return successfully for the prerequisiteChecks element to return success.This element lists check operations that are meaningful in the context of an individual server. This distinguishes component prerequisite checks from domain checks, which are meaningful in the context of a Windows domain.Prerequisite checks are used to prove that a set of servers are ready for a deployment. The Octopus Deployment Framework and Console support a "check only" mode in which all checks are run against a set of servers, but no MSIs or command actions are deployed. Operators can run a "check only" test against their bed before committing time to a full deployment.
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<ChecksType> prerequisiteChecks {
                    get {
                        if ((this.prerequisiteChecksField == null)) {
                            this.prerequisiteChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("prerequisiteChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.prerequisiteChecksField;
                    }
                    set {
                        if ((value == null)) {
                            this.prerequisiteChecksField = null;
                        }
                        else {
                            if ((this.prerequisiteChecksField == null)) {
                                this.prerequisiteChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("prerequisiteChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<ChecksType>(this.prerequisiteChecksField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// Indicates that this component implements the specified interface.
                /// </para>
                /// <para>
                /// 
                ///The <publishInterface> element names a unique "interface" to be "published" by this component 
                ///when it is installed.
                ///Note that in this context, the terms "publish", "require" and "interface" only have meaning within Octopus.
                ///These interfaces should not be confused with COM interfaces or any other interfaces that might be 
                ///published with the Windows operating system.
                ///
                ///The publishInterface and requireInterface elements are
                ///the means by which developers can impose ordering upon the installation of their components,
                ///either within a single server, or between servers.
                ///Natively, XML does not support the notion of ordering. The list of aggregateComponent 
                ///elements under a component is considered an unordered collection, 
                ///meaning that there are no guarantees about the order in which two peer components execute. 
                ///A developer can require that another component be installed before the current one by 
                ///requiring an interface that is correspondingly published by the prerequisite component.
                ///A published interface becomes visible to other components once its parent component 
                ///has been executed on a server in the topology. 
                ///Published interfaces are visible to other components that have been associated with 
                ///the same server, or that have been associated with other servers in the same topology.
                /// </para>
                /// <para>
                /// Occurrence: optional, repeating, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.componentsLocalType.componentLocalType.publishInterfaceLocalType> publishInterface {
                    get {
                        if ((this.publishInterfaceField == null)) {
                            this.publishInterfaceField = new XTypedList<publishInterfaceLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("publishInterface", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.publishInterfaceField;
                    }
                    set {
                        if ((value == null)) {
                            this.publishInterfaceField = null;
                        }
                        else {
                            if ((this.publishInterfaceField == null)) {
                                this.publishInterfaceField = XTypedList<publishInterfaceLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("publishInterface", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<publishInterfaceLocalType>(this.publishInterfaceField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// Indicates that the specified interface must be published before this component can be installed.
                /// </para>
                /// <para>
                /// 
                ///The <requireInterface> element names a unique interface that must be published by another component before the current component will install.
                ///
                ///The publishInterface and requireInterface elements are the
                ///means by which developers can impose ordering upon the installation of their components.
                ///
                /// </para>
                /// <para>
                /// Occurrence: optional, repeating, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.componentsLocalType.componentLocalType.requireInterfaceLocalType> requireInterface {
                    get {
                        if ((this.requireInterfaceField == null)) {
                            this.requireInterfaceField = new XTypedList<requireInterfaceLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("requireInterface", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.requireInterfaceField;
                    }
                    set {
                        if ((value == null)) {
                            this.requireInterfaceField = null;
                        }
                        else {
                            if ((this.requireInterfaceField == null)) {
                                this.requireInterfaceField = XTypedList<requireInterfaceLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("requireInterface", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<requireInterfaceLocalType>(this.requireInterfaceField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// References another component that must be installed as part of this component, and before any msi or command action in this component.
                /// </para>
                /// <para>
                /// Occurrence: optional, repeating, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<AggregateComponentType> aggregateComponent {
                    get {
                        if ((this.aggregateComponentField == null)) {
                            this.aggregateComponentField = new XTypedList<AggregateComponentType>(this, LinqToXsdTypeManager.Instance, XName.Get("aggregateComponent", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.aggregateComponentField;
                    }
                    set {
                        if ((value == null)) {
                            this.aggregateComponentField = null;
                        }
                        else {
                            if ((this.aggregateComponentField == null)) {
                                this.aggregateComponentField = XTypedList<AggregateComponentType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("aggregateComponent", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<AggregateComponentType>(this.aggregateComponentField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// This element is DEPRECATED. Use prerequisiteChecks instead.
                /// </para>
                /// <para>
                /// 
                ///                                                        The <checks> element is exactly equivalent to the <prerequisiteChecks> element;
                ///                                                        <checks> is allowed in the service.xml only for compatibility with previous versions of Octopus.
                ///                                                        
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<ChecksType> checks {
                    get {
                        if ((this.checksField == null)) {
                            this.checksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("checks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.checksField;
                    }
                    set {
                        if ((value == null)) {
                            this.checksField = null;
                        }
                        else {
                            if ((this.checksField == null)) {
                                this.checksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<ChecksType>(this.checksField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// An MSI file to be executed.
                /// </para>
                /// <para>
                /// The <msi> element names a Microsoft Windows Installer file that should be executed by the Octopus Agent. The element optionally also specifies properties to pass to the MSI file.All components ultimately reduce to a set of command actions or MSI files. MSI files are the standard Microsoft technology for installing, and uninstalling software on Microsoft Windows machines and documenting what is installed. Although a component may aggregate many msi elements by aggregating other components, only a single msi element may be declared in any given component.The only MSI properties that can be changed on the command line are Public properties: those whose name contains no lowercase letters. Thus, the 'name' attribute of properties defined for the MSI should not contain lowercase letters.
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Setter: Appends
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.componentsLocalType.componentLocalType.msiLocalType> msi {
                    get {
                        if ((this.msiField == null)) {
                            this.msiField = new XTypedList<msiLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("msi", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.msiField;
                    }
                    set {
                        if ((value == null)) {
                            this.msiField = null;
                        }
                        else {
                            if ((this.msiField == null)) {
                                this.msiField = XTypedList<msiLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("msi", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<msiLocalType>(this.msiField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A set of checks which determine whether this component is currently installed.
                /// </para>
                /// <para>
                /// The <installedChecks> element defines a set of checks that determine whether the component is currently installed. During install, if these checks return true, the component action is skipped. During uninstall, if these checks return false, the component action is skipped.
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Setter: Appends
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<ChecksType> installedChecks {
                    get {
                        if ((this.installedChecksField == null)) {
                            this.installedChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("installedChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.installedChecksField;
                    }
                    set {
                        if ((value == null)) {
                            this.installedChecksField = null;
                        }
                        else {
                            if ((this.installedChecksField == null)) {
                                this.installedChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("installedChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<ChecksType>(this.installedChecksField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A command which installs this component.
                /// </para>
                /// <para>
                /// The <installCommand> element specifies an arbitrary command which installs the enclosing component. Optional child elements specify status codes, input files, and output files for the command.
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Setter: Appends
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<CommandType> installCommand {
                    get {
                        if ((this.installCommandField == null)) {
                            this.installCommandField = new XTypedList<CommandType>(this, LinqToXsdTypeManager.Instance, XName.Get("installCommand", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.installCommandField;
                    }
                    set {
                        if ((value == null)) {
                            this.installCommandField = null;
                        }
                        else {
                            if ((this.installCommandField == null)) {
                                this.installCommandField = XTypedList<CommandType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("installCommand", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<CommandType>(this.installCommandField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A command which uninstalls this component.
                /// </para>
                /// <para>
                /// The <uninstallCommand> element specifies an arbitrary command which uninstalls the enclosing component. Optional child elements specify status codes, input files, and output files for the command.
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Setter: Appends
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<CommandType> uninstallCommand {
                    get {
                        if ((this.uninstallCommandField == null)) {
                            this.uninstallCommandField = new XTypedList<CommandType>(this, LinqToXsdTypeManager.Instance, XName.Get("uninstallCommand", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.uninstallCommandField;
                    }
                    set {
                        if ((value == null)) {
                            this.uninstallCommandField = null;
                        }
                        else {
                            if ((this.uninstallCommandField == null)) {
                                this.uninstallCommandField = XTypedList<CommandType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("uninstallCommand", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<CommandType>(this.uninstallCommandField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// Indicates an explicit reboot action.
                /// </para>
                /// <para>
                /// The <reboot> element indicates that the target server should be rebooted when this component is installed and/or uninstalled.
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Setter: Appends
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.componentsLocalType.componentLocalType.rebootLocalType> reboot {
                    get {
                        if ((this.rebootField == null)) {
                            this.rebootField = new XTypedList<rebootLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("reboot", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.rebootField;
                    }
                    set {
                        if ((value == null)) {
                            this.rebootField = null;
                        }
                        else {
                            if ((this.rebootField == null)) {
                                this.rebootField = XTypedList<rebootLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("reboot", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<rebootLocalType>(this.rebootField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A set of checks which can be run after the deployment has been finished.
                /// </para>
                /// <para>
                /// The <postDeploymentChecks> element defines a set of checks that validate a deployment. They can be executed separately from the main deployment using both GUI and CLI.
                /// </para>
                /// <para>
                /// Occurrence: optional, choice
                /// </para>
                /// <para>
                /// Regular expression: (property* | conditionChecks? | prerequisiteChecks? | publishInterface* | requireInterface* | aggregateComponent* | checks? | (msi? | installedChecks? | installCommand? | uninstallCommand? | reboot?)?|postDeploymentChecks?)+
                /// </para>
                /// </summary>
                public IList<ChecksType> postDeploymentChecks {
                    get {
                        if ((this.postDeploymentChecksField == null)) {
                            this.postDeploymentChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("postDeploymentChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.postDeploymentChecksField;
                    }
                    set {
                        if ((value == null)) {
                            this.postDeploymentChecksField = null;
                        }
                        else {
                            if ((this.postDeploymentChecksField == null)) {
                                this.postDeploymentChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("postDeploymentChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<ChecksType>(this.postDeploymentChecksField, value);
                            }
                        }
                    }
                }
                
                /// <summary>
                /// <para>
                /// A name which uniquely identifies this component.
                /// </para>
                /// <para>
                /// Occurrence: required
                /// </para>
                /// </summary>
                public string name {
                    get {
                        XAttribute x = this.Attribute(XName.Get("name", ""));
                        return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                    set {
                        this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                    get {
                        return localElementDictionary;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("component", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<componentLocalType>(this);
                }
                
                private static void BuildElementDictionary() {
                    localElementDictionary.Add(XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(PropertyType));
                    localElementDictionary.Add(XName.Get("conditionChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(ChecksType));
                    localElementDictionary.Add(XName.Get("prerequisiteChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(ChecksType));
                    localElementDictionary.Add(XName.Get("publishInterface", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(publishInterfaceLocalType));
                    localElementDictionary.Add(XName.Get("requireInterface", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(requireInterfaceLocalType));
                    localElementDictionary.Add(XName.Get("aggregateComponent", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(AggregateComponentType));
                    localElementDictionary.Add(XName.Get("checks", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(ChecksType));
                    localElementDictionary.Add(XName.Get("msi", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(msiLocalType));
                    localElementDictionary.Add(XName.Get("installedChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(ChecksType));
                    localElementDictionary.Add(XName.Get("installCommand", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CommandType));
                    localElementDictionary.Add(XName.Get("uninstallCommand", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CommandType));
                    localElementDictionary.Add(XName.Get("reboot", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(rebootLocalType));
                    localElementDictionary.Add(XName.Get("postDeploymentChecks", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(ChecksType));
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
                
                public partial class publishInterfaceLocalType : XTypedElement, IXMetaData {
                    
         public static explicit operator publishInterfaceLocalType(XElement xe) { return XTypedServices.ToXTypedElement<publishInterfaceLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                    
                    public publishInterfaceLocalType() {
                    }
                    
                    /// <summary>
                    /// <para>
                    /// An arbitrary name chosen by the service.xml author.
                    ///
                    /// </para>
                    /// <para>
                    /// Occurrence: required
                    /// </para>
                    /// </summary>
                    public string name {
                        get {
                            XAttribute x = this.Attribute(XName.Get("name", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    XName IXMetaData.SchemaName {
                        get {
                            return XName.Get("publishInterface", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    SchemaOrigin IXMetaData.TypeOrigin {
                        get {
                            return SchemaOrigin.Fragment;
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    ILinqToXsdTypeManager IXMetaData.TypeManager {
                        get {
                            return LinqToXsdTypeManager.Instance;
                        }
                    }
                    
                    public override XTypedElement Clone() {
                        return XTypedServices.CloneXTypedElement<publishInterfaceLocalType>(this);
                    }
                    
                    ContentModelEntity IXMetaData.GetContentModel() {
                        return ContentModelEntity.Default;
                    }
                }
                
                public partial class requireInterfaceLocalType : XTypedElement, IXMetaData {
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    private static string waitDefaultValue = "all";
                    
         public static explicit operator requireInterfaceLocalType(XElement xe) { return XTypedServices.ToXTypedElement<requireInterfaceLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                    
                    public requireInterfaceLocalType() {
                    }
                    
                    /// <summary>
                    /// <para>
                    /// The name of the interface. This must correspond to the name of some <publishInterface> element elsewhere in the service.xml file.
                    /// </para>
                    /// <para>
                    /// Occurrence: required
                    /// </para>
                    /// </summary>
                    public string name {
                        get {
                            XAttribute x = this.Attribute(XName.Get("name", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    /// <summary>
                    /// <para>
                    /// Specifies whether the dependency is within a single server or cross-server.
                    /// </para>
                    /// <para>
                    /// The wait attribute may take any of the following values:allThe component will wait until all instances of the specified interface are published.anyThe component may be installed as soon as any instance of the specified interface is published.sameThe component will wait for the specified interface to be published on the same server on which the component is being installed.
                    /// </para>
                    /// <para>
                    /// Occurrence: optional
                    /// </para>
                    /// </summary>
                    public string wait {
                        get {
                            XAttribute x = this.Attribute(XName.Get("wait", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, waitDefaultValue);
                        }
                        set {
                            this.SetAttribute(XName.Get("wait", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    XName IXMetaData.SchemaName {
                        get {
                            return XName.Get("requireInterface", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    SchemaOrigin IXMetaData.TypeOrigin {
                        get {
                            return SchemaOrigin.Fragment;
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    ILinqToXsdTypeManager IXMetaData.TypeManager {
                        get {
                            return LinqToXsdTypeManager.Instance;
                        }
                    }
                    
                    public override XTypedElement Clone() {
                        return XTypedServices.CloneXTypedElement<requireInterfaceLocalType>(this);
                    }
                    
                    ContentModelEntity IXMetaData.GetContentModel() {
                        return ContentModelEntity.Default;
                    }
                }
                
                /// <summary>
                /// <para>
                /// Regular expression: (property*)*
                /// </para>
                /// </summary>
                public partial class msiLocalType : XTypedElement, IXMetaData {
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    private XTypedList<PropertyType> propertyField;
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
                    
         public static explicit operator msiLocalType(XElement xe) { return XTypedServices.ToXTypedElement<msiLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                    
                    static msiLocalType() {
                        BuildElementDictionary();
                    }
                    
                    /// <summary>
                    /// <para>
                    /// Regular expression: (property*)*
                    /// </para>
                    /// </summary>
                    public msiLocalType() {
                    }
                    
                    /// <summary>
                    /// <para>
                    /// A property to pass to the MSI file as a command-line parameter.
                    /// </para>
                    /// <para>
                    /// Occurrence: optional, repeating, choice
                    /// </para>
                    /// <para>
                    /// Regular expression: (property*)*
                    /// </para>
                    /// </summary>
                    public IList<PropertyType> property {
                        get {
                            if ((this.propertyField == null)) {
                                this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            return this.propertyField;
                        }
                        set {
                            if ((value == null)) {
                                this.propertyField = null;
                            }
                            else {
                                if ((this.propertyField == null)) {
                                    this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                                }
                                else {
                                    XTypedServices.SetList<PropertyType>(this.propertyField, value);
                                }
                            }
                        }
                    }
                    
                    /// <summary>
                    /// <para>
                    /// The file system path of the MSI file, relative to the directory containing the service.xml file. In most cases the MSI files are in the same directory as the service.xml file, so the MSI path is a simple file name, but it may be convenient in some cases to put MSI files in subdirectories.
                    /// </para>
                    /// <para>
                    /// Occurrence: required
                    /// </para>
                    /// </summary>
                    public string path {
                        get {
                            XAttribute x = this.Attribute(XName.Get("path", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    /// <summary>
                    /// <para>
                    /// Normally properties are not passed to MSI files when uninstalling. Set this attribute to "true" to specify that this MSI file requires properties for uninstall. This option can also be set globally for all MSI files by setting the attribute on the <service> element.
                    /// </para>
                    /// <para>
                    /// Occurrence: optional
                    /// </para>
                    /// </summary>
                    public System.Nullable<bool> passPropertiesOnUninstall {
                        get {
                            XAttribute x = this.Attribute(XName.Get("passPropertiesOnUninstall", ""));
                            if ((x == null)) {
                                return null;
                            }
                            return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("passPropertiesOnUninstall", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                        get {
                            return localElementDictionary;
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    XName IXMetaData.SchemaName {
                        get {
                            return XName.Get("msi", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    SchemaOrigin IXMetaData.TypeOrigin {
                        get {
                            return SchemaOrigin.Fragment;
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    ILinqToXsdTypeManager IXMetaData.TypeManager {
                        get {
                            return LinqToXsdTypeManager.Instance;
                        }
                    }
                    
                    public override XTypedElement Clone() {
                        return XTypedServices.CloneXTypedElement<msiLocalType>(this);
                    }
                    
                    private static void BuildElementDictionary() {
                        localElementDictionary.Add(XName.Get("property", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(PropertyType));
                    }
                    
                    ContentModelEntity IXMetaData.GetContentModel() {
                        return ContentModelEntity.Default;
                    }
                }
                
                public partial class rebootLocalType : XTypedElement, IXMetaData {
                    
         public static explicit operator rebootLocalType(XElement xe) { return XTypedServices.ToXTypedElement<rebootLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                    
                    public rebootLocalType() {
                    }
                    
                    /// <summary>
                    /// <para>
                    /// Set this attribute to "true" to indicate that the server should be rebooted when the component is installed, or "false" to indicate that this component does not cause the server to be rebooted during install.
                    /// </para>
                    /// <para>
                    /// Occurrence: required
                    /// </para>
                    /// </summary>
                    public bool onInstall {
                        get {
                            XAttribute x = this.Attribute(XName.Get("onInstall", ""));
                            return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("onInstall", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                        }
                    }
                    
                    /// <summary>
                    /// <para>
                    /// Set this attribute to "true" to indicate that the server should be rebooted when the component is uninstalled, or "false" to indicate that this component does not cause the server to be rebooted during uninstall.
                    /// </para>
                    /// <para>
                    /// Occurrence: required
                    /// </para>
                    /// </summary>
                    public bool onUninstall {
                        get {
                            XAttribute x = this.Attribute(XName.Get("onUninstall", ""));
                            return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("onUninstall", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    XName IXMetaData.SchemaName {
                        get {
                            return XName.Get("reboot", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    SchemaOrigin IXMetaData.TypeOrigin {
                        get {
                            return SchemaOrigin.Fragment;
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    ILinqToXsdTypeManager IXMetaData.TypeManager {
                        get {
                            return LinqToXsdTypeManager.Instance;
                        }
                    }
                    
                    public override XTypedElement Clone() {
                        return XTypedServices.CloneXTypedElement<rebootLocalType>(this);
                    }
                    
                    ContentModelEntity IXMetaData.GetContentModel() {
                        return ContentModelEntity.Default;
                    }
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the servers attribute of publishComponent elements.
    /// </para>
    /// </summary>
    public sealed class PublishServersType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "all",
                        "select"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private PublishServersType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the method attribute of checkFile or checkRegistry elements.
    /// </para>
    /// </summary>
    public sealed class CompareMethodType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "eq",
                        "ex",
                        "ge",
                        "gt",
                        "le",
                        "lt",
                        "neq",
                        "nex"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private CompareMethodType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the type attribute of checkRegistry elements.
    /// </para>
    /// </summary>
    public sealed class RegistryValueType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "dword",
                        "string",
                        "version"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private RegistryValueType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the type attribute of checkValue elements.
    /// </para>
    /// </summary>
    public sealed class PropertyValueType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "integer",
                        "string",
                        "version"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private PropertyValueType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the wait attribute of requireInterface elements.
    /// </para>
    /// </summary>
    public sealed class InterfaceWaitType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "all",
                        "any",
                        "same"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private InterfaceWaitType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the type attribute of serverList elements.
    /// </para>
    /// </summary>
    public sealed class ServerListTypeType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "component",
                        "publishInterface",
                        "requireInterface"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ServerListTypeType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the startup attribute of CheckService elements.
    /// </para>
    /// </summary>
    public sealed class ServiceStartupType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "automatic",
                        "disabled",
                        "enabled",
                        "manual",
                        "ignore"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ServiceStartupType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the status attribute of CheckService elements.
    /// </para>
    /// </summary>
    public sealed class ServiceStatusType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "absent",
                        "started",
                        "stopped",
                        "ignore"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ServiceStatusType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the type attribute of statusCode elements.
    /// </para>
    /// </summary>
    public sealed class StatusCodeTypeType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "failure",
                        "warning",
                        "success",
                        "success_reboot",
                        "reboot_rerun"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private StatusCodeTypeType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// A set of checks to be performed at the domain level before beginning deployment.
    /// </para>
    /// <para>
    /// 
    ///The <domainChecks> element describes one or more atomic checks that will be performed before the Octopus Deployment Framework acts upon the surrounding service or topology element. All of the child elements of the check must return successfully for the domainChecks element to return success.
    ///
    ///This element lists check operations that are meaningful in the context of a Windows domain. This distinguishes domainChecks from the checks under a component element, which are meaningful in the context of an individual server.
    ///
    ///Domain checks are useful to detect flawed system setups before proceeding with a full deployment. In many Operatonal environments, access to the Active Directory is restricted, meaning that domain users and groups must be created manually in advance of automated deployment. If an account is mis-named, has the wrong password, or is not a member of the correct groups, installation might proceed despite the fact that the service will not run correctly. Developers can require domain checks before deploying to avoid this problem.
    ///
    ///The Octopus Deployment Framework and Console support a "check only" mode in which all checks are run against a set of servers, but no components are executed. Operators can run a "check only" test against their bed before committing time to a full deployment.
    ///
    /// </para>
    /// <para>
    /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
    /// </para>
    /// </summary>
    public partial class DomainChecksType : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.ChecksType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator DomainChecksType(XElement xe) { return XTypedServices.ToXTypedElement<DomainChecksType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static DomainChecksType() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// A set of checks to be performed at the domain level before beginning deployment.
        /// </para>
        /// <para>
        /// 
        ///The <domainChecks> element describes one or more atomic checks that will be performed before the Octopus Deployment Framework acts upon the surrounding service or topology element. All of the child elements of the check must return successfully for the domainChecks element to return success.
        ///
        ///This element lists check operations that are meaningful in the context of a Windows domain. This distinguishes domainChecks from the checks under a component element, which are meaningful in the context of an individual server.
        ///
        ///Domain checks are useful to detect flawed system setups before proceeding with a full deployment. In many Operatonal environments, access to the Active Directory is restricted, meaning that domain users and groups must be created manually in advance of automated deployment. If an account is mis-named, has the wrong password, or is not a member of the correct groups, installation might proceed despite the fact that the service will not run correctly. Developers can require domain checks before deploying to avoid this problem.
        ///
        ///The Octopus Deployment Framework and Console support a "check only" mode in which all checks are run against a set of servers, but no components are executed. Operators can run a "check only" test against their bed before committing time to a full deployment.
        ///
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public DomainChecksType() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("DomainChecksType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DomainChecksType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckUser));
            localElementDictionary.Add(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckGroup));
            localElementDictionary.Add(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckGroupMembership));
            localElementDictionary.Add(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckDrive));
            localElementDictionary.Add(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckFile));
            localElementDictionary.Add(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckFolder));
            localElementDictionary.Add(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckValue));
            localElementDictionary.Add(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckRegistry));
            localElementDictionary.Add(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckService));
            localElementDictionary.Add(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckWebSite));
            localElementDictionary.Add(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CommandCheck));
            localElementDictionary.Add(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(XTypedElement));
            localElementDictionary.Add(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(XTypedElement));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(3, new Transitions(new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(5, new Transitions(new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(7, new Transitions(new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(9, new Transitions(new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(11, new Transitions(new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(13, new Transitions(new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(15, new Transitions(new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(17, new Transitions(new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(19, new Transitions(new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(21, new Transitions(new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(23, new Transitions(new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(25, new Transitions(new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(27, new Transitions(new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(29, new Transitions(new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(31, new Transitions(new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(33, new Transitions(new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            1,
                            3,
                            5,
                            7,
                            9,
                            11,
                            13,
                            15,
                            17,
                            19,
                            21,
                            23,
                            25,
                            27,
                            29,
                            31,
                            33}), transitions);
        }
    }
    
    /// <summary>
    /// <para>
    /// A property to be passed to a lower-level entity.
    /// </para>
    /// <para>
    /// The passProperty element is used to override the value of a property in a published or aggregated component with the value of a local property or static value.The passProperty 'value' attribute may refer to the value of another property - for example a local userInput property - as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan".Of course, the 'value' attribute of passProperty may also be a static value defined by the service manifest developer.
    /// </para>
    /// </summary>
    public partial class PassPropertyType : XTypedElement, IXMetaData {
        
         public static explicit operator PassPropertyType(XElement xe) { return XTypedServices.ToXTypedElement<PassPropertyType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// A property to be passed to a lower-level entity.
        /// </para>
        /// <para>
        /// The passProperty element is used to override the value of a property in a published or aggregated component with the value of a local property or static value.The passProperty 'value' attribute may refer to the value of another property - for example a local userInput property - as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan".Of course, the 'value' attribute of passProperty may also be a static value defined by the service manifest developer.
        /// </para>
        /// </summary>
        public PassPropertyType() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the property being overridden.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The value to use for the property.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string value {
            get {
                XAttribute x = this.Attribute(XName.Get("value", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("PassPropertyType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<PassPropertyType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A property definition.
    /// </para>
    /// <para>
    /// 
    ///The <property> element is used throughout a service manifest to obtain user input and reconcile that input with predefined values. The values of properties may be entered by users, set 