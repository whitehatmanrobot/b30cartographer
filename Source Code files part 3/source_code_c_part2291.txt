__
#define __IWMRMCoding_FWD_DEFINED__
typedef interface IWMRMCoding IWMRMCoding;
#endif 	/* __IWMRMCoding_FWD_DEFINED__ */


#ifndef __IWMRMKeys_FWD_DEFINED__
#define __IWMRMKeys_FWD_DEFINED__
typedef interface IWMRMKeys IWMRMKeys;
#endif 	/* __IWMRMKeys_FWD_DEFINED__ */


#ifndef __IWMRMKeys2_FWD_DEFINED__
#define __IWMRMKeys2_FWD_DEFINED__
typedef interface IWMRMKeys2 IWMRMKeys2;
#endif 	/* __IWMRMKeys2_FWD_DEFINED__ */


#ifndef __IWMRMLicenseStateData_FWD_DEFINED__
#define __IWMRMLicenseStateData_FWD_DEFINED__
typedef interface IWMRMLicenseStateData IWMRMLicenseStateData;
#endif 	/* __IWMRMLicenseStateData_FWD_DEFINED__ */


#ifndef __IWMRMUplink_FWD_DEFINED__
#define __IWMRMUplink_FWD_DEFINED__
typedef interface IWMRMUplink IWMRMUplink;
#endif 	/* __IWMRMUplink_FWD_DEFINED__ */


#ifndef __IWMRMUplinkCollection_FWD_DEFINED__
#define __IWMRMUplinkCollection_FWD_DEFINED__
typedef interface IWMRMUplinkCollection IWMRMUplinkCollection;
#endif 	/* __IWMRMUplinkCollection_FWD_DEFINED__ */


#ifndef __IWMRMChallenge_FWD_DEFINED__
#define __IWMRMChallenge_FWD_DEFINED__
typedef interface IWMRMChallenge IWMRMChallenge;
#endif 	/* __IWMRMChallenge_FWD_DEFINED__ */


#ifndef __IWMRMChallenge2_FWD_DEFINED__
#define __IWMRMChallenge2_FWD_DEFINED__
typedef interface IWMRMChallenge2 IWMRMChallenge2;
#endif 	/* __IWMRMChallenge2_FWD_DEFINED__ */


#ifndef __IWMRMChallenge3_FWD_DEFINED__
#define __IWMRMChallenge3_FWD_DEFINED__
typedef interface IWMRMChallenge3 IWMRMChallenge3;
#endif 	/* __IWMRMChallenge3_FWD_DEFINED__ */


#ifndef __IWMRMChallenge4_FWD_DEFINED__
#define __IWMRMChallenge4_FWD_DEFINED__
typedef interface IWMRMChallenge4 IWMRMChallenge4;
#endif 	/* __IWMRMChallenge4_FWD_DEFINED__ */


#ifndef __IWMRMLicGen_FWD_DEFINED__
#define __IWMRMLicGen_FWD_DEFINED__
typedef interface IWMRMLicGen IWMRMLicGen;
#endif 	/* __IWMRMLicGen_FWD_DEFINED__ */


#ifndef __IWMRMLicGen2_FWD_DEFINED__
#define __IWMRMLicGen2_FWD_DEFINED__
typedef interface IWMRMLicGen2 IWMRMLicGen2;
#endif 	/* __IWMRMLicGen2_FWD_DEFINED__ */


#ifndef __IWMRMLicGen3_FWD_DEFINED__
#define __IWMRMLicGen3_FWD_DEFINED__
typedef interface IWMRMLicGen3 IWMRMLicGen3;
#endif 	/* __IWMRMLicGen3_FWD_DEFINED__ */


#ifndef __IWMRMLicGen4_FWD_DEFINED__
#define __IWMRMLicGen4_FWD_DEFINED__
typedef interface IWMRMLicGen4 IWMRMLicGen4;
#endif 	/* __IWMRMLicGen4_FWD_DEFINED__ */


#ifndef __IWMRMLicGen5_FWD_DEFINED__
#define __IWMRMLicGen5_FWD_DEFINED__
typedef interface IWMRMLicGen5 IWMRMLicGen5;
#endif 	/* __IWMRMLicGen5_FWD_DEFINED__ */


#ifndef __IWMRMRights_FWD_DEFINED__
#define __IWMRMRights_FWD_DEFINED__
typedef interface IWMRMRights IWMRMRights;
#endif 	/* __IWMRMRights_FWD_DEFINED__ */


#ifndef __IWMRMRights2_FWD_DEFINED__
#define __IWMRMRights2_FWD_DEFINED__
typedef interface IWMRMRights2 IWMRMRights2;
#endif 	/* __IWMRMRights2_FWD_DEFINED__ */


#ifndef __IWMRMRights3_FWD_DEFINED__
#define __IWMRMRights3_FWD_DEFINED__
typedef interface IWMRMRights3 IWMRMRights3;
#endif 	/* __IWMRMRights3_FWD_DEFINED__ */


#ifndef __IWMRMResponse_FWD_DEFINED__
#define __IWMRMResponse_FWD_DEFINED__
typedef interface IWMRMResponse IWMRMResponse;
#endif 	/* __IWMRMResponse_FWD_DEFINED__ */


#ifndef __IWMRMResponse2_FWD_DEFINED__
#define __IWMRMResponse2_FWD_DEFINED__
typedef interface IWMRMResponse2 IWMRMResponse2;
#endif 	/* __IWMRMResponse2_FWD_DEFINED__ */


#ifndef __IWMRMTools_FWD_DEFINED__
#define __IWMRMTools_FWD_DEFINED__
typedef interface IWMRMTools IWMRMTools;
#endif 	/* __IWMRMTools_FWD_DEFINED__ */


#ifndef __IWMRMHeaderSigning_FWD_DEFINED__
#define __IWMRMHeaderSigning_FWD_DEFINED__
typedef interface IWMRMHeaderSigning IWMRMHeaderSigning;
#endif 	/* __IWMRMHeaderSigning_FWD_DEFINED__ */


#ifndef __IWMRMMetering_FWD_DEFINED__
#define __IWMRMMetering_FWD_DEFINED__
typedef interface IWMRMMetering IWMRMMetering;
#endif 	/* __IWMRMMetering_FWD_DEFINED__ */


#ifndef __IWMRMMeteringData_FWD_DEFINED__
#define __IWMRMMeteringData_FWD_DEFINED__
typedef interface IWMRMMeteringData IWMRMMeteringData;
#endif 	/* __IWMRMMeteringData_FWD_DEFINED__ */


#ifndef __IWMRMMeteringContentCollection_FWD_DEFINED__
#define __IWMRMMeteringContentCollection_FWD_DEFINED__
typedef interface IWMRMMeteringContentCollection IWMRMMeteringContentCollection;
#endif 	/* __IWMRMMeteringContentCollection_FWD_DEFINED__ */


#ifndef __IWMRMMeteringContent_FWD_DEFINED__
#define __IWMRMMeteringContent_FWD_DEFINED__
typedef interface IWMRMMeteringContent IWMRMMeteringContent;
#endif 	/* __IWMRMMeteringContent_FWD_DEFINED__ */


#ifndef __IWMRMMeteringActionCollection_FWD_DEFINED__
#define __IWMRMMeteringActionCollection_FWD_DEFINED__
typedef interface IWMRMMeteringActionCollection IWMRMMeteringActionCollection;
#endif 	/* __IWMRMMeteringActionCollection_FWD_DEFINED__ */


#ifndef __IWMRMMeteringAction_FWD_DEFINED__
#define __IWMRMMeteringAction_FWD_DEFINED__
typedef interface IWMRMMeteringAction IWMRMMeteringAction;
#endif 	/* __IWMRMMeteringAction_FWD_DEFINED__ */


#ifndef __IWMRMRestrictions_FWD_DEFINED__
#define __IWMRMRestrictions_FWD_DEFINED__
typedef interface IWMRMRestrictions IWMRMRestrictions;
#endif 	/* __IWMRMRestrictions_FWD_DEFINED__ */


#ifndef __IWMRMRestrictions2_FWD_DEFINED__
#define __IWMRMRestrictions2_FWD_DEFINED__
typedef interface IWMRMRestrictions2 IWMRMRestrictions2;
#endif 	/* __IWMRMRestrictions2_FWD_DEFINED__ */


#ifndef __IWMRMLicenseRevocationAcknowledger_FWD_DEFINED__
#define __IWMRMLicenseRevocationAcknowledger_FWD_DEFINED__
typedef interface IWMRMLicenseRevocationAcknowledger IWMRMLicenseRevocationAcknowledger;
#endif 	/* __IWMRMLicenseRevocationAcknowledger_FWD_DEFINED__ */


#ifndef __IWMRMLicenseRevocationChallenge_FWD_DEFINED__
#define __IWMRMLicenseRevocationChallenge_FWD_DEFINED__
typedef interface IWMRMLicenseRevocationChallenge IWMRMLicenseRevocationChallenge;
#endif 	/* __IWMRMLicenseRevocationChallenge_FWD_DEFINED__ */


#ifndef __IWMRMLicenseRevocationResponse_FWD_DEFINED__
#define __IWMRMLicenseRevocationResponse_FWD_DEFINED__
typedef interface IWMRMLicenseRevocationResponse IWMRMLicenseRevocationResponse;
#endif 	/* __IWMRMLicenseRevocationResponse_FWD_DEFINED__ */


#ifndef __WMRMProtect_FWD_DEFINED__
#define __WMRMProtect_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMProtect WMRMProtect;
#else
typedef struct WMRMProtect WMRMProtect;
#endif /* __cplusplus */

#endif 	/* __WMRMProtect_FWD_DEFINED__ */


#ifndef __WMRMHeader_FWD_DEFINED__
#define __WMRMHeader_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMHeader WMRMHeader;
#else
typedef struct WMRMHeader WMRMHeader;
#endif /* __cplusplus */

#endif 	/* __WMRMHeader_FWD_DEFINED__ */


#ifndef __WMRMCoding_FWD_DEFINED__
#define __WMRMCoding_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMCoding WMRMCoding;
#else
typedef struct WMRMCoding WMRMCoding;
#endif /* __cplusplus */

#endif 	/* __WMRMCoding_FWD_DEFINED__ */


#ifndef __WMRMKeys_FWD_DEFINED__
#define __WMRMKeys_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMKeys WMRMKeys;
#else
typedef struct WMRMKeys WMRMKeys;
#endif /* __cplusplus */

#endif 	/* __WMRMKeys_FWD_DEFINED__ */


#ifndef __WMRMChallenge_FWD_DEFINED__
#define __WMRMChallenge_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMChallenge WMRMChallenge;
#else
typedef struct WMRMChallenge WMRMChallenge;
#endif /* __cplusplus */

#endif 	/* __WMRMChallenge_FWD_DEFINED__ */


#ifndef __WMRMLicGen_FWD_DEFINED__
#define __WMRMLicGen_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMLicGen WMRMLicGen;
#else
typedef struct WMRMLicGen WMRMLicGen;
#endif /* __cplusplus */

#endif 	/* __WMRMLicGen_FWD_DEFINED__ */


#ifndef __WMRMRights_FWD_DEFINED__
#define __WMRMRights_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMRights WMRMRights;
#else
typedef struct WMRMRights WMRMRights;
#endif /* __cplusplus */

#endif 	/* __WMRMRights_FWD_DEFINED__ */


#ifndef __WMRMResponse_FWD_DEFINED__
#define __WMRMResponse_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMResponse WMRMResponse;
#else
typedef struct WMRMResponse WMRMResponse;
#endif /* __cplusplus */

#endif 	/* __WMRMResponse_FWD_DEFINED__ */


#ifndef __WMRMTools_FWD_DEFINED__
#define __WMRMTools_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMTools WMRMTools;
#else
typedef struct WMRMTools WMRMTools;
#endif /* __cplusplus */

#endif 	/* __WMRMTools_FWD_DEFINED__ */


#ifndef __WMRMMetering_FWD_DEFINED__
#define __WMRMMetering_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMMetering WMRMMetering;
#else
typedef struct WMRMMetering WMRMMetering;
#endif /* __cplusplus */

#endif 	/* __WMRMMetering_FWD_DEFINED__ */


#ifndef __WMRMRestrictions_FWD_DEFINED__
#define __WMRMRestrictions_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMRestrictions WMRMRestrictions;
#else
typedef struct WMRMRestrictions WMRMRestrictions;
#endif /* __cplusplus */

#endif 	/* __WMRMRestrictions_FWD_DEFINED__ */


#ifndef __WMRMLicenseRevocationAcknowledger_FWD_DEFINED__
#define __WMRMLicenseRevocationAcknowledger_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMLicenseRevocationAcknowledger WMRMLicenseRevocationAcknowledger;
#else
typedef struct WMRMLicenseRevocationAcknowledger WMRMLicenseRevocationAcknowledger;
#endif /* __cplusplus */

#endif 	/* __WMRMLicenseRevocationAcknowledger_FWD_DEFINED__ */


#ifndef __WMRMLicenseRevocationChallenge_FWD_DEFINED__
#define __WMRMLicenseRevocationChallenge_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMLicenseRevocationChallenge WMRMLicenseRevocationChallenge;
#else
typedef struct WMRMLicenseRevocationChallenge WMRMLicenseRevocationChallenge;
#endif /* __cplusplus */

#endif 	/* __WMRMLicenseRevocationChallenge_FWD_DEFINED__ */


#ifndef __WMRMLicenseRevocationResponse_FWD_DEFINED__
#define __WMRMLicenseRevocationResponse_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMRMLicenseRevocationResponse WMRMLicenseRevocationResponse;
#else
typedef struct WMRMLicenseRevocationResponse WMRMLicenseRevocationResponse;
#endif /* __cplusplus */

#endif 	/* __WMRMLicenseRevocationResponse_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmrmobjs_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//=========================================================================
///////////////////////////////////////////////////////////////////////////
//
// These are the valid cert types for IWMRMKeys2::GetCertificate
//
static const WCHAR g_wszLSHeaderSigningCert[]  = L"LSHeaderSigningCert";
static const WCHAR g_wszLSLicenseSigningCert[] = L"LSLicenseSigningCert";
static const WCHAR g_wszLSRootCert[]           = L"LSRootCert";
//
///////////////////////////////////////////////////////////////////////////






typedef 
enum WMRM_RESTRICTION_TYPE
    {	WMRM_UNCOMPRESSEDDIGITALVIDEO	= 0x1,
	WMRM_COMPRESSEDDIGITALVIDEO	= 0x2,
	WMRM_ANALOGVIDEO	= 0x3,
	WMRM_COMPRESSEDDIGITALAUDIO	= 0x4,
	WMRM_UNCOMPRESSEDDIGITALAUDIO	= 0x5,
	WMRM_COPY	= 0x6
    } 	WMRM_RESTRICTION_TYPE;

typedef 
enum WMRM_LICENSE_STATE_CATEGORY
    {	WMRM_LICENSE_STATE_NORIGHT	= 0,
	WMRM_LICENSE_STATE_UNLIM	= WMRM_LICENSE_STATE_NORIGHT + 1,
	WMRM_LICENSE_STATE_COUNT	= WMRM_LICENSE_STATE_UNLIM + 1,
	WMRM_LICENSE_STATE_FROM	= WMRM_LICENSE_STATE_COUNT + 1,
	WMRM_LICENSE_STATE_UNTIL	= WMRM_LICENSE_STATE_FROM + 1,
	WMRM_LICENSE_STATE_FROM_UNTIL	= WMRM_LICENSE_STATE_UNTIL + 1,
	WMRM_LICENSE_STATE_COUNT_FROM	= WMRM_LICENSE_STATE_FROM_UNTIL + 1,
	WMRM_LICENSE_STATE_COUNT_UNTIL	= WMRM_LICENSE_STATE_COUNT_FROM + 1,
	WMRM_LICENSE_STATE_COUNT_FROM_UNTIL	= WMRM_LICENSE_STATE_COUNT_UNTIL + 1,
	WMRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE	= WMRM_LICENSE_STATE_COUNT_FROM_UNTIL + 1
    } 	WMRM_LICENSE_STATE_CATEGORY;



extern RPC_IF_HANDLE __MIDL_itf_wmrmobjs_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmrmobjs_0000_v0_0_s_ifspec;

#ifndef __IWMRMProtect_INTERFACE_DEFINED__
#define __IWMRMProtect_INTERFACE_DEFINED__

/* interface IWMRMProtect */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMProtect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5B888AAC-5761-4201-959E-62B9EA9406C4")
    IWMRMProtect : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InputFile( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_InputFile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_V1LicenseAcqURL( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_V1LicenseAcqURL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Header( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Header( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProtectFile( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteFile( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_V1KeyID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_V1KeyID( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMProtectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMProtect * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMProtect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMProtect * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMProtect * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMProtect * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMProtect * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMProtect * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InputFile )( 
            IWMRMProtect * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InputFile )( 
            IWMRMProtect * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_V1LicenseAcqURL )( 
            IWMRMProtect * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_V1LicenseAcqURL )( 
            IWMRMProtect * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IWMRMProtect * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IWMRMProtect * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Header )( 
            IWMRMProtect * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Header )( 
            IWMRMProtect * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ProtectFile )( 
            IWMRMProtect * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteFile )( 
            IWMRMProtect * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_V1KeyID )( 
            IWMRMProtect * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_V1KeyID )( 
            IWMRMProtect * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IWMRMProtectVtbl;

    interface IWMRMProtect
    {
        CONST_VTBL struct IWMRMProtectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMProtect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMProtect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMProtect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMProtect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMProtect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMProtect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMProtect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMProtect_get_InputFile(This,pVal)	\
    (This)->lpVtbl -> get_InputFile(This,pVal)

#define IWMRMProtect_put_InputFile(This,newVal)	\
    (This)->lpVtbl -> put_InputFile(This,newVal)

#define IWMRMProtect_get_V1LicenseAcqURL(This,pVal)	\
    (This)->lpVtbl -> get_V1LicenseAcqURL(This,pVal)

#define IWMRMProtect_put_V1LicenseAcqURL(This,newVal)	\
    (This)->lpVtbl -> put_V1LicenseAcqURL(This,newVal)

#define IWMRMProtect_get_Key(This,pVal)	\
    (This)->lpVtbl -> get_Key(This,pVal)

#define IWMRMProtect_put_Key(This,newVal)	\
    (This)->lpVtbl -> put_Key(This,newVal)

#define IWMRMProtect_get_Header(This,pVal)	\
    (This)->lpVtbl -> get_Header(This,pVal)

#define IWMRMProtect_put_Header(This,newVal)	\
    (This)->lpVtbl -> put_Header(This,newVal)

#define IWMRMProtect_ProtectFile(This,bstrFileName)	\
    (This)->lpVtbl -> ProtectFile(This,bstrFileName)

#define IWMRMProtect_WriteFile(This,bstrFileName)	\
    (This)->lpVtbl -> WriteFile(This,bstrFileName)

#define IWMRMProtect_get_V1KeyID(This,pVal)	\
    (This)->lpVtbl -> get_V1KeyID(This,pVal)

#define IWMRMProtect_put_V1KeyID(This,newVal)	\
    (This)->lpVtbl -> put_V1KeyID(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_get_InputFile_Proxy( 
    IWMRMProtect * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMProtect_get_InputFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_put_InputFile_Proxy( 
    IWMRMProtect * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMProtect_put_InputFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_get_V1LicenseAcqURL_Proxy( 
    IWMRMProtect * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMProtect_get_V1LicenseAcqURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_put_V1LicenseAcqURL_Proxy( 
    IWMRMProtect * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMProtect_put_V1LicenseAcqURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_get_Key_Proxy( 
    IWMRMProtect * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMProtect_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_put_Key_Proxy( 
    IWMRMProtect * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMProtect_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_get_Header_Proxy( 
    IWMRMProtect * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMProtect_get_Header_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_put_Header_Proxy( 
    IWMRMProtect * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMProtect_put_Header_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_ProtectFile_Proxy( 
    IWMRMProtect * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IWMRMProtect_ProtectFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_WriteFile_Proxy( 
    IWMRMProtect * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IWMRMProtect_WriteFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_get_V1KeyID_Proxy( 
    IWMRMProtect * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMProtect_get_V1KeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMProtect_put_V1KeyID_Proxy( 
    IWMRMProtect * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMProtect_put_V1KeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMProtect_INTERFACE_DEFINED__ */


#ifndef __IWMRMHeader_INTERFACE_DEFINED__
#define __IWMRMHeader_INTERFACE_DEFINED__

/* interface IWMRMHeader */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMHeader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0B4ECB7A-5F65-4C65-B509-F0BAA2043BC9")
    IWMRMHeader : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Header( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Header( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_KeyID( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ContentID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ContentID( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IndividualizedVersion( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IndividualizedVersion( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LicenseAcqURL( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LicenseAcqURL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attribute( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attribute( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Sign( 
            /* [in] */ BSTR bstrPrivKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Verify( 
            /* [in] */ BSTR bstrPubKey,
            /* [retval][out] */ LONG *plResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetCheckSum( 
            /* [in] */ BSTR bstrKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMHeaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMHeader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMHeader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMHeader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMHeader * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMHeader * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMHeader * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMHeader * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Header )( 
            IWMRMHeader * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Header )( 
            IWMRMHeader * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IWMRMHeader * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMHeader * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMHeader * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentID )( 
            IWMRMHeader * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContentID )( 
            IWMRMHeader * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IndividualizedVersion )( 
            IWMRMHeader * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IndividualizedVersion )( 
            IWMRMHeader * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LicenseAcqURL )( 
            IWMRMHeader * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LicenseAcqURL )( 
            IWMRMHeader * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IWMRMHeader * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IWMRMHeader * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Sign )( 
            IWMRMHeader * This,
            /* [in] */ BSTR bstrPrivKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Verify )( 
            IWMRMHeader * This,
            /* [in] */ BSTR bstrPubKey,
            /* [retval][out] */ LONG *plResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetCheckSum )( 
            IWMRMHeader * This,
            /* [in] */ BSTR bstrKey);
        
        END_INTERFACE
    } IWMRMHeaderVtbl;

    interface IWMRMHeader
    {
        CONST_VTBL struct IWMRMHeaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMHeader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMHeader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMHeader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMHeader_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMHeader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMHeader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMHeader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMHeader_get_Header(This,pVal)	\
    (This)->lpVtbl -> get_Header(This,pVal)

#define IWMRMHeader_put_Header(This,newVal)	\
    (This)->lpVtbl -> put_Header(This,newVal)

#define IWMRMHeader_get_Version(This,pVal)	\
    (This)->lpVtbl -> get_Version(This,pVal)

#define IWMRMHeader_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMHeader_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMHeader_get_ContentID(This,pVal)	\
    (This)->lpVtbl -> get_ContentID(This,pVal)

#define IWMRMHeader_put_ContentID(This,newVal)	\
    (This)->lpVtbl -> put_ContentID(This,newVal)

#define IWMRMHeader_get_IndividualizedVersion(This,pVal)	\
    (This)->lpVtbl -> get_IndividualizedVersion(This,pVal)

#define IWMRMHeader_put_IndividualizedVersion(This,newVal)	\
    (This)->lpVtbl -> put_IndividualizedVersion(This,newVal)

#define IWMRMHeader_get_LicenseAcqURL(This,pVal)	\
    (This)->lpVtbl -> get_LicenseAcqURL(This,pVal)

#define IWMRMHeader_put_LicenseAcqURL(This,newVal)	\
    (This)->lpVtbl -> put_LicenseAcqURL(This,newVal)

#define IWMRMHeader_get_Attribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,bstrName,pVal)

#define IWMRMHeader_put_Attribute(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,bstrName,newVal)

#define IWMRMHeader_Sign(This,bstrPrivKey)	\
    (This)->lpVtbl -> Sign(This,bstrPrivKey)

#define IWMRMHeader_Verify(This,bstrPubKey,plResult)	\
    (This)->lpVtbl -> Verify(This,bstrPubKey,plResult)

#define IWMRMHeader_SetCheckSum(This,bstrKey)	\
    (This)->lpVtbl -> SetCheckSum(This,bstrKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_get_Header_Proxy( 
    IWMRMHeader * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMHeader_get_Header_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_put_Header_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMHeader_put_Header_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_get_Version_Proxy( 
    IWMRMHeader * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMHeader_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_get_KeyID_Proxy( 
    IWMRMHeader * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMHeader_get_KeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_put_KeyID_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMHeader_put_KeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_get_ContentID_Proxy( 
    IWMRMHeader * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMHeader_get_ContentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_put_ContentID_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMHeader_put_ContentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_get_IndividualizedVersion_Proxy( 
    IWMRMHeader * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMHeader_get_IndividualizedVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_put_IndividualizedVersion_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMHeader_put_IndividualizedVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_get_LicenseAcqURL_Proxy( 
    IWMRMHeader * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMHeader_get_LicenseAcqURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_put_LicenseAcqURL_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMHeader_put_LicenseAcqURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_get_Attribute_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMHeader_get_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_put_Attribute_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMHeader_put_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_Sign_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR bstrPrivKey);


void __RPC_STUB IWMRMHeader_Sign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_Verify_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR bstrPubKey,
    /* [retval][out] */ LONG *plResult);


void __RPC_STUB IWMRMHeader_Verify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMHeader_SetCheckSum_Proxy( 
    IWMRMHeader * This,
    /* [in] */ BSTR bstrKey);


void __RPC_STUB IWMRMHeader_SetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMHeader_INTERFACE_DEFINED__ */


#ifndef __IWMRMHeader2_INTERFACE_DEFINED__
#define __IWMRMHeader2_INTERFACE_DEFINED__

/* interface IWMRMHeader2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMHeader2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44F7DFDA-C7D1-4c7f-83D2-73BA3EAED9FA")
    IWMRMHeader2 : public IWMRMHeader
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddUplink( 
            /* [in] */ BSTR uplinkKid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveUplink( 
            /* [in] */ BSTR uplinkKid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMHeader2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMHeader2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMHeader2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMHeader2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMHeader2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMHeader2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMHeader2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMHeader2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Header )( 
            IWMRMHeader2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Header )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IWMRMHeader2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMHeader2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentID )( 
            IWMRMHeader2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContentID )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IndividualizedVersion )( 
            IWMRMHeader2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IndividualizedVersion )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LicenseAcqURL )( 
            IWMRMHeader2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LicenseAcqURL )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Sign )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR bstrPrivKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Verify )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR bstrPubKey,
            /* [retval][out] */ LONG *plResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetCheckSum )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddUplink )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR uplinkKid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveUplink )( 
            IWMRMHeader2 * This,
            /* [in] */ BSTR uplinkKid);
        
        END_INTERFACE
    } IWMRMHeader2Vtbl;

    interface IWMRMHeader2
    {
        CONST_VTBL struct IWMRMHeader2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMHeader2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMHeader2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMHeader2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMHeader2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMHeader2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMHeader2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMHeader2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMHeader2_get_Header(This,pVal)	\
    (This)->lpVtbl -> get_Header(This,pVal)

#define IWMRMHeader2_put_Header(This,newVal)	\
    (This)->lpVtbl -> put_Header(This,newVal)

#define IWMRMHeader2_get_Version(This,pVal)	\
    (This)->lpVtbl -> get_Version(This,pVal)

#define IWMRMHeader2_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMHeader2_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMHeader2_get_ContentID(This,pVal)	\
    (This)->lpVtbl -> get_ContentID(This,pVal)

#define IWMRMHeader2_put_ContentID(This,newVal)	\
    (This)->lpVtbl -> put_ContentID(This,newVal)

#define IWMRMHeader2_get_IndividualizedVersion(This,pVal)	\
    (This)->lpVtbl -> get_IndividualizedVersion(This,pVal)

#define IWMRMHeader2_put_IndividualizedVersion(This,newVal)	\
    (This)->lpVtbl -> put_IndividualizedVersion(This,newVal)

#define IWMRMHeader2_get_LicenseAcqURL(This,pVal)	\
    (This)->lpVtbl -> get_LicenseAcqURL(This,pVal)

#define IWMRMHeader2_put_LicenseAcqURL(This,newVal)	\
    (This)->lpVtbl -> put_LicenseAcqURL(This,newVal)

#define IWMRMHeader2_get_Attribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,bstrName,pVal)

#define IWMRMHeader2_put_Attribute(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,bstrName,newVal)

#define IWMRMHeader2_Sign(This,bstrPrivKey)	\
    (This)->lpVtbl -> Sign(This,bstrPrivKey)

#define IWMRMHeader2_Verify(This,bstrPubKey,plResult)	\
    (This)->lpVtbl -> Verify(This,bstrPubKey,plResult)

#define IWMRMHeader2_SetCheckSum(This,bstrKey)	\
    (This)->lpVtbl -> SetCheckSum(This,bstrKey)


#define IWMRMHeader2_AddUplink(This,uplinkKid)	\
    (This)->lpVtbl -> AddUplink(This,uplinkKid)

#define IWMRMHeader2_RemoveUplink(This,uplinkKid)	\
    (This)->lpVtbl -> RemoveUplink(This,uplinkKid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMHeader2_AddUplink_Proxy( 
    IWMRMHeader2 * This,
    /* [in] */ BSTR uplinkKid);


void __RPC_STUB IWMRMHeader2_AddUplink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMHeader2_RemoveUplink_Proxy( 
    IWMRMHeader2 * This,
    /* [in] */ BSTR uplinkKid);


void __RPC_STUB IWMRMHeader2_RemoveUplink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMHeader2_INTERFACE_DEFINED__ */


#ifndef __IWMRMCoding_INTERFACE_DEFINED__
#define __IWMRMCoding_INTERFACE_DEFINED__

/* interface IWMRMCoding */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMRMCoding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C39DDC6-E5C1-40A8-B208-17B5E4006C83")
    IWMRMCoding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Encode( 
            /* [size_is][in] */ BYTE *pbData,
            /* [in] */ LONG lSize,
            /* [retval][out] */ BSTR *pbstrEncodedData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Decode( 
            /* [in] */ BSTR bstrEncodedData,
            /* [out] */ LONG *plSize,
            /* [size_is][size_is][out] */ BYTE **ppbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMCodingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMCoding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMCoding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMCoding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Encode )( 
            IWMRMCoding * This,
            /* [size_is][in] */ BYTE *pbData,
            /* [in] */ LONG lSize,
            /* [retval][out] */ BSTR *pbstrEncodedData);
        
        HRESULT ( STDMETHODCALLTYPE *Decode )( 
            IWMRMCoding * This,
            /* [in] */ BSTR bstrEncodedData,
            /* [out] */ LONG *plSize,
            /* [size_is][size_is][out] */ BYTE **ppbData);
        
        END_INTERFACE
    } IWMRMCodingVtbl;

    interface IWMRMCoding
    {
        CONST_VTBL struct IWMRMCodingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMCoding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMCoding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMCoding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMCoding_Encode(This,pbData,lSize,pbstrEncodedData)	\
    (This)->lpVtbl -> Encode(This,pbData,lSize,pbstrEncodedData)

#define IWMRMCoding_Decode(This,bstrEncodedData,plSize,ppbData)	\
    (This)->lpVtbl -> Decode(This,bstrEncodedData,plSize,ppbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMRMCoding_Encode_Proxy( 
    IWMRMCoding * This,
    /* [size_is][in] */ BYTE *pbData,
    /* [in] */ LONG lSize,
    /* [retval][out] */ BSTR *pbstrEncodedData);


void __RPC_STUB IWMRMCoding_Encode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMRMCoding_Decode_Proxy( 
    IWMRMCoding * This,
    /* [in] */ BSTR bstrEncodedData,
    /* [out] */ LONG *plSize,
    /* [size_is][size_is][out] */ BYTE **ppbData);


void __RPC_STUB IWMRMCoding_Decode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMCoding_INTERFACE_DEFINED__ */


#ifndef __IWMRMKeys_INTERFACE_DEFINED__
#define __IWMRMKeys_INTERFACE_DEFINED__

/* interface IWMRMKeys */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMKeys;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44B557F6-BCB6-4BAE-9CA9-EC81D6DAAB45")
    IWMRMKeys : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSeed( 
            /* [retval][out] */ BSTR *pbstrSeed) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateKeyID( 
            /* [retval][out] */ BSTR *pbstrKeyID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Seed( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Seed( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_KeyID( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateKey( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSigningKeys( 
            /* [out][in] */ VARIANT *pvarPrivKey,
            /* [out][in] */ VARIANT *pvarPubKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMKeysVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMKeys * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMKeys * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMKeys * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMKeys * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMKeys * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMKeys * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMKeys * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSeed )( 
            IWMRMKeys * This,
            /* [retval][out] */ BSTR *pbstrSeed);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKeyID )( 
            IWMRMKeys * This,
            /* [retval][out] */ BSTR *pbstrKeyID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Seed )( 
            IWMRMKeys * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Seed )( 
            IWMRMKeys * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMKeys * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMKeys * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKey )( 
            IWMRMKeys * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSigningKeys )( 
            IWMRMKeys * This,
            /* [out][in] */ VARIANT *pvarPrivKey,
            /* [out][in] */ VARIANT *pvarPubKey);
        
        END_INTERFACE
    } IWMRMKeysVtbl;

    interface IWMRMKeys
    {
        CONST_VTBL struct IWMRMKeysVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMKeys_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMKeys_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMKeys_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMKeys_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMKeys_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMKeys_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMKeys_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMKeys_GenerateSeed(This,pbstrSeed)	\
    (This)->lpVtbl -> GenerateSeed(This,pbstrSeed)

#define IWMRMKeys_GenerateKeyID(This,pbstrKeyID)	\
    (This)->lpVtbl -> GenerateKeyID(This,pbstrKeyID)

#define IWMRMKeys_get_Seed(This,pVal)	\
    (This)->lpVtbl -> get_Seed(This,pVal)

#define IWMRMKeys_put_Seed(This,newVal)	\
    (This)->lpVtbl -> put_Seed(This,newVal)

#define IWMRMKeys_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMKeys_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMKeys_GenerateKey(This,pbstrKey)	\
    (This)->lpVtbl -> GenerateKey(This,pbstrKey)

#define IWMRMKeys_GenerateSigningKeys(This,pvarPrivKey,pvarPubKey)	\
    (This)->lpVtbl -> GenerateSigningKeys(This,pvarPrivKey,pvarPubKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMKeys_GenerateSeed_Proxy( 
    IWMRMKeys * This,
    /* [retval][out] */ BSTR *pbstrSeed);


void __RPC_STUB IWMRMKeys_GenerateSeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMKeys_GenerateKeyID_Proxy( 
    IWMRMKeys * This,
    /* [retval][out] */ BSTR *pbstrKeyID);


void __RPC_STUB IWMRMKeys_GenerateKeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMKeys_get_Seed_Proxy( 
    IWMRMKeys * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMKeys_get_Seed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMKeys_put_Seed_Proxy( 
    IWMRMKeys * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMKeys_put_Seed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMKeys_get_KeyID_Proxy( 
    IWMRMKeys * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMKeys_get_KeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMKeys_put_KeyID_Proxy( 
    IWMRMKeys * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMKeys_put_KeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMKeys_GenerateKey_Proxy( 
    IWMRMKeys * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IWMRMKeys_GenerateKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMKeys_GenerateSigningKeys_Proxy( 
    IWMRMKeys * This,
    /* [out][in] */ VARIANT *pvarPrivKey,
    /* [out][in] */ VARIANT *pvarPubKey);


void __RPC_STUB IWMRMKeys_GenerateSigningKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMKeys_INTERFACE_DEFINED__ */


#ifndef __IWMRMKeys2_INTERFACE_DEFINED__
#define __IWMRMKeys2_INTERFACE_DEFINED__

/* interface IWMRMKeys2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMKeys2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C7F23FA-8A18-4d7b-A7F0-9BF113B91DBF")
    IWMRMKeys2 : public IWMRMKeys
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSigningKeysEx( 
            /* [out][in] */ VARIANT *pvarPrivKey,
            /* [out][in] */ VARIANT *pvarPubKey,
            /* [out][in] */ VARIANT *pvarCert) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCertificate( 
            /* [in] */ BSTR bstrCertType,
            /* [retval][out] */ BSTR *pbstrCert) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateKeyEx( 
            /* [in] */ LONG lReqLen,
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMKeys2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMKeys2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMKeys2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMKeys2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMKeys2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMKeys2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMKeys2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMKeys2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSeed )( 
            IWMRMKeys2 * This,
            /* [retval][out] */ BSTR *pbstrSeed);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKeyID )( 
            IWMRMKeys2 * This,
            /* [retval][out] */ BSTR *pbstrKeyID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Seed )( 
            IWMRMKeys2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Seed )( 
            IWMRMKeys2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMKeys2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMKeys2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKey )( 
            IWMRMKeys2 * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSigningKeys )( 
            IWMRMKeys2 * This,
            /* [out][in] */ VARIANT *pvarPrivKey,
            /* [out][in] */ VARIANT *pvarPubKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSigningKeysEx )( 
            IWMRMKeys2 * This,
            /* [out][in] */ VARIANT *pvarPrivKey,
            /* [out][in] */ VARIANT *pvarPubKey,
            /* [out][in] */ VARIANT *pvarCert);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCertificate )( 
            IWMRMKeys2 * This,
            /* [in] */ BSTR bstrCertType,
            /* [retval][out] */ BSTR *pbstrCert);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKeyEx )( 
            IWMRMKeys2 * This,
            /* [in] */ LONG lReqLen,
            /* [retval][out] */ BSTR *pbstrKey);
        
        END_INTERFACE
    } IWMRMKeys2Vtbl;

    interface IWMRMKeys2
    {
        CONST_VTBL struct IWMRMKeys2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMKeys2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMKeys2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMKeys2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMKeys2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMKeys2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMKeys2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMKeys2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMKeys2_GenerateSeed(This,pbstrSeed)	\
    (This)->lpVtbl -> GenerateSeed(This,pbstrSeed)

#define IWMRMKeys2_GenerateKeyID(This,pbstrKeyID)	\
    (This)->lpVtbl -> GenerateKeyID(This,pbstrKeyID)

#define IWMRMKeys2_get_Seed(This,pVal)	\
    (This)->lpVtbl -> get_Seed(This,pVal)

#define IWMRMKeys2_put_Seed(This,newVal)	\
    (This)->lpVtbl -> put_Seed(This,newVal)

#define IWMRMKeys2_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMKeys2_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMKeys2_GenerateKey(This,pbstrKey)	\
    (This)->lpVtbl -> GenerateKey(This,pbstrKey)

#define IWMRMKeys2_GenerateSigningKeys(This,pvarPrivKey,pvarPubKey)	\
    (This)->lpVtbl -> GenerateSigningKeys(This,pvarPrivKey,pvarPubKey)


#define IWMRMKeys2_GenerateSigningKeysEx(This,pvarPrivKey,pvarPubKey,pvarCert)	\
    (This)->lpVtbl -> GenerateSigningKeysEx(This,pvarPrivKey,pvarPubKey,pvarCert)

#define IWMRMKeys2_GetCertificate(This,bstrCertType,pbstrCert)	\
    (This)->lpVtbl -> GetCertificate(This,bstrCertType,pbstrCert)

#define IWMRMKeys2_GenerateKeyEx(This,lReqLen,pbstrKey)	\
    (This)->lpVtbl -> GenerateKeyEx(This,lReqLen,pbstrKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMKeys2_GenerateSigningKeysEx_Proxy( 
    IWMRMKeys2 * This,
    /* [out][in] */ VARIANT *pvarPrivKey,
    /* [out][in] */ VARIANT *pvarPubKey,
    /* [out][in] */ VARIANT *pvarCert);


void __RPC_STUB IWMRMKeys2_GenerateSigningKeysEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMKeys2_GetCertificate_Proxy( 
    IWMRMKeys2 * This,
    /* [in] */ BSTR bstrCertType,
    /* [retval][out] */ BSTR *pbstrCert);


void __RPC_STUB IWMRMKeys2_GetCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMKeys2_GenerateKeyEx_Proxy( 
    IWMRMKeys2 * This,
    /* [in] */ LONG lReqLen,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IWMRMKeys2_GenerateKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMKeys2_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicenseStateData_INTERFACE_DEFINED__
#define __IWMRMLicenseStateData_INTERFACE_DEFINED__

/* interface IWMRMLicenseStateData */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicenseStateData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E47FB7B-05BF-40f7-899A-1423E955DB62")
    IWMRMLicenseStateData : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamId( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ WMRM_LICENSE_STATE_CATEGORY *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Vagueness( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Counts( 
            /* [retval][out] */ SAFEARRAY * *ppsaCounts) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Dates( 
            /* [retval][out] */ SAFEARRAY * *ppsaCounts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicenseStateDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicenseStateData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicenseStateData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicenseStateData * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicenseStateData * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicenseStateData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicenseStateData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicenseStateData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamId )( 
            IWMRMLicenseStateData * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IWMRMLicenseStateData * This,
            /* [retval][out] */ WMRM_LICENSE_STATE_CATEGORY *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Vagueness )( 
            IWMRMLicenseStateData * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Counts )( 
            IWMRMLicenseStateData * This,
            /* [retval][out] */ SAFEARRAY * *ppsaCounts);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dates )( 
            IWMRMLicenseStateData * This,
            /* [retval][out] */ SAFEARRAY * *ppsaCounts);
        
        END_INTERFACE
    } IWMRMLicenseStateDataVtbl;

    interface IWMRMLicenseStateData
    {
        CONST_VTBL struct IWMRMLicenseStateDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicenseStateData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicenseStateData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicenseStateData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicenseStateData_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicenseStateData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicenseStateData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicenseStateData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicenseStateData_get_StreamId(This,pVal)	\
    (This)->lpVtbl -> get_StreamId(This,pVal)

#define IWMRMLicenseStateData_get_Category(This,pVal)	\
    (This)->lpVtbl -> get_Category(This,pVal)

#define IWMRMLicenseStateData_get_Vagueness(This,pVal)	\
    (This)->lpVtbl -> get_Vagueness(This,pVal)

#define IWMRMLicenseStateData_get_Counts(This,ppsaCounts)	\
    (This)->lpVtbl -> get_Counts(This,ppsaCounts)

#define IWMRMLicenseStateData_get_Dates(This,ppsaCounts)	\
    (This)->lpVtbl -> get_Dates(This,ppsaCounts)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseStateData_get_StreamId_Proxy( 
    IWMRMLicenseStateData * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IWMRMLicenseStateData_get_StreamId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseStateData_get_Category_Proxy( 
    IWMRMLicenseStateData * This,
    /* [retval][out] */ WMRM_LICENSE_STATE_CATEGORY *pVal);


void __RPC_STUB IWMRMLicenseStateData_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseStateData_get_Vagueness_Proxy( 
    IWMRMLicenseStateData * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IWMRMLicenseStateData_get_Vagueness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseStateData_get_Counts_Proxy( 
    IWMRMLicenseStateData * This,
    /* [retval][out] */ SAFEARRAY * *ppsaCounts);


void __RPC_STUB IWMRMLicenseStateData_get_Counts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseStateData_get_Dates_Proxy( 
    IWMRMLicenseStateData * This,
    /* [retval][out] */ SAFEARRAY * *ppsaCounts);


void __RPC_STUB IWMRMLicenseStateData_get_Dates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicenseStateData_INTERFACE_DEFINED__ */


#ifndef __IWMRMUplink_INTERFACE_DEFINED__
#define __IWMRMUplink_INTERFACE_DEFINED__

/* interface IWMRMUplink */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMUplink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAD38F38-75E3-457e-82DD-D01B2BB18468")
    IWMRMUplink : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LicenseState( 
            /* [retval][out] */ IWMRMLicenseStateData **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMUplinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMUplink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMUplink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMUplink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMUplink * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMUplink * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMUplink * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMUplink * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KID )( 
            IWMRMUplink * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LicenseState )( 
            IWMRMUplink * This,
            /* [retval][out] */ IWMRMLicenseStateData **pVal);
        
        END_INTERFACE
    } IWMRMUplinkVtbl;

    interface IWMRMUplink
    {
        CONST_VTBL struct IWMRMUplinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMUplink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMUplink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMUplink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMUplink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMUplink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMUplink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMUplink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMUplink_get_KID(This,pVal)	\
    (This)->lpVtbl -> get_KID(This,pVal)

#define IWMRMUplink_get_LicenseState(This,pVal)	\
    (This)->lpVtbl -> get_LicenseState(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMUplink_get_KID_Proxy( 
    IWMRMUplink * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMUplink_get_KID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMUplink_get_LicenseState_Proxy( 
    IWMRMUplink * This,
    /* [retval][out] */ IWMRMLicenseStateData **pVal);


void __RPC_STUB IWMRMUplink_get_LicenseState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMUplink_INTERFACE_DEFINED__ */


#ifndef __IWMRMUplinkCollection_INTERFACE_DEFINED__
#define __IWMRMUplinkCollection_INTERFACE_DEFINED__

/* interface IWMRMUplinkCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMUplinkCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C2A28ABF-39AA-46de-AD04-66FF20D140A9")
    IWMRMUplinkCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ LONG index,
            /* [retval][out] */ IWMRMUplink **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ LONG *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMUplinkCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMUplinkCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMUplinkCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMUplinkCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMUplinkCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMUplinkCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMUplinkCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMUplinkCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IWMRMUplinkCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ IWMRMUplink **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMRMUplinkCollection * This,
            /* [retval][out] */ LONG *pVal);
        
        END_INTERFACE
    } IWMRMUplinkCollectionVtbl;

    interface IWMRMUplinkCollection
    {
        CONST_VTBL struct IWMRMUplinkCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMUplinkCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMUplinkCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMUplinkCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMUplinkCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMUplinkCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMUplinkCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMUplinkCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMUplinkCollection_get_item(This,index,pVal)	\
    (This)->lpVtbl -> get_item(This,index,pVal)

#define IWMRMUplinkCollection_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMUplinkCollection_get_item_Proxy( 
    IWMRMUplinkCollection * This,
    /* [in] */ LONG index,
    /* [retval][out] */ IWMRMUplink **pVal);


void __RPC_STUB IWMRMUplinkCollection_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMUplinkCollection_get_length_Proxy( 
    IWMRMUplinkCollection * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB IWMRMUplinkCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMUplinkCollection_INTERFACE_DEFINED__ */


#ifndef __IWMRMChallenge_INTERFACE_DEFINED__
#define __IWMRMChallenge_INTERFACE_DEFINED__

/* interface IWMRMChallenge */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMChallenge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96CE0585-2129-44E8-9F26-0CFBA54392FE")
    IWMRMChallenge : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Challenge( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Challenge( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClientAttribute( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Header( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClientInfo( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_V1Challenge( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActionCount( 
            /* [retval][out] */ DWORD *pdwVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Action( 
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMChallengeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMChallenge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMChallenge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMChallenge * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMChallenge * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMChallenge * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMChallenge * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMChallenge * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Challenge )( 
            IWMRMChallenge * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Challenge )( 
            IWMRMChallenge * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientAttribute )( 
            IWMRMChallenge * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Header )( 
            IWMRMChallenge * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientInfo )( 
            IWMRMChallenge * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_V1Challenge )( 
            IWMRMChallenge * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActionCount )( 
            IWMRMChallenge * This,
            /* [retval][out] */ DWORD *pdwVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Action )( 
            IWMRMChallenge * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IWMRMChallengeVtbl;

    interface IWMRMChallenge
    {
        CONST_VTBL struct IWMRMChallengeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMChallenge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMChallenge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMChallenge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMChallenge_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMChallenge_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMChallenge_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMChallenge_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMChallenge_get_Challenge(This,pVal)	\
    (This)->lpVtbl -> get_Challenge(This,pVal)

#define IWMRMChallenge_put_Challenge(This,newVal)	\
    (This)->lpVtbl -> put_Challenge(This,newVal)

#define IWMRMChallenge_get_ClientAttribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_ClientAttribute(This,bstrName,pVal)

#define IWMRMChallenge_get_Header(This,pVal)	\
    (This)->lpVtbl -> get_Header(This,pVal)

#define IWMRMChallenge_get_ClientInfo(This,pVal)	\
    (This)->lpVtbl -> get_ClientInfo(This,pVal)

#define IWMRMChallenge_get_V1Challenge(This,pVal)	\
    (This)->lpVtbl -> get_V1Challenge(This,pVal)

#define IWMRMChallenge_get_ActionCount(This,pdwVal)	\
    (This)->lpVtbl -> get_ActionCount(This,pdwVal)

#define IWMRMChallenge_get_Action(This,dwIndex,pVal)	\
    (This)->lpVtbl -> get_Action(This,dwIndex,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge_get_Challenge_Proxy( 
    IWMRMChallenge * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMChallenge_get_Challenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge_put_Challenge_Proxy( 
    IWMRMChallenge * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMChallenge_put_Challenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge_get_ClientAttribute_Proxy( 
    IWMRMChallenge * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMChallenge_get_ClientAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge_get_Header_Proxy( 
    IWMRMChallenge * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMChallenge_get_Header_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge_get_ClientInfo_Proxy( 
    IWMRMChallenge * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMChallenge_get_ClientInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge_get_V1Challenge_Proxy( 
    IWMRMChallenge * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMChallenge_get_V1Challenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge_get_ActionCount_Proxy( 
    IWMRMChallenge * This,
    /* [retval][out] */ DWORD *pdwVal);


void __RPC_STUB IWMRMChallenge_get_ActionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge_get_Action_Proxy( 
    IWMRMChallenge * This,
    /* [in] */ DWORD dwIndex,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMChallenge_get_Action_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMChallenge_INTERFACE_DEFINED__ */


#ifndef __IWMRMChallenge2_INTERFACE_DEFINED__
#define __IWMRMChallenge2_INTERFACE_DEFINED__

/* interface IWMRMChallenge2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMChallenge2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68CC3E3C-47ED-47ce-925F-EABE931FF518")
    IWMRMChallenge2 : public IWMRMChallenge
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckClientCapability( 
            /* [in] */ BSTR bstrFunctionName,
            /* [retval][out] */ BOOL *fSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMChallenge2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMChallenge2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMChallenge2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMChallenge2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMChallenge2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMChallenge2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMChallenge2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMChallenge2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Challenge )( 
            IWMRMChallenge2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Challenge )( 
            IWMRMChallenge2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientAttribute )( 
            IWMRMChallenge2 * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Header )( 
            IWMRMChallenge2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientInfo )( 
            IWMRMChallenge2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_V1Challenge )( 
            IWMRMChallenge2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActionCount )( 
            IWMRMChallenge2 * This,
            /* [retval][out] */ DWORD *pdwVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Action )( 
            IWMRMChallenge2 * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CheckClientCapability )( 
            IWMRMChallenge2 * This,
            /* [in] */ BSTR bstrFunctionName,
            /* [retval][out] */ BOOL *fSupport);
        
        END_INTERFACE
    } IWMRMChallenge2Vtbl;

    interface IWMRMChallenge2
    {
        CONST_VTBL struct IWMRMChallenge2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMChallenge2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMChallenge2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMChallenge2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMChallenge2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMChallenge2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMChallenge2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMChallenge2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMChallenge2_get_Challenge(This,pVal)	\
    (This)->lpVtbl -> get_Challenge(This,pVal)

#define IWMRMChallenge2_put_Challenge(This,newVal)	\
    (This)->lpVtbl -> put_Challenge(This,newVal)

#define IWMRMChallenge2_get_ClientAttribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_ClientAttribute(This,bstrName,pVal)

#define IWMRMChallenge2_get_Header(This,pVal)	\
    (This)->lpVtbl -> get_Header(This,pVal)

#define IWMRMChallenge2_get_ClientInfo(This,pVal)	\
    (This)->lpVtbl -> get_ClientInfo(This,pVal)

#define IWMRMChallenge2_get_V1Challenge(This,pVal)	\
    (This)->lpVtbl -> get_V1Challenge(This,pVal)

#define IWMRMChallenge2_get_ActionCount(This,pdwVal)	\
    (This)->lpVtbl -> get_ActionCount(This,pdwVal)

#define IWMRMChallenge2_get_Action(This,dwIndex,pVal)	\
    (This)->lpVtbl -> get_Action(This,dwIndex,pVal)


#define IWMRMChallenge2_CheckClientCapability(This,bstrFunctionName,fSupport)	\
    (This)->lpVtbl -> CheckClientCapability(This,bstrFunctionName,fSupport)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge2_CheckClientCapability_Proxy( 
    IWMRMChallenge2 * This,
    /* [in] */ BSTR bstrFunctionName,
    /* [retval][out] */ BOOL *fSupport);


void __RPC_STUB IWMRMChallenge2_CheckClientCapability_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMChallenge2_INTERFACE_DEFINED__ */


#ifndef __IWMRMChallenge3_INTERFACE_DEFINED__
#define __IWMRMChallenge3_INTERFACE_DEFINED__

/* interface IWMRMChallenge3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMChallenge3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDC4CEB6-D868-4825-9871-DC5CD99B6D7C")
    IWMRMChallenge3 : public IWMRMChallenge2
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Uplinks( 
            /* [retval][out] */ IWMRMUplinkCollection **ppVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClientVersion( 
            /* [retval][out] */ BSTR *pbstrClientVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMChallenge3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMChallenge3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMChallenge3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMChallenge3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMChallenge3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMChallenge3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMChallenge3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMChallenge3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Challenge )( 
            IWMRMChallenge3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Challenge )( 
            IWMRMChallenge3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientAttribute )( 
            IWMRMChallenge3 * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Header )( 
            IWMRMChallenge3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientInfo )( 
            IWMRMChallenge3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_V1Challenge )( 
            IWMRMChallenge3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActionCount )( 
            IWMRMChallenge3 * This,
            /* [retval][out] */ DWORD *pdwVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Action )( 
            IWMRMChallenge3 * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CheckClientCapability )( 
            IWMRMChallenge3 * This,
            /* [in] */ BSTR bstrFunctionName,
            /* [retval][out] */ BOOL *fSupport);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Uplinks )( 
            IWMRMChallenge3 * This,
            /* [retval][out] */ IWMRMUplinkCollection **ppVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientVersion )( 
            IWMRMChallenge3 * This,
            /* [retval][out] */ BSTR *pbstrClientVersion);
        
        END_INTERFACE
    } IWMRMChallenge3Vtbl;

    interface IWMRMChallenge3
    {
        CONST_VTBL struct IWMRMChallenge3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMChallenge3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMChallenge3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMChallenge3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMChallenge3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMChallenge3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMChallenge3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMChallenge3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMChallenge3_get_Challenge(This,pVal)	\
    (This)->lpVtbl -> get_Challenge(This,pVal)

#define IWMRMChallenge3_put_Challenge(This,newVal)	\
    (This)->lpVtbl -> put_Challenge(This,newVal)

#define IWMRMChallenge3_get_ClientAttribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_ClientAttribute(This,bstrName,pVal)

#define IWMRMChallenge3_get_Header(This,pVal)	\
    (This)->lpVtbl -> get_Header(This,pVal)

#define IWMRMChallenge3_get_ClientInfo(This,pVal)	\
    (This)->lpVtbl -> get_ClientInfo(This,pVal)

#define IWMRMChallenge3_get_V1Challenge(This,pVal)	\
    (This)->lpVtbl -> get_V1Challenge(This,pVal)

#define IWMRMChallenge3_get_ActionCount(This,pdwVal)	\
    (This)->lpVtbl -> get_ActionCount(This,pdwVal)

#define IWMRMChallenge3_get_Action(This,dwIndex,pVal)	\
    (This)->lpVtbl -> get_Action(This,dwIndex,pVal)


#define IWMRMChallenge3_CheckClientCapability(This,bstrFunctionName,fSupport)	\
    (This)->lpVtbl -> CheckClientCapability(This,bstrFunctionName,fSupport)


#define IWMRMChallenge3_get_Uplinks(This,ppVal)	\
    (This)->lpVtbl -> get_Uplinks(This,ppVal)

#define IWMRMChallenge3_get_ClientVersion(This,pbstrClientVersion)	\
    (This)->lpVtbl -> get_ClientVersion(This,pbstrClientVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge3_get_Uplinks_Proxy( 
    IWMRMChallenge3 * This,
    /* [retval][out] */ IWMRMUplinkCollection **ppVal);


void __RPC_STUB IWMRMChallenge3_get_Uplinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge3_get_ClientVersion_Proxy( 
    IWMRMChallenge3 * This,
    /* [retval][out] */ BSTR *pbstrClientVersion);


void __RPC_STUB IWMRMChallenge3_get_ClientVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMChallenge3_INTERFACE_DEFINED__ */


#ifndef __IWMRMChallenge4_INTERFACE_DEFINED__
#define __IWMRMChallenge4_INTERFACE_DEFINED__

/* interface IWMRMChallenge4 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMChallenge4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A171AF2-03AD-4b66-B228-8CEF6AAEE1C7")
    IWMRMChallenge4 : public IWMRMChallenge3
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RevInfo( 
            /* [retval][out] */ BSTR *pbstrRevInfoBlob) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RevInfoPresent( 
            /* [retval][out] */ BOOL *f_pFRevInfoPresent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMChallenge4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMChallenge4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMChallenge4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMChallenge4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMChallenge4 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMChallenge4 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMChallenge4 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMChallenge4 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Challenge )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Challenge )( 
            IWMRMChallenge4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientAttribute )( 
            IWMRMChallenge4 * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Header )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientInfo )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_V1Challenge )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActionCount )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ DWORD *pdwVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Action )( 
            IWMRMChallenge4 * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CheckClientCapability )( 
            IWMRMChallenge4 * This,
            /* [in] */ BSTR bstrFunctionName,
            /* [retval][out] */ BOOL *fSupport);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Uplinks )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ IWMRMUplinkCollection **ppVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientVersion )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ BSTR *pbstrClientVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RevInfo )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ BSTR *pbstrRevInfoBlob);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RevInfoPresent )( 
            IWMRMChallenge4 * This,
            /* [retval][out] */ BOOL *f_pFRevInfoPresent);
        
        END_INTERFACE
    } IWMRMChallenge4Vtbl;

    interface IWMRMChallenge4
    {
        CONST_VTBL struct IWMRMChallenge4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMChallenge4_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMChallenge4_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMChallenge4_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMChallenge4_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMChallenge4_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMChallenge4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMChallenge4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMChallenge4_get_Challenge(This,pVal)	\
    (This)->lpVtbl -> get_Challenge(This,pVal)

#define IWMRMChallenge4_put_Challenge(This,newVal)	\
    (This)->lpVtbl -> put_Challenge(This,newVal)

#define IWMRMChallenge4_get_ClientAttribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_ClientAttribute(This,bstrName,pVal)

#define IWMRMChallenge4_get_Header(This,pVal)	\
    (This)->lpVtbl -> get_Header(This,pVal)

#define IWMRMChallenge4_get_ClientInfo(This,pVal)	\
    (This)->lpVtbl -> get_ClientInfo(This,pVal)

#define IWMRMChallenge4_get_V1Challenge(This,pVal)	\
    (This)->lpVtbl -> get_V1Challenge(This,pVal)

#define IWMRMChallenge4_get_ActionCount(This,pdwVal)	\
    (This)->lpVtbl -> get_ActionCount(This,pdwVal)

#define IWMRMChallenge4_get_Action(This,dwIndex,pVal)	\
    (This)->lpVtbl -> get_Action(This,dwIndex,pVal)


#define IWMRMChallenge4_CheckClientCapability(This,bstrFunctionName,fSupport)	\
    (This)->lpVtbl -> CheckClientCapability(This,bstrFunctionName,fSupport)


#define IWMRMChallenge4_get_Uplinks(This,ppVal)	\
    (This)->lpVtbl -> get_Uplinks(This,ppVal)

#define IWMRMChallenge4_get_ClientVersion(This,pbstrClientVersion)	\
    (This)->lpVtbl -> get_ClientVersion(This,pbstrClientVersion)


#define IWMRMChallenge4_get_RevInfo(This,pbstrRevInfoBlob)	\
    (This)->lpVtbl -> get_RevInfo(This,pbstrRevInfoBlob)

#define IWMRMChallenge4_get_RevInfoPresent(This,f_pFRevInfoPresent)	\
    (This)->lpVtbl -> get_RevInfoPresent(This,f_pFRevInfoPresent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge4_get_RevInfo_Proxy( 
    IWMRMChallenge4 * This,
    /* [retval][out] */ BSTR *pbstrRevInfoBlob);


void __RPC_STUB IWMRMChallenge4_get_RevInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMChallenge4_get_RevInfoPresent_Proxy( 
    IWMRMChallenge4 * This,
    /* [retval][out] */ BOOL *f_pFRevInfoPresent);


void __RPC_STUB IWMRMChallenge4_get_RevInfoPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMChallenge4_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicGen_INTERFACE_DEFINED__
#define __IWMRMLicGen_INTERFACE_DEFINED__

/* interface IWMRMLicGen */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicGen;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8BE066FE-EF53-4B59-967B-7CA06CBFAAC2")
    IWMRMLicGen : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ClientInfo( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_KeyID( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BindToPubKey( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BindToPubKey( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetKey( 
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLicenseToDeliver( 
            /* [retval][out] */ BSTR *pbstrLicense) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attribute( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attribute( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Rights( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Rights( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClientVersion( 
            /* [out][in] */ VARIANT *pvarCategory,
            /* [out][in] */ VARIANT *pvarVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicGenVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicGen * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicGen * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicGen * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicGen * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicGen * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicGen * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicGen * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IWMRMLicGen * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IWMRMLicGen * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientInfo )( 
            IWMRMLicGen * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMLicGen * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMLicGen * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BindToPubKey )( 
            IWMRMLicGen * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BindToPubKey )( 
            IWMRMLicGen * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            IWMRMLicGen * This,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLicenseToDeliver )( 
            IWMRMLicGen * This,
            /* [retval][out] */ BSTR *pbstrLicense);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IWMRMLicGen * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IWMRMLicGen * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rights )( 
            IWMRMLicGen * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rights )( 
            IWMRMLicGen * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetClientVersion )( 
            IWMRMLicGen * This,
            /* [out][in] */ VARIANT *pvarCategory,
            /* [out][in] */ VARIANT *pvarVersion);
        
        END_INTERFACE
    } IWMRMLicGenVtbl;

    interface IWMRMLicGen
    {
        CONST_VTBL struct IWMRMLicGenVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicGen_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicGen_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicGen_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicGen_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicGen_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicGen_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicGen_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicGen_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IWMRMLicGen_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IWMRMLicGen_put_ClientInfo(This,newVal)	\
    (This)->lpVtbl -> put_ClientInfo(This,newVal)

#define IWMRMLicGen_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMLicGen_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMLicGen_get_BindToPubKey(This,pVal)	\
    (This)->lpVtbl -> get_BindToPubKey(This,pVal)

#define IWMRMLicGen_put_BindToPubKey(This,newVal)	\
    (This)->lpVtbl -> put_BindToPubKey(This,newVal)

#define IWMRMLicGen_SetKey(This,bstrType,bstrKey)	\
    (This)->lpVtbl -> SetKey(This,bstrType,bstrKey)

#define IWMRMLicGen_GetLicenseToDeliver(This,pbstrLicense)	\
    (This)->lpVtbl -> GetLicenseToDeliver(This,pbstrLicense)

#define IWMRMLicGen_get_Attribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,bstrName,pVal)

#define IWMRMLicGen_put_Attribute(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,bstrName,newVal)

#define IWMRMLicGen_get_Rights(This,pVal)	\
    (This)->lpVtbl -> get_Rights(This,pVal)

#define IWMRMLicGen_put_Rights(This,newVal)	\
    (This)->lpVtbl -> put_Rights(This,newVal)

#define IWMRMLicGen_GetClientVersion(This,pvarCategory,pvarVersion)	\
    (This)->lpVtbl -> GetClientVersion(This,pvarCategory,pvarVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_get_Priority_Proxy( 
    IWMRMLicGen * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMRMLicGen_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_put_Priority_Proxy( 
    IWMRMLicGen * This,
    /* [in] */ long newVal);


void __RPC_STUB IWMRMLicGen_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_put_ClientInfo_Proxy( 
    IWMRMLicGen * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen_put_ClientInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_get_KeyID_Proxy( 
    IWMRMLicGen * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicGen_get_KeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_put_KeyID_Proxy( 
    IWMRMLicGen * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen_put_KeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_get_BindToPubKey_Proxy( 
    IWMRMLicGen * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicGen_get_BindToPubKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_put_BindToPubKey_Proxy( 
    IWMRMLicGen * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen_put_BindToPubKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_SetKey_Proxy( 
    IWMRMLicGen * This,
    /* [in] */ BSTR bstrType,
    /* [in] */ BSTR bstrKey);


void __RPC_STUB IWMRMLicGen_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_GetLicenseToDeliver_Proxy( 
    IWMRMLicGen * This,
    /* [retval][out] */ BSTR *pbstrLicense);


void __RPC_STUB IWMRMLicGen_GetLicenseToDeliver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_get_Attribute_Proxy( 
    IWMRMLicGen * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicGen_get_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_put_Attribute_Proxy( 
    IWMRMLicGen * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen_put_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_get_Rights_Proxy( 
    IWMRMLicGen * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicGen_get_Rights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_put_Rights_Proxy( 
    IWMRMLicGen * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen_put_Rights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen_GetClientVersion_Proxy( 
    IWMRMLicGen * This,
    /* [out][in] */ VARIANT *pvarCategory,
    /* [out][in] */ VARIANT *pvarVersion);


void __RPC_STUB IWMRMLicGen_GetClientVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicGen_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicGen2_INTERFACE_DEFINED__
#define __IWMRMLicGen2_INTERFACE_DEFINED__

/* interface IWMRMLicGen2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicGen2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BF10E749-9C9F-47a1-917C-E6998AE162A0")
    IWMRMLicGen2 : public IWMRMLicGen
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsClientExcluded( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IndividualizedVersion( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddContentRevocation( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicGen2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicGen2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicGen2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicGen2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicGen2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicGen2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicGen2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicGen2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IWMRMLicGen2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IWMRMLicGen2 * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientInfo )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMLicGen2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BindToPubKey )( 
            IWMRMLicGen2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BindToPubKey )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLicenseToDeliver )( 
            IWMRMLicGen2 * This,
            /* [retval][out] */ BSTR *pbstrLicense);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rights )( 
            IWMRMLicGen2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rights )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetClientVersion )( 
            IWMRMLicGen2 * This,
            /* [out][in] */ VARIANT *pvarCategory,
            /* [out][in] */ VARIANT *pvarVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsClientExcluded )( 
            IWMRMLicGen2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IndividualizedVersion )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddContentRevocation )( 
            IWMRMLicGen2 * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IWMRMLicGen2Vtbl;

    interface IWMRMLicGen2
    {
        CONST_VTBL struct IWMRMLicGen2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicGen2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicGen2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicGen2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicGen2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicGen2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicGen2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicGen2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicGen2_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IWMRMLicGen2_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IWMRMLicGen2_put_ClientInfo(This,newVal)	\
    (This)->lpVtbl -> put_ClientInfo(This,newVal)

#define IWMRMLicGen2_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMLicGen2_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMLicGen2_get_BindToPubKey(This,pVal)	\
    (This)->lpVtbl -> get_BindToPubKey(This,pVal)

#define IWMRMLicGen2_put_BindToPubKey(This,newVal)	\
    (This)->lpVtbl -> put_BindToPubKey(This,newVal)

#define IWMRMLicGen2_SetKey(This,bstrType,bstrKey)	\
    (This)->lpVtbl -> SetKey(This,bstrType,bstrKey)

#define IWMRMLicGen2_GetLicenseToDeliver(This,pbstrLicense)	\
    (This)->lpVtbl -> GetLicenseToDeliver(This,pbstrLicense)

#define IWMRMLicGen2_get_Attribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,bstrName,pVal)

#define IWMRMLicGen2_put_Attribute(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,bstrName,newVal)

#define IWMRMLicGen2_get_Rights(This,pVal)	\
    (This)->lpVtbl -> get_Rights(This,pVal)

#define IWMRMLicGen2_put_Rights(This,newVal)	\
    (This)->lpVtbl -> put_Rights(This,newVal)

#define IWMRMLicGen2_GetClientVersion(This,pvarCategory,pvarVersion)	\
    (This)->lpVtbl -> GetClientVersion(This,pvarCategory,pvarVersion)


#define IWMRMLicGen2_get_IsClientExcluded(This,pVal)	\
    (This)->lpVtbl -> get_IsClientExcluded(This,pVal)

#define IWMRMLicGen2_put_IndividualizedVersion(This,newVal)	\
    (This)->lpVtbl -> put_IndividualizedVersion(This,newVal)

#define IWMRMLicGen2_AddContentRevocation(This,newVal)	\
    (This)->lpVtbl -> AddContentRevocation(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen2_get_IsClientExcluded_Proxy( 
    IWMRMLicGen2 * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMLicGen2_get_IsClientExcluded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen2_put_IndividualizedVersion_Proxy( 
    IWMRMLicGen2 * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen2_put_IndividualizedVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen2_AddContentRevocation_Proxy( 
    IWMRMLicGen2 * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen2_AddContentRevocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicGen2_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicGen3_INTERFACE_DEFINED__
#define __IWMRMLicGen3_INTERFACE_DEFINED__

/* interface IWMRMLicGen3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicGen3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8A86E62-DB16-4387-83EF-96663388DFB5")
    IWMRMLicGen3 : public IWMRMLicGen2
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UplinkKid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UplinkKid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UplinkKey( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UplinkKey( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeteringCertificate( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MeteringCertificate( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicGen3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicGen3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicGen3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicGen3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicGen3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicGen3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicGen3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicGen3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IWMRMLicGen3 * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientInfo )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BindToPubKey )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BindToPubKey )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLicenseToDeliver )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ BSTR *pbstrLicense);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rights )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rights )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetClientVersion )( 
            IWMRMLicGen3 * This,
            /* [out][in] */ VARIANT *pvarCategory,
            /* [out][in] */ VARIANT *pvarVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsClientExcluded )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IndividualizedVersion )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddContentRevocation )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UplinkKid )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UplinkKid )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UplinkKey )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UplinkKey )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeteringCertificate )( 
            IWMRMLicGen3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MeteringCertificate )( 
            IWMRMLicGen3 * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IWMRMLicGen3Vtbl;

    interface IWMRMLicGen3
    {
        CONST_VTBL struct IWMRMLicGen3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicGen3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicGen3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicGen3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicGen3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicGen3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicGen3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicGen3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicGen3_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IWMRMLicGen3_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IWMRMLicGen3_put_ClientInfo(This,newVal)	\
    (This)->lpVtbl -> put_ClientInfo(This,newVal)

#define IWMRMLicGen3_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMLicGen3_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMLicGen3_get_BindToPubKey(This,pVal)	\
    (This)->lpVtbl -> get_BindToPubKey(This,pVal)

#define IWMRMLicGen3_put_BindToPubKey(This,newVal)	\
    (This)->lpVtbl -> put_BindToPubKey(This,newVal)

#define IWMRMLicGen3_SetKey(This,bstrType,bstrKey)	\
    (This)->lpVtbl -> SetKey(This,bstrType,bstrKey)

#define IWMRMLicGen3_GetLicenseToDeliver(This,pbstrLicense)	\
    (This)->lpVtbl -> GetLicenseToDeliver(This,pbstrLicense)

#define IWMRMLicGen3_get_Attribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,bstrName,pVal)

#define IWMRMLicGen3_put_Attribute(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,bstrName,newVal)

#define IWMRMLicGen3_get_Rights(This,pVal)	\
    (This)->lpVtbl -> get_Rights(This,pVal)

#define IWMRMLicGen3_put_Rights(This,newVal)	\
    (This)->lpVtbl -> put_Rights(This,newVal)

#define IWMRMLicGen3_GetClientVersion(This,pvarCategory,pvarVersion)	\
    (This)->lpVtbl -> GetClientVersion(This,pvarCategory,pvarVersion)


#define IWMRMLicGen3_get_IsClientExcluded(This,pVal)	\
    (This)->lpVtbl -> get_IsClientExcluded(This,pVal)

#define IWMRMLicGen3_put_IndividualizedVersion(This,newVal)	\
    (This)->lpVtbl -> put_IndividualizedVersion(This,newVal)

#define IWMRMLicGen3_AddContentRevocation(This,newVal)	\
    (This)->lpVtbl -> AddContentRevocation(This,newVal)


#define IWMRMLicGen3_get_UplinkKid(This,pVal)	\
    (This)->lpVtbl -> get_UplinkKid(This,pVal)

#define IWMRMLicGen3_put_UplinkKid(This,newVal)	\
    (This)->lpVtbl -> put_UplinkKid(This,newVal)

#define IWMRMLicGen3_get_UplinkKey(This,pVal)	\
    (This)->lpVtbl -> get_UplinkKey(This,pVal)

#define IWMRMLicGen3_put_UplinkKey(This,newVal)	\
    (This)->lpVtbl -> put_UplinkKey(This,newVal)

#define IWMRMLicGen3_get_MeteringCertificate(This,pVal)	\
    (This)->lpVtbl -> get_MeteringCertificate(This,pVal)

#define IWMRMLicGen3_put_MeteringCertificate(This,newVal)	\
    (This)->lpVtbl -> put_MeteringCertificate(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen3_get_UplinkKid_Proxy( 
    IWMRMLicGen3 * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicGen3_get_UplinkKid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen3_put_UplinkKid_Proxy( 
    IWMRMLicGen3 * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen3_put_UplinkKid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen3_get_UplinkKey_Proxy( 
    IWMRMLicGen3 * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicGen3_get_UplinkKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen3_put_UplinkKey_Proxy( 
    IWMRMLicGen3 * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen3_put_UplinkKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen3_get_MeteringCertificate_Proxy( 
    IWMRMLicGen3 * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicGen3_get_MeteringCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen3_put_MeteringCertificate_Proxy( 
    IWMRMLicGen3 * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicGen3_put_MeteringCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicGen3_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicGen4_INTERFACE_DEFINED__
#define __IWMRMLicGen4_INTERFACE_DEFINED__

/* interface IWMRMLicGen4 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicGen4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9285CD7-2256-43e6-BBDA-5BDEB50172EA")
    IWMRMLicGen4 : public IWMRMLicGen3
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetInclusionList( 
            /* [in] */ BSTR pXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicGen4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicGen4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicGen4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicGen4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicGen4 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicGen4 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicGen4 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicGen4 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IWMRMLicGen4 * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientInfo )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BindToPubKey )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BindToPubKey )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLicenseToDeliver )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ BSTR *pbstrLicense);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rights )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rights )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetClientVersion )( 
            IWMRMLicGen4 * This,
            /* [out][in] */ VARIANT *pvarCategory,
            /* [out][in] */ VARIANT *pvarVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsClientExcluded )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IndividualizedVersion )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddContentRevocation )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UplinkKid )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UplinkKid )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UplinkKey )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UplinkKey )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeteringCertificate )( 
            IWMRMLicGen4 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MeteringCertificate )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetInclusionList )( 
            IWMRMLicGen4 * This,
            /* [in] */ BSTR pXML);
        
        END_INTERFACE
    } IWMRMLicGen4Vtbl;

    interface IWMRMLicGen4
    {
        CONST_VTBL struct IWMRMLicGen4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicGen4_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicGen4_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicGen4_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicGen4_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicGen4_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicGen4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicGen4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicGen4_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IWMRMLicGen4_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IWMRMLicGen4_put_ClientInfo(This,newVal)	\
    (This)->lpVtbl -> put_ClientInfo(This,newVal)

#define IWMRMLicGen4_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMLicGen4_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMLicGen4_get_BindToPubKey(This,pVal)	\
    (This)->lpVtbl -> get_BindToPubKey(This,pVal)

#define IWMRMLicGen4_put_BindToPubKey(This,newVal)	\
    (This)->lpVtbl -> put_BindToPubKey(This,newVal)

#define IWMRMLicGen4_SetKey(This,bstrType,bstrKey)	\
    (This)->lpVtbl -> SetKey(This,bstrType,bstrKey)

#define IWMRMLicGen4_GetLicenseToDeliver(This,pbstrLicense)	\
    (This)->lpVtbl -> GetLicenseToDeliver(This,pbstrLicense)

#define IWMRMLicGen4_get_Attribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,bstrName,pVal)

#define IWMRMLicGen4_put_Attribute(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,bstrName,newVal)

#define IWMRMLicGen4_get_Rights(This,pVal)	\
    (This)->lpVtbl -> get_Rights(This,pVal)

#define IWMRMLicGen4_put_Rights(This,newVal)	\
    (This)->lpVtbl -> put_Rights(This,newVal)

#define IWMRMLicGen4_GetClientVersion(This,pvarCategory,pvarVersion)	\
    (This)->lpVtbl -> GetClientVersion(This,pvarCategory,pvarVersion)


#define IWMRMLicGen4_get_IsClientExcluded(This,pVal)	\
    (This)->lpVtbl -> get_IsClientExcluded(This,pVal)

#define IWMRMLicGen4_put_IndividualizedVersion(This,newVal)	\
    (This)->lpVtbl -> put_IndividualizedVersion(This,newVal)

#define IWMRMLicGen4_AddContentRevocation(This,newVal)	\
    (This)->lpVtbl -> AddContentRevocation(This,newVal)


#define IWMRMLicGen4_get_UplinkKid(This,pVal)	\
    (This)->lpVtbl -> get_UplinkKid(This,pVal)

#define IWMRMLicGen4_put_UplinkKid(This,newVal)	\
    (This)->lpVtbl -> put_UplinkKid(This,newVal)

#define IWMRMLicGen4_get_UplinkKey(This,pVal)	\
    (This)->lpVtbl -> get_UplinkKey(This,pVal)

#define IWMRMLicGen4_put_UplinkKey(This,newVal)	\
    (This)->lpVtbl -> put_UplinkKey(This,newVal)

#define IWMRMLicGen4_get_MeteringCertificate(This,pVal)	\
    (This)->lpVtbl -> get_MeteringCertificate(This,pVal)

#define IWMRMLicGen4_put_MeteringCertificate(This,newVal)	\
    (This)->lpVtbl -> put_MeteringCertificate(This,newVal)


#define IWMRMLicGen4_SetInclusionList(This,pXML)	\
    (This)->lpVtbl -> SetInclusionList(This,pXML)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen4_SetInclusionList_Proxy( 
    IWMRMLicGen4 * This,
    /* [in] */ BSTR pXML);


void __RPC_STUB IWMRMLicGen4_SetInclusionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicGen4_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicGen5_INTERFACE_DEFINED__
#define __IWMRMLicGen5_INTERFACE_DEFINED__

/* interface IWMRMLicGen5 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicGen5;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05A1502E-54CB-4e6b-8273-5E5667EE0C6D")
    IWMRMLicGen5 : public IWMRMLicGen4
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RIV( 
            /* [retval][out] */ DWORD *pdwRIV) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedCRLS( 
            /* [retval][out] */ BSTR *f_pbstrSupportedCRLS) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicGen5Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicGen5 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicGen5 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicGen5 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicGen5 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicGen5 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicGen5 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicGen5 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IWMRMLicGen5 * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientInfo )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyID )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyID )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BindToPubKey )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BindToPubKey )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLicenseToDeliver )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BSTR *pbstrLicense);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rights )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rights )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetClientVersion )( 
            IWMRMLicGen5 * This,
            /* [out][in] */ VARIANT *pvarCategory,
            /* [out][in] */ VARIANT *pvarVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsClientExcluded )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IndividualizedVersion )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddContentRevocation )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UplinkKid )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UplinkKid )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UplinkKey )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UplinkKey )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeteringCertificate )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MeteringCertificate )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetInclusionList )( 
            IWMRMLicGen5 * This,
            /* [in] */ BSTR pXML);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RIV )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ DWORD *pdwRIV);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedCRLS )( 
            IWMRMLicGen5 * This,
            /* [retval][out] */ BSTR *f_pbstrSupportedCRLS);
        
        END_INTERFACE
    } IWMRMLicGen5Vtbl;

    interface IWMRMLicGen5
    {
        CONST_VTBL struct IWMRMLicGen5Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicGen5_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicGen5_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicGen5_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicGen5_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicGen5_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicGen5_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicGen5_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicGen5_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IWMRMLicGen5_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IWMRMLicGen5_put_ClientInfo(This,newVal)	\
    (This)->lpVtbl -> put_ClientInfo(This,newVal)

#define IWMRMLicGen5_get_KeyID(This,pVal)	\
    (This)->lpVtbl -> get_KeyID(This,pVal)

#define IWMRMLicGen5_put_KeyID(This,newVal)	\
    (This)->lpVtbl -> put_KeyID(This,newVal)

#define IWMRMLicGen5_get_BindToPubKey(This,pVal)	\
    (This)->lpVtbl -> get_BindToPubKey(This,pVal)

#define IWMRMLicGen5_put_BindToPubKey(This,newVal)	\
    (This)->lpVtbl -> put_BindToPubKey(This,newVal)

#define IWMRMLicGen5_SetKey(This,bstrType,bstrKey)	\
    (This)->lpVtbl -> SetKey(This,bstrType,bstrKey)

#define IWMRMLicGen5_GetLicenseToDeliver(This,pbstrLicense)	\
    (This)->lpVtbl -> GetLicenseToDeliver(This,pbstrLicense)

#define IWMRMLicGen5_get_Attribute(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,bstrName,pVal)

#define IWMRMLicGen5_put_Attribute(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,bstrName,newVal)

#define IWMRMLicGen5_get_Rights(This,pVal)	\
    (This)->lpVtbl -> get_Rights(This,pVal)

#define IWMRMLicGen5_put_Rights(This,newVal)	\
    (This)->lpVtbl -> put_Rights(This,newVal)

#define IWMRMLicGen5_GetClientVersion(This,pvarCategory,pvarVersion)	\
    (This)->lpVtbl -> GetClientVersion(This,pvarCategory,pvarVersion)


#define IWMRMLicGen5_get_IsClientExcluded(This,pVal)	\
    (This)->lpVtbl -> get_IsClientExcluded(This,pVal)

#define IWMRMLicGen5_put_IndividualizedVersion(This,newVal)	\
    (This)->lpVtbl -> put_IndividualizedVersion(This,newVal)

#define IWMRMLicGen5_AddContentRevocation(This,newVal)	\
    (This)->lpVtbl -> AddContentRevocation(This,newVal)


#define IWMRMLicGen5_get_UplinkKid(This,pVal)	\
    (This)->lpVtbl -> get_UplinkKid(This,pVal)

#define IWMRMLicGen5_put_UplinkKid(This,newVal)	\
    (This)->lpVtbl -> put_UplinkKid(This,newVal)

#define IWMRMLicGen5_get_UplinkKey(This,pVal)	\
    (This)->lpVtbl -> get_UplinkKey(This,pVal)

#define IWMRMLicGen5_put_UplinkKey(This,newVal)	\
    (This)->lpVtbl -> put_UplinkKey(This,newVal)

#define IWMRMLicGen5_get_MeteringCertificate(This,pVal)	\
    (This)->lpVtbl -> get_MeteringCertificate(This,pVal)

#define IWMRMLicGen5_put_MeteringCertificate(This,newVal)	\
    (This)->lpVtbl -> put_MeteringCertificate(This,newVal)


#define IWMRMLicGen5_SetInclusionList(This,pXML)	\
    (This)->lpVtbl -> SetInclusionList(This,pXML)


#define IWMRMLicGen5_get_RIV(This,pdwRIV)	\
    (This)->lpVtbl -> get_RIV(This,pdwRIV)

#define IWMRMLicGen5_get_SupportedCRLS(This,f_pbstrSupportedCRLS)	\
    (This)->lpVtbl -> get_SupportedCRLS(This,f_pbstrSupportedCRLS)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen5_get_RIV_Proxy( 
    IWMRMLicGen5 * This,
    /* [retval][out] */ DWORD *pdwRIV);


void __RPC_STUB IWMRMLicGen5_get_RIV_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicGen5_get_SupportedCRLS_Proxy( 
    IWMRMLicGen5 * This,
    /* [retval][out] */ BSTR *f_pbstrSupportedCRLS);


void __RPC_STUB IWMRMLicGen5_get_SupportedCRLS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicGen5_INTERFACE_DEFINED__ */


#ifndef __IWMRMRights_INTERFACE_DEFINED__
#define __IWMRMRights_INTERFACE_DEFINED__

/* interface IWMRMRights */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMRights;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F32F2174-5529-4D22-A2B8-7905F389F1C9")
    IWMRMRights : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowBackupRestore( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowBackupRestore( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowBurnToCD( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowBurnToCD( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BeginDate( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BeginDate( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeleteOnClockRollback( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DeleteOnClockRollback( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisableOnClockRollback( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DisableOnClockRollback( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExpirationDate( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ExpirationDate( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllRights( 
            /* [retval][out] */ BSTR *pbstrRights) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinimumAppSecurity( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MinimumAppSecurity( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowPlayOnPC( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowPlayOnPC( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Playcount( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Playcount( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSAPMode( 
            /* [in] */ VARIANT varAllowDigitalOut,
            /* [in] */ VARIANT varCheckDriverCerts,
            /* [in] */ VARIANT varMinDriverSecurity) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSAPMode( 
            /* [out][in] */ VARIANT *pvarAllowDigitalOut,
            /* [out][in] */ VARIANT *pvarCheckDriverCerts,
            /* [out][in] */ VARIANT *pvarMinDriverSecurity) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowTransferToSDMI( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowTransferToSDMI( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowTransferToNonSDMI( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowTransferToNonSDMI( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransferCount( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TransferCount( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PMRights( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PMRights( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PMAppSecurity( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PMAppSecurity( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PMExpirationDate( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PMExpirationDate( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BurnToCDCount( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BurnToCDCount( 
            /* [in] */ DWORD newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMRightsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMRights * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMRights * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMRights * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMRights * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMRights * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMRights * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMRights * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowBackupRestore )( 
            IWMRMRights * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowBackupRestore )( 
            IWMRMRights * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowBurnToCD )( 
            IWMRMRights * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowBurnToCD )( 
            IWMRMRights * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BeginDate )( 
            IWMRMRights * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BeginDate )( 
            IWMRMRights * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteOnClockRollback )( 
            IWMRMRights * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteOnClockRollback )( 
            IWMRMRights * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisableOnClockRollback )( 
            IWMRMRights * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisableOnClockRollback )( 
            IWMRMRights * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationDate )( 
            IWMRMRights * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExpirationDate )( 
            IWMRMRights * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAllRights )( 
            IWMRMRights * This,
            /* [retval][out] */ BSTR *pbstrRights);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumAppSecurity )( 
            IWMRMRights * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumAppSecurity )( 
            IWMRMRights * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlayOnPC )( 
            IWMRMRights * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlayOnPC )( 
            IWMRMRights * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Playcount )( 
            IWMRMRights * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Playcount )( 
            IWMRMRights * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMRMRights * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSAPMode )( 
            IWMRMRights * This,
            /* [in] */ VARIANT varAllowDigitalOut,
            /* [in] */ VARIANT varCheckDriverCerts,
            /* [in] */ VARIANT varMinDriverSecurity);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSAPMode )( 
            IWMRMRights * This,
            /* [out][in] */ VARIANT *pvarAllowDigitalOut,
            /* [out][in] */ VARIANT *pvarCheckDriverCerts,
            /* [out][in] */ VARIANT *pvarMinDriverSecurity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowTransferToSDMI )( 
            IWMRMRights * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowTransferToSDMI )( 
            IWMRMRights * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowTransferToNonSDMI )( 
            IWMRMRights * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowTransferToNonSDMI )( 
            IWMRMRights * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransferCount )( 
            IWMRMRights * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TransferCount )( 
            IWMRMRights * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMRights )( 
            IWMRMRights * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMRights )( 
            IWMRMRights * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMAppSecurity )( 
            IWMRMRights * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMAppSecurity )( 
            IWMRMRights * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMExpirationDate )( 
            IWMRMRights * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMExpirationDate )( 
            IWMRMRights * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BurnToCDCount )( 
            IWMRMRights * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BurnToCDCount )( 
            IWMRMRights * This,
            /* [in] */ DWORD newVal);
        
        END_INTERFACE
    } IWMRMRightsVtbl;

    interface IWMRMRights
    {
        CONST_VTBL struct IWMRMRightsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMRights_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMRights_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMRights_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMRights_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMRights_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMRights_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMRights_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMRights_get_AllowBackupRestore(This,pVal)	\
    (This)->lpVtbl -> get_AllowBackupRestore(This,pVal)

#define IWMRMRights_put_AllowBackupRestore(This,newVal)	\
    (This)->lpVtbl -> put_AllowBackupRestore(This,newVal)

#define IWMRMRights_get_AllowBurnToCD(This,pVal)	\
    (This)->lpVtbl -> get_AllowBurnToCD(This,pVal)

#define IWMRMRights_put_AllowBurnToCD(This,newVal)	\
    (This)->lpVtbl -> put_AllowBurnToCD(This,newVal)

#define IWMRMRights_get_BeginDate(This,pVal)	\
    (This)->lpVtbl -> get_BeginDate(This,pVal)

#define IWMRMRights_put_BeginDate(This,newVal)	\
    (This)->lpVtbl -> put_BeginDate(This,newVal)

#define IWMRMRights_get_DeleteOnClockRollback(This,pVal)	\
    (This)->lpVtbl -> get_DeleteOnClockRollback(This,pVal)

#define IWMRMRights_put_DeleteOnClockRollback(This,newVal)	\
    (This)->lpVtbl -> put_DeleteOnClockRollback(This,newVal)

#define IWMRMRights_get_DisableOnClockRollback(This,pVal)	\
    (This)->lpVtbl -> get_DisableOnClockRollback(This,pVal)

#define IWMRMRights_put_DisableOnClockRollback(This,newVal)	\
    (This)->lpVtbl -> put_DisableOnClockRollback(This,newVal)

#define IWMRMRights_get_ExpirationDate(This,pVal)	\
    (This)->lpVtbl -> get_ExpirationDate(This,pVal)

#define IWMRMRights_put_ExpirationDate(This,newVal)	\
    (This)->lpVtbl -> put_ExpirationDate(This,newVal)

#define IWMRMRights_GetAllRights(This,pbstrRights)	\
    (This)->lpVtbl -> GetAllRights(This,pbstrRights)

#define IWMRMRights_get_MinimumAppSecurity(This,pVal)	\
    (This)->lpVtbl -> get_MinimumAppSecurity(This,pVal)

#define IWMRMRights_put_MinimumAppSecurity(This,newVal)	\
    (This)->lpVtbl -> put_MinimumAppSecurity(This,newVal)

#define IWMRMRights_get_AllowPlayOnPC(This,pVal)	\
    (This)->lpVtbl -> get_AllowPlayOnPC(This,pVal)

#define IWMRMRights_put_AllowPlayOnPC(This,newVal)	\
    (This)->lpVtbl -> put_AllowPlayOnPC(This,newVal)

#define IWMRMRights_get_Playcount(This,pVal)	\
    (This)->lpVtbl -> get_Playcount(This,pVal)

#define IWMRMRights_put_Playcount(This,newVal)	\
    (This)->lpVtbl -> put_Playcount(This,newVal)

#define IWMRMRights_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMRMRights_SetSAPMode(This,varAllowDigitalOut,varCheckDriverCerts,varMinDriverSecurity)	\
    (This)->lpVtbl -> SetSAPMode(This,varAllowDigitalOut,varCheckDriverCerts,varMinDriverSecurity)

#define IWMRMRights_GetSAPMode(This,pvarAllowDigitalOut,pvarCheckDriverCerts,pvarMinDriverSecurity)	\
    (This)->lpVtbl -> GetSAPMode(This,pvarAllowDigitalOut,pvarCheckDriverCerts,pvarMinDriverSecurity)

#define IWMRMRights_get_AllowTransferToSDMI(This,pVal)	\
    (This)->lpVtbl -> get_AllowTransferToSDMI(This,pVal)

#define IWMRMRights_put_AllowTransferToSDMI(This,newVal)	\
    (This)->lpVtbl -> put_AllowTransferToSDMI(This,newVal)

#define IWMRMRights_get_AllowTransferToNonSDMI(This,pVal)	\
    (This)->lpVtbl -> get_AllowTransferToNonSDMI(This,pVal)

#define IWMRMRights_put_AllowTransferToNonSDMI(This,newVal)	\
    (This)->lpVtbl -> put_AllowTransferToNonSDMI(This,newVal)

#define IWMRMRights_get_TransferCount(This,pVal)	\
    (This)->lpVtbl -> get_TransferCount(This,pVal)

#define IWMRMRights_put_TransferCount(This,newVal)	\
    (This)->lpVtbl -> put_TransferCount(This,newVal)

#define IWMRMRights_get_PMRights(This,pVal)	\
    (This)->lpVtbl -> get_PMRights(This,pVal)

#define IWMRMRights_put_PMRights(This,newVal)	\
    (This)->lpVtbl -> put_PMRights(This,newVal)

#define IWMRMRights_get_PMAppSecurity(This,pVal)	\
    (This)->lpVtbl -> get_PMAppSecurity(This,pVal)

#define IWMRMRights_put_PMAppSecurity(This,newVal)	\
    (This)->lpVtbl -> put_PMAppSecurity(This,newVal)

#define IWMRMRights_get_PMExpirationDate(This,pVal)	\
    (This)->lpVtbl -> get_PMExpirationDate(This,pVal)

#define IWMRMRights_put_PMExpirationDate(This,newVal)	\
    (This)->lpVtbl -> put_PMExpirationDate(This,newVal)

#define IWMRMRights_get_BurnToCDCount(This,pVal)	\
    (This)->lpVtbl -> get_BurnToCDCount(This,pVal)

#define IWMRMRights_put_BurnToCDCount(This,newVal)	\
    (This)->lpVtbl -> put_BurnToCDCount(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_AllowBackupRestore_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMRights_get_AllowBackupRestore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_AllowBackupRestore_Proxy( 
    IWMRMRights * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IWMRMRights_put_AllowBackupRestore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_AllowBurnToCD_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMRights_get_AllowBurnToCD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_AllowBurnToCD_Proxy( 
    IWMRMRights * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IWMRMRights_put_AllowBurnToCD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_BeginDate_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMRights_get_BeginDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_BeginDate_Proxy( 
    IWMRMRights * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMRights_put_BeginDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_DeleteOnClockRollback_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMRights_get_DeleteOnClockRollback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_DeleteOnClockRollback_Proxy( 
    IWMRMRights * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IWMRMRights_put_DeleteOnClockRollback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_DisableOnClockRollback_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMRights_get_DisableOnClockRollback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_DisableOnClockRollback_Proxy( 
    IWMRMRights * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IWMRMRights_put_DisableOnClockRollback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_ExpirationDate_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMRights_get_ExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_ExpirationDate_Proxy( 
    IWMRMRights * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMRights_put_ExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRights_GetAllRights_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BSTR *pbstrRights);


void __RPC_STUB IWMRMRights_GetAllRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_MinimumAppSecurity_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights_get_MinimumAppSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_MinimumAppSecurity_Proxy( 
    IWMRMRights * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights_put_MinimumAppSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_AllowPlayOnPC_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMRights_get_AllowPlayOnPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_AllowPlayOnPC_Proxy( 
    IWMRMRights * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IWMRMRights_put_AllowPlayOnPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_Playcount_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights_get_Playcount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_Playcount_Proxy( 
    IWMRMRights * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights_put_Playcount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRights_Reset_Proxy( 
    IWMRMRights * This);


void __RPC_STUB IWMRMRights_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRights_SetSAPMode_Proxy( 
    IWMRMRights * This,
    /* [in] */ VARIANT varAllowDigitalOut,
    /* [in] */ VARIANT varCheckDriverCerts,
    /* [in] */ VARIANT varMinDriverSecurity);


void __RPC_STUB IWMRMRights_SetSAPMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRights_GetSAPMode_Proxy( 
    IWMRMRights * This,
    /* [out][in] */ VARIANT *pvarAllowDigitalOut,
    /* [out][in] */ VARIANT *pvarCheckDriverCerts,
    /* [out][in] */ VARIANT *pvarMinDriverSecurity);


void __RPC_STUB IWMRMRights_GetSAPMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_AllowTransferToSDMI_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMRights_get_AllowTransferToSDMI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_AllowTransferToSDMI_Proxy( 
    IWMRMRights * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IWMRMRights_put_AllowTransferToSDMI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_AllowTransferToNonSDMI_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMRights_get_AllowTransferToNonSDMI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_AllowTransferToNonSDMI_Proxy( 
    IWMRMRights * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IWMRMRights_put_AllowTransferToNonSDMI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_TransferCount_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights_get_TransferCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_TransferCount_Proxy( 
    IWMRMRights * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights_put_TransferCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_PMRights_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights_get_PMRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_PMRights_Proxy( 
    IWMRMRights * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights_put_PMRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_PMAppSecurity_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights_get_PMAppSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_PMAppSecurity_Proxy( 
    IWMRMRights * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights_put_PMAppSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_PMExpirationDate_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMRights_get_PMExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_PMExpirationDate_Proxy( 
    IWMRMRights * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMRights_put_PMExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights_get_BurnToCDCount_Proxy( 
    IWMRMRights * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights_get_BurnToCDCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights_put_BurnToCDCount_Proxy( 
    IWMRMRights * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights_put_BurnToCDCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMRights_INTERFACE_DEFINED__ */


#ifndef __IWMRMRights2_INTERFACE_DEFINED__
#define __IWMRMRights2_INTERFACE_DEFINED__

/* interface IWMRMRights2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMRights2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E049387D-AAF0-4856-9E18-5FDBBC847D9D")
    IWMRMRights2 : public IWMRMRights
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExpirationAfterFirstUse( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ExpirationAfterFirstUse( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExpirationOnStore( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ExpirationOnStore( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowSaveStreamProtected( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowSaveStreamProtected( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExcludeApplication( 
            /* [in] */ DWORD dwAppID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinimumClientSDKSecurity( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MinimumClientSDKSecurity( 
            /* [in] */ DWORD newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMRights2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMRights2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMRights2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMRights2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMRights2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMRights2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMRights2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMRights2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowBackupRestore )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowBackupRestore )( 
            IWMRMRights2 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowBurnToCD )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowBurnToCD )( 
            IWMRMRights2 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BeginDate )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BeginDate )( 
            IWMRMRights2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteOnClockRollback )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteOnClockRollback )( 
            IWMRMRights2 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisableOnClockRollback )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisableOnClockRollback )( 
            IWMRMRights2 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationDate )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExpirationDate )( 
            IWMRMRights2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAllRights )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BSTR *pbstrRights);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumAppSecurity )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumAppSecurity )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlayOnPC )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlayOnPC )( 
            IWMRMRights2 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Playcount )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Playcount )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMRMRights2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSAPMode )( 
            IWMRMRights2 * This,
            /* [in] */ VARIANT varAllowDigitalOut,
            /* [in] */ VARIANT varCheckDriverCerts,
            /* [in] */ VARIANT varMinDriverSecurity);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSAPMode )( 
            IWMRMRights2 * This,
            /* [out][in] */ VARIANT *pvarAllowDigitalOut,
            /* [out][in] */ VARIANT *pvarCheckDriverCerts,
            /* [out][in] */ VARIANT *pvarMinDriverSecurity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowTransferToSDMI )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowTransferToSDMI )( 
            IWMRMRights2 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowTransferToNonSDMI )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowTransferToNonSDMI )( 
            IWMRMRights2 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransferCount )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TransferCount )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMRights )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMRights )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMAppSecurity )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMAppSecurity )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMExpirationDate )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMExpirationDate )( 
            IWMRMRights2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BurnToCDCount )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BurnToCDCount )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationAfterFirstUse )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExpirationAfterFirstUse )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationOnStore )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExpirationOnStore )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowSaveStreamProtected )( 
            IWMRMRights2 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowSaveStreamProtected )( 
            IWMRMRights2 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExcludeApplication )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD dwAppID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumClientSDKSecurity )( 
            IWMRMRights2 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumClientSDKSecurity )( 
            IWMRMRights2 * This,
            /* [in] */ DWORD newVal);
        
        END_INTERFACE
    } IWMRMRights2Vtbl;

    interface IWMRMRights2
    {
        CONST_VTBL struct IWMRMRights2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMRights2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMRights2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMRights2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMRights2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMRights2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMRights2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMRights2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMRights2_get_AllowBackupRestore(This,pVal)	\
    (This)->lpVtbl -> get_AllowBackupRestore(This,pVal)

#define IWMRMRights2_put_AllowBackupRestore(This,newVal)	\
    (This)->lpVtbl -> put_AllowBackupRestore(This,newVal)

#define IWMRMRights2_get_AllowBurnToCD(This,pVal)	\
    (This)->lpVtbl -> get_AllowBurnToCD(This,pVal)

#define IWMRMRights2_put_AllowBurnToCD(This,newVal)	\
    (This)->lpVtbl -> put_AllowBurnToCD(This,newVal)

#define IWMRMRights2_get_BeginDate(This,pVal)	\
    (This)->lpVtbl -> get_BeginDate(This,pVal)

#define IWMRMRights2_put_BeginDate(This,newVal)	\
    (This)->lpVtbl -> put_BeginDate(This,newVal)

#define IWMRMRights2_get_DeleteOnClockRollback(This,pVal)	\
    (This)->lpVtbl -> get_DeleteOnClockRollback(This,pVal)

#define IWMRMRights2_put_DeleteOnClockRollback(This,newVal)	\
    (This)->lpVtbl -> put_DeleteOnClockRollback(This,newVal)

#define IWMRMRights2_get_DisableOnClockRollback(This,pVal)	\
    (This)->lpVtbl -> get_DisableOnClockRollback(This,pVal)

#define IWMRMRights2_put_DisableOnClockRollback(This,newVal)	\
    (This)->lpVtbl -> put_DisableOnClockRollback(This,newVal)

#define IWMRMRights2_get_ExpirationDate(This,pVal)	\
    (This)->lpVtbl -> get_ExpirationDate(This,pVal)

#define IWMRMRights2_put_ExpirationDate(This,newVal)	\
    (This)->lpVtbl -> put_ExpirationDate(This,newVal)

#define IWMRMRights2_GetAllRights(This,pbstrRights)	\
    (This)->lpVtbl -> GetAllRights(This,pbstrRights)

#define IWMRMRights2_get_MinimumAppSecurity(This,pVal)	\
    (This)->lpVtbl -> get_MinimumAppSecurity(This,pVal)

#define IWMRMRights2_put_MinimumAppSecurity(This,newVal)	\
    (This)->lpVtbl -> put_MinimumAppSecurity(This,newVal)

#define IWMRMRights2_get_AllowPlayOnPC(This,pVal)	\
    (This)->lpVtbl -> get_AllowPlayOnPC(This,pVal)

#define IWMRMRights2_put_AllowPlayOnPC(This,newVal)	\
    (This)->lpVtbl -> put_AllowPlayOnPC(This,newVal)

#define IWMRMRights2_get_Playcount(This,pVal)	\
    (This)->lpVtbl -> get_Playcount(This,pVal)

#define IWMRMRights2_put_Playcount(This,newVal)	\
    (This)->lpVtbl -> put_Playcount(This,newVal)

#define IWMRMRights2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMRMRights2_SetSAPMode(This,varAllowDigitalOut,varCheckDriverCerts,varMinDriverSecurity)	\
    (This)->lpVtbl -> SetSAPMode(This,varAllowDigitalOut,varCheckDriverCerts,varMinDriverSecurity)

#define IWMRMRights2_GetSAPMode(This,pvarAllowDigitalOut,pvarCheckDriverCerts,pvarMinDriverSecurity)	\
    (This)->lpVtbl -> GetSAPMode(This,pvarAllowDigitalOut,pvarCheckDriverCerts,pvarMinDriverSecurity)

#define IWMRMRights2_get_AllowTransferToSDMI(This,pVal)	\
    (This)->lpVtbl -> get_AllowTransferToSDMI(This,pVal)

#define IWMRMRights2_put_AllowTransferToSDMI(This,newVal)	\
    (This)->lpVtbl -> put_AllowTransferToSDMI(This,newVal)

#define IWMRMRights2_get_AllowTransferToNonSDMI(This,pVal)	\
    (This)->lpVtbl -> get_AllowTransferToNonSDMI(This,pVal)

#define IWMRMRights2_put_AllowTransferToNonSDMI(This,newVal)	\
    (This)->lpVtbl -> put_AllowTransferToNonSDMI(This,newVal)

#define IWMRMRights2_get_TransferCount(This,pVal)	\
    (This)->lpVtbl -> get_TransferCount(This,pVal)

#define IWMRMRights2_put_TransferCount(This,newVal)	\
    (This)->lpVtbl -> put_TransferCount(This,newVal)

#define IWMRMRights2_get_PMRights(This,pVal)	\
    (This)->lpVtbl -> get_PMRights(This,pVal)

#define IWMRMRights2_put_PMRights(This,newVal)	\
    (This)->lpVtbl -> put_PMRights(This,newVal)

#define IWMRMRights2_get_PMAppSecurity(This,pVal)	\
    (This)->lpVtbl -> get_PMAppSecurity(This,pVal)

#define IWMRMRights2_put_PMAppSecurity(This,newVal)	\
    (This)->lpVtbl -> put_PMAppSecurity(This,newVal)

#define IWMRMRights2_get_PMExpirationDate(This,pVal)	\
    (This)->lpVtbl -> get_PMExpirationDate(This,pVal)

#define IWMRMRights2_put_PMExpirationDate(This,newVal)	\
    (This)->lpVtbl -> put_PMExpirationDate(This,newVal)

#define IWMRMRights2_get_BurnToCDCount(This,pVal)	\
    (This)->lpVtbl -> get_BurnToCDCount(This,pVal)

#define IWMRMRights2_put_BurnToCDCount(This,newVal)	\
    (This)->lpVtbl -> put_BurnToCDCount(This,newVal)


#define IWMRMRights2_get_ExpirationAfterFirstUse(This,pVal)	\
    (This)->lpVtbl -> get_ExpirationAfterFirstUse(This,pVal)

#define IWMRMRights2_put_ExpirationAfterFirstUse(This,newVal)	\
    (This)->lpVtbl -> put_ExpirationAfterFirstUse(This,newVal)

#define IWMRMRights2_get_ExpirationOnStore(This,pVal)	\
    (This)->lpVtbl -> get_ExpirationOnStore(This,pVal)

#define IWMRMRights2_put_ExpirationOnStore(This,newVal)	\
    (This)->lpVtbl -> put_ExpirationOnStore(This,newVal)

#define IWMRMRights2_get_AllowSaveStreamProtected(This,pVal)	\
    (This)->lpVtbl -> get_AllowSaveStreamProtected(This,pVal)

#define IWMRMRights2_put_AllowSaveStreamProtected(This,newVal)	\
    (This)->lpVtbl -> put_AllowSaveStreamProtected(This,newVal)

#define IWMRMRights2_ExcludeApplication(This,dwAppID)	\
    (This)->lpVtbl -> ExcludeApplication(This,dwAppID)

#define IWMRMRights2_get_MinimumClientSDKSecurity(This,pVal)	\
    (This)->lpVtbl -> get_MinimumClientSDKSecurity(This,pVal)

#define IWMRMRights2_put_MinimumClientSDKSecurity(This,newVal)	\
    (This)->lpVtbl -> put_MinimumClientSDKSecurity(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_get_ExpirationAfterFirstUse_Proxy( 
    IWMRMRights2 * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights2_get_ExpirationAfterFirstUse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_put_ExpirationAfterFirstUse_Proxy( 
    IWMRMRights2 * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights2_put_ExpirationAfterFirstUse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_get_ExpirationOnStore_Proxy( 
    IWMRMRights2 * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights2_get_ExpirationOnStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_put_ExpirationOnStore_Proxy( 
    IWMRMRights2 * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights2_put_ExpirationOnStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_get_AllowSaveStreamProtected_Proxy( 
    IWMRMRights2 * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IWMRMRights2_get_AllowSaveStreamProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_put_AllowSaveStreamProtected_Proxy( 
    IWMRMRights2 * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IWMRMRights2_put_AllowSaveStreamProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_ExcludeApplication_Proxy( 
    IWMRMRights2 * This,
    /* [in] */ DWORD dwAppID);


void __RPC_STUB IWMRMRights2_ExcludeApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_get_MinimumClientSDKSecurity_Proxy( 
    IWMRMRights2 * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights2_get_MinimumClientSDKSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights2_put_MinimumClientSDKSecurity_Proxy( 
    IWMRMRights2 * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights2_put_MinimumClientSDKSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMRights2_INTERFACE_DEFINED__ */


#ifndef __IWMRMRights3_INTERFACE_DEFINED__
#define __IWMRMRights3_INTERFACE_DEFINED__

/* interface IWMRMRights3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMRights3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("84650B4B-0857-4899-B383-994642CA9D30")
    IWMRMRights3 : public IWMRMRights2
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowCollaborativePlay( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowCollaborativePlay( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowPlaylistBurn( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowPlaylistBurn( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlaylistBurnTrackCount( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlaylistBurnTrackCount( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxPlaylistBurnCount( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxPlaylistBurnCount( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowCopy( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowCopy( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CopyCount( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CopyCount( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GracePeriod( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GracePeriod( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowPlay( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowPlay( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CopyRestrictions( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CopyRestrictions( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayRestrictions( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayRestrictions( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinimumSecurityLevel( 
            /* [retval][out] */ DWORD *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MinimumSecurityLevel( 
            /* [in] */ DWORD newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMRights3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMRights3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMRights3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMRights3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMRights3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMRights3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMRights3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMRights3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowBackupRestore )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowBackupRestore )( 
            IWMRMRights3 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowBurnToCD )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowBurnToCD )( 
            IWMRMRights3 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BeginDate )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BeginDate )( 
            IWMRMRights3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteOnClockRollback )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteOnClockRollback )( 
            IWMRMRights3 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisableOnClockRollback )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisableOnClockRollback )( 
            IWMRMRights3 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationDate )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExpirationDate )( 
            IWMRMRights3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAllRights )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BSTR *pbstrRights);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumAppSecurity )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumAppSecurity )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlayOnPC )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlayOnPC )( 
            IWMRMRights3 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Playcount )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Playcount )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMRMRights3 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSAPMode )( 
            IWMRMRights3 * This,
            /* [in] */ VARIANT varAllowDigitalOut,
            /* [in] */ VARIANT varCheckDriverCerts,
            /* [in] */ VARIANT varMinDriverSecurity);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSAPMode )( 
            IWMRMRights3 * This,
            /* [out][in] */ VARIANT *pvarAllowDigitalOut,
            /* [out][in] */ VARIANT *pvarCheckDriverCerts,
            /* [out][in] */ VARIANT *pvarMinDriverSecurity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowTransferToSDMI )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowTransferToSDMI )( 
            IWMRMRights3 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowTransferToNonSDMI )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowTransferToNonSDMI )( 
            IWMRMRights3 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransferCount )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TransferCount )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMRights )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMRights )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMAppSecurity )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMAppSecurity )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PMExpirationDate )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PMExpirationDate )( 
            IWMRMRights3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BurnToCDCount )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BurnToCDCount )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationAfterFirstUse )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExpirationAfterFirstUse )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationOnStore )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExpirationOnStore )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowSaveStreamProtected )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowSaveStreamProtected )( 
            IWMRMRights3 * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExcludeApplication )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD dwAppID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumClientSDKSecurity )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumClientSDKSecurity )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowCollaborativePlay )( 
            IWMRMRights3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowCollaborativePlay )( 
            IWMRMRights3 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlaylistBurn )( 
            IWMRMRights3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlaylistBurn )( 
            IWMRMRights3 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlaylistBurnTrackCount )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlaylistBurnTrackCount )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxPlaylistBurnCount )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxPlaylistBurnCount )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowCopy )( 
            IWMRMRights3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowCopy )( 
            IWMRMRights3 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CopyCount )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CopyCount )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GracePeriod )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GracePeriod )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlay )( 
            IWMRMRights3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlay )( 
            IWMRMRights3 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CopyRestrictions )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CopyRestrictions )( 
            IWMRMRights3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayRestrictions )( 
            IWMRMRights3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayRestrictions )( 
            IWMRMRights3 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumSecurityLevel )( 
            IWMRMRights3 * This,
            /* [retval][out] */ DWORD *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumSecurityLevel )( 
            IWMRMRights3 * This,
            /* [in] */ DWORD newVal);
        
        END_INTERFACE
    } IWMRMRights3Vtbl;

    interface IWMRMRights3
    {
        CONST_VTBL struct IWMRMRights3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMRights3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMRights3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMRights3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMRights3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMRights3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMRights3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMRights3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMRights3_get_AllowBackupRestore(This,pVal)	\
    (This)->lpVtbl -> get_AllowBackupRestore(This,pVal)

#define IWMRMRights3_put_AllowBackupRestore(This,newVal)	\
    (This)->lpVtbl -> put_AllowBackupRestore(This,newVal)

#define IWMRMRights3_get_AllowBurnToCD(This,pVal)	\
    (This)->lpVtbl -> get_AllowBurnToCD(This,pVal)

#define IWMRMRights3_put_AllowBurnToCD(This,newVal)	\
    (This)->lpVtbl -> put_AllowBurnToCD(This,newVal)

#define IWMRMRights3_get_BeginDate(This,pVal)	\
    (This)->lpVtbl -> get_BeginDate(This,pVal)

#define IWMRMRights3_put_BeginDate(This,newVal)	\
    (This)->lpVtbl -> put_BeginDate(This,newVal)

#define IWMRMRights3_get_DeleteOnClockRollback(This,pVal)	\
    (This)->lpVtbl -> get_DeleteOnClockRollback(This,pVal)

#define IWMRMRights3_put_DeleteOnClockRollback(This,newVal)	\
    (This)->lpVtbl -> put_DeleteOnClockRollback(This,newVal)

#define IWMRMRights3_get_DisableOnClockRollback(This,pVal)	\
    (This)->lpVtbl -> get_DisableOnClockRollback(This,pVal)

#define IWMRMRights3_put_DisableOnClockRollback(This,newVal)	\
    (This)->lpVtbl -> put_DisableOnClockRollback(This,newVal)

#define IWMRMRights3_get_ExpirationDate(This,pVal)	\
    (This)->lpVtbl -> get_ExpirationDate(This,pVal)

#define IWMRMRights3_put_ExpirationDate(This,newVal)	\
    (This)->lpVtbl -> put_ExpirationDate(This,newVal)

#define IWMRMRights3_GetAllRights(This,pbstrRights)	\
    (This)->lpVtbl -> GetAllRights(This,pbstrRights)

#define IWMRMRights3_get_MinimumAppSecurity(This,pVal)	\
    (This)->lpVtbl -> get_MinimumAppSecurity(This,pVal)

#define IWMRMRights3_put_MinimumAppSecurity(This,newVal)	\
    (This)->lpVtbl -> put_MinimumAppSecurity(This,newVal)

#define IWMRMRights3_get_AllowPlayOnPC(This,pVal)	\
    (This)->lpVtbl -> get_AllowPlayOnPC(This,pVal)

#define IWMRMRights3_put_AllowPlayOnPC(This,newVal)	\
    (This)->lpVtbl -> put_AllowPlayOnPC(This,newVal)

#define IWMRMRights3_get_Playcount(This,pVal)	\
    (This)->lpVtbl -> get_Playcount(This,pVal)

#define IWMRMRights3_put_Playcount(This,newVal)	\
    (This)->lpVtbl -> put_Playcount(This,newVal)

#define IWMRMRights3_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMRMRights3_SetSAPMode(This,varAllowDigitalOut,varCheckDriverCerts,varMinDriverSecurity)	\
    (This)->lpVtbl -> SetSAPMode(This,varAllowDigitalOut,varCheckDriverCerts,varMinDriverSecurity)

#define IWMRMRights3_GetSAPMode(This,pvarAllowDigitalOut,pvarCheckDriverCerts,pvarMinDriverSecurity)	\
    (This)->lpVtbl -> GetSAPMode(This,pvarAllowDigitalOut,pvarCheckDriverCerts,pvarMinDriverSecurity)

#define IWMRMRights3_get_AllowTransferToSDMI(This,pVal)	\
    (This)->lpVtbl -> get_AllowTransferToSDMI(This,pVal)

#define IWMRMRights3_put_AllowTransferToSDMI(This,newVal)	\
    (This)->lpVtbl -> put_AllowTransferToSDMI(This,newVal)

#define IWMRMRights3_get_AllowTransferToNonSDMI(This,pVal)	\
    (This)->lpVtbl -> get_AllowTransferToNonSDMI(This,pVal)

#define IWMRMRights3_put_AllowTransferToNonSDMI(This,newVal)	\
    (This)->lpVtbl -> put_AllowTransferToNonSDMI(This,newVal)

#define IWMRMRights3_get_TransferCount(This,pVal)	\
    (This)->lpVtbl -> get_TransferCount(This,pVal)

#define IWMRMRights3_put_TransferCount(This,newVal)	\
    (This)->lpVtbl -> put_TransferCount(This,newVal)

#define IWMRMRights3_get_PMRights(This,pVal)	\
    (This)->lpVtbl -> get_PMRights(This,pVal)

#define IWMRMRights3_put_PMRights(This,newVal)	\
    (This)->lpVtbl -> put_PMRights(This,newVal)

#define IWMRMRights3_get_PMAppSecurity(This,pVal)	\
    (This)->lpVtbl -> get_PMAppSecurity(This,pVal)

#define IWMRMRights3_put_PMAppSecurity(This,newVal)	\
    (This)->lpVtbl -> put_PMAppSecurity(This,newVal)

#define IWMRMRights3_get_PMExpirationDate(This,pVal)	\
    (This)->lpVtbl -> get_PMExpirationDate(This,pVal)

#define IWMRMRights3_put_PMExpirationDate(This,newVal)	\
    (This)->lpVtbl -> put_PMExpirationDate(This,newVal)

#define IWMRMRights3_get_BurnToCDCount(This,pVal)	\
    (This)->lpVtbl -> get_BurnToCDCount(This,pVal)

#define IWMRMRights3_put_BurnToCDCount(This,newVal)	\
    (This)->lpVtbl -> put_BurnToCDCount(This,newVal)


#define IWMRMRights3_get_ExpirationAfterFirstUse(This,pVal)	\
    (This)->lpVtbl -> get_ExpirationAfterFirstUse(This,pVal)

#define IWMRMRights3_put_ExpirationAfterFirstUse(This,newVal)	\
    (This)->lpVtbl -> put_ExpirationAfterFirstUse(This,newVal)

#define IWMRMRights3_get_ExpirationOnStore(This,pVal)	\
    (This)->lpVtbl -> get_ExpirationOnStore(This,pVal)

#define IWMRMRights3_put_ExpirationOnStore(This,newVal)	\
    (This)->lpVtbl -> put_ExpirationOnStore(This,newVal)

#define IWMRMRights3_get_AllowSaveStreamProtected(This,pVal)	\
    (This)->lpVtbl -> get_AllowSaveStreamProtected(This,pVal)

#define IWMRMRights3_put_AllowSaveStreamProtected(This,newVal)	\
    (This)->lpVtbl -> put_AllowSaveStreamProtected(This,newVal)

#define IWMRMRights3_ExcludeApplication(This,dwAppID)	\
    (This)->lpVtbl -> ExcludeApplication(This,dwAppID)

#define IWMRMRights3_get_MinimumClientSDKSecurity(This,pVal)	\
    (This)->lpVtbl -> get_MinimumClientSDKSecurity(This,pVal)

#define IWMRMRights3_put_MinimumClientSDKSecurity(This,newVal)	\
    (This)->lpVtbl -> put_MinimumClientSDKSecurity(This,newVal)


#define IWMRMRights3_get_AllowCollaborativePlay(This,pVal)	\
    (This)->lpVtbl -> get_AllowCollaborativePlay(This,pVal)

#define IWMRMRights3_put_AllowCollaborativePlay(This,newVal)	\
    (This)->lpVtbl -> put_AllowCollaborativePlay(This,newVal)

#define IWMRMRights3_get_AllowPlaylistBurn(This,pVal)	\
    (This)->lpVtbl -> get_AllowPlaylistBurn(This,pVal)

#define IWMRMRights3_put_AllowPlaylistBurn(This,newVal)	\
    (This)->lpVtbl -> put_AllowPlaylistBurn(This,newVal)

#define IWMRMRights3_get_PlaylistBurnTrackCount(This,pVal)	\
    (This)->lpVtbl -> get_PlaylistBurnTrackCount(This,pVal)

#define IWMRMRights3_put_PlaylistBurnTrackCount(This,newVal)	\
    (This)->lpVtbl -> put_PlaylistBurnTrackCount(This,newVal)

#define IWMRMRights3_get_MaxPlaylistBurnCount(This,pVal)	\
    (This)->lpVtbl -> get_MaxPlaylistBurnCount(This,pVal)

#define IWMRMRights3_put_MaxPlaylistBurnCount(This,newVal)	\
    (This)->lpVtbl -> put_MaxPlaylistBurnCount(This,newVal)

#define IWMRMRights3_get_AllowCopy(This,pVal)	\
    (This)->lpVtbl -> get_AllowCopy(This,pVal)

#define IWMRMRights3_put_AllowCopy(This,newVal)	\
    (This)->lpVtbl -> put_AllowCopy(This,newVal)

#define IWMRMRights3_get_CopyCount(This,pVal)	\
    (This)->lpVtbl -> get_CopyCount(This,pVal)

#define IWMRMRights3_put_CopyCount(This,newVal)	\
    (This)->lpVtbl -> put_CopyCount(This,newVal)

#define IWMRMRights3_get_GracePeriod(This,pVal)	\
    (This)->lpVtbl -> get_GracePeriod(This,pVal)

#define IWMRMRights3_put_GracePeriod(This,newVal)	\
    (This)->lpVtbl -> put_GracePeriod(This,newVal)

#define IWMRMRights3_get_AllowPlay(This,pVal)	\
    (This)->lpVtbl -> get_AllowPlay(This,pVal)

#define IWMRMRights3_put_AllowPlay(This,newVal)	\
    (This)->lpVtbl -> put_AllowPlay(This,newVal)

#define IWMRMRights3_get_CopyRestrictions(This,pVal)	\
    (This)->lpVtbl -> get_CopyRestrictions(This,pVal)

#define IWMRMRights3_put_CopyRestrictions(This,newVal)	\
    (This)->lpVtbl -> put_CopyRestrictions(This,newVal)

#define IWMRMRights3_get_PlayRestrictions(This,pVal)	\
    (This)->lpVtbl -> get_PlayRestrictions(This,pVal)

#define IWMRMRights3_put_PlayRestrictions(This,newVal)	\
    (This)->lpVtbl -> put_PlayRestrictions(This,newVal)

#define IWMRMRights3_get_MinimumSecurityLevel(This,pVal)	\
    (This)->lpVtbl -> get_MinimumSecurityLevel(This,pVal)

#define IWMRMRights3_put_MinimumSecurityLevel(This,newVal)	\
    (This)->lpVtbl -> put_MinimumSecurityLevel(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_AllowCollaborativePlay_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMRMRights3_get_AllowCollaborativePlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_AllowCollaborativePlay_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMRMRights3_put_AllowCollaborativePlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_AllowPlaylistBurn_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMRMRights3_get_AllowPlaylistBurn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_AllowPlaylistBurn_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMRMRights3_put_AllowPlaylistBurn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_PlaylistBurnTrackCount_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights3_get_PlaylistBurnTrackCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_PlaylistBurnTrackCount_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights3_put_PlaylistBurnTrackCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_MaxPlaylistBurnCount_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights3_get_MaxPlaylistBurnCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_MaxPlaylistBurnCount_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights3_put_MaxPlaylistBurnCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_AllowCopy_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMRMRights3_get_AllowCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_AllowCopy_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMRMRights3_put_AllowCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_CopyCount_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights3_get_CopyCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_CopyCount_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights3_put_CopyCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_GracePeriod_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights3_get_GracePeriod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_GracePeriod_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights3_put_GracePeriod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_AllowPlay_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMRMRights3_get_AllowPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_AllowPlay_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMRMRights3_put_AllowPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_CopyRestrictions_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMRights3_get_CopyRestrictions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_CopyRestrictions_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMRights3_put_CopyRestrictions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_PlayRestrictions_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMRights3_get_PlayRestrictions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_PlayRestrictions_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMRights3_put_PlayRestrictions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_get_MinimumSecurityLevel_Proxy( 
    IWMRMRights3 * This,
    /* [retval][out] */ DWORD *pVal);


void __RPC_STUB IWMRMRights3_get_MinimumSecurityLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMRights3_put_MinimumSecurityLevel_Proxy( 
    IWMRMRights3 * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB IWMRMRights3_put_MinimumSecurityLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMRights3_INTERFACE_DEFINED__ */


#ifndef __IWMRMResponse_INTERFACE_DEFINED__
#define __IWMRMResponse_INTERFACE_DEFINED__

/* interface IWMRMResponse */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMResponse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4585796B-BC65-449a-ADDA-499D6DB07801")
    IWMRMResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddLicense( 
            /* [in] */ BSTR bstrVersion,
            /* [in] */ BSTR bstrLicense) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLicenseResponse( 
            /* [retval][out] */ BSTR *pbstrResponse) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplaceQuotesWith( 
            /* [in] */ BSTR bstrReplacement) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMResponse * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMResponse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMResponse * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMResponse * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMResponse * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMResponse * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMResponse * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddLicense )( 
            IWMRMResponse * This,
            /* [in] */ BSTR bstrVersion,
            /* [in] */ BSTR bstrLicense);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLicenseResponse )( 
            IWMRMResponse * This,
            /* [retval][out] */ BSTR *pbstrResponse);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplaceQuotesWith )( 
            IWMRMResponse * This,
            /* [in] */ BSTR bstrReplacement);
        
        END_INTERFACE
    } IWMRMResponseVtbl;

    interface IWMRMResponse
    {
        CONST_VTBL struct IWMRMResponseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMResponse_AddLicense(This,bstrVersion,bstrLicense)	\
    (This)->lpVtbl -> AddLicense(This,bstrVersion,bstrLicense)

#define IWMRMResponse_GetLicenseResponse(This,pbstrResponse)	\
    (This)->lpVtbl -> GetLicenseResponse(This,pbstrResponse)

#define IWMRMResponse_put_ReplaceQuotesWith(This,bstrReplacement)	\
    (This)->lpVtbl -> put_ReplaceQuotesWith(This,bstrReplacement)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMResponse_AddLicense_Proxy( 
    IWMRMResponse * This,
    /* [in] */ BSTR bstrVersion,
    /* [in] */ BSTR bstrLicense);


void __RPC_STUB IWMRMResponse_AddLicense_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMResponse_GetLicenseResponse_Proxy( 
    IWMRMResponse * This,
    /* [retval][out] */ BSTR *pbstrResponse);


void __RPC_STUB IWMRMResponse_GetLicenseResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMResponse_put_ReplaceQuotesWith_Proxy( 
    IWMRMResponse * This,
    /* [in] */ BSTR bstrReplacement);


void __RPC_STUB IWMRMResponse_put_ReplaceQuotesWith_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMResponse_INTERFACE_DEFINED__ */


#ifndef __IWMRMResponse2_INTERFACE_DEFINED__
#define __IWMRMResponse2_INTERFACE_DEFINED__

/* interface IWMRMResponse2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMResponse2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA22CA52-7FD8-4229-B60F-780A774608EB")
    IWMRMResponse2 : public IWMRMResponse
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddRevocationData( 
            BSTR bstrRevInfo,
            BSTR bstrSupportedCRLS,
            BOOL fRevInfoPresent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMResponse2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMResponse2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMResponse2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMResponse2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMResponse2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMResponse2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMResponse2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMResponse2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddLicense )( 
            IWMRMResponse2 * This,
            /* [in] */ BSTR bstrVersion,
            /* [in] */ BSTR bstrLicense);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLicenseResponse )( 
            IWMRMResponse2 * This,
            /* [retval][out] */ BSTR *pbstrResponse);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplaceQuotesWith )( 
            IWMRMResponse2 * This,
            /* [in] */ BSTR bstrReplacement);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddRevocationData )( 
            IWMRMResponse2 * This,
            BSTR bstrRevInfo,
            BSTR bstrSupportedCRLS,
            BOOL fRevInfoPresent);
        
        END_INTERFACE
    } IWMRMResponse2Vtbl;

    interface IWMRMResponse2
    {
        CONST_VTBL struct IWMRMResponse2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMResponse2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMResponse2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMResponse2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMResponse2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMResponse2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMResponse2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMResponse2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMResponse2_AddLicense(This,bstrVersion,bstrLicense)	\
    (This)->lpVtbl -> AddLicense(This,bstrVersion,bstrLicense)

#define IWMRMResponse2_GetLicenseResponse(This,pbstrResponse)	\
    (This)->lpVtbl -> GetLicenseResponse(This,pbstrResponse)

#define IWMRMResponse2_put_ReplaceQuotesWith(This,bstrReplacement)	\
    (This)->lpVtbl -> put_ReplaceQuotesWith(This,bstrReplacement)


#define IWMRMResponse2_AddRevocationData(This,bstrRevInfo,bstrSupportedCRLS,fRevInfoPresent)	\
    (This)->lpVtbl -> AddRevocationData(This,bstrRevInfo,bstrSupportedCRLS,fRevInfoPresent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMResponse2_AddRevocationData_Proxy( 
    IWMRMResponse2 * This,
    BSTR bstrRevInfo,
    BSTR bstrSupportedCRLS,
    BOOL fRevInfoPresent);


void __RPC_STUB IWMRMResponse2_AddRevocationData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMResponse2_INTERFACE_DEFINED__ */


#ifndef __IWMRMTools_INTERFACE_DEFINED__
#define __IWMRMTools_INTERFACE_DEFINED__

/* interface IWMRMTools */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMTools;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FFEC8072-F9F0-47fd-9B7E-C10951B36940")
    IWMRMTools : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateContentRevocation( 
            /* [in] */ BSTR bstrContentOwnerPrivKey,
            /* [in] */ DWORD dwSequenceNumber,
            /* [in] */ BSTR bstrContentOwnerPubKey,
            /* [in] */ BSTR bstrLicenseServerPubKey,
            /* [in] */ VARIANT vsrReserved,
            /* [retval][out] */ BSTR *pbstrContentRevocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMToolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMTools * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMTools * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMTools * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMTools * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMTools * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMTools * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMTools * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateContentRevocation )( 
            IWMRMTools * This,
            /* [in] */ BSTR bstrContentOwnerPrivKey,
            /* [in] */ DWORD dwSequenceNumber,
            /* [in] */ BSTR bstrContentOwnerPubKey,
            /* [in] */ BSTR bstrLicenseServerPubKey,
            /* [in] */ VARIANT vsrReserved,
            /* [retval][out] */ BSTR *pbstrContentRevocation);
        
        END_INTERFACE
    } IWMRMToolsVtbl;

    interface IWMRMTools
    {
        CONST_VTBL struct IWMRMToolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMTools_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMTools_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMTools_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMTools_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMTools_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMTools_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMTools_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMTools_GenerateContentRevocation(This,bstrContentOwnerPrivKey,dwSequenceNumber,bstrContentOwnerPubKey,bstrLicenseServerPubKey,vsrReserved,pbstrContentRevocation)	\
    (This)->lpVtbl -> GenerateContentRevocation(This,bstrContentOwnerPrivKey,dwSequenceNumber,bstrContentOwnerPubKey,bstrLicenseServerPubKey,vsrReserved,pbstrContentRevocation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMTools_GenerateContentRevocation_Proxy( 
    IWMRMTools * This,
    /* [in] */ BSTR bstrContentOwnerPrivKey,
    /* [in] */ DWORD dwSequenceNumber,
    /* [in] */ BSTR bstrContentOwnerPubKey,
    /* [in] */ BSTR bstrLicenseServerPubKey,
    /* [in] */ VARIANT vsrReserved,
    /* [retval][out] */ BSTR *pbstrContentRevocation);


void __RPC_STUB IWMRMTools_GenerateContentRevocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMTools_INTERFACE_DEFINED__ */


#ifndef __IWMRMHeaderSigning_INTERFACE_DEFINED__
#define __IWMRMHeaderSigning_INTERFACE_DEFINED__

/* interface IWMRMHeaderSigning */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMRMHeaderSigning;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("247B673A-259D-4064-A4BE-9CAECCF77BA7")
    IWMRMHeaderSigning : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddDigitalSignatureObject( 
            /* [size_is][out][in] */ BYTE *pbHeader,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwBytesNeeded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMHeaderSigningVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMHeaderSigning * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMHeaderSigning * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMHeaderSigning * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddDigitalSignatureObject )( 
            IWMRMHeaderSigning * This,
            /* [size_is][out][in] */ BYTE *pbHeader,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwBytesNeeded);
        
        END_INTERFACE
    } IWMRMHeaderSigningVtbl;

    interface IWMRMHeaderSigning
    {
        CONST_VTBL struct IWMRMHeaderSigningVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMHeaderSigning_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMHeaderSigning_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMHeaderSigning_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMHeaderSigning_AddDigitalSignatureObject(This,pbHeader,dwSize,pdwBytesNeeded)	\
    (This)->lpVtbl -> AddDigitalSignatureObject(This,pbHeader,dwSize,pdwBytesNeeded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMRMHeaderSigning_AddDigitalSignatureObject_Proxy( 
    IWMRMHeaderSigning * This,
    /* [size_is][out][in] */ BYTE *pbHeader,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwBytesNeeded);


void __RPC_STUB IWMRMHeaderSigning_AddDigitalSignatureObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMHeaderSigning_INTERFACE_DEFINED__ */


#ifndef __IWMRMMetering_INTERFACE_DEFINED__
#define __IWMRMMetering_INTERFACE_DEFINED__

/* interface IWMRMMetering */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMMetering;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E84F84F-E590-44cf-B76A-B6364302DD8D")
    IWMRMMetering : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeteringCertificate( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MeteringCertificate( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerPrivateKey( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerPrivateKey( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Challenge( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Challenge( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMeteringDataAsXml( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMeteringResponse( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMeteringData( 
            /* [retval][out] */ IWMRMMeteringData **meteringData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMMeteringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMMetering * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMMetering * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMMetering * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMMetering * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMMetering * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMMetering * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMMetering * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeteringCertificate )( 
            IWMRMMetering * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MeteringCertificate )( 
            IWMRMMetering * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerPrivateKey )( 
            IWMRMMetering * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServerPrivateKey )( 
            IWMRMMetering * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Challenge )( 
            IWMRMMetering * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Challenge )( 
            IWMRMMetering * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMeteringDataAsXml )( 
            IWMRMMetering * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMeteringResponse )( 
            IWMRMMetering * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMeteringData )( 
            IWMRMMetering * This,
            /* [retval][out] */ IWMRMMeteringData **meteringData);
        
        END_INTERFACE
    } IWMRMMeteringVtbl;

    interface IWMRMMetering
    {
        CONST_VTBL struct IWMRMMeteringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMMetering_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMMetering_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMMetering_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMMetering_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMMetering_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMMetering_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMMetering_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMMetering_get_MeteringCertificate(This,pVal)	\
    (This)->lpVtbl -> get_MeteringCertificate(This,pVal)

#define IWMRMMetering_put_MeteringCertificate(This,newVal)	\
    (This)->lpVtbl -> put_MeteringCertificate(This,newVal)

#define IWMRMMetering_get_ServerPrivateKey(This,pVal)	\
    (This)->lpVtbl -> get_ServerPrivateKey(This,pVal)

#define IWMRMMetering_put_ServerPrivateKey(This,newVal)	\
    (This)->lpVtbl -> put_ServerPrivateKey(This,newVal)

#define IWMRMMetering_put_Challenge(This,newVal)	\
    (This)->lpVtbl -> put_Challenge(This,newVal)

#define IWMRMMetering_get_Challenge(This,pVal)	\
    (This)->lpVtbl -> get_Challenge(This,pVal)

#define IWMRMMetering_GetMeteringDataAsXml(This,pVal)	\
    (This)->lpVtbl -> GetMeteringDataAsXml(This,pVal)

#define IWMRMMetering_GetMeteringResponse(This,pVal)	\
    (This)->lpVtbl -> GetMeteringResponse(This,pVal)

#define IWMRMMetering_GetMeteringData(This,meteringData)	\
    (This)->lpVtbl -> GetMeteringData(This,meteringData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_get_MeteringCertificate_Proxy( 
    IWMRMMetering * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMetering_get_MeteringCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_put_MeteringCertificate_Proxy( 
    IWMRMMetering * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMMetering_put_MeteringCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_get_ServerPrivateKey_Proxy( 
    IWMRMMetering * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMetering_get_ServerPrivateKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_put_ServerPrivateKey_Proxy( 
    IWMRMMetering * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMMetering_put_ServerPrivateKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_put_Challenge_Proxy( 
    IWMRMMetering * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMMetering_put_Challenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_get_Challenge_Proxy( 
    IWMRMMetering * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMetering_get_Challenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_GetMeteringDataAsXml_Proxy( 
    IWMRMMetering * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMetering_GetMeteringDataAsXml_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_GetMeteringResponse_Proxy( 
    IWMRMMetering * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMetering_GetMeteringResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMMetering_GetMeteringData_Proxy( 
    IWMRMMetering * This,
    /* [retval][out] */ IWMRMMeteringData **meteringData);


void __RPC_STUB IWMRMMetering_GetMeteringData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMMetering_INTERFACE_DEFINED__ */


#ifndef __IWMRMMeteringData_INTERFACE_DEFINED__
#define __IWMRMMeteringData_INTERFACE_DEFINED__

/* interface IWMRMMeteringData */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMMeteringData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A726F062-C431-4b5d-92C8-52D7D709FFE7")
    IWMRMMeteringData : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeteringId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransactionId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ContentCollection( 
            /* [retval][out] */ IWMRMMeteringContentCollection **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMMeteringDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMMeteringData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMMeteringData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMMeteringData * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMMeteringData * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMMeteringData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMMeteringData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMMeteringData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeteringId )( 
            IWMRMMeteringData * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionId )( 
            IWMRMMeteringData * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentCollection )( 
            IWMRMMeteringData * This,
            /* [retval][out] */ IWMRMMeteringContentCollection **pVal);
        
        END_INTERFACE
    } IWMRMMeteringDataVtbl;

    interface IWMRMMeteringData
    {
        CONST_VTBL struct IWMRMMeteringDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMMeteringData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMMeteringData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMMeteringData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMMeteringData_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMMeteringData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMMeteringData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMMeteringData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMMeteringData_get_MeteringId(This,pVal)	\
    (This)->lpVtbl -> get_MeteringId(This,pVal)

#define IWMRMMeteringData_get_TransactionId(This,pVal)	\
    (This)->lpVtbl -> get_TransactionId(This,pVal)

#define IWMRMMeteringData_get_ContentCollection(This,pVal)	\
    (This)->lpVtbl -> get_ContentCollection(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringData_get_MeteringId_Proxy( 
    IWMRMMeteringData * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMeteringData_get_MeteringId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringData_get_TransactionId_Proxy( 
    IWMRMMeteringData * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMeteringData_get_TransactionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringData_get_ContentCollection_Proxy( 
    IWMRMMeteringData * This,
    /* [retval][out] */ IWMRMMeteringContentCollection **pVal);


void __RPC_STUB IWMRMMeteringData_get_ContentCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMMeteringData_INTERFACE_DEFINED__ */


#ifndef __IWMRMMeteringContentCollection_INTERFACE_DEFINED__
#define __IWMRMMeteringContentCollection_INTERFACE_DEFINED__

/* interface IWMRMMeteringContentCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMMeteringContentCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9DD83AC3-5C7A-4d9f-91B2-E56E334AAB7E")
    IWMRMMeteringContentCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ LONG index,
            /* [retval][out] */ IWMRMMeteringContent **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ LONG *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMMeteringContentCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMMeteringContentCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMMeteringContentCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMMeteringContentCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMMeteringContentCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMMeteringContentCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMMeteringContentCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMMeteringContentCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IWMRMMeteringContentCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ IWMRMMeteringContent **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMRMMeteringContentCollection * This,
            /* [retval][out] */ LONG *pVal);
        
        END_INTERFACE
    } IWMRMMeteringContentCollectionVtbl;

    interface IWMRMMeteringContentCollection
    {
        CONST_VTBL struct IWMRMMeteringContentCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMMeteringContentCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMMeteringContentCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMMeteringContentCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMMeteringContentCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMMeteringContentCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMMeteringContentCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMMeteringContentCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMMeteringContentCollection_get_item(This,index,pVal)	\
    (This)->lpVtbl -> get_item(This,index,pVal)

#define IWMRMMeteringContentCollection_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringContentCollection_get_item_Proxy( 
    IWMRMMeteringContentCollection * This,
    /* [in] */ LONG index,
    /* [retval][out] */ IWMRMMeteringContent **pVal);


void __RPC_STUB IWMRMMeteringContentCollection_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringContentCollection_get_length_Proxy( 
    IWMRMMeteringContentCollection * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB IWMRMMeteringContentCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMMeteringContentCollection_INTERFACE_DEFINED__ */


#ifndef __IWMRMMeteringContent_INTERFACE_DEFINED__
#define __IWMRMMeteringContent_INTERFACE_DEFINED__

/* interface IWMRMMeteringContent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMMeteringContent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83A8F002-1B03-4719-B57E-DC0391A491FF")
    IWMRMMeteringContent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Actions( 
            /* [retval][out] */ IWMRMMeteringActionCollection **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMMeteringContentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMMeteringContent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMMeteringContent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMMeteringContent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMMeteringContent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMMeteringContent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMMeteringContent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMMeteringContent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyId )( 
            IWMRMMeteringContent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Actions )( 
            IWMRMMeteringContent * This,
            /* [retval][out] */ IWMRMMeteringActionCollection **pVal);
        
        END_INTERFACE
    } IWMRMMeteringContentVtbl;

    interface IWMRMMeteringContent
    {
        CONST_VTBL struct IWMRMMeteringContentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMMeteringContent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMMeteringContent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMMeteringContent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMMeteringContent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMMeteringContent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMMeteringContent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMMeteringContent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMMeteringContent_get_KeyId(This,pVal)	\
    (This)->lpVtbl -> get_KeyId(This,pVal)

#define IWMRMMeteringContent_get_Actions(This,pVal)	\
    (This)->lpVtbl -> get_Actions(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringContent_get_KeyId_Proxy( 
    IWMRMMeteringContent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMeteringContent_get_KeyId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringContent_get_Actions_Proxy( 
    IWMRMMeteringContent * This,
    /* [retval][out] */ IWMRMMeteringActionCollection **pVal);


void __RPC_STUB IWMRMMeteringContent_get_Actions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMMeteringContent_INTERFACE_DEFINED__ */


#ifndef __IWMRMMeteringActionCollection_INTERFACE_DEFINED__
#define __IWMRMMeteringActionCollection_INTERFACE_DEFINED__

/* interface IWMRMMeteringActionCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMMeteringActionCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("371A3AC2-2549-4ff7-BCE6-314B2CD23F41")
    IWMRMMeteringActionCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ LONG index,
            /* [retval][out] */ IWMRMMeteringAction **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ LONG *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMMeteringActionCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMMeteringActionCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMMeteringActionCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMMeteringActionCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMMeteringActionCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMMeteringActionCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMMeteringActionCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMMeteringActionCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IWMRMMeteringActionCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ IWMRMMeteringAction **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMRMMeteringActionCollection * This,
            /* [retval][out] */ LONG *pVal);
        
        END_INTERFACE
    } IWMRMMeteringActionCollectionVtbl;

    interface IWMRMMeteringActionCollection
    {
        CONST_VTBL struct IWMRMMeteringActionCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMMeteringActionCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMMeteringActionCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMMeteringActionCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMMeteringActionCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMMeteringActionCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMMeteringActionCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMMeteringActionCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMMeteringActionCollection_get_item(This,index,pVal)	\
    (This)->lpVtbl -> get_item(This,index,pVal)

#define IWMRMMeteringActionCollection_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringActionCollection_get_item_Proxy( 
    IWMRMMeteringActionCollection * This,
    /* [in] */ LONG index,
    /* [retval][out] */ IWMRMMeteringAction **pVal);


void __RPC_STUB IWMRMMeteringActionCollection_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringActionCollection_get_length_Proxy( 
    IWMRMMeteringActionCollection * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB IWMRMMeteringActionCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMMeteringActionCollection_INTERFACE_DEFINED__ */


#ifndef __IWMRMMeteringAction_INTERFACE_DEFINED__
#define __IWMRMMeteringAction_INTERFACE_DEFINED__

/* interface IWMRMMeteringAction */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMMeteringAction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD5E7658-2690-4203-99D5-8DC98AA5C37E")
    IWMRMMeteringAction : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ LONG *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMMeteringActionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMMeteringAction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMMeteringAction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMMeteringAction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMMeteringAction * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMMeteringAction * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMMeteringAction * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMMeteringAction * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMRMMeteringAction * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IWMRMMeteringAction * This,
            /* [retval][out] */ LONG *pVal);
        
        END_INTERFACE
    } IWMRMMeteringActionVtbl;

    interface IWMRMMeteringAction
    {
        CONST_VTBL struct IWMRMMeteringActionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMMeteringAction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMMeteringAction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMMeteringAction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMMeteringAction_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMMeteringAction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMMeteringAction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMMeteringAction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMMeteringAction_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMRMMeteringAction_get_Value(This,pVal)	\
    (This)->lpVtbl -> get_Value(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringAction_get_Name_Proxy( 
    IWMRMMeteringAction * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMMeteringAction_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMMeteringAction_get_Value_Proxy( 
    IWMRMMeteringAction * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB IWMRMMeteringAction_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMMeteringAction_INTERFACE_DEFINED__ */


#ifndef __IWMRMRestrictions_INTERFACE_DEFINED__
#define __IWMRMRestrictions_INTERFACE_DEFINED__

/* interface IWMRMRestrictions */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMRestrictions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65036A26-70C2-428C-9A53-C8EAC6A420C3")
    IWMRMRestrictions : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddRestriction( 
            /* [in] */ WMRM_RESTRICTION_TYPE val,
            /* [in] */ DWORD level) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddExtension( 
            /* [in] */ BSTR guid,
            /* [in] */ BYTE byteVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddSchemeToReserved( 
            /* [in] */ BSTR guid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRestrictions( 
            /* [retval][out] */ BSTR *prestrictions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMRestrictionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMRestrictions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMRestrictions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMRestrictions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMRestrictions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMRestrictions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMRestrictions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMRestrictions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddRestriction )( 
            IWMRMRestrictions * This,
            /* [in] */ WMRM_RESTRICTION_TYPE val,
            /* [in] */ DWORD level);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddExtension )( 
            IWMRMRestrictions * This,
            /* [in] */ BSTR guid,
            /* [in] */ BYTE byteVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddSchemeToReserved )( 
            IWMRMRestrictions * This,
            /* [in] */ BSTR guid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRestrictions )( 
            IWMRMRestrictions * This,
            /* [retval][out] */ BSTR *prestrictions);
        
        END_INTERFACE
    } IWMRMRestrictionsVtbl;

    interface IWMRMRestrictions
    {
        CONST_VTBL struct IWMRMRestrictionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMRestrictions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMRestrictions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMRestrictions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMRestrictions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMRestrictions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMRestrictions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMRestrictions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMRestrictions_AddRestriction(This,val,level)	\
    (This)->lpVtbl -> AddRestriction(This,val,level)

#define IWMRMRestrictions_AddExtension(This,guid,byteVal)	\
    (This)->lpVtbl -> AddExtension(This,guid,byteVal)

#define IWMRMRestrictions_AddSchemeToReserved(This,guid)	\
    (This)->lpVtbl -> AddSchemeToReserved(This,guid)

#define IWMRMRestrictions_GetRestrictions(This,prestrictions)	\
    (This)->lpVtbl -> GetRestrictions(This,prestrictions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRestrictions_AddRestriction_Proxy( 
    IWMRMRestrictions * This,
    /* [in] */ WMRM_RESTRICTION_TYPE val,
    /* [in] */ DWORD level);


void __RPC_STUB IWMRMRestrictions_AddRestriction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRestrictions_AddExtension_Proxy( 
    IWMRMRestrictions * This,
    /* [in] */ BSTR guid,
    /* [in] */ BYTE byteVal);


void __RPC_STUB IWMRMRestrictions_AddExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRestrictions_AddSchemeToReserved_Proxy( 
    IWMRMRestrictions * This,
    /* [in] */ BSTR guid);


void __RPC_STUB IWMRMRestrictions_AddSchemeToReserved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRestrictions_GetRestrictions_Proxy( 
    IWMRMRestrictions * This,
    /* [retval][out] */ BSTR *prestrictions);


void __RPC_STUB IWMRMRestrictions_GetRestrictions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMRestrictions_INTERFACE_DEFINED__ */


#ifndef __IWMRMRestrictions2_INTERFACE_DEFINED__
#define __IWMRMRestrictions2_INTERFACE_DEFINED__

/* interface IWMRMRestrictions2 */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMRestrictions2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DAEAD681-BE15-4be7-B062-F08383A55097")
    IWMRMRestrictions2 : public IWMRMRestrictions
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddInclusion( 
            /* [in] */ BSTR guid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInclusionList( 
            /* [retval][out] */ BSTR *pXml) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMRestrictions2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMRestrictions2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMRestrictions2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMRestrictions2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMRestrictions2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMRestrictions2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMRestrictions2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMRestrictions2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddRestriction )( 
            IWMRMRestrictions2 * This,
            /* [in] */ WMRM_RESTRICTION_TYPE val,
            /* [in] */ DWORD level);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddExtension )( 
            IWMRMRestrictions2 * This,
            /* [in] */ BSTR guid,
            /* [in] */ BYTE byteVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddSchemeToReserved )( 
            IWMRMRestrictions2 * This,
            /* [in] */ BSTR guid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRestrictions )( 
            IWMRMRestrictions2 * This,
            /* [retval][out] */ BSTR *prestrictions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddInclusion )( 
            IWMRMRestrictions2 * This,
            /* [in] */ BSTR guid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInclusionList )( 
            IWMRMRestrictions2 * This,
            /* [retval][out] */ BSTR *pXml);
        
        END_INTERFACE
    } IWMRMRestrictions2Vtbl;

    interface IWMRMRestrictions2
    {
        CONST_VTBL struct IWMRMRestrictions2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMRestrictions2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMRestrictions2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMRestrictions2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMRestrictions2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMRestrictions2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMRestrictions2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMRestrictions2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMRestrictions2_AddRestriction(This,val,level)	\
    (This)->lpVtbl -> AddRestriction(This,val,level)

#define IWMRMRestrictions2_AddExtension(This,guid,byteVal)	\
    (This)->lpVtbl -> AddExtension(This,guid,byteVal)

#define IWMRMRestrictions2_AddSchemeToReserved(This,guid)	\
    (This)->lpVtbl -> AddSchemeToReserved(This,guid)

#define IWMRMRestrictions2_GetRestrictions(This,prestrictions)	\
    (This)->lpVtbl -> GetRestrictions(This,prestrictions)


#define IWMRMRestrictions2_AddInclusion(This,guid)	\
    (This)->lpVtbl -> AddInclusion(This,guid)

#define IWMRMRestrictions2_GetInclusionList(This,pXml)	\
    (This)->lpVtbl -> GetInclusionList(This,pXml)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRestrictions2_AddInclusion_Proxy( 
    IWMRMRestrictions2 * This,
    /* [in] */ BSTR guid);


void __RPC_STUB IWMRMRestrictions2_AddInclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMRestrictions2_GetInclusionList_Proxy( 
    IWMRMRestrictions2 * This,
    /* [retval][out] */ BSTR *pXml);


void __RPC_STUB IWMRMRestrictions2_GetInclusionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMRestrictions2_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicenseRevocationAcknowledger_INTERFACE_DEFINED__
#define __IWMRMLicenseRevocationAcknowledger_INTERFACE_DEFINED__

/* interface IWMRMLicenseRevocationAcknowledger */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicenseRevocationAcknowledger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6607B5EE-0081-46E2-88B2-4470983AA791")
    IWMRMLicenseRevocationAcknowledger : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Verify( 
            /* [in] */ BSTR machinePubkey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTransactionId( 
            /* [retval][out] */ BSTR *transactionId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Acknowledgement( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Acknowledgement( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicenseRevocationAcknowledgerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicenseRevocationAcknowledger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicenseRevocationAcknowledger * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Verify )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [in] */ BSTR machinePubkey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTransactionId )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [retval][out] */ BSTR *transactionId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Acknowledgement )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Acknowledgement )( 
            IWMRMLicenseRevocationAcknowledger * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IWMRMLicenseRevocationAcknowledgerVtbl;

    interface IWMRMLicenseRevocationAcknowledger
    {
        CONST_VTBL struct IWMRMLicenseRevocationAcknowledgerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicenseRevocationAcknowledger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicenseRevocationAcknowledger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicenseRevocationAcknowledger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicenseRevocationAcknowledger_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicenseRevocationAcknowledger_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicenseRevocationAcknowledger_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicenseRevocationAcknowledger_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicenseRevocationAcknowledger_Verify(This,machinePubkey)	\
    (This)->lpVtbl -> Verify(This,machinePubkey)

#define IWMRMLicenseRevocationAcknowledger_GetTransactionId(This,transactionId)	\
    (This)->lpVtbl -> GetTransactionId(This,transactionId)

#define IWMRMLicenseRevocationAcknowledger_get_Acknowledgement(This,pVal)	\
    (This)->lpVtbl -> get_Acknowledgement(This,pVal)

#define IWMRMLicenseRevocationAcknowledger_put_Acknowledgement(This,newVal)	\
    (This)->lpVtbl -> put_Acknowledgement(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationAcknowledger_Verify_Proxy( 
    IWMRMLicenseRevocationAcknowledger * This,
    /* [in] */ BSTR machinePubkey);


void __RPC_STUB IWMRMLicenseRevocationAcknowledger_Verify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationAcknowledger_GetTransactionId_Proxy( 
    IWMRMLicenseRevocationAcknowledger * This,
    /* [retval][out] */ BSTR *transactionId);


void __RPC_STUB IWMRMLicenseRevocationAcknowledger_GetTransactionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationAcknowledger_get_Acknowledgement_Proxy( 
    IWMRMLicenseRevocationAcknowledger * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicenseRevocationAcknowledger_get_Acknowledgement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationAcknowledger_put_Acknowledgement_Proxy( 
    IWMRMLicenseRevocationAcknowledger * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicenseRevocationAcknowledger_put_Acknowledgement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicenseRevocationAcknowledger_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicenseRevocationChallenge_INTERFACE_DEFINED__
#define __IWMRMLicenseRevocationChallenge_INTERFACE_DEFINED__

/* interface IWMRMLicenseRevocationChallenge */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicenseRevocationChallenge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11929226-B8D9-4855-8E24-7F2AFC0B7D96")
    IWMRMLicenseRevocationChallenge : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR lrbChallenge) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTransactionId( 
            /* [retval][out] */ BSTR *pbstrTid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMachineId( 
            /* [retval][out] */ BSTR *pbstrMid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMachinePublicKey( 
            /* [retval][out] */ BSTR *pbstrMPubKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCustomData( 
            /* [retval][out] */ BSTR *pbstrCustomData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicenseRevocationChallengeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicenseRevocationChallenge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicenseRevocationChallenge * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [in] */ BSTR lrbChallenge);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTransactionId )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [retval][out] */ BSTR *pbstrTid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMachineId )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [retval][out] */ BSTR *pbstrMid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMachinePublicKey )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [retval][out] */ BSTR *pbstrMPubKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCustomData )( 
            IWMRMLicenseRevocationChallenge * This,
            /* [retval][out] */ BSTR *pbstrCustomData);
        
        END_INTERFACE
    } IWMRMLicenseRevocationChallengeVtbl;

    interface IWMRMLicenseRevocationChallenge
    {
        CONST_VTBL struct IWMRMLicenseRevocationChallengeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicenseRevocationChallenge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicenseRevocationChallenge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicenseRevocationChallenge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicenseRevocationChallenge_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicenseRevocationChallenge_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicenseRevocationChallenge_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicenseRevocationChallenge_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicenseRevocationChallenge_Initialize(This,lrbChallenge)	\
    (This)->lpVtbl -> Initialize(This,lrbChallenge)

#define IWMRMLicenseRevocationChallenge_GetTransactionId(This,pbstrTid)	\
    (This)->lpVtbl -> GetTransactionId(This,pbstrTid)

#define IWMRMLicenseRevocationChallenge_GetMachineId(This,pbstrMid)	\
    (This)->lpVtbl -> GetMachineId(This,pbstrMid)

#define IWMRMLicenseRevocationChallenge_GetMachinePublicKey(This,pbstrMPubKey)	\
    (This)->lpVtbl -> GetMachinePublicKey(This,pbstrMPubKey)

#define IWMRMLicenseRevocationChallenge_GetCustomData(This,pbstrCustomData)	\
    (This)->lpVtbl -> GetCustomData(This,pbstrCustomData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationChallenge_Initialize_Proxy( 
    IWMRMLicenseRevocationChallenge * This,
    /* [in] */ BSTR lrbChallenge);


void __RPC_STUB IWMRMLicenseRevocationChallenge_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationChallenge_GetTransactionId_Proxy( 
    IWMRMLicenseRevocationChallenge * This,
    /* [retval][out] */ BSTR *pbstrTid);


void __RPC_STUB IWMRMLicenseRevocationChallenge_GetTransactionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationChallenge_GetMachineId_Proxy( 
    IWMRMLicenseRevocationChallenge * This,
    /* [retval][out] */ BSTR *pbstrMid);


void __RPC_STUB IWMRMLicenseRevocationChallenge_GetMachineId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationChallenge_GetMachinePublicKey_Proxy( 
    IWMRMLicenseRevocationChallenge * This,
    /* [retval][out] */ BSTR *pbstrMPubKey);


void __RPC_STUB IWMRMLicenseRevocationChallenge_GetMachinePublicKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationChallenge_GetCustomData_Proxy( 
    IWMRMLicenseRevocationChallenge * This,
    /* [retval][out] */ BSTR *pbstrCustomData);


void __RPC_STUB IWMRMLicenseRevocationChallenge_GetCustomData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicenseRevocationChallenge_INTERFACE_DEFINED__ */


#ifndef __IWMRMLicenseRevocationResponse_INTERFACE_DEFINED__
#define __IWMRMLicenseRevocationResponse_INTERFACE_DEFINED__

/* interface IWMRMLicenseRevocationResponse */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMRMLicenseRevocationResponse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D410E2DB-80E4-43CC-8014-EF99755E1728")
    IWMRMLicenseRevocationResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_KeyId( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CustomData( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CustomData( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RevocationPublicKey( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RevocationPublicKey( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransactionId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TransactionId( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSignedResponse( 
            /* [in] */ BSTR bstrLGPrivateKey,
            /* [in] */ BSTR bstrMachinePublicKey,
            /* [retval][out] */ BSTR *pbstrResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRMLicenseRevocationResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRMLicenseRevocationResponse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRMLicenseRevocationResponse * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMRMLicenseRevocationResponse * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyId )( 
            IWMRMLicenseRevocationResponse * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyId )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CustomData )( 
            IWMRMLicenseRevocationResponse * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CustomData )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RevocationPublicKey )( 
            IWMRMLicenseRevocationResponse * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RevocationPublicKey )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionId )( 
            IWMRMLicenseRevocationResponse * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TransactionId )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSignedResponse )( 
            IWMRMLicenseRevocationResponse * This,
            /* [in] */ BSTR bstrLGPrivateKey,
            /* [in] */ BSTR bstrMachinePublicKey,
            /* [retval][out] */ BSTR *pbstrResponse);
        
        END_INTERFACE
    } IWMRMLicenseRevocationResponseVtbl;

    interface IWMRMLicenseRevocationResponse
    {
        CONST_VTBL struct IWMRMLicenseRevocationResponseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRMLicenseRevocationResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRMLicenseRevocationResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRMLicenseRevocationResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRMLicenseRevocationResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMRMLicenseRevocationResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMRMLicenseRevocationResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMRMLicenseRevocationResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMRMLicenseRevocationResponse_get_KeyId(This,pVal)	\
    (This)->lpVtbl -> get_KeyId(This,pVal)

#define IWMRMLicenseRevocationResponse_put_KeyId(This,newVal)	\
    (This)->lpVtbl -> put_KeyId(This,newVal)

#define IWMRMLicenseRevocationResponse_get_CustomData(This,pVal)	\
    (This)->lpVtbl -> get_CustomData(This,pVal)

#define IWMRMLicenseRevocationResponse_put_CustomData(This,newVal)	\
    (This)->lpVtbl -> put_CustomData(This,newVal)

#define IWMRMLicenseRevocationResponse_get_RevocationPublicKey(This,pVal)	\
    (This)->lpVtbl -> get_RevocationPublicKey(This,pVal)

#define IWMRMLicenseRevocationResponse_put_RevocationPublicKey(This,newVal)	\
    (This)->lpVtbl -> put_RevocationPublicKey(This,newVal)

#define IWMRMLicenseRevocationResponse_get_TransactionId(This,pVal)	\
    (This)->lpVtbl -> get_TransactionId(This,pVal)

#define IWMRMLicenseRevocationResponse_put_TransactionId(This,newVal)	\
    (This)->lpVtbl -> put_TransactionId(This,newVal)

#define IWMRMLicenseRevocationResponse_GenerateSignedResponse(This,bstrLGPrivateKey,bstrMachinePublicKey,pbstrResponse)	\
    (This)->lpVtbl -> GenerateSignedResponse(This,bstrLGPrivateKey,bstrMachinePublicKey,pbstrResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_get_KeyId_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicenseRevocationResponse_get_KeyId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_put_KeyId_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicenseRevocationResponse_put_KeyId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_get_CustomData_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicenseRevocationResponse_get_CustomData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_put_CustomData_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicenseRevocationResponse_put_CustomData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_get_RevocationPublicKey_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicenseRevocationResponse_get_RevocationPublicKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_put_RevocationPublicKey_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicenseRevocationResponse_put_RevocationPublicKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_get_TransactionId_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMRMLicenseRevocationResponse_get_TransactionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_put_TransactionId_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMRMLicenseRevocationResponse_put_TransactionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMRMLicenseRevocationResponse_GenerateSignedResponse_Proxy( 
    IWMRMLicenseRevocationResponse * This,
    /* [in] */ BSTR bstrLGPrivateKey,
    /* [in] */ BSTR bstrMachinePublicKey,
    /* [retval][out] */ BSTR *pbstrResponse);


void __RPC_STUB IWMRMLicenseRevocationResponse_GenerateSignedResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRMLicenseRevocationResponse_INTERFACE_DEFINED__ */



#ifndef __WMRMOBJSLib_LIBRARY_DEFINED__
#define __WMRMOBJSLib_LIBRARY_DEFINED__

/* library WMRMOBJSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WMRMOBJSLib;

EXTERN_C const CLSID CLSID_WMRMProtect;

#ifdef __cplusplus

class DECLSPEC_UUID("42152A9D-AFFE-48B8-9C61-C1C5DDB64FF7")
WMRMProtect;
#endif

EXTERN_C const CLSID CLSID_WMRMHeader;

#ifdef __cplusplus

class DECLSPEC_UUID("457B9521-268E-44D6-A1D7-189C47EA7D5A")
WMRMHeader;
#endif

EXTERN_C const CLSID CLSID_WMRMCoding;

#ifdef __cplusplus

class DECLSPEC_UUID("3B19D980-A64C-4245-AC20-9E087CDE2DA3")
WMRMCoding;
#endif

EXTERN_C const CLSID CLSID_WMRMKeys;

#ifdef __cplusplus

class DECLSPEC_UUID("3AFB20E3-6FA9-44C7-9F93-0BA1F35B7501")
WMRMKeys;
#endif

EXTERN_C const CLSID CLSID_WMRMChallenge;

#ifdef __cplusplus

class DECLSPEC_UUID("76FB40C2-7B90-402A-867D-73747BF85F48")
WMRMChallenge;
#endif

EXTERN_C const CLSID CLSID_WMRMLicGen;

#ifdef __cplusplus

class DECLSPEC_UUID("FD12AEC6-1A3D-4294-8019-B6B771467428")
WMRMLicGen;
#endif

EXTERN_C const CLSID CLSID_WMRMRights;

#ifdef __cplusplus

class DECLSPEC_UUID("54789987-B968-4E76-9E40-D5F5EFC01714")
WMRMRights;
#endif

EXTERN_C const CLSID CLSID_WMRMResponse;

#ifdef __cplusplus

class DECLSPEC_UUID("11582EB3-3A56-4e50-B786-9B121E9C20D9")
WMRMResponse;
#endif

EXTERN_C const CLSID CLSID_WMRMTools;

#ifdef __cplusplus

class DECLSPEC_UUID("B984156F-0759-4959-9FD4-A865E9D6C28B")
WMRMTools;
#endif

EXTERN_C const CLSID CLSID_WMRMMetering;

#ifdef __cplusplus

class DECLSPEC_UUID("39C0D5BB-5E00-48e1-A4FF-7FD6EBC98123")
WMRMMetering;
#endif

EXTERN_C const CLSID CLSID_WMRMRestrictions;

#ifdef __cplusplus

class DECLSPEC_UUID("AC42A8E0-D613-4681-8AF7-365C120A7176")
WMRMRestrictions;
#endif

EXTERN_C const CLSID CLSID_WMRMLicenseRevocationAcknowledger;

#ifdef __cplusplus

class DECLSPEC_UUID("D83699D3-B617-42A5-B78C-17E61B1B642C")
WMRMLicenseRevocationAcknowledger;
#endif

EXTERN_C const CLSID CLSID_WMRMLicenseRevocationChallenge;

#ifdef __cplusplus

class DECLSPEC_UUID("6F9DE141-2480-4B43-829F-A1F8E55B1EF4")
WMRMLicenseRevocationChallenge;
#endif

EXTERN_C const CLSID CLSID_WMRMLicenseRevocationResponse;

#ifdef __cplusplus

class DECLSPEC_UUID("F563FD76-816A-4BA0-8D43-A153F7315EFC")
WMRMLicenseRevocationResponse;
#endif
#endif /* __WMRMOBJSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\blendedheap.hpp ===
#ifndef _BLENDED_HEAP_HPP_
#define _BLENDED_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A blended heap.                                                */
    /*                                                                  */
    /*   A blended heap tries to provide good performance and           */
    /*   thoughtfull memory layout for a modest cost in terms of        */
    /*   additional memory usage.                                       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE BLENDED_HEAP : public ROCKALL_FRONT_END
    {
   public:
        //
        //   Public functions.
        //
        BLENDED_HEAP
			( 
			int						  MaxFreeSpace = HalfMegabyte,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~BLENDED_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BLENDED_HEAP( const BLENDED_HEAP & Copy );

        void operator=( const BLENDED_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\debugheap.hpp ===
#ifndef _DEBUG_HEAP_HPP_
#define _DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallDebugFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specify the initial size of various tables.      */
    /*                                                                  */
    /********************************************************************/

const int MaxLeadingGuardWords		  = (MaxFunctions + 1);

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CALL_STACK;

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE DEBUG_HEAP : public ROCKALL_DEBUG_FRONT_END
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Count;
			int						  Size;
			void					  *Functions[ MaxLeadingGuardWords ];
			}
		HEADER;

		typedef struct
			{
			char					  GuardBytes[ GuardSize ];
			void					  *GuardWords[1];
			}
		TRAILER;

		typedef struct
			{
			HEADER					  DebugHeader;
			TRAILER					  DebugTrailer;
			}
		HEADER_AND_TRAILER;

		//
		//   Private data.
		//
		CALL_STACK					  *CallStack;
		bool						  ExitOnError;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        DEBUG_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true,
			//
			//   Additional debug flags.
			//
			bool					  FunctionTrace = false,
			bool					  TrapOnUserError = true
			);

		virtual void HeapLeaks( void );

        virtual ~DEBUG_HEAP( void );

	protected:
		//
		//   Guard word functions.
		//
		//   The guard word functions create, maintain,
		//   verify and delete guard words around
		//   debug memory allocations.
		//
		virtual void DeleteGuard( void *Address );

		virtual bool NewGuard( void **Address,int Size,int *Space );

		virtual bool VerifyGuard( void *Address,int *Size,int *Space );

		virtual bool WalkGuard( bool *Active,void **Address,int *Space );

		virtual void UserError( void *Address,void *Details,char *Message );

	private:
		//
		//   Private functions.
		//
		//   Support functions to compute various
		//   offsets and sizes within the page heap.
		//   
		void *ComputeHeapAddress( void *Address );

		void *ComputeUserAddress( void *Address );
			 
		int ComputeUserSpace( int Space );

		//
		//   Private functions.
		//
		//   Support functions to implement the guard
		//   words for the debug heap.
		//   
		bool VerifyAddress
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			bool					  Verify
			);

		bool VerifyGuardWords
			( 
			void					  *Address,
			int						  Size 
			);

		bool VerifyHeader
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			bool					  Verify
			);

		bool VerifyHeaderAndTrailer
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			TRAILER					  **Trailer,
			bool					  Verify
			);

		bool VerifyTrailer
			( 
			HEADER					  *Header,
			int						  Space,
			TRAILER					  **Trailer
			);

		void WriteGuardWords
			( 
			void					  *Address,
			int						  Size 
			);

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DEBUG_HEAP( const DEBUG_HEAP & Copy );

        void operator=( const DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\defaultheap.hpp ===
#ifndef _DEFAULT_HEAP_HPP_
#define _DEFAULT_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#ifdef _DEBUG
#include "DebugHeap.hpp"
typedef DEBUG_HEAP DEFAULT_HEAP;
#else
#include "FastHeap.hpp"
typedef FAST_HEAP DEFAULT_HEAP;
#endif
#ifndef NO_DEFAULT_HEAP

    /********************************************************************/
    /*                                                                  */
    /*   Default heap.                                                  */
    /*                                                                  */
    /*   The default heap is available for everyone as soon as the      */
    /*   memory allocator DLL has loaded.                               */
    /*                                                                  */
    /********************************************************************/

extern ROCKALL_DLL_LINKAGE DEFAULT_HEAP DefaultHeap;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\fastheap.hpp ===
#ifndef _FAST_HEAP_HPP_
#define _FAST_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A fast heap.                                                   */
    /*                                                                  */
    /*   A fast heap tries to provide very good performance even        */
    /*   if that comes at a significant cost in terms of additional     */
    /*   memory usage.                                                  */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE FAST_HEAP : public ROCKALL_FRONT_END
    {
   public:
        //
        //   Public functions.
        //
        FAST_HEAP
			( 
			int						  MaxFreeSpace = (2 * HalfMegabyte),
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~FAST_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FAST_HEAP( const FAST_HEAP & Copy );

        void operator=( const FAST_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\DynamicDebugHeap.hpp ===
#ifndef _DYNAMIC_DEBUG_HEAP_HPP_
#define _DYNAMIC_DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "DebugHeap.hpp"
#include "FastHeap.hpp"
#include "PageHeap.hpp"
#include "SmallHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class LIST;

struct DYNAMIC_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   A dynamic debug heap.                                          */
    /*                                                                  */
    /*   A dynamic debug heap switches all allocations between a        */
    /*   standard 'FAST_HEAP', a 'DEBUG_HEAP' and a 'PAGE_HEAP' in      */
    /*   proportion to the supplied ratios.  The dynamic spread means   */
    /*   that the heap is typically quite fast but occasional random    */
    /*   allocations are heavily checked by the debugging features.     */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE DYNAMIC_DEBUG_HEAP : public SMALL_HEAP
    {
		//
		//   Private data.
		//
		bool						  Active;

		LIST						  *AllHeaps;
		DYNAMIC_HEAP				  *Array;
		DYNAMIC_HEAP				  *HeapWalk;

		DEBUG_HEAP					  DebugHeap;
		FAST_HEAP					  FastHeap;
		PAGE_HEAP					  PageHeap;

		int							  PercentDebug;
		int							  PercentPage;

   public:
        //
        //   Public functions.
        //
        DYNAMIC_DEBUG_HEAP
			( 
			int						  MaxFreeSpace = (2 * HalfMegabyte),
			bool					  Recycle = false,
			bool					  SingleImage = true,
			bool					  ThreadSafe = true,
			//
			//   Additional debug flags.
			//
			bool					  FunctionTrace = false,
			int						  PercentToDebug = 20,
			int						  PercentToPage = 5,
			bool					  TrapOnUserError = true
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual void HeapLeaks( void );

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

        ~DYNAMIC_DEBUG_HEAP( void );

	protected:
		//
		//   Protected inline functions.
		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		virtual void *SpecialNew( int Size );

   private:
	    //
	    //   Private functions.
	    //
	    int RandomNumber( void );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DYNAMIC_DEBUG_HEAP( const DYNAMIC_DEBUG_HEAP & Copy );

        void operator=( const DYNAMIC_DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\icecap.h ===
//-----------------------------------------------------------------------------
//
//  File: Icecap.h
//  Copyright (C) 1997-1998 Microsoft Corporation
//  All rights reserved.
//
//  This header file is part of IceCAP {{rmj}}.{{rmm}}.{{rup}}.  It is
//  MICROSOFT CONFIDENTIAL, and should not be distributed except under NDA.
//
//-----------------------------------------------------------------------------

// ICECAP.H
// interface to the Datalocality APIs

#ifndef __ICECAP_H__
#define __ICECAP_H__

#ifndef DONTUSEICECAPLIB
#pragma comment(lib, "IceCAP.lib")
#endif	// USEICECAPLIB

#ifdef __cplusplus
extern "C" {
#endif

// Defines for Levels and Id's
#define PROFILE_GLOBALLEVEL 1
#define PROFILE_PROCESSLEVEL 2
#define PROFILE_THREADLEVEL 3
#define PROFILE_FIBERLEVEL 4
#define PROFILE_CURRENTID ((unsigned long)0xFFFFFFFF)

// Start/Stop Api's
int _declspec(dllimport) _stdcall StopProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall StartProfile(int nLevel, unsigned long dwId);

// Suspend/Resume Api's
int _declspec(dllimport) _stdcall SuspendProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall ResumeProfile(int nLevel, unsigned long dwId);

// Mark Api's
int _declspec(dllimport) _stdcall MarkProfile(long lMarker);
int _declspec(dllimport) _stdcall CommentMarkProfile(long lMarker, const char *szComment);
int _declspec(dllimport) _stdcall CommentMarkAtProfile(__int64 dnTimestamp, long lMarker, const char *szComment);
int _declspec(dllimport) _stdcall DlpMarkProfile(long lMarker0, long lMarker1);

// Named Profiling Elements Api's
int _declspec(dllimport) _stdcall NameProfile(const char *pszName, int nLevel, unsigned long dwId);

// Security Api's
// NOTE: please contact ICAPSUP before using this function
int _declspec(dllimport) _stdcall ClearProcessSecurityAcl(int fImpersonatingUser);

// xxxProfile return codes
#define PROFILE_OK 0						// xxxProfile call successful
#define PROFILE_ERROR_NOT_YET_IMPLEMENTED 1 // api or level,id combination not supported yet
#define PROFILE_ERROR_MODE_NEVER 2		// mode was never when called
#define PROFILE_ERROR_LEVEL_NOEXIST 3	// level doesn't exist
#define PROFILE_ERROR_ID_NOEXIST 4		// id doesn't exist
#define PROFILE_ERROR_NO_WMI_UPDATE 5	// failed to update the WMI (pagefault collection) state

// MarkProfile return codes
#define MARK_OK					0	// Mark was taken successfully
#define MARK_ERROR_MODE_NEVER	1	// Profiling was never when MarkProfile called
#define MARK_ERROR_MODE_OFF		2	// Profiling was off when MarkProfile called
#define MARK_ERROR_MARKER_RESERVED	3	// Mark value passed is a reserved value
#define MARK_TEXTTOOLONG		4	// Comment text was truncated
#define MARK_ERROR_OUTOFMEMORY	6	// no memory was available in which to record the event

// NameProfile return codes
#define NAME_OK						0	// Name was registered sucessfullly
#define NAME_ERROR_TEXTTRUNCATED	1	// The name text was too long and was therefore truncated
#define NAME_ERROR_REDEFINITION		2	// The given profile element has already been named
#define NAME_ERROR_LEVEL_NOEXIST	3	// level doesn't exist
#define NAME_ERROR_ID_NOEXIST 		4	// id doesn't exist
#define NAME_ERROR_INVALID_NAME		5	// name does not meet the specification's requirements
#define NAME_ERROR_OUTOFMEMORY		6	// no memory was available in which to record the event
#define NAME_ERROR_NO_SUPPORT		7	// the given operation is not supported

// Icecap 3.x Compatibility defines
#define StartCAP() StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define StopCAP() StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define SuspendCAP() SuspendProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define ResumeCAP() ResumeProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)

#define StartCAPAll() StartProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define StopCAPAll() StopProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define SuspendCAPAll() SuspendProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define ResumeCAPAll() ResumeProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)

#define MarkCAP(mark) MarkProfile(mark)

#define AllowCAP() 

// DataLocality 1.x Compatibility defines
#define StartDLP() StartCAP()
#define StopDLP() StopCAP()
#define MarkDLP(mark) MarkCAP(mark)

//
// USER DEFINED COUNTER HELPERS AND TYPES
//

// COUNTER_FUNCTION_PROLOGE and EPILOGE
//
// These functions are supplied to protect the state of registers
// that the IceCAP collection probes rely on.  We did everything we
// could to eliminate instructions during collection.  Your mission,
// if you choose to accept it, is the same.
//
#define COUNTER_FUNCTION_PROLOGE	_asm push ecx _asm push ebx _asm push ebp
#define COUNTER_FUNCTION_EPILOGE	_asm pop ebp _asm pop ebx _asm pop ecx _asm ret

#ifndef USER_COUNTER_INFO_DEFINED
#define USER_COUNTER_INFO_DEFINED

// CONSTS AND ENUMS
//

// UserCounterType
//
// These enumerations describe how the counter works.
//
// MonotonicallyIncreasing	--	This describes a counter that will increment
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks the
//								number of memory allocations.  Each allocation
//								increments the number by one.
//
// MonotonicallyDecreasint	--	This describes a counter that will decrement
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks a limited
//								resource.  Each use of the resource decrements
//								the number by one.
//
// RandomIncreasing --			This describes a counter that will increase for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be the total memory
//								allocated.  Each allocation would add it's size
//								to the counter, but each allocation being potentially
//								different, causes the counter to go up by a random
//								amount each time.
//
// RandomDecreasing --			This describes a coutner that will decrease for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be a limited resource
//								that can be used in bunches.  Each use fo the
//								the resource would cause the number to descrease
//								by a random amount.
//
// Random --					This number can either go up, or go down.  An
//								example would be the total amount of available
//								memory, which can either go up (as memory is
//								free'd), or go down (as memory is allocated).
//
enum UserCounterType
{
	MonotonicallyIncreasing,
	MonotonicallyDecreasing,
	RandomIncreasing,
	RandomDecreasing,
	Random
};

// TYPEDEFS
//

typedef signed __int64	COUNTER, *PCOUNTER;

///////////////////////////////////////////////////////////////
// USERCOUNTERINFO
//
// This structure descibes a user defined counter so that
// IceCAP can use it during profiling runs.
//
// History:  9-21-98 BarryNo Created
//
///////////////////////////////////////////////////////////////
typedef struct _USERCOUNTERINFO
{
	unsigned long dwSize;			// Size of this structure (for version control)
	char  szCounterFuncName[32];	// Name of the function
	enum UserCounterType	ct;		// Describes the type of number we will be collecting
	char szName[32];				// Name of user counter
	int bSynchronized;				// Is this counter synchronized

} USERCOUNTERINFO, *PUSERCOUNTERINFO;

#endif  // USER_COUNTER_INFO_DEFINED

#ifdef __cplusplus
}
#endif

#endif // __ICECAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\posixheap.hpp ===
#ifndef _POSIX_HEAP_HPP_
#define _POSIX_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "DefaultHeap.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   The standard posix interface.                                  */
    /*                                                                  */
    /*   The Posix interface allows Rockall to be linked into Unix      */
    /*   applications with a minimal amount of fuss.  Although the      */
    /*   function names are not identical to the posix names (so as     */
    /*   to avoid name clashes) functionally they are close enough      */
    /*    to be simple replacements.                                    */
    /*                                                                  */
    /********************************************************************/

inline void *Calloc( int Size )
	{ return DefaultHeap.New( Size,NULL,true ); }

inline bool Free( void *Address,int Size = NoSize )
	{ return DefaultHeap.Delete( Address,Size ); }

inline void *Malloc( int Size )
	{ return DefaultHeap.New( Size ); }

inline void *Realloc( void *Address,int NewSize )
	{ return DefaultHeap.Resize( Address,NewSize ); }
#ifdef POSIX_EXTENSIONS

    /********************************************************************/
    /*                                                                  */
    /*   Extensions to the posix interface.                             */
    /*                                                                  */
    /*   The Posix interface is fairly restricted and only gives        */
    /*   access to a small portion of Rockall.  The functions that      */
    /*   follow expose additional Rockall functionality.                */
    /*                                                                  */
    /********************************************************************/

inline void DeleteAll( bool Recycle = true )
	{ DefaultHeap.DeleteAll( Recycle ); }

inline bool MultipleFree
		( 
		int				Actual,
		void			*Array[],
		int				Size = NoSize
		)
	{ return DefaultHeap.MultipleDelete( Actual,Array,Size ); }

inline bool MultipleMalloc
		( 
		int				*Actual,
		void			*Array[],
		int				Requested,
		int				Size
		)
	{ return DefaultHeap.MultipleNew( Actual,Array,Requested,Size ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\rockall.hpp ===
#ifndef _ROCKALL_HPP_
#define _ROCKALL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation constants.                                   */
    /*                                                                  */
    /*   The memory allocation constants are denote special situations  */
    /*   where optimizations are possible or failures have cccured.     */
    /*                                                                  */
    /********************************************************************/

const int AllocationFailure			  = 0;
const int GuardValue				  = 0xDeadBeef;
const int NoSize					  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class FIND;
class HEAP;
class NEW_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation interface.                               */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL
    {
    public:
		//
		//   Public types.
		//
		//   A heap is constructed of a collection of 
		//   fixed sized buckets each with an associated
		//   cache.  The details of these buckets are
		//   supplied to the heap using the following
		//   structure.
		//
		typedef struct
			{
			int						  AllocationSize;
			int						  CacheSize;
			int						  ChunkSize;
			int						  PageSize;
			}
		CACHE_DETAILS;

		//
		//   Public data.
		//
		//   The internals linkages in a heap are built
		//   dynamically during the execution of a heaps
		//   constructor.  The member that follow relate
		//   to key internal classes.
		//
		CACHE						  **Array;
		CACHE						  *Caches;
		FIND						  *Find;
		HEAP						  *Heap;
		NEW_PAGE					  *NewPage;

		//
		//   A heap constructor is required to preserve 
		//   a small amount of information for the heap
		//   destructor.
		//
		bool						  GlobalDelete;
		int							  GuardWord;
		int							  NumberOfCaches;
		int							  TotalSize;

        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
		ROCKALL( void );

        ROCKALL
			(
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  FindCacheSize,
			int						  FindCacheThreshold,
			int						  FindSize,
			int						  MaxFreeSpace,
			int						  *NewPageSizes,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafe 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void DeleteArea( void *Memory,int Size,bool User );

		virtual int NaturalSize( void );

		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~ROCKALL( void );

		//
		//   Public inline functions.
		//
		inline bool Available( void )
			{ return (GuardWord == GuardValue); }

		inline bool Corrupt( void )
			{ return (GuardWord != GuardValue); }

	protected:
		//
		//   Protected inline functions.
		//
		//   A heap needs to compute the size of certain
		//   user supplied structures.  This task is 
		//   performed by the following function.
		//
		int ComputeSize( char *Array,int Stride );

		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		virtual void *SpecialNew( int Size );

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL( const ROCKALL & Copy );

        void operator=( const ROCKALL & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\PageHeap.hpp ===
#ifndef _PAGE_HEAP_HPP_
#define _PAGE_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallDebugFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specify the initial size of various tables.      */
    /*                                                                  */
    /********************************************************************/

const int MinLeadingGuardWords		  = (MaxFunctions + 1);

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CALL_STACK;

    /********************************************************************/
    /*                                                                  */
    /*   The page heap allocator.                                       */
    /*                                                                  */
    /*   The page heap allocator checks all the memory allocation       */
    /*   references to make sure they are reasonable.  If not then it   */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE PAGE_HEAP : public ROCKALL_DEBUG_FRONT_END
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Count;
			int						  Size;
			void					  *Functions[ MinLeadingGuardWords ];
			}
		HEADER;

		typedef struct
			{
			char					  GuardBytes[ GuardSize ];
			void					  *GuardWords[1];
			}
		TRAILER;

		typedef struct
			{
			HEADER					  DebugHeader;
			TRAILER					  DebugTrailer;
			}
		HEADER_AND_TRAILER;

		//
		//   Private data.
		//
		CALL_STACK					  *CallStack;
		bool						  ExitOnError;
		int							  PageMask;
		int							  PageSize;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        PAGE_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true,
			//
			//   Additional debug flags.
			//
			bool					  FunctionTrace = false,
			bool					  TrapOnUserError = true
			);

		virtual void HeapLeaks( void );

        virtual ~PAGE_HEAP( void );

	protected:
		//
		//   Guard word functions.
		//
		//   The guard word functions create, maintain,
		//   verify and delete guard words around
		//   page heap memory allocations.
		//
		virtual void DeleteGuard( void *Address );

		virtual bool NewGuard( void **Address,int Size,int *Space );

		virtual bool VerifyGuard( void *Address,int *Size,int *Space );

		virtual bool WalkGuard( bool *Active,void **Address,int *Space );

		virtual void UserError( void *Address,void *Details,char *Message );

	private:
		//
		//   Private functions.
		//
		//   Support functions to compute various
		//   offsets and sizes within the page heap.
		//   
		int ComputeGuardSpace( int Space );

		void *ComputeHeapAddress( void *Address );
			 
		int ComputeHeapSpace( int Space );

		void *ComputeUserAddress( void *Address,int Size );

		//
		//   Private functions.
		//
		//   Support functions to implement the guard
		//   words for the page heap.
		//   
		bool VerifyAddress
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			bool					  Verify
			);

		bool VerifyGuardWords
			( 
			void					  *Address,
			int						  Size 
			);

		bool VerifyHeader
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			bool					  Verify
			);

		bool VerifyHeaderAndTrailer
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			TRAILER					  **Trailer,
			bool					  Verify
			);

		bool VerifyTrailer
			( 
			HEADER					  *Header,
			int						  Space,
			TRAILER					  **Trailer
			);

		void WriteGuardWords
			( 
			void					  *Address,
			int						  Size 
			);

		//
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        PAGE_HEAP( const PAGE_HEAP & Copy );

        void operator=( const PAGE_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\RockallBackEnd.hpp ===
#ifndef _ROCKALL_BACK_END_HPP_
#define _ROCKALL_BACK_END_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation support services.                        */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL_BACK_END
    {
		//
		//   Private static data.
		//
		static ROCKALL_BACK_END		  DefaultBaseClass;

    public:
		//
		//   Low level heap interface.
		//
		//   The following group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		ROCKALL_BACK_END( void );

		virtual void DeleteArea( void *Memory,int Size,bool User );

		virtual int NaturalSize( void );

		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~ROCKALL_BACK_END( void );

		//
		//   Static public inline functions.
		//
		static ROCKALL_BACK_END *RockallBackEnd( void )
			{ return & DefaultBaseClass; }

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL_BACK_END( const ROCKALL_BACK_END & Copy );

        void operator=( const ROCKALL_BACK_END & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\RockallDebugBackEnd.hpp ===
#ifndef _ROCKALL_DEBUG_BACK_END_HPP_
#define _ROCKALL_DEBUG_BACK_END_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallBackEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The debug heap services.                                       */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DEBUG_BACK_END : public ROCKALL_BACK_END
    {
		//
		//   Private data.
		//
		bool					  Formatting;
		bool					  NoAccess;

		int						  PageSize;

    public:
		//
		//   Low level heap interface.
		//
		//   The following group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
        ROCKALL_DEBUG_BACK_END
			( 
			bool					  NewFormatting = false,
			bool					  NewNoAccess = false 
			);

		virtual void *NewArea( int AlignMask,int Size,bool User );

		void ProtectArea( void *Address,int Size );

		void UnprotectArea( void *Address,int Size );

        virtual ~ROCKALL_DEBUG_BACK_END( void );

		//
		//   Public line functions.
		//
		inline int GetPageSize( void )
			{ return PageSize; }

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL_DEBUG_BACK_END( const ROCKALL_DEBUG_BACK_END & Copy );

        void operator=( const ROCKALL_DEBUG_BACK_END & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\SingleSizeHeap.hpp ===
#ifndef _SINGLE_SIZE_HEAP_HPP_
#define _SINGLE_SIZE_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/
 
#include "DefaultHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The placement new and delete macros.                           */
    /*                                                                  */
    /*   The placement new and delete macros allow the constructor      */
    /*   and destructos of a type to be called as needed.               */
    /*                                                                  */
    /********************************************************************/

#define PLACEMENT_NEW( Address,Type )		new( Address ) Type
#define PLACEMENT_DELETE( Address,Type )	(((Type*) Address) -> ~Type())

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specify the size of local cache.                 */
    /*                                                                  */
    /********************************************************************/

const int MaxStackSize				  = 64;

    /********************************************************************/
    /*                                                                  */
    /*   A single size heap.                                            */
    /*                                                                  */
    /*   The vision for this class is to provide an extremely fast      */
    /*   simple single sized memory allocation class.  There are        */
    /*   claerly a large number of enhancemnts that could be made       */
    /*   such as locking, deleting all allocations in the destructor    */
    /*   and many others.  Nonetheless, such enhancements are not       */
    /*   covered as specific applications have differing requirements.  */
    /*   This class simply demonstrates how easy it is to build custom  */
    /*   functionality with Rockall.                                    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE = MaxStackSize> class SINGLE_SIZE_HEAP
    {
        //
        //   Private data.
        //
		int							  FillSize;
		int							  TopOfStack;

		ROCKALL_FRONT_END			  *Heap;
		TYPE						  *Stack[ STACK_SIZE ];

    public:
        //
        //   Public functions.
        //
        SINGLE_SIZE_HEAP( ROCKALL_FRONT_END *NewHeap = & DefaultHeap );

        TYPE *New( void );

        void Delete( TYPE *Type );

        ~SINGLE_SIZE_HEAP( void );

	private:
        //
        //   Disabled operations.
        //
        SINGLE_SIZE_HEAP( const SINGLE_SIZE_HEAP & Copy );

        void operator=( const SINGLE_SIZE_HEAP & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new pool and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE> SINGLE_SIZE_HEAP<TYPE,STACK_SIZE>::SINGLE_SIZE_HEAP
		( 
		ROCKALL_FRONT_END			  *NewHeap
		)
    {
	//
	//   Zero the top of stack and setup 
	//   the heap.
	//
	FillSize = (STACK_SIZE / 2);
    TopOfStack = 0;

	Heap = NewHeap;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Single size allocation.                                        */
    /*                                                                  */
    /*   We will allocate a variable and call the constructor.          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE> TYPE *SINGLE_SIZE_HEAP<TYPE,STACK_SIZE>::New( void )
    {
	//
	//   When we run out of allocations we fill the
	//   stack with a single call to Rockall.
	//
	if ( TopOfStack <= 0 )
		{
		Heap -> MultipleNew
			( 
			& TopOfStack,
			((void**) Stack),
			FillSize,
			sizeof(TYPE)
			);
		}

	//
	//   We will supply an allocation if one is available.
	//
	if ( TopOfStack > 0 )
		{
		TYPE *Type = Stack[ (-- TopOfStack) ];

		PLACEMENT_NEW( Type,TYPE );

		return Type; 
		}
	else
		{ return NULL; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Single size dellocation.                                       */
    /*                                                                  */
    /*   We will deallocate a variable and call the destructor.         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE> void SINGLE_SIZE_HEAP<TYPE,STACK_SIZE>::Delete
		( 
		TYPE						  *Type
		)
	{
	//
	//   When the supplied allocation is null we know
	//   we can skip the deallocation.
	//
	if ( Type != NULL )
		{
		//
		//   Delete the supplied allocation.
		//
		PLACEMENT_DELETE( Type,TYPE );

		Stack[ (TopOfStack ++) ] = Type;

		//
		//   Flush a portion of the stack if it
		//   is full.
		//
		if ( TopOfStack >= STACK_SIZE )
			{
			//
			//   Delete any outstanding memory 
			//   allocations.
			//
			Heap -> MultipleDelete
				(
				(TopOfStack -= FillSize),
				((void**) & Stack[ TopOfStack ])
				);
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE> SINGLE_SIZE_HEAP<TYPE,STACK_SIZE>::~SINGLE_SIZE_HEAP( void )
    {
	//
	//   Delete any outstanding memory 
	//   allocations.
	//
	Heap -> MultipleDelete
		(
		TopOfStack,
		((void**) Stack)
		);

	TopOfStack = 0;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\RockallFrontEnd.hpp ===
#ifndef _ROCKALL_FRONT_END_HPP_
#define _ROCKALL_FRONT_END_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   The hardware word size.                                        */
    /*                                                                  */
    /*   We need to deduce the word size for the current hardware so    */
    /*   we can create suitable constants and interfaces.               */
    /*                                                                  */
    /********************************************************************/

#ifndef _WIN64
typedef __w64 __int32				  SNATIVE;
typedef __w64 unsigned __int32		  UNATIVE;
#else
typedef __int64						  SNATIVE;
typedef unsigned __int64			  UNATIVE;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation constants.                                   */
    /*                                                                  */
    /*   The memory allocation constants are denote special situations  */
    /*   where optimizations are possible or failures have cccured.     */
    /*                                                                  */
    /********************************************************************/

const SNATIVE AllocationFailure		  = 0;
const SNATIVE GuardMask				  = (sizeof(void*)-1);
const SNATIVE GuardSize				  = sizeof(void*);
const SNATIVE HalfMegabyte			  = (512 * 1024);
const SNATIVE NoSize				  = -1;

#ifndef _WIN64
const SNATIVE GuardValue			  = 0xDeadBeef;
#else
const SNATIVE GuardValue			  = 0xDeadBeefDeadBeef;
#endif


    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class FIND;
class HEAP;
class NEW_PAGE;
class ROCKALL_BACK_END;
class THREAD_SAFE;

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation interface.                               */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL_FRONT_END
    {
    public:
		//
		//   Public types.
		//
		//   A heap is constructed of a collection of 
		//   fixed sized buckets each with an associated
		//   cache.  The details of these buckets are
		//   supplied to the heap using the following
		//   structure.
		//
		typedef struct
			{
			int						  AllocationSize;
			int						  CacheSize;
			int						  ChunkSize;
			int						  PageSize;
			}
		CACHE_DETAILS;

		//
		//   Public data.
		//
		//   The internals linkages in a heap are built
		//   dynamically during the execution of a heaps
		//   constructor.  The member that follow relate
		//   to key internal classes.
		//
		CACHE						  **Array;
		CACHE						  *Caches;
		HEAP						  *Heap;
		NEW_PAGE					  *NewPage;
		FIND						  *PrivateFind;
		FIND						  *PublicFind;
		ROCKALL_BACK_END			  *RockallBackEnd;
		THREAD_SAFE					  *ThreadSafe;

		//
		//   A heap constructor is required to preserve 
		//   a small amount of information for the heap
		//   destructor.
		//
		bool						  GlobalDelete;
		SNATIVE						  GuardWord;
		int							  NumberOfCaches;
		int							  TotalSize;

        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        ROCKALL_FRONT_END
			(
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  FindCacheSize,
			int						  FindCacheThreshold,
			int						  FindSize,
			int						  MaxFreeSpace,
			int						  *NewPageSizes,
			ROCKALL_BACK_END		  *NewRockallBackEnd,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafeFlag
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space = NULL
			);

        virtual ~ROCKALL_FRONT_END( void );

		//
		//   Public inline functions.
		//
		inline bool Available( void )
			{ return (GuardWord == GuardValue); }

		inline bool Corrupt( void )
			{ return (GuardWord != GuardValue); }

	protected:
		//
		//   Protected inline functions.
		//
		//   A heap needs to compute the size of certain
		//   user supplied structures.  This task is 
		//   performed by the following function.
		//
		int ComputeSize( char *Array,int Stride );

		//
		//   Execptional situations.
		//
		//   The third group of functions are called in
		//   exceptional situations.
		//
		virtual void Exception( char *Message );

		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as part of heap deletion.
		//
		virtual void *SpecialNew( int Size );

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL_FRONT_END( const ROCKALL_FRONT_END & Copy );

        void operator=( const ROCKALL_FRONT_END & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\smallheap.hpp ===
#ifndef _SMALL_HEAP_HPP_
#define _SMALL_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A small heap.                                                  */
    /*                                                                  */
    /*   A small heap tries to significantly reduce memory usage        */
    /*   even if that comes at a significant cost in terms of           */
    /*   performance.                                                   */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE SMALL_HEAP : public ROCKALL_FRONT_END
    {
   public:
        //
        //   Public functions.
        //
        SMALL_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~SMALL_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMALL_HEAP( const SMALL_HEAP & Copy );

        void operator=( const SMALL_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\windowsheap.hpp ===
#ifndef WINDOWS_HEAP_HPP 
#define WINDOWS_HEAP_HPP 1                         
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Windows.h"

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

#ifdef __cplusplus
#define EXTERN_C			extern "C"
#else
#define EXTERN_C
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The shadow interface.                                          */
    /*                                                                  */
    /*   The shadow interface closely resembles the NT heap interface   */
    /*   and so enables the easy porting of applications.               */
    /*                                                                  */
    /********************************************************************/

EXTERN_C ROCKALL_DLL_LINKAGE HANDLE WindowsHeapCreate
	( 
	DWORD						  Flags,
	DWORD						  InitialSize,
	DWORD						  MaximumSize 
	);

EXTERN_C ROCKALL_DLL_LINKAGE LPVOID WindowsHeapAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	DWORD						  Size 
	);

EXTERN_C ROCKALL_DLL_LINKAGE UINT WindowsHeapCompact
	( 
	HANDLE						  Heap,
	DWORD						  Flags 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapFree
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapLock
	( 
	HANDLE						  Heap 
	);

EXTERN_C ROCKALL_DLL_LINKAGE LPVOID WindowsHeapReAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory,
	DWORD						  Size 
	);

EXTERN_C ROCKALL_DLL_LINKAGE VOID WindowsHeapReset
	(
	HANDLE						  Heap 
	);

EXTERN_C ROCKALL_DLL_LINKAGE DWORD WindowsHeapSize
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapUnlock
	(
	HANDLE						  Heap 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapValidate
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapWalk
	( 
	HANDLE						  Heap,
	LPPROCESS_HEAP_ENTRY		  Walk 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapDestroy
	(
	HANDLE						  Heap 
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\zoneheap.hpp ===
#ifndef _ZONE_HEAP_HPP_
#define _ZONE_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

#pragma warning( disable : 4100 )

    /********************************************************************/
    /*                                                                  */
    /*   A zone heap.                                                   */
    /*                                                                  */
    /*   A zone heap simply allocates a large amount of space and       */
    /*   allocates space by advancing a pointer down an array.          */
    /*   There is no way to free space except by deleting it all.       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ZONE_HEAP : public ROCKALL_FRONT_END
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
			char					  *Start;
			char					  *End;
			}
		ZONE;

		//
		//   Private data.
		//
		int							  MaxSize;
		bool						  ThreadLocks;
		ZONE						  Zone;

   public:
        //
        //   Public functions.
        //
        ZONE_HEAP
			( 
			int						  MaxFreeSpace = (2 * HalfMegabyte),
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
				( 
				void				  *Address,
				int					  Size = NoSize 
				)
			{ return false; }

		virtual bool Details
				( 
				void				  *Address,
				int					  *Space = NULL 
				)
			{ return false; }

		virtual bool MultipleDelete
				( 
				int					  Actual,
				void				  *Array[],
				int					  Size = NoSize
				)
			{ return false; }

		virtual bool MultipleNew
				( 
				int					  *Actual,
				void				  *Array[],
				int					  Requested,
				int					  Size,
				int					  *Space = NULL,
				bool				  Zero = false
				);

		virtual void *New
				( 
				int					  Size,
				int					  *Space = NULL,
				bool				  Zero = false
				);

		virtual void *Resize
				( 
				void				  *Address,
				int					  NewSize,
				int					  Move = -64,
				int					  *Space = NULL,
				bool				  NoDelete = false,
				bool				  Zero = false
				)
			{ return NULL; }

		virtual bool Verify
				( 
				void				  *Address = NULL,
				int					  *Space = NULL 
				)
			{ return false; }

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual bool Walk
				(
				bool				  *Active,
				void				  **Address,
				int					  *Space
				)
			{ return false; }

        ~ZONE_HEAP( void );

	private:
		//
		//   Private functions.
		//
		bool UpdateZone( ZONE *Original,ZONE *Update );

		void WriteZone( ZONE *Update );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ZONE_HEAP( const ZONE_HEAP & Copy );

        void operator=( const ZONE_HEAP & Copy );
    };

#pragma warning( default : 4100 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\RockallDebugFrontEnd.hpp ===
#ifndef _ROCKALL_DEBUG_FRONT_END_HPP_
#define _ROCKALL_DEBUG_FRONT_END_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specify the initial size of various tables.      */
    /*                                                                  */
    /********************************************************************/

const int MaxFunctions				  = 5;

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL_DEBUG_FRONT_END : public ROCKALL_FRONT_END
    {
    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        ROCKALL_DEBUG_FRONT_END
			( 
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  MaxFreeSpace,
			ROCKALL_BACK_END		  *RockallBackEnd,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafe
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = 1,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

        virtual ~ROCKALL_DEBUG_FRONT_END( void );

	protected:
		//
		//   Guard word functions.
		//
		//   The guard word functions create, maintain,
		//   verify and delete guard words around
		//   debug memory allocations.
		//
		virtual void DeleteGuard( void *Address ) = 0;

		virtual bool NewGuard( void **Address,int Size,int *Space ) = 0;

		virtual bool VerifyGuard( void *Address,int *Size,int *Space ) = 0;

		virtual bool WalkGuard( bool *Active,void **Address,int *Space ) = 0;

		virtual void UserError( void *Address,void *Header,char *Message ) = 0;

	private:
		//
		//   Execptional situations.
		//
		//   The third group of functions are called in
		//   exceptional situations.
		//
		virtual void Exception( char *Message );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL_DEBUG_FRONT_END( const ROCKALL_DEBUG_FRONT_END & Copy );

        void operator=( const ROCKALL_DEBUG_FRONT_END & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\xtools\smpheap.hpp ===
#ifndef _SMP_HEAP_HPP_
#define _SMP_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPLAIN_ABOUT_SMP_HEAP_LEAKS
#include "DebugHeap.hpp"
typedef DEBUG_HEAP					  SMP_HEAP_TYPE;
#else
#include "FastHeap.hpp"
typedef FAST_HEAP					  SMP_HEAP_TYPE;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class DLL;
class LIST;
class TLS;

struct PRIVATE_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   A SMP heap.                                                    */
    /*                                                                  */
    /*   A SMP heap is optimized for SMP performance.  Each thread      */
    /*   is given its own private per thread heap but the standard      */
    /*   Rockall API is maintained so it looks like a single heap.      */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE SMP_HEAP : public SMP_HEAP_TYPE
    {
		//
		//   Private data.
		//
		bool						  Active;
		bool						  DeleteOnExit;

		LIST						  *ActiveHeaps;
		DLL							  *DllEvents;
		LIST						  *FreeHeaps;
		PRIVATE_HEAP				  *HeapWalk;
		TLS							  *Tls;

		int							  ActiveLocks;
		int							  MaxFreeSpace;
		bool						  Recycle;
		bool						  SingleImage;
		bool						  ThreadSafe;

   public:
        //
        //   Public functions.
        //
        SMP_HEAP
			( 
			int						  MaxFreeSpace = (2 * HalfMegabyte),
			bool					  Recycle = true,
			bool					  SingleImage = true,
			bool					  ThreadSafe = true,
			//
			//   Special flags for this heap.
			//
			bool					  DeleteHeapOnExit = false
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Special public functions
		//
		static void ThreadDetach( void *Parameter,int Reason );

        ~SMP_HEAP( void );

	protected:
		//
		//   Protected inline functions.
		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		virtual void *SpecialNew( int Size );

   private:
		//
		//   Static private functions.
		//
	    PRIVATE_HEAP *GetPrivateHeap( void );


        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMP_HEAP( const SMP_HEAP & Copy );

        void operator=( const SMP_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\inc\bldver.cpp ===
using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;

//
// if you want to use a private version file and customize this, see
// file://samsndrop02/CoreXT-Latest/docs/corext/corext/version.htm
//

[assembly: AssemblyVersion("12.4.56.0")];

[assembly: AssemblyCompany("Microsoft Corp.")];
[assembly: AssemblyProduct("Microsoft CoReXT")];
[assembly: AssemblyCopyright("2002")];



#if ENABLE_CODESIGN
#if !(BUILD_NO_GLOBAL_STRONG_NAME)
#if ENABLE_PRS_DELAYSIGN
[assembly: AssemblyDelaySign(true)];
[assembly: AssemblyKeyFile("C:\\Depot\\XONLINE_MAIN\\private\\keys\\XBLKey.snk")];
#else
[assembly: AssemblyKeyFile("")];
[assembly: AssemblyKeyName("")];
[assembly: AssemblyDelaySign(false)];
#endif
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\inc\bldver.h ===
//
// this file is automatically generated
// by beaver.exe 1.11.2003.0
//

//
// if you want to use a private version file and customize this, see
// file://samsndrop02/CoreXT-Latest/docs/corext/corext/version.htm
//

#ifndef _BLDVER_H_
#define _BLDVER_H_

#define BUILD_NUMBER            "56.0"
#define BUILD_NUM               56,0
#define PRODUCT_NUMBER          "12.4"
#define PRODUCT_NUM             12,4
#define INET_VERSION            "12.4.56.0"
#define INET_VER                12,4,56,0

#define PRODUCT_MAJOR           12
#define PRODUCT_MAJOR_STRING    "12"
#define PRODUCT_MAJOR_NUMBER    12

#define PRODUCT_MINOR           4
#define PRODUCT_MINOR_STRING    "4"
#define PRODUCT_MINOR_NUMBER    4

#define BUILD_MAJOR             56
#define BUILD_MAJOR_STRING      "56"
#define BUILD_MAJOR_NUMBER      56

#define BUILD_MINOR             0
#define BUILD_MINOR_STRING      "0"
#define BUILD_MINOR_NUMBER      0

#define BUILD_PRIVATE           "Built by Administrator on WIN-HF6BUG0SJII.\0"

#define VER_PRODUCTMAJORVERSION 12
#define VER_PRODUCTMINORVERSION 4
#define VER_PRODUCTBUILD        56
#define VER_PRODUCTBUILD_QFE    0
#define VER_PRODUCTVERSION      12,4,56,0
#define VER_PRODUCTVERSION_STR  "12.4.56.0"
#define VER_PRODUCTNAME_STR     "Microsoft(R) Xbox(TM)"
#define VER_COMPANYNAME_STR     "Microsoft Corporation"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\inc\bldver.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// if you want to use a private version file and customize this, see
// file://samsndrop02/CoreXT-Latest/docs/corext/corext/version.htm
//

#if FIXED_ASSEMBLY_VERSION
[assembly: AssemblyVersion("12.4.0.0")]
[assembly: AssemblyFileVersion("12.4.56.0")]
#else
[assembly: AssemblyVersion("12.4.56.0")]
#endif


[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft(R) Xbox(TM)")] 
[assembly: AssemblyCopyright("\xA9 Microsoft Corporation. All rights reserved.")]
[assembly: AssemblyTrademark("Microsoft(R) is a registered trademark of Microsoft Corporation. Xbox(TM) is a trademark of Microsoft Corporation.")]
[assembly: AssemblyDescription("Built by: Administrator")] 

#if ENABLE_CODESIGN

#if ENABLE_PRS_DELAYSIGN
[assembly: AssemblyKeyFile(@"C:\Depot\XONLINE_MAIN\private\keys\XBLKey.snk")]
[assembly: AssemblyKeyName("")]
[assembly: AssemblyDelaySign(true)]
#else
#if !CUSTOM_KEYFILE
[assembly: AssemblyKeyFile(@"C:\Depot\XONLINE_MAIN\public\internal\strongnamekeys\fake\CoreXTTestKey.snk")]
[assembly: AssemblyKeyName("")]
#endif
[assembly: AssemblyDelaySign(false)]
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\automation\v2\etc\BuildTrackerHelper.cs ===
/*
    This file contains various quick-run BT API calls for use from different scripts

    Run:
    nxe.exe -R -r %extpath%\BuildTracker\Api\3.6\Microsoft.BuildTracker.Contracts.dll -r %extpath%\BuildTracker\Api\3.6\Microsoft.BuildTracker.Client.dll %inetroot%\build\scripts\etc\BuildTrackerHelper.cs -35 -a [btApiUrl] <Function> [args...]

    * pass the net.tcp Uri as the first parameter, or set BuildTrackerApiUri in your environment prior to calling
    * if parsing output, set EOL=; to ignore comments (FOR /F "eol=;" %%I IN ...)

    Functions:

      JobLegs <jobId> [<file>]
        [OUT] Leg<tab>id<tab>name<tab>type<tab>description

      BranchDrop <branch>
        [OUT] <DropName><tab><DropShare>

*/

using System;
using System.Text;
using System.Xml;
using Microsoft.BuildTracker.Client;

namespace Tools
{
    class Script
    {
        private static string DefaultBuildTrackerApiUri = "net.tcp://BUILDLABAPI:9700/BuildTrackerApi";
        private static string BuildTrackerApiUri;

        public static int Main(string[] args)
        {
            int result = 1;
            int argStart = 0;

            if (args.Length > 0 && args[0].StartsWith("net.tcp", StringComparison.OrdinalIgnoreCase))
            {
                BuildTrackerApiUri = args[0];
                ++argStart;
            }
            else if (string.IsNullOrEmpty(BuildTrackerApiUri = Environment.GetEnvironmentVariable("BuildTrackerApiUri")))
            {
                BuildTrackerApiUri = DefaultBuildTrackerApiUri;
            }

            if (args.Length < argStart + 1)
            {
                Console.Error.WriteLine("No function given");
                return 1;
            }


            string function = args[argStart++].ToUpper();
            string[] functionArgs = new string[args.Length - argStart];
            Array.Copy(args, argStart, functionArgs, 0, functionArgs.Length);

            try
            {
                Console.WriteLine(";Connecting to " + BuildTrackerApiUri);
                switch (function)
                {
                    case "JOBLEGS" : result = GetJobLegs(functionArgs); break;
                    case "BRANCHDROP" : result = GetBranchDrop(functionArgs); break;
                    default : Console.Error.WriteLine("No function found with name : " + args[0]); break;
                }
            }
            catch (Exception e)
            {
                Console.Error.WriteLine(e.ToString());
            }
            return result;
        }

        /// <summary>Get the Job leg list</summary>
        /// <param name="args">[jobId]</param>
        public static int GetJobLegs(string[] args)
        {
            int result = 0;
            if (args.Length < 1)
            {
                throw new ArgumentNullException("jobId missing for function GetJobLegs");
            }

            int jobId = int.Parse(args[0]);
            string xmlOut = null;
            XmlDocument legsDoc = null;
            XmlNode legsNode = null;

            if (args.Length > 1)
            {
                xmlOut = args[1];
                legsDoc = new XmlDocument();
                legsNode = AddNode(legsDoc, legsDoc, "BuildTracker", null);
                legsNode = AddNode(legsDoc, legsNode, "BuildJob", null);
                AddNode(legsDoc, legsNode, "@instance", jobId.ToString());
                legsNode = AddNode(legsDoc, legsNode, "Legs", null);
            }

            using(BuildTrackerService bt = BuildTrackerService.Connect(BuildTrackerApiUri))
            {
                JobInstance instance = bt.GetJobInstance(jobId);
                JobDefinition def = instance.GetJobDefinition();
                foreach (LegDefinition leg in def.GetLegDefinitions())
                {
                    string type = leg.GetType().ToString();
                    type = type.Substring(type.LastIndexOf(".")+1);

                    if (legsNode != null)
                    {
                        XmlNode legNode = AddNode(legsDoc, legsNode, "Leg", null);
                        AddNode(legsDoc, legNode, "@id", leg.Id.ToString());
                        AddNode(legsDoc, legNode, "@name", leg.Name);
                        AddNode(legsDoc, legNode, "@description", leg.Description);
                        AddNode(legsDoc, legNode, "@type", type);
                    }
                    Console.WriteLine("Leg\t{0}\t{1}\t{2}\t{3}", leg.Id, leg.Name, type, leg.Description);
                }
            }

            if (legsDoc != null)
            {
                XmlWriterSettings settings = new XmlWriterSettings(){OmitXmlDeclaration = true, Indent = true, Encoding = Encoding.ASCII};
                using (XmlWriter writer = XmlWriter.Create(xmlOut, settings))
                {
                    legsDoc.Save(writer);
                }
            }

            return result;
        }


        /// <summary>Get the BuildShareGroup name and path for a given branch</summary>
        /// <param name="args">[product],[branch]</param>
        public static int GetBranchDrop(string[] args)
        {
            int result = 0;
            if (args.Length < 2)
            {
                throw new ArgumentNullException("Product or branch missing for function GetBranchDrop");
            }

            string productName = args[0];
            string branchName = args[1];

            using(BuildTrackerService bt = BuildTrackerService.Connect(BuildTrackerApiUri))
            {
                Product prod = bt.GetProduct(productName);
                Branch branch = prod.GetBranch(branchName);
                BuildShareGroup primaryGroup = null;

                foreach(BuildShareGroup group in branch.GetBuildShareGroups())
                {
                    Console.WriteLine(";Found Group:" + group.Name);
                    if (group.Name.ToLower().Contains(branchName)) //, StringComparer.OrdinalIgnoreCase))
                    {
                        primaryGroup = group;
                    }
                }

                if (primaryGroup == null)
                {
                    Console.Error.WriteLine("No Group Found when searching for branchname inside the BuildShareGroup name");
                    result = 1;
                }
                else
                {
                    Console.WriteLine("{0}\t{1}", primaryGroup.Name, primaryGroup.DropSharePath);
                }
            }

            return result;
        }

        /// <summary>
        /// Add a node beneath the parent
        /// </summary>
        /// <param name="owner">Owner document.</param>
        /// <param name="parent">Parent node.</param>
        /// <param name="name">Name of the node or attribute to get or add.</param>
        /// <returns>The node that was added</returns>
        private static XmlNode AddNode(XmlDocument owner, XmlNode parent, string name, string value)
        {
            if (string.IsNullOrEmpty(name))
                throw new ArgumentNullException("name");
            if (parent == null)
                throw new ArgumentNullException("parent");

            bool isAttribute = false;
            XmlNode result = null;
            if (name[0] == '@')
            {
                name = name.Substring(1);
                isAttribute = true;
            }

            if (isAttribute)
            {
                XmlAttribute attr = owner.CreateAttribute(name);
                parent.Attributes.Append(attr);
                if (!string.IsNullOrEmpty(value))
                {
                    attr.Value = value;
                }
                result = attr;
            }
            else
            {
                XmlNode child = owner.CreateElement(name);
                parent.AppendChild(child);
                if (!string.IsNullOrEmpty(value))
                {
                    child.InnerText = value;
                }
                result = child;
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\DependencySpy\makefile.inc ===
##
#
# This is a makefile to use for depencency check
# Just include it in your makefile.inc, and add sources.inc to your sources
#
# Author: SergeiS
#
##

DEPEND_TOOL = $(INETROOT)\tools\build\DependencySpy\depend.pl

!if exist (".\makefile.dep")
#this can define MISSINGDEPENDENCIES, too
!include ".\makefile.dep"

!ifdef MISSINGDEPENDENCIES
## something was deleted -- need a clean build
!message DependencySpy info: Missing dependencies found, deleting "$(O)\" ...
!if [-del /q /s "$(O)" >nul 2>nul]
!endif 
!endif

!else
!if !defined(NO_DEPENDENCY_CHECK)
MISSINGDEPENDENCIES = 1
!endif

!endif

!ifndef DEPEND_ROOT
# can be defined in your makefile.inc
# Everything under this tree is considered a "dependency". 
# Everything outside that is included is out counted to save time and makefile.dep size
# It is not recommended to use $(INETROOT) because some locations there are likely to depend on the build type (debug/retail)
DEPEND_ROOT = $(INETROOT)\private
!endif

GENERATE_MAKEFILE_DEP = perl $(DEPEND_TOOL) "$(DEPEND_ROOT)" "$(SOURCES)" $(CXX_COMPILER_FLAGS)

!ifdef MISSINGDEPENDENCIES

# either makefile.dep doesn't exist or
# some files marked as dependent are missing 
# -- nmake doesn't support dependence of the files' existance, 
#    so we can't include dependencies of the missing files, need to re-generate the list (at preprocess time)
!if [$(GENERATE_MAKEFILE_DEP)]
!endif
#and include it again
!include ".\makefile.dep"

!endif

makefile.dep: .\sources $(DEPEND_TOOL)  $(DEPENDADDINIONALFILES)
	$(GENERATE_MAKEFILE_DEP)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\DependencySpy\sources.inc ===
## 
# dependency check for DependencySpy
#
# include this file in your sources
#
# assign DEPENDADDITIONALFILES to anything the change if that will cause dependencies to rebuild 
# (your sources and makefile.inc in the project dir are already included, but you may want to add something that you !include from them)
#
##

# this really relies on the existance of makefile.inc (which should include tools\build\DependencySpy\makefile.inc . Main CoreXC makefile.inc is really optional for .c/.cpp projects.)
!if exist (".\makefile.inc") && !defined(NO_DEPENDENCY_CHECK)
#build a .dep file
NTTARGETFILE1	= $(NTTARGETFILE1) .\makefile.dep
#set to rebuild it if the following files have changes (including this file)
DEPENDADDITIONALFILES	= $(DEPENDADDITIONALFILES) $(INETROOT)\tools\build\DependencySpy\sources.inc $(INETROOT)\tools\build\DependencySpy\makefile.inc
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\makefiles\makefile.cs ===
#
# C# compiler rules (ddoub)
#

! if "$(CSCOMPILERNAME)" == ""
CSCOMPILERNAME=csc.exe
! endif

! if "$(CSTARGETTYPE)" == "CONSOLE"
CSTARGETEXT=exe
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /target:exe
! elseif "$(CSTARGETTYPE)" == "PROGRAM"
CSTARGETEXT=exe
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /target:winexe
! elseif "$(CSTARGETTYPE)" == "LIBRARY"
CSTARGETEXT=dll
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /target:library
! elseif "$(CSTARGETTYPE)" == "DYNLINK"
CSTARGETEXT=dll
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /target:library
! elseif "$(CSTARGETTYPE)" == "MODULE"
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /target:module
CSTARGETEXT=netmodule
! else
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /target:exe
CSTARGETEXT=exe
! endif

! if "$(CSMODULES)"!=""
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /addmodule:$(CSMODULES)
! endif

! if "$(CSDEFINES)"!=""
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /define:$(CSDEFINES)
! endif

CSTARGETBINARY=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(CSTARGETEXT)

! if $(FREEBUILD)
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /debug- /debug:pdbonly
! else
CSCOMPILERFLAGS=$(CSCOMPILERFLAGS) /debug+ /debug:full
! endif

csharp:
! if "$(LINKONLY)"==""
    echo Build_Status BUILD: Building $(CSTARGETBINARY)
    echo Build_Status BUILD: Compiling $(CSSOURCES)
    $(CSCOMPILERNAME) $(CSCOMPILERFLAGS) /nologo /out:$(CSTARGETBINARY) $(CSSOURCES)
! endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\makefiles\makefile.inc ===
!IFNDEF COREXT_MAKEFILE_INC
!INCLUDE makefile.wix
!INCLUDE makefile.edb
!INCLUDE makefile.lba
!INCLUDE makefile.lcx
!INCLUDE makefile.chm
!INCLUDE makefile.lib
!if defined(SQL_DATABASES)
!INCLUDE makefile.sql
!INCLUDE makefile.spil
!endif
!INCLUDE makefile.rsx
!INCLUDE makefile.tlb
!INCLUDE makefile.ax
!INCLUDE makefile.net
!INCLUDE makefile.il
!INCLUDE makefile.signed
!INCLUDE makefile.aspnet
!INCLUDE makefile.wsdl
!INCLUDE makefile.inlineTests
!INCLUDE makefile.deprecated
COREXT_MAKEFILE_INC=1
!ELSE
! message BUILDMSG: Warning: Do not !include $(INETROOT)\build\makefile.inc twice!
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Override\etc\CompactFramework\AsmFileVer.cs ===
using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(AttributeTargets.Assembly, Inherited=false), ComVisible(true)]
    public sealed class AssemblyFileVersionAttribute : Attribute
    {
        // Fields
        private string _version;
    
        // Methods
        public AssemblyFileVersionAttribute(string version)
        {
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            this._version = version;
        }

        // Properties
        public string Version
        {
            get
            {
                return this._version;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\support\binupdate\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\support\binupdate\binVersion.cs ===
using System;
using System.Diagnostics;
using System.IO;

namespace binVersion
{
	/// <summary>
	/// Methods for retrieving and comparing file versions and dates.
	/// </summary>
	class BinVersion
	{
		bool m_fOptionCopy;
		bool m_fOptionBackupOverwrite;
		bool m_fSourceDepot;
		bool m_fQuiet;

		String m_sLeft;
		String m_sRight;
		String m_sBackupFolder;

		BinVersion() 
		{
			m_fOptionCopy = false;
			m_fOptionBackupOverwrite = false;
			m_fSourceDepot = false;
			m_fQuiet = false;

			m_sLeft = null;
			m_sRight = null;
			m_sBackupFolder = null;
		}

		void ConsoleOutput(string s)
		{
			if (m_fQuiet)
				return;

			Console.WriteLine(s);
		}

		static void Usage()
		{
			Console.Write(
				"\n    " + System.Reflection.Assembly.GetCallingAssembly().ToString() + " (rragno/ddoub)\n\n" +
				"    Usage:\n\n" +			
				"      binupdate <options> [file]\n" +
				"        Gives the version and date of 'file'.\n\n" +
				"      binupdate <options> [left file] [right file]\n" +
				"        Compares the version and date of 'file1' and 'file2'.\n\n" +
				"    Options:\n\n" +
				"      -?, -h(elp)        : this help screen\n" +
				"          -c(opy)        : perform copy\n" +
				"          -backup:path   : backup path\n" +
				"          -o(verwrite)   : overwrite backups\n" +
				"          -s(depot)      : source depot edit\n" +
				"          -q(quiet)      : quiet mode\n"
				);
			
			Environment.Exit(-1);
		}

		void copyFiles()
		{

			string fileNameOnly = Path.GetFileName(m_sLeft);
			string pathNameOnly = Path.GetDirectoryName(m_sLeft);
			
			int nCompareVersion = compareVersions(m_sLeft, m_sRight);
			int nCompareDates = compareDates(m_sLeft, m_sRight);

			if (nCompareVersion < 0)
				Console.WriteLine(fileNameOnly + ": " + fileVersion(m_sLeft) + " -> " + fileVersion(m_sRight) + " (" + pathNameOnly + ")");
			else if (nCompareDates < 0)
				Console.WriteLine(fileNameOnly + ": " + fileDate(m_sLeft) + " -> " + fileDate(m_sRight) + " (" + pathNameOnly + ")");
			else 
				Console.WriteLine(fileNameOnly + ": " + fileDate(m_sLeft) + " (" + pathNameOnly + ")");

			if (! m_fOptionCopy)
				return;

			if (nCompareVersion == 0 && nCompareDates >= 0)
				return;

			// current version is newer
			if (nCompareVersion > 0)
				return;

			if (m_sBackupFolder != null)
			{
				
				string sTargetBackupFile = Path.Combine(m_sBackupFolder, fileNameOnly);
				
				if (m_fOptionBackupOverwrite && File.Exists(sTargetBackupFile))
				{				
					System.IO.FileAttributes fAttributes = File.GetAttributes(sTargetBackupFile);
					if (((fAttributes & System.IO.FileAttributes.ReadOnly) == System.IO.FileAttributes.ReadOnly) || 
						((fAttributes & System.IO.FileAttributes.System) == System.IO.FileAttributes.System))
					{
						ConsoleOutput("Resetting attributes on " + sTargetBackupFile + "...");
						fAttributes &= ~System.IO.FileAttributes.ReadOnly;
						fAttributes &= ~System.IO.FileAttributes.System;
						File.SetAttributes(sTargetBackupFile, fAttributes);					
					}
				}

				ConsoleOutput("Backing up " + m_sLeft + " to " + m_sBackupFolder + "...");

 				File.Copy(m_sLeft, sTargetBackupFile, m_fOptionBackupOverwrite);				
			}

			if (m_fSourceDepot)
			{					
				ConsoleOutput("Source-depot editing " + m_sLeft + "...");

//				Microsoft.SourceDepot.DepotClient sDepot = new Microsoft.SourceDepot.DepotClient();
//				sDepot.AutoConnect();
//				sDepot.RunCommand("edit", new string[] { m_sLeft });
				ProcessStartInfo psi = new ProcessStartInfo("sd", "edit " + m_sLeft);
				psi.CreateNoWindow = true;
				psi.WindowStyle = ProcessWindowStyle.Hidden;
				Process.Start(psi).WaitForExit();
			}

			ConsoleOutput("Copying updated " + fileNameOnly + " to " + pathNameOnly + "...");

			File.Copy(m_sRight, m_sLeft, true);
		}

		/// <summary>
		/// Driver for basic version comparison and operations.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			try
			{
				RunBinUpdate(args);
			}
			catch (Exception e)
			{						
				Console.Error.WriteLine(e.Message.ToString());
				Environment.Exit(-1);
			}
		}

		static void RunBinUpdate(string[] args)
		{
			BinVersion binVersion = new BinVersion();

			for (int nArg = 0; nArg < args.Length; nArg++)
			{
				String sArg = args[nArg];
				String sTrimmedArg = sArg.TrimStart('/', '-');

				if (sArg.Length != sTrimmedArg.Length)
				{
					if (sTrimmedArg == "copy")
					{
						binVersion.m_fOptionCopy = true;						
					}                    
					else if (sTrimmedArg.StartsWith("backup:"))
					{
						binVersion.m_sBackupFolder = sTrimmedArg.Substring(7);						
					}
					else if (sTrimmedArg == "overwrite")
					{
						binVersion.m_fOptionBackupOverwrite = true;
					}
					else if (sTrimmedArg == "sdepot")
					{
						binVersion.m_fSourceDepot = true;
						
					}
					else if (sTrimmedArg == "quiet")
					{
						binVersion.m_fQuiet = true;
					}
					else for (int nInArg = 0; nInArg < sTrimmedArg.Length; nInArg++)
						 {
							 switch (sTrimmedArg[nInArg])
							 {
								 case '?':
								 case 'h':								 
									 Usage();
									 break;
								 case 'c':								 
									 binVersion.m_fOptionCopy = true;
									 break;
								 case 'o':
									 binVersion.m_fOptionBackupOverwrite = true;
									 break;
								 case 's':
									 binVersion.m_fSourceDepot = true;
									 break;
								 case 'q':
									 binVersion.m_fQuiet = true;
									 break;
								 default:
									 Console.WriteLine("Error! Unknown option " + sTrimmedArg[nInArg]);
									 Usage();
									 break;
							 };
						 }

					continue;
				}

				if (binVersion.m_sLeft != null)
				{
					if (binVersion.m_sRight == null) 
					{
						binVersion.m_sRight = args[nArg];
					}
					else 
					{
						Usage();
					}
				}
				else
				{
					binVersion.m_sLeft = args[nArg];
				}
			}

			if (binVersion.m_sLeft == null) Usage();

			if (binVersion.m_sRight == null)
			{
				binVersion.showProperties(binVersion.m_sLeft);
			}
			else
			{
				binVersion.showProperties(binVersion.m_sLeft);
				binVersion.showProperties(binVersion.m_sRight);

				binVersion.showCompareDates();
				binVersion.showCompareVersions();
				binVersion.copyFiles();			
			}
		}

		void showProperties(String fileName)
		{
			ConsoleOutput(fileName);
			ConsoleOutput("        date: " + fileDate(fileName));
			ConsoleOutput("     version: " + fileVersion(fileName));
		}

		void showCompareDates()
		{
			int nCompareDate = compareDates(m_sLeft, m_sRight);

			if (nCompareDate == 0)
			{
				ConsoleOutput("Dates are indentical.");
			}
			else
			{
				ConsoleOutput(m_sLeft + " date is " + ((nCompareDate > 0)?"newer":"older") + " than " + m_sRight + ".");
			}
		}

		void showCompareVersions()
		{
			int nCompareVersion = compareVersions(m_sLeft, m_sRight);

			if (nCompareVersion == 0)
			{
				ConsoleOutput("Versions are identical.");					
			}
			else
			{
				ConsoleOutput(m_sLeft + " version is " + ((nCompareVersion > 0)?"newer":"older") + " than " + m_sRight + ".");
			}
		}

		/// returns the full version of the given file as a string
		/// returns "" if file does not exist or can't be accessed or has version "0.0.0.0"
		///         or no version info
		static string fileVersion(string fname)
		{
			FileVersionInfo verInfo = FileVersionInfo.GetVersionInfo(fname);
			
			if (verInfo == null)  
			{
				return "0.0.0.0";
			}
			
			return verInfo.FileVersion.Replace("\"", "");
		}

		/// returns the date of the given file as a string
		/// returns "" if file does not exist or can't be accessed
		static string fileDate(string fname)
		{			
			return  File.GetLastWriteTime(fname).ToString();
		}

		/// returns -1 for less than, 0 for equal, +1 for greater than
		/// also returns 0 if incomparable (file doesn't exist or has no version info)
		static int compareVersions(string fname1, string fname2)
		{
			FileVersionInfo verInfo1 = FileVersionInfo.GetVersionInfo(fname1);
			FileVersionInfo verInfo2 = FileVersionInfo.GetVersionInfo(fname2);
			if (verInfo1 == null || verInfo2 == null)  
			{
				return 0;
			}

			if (verInfo1.FileVersion == verInfo2.FileVersion)
			{
				return 0;
			}
				
			if (verInfo1.FileMajorPart > verInfo2.FileMajorPart)  return 1;
			if (verInfo1.FileMajorPart < verInfo2.FileMajorPart)  return -1;

			if (verInfo1.FileMinorPart > verInfo2.FileMinorPart)  return 1;
			if (verInfo1.FileMinorPart < verInfo2.FileMinorPart)  return -1;

			if (verInfo1.FileBuildPart > verInfo2.FileBuildPart)  return 1;
			if (verInfo1.FileBuildPart < verInfo2.FileBuildPart)  return -1;

			if (verInfo1.FilePrivatePart > verInfo2.FilePrivatePart)  return 1;
			if (verInfo1.FilePrivatePart < verInfo2.FilePrivatePart)  return -1;

			throw(new SystemException("Error! This is impossible."));			
		}


		/// returns -1 for less than, 0 for equal, +1 for greater than
		/// also returns 0 if incomparable (file doesn't exist)
		static int compareDates(string fname1, string fname2)
		{
			DateTime dateInfo1 = File.GetLastWriteTime(fname1);
			DateTime dateInfo2 = File.GetLastWriteTime(fname2);

			return dateInfo1.CompareTo(dateInfo2);
		}

//		static void SDThrowException(SourceDepotWrapper.SDWrapper oSdWrapper)
//		{
//			SDThrowException(oSdWrapper, true);
//		}
//
//		static void SDThrowException(SourceDepotWrapper.SDWrapper oSdWrapper, bool fThrowOnWarnings)
//		{
//			if (oSdWrapper.errors.fieldCount > 0 || (oSdWrapper.warnings.fieldCount > 0 && fThrowOnWarnings))
//			{
//				throw(SDMakeException(oSdWrapper));
//			}
//		}
//
//		static SystemException SDMakeException(SourceDepotWrapper.SDWrapper oSdWrapper)
//		{
//			string sWarnings = oSdWrapper.warnings.Join(null, null);
//			string sErrors = oSdWrapper.errors.Join(null, null);
//
//			if (sErrors.Length == 0 && sWarnings.Length == 0)
//				return null;
//
//			return new SystemException("Errors:\n" + sErrors + "\nWarnings:\n" + sWarnings);
//			
//		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\authdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       authdata.cxx
//
//  Contents:   KDC Internal Authdata types
//
//  Classes:
//
//  Functions:
//
//  History:    19-July-2001    JBrezak
//              16-Sept-2001    Updated for the new interface
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include "fileno.h"
#define FILENO FILENO_GETAS
#define KDC_PAC_CHECKSUM        KERB_CHECKSUM_HMAC_MD5


//
// Authdata handler for Win2000 PAC
//

class CADWin2000PAC : public IADHandler, public IADPacSection
{
public:
    CADWin2000PAC() : m_pPacAuth(NULL),
                      m_piPacReq(NULL),
                      m_piCrypt(NULL)
    {
        //  get crypt interface here ....
        //  this can never be NULL
        m_piCrypt = KdcGetICrypt();
    }
    //  cleanup state
    ~CADWin2000PAC()
    {
        MIDL_user_free(m_pPacAuth);
    }
    //  IADHandler implementation
    virtual KERBERR __stdcall Check(
        IN  IKerbRequest    *pIKerbRequest,
        // Tgt server principal.
        IN  IKerbPrincipal  *piTgt,
        IN  PKERB_AUTHORIZATION_DATA pAuthData,
        OUT PKERB_EXT_ERROR pExtendedError);

    virtual KERBERR __stdcall AddToTicket(
        IN  IKerbRequest                *pIKerbRequest,
        OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR pExtendedError);
    virtual ULONG   __stdcall GetADType()
    {
        return  KERB_AUTH_DATA_PAC;
    }
    //  no ref counting. caller is done
    virtual void Release(void)
    {
        delete  this;
    }
    //
    //  support interface returnin raw PAC sections
    //
    virtual HRESULT __stdcall QueryInterface(REFIID intf, PVOID *ppv)
    {
        if (IsEqualGUID(intf, IID_IADPacSection))
        {
            *ppv = (PVOID*)((IADPacSection*)this);
            return  S_OK;
        }
        return  E_NOINTERFACE;
    }

    //  IADPacSection impl
    NTSTATUS __stdcall GetPacSection(ULONG ulPacSection,
                                     const PAC_INFO_BUFFER **pBuf);

private:
    //  keep Pac that came with request
    PPACTYPE m_pPacAuth;
    //  interface for requested PAC sections
    IPAPacReqEx *m_piPacReq;
    //  crypt interface used
    PIKerbCrypt m_piCrypt;

    //  private handler methods
    KERBERR
    KdcVerifyPacSignature(
        IN IKerbRequest   *pReq,
        IN PIKerbPrincipal TgtInfo,
        IN ULONG PacSize,
        IN PUCHAR PacData,
        OUT PKERB_EXT_ERROR pExtendedError
        );
    KERBERR
    KdcSupplyPacAuthData(IN PIKerbRequest piReq,
                         IN PIKerbPrincipal piUser,
                         IN PIKerbPrincipal piTgt,
                         IN PKERB_AUTHORIZATION_DATA OrgIfRelevant,
                         OUT PKERB_AUTHORIZATION_DATA * ppAuthData,
                         OUT PKERB_EXT_ERROR pExtendedError);
    KERBERR
    KdcBuildPac(IN PIKerbRequest   piReq,
                IN PIKerbPrincipal UserInfo,
                IN BOOLEAN IsUpdate,
                IN ULONG SignatureSize,
                OUT PPACTYPE *Pac,
                OUT NTSTATUS *pStatus);
    KERBERR
    GetPacInfo(IN PIKerbRequest            piReq,
               IN PIKerbPrincipal          User,
               IN BOOLEAN                  IsUpdate,
               OUT PPAC_INFO_BUFFER        *pPacData,
               OUT PNTSTATUS                pStatus,
               IN PIPACHandler              piHandler);

};

//
//  Local helpers
//
KERBERR
KdcInsertPacIntoAuthData(
    IN PKERB_AUTHORIZATION_DATA OrgIfRelevant,
    IN PKERB_AUTHORIZATION_DATA PacAuthData,
    IN OUT PKERB_AUTHORIZATION_DATA * UpdatedAuthData
    );
KERBERR
KerbRemovePacFromAuthData(
    IN OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT    PKERB_AUTHORIZATION_DATA *IfRelevantReturn
    );
KERBERR
KdcSignPac(
    IN PIKerbRequest piReq,
    IN PIKerbPrincipal piUser,
    IN OPTIONAL PIKerbPrincipal piServ,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize,
    OUT PKERB_EXT_ERROR pExtendedError
    );

KERBERR
KdcCheckAuthData(
    IN PIKerbPrincipal          TgtInfo,
    IN CKerbRequest             *pReq,
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"KdcCheckAuthData", (PVOID *) &KerbErr);
    IADHandler **ppiAD = pReq->m_ppiADHandlers;
    ULONG cHandlers = KdcADHandlerFactoryList.cElem;

    while(cHandlers-- && *ppiAD)
    {
        //  all handlers perform the check on all auth data
        //  it is up to the handler to locate their auth data
        KerbErr = (*ppiAD)->Check(
                      pReq,
                      TgtInfo,
                      AuthData,
                      pExtendedError
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        ppiAD++;
    }

    return(KerbErr);
}



KERBERR
KdcReturnAuthData(
    IN CKerbRequest              *pReq,
    OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    IADHandler **ppiAD = pReq->m_ppiADHandlers;
    ULONG cHandlers = KdcADHandlerFactoryList.cElem;

    TRACER(L"KdcReturnAuthData", (PVOID *) &KerbErr);

    while(cHandlers-- && *ppiAD)
    {
        //  all handlers perform the check on all auth data
        //  it is up to the handler to locate their auth data
        KerbErr = (*ppiAD)->AddToTicket(
                      pReq,
                      AuthData,
                      pExtendedError
                      );
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        ppiAD++;
    }

    return(KerbErr);
}


//
//  AD factory
//
class CADWin2000PACFactory : public IADHandlerFactory
{
public:
    virtual NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,
        OUT IADHandler     **ppIADHandler)
    {
        //  new and release can be used since these are local allocs
        *ppIADHandler = new CADWin2000PAC;
        if (*ppIADHandler == NULL)
            return  STATUS_NO_MEMORY;
        //  any initialization ???

        return  STATUS_SUCCESS;
    }

}g_ADW2KFactory;

NTSTATUS
KdcInitializeInternalADHandlers(
    VOID
    )
{

    return KdcRegisterADHandlerFactory(&g_ADW2KFactory);
}

//
//  auth data handlers
//
//
//  check auth data
//
KERBERR __stdcall CADWin2000PAC::Check(
        PIKerbRequest       pReq,
        // Tgt server principal.
        IN  IKerbPrincipal  *piTgt,
        IN  PKERB_AUTHORIZATION_DATA pAuthData,
        OUT PKERB_EXT_ERROR pExtendedError)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"CADWin2000PAC::Check", (PVOID *) &KerbErr);
    const KERB_AUTHORIZATION_DATA * PacAuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;

    //  get PAC request interface
    NTSTATUS Status = pReq->GetPAHandler(IID_IPAPacReqEx, (PVOID*)&m_piPacReq);
    if (!NT_SUCCESS(Status))
    {
        //  BUGBUG todo: log/trace. This should not happen ever!
        DsysAssert(FALSE);
        return  KRB_ERR_GENERIC;
    }

    //
    // Locate the PAC in the authdata and retrieve useful context
    //
    if (pAuthData != NULL)
    {

        //
        // Get the PAC from the source ticket's authdata
        //

        KerbErr = KerbGetPacFromAuthData(
                     pAuthData,
                     &IfRelevantData,
                     &PacAuthData
                     );

        if (!KERB_SUCCESS(KerbErr) || PacAuthData == NULL)
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to extract pac from auth data: 0x%x\n",
                      KLIN(FILENO, __LINE__),
                      KerbErr));
            goto Cleanup;
        }
        //
        //  Now verify the existing signature
        //  with Tgt key
        //
        KerbErr = KdcVerifyPacSignature(
                     pReq,
                     piTgt,
                     PacAuthData->value.auth_data.length,
                     PacAuthData->value.auth_data.value,
                     pExtendedError
                     );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


#if 0
        //
        // Perform SID filtering if necessary
        //
        KerbErr = KdcCheckPacForSidFiltering(
                     OldServerInfo,
                     &PacAuthData->value.auth_data.value,
                     (PULONG) &PacAuthData->value.auth_data.length
                     );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
#endif
        //
        //  delete any previous state
        //
        if (m_pPacAuth)
        {
            MIDL_user_free(m_pPacAuth);
            m_pPacAuth = NULL;
        }

        //
        // Save the PAC sections
        //
        m_pPacAuth = (PPACTYPE) MIDL_user_allocate
            (PacAuthData->value.auth_data.length);
        if (m_pPacAuth == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }


        memcpy(
            m_pPacAuth,
            PacAuthData->value.auth_data.value,
            PacAuthData->value.auth_data.length
            );


        if (PAC_UnMarshal(
                m_pPacAuth,
                PacAuthData->value.auth_data.length
            ) == 0)
        {
            D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        D_DebugLog((DEB_TRACE, "Got pac from auth data\n"));



    }


Cleanup:
    if (IfRelevantData)
    {
        KerbFreeData(PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                     IfRelevantData);
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyPacSignature
//
//  Synopsis:   Verifies a PAC by checksumming it and comparing the result
//              with the server checksum. In addition, if the pac wasn't
//              created by another realm (server ticket info is not
//              an interdomain account) verify the KDC signature on the
//              pac.
//
//  Effects:
//
//  Arguments:  ServerInfo - Ticket info for the server, used
//                      for the initial signature
//              Pac - An unmarshalled PAC.
//
//  Requires:
//
//  Returns:
//
//  Notes:      ServerInfo contains the TGT. The code checks the name is indeed
//              krbtgt.
//              Note that the server signature and the KDC signature are the same
//              only server signature is checked.
//
//
//--------------------------------------------------------------------------

KERBERR
CADWin2000PAC::KdcVerifyPacSignature(
    IN IKerbRequest   *pReq,
    IN PIKerbPrincipal TgtInfo,
    IN ULONG PacSize,
    IN PUCHAR PacData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"CADWin2000PAC::KdcVerifyPacSignature", (PVOID *) &KerbErr);
    PPAC_INFO_BUFFER PrivSvrBuffer;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    UCHAR LocalPrivSvrChecksum[20];
    PPACTYPE Pac;
    BOOLEAN fVerified = FALSE;

    TRACE(KDC, KdcVerifyPacSignature, DEB_FUNCTION);

    //
    //  only tgt accepted
    //
    if (!KdcIsKrbtgt(TgtInfo->GetName()))
    {
        KerbErr = KDC_ERR_SERVER_NOMATCH;
        goto Cleanup;
    }

    Pac = (PPACTYPE) PacData;

    if (PAC_UnMarshal(Pac, PacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    //
    // Locate server signature, copy the checksum, and zero the value
    // so the checksum won't include the old checksums.
    //
    PrivSvrBuffer = PAC_Find(Pac, PAC_PRIVSVR_CHECKSUM, NULL );
    if ((PrivSvrBuffer == NULL) || (PrivSvrBuffer->cbBufferSize < PAC_SIGNATURE_SIZE(0)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;

    if (sizeof(LocalPrivSvrChecksum) < PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize))
    {
        //  pretty unlikely but just in case ...
        DsysAssert(FALSE);
        KerbErr = KRB_ERR_GENERIC;
        goto    Cleanup;
    }
    memcpy(
        LocalPrivSvrChecksum,
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    ZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Remarshal the pac so we can checksum it.
    //

    if (!PAC_ReMarshal(Pac, PacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now compute the signatures on the PAC. First we compute the checksum
    // of the validation information using the tgt's key.
    //
    Status = TgtInfo->Checksum(PrivSvrSignature->SignatureType,
                              KERB_NON_KERB_CKSUM_SALT,
                              pReq->GetEncryptionTypes(),
                              &PacData,
                              &PacSize,
                              1,
                              //    chksum buffer to verify against
                              PrivSvrSignature->Signature,
                              PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize),
                              NULL, // don't need the actual chksum
                              NULL,
                              &fVerified,
                              pExtendedError);
    // @@@ uhh, if you really want to verify the checksum, !fVerified would be a good 
    // thing to check. Not doing that now as it breaks the STF tests.
    if (!NT_SUCCESS(Status))
    {
        //  checksumming failed
        if (Status == STATUS_NOT_FOUND)
        {
            KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        }
        else
        {
            //  should we check for a specific errcode here?
            DebugLog((DEB_ERROR, "Pac was modified - server checksum doesn't match\n"));
            KerbErr = KRB_AP_ERR_MODIFIED;
        }
    }


Cleanup:

    if (KerbErr == KRB_AP_ERR_MODIFIED)
    {
        UNICODE_STRING AccountString = {0};
        LPWSTR AccountName = NULL;

        //
        // if the allocation fails don't log the name (leave it NULL)
        //

        if (KERB_SUCCESS(KerbConvertKdcNameToString(
                             &AccountString,
                             TgtInfo->GetName(),
                             TgtInfo->GetRealm())))
        {
            AccountName = (LPWSTR) MIDL_user_allocate(AccountString.Length + sizeof(WCHAR));

            if (NULL != AccountName)
            {
                memcpy(
                    AccountName,
                    AccountString.Buffer,
                    AccountString.Length
                    );
                AccountName[AccountString.Length - 1] = L'\0';
            }
        }

        KdbReportEventW(
            IEvent::ERROR_TYPE,
            KDCEVENT_PAC_VERIFICATION_FAILURE,
            sizeof(ULONG),
            &KerbErr,
            1,
            AccountName == NULL ? L"Failed allocation" : AccountName
            );

        if (NULL != AccountName)
        {
            MIDL_user_free(AccountName);
        }
        KerbFreeString(&AccountString);
    }



    return(KerbErr);
}

//
//  add auth data
//
KERBERR __stdcall CADWin2000PAC::AddToTicket(
        IN  IKerbRequest                *piReq,
        IN OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR pExtendedError)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA    OrgIfRelevant = NULL;
    PIKerbPrincipal piUser = NULL;

    TRACER(L"CADWin2000PAC::AddToTicket", (PVOID *) &KerbErr);

    //
    // Build a PAC -    AS: if preauthenticated and DontIncludePac
    //                  TGS: if present on input and not DontIncludePac or
    //                       not present and there is a client name mapping
    //                       in cname of request.
    //
    if (!m_piPacReq)
    {
        //
        //  get PAC request interface
        //
        NTSTATUS Status = piReq->GetPAHandler(IID_IPAPacReqEx, (PVOID*)&m_piPacReq);
        if (!NT_SUCCESS(Status))
        {
            //  BUGBUG todo: log/trace. This should not happen ever!
            TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to get PAHandler: 0x%x", Status));
            DsysAssert(FALSE);
            return  KRB_ERR_GENERIC;
        }
    }

    if(piReq->GetServId() == KerbTgs)
    {
        //  remove PAC from the output data
        KerbErr = KerbRemovePacFromAuthData(ppAuthData, &OrgIfRelevant);
    }

    if (!m_piPacReq->IsPacRequested())
    {
        return  KDC_ERR_NONE;
    }

    // Check with the principal to see if we should return a PAC
    piUser = piReq->GetIPrincClient();
    if (piUser != NULL && piUser->IsPacRequested() == FALSE) 
    {
        return  KDC_ERR_NONE;
    }

    KerbErr = KdcSupplyPacAuthData(
                 piReq,
                 piUser,
                 piReq->GetIPrincService(),
                 OrgIfRelevant,
                 ppAuthData,
                 pExtendedError
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to get packauth data: 0x%x", KerbErr));
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to get pac auth data : 0x%x\n",
                    KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

Cleanup:
    KerbFreeAuthData(OrgIfRelevant);

    return KerbErr;
}


//+---------------------------------------------------------------------------
//
//  Name:       KdcSupplyPacAuthData
//
//  Synopsis:   Creates a PAC for the specified client, encrypts it with the
//              server's key, and packs it into a KERB_AUTHORIZATON_DATA
//
//  Arguments:  UserInfo - Information about user
//              GroupMembership - Users group memberships
//              ServerKey - Key of server, used for signing
//              CredentialKey - if present & valid, used to encrypt supp. creds
//              AddResourceGroups - if TRUE, resources groups will be included
//              EncryptedTicket - Optional ticke to tie PAC to
//              PacAuthData - Receives a KERB_AUTHORIZATION_DATA of type
//                      KERB_AUTH_DATA_PAC, containing a PAC.
//
//  Notes:      PacAuthData should be freed with KerbFreeAuthorizationData.
//
//+---------------------------------------------------------------------------
KERBERR
CADWin2000PAC::KdcSupplyPacAuthData(
    IN PIKerbRequest piReq,
    IN PIKerbPrincipal piUser,
    IN PIKerbPrincipal piServ,
    IN PKERB_AUTHORIZATION_DATA OrgIfRelevant,
    IN OUT PKERB_AUTHORIZATION_DATA * ppAuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PPACTYPE pNewPac = NULL;
    KERB_AUTHORIZATION_DATA AuthorizationData = {0};
    ULONG PacSize;
    ULONG  cbCheckSize = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACER(L"CADWin2000PAC::KdcSupplyPacAuthData", (PVOID *) &KerbErr);

    Status = m_piCrypt->GetChecksumSize((CTYPE)KDC_PAC_CHECKSUM, &cbCheckSize);
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    KerbErr = KdcBuildPac(
                 piReq,
                 piUser,
                 piReq->GetServId() == KerbTgs,
                 cbCheckSize,            // leave space for signature
                 &pNewPac,
                 &Status);

    if (!KERB_SUCCESS(KerbErr))
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"GetPAC: Can't get PAC or supp creds: 0x%x", KerbErr));
        D_DebugLog(( DEB_WARN,
            "GetPAC: Can't get PAC or supp creds: 0x%x \n", KerbErr ));

        goto Cleanup;
    }

    //
    //  The PAC is going to be double-encrypted.  This is done by having the
    //  PAC in an EncryptedData, and having that EncryptedData in a AuthData
    //  as part of an AuthDataList (along with the rest of the supp creds).
    //  Finally, the entire list is encrypted.
    //
    //      KERB_AUTHORIZATION_DATA containing {
    //              PAC
    //
    //      }
    //

    //
    // First build inner encrypted data
    //

    PacSize = PAC_GetSize(pNewPac);

    //
    //  What if there is nothing to build ?
    //

    if (PacSize == 0)
    {
        goto Cleanup;
    }

    AuthorizationData.value.auth_data_type = KERB_AUTH_DATA_PAC;
    AuthorizationData.value.auth_data.length = PacSize;
    AuthorizationData.value.auth_data.value = (PUCHAR) MIDL_user_allocate(PacSize);
    if (AuthorizationData.value.auth_data.value == NULL)
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"MIDL_user_allocate failed"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PAC_Marshal(pNewPac, PacSize, AuthorizationData.value.auth_data.value);

    //
    // Compute the signatures
    //

    KerbErr = KdcSignPac(
                piReq,
                piUser,
                piServ,
                &AuthorizationData.value.auth_data.value,
                (PULONG) &AuthorizationData.value.auth_data.length,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {

        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to sign PAC: 0x%x", KerbErr));
        goto Cleanup;
    }

    //
    // Create the auth data to return
    //

    KerbErr = KdcInsertPacIntoAuthData(
                    OrgIfRelevant,
                    &AuthorizationData,
                    ppAuthData
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to insert pac into new auth data: 0x%x", KerbErr));
        DebugLog((DEB_ERROR,"Failed to insert pac into new auth data: 0x%x\n",
            KerbErr));
        goto Cleanup;
    }

Cleanup:

    if (AuthorizationData.value.auth_data.value != NULL)
    {
        MIDL_user_free(AuthorizationData.value.auth_data.value);
    }

    if (pNewPac != NULL)
    {
        MIDL_user_free(pNewPac);
    }

    return(KerbErr);

}



//+---------------------------------------------------------------------------
//
//  Name:       KdcBuildPac
//
//  Synopsis:
//
//  Arguments:
//
//  Notes:      This will call the Pac handlers with any previous PAC contents
//              from the ReqContext. The Handlers determine what to do with
//              their existing sections.
//              Note this code assumes internal Core structs are known.
//              To get rid of this dependency, IKerbRequest needs to expose
//              enumeration methods for PAC handlers
//
//+---------------------------------------------------------------------------

KERBERR
CADWin2000PAC::KdcBuildPac(
    IN PIKerbRequest   piReq,
    IN PIKerbPrincipal UserInfo,
    IN BOOLEAN IsUpdate,
    IN ULONG SignatureSize,
    OUT PPACTYPE *Pac,
    OUT NTSTATUS *pStatus
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    PPACTYPE NewPac = NULL;
    PPAC_INFO_BUFFER *PacInfo;
    ULONG NumberOfPacHandlers;
    ULONG PacInfoCount = 0, cPAPacCount = 0;

    TRACE(KDC, KdcBuildPac, DEB_FUNCTION);
    TRACER(L"CADWin2000PAC::KdcBuildPac", (PVOID *) &KerbErr);

    //
    // There are no logon_info PAC structures in the Xbox World
    // 

    cPAPacCount = 0;

    //
    // If no PAC handlers, no PAC and nothing to do
    //

    NumberOfPacHandlers = g_KdcPacHandlerList.cElem;
    if (0 == NumberOfPacHandlers)
    {
        return (KerbErr);
    }

    //
    // Allocate a place to hold the Pac info buffers
    //

    PacInfo = (PPAC_INFO_BUFFER *) MIDL_user_allocate(
        (NumberOfPacHandlers + cPAPacCount) *sizeof(PPAC_INFO_BUFFER)
        );
    if (NULL == PacInfo)
    {
        return (KRB_ERR_GENERIC);
    }

    ZeroMemory(
        PacInfo,
        ((NumberOfPacHandlers + cPAPacCount) * sizeof(PPAC_INFO_BUFFER))
        );

    *Pac = NULL;

    //
    //
    //  Call the Pac handlers to build a PAC
    //  iterate using the internal struct directly
    //  todo: add PAC enum interfaces to IKerbRequest
    //
    g_KdcPacHandlerList.Lock.ReadLock();
    for (PLIST_ENTRY ListEntry = g_KdcPacHandlerList.Head.Flink;
         ListEntry && (ListEntry != &g_KdcPacHandlerList.Head);
         ListEntry = ListEntry->Flink)
    {
        PKDC_LIST_ENTRY HandlerEntry =
            (PKDC_LIST_ENTRY)
            CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);

        // Called holding PAC lock
        KerbErr = GetPacInfo(
            piReq,
            UserInfo,
            IsUpdate,
            //  outgoing PAC
            &PacInfo[PacInfoCount],
            pStatus,
            (IPACHandler*)HandlerEntry->pData
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        if (PacInfo[PacInfoCount])
        {
            //  increment the count only if we got PAC info
            PacInfoCount++;
        }
    }
    g_KdcPacHandlerList.Lock.ReadUnlock();

    //  post-Process PA-With identity pac section
    //  the PAC handler does not know how to assign new pac sections
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Construct the PAC structure
    //

    if (PacInfoCount == 0)
    {
        //
        // No PAC to build; don't return an empty one
        //
        goto Cleanup;
    }

    //  before initilizing the pac, Make sure the extra PAC sections
    //  immediately follow the sections associated with handlers
    //
    if (PacInfoCount < NumberOfPacHandlers)
    {
        //  if a PAC handler did not provide data,
        //  shift all remaining extra PACs
        for (ULONG iPac = 0; iPac < cPAPacCount; iPac++)
        {
            PacInfo[PacInfoCount + iPac] = PacInfo[NumberOfPacHandlers + iPac];
        }
    }

    Status = PAC_Init(
        SignatureSize,
        PacInfoCount + cPAPacCount,
        PacInfo,
        &NewPac
        );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to init pac: 0x%x\n",Status));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    *Pac = NewPac;
    NewPac = NULL;

Cleanup:

    if (PacInfo)
    {
        while (PacInfoCount > 0)
        {
            if (PacInfo[--PacInfoCount] != NULL)
            {
                MIDL_user_free(PacInfo[PacInfoCount]);
            }
        }

        MIDL_user_free(PacInfo);
    }

    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  method:   GetPacInfo
//
//  Synopsis:   Sets up the call for the Pac build handlers
//
//  Effects:
//
//  Arguments:  piReq - kerb request intf
//              User  - user principal interface
//              IsUpdate  - is the PAC being updated
//              PacData - address of the PAC section being updated
//              piHandler - intf pointer for the PAC handler
//
//  Requires:
//
//  Returns:
//
//  Notes:      If PAC sections are to be filtered, it is handled here based
//              on the PA-PAC-REQUEST options.
//
//
//--------------------------------------------------------------------------
KERBERR
CADWin2000PAC::GetPacInfo(
    IN PIKerbRequest            piReq,
    IN PIKerbPrincipal          User,
    IN BOOLEAN                  IsUpdate,
    OUT PPAC_INFO_BUFFER        *pPacData,
    OUT PNTSTATUS               pStatus,
    IN PIPACHandler             piHandler
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"CADWin2000PAC::GetPacInfo", (PVOID *) &KerbErr);
    PPAC_INFO_BUFFER PrevPacInfo = NULL, CopyPacInfo;

    //
    // Check if this PAC section is requested
    //
//    if (!m_piPacReq->IsPacSectionRequested(piHandler->GetPacType()))
//    {
//        //  PAC is not requested with exception of compound identity
//        goto Cleanup;
//    }

    //
    // If previous PAC_INFO for this handler, pass it along
    //

    if (m_pPacAuth)
    {
        //
        //  loop thru the PAC sections instead of calling PAC_Find
        //  we need to accomodate the extra logon info pac sections
        //  which are served by the same logon info handler
        //
        PrevPacInfo = &m_pPacAuth->Buffers[0];
        ULONG iPac;
        for (iPac = 0; iPac < m_pPacAuth->cBuffers; iPac++, PrevPacInfo++)
        {
            ULONG   ulType = PrevPacInfo->ulType;
            if (ulType == piHandler->GetPacType())
            {
                break;
            }
        }

        if (iPac < m_pPacAuth->cBuffers)
        {
            //
            // Copy the data and sent it along. This is freed later
            //

            CopyPacInfo = (PPAC_INFO_BUFFER) MIDL_user_allocate(
                PrevPacInfo->cbBufferSize + sizeof(PAC_INFO_BUFFER)
                );
            if (NULL == CopyPacInfo) 
            {
                KerbErr = KRB_ERR_GENERIC;
                goto    Cleanup;
            }

            CopyPacInfo->Data         = (PBYTE) (CopyPacInfo + 1);
            CopyPacInfo->cbBufferSize = PrevPacInfo->cbBufferSize;
            CopyPacInfo->ulType       = PrevPacInfo->ulType;

            memcpy(
                CopyPacInfo->Data,
                PrevPacInfo->Data,
                PrevPacInfo->cbBufferSize
                );

            *pPacData = CopyPacInfo;
        }
    }

    //
    // Call the build handler
    //
    KerbErr = piHandler->Build(
        piReq,
        IsUpdate,
        pPacData,
        pStatus
        );

Cleanup:
    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcInsertPacIntoAuthData
//
//  Synopsis:   Inserts the PAC into the auth data in the two places
//              it lives - in the IF_RELEVANT portion & in the outer body
//
//  Effects:
//
//  Arguments:  OrgIfRelevant   - IfRelevant data present in the original
//                                ticket minus the PAC
//              PacAuthData     - Pac Auth data
//              UpdatedAuthData - Auth data to update
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcInsertPacIntoAuthData(
    IN PKERB_AUTHORIZATION_DATA OrgIfRelevant,
    IN PKERB_AUTHORIZATION_DATA PacAuthData,
    IN OUT PKERB_AUTHORIZATION_DATA * UpdatedAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"KdcInsertPacIntoAuthData", (PVOID *) &KerbErr);
    PKERB_AUTHORIZATION_DATA LocalAuthData = NULL;
    PKERB_AUTHORIZATION_DATA LocalIfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA NewIfRelevantData = NULL;
    KERB_AUTHORIZATION_DATA TempPacData = {0};
    KERB_AUTHORIZATION_DATA TempOldPac = {0};

    if (UpdatedAuthData == NULL)
    {
        return  KRB_ERR_GENERIC;
    }

    NewIfRelevantData = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));
    if (NewIfRelevantData == NULL)
    {
        return  KRB_ERR_GENERIC;
    }

    ZeroMemory(
        NewIfRelevantData,
        sizeof(KERB_AUTHORIZATION_DATA)
        );

    //
    // First build the IfRelevantData
    //
    // The general idea is to replace, in line, the relevant authorization
    // data. This means (a) putting it into the IfRelevantData or making
    // the IfRelevantData be PacAuthData, and (b) putting it into AuthData
    // as well as changing the IfRelevant portions of that data
    //

    if (OrgIfRelevant != NULL)
    {
        LocalAuthData = const_cast<KERB_AUTHORIZATION_DATA*>(
                            KerbFindAuthDataEntry(
                                KERB_AUTH_DATA_PAC,
                                OrgIfRelevant
                                ));

        if (LocalAuthData == NULL)
        {
            LocalIfRelevantData = PacAuthData;
            PacAuthData->next = OrgIfRelevant;
        }
        else
        {
            //
            // Replace the pac in the if-relevant list with the
            // new one.
            //

            TempOldPac = *LocalAuthData;
            LocalAuthData->value.auth_data.value = PacAuthData->value.auth_data.value;
            LocalAuthData->value.auth_data.length = PacAuthData->value.auth_data.length;

            LocalIfRelevantData = OrgIfRelevant;
        }
    }
    else
    {
        //
        // build a new if-relevant data
        //

        TempPacData = *PacAuthData;
        TempPacData.next = NULL;
        LocalIfRelevantData = &TempPacData;
    }

    //
    // Build a local if-relevant auth data
    //

    KerbErr = KerbPackData(
                  &LocalIfRelevantData,
                  PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                  (PULONG) &NewIfRelevantData->value.auth_data.length,
                  &NewIfRelevantData->value.auth_data.value
                  );

    //
    // fixup the old if-relevant list, if necessary
    //

    if (TempOldPac.value.auth_data.value != NULL)
    {
        *LocalAuthData = TempOldPac;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    NewIfRelevantData->value.auth_data_type = KERB_AUTH_DATA_IF_RELEVANT;


    //
    // form the list
    //
    NewIfRelevantData->next = *UpdatedAuthData;
    *UpdatedAuthData = NewIfRelevantData;

    //  clear the ptr so it does not get freed
    NewIfRelevantData = NULL;

Cleanup:


    if (NewIfRelevantData != NULL)
    {
        KerbFreeAuthData(NewIfRelevantData);
    }

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcSignPac
//
//  Synopsis:   Signs a PAC by first checksumming it with the
//              server's key and then signing that with the KDC key.
//
//  Effects:    Modifies the server sig & privsvr sig fields of the PAC
//
//  Arguments:  ServerKey - used for server signature
//              KdcKey - used for Kdc signature. If not present, the tgt for
//                      the realm will be looked up and the KDC_PAC_KEYTYPE
//                      will be used.
//              PacData - An marshalled PAC.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcSignPac(
    IN PIKerbRequest piReq,
    IN PIKerbPrincipal piUser,
    IN OPTIONAL PIKerbPrincipal piServ,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PPAC_INFO_BUFFER PrivSvrBuffer;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    PPACTYPE Pac;
    ULONG LocalPacSize;
    //  depending on the request, interpret the
    //  principals. in AS req. Tgt is the service, otherwise
    //  it is  the client
    PIKerbPrincipal piTgt = piReq->GetServId() == KerbTgs ?
        piUser : piServ;

    TRACER(L"KdcSignPac", (PVOID *) &KerbErr);

    //
    // Unmarshal the PAC in place so we can locate the signature buffers
    //

    Pac = (PPACTYPE) *PacData;
    LocalPacSize = *PacSize;
    if (PAC_UnMarshal(Pac, LocalPacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to unmarshal pac: 0x%x", KerbErr));
        goto Cleanup;
    }


    //
    // Locate the signature buffers so the signature fields can be zeroed out
    // before computing the checksum.
    //

    PrivSvrBuffer = PAC_Find(Pac, PAC_PRIVSVR_CHECKSUM, NULL );
    DsysAssert(PrivSvrBuffer != NULL);
    if (PrivSvrBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;
    PrivSvrSignature->SignatureType = (ULONG) KDC_PAC_CHECKSUM;

    ZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Now remarshall the PAC to compute the checksum.
    //

    if (!PAC_ReMarshal(Pac, LocalPacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"PAC_Remarshal Failed: 0x%x", KerbErr));
        goto Cleanup;
    }

    //
    // Compute the checksum of the server checksum using the KDC account.
    //

    if (piTgt)
    {
        ULONG cbSize = PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize);
        Status = piTgt->Checksum( (CTYPE)KDC_PAC_CHECKSUM,
                                  KERB_NON_KERB_CKSUM_SALT,
                                  piReq->GetEncryptionTypes(),
                                  (PBYTE*)&Pac,
                                  &LocalPacSize,
                                  1,    // 1 buf
                                  NULL, // nothing to verify
                                  NULL,
                                  // again: should not allocate!
                                  PrivSvrSignature->Signature,
                                  &cbSize,
                                  NULL,
                                  pExtendedError);

        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to compute checksum: 0x%x", Status));
            goto Cleanup;
        }
    }

    if (*PacData != (PBYTE) Pac)
    {
        MIDL_user_free(*PacData);
        *PacData = (PBYTE) Pac;
        *PacSize = LocalPacSize;
    }

Cleanup:

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRemovePacFromAuthData
//
//  Synopsis:   Remove the PAC from the auth data list
//
//  Effects:
//
//  Arguments:  AuthData    -   [in/out] auth data to process
//              IfRelevantReturn -  [out]
//          ifrelevant data containing auth data different than pac
//
//  Requires:
//
//  Returns:
//
//  Notes:  PAC is removed from all if-relevant data. The first If-relevant
//          data containing something other than PAC is returned.
//          the caller is responsible for freeing the returned data
//
//          More if-relevant data elements containing a PAC are unlinked alltogether
//
//
//--------------------------------------------------------------------------

KERBERR
KerbRemovePacFromAuthData(
    IN OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT    PKERB_AUTHORIZATION_DATA *IfRelevantReturn
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"KerbRemovePacFromAuthData", (PVOID *) &KerbErr);
    PKERB_AUTHORIZATION_DATA RelevantAuthData = NULL;
    PKERB_AUTHORIZATION_DATA PrevAuthData = NULL;

    if (IfRelevantReturn != NULL)
    {
        *IfRelevantReturn = NULL;
    }


    RelevantAuthData = *AuthData;

    //  default return if all nodes get unlinked
    *AuthData = NULL;

    //
    // Loop searching for if-relevantor pac data
    //
    while (RelevantAuthData != NULL)
    {
        PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;
        const KERB_AUTHORIZATION_DATA * PacAuthData = NULL;
        if (RelevantAuthData->value.auth_data_type == KERB_AUTH_DATA_IF_RELEVANT)
        {
            //  process if relevant
            //
            // Unpack it
            //

            KerbErr = KerbUnpackData(
                        RelevantAuthData->value.auth_data.value,
                        RelevantAuthData->value.auth_data.length,
                        PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                        (PVOID *) &IfRelevantData
                        );

            if (KERB_SUCCESS(KerbErr))
            {
                //
                // Look for the PAC in the if-relevant data
                //

                PacAuthData = KerbFindAuthDataEntry(
                                  KERB_AUTH_DATA_PAC,
                                  *IfRelevantData
                                  );
            }
            else
            {
                //
                // We don't mind if we couldn't unpack it.
                // Tickets do not always have PAC information.
                //

                KerbErr = KDC_ERR_NONE;
            }

            if (PacAuthData != NULL)
            {
                if (IfRelevantReturn != NULL &&
                    *IfRelevantReturn == NULL &&
                    (*IfRelevantData)->next != NULL)
                {
                    //  if we have not stored if-relevant AND
                    //  the if-relevant entry containing the PAC has other entries
                    //  preserve the rest of the entries
                    KerbErr = KerbCopyAndAppendAuthData(IfRelevantReturn,
                                                        *IfRelevantData);

                    //  and remove the PAC from the data that was copied
                    if (KERB_SUCCESS(KerbErr))
                    {
                        KerbErr = KerbRemovePacFromAuthData(IfRelevantReturn, NULL);
                    }

                    if (!KERB_SUCCESS(KerbErr)){
                        goto    Cleanup;
                    }
                }

                //  the unpacked struct
                KerbFreeData(
                    PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                    IfRelevantData
                    );

                //
                // Unlink the if-relevant and free it
                //
                if (PrevAuthData != NULL)
                {
                    //  element in the middle
                    PrevAuthData->next = RelevantAuthData->next;
                    RelevantAuthData->next = NULL;
                    KerbFreeAuthData(RelevantAuthData);
                    RelevantAuthData = PrevAuthData->next;
                }
                else
                {
                    //  first element
                    PrevAuthData = RelevantAuthData->next;
                    RelevantAuthData->next = NULL;
                    KerbFreeAuthData(RelevantAuthData);
                    RelevantAuthData = PrevAuthData;
                    PrevAuthData = NULL;
                }


                continue;
            }
            else if (IfRelevantData)
            {

                //  just free the unpacked struct and go on
                KerbFreeData(
                    PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                    IfRelevantData
                    );
            }

        }
        else if (RelevantAuthData->value.auth_data_type == KERB_AUTH_DATA_PAC)
        {
            //  old style auth data
            //
            // Unlink the pac authdata (if not part of the if-relevant)
            //
            // NOTE: Prior to Win2000 Beta3

            if (PrevAuthData != NULL)
            {
                //  element in the middle
                PrevAuthData->next = RelevantAuthData->next;
                RelevantAuthData->next = NULL;
                KerbFreeAuthData(RelevantAuthData);
                RelevantAuthData = PrevAuthData->next;
            }
            else
            {
                //  first element
                PrevAuthData = RelevantAuthData->next;
                RelevantAuthData->next = NULL;
                KerbFreeAuthData(RelevantAuthData);
                RelevantAuthData = PrevAuthData;
                PrevAuthData = NULL;
            }


            continue;
        }

        //  neiter relevant with pac nor pac were found - preserve the auth data
        //  if not initialized
        if (*AuthData == NULL)
        {
            *AuthData = RelevantAuthData;
        }

        //  move to the next
        PrevAuthData = RelevantAuthData;
        RelevantAuthData = RelevantAuthData->next;
    }


Cleanup:
    if (!KERB_SUCCESS(KerbErr) &&
        IfRelevantReturn)
    {
        KerbFreeAuthData(*IfRelevantReturn);
    }

    return(KerbErr);
}

//
//  create a handler instance outside the context of the request
//
NTSTATUS
__stdcall
KdcCreateADHandlerInstance(
    IN  ADDATA_TYPE     ADType,
    OUT IADHandler   ** ppIADHandler
    )
{
    PLIST_ENTRY ListEntry;
    NTSTATUS    Status = STATUS_NOT_FOUND;
    TRACER(L"KdcCreateADHandlerInstance", (PVOID *) &Status);
    KdcADHandlerFactoryList.Lock.ReadLock();
    for (ListEntry = KdcADHandlerFactoryList.Head.Flink;
         ListEntry && (ListEntry != &KdcADHandlerFactoryList.Head);
         ListEntry = ListEntry->Flink)
    {
        //  real ugly. create an instance, check the type
        //  and if no match, release the instance
        //  fortuately we have just 1 handler
        IADHandler  *piAD;
        PKDC_LIST_ENTRY pHandlerEntry =
            (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);

        Status = ((IADHandlerFactory*)pHandlerEntry->pData)->
                CreateInstance(NULL, &piAD);
        if (Status != STATUS_SUCCESS)
            break;
        if (piAD->GetADType() == (ULONG)ADType)
        {
            *ppIADHandler = piAD;
            break;
        }
        //  no match ...
        piAD->Release();
        Status = STATUS_NOT_FOUND;
    }
    KdcADHandlerFactoryList.Lock.ReadUnlock();

    return  Status;
}

//
//  IADPacSection method impl.
//  search for the request pac section and return it
//  to the caller
//
NTSTATUS
__stdcall
CADWin2000PAC::GetPacSection(
    IN ULONG ulPacSection,
    OUT const PAC_INFO_BUFFER **ppRetBuf
    )
{
    if (m_pPacAuth)
    {
        PPAC_INFO_BUFFER pBuf = PAC_Find(m_pPacAuth, ulPacSection, NULL);
        if (pBuf)
        {
            *ppRetBuf = pBuf;
            return  STATUS_SUCCESS;
        }
    }
    return  STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\authdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       authdata.h
//
//  Contents:   KDC authdata function interfaces
//
//  Classes:
//
//  Functions:
//
//  History:    19-July-2001    JBrezak
//              12-Sept-2001    yordanr - modified for new interface
//
//----------------------------------------------------------------------------

#ifndef _AUTHDATA_H_
#define _AUTHDATA_H_

KERBERR
KdcCheckAuthData(
    IN PIKerbPrincipal          pTgtInfo,
    IN CKerbRequest             *pReq,
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_EXT_ERROR pExtendedError);


KERBERR
KdcReturnAuthData(
    IN CKerbRequest              *pReq,
    OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    );


NTSTATUS
KdcInitializeInternalADHandlers(
    VOID
    );

typedef KERBERR (*KDC_AD_ITERATE_FN) (
    IN PIKdbProvider            piKdb,
    IN KERB_SERVICE_ID          Service,
    IN PIKerbPrincipal              ClientInfo,
    IN PIKerbPrincipal              ServerInfo,
    IN PKERB_KDC_REQUEST_BODY   RequestBody,
    IN CONST ULONG              PreAuthType,
    IN PKERB_ENCRYPTION_KEY     SessionKey,
    IN OUT PKERB_ENCRYPTED_TICKET EncryptedTicket,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN  CKerbRequest*            pKerbReq,
    IN PIADHandler              Handler,
    IN OUT PVOID                Data
    );

KERBERR
KdcIterateAuthDataHandler(
    IN PIKdbProvider            piKdb,
    IN KERB_SERVICE_ID          Service,
    IN PIKerbPrincipal              ClientInfo,
    IN PIKerbPrincipal              ServerInfo,
    IN PKERB_KDC_REQUEST_BODY   RequestBody,
    IN CONST ULONG              PreAuthType,
    IN PKERB_ENCRYPTION_KEY     SessionKey,
    IN OUT PKERB_ENCRYPTED_TICKET EncryptedTicket,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN  CKerbRequest*            pKerbReq,
    IN KDC_AD_ITERATE_FN        Func,
    IN OUT PVOID                Data
    );

#endif // _AUTHDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\config.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Config.h

Abstract:

    This header file defines the function prototypes of the temporary
    helper routines to get configuration information from the NT
    configuration files.

Author:

    Rita Wong (ritaw) 22-May-1991

Environment:

    Only runs under NT.

Notes:

    You must include the following before this file:

            windef.h OR windows.h  // Win32 type definitions

Revision History:

    22-May-1991 RitaW
        Created.
    27-Nov-1991 JohnRo
        Prepare for revised config handlers.  Added revision history.
    08-Jan-1992 JohnRo
        Added SECT_NT_REPLICATOR.
    13-Feb-1992 JohnRo
        Moved section name equates to <confname.h>.
        Include <netdebug.h> and <lmcons.h> here instead of everywhere else.
        Added NetpDbgDisplayConfigSection().
        Added NetpDeleteConfigKeyword() and NetpNumberOfConfigKeywords().
        Added Netp{Get,Set}Config{Bool,Dword}.
    14-Mar-1992 JohnRo
        Get rid of old config helper callers.
    23-Mar-1992 JohnRo
        Get rid of old config helpers.
    08-May-1992 JohnRo
        Add LPTSTR array routines.
    08-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
    25-Feb-1993 JohnRo
        RAID 12914: avoid double close and free mem in NetpCloseConfigData().
    07-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/


#ifndef CONFIG_H
#define CONFIG_H


#include <lmcons.h>     // NET_API_STATUS.
#include "netdebug.h"   // LPDEBUG_STRING.
#include "strarray.h"   // LPTSTR_ARRAY.


//
// Opaque pointer for net config handles.  (The real structure is in ConfigP.h,
// and should only be used by NetLib routines.)
//
typedef LPVOID LPNET_CONFIG_HANDLE;


//
// Note that the routines in this file only accept the SECT_NT_ versions.
// See <confname.h> for more details.
//


// NetpOpenConfigData opens the Paramaters section of a given service.
NET_API_STATUS WINAPI
NetpOpenConfigData(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN BOOL ReadOnly
    );

// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    );

// NetpOpenConfigData opens the Paramaters section of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPath(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN BOOL ReadOnly
    );

// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPathEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    );

// Delete a keyword and its value.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpDeleteConfigKeyword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword
    );

NET_API_STATUS
NetpExpandConfigString(
    IN  LPCTSTR  UncServerName OPTIONAL,
    IN  LPCTSTR  UnexpandedString,
    OUT LPTSTR * ValueBufferPtr         // Must be freed by NetApiBufferFree().
    );

// If NetpOpenConfigData fails, try calling NetpHandleConfigFailure to decide
// what to do about it.
NET_API_STATUS
NetpHandleConfigFailure(
    IN LPDEBUG_STRING DebugName,        // Name of routine.
    IN NET_API_STATUS ApiStatus,        // NetpOpenConfigData's error code.
    IN LPTSTR ServerNameValue OPTIONAL,
    OUT LPBOOL TryDownlevel
    );

// Get a boolean value.  Return ERROR_INVALID_DATA if value isn't boolean.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigBool (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN BOOL DefaultValue,
    OUT LPBOOL ValueBuffer
    );

// Get an unsigned numeric value.  Return ERROR_INVALID_DATA if value isn't
// numeric.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigDword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN DWORD DefaultValue,
    OUT LPDWORD ValueBuffer
    );

// Return null-null array of strings.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS WINAPI
NetpGetConfigTStrArray(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR_ARRAY * ValueBuffer      // Must be freed by NetApiBufferFree().
    );

// Return string value for a given keyword.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigValue (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR * ValueBuffer            // Must be freed by NetApiBufferFree().
    );

NET_API_STATUS
NetpEnumConfigSectionValues(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPTSTR * KeywordBuffer,         // Must be freed by NetApiBufferFree().
    OUT LPTSTR * ValueBuffer,           // Must be freed by NetApiBufferFree().
    IN BOOL FirstTime
    );

NET_API_STATUS
NetpNumberOfConfigKeywords (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPDWORD Count
    );

NET_API_STATUS
NetpSetConfigValue(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN LPTSTR Value
    );

NET_API_STATUS WINAPI
NetpCloseConfigData(
    IN OUT LPNET_CONFIG_HANDLE ConfigHandle
    );


#endif // ndef CONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\debug.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       debug.cxx
//
//  Contents:   Debug definitions that shouldn't be necessary
//              in the retail build.
//
//  History:    19-Nov-92 WadeR     Created
//
//  Notes:      If you change or add a debug level, also fix debug.hxx
//              This is only compiled if DBG > 0
//
//--------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "debug.hxx"
#include <tostring.hxx>



//
// The "#pragma hdrstop" causes the preprocessor to forget any "#if"s
// is is processing.  Therefore you can't have it inside an "#if" block.
// So the includes will always compile, and the rest of this code becomes
// conditional.
//


#include <stddef.h>


//
// Variables for heap checking and used by sectrace.hxx:
//

// Set following to HEAP_CHECK_ON_ENTER | HEAP_CHECK_ON_EXIT for heap checking.
DWORD dwHeapChecking = 0;

// This keeps a registry key handle to the HKLM\System\CCSet\Control\LSA\
// Kerberoskey
HKEY hKerbParams = NULL; 
HANDLE hKerbWait = NULL;

//
// Tons and tons of global data to get debugging params from the ini file.
//
// Note: For every trace bit, there must be a label in this array matching
//       that trace bit and only that trace bit.  There can be other labels
//       matching combinations of trace bits.
//

DEBUG_KEY   KdcDebugKeys[] = {  {DEB_ERROR,     "Error"},
                                {DEB_WARN,      "Warning"},
                                {DEB_TRACE,     "Trace"},
                                {DEB_T_KDC,     "Kdc"},
                                {DEB_T_TICKETS, "Tickets"},
                                {DEB_T_DOMAIN,  "Domain"},
                                {DEB_T_SOCK,    "Sock"},
                                {DEB_T_TRANSIT, "Transit"},
                                {DEB_T_PERF_STATS, "Perf"},
                                {DEB_T_PKI, "PKI"},
                                {0, NULL},
                            };



DEFINE_DEBUG2(KDC);
extern DWORD KSuppInfoLevel; // needed to adjust values for common2 dir


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbGetKerbRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry 
//
//  Arguments:  HKEY to HKLM/System/CCS/LSA/Kerberos
//
//  Notes:      Sets KDCInfolevel for debug spew
//
void
KerbGetKerbRegParams(HKEY ParamKey)
{

    DWORD       cbType, tmpInfoLevel = KDCInfoLevel, cbSize = sizeof(DWORD);
    DWORD       dwErr;
 
    dwErr = RegQueryValueExW(
        ParamKey,
        WSZ_DEBUGLEVEL,
        NULL,
        &cbType,
        (LPBYTE)&tmpInfoLevel,
        &cbSize      
        );
    if (dwErr != ERROR_SUCCESS)
    {
        if (dwErr ==  ERROR_FILE_NOT_FOUND)
        {
            // no registry value is present, don't want info
            // so reset to defaults


            // NOTE:  Since SCLogon sux so badly, we're going to log all PKI events for now.
            // FESTER:  Pull for server B3.


#if DBG

            KSuppInfoLevel = KDCInfoLevel = DEB_ERROR | DEB_T_PKI;
            
#else // fre
            KSuppInfoLevel = KDCInfoLevel = DEB_T_PKI;
#endif
        }else{
            DebugLog((DEB_WARN, "Failed to query DebugLevel: 0x%x\n", dwErr));        
        }      

        
    }

    // TBD:  Validate flags?
                      
    KSuppInfoLevel = KDCInfoLevel = tmpInfoLevel;
    
    return;
}

//
// Tempo?
//
/*void FillExtError(PKERB_EXT_ERROR p,NTSTATUS s,ULONG f,ULONG l) 
{                                                               
   if (EXT_ERROR_ON(KDCInfoLevel))                                                  \
   {                                                            
      p->status = s;                                            
      p->klininfo = KLIN(f,l);                                  
   }                                                            
                                                                
   sprintf(xx, "XX File-%i, Line-%i", f,l);                   
   OutputDebugStringA(xx);                                      
                                                                 
} */



////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchKerbParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
NTAPI
KerbWatchKerbParamKey(PVOID    pCtxt,
                  BOOLEAN  fWaitStatus)
{
       
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
   
    if (NULL == hKerbParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Services\\Kdc\\Parameters",
                    0,
                    KEY_READ,
                    &hKerbParams);
 
        if (ERROR_SUCCESS != lRes)
        {
            DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != hKerbWait) 
    {
        Status = UnregisterWait(hKerbWait);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }

    lRes = RegNotifyChangeKeyValue(
                hKerbParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes) 
    {
        DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }
                   
    KerbGetKerbRegParams(hKerbParams);
    
Reregister:
    
    Status = RegisterWaitForSingleObject(&hKerbWait,
                             (HANDLE) pCtxt,
                             KerbWatchKerbParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEONLYONCE);
}

////////////////////////////////////////////////////////////////////
//
//  Name:       WaitKerbCleanup
//
//  Synopsis:   Cleans up for KerbWatchKerbParamKey
//
//  Arguments:  <none>
//
//  Notes:      .
//
VOID 
WaitKerbCleanup(HANDLE hEvent)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (NULL != hKerbWait) {
        Status = UnregisterWait(hKerbWait);
        hKerbWait = NULL;
    }

    if (NT_SUCCESS(Status) && NULL != hEvent) {
        CloseHandle(hEvent);
        hEvent = NULL;
    }
}
        


////////////////////////////////////////////////////////////////////
//
//  Name:       GetDebugParams
//
//  Synopsis:   Gets the debug paramaters from the ini file.
//
//  Arguments:  <none>
//
//  Notes:      .
//
void
GetDebugParams()
{
    KDCInitDebug(KdcDebugKeys);
}


#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   PrintIntervalTime
//
//  Synopsis:   
//
//  Arguments:  [DebugFlag] -- 
//              [Message]   -- 
//              [Interval]  -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

void 
PrintIntervalTime (
    ULONG DebugFlag,
    LPSTR Message,
    PLARGE_INTEGER Interval )
{
    LONGLONG llTime = Interval->QuadPart;
    LONG lSeconds = (LONG) ( llTime / 10000000 );
    LONG lMinutes = ( lSeconds / 60 ) % 60;
    LONG lHours = ( lSeconds / 3600 );
    DebugLog(( DebugFlag, "%s %d:%2.2d:%2.2d \n", Message, lHours, lMinutes, lSeconds % 60 ));
}

//+---------------------------------------------------------------------------
//
//  Function:   PrintTime
//
//  Synopsis:   
//
//  Arguments:  [DebugFlag] -- 
//              [Message]   -- 
//              [Time]      -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

void 
PrintTime (
    ULONG DebugFlag,
    LPSTR Message,
    PLARGE_INTEGER Time )
{
    SYSTEMTIME st;

    FileTimeToSystemTime ( (PFILETIME) Time, & st );
    DebugLog((DebugFlag, "%s %d-%d-%d %d:%2.2d:%2.2d\n", Message, st.wMonth, st.wDay, st.wYear,
                st.wHour, st.wMinute, st.wSecond ));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\crypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

    Scott Field (SField)    09-October-2000
        Add RNG and Memory encryption interfaces

--*/


#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)


//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH


//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH



#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035

#define RtlGenRandom                    SystemFunction036
#define RtlEncryptMemory                SystemFunction040
#define RtlDecryptMemory                SystemFunction041


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS 
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS NTAPI
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );

BOOLEAN
RtlGenRandom(
    OUT PVOID RandomBuffer,
    IN  ULONG RandomBufferLength
    );


//
// The buffer passed into RtlEncryptMemory and RtlDecryptMemory
// must be a multiple of this length.
//

#define RTL_ENCRYPT_MEMORY_SIZE 8

//
// Allow Encrypt/Decrypt across process boundaries.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory.
//

#define RTL_ENCRYPT_OPTION_CROSS_PROCESS    0x01


NTSTATUS
RtlEncryptMemory(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

NTSTATUS
RtlDecryptMemory(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\fileno.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fileno.h
//
//  Stolen from DS line number obfuscation macros
//
//--------------------------------------------------------------------------

//
// fileno.h - defines symbolic constants  for kerberos c code
// files. File numbers are 16 bit values. The high byte is the directory number and
// the low byte is the file number within the directory.
//

// Why not make the macro have just one arg, since line is always
// __LINE__?  Because if we did then __LINE__ would be evaluated here,
// rather than at the invocation of the macro, and so would always
// have the value 11.
#define KLIN(fileno,line) (((fileno) << 16) | (line))

//
//  *** NOTE: ***
//
//  If you add FILENO_*'s to this list, be sure to make a corresponding update
//  to kerberos\utest\klin.c so that dsid.exe can properly decode the DSID
//  corresponding to the new file.
//
//  If you add DIRNO_*'s to this list, be sure to make a corresponding update
//  to ds\src\dscommon\dsvent.c - rEventSourceMappings[].
//

// define directory numbers

#define DIRNO_CLIENT2   (0)                             // \client2
#define DIRNO_COMMON2   (1 << 8)                        // \common2
#define DIRNO_KERNEL    (2 << 8)                        // \kernel
#define DIRNO_RTL       (3 << 8)                        // \rtl
#define DIRNO_SERVER    (4 << 8)                        // \server
#define DIRNO_KDB	(5 << 8)			// \server\layers

// client2 directory
#define FILENO_BNDCACHE         (DIRNO_CLIENT2 + 0)      // bndcache.cxx
#define FILENO_CREDAPI          (DIRNO_CLIENT2 + 1)      // credapi.cxx
#define FILENO_CREDMGR          (DIRNO_CLIENT2 + 2)      // credmgr.cxx
#define FILENO_CTXTAPI          (DIRNO_CLIENT2 + 3)      // ctxtapi.cxx
#define FILENO_CTXTMGR          (DIRNO_CLIENT2 + 4)      // ctxtmgr.cxx
#define FILENO_GSSUTIL          (DIRNO_CLIENT2 + 5)      // gssutil.cxx
#define FILENO_KERBEROS         (DIRNO_CLIENT2 + 6)      // kerberos.cxx
#define FILENO_KERBLIST         (DIRNO_CLIENT2 + 7)      // kerblist.cxx
#define FILENO_KERBPASS         (DIRNO_CLIENT2 + 8)      // kerbpass.cxx
#define FILENO_KERBTICK         (DIRNO_CLIENT2 + 9)      // kerbtick.cxx
#define FILENO_KERBUTIL         (DIRNO_CLIENT2 + 10)     // kerbutil.cxx
#define FILENO_KERBWOW          (DIRNO_CLIENT2 + 11)     // kerbwow.cxx
#define FILENO_KRBEVENT         (DIRNO_CLIENT2 + 12)     // krbevent.cxx
#define FILENO_KRBTOKEN         (DIRNO_CLIENT2 + 13)     // krbtoken.cxx
#define FILENO_LOGONAPI         (DIRNO_CLIENT2 + 14)     // logonapi.cxx
#define FILENO_MISCAPI          (DIRNO_CLIENT2 + 15)     // miscapi.cxx
#define FILENO_MITUTIL          (DIRNO_CLIENT2 + 16)     // mitutil.cxx
#define FILENO_PKAUTH           (DIRNO_CLIENT2 + 17)     // pkauth.cxx
#define FILENO_PROXYAPI         (DIRNO_CLIENT2 + 18)     // proxyapi.cxx
#define FILENO_RPCUTIL          (DIRNO_CLIENT2 + 19)     // rpcutil.cxx
#define FILENO_SIDCACHE         (DIRNO_CLIENT2 + 20)     // sidcache.cxx
#define FILENO_TIMESYNC         (DIRNO_CLIENT2 + 21)     // timesync.cxx
#define FILENO_TKTCACHE         (DIRNO_CLIENT2 + 22)     // tktcache.cxx
#define FILENO_TKTLOGON         (DIRNO_CLIENT2 + 23)     // tktlogon.cxx
#define FILENO_USERAPI          (DIRNO_CLIENT2 + 24)     // userapi.cxx
#define FILENO_USERLIST         (DIRNO_CLIENT2 + 25)     // userlist.cxx
                       
// common2 directory
#define FILENO_AUTHEN           (DIRNO_COMMON2 + 0)       // authen.cxx
#define FILENO_CRYPT            (DIRNO_COMMON2 + 1)       // crypt.c
#define FILENO_KEYGEN           (DIRNO_COMMON2 + 2)       // keygen.c
#define FILENO_KRB5             (DIRNO_COMMON2 + 3)       // krb5.c
#define FILENO_NAMES            (DIRNO_COMMON2 + 4)       // names.cxx
#define FILENO_PASSWD           (DIRNO_COMMON2 + 5)       // passwd.c
#define FILENO_RESTRICT         (DIRNO_COMMON2 + 6)       // restrict.cxx
#define FILENO_SOCKETS          (DIRNO_COMMON2 + 7)       // sockets.cxx
#define FILENO_TICKETS          (DIRNO_COMMON2 + 8)       // tickets.cxx


// kernel directory
#define FILENO_CPGSSUTL            (DIRNO_KERNEL + 0)         // cpgssutl.cxx
#define FILENO_CTXTMGR2            (DIRNO_KERNEL + 1)         // ctxtmgr.cxx
#define FILENO_KERBLIST2           (DIRNO_KERNEL + 2)         // kerblist.cxx
#define FILENO_KRNLAPI             (DIRNO_KERNEL + 3)         // krnlapi.cxxc

// RTL directory       
#define FILENO_AUTHDATA         (DIRNO_RTL + 0)     // authdata.cxx
#define FILENO_CRACKPAC         (DIRNO_RTL + 1)     // crackpac.cxx
#define FILENO_CRED             (DIRNO_RTL + 2)     // cred.cxx
#define FILENO_CREDLIST         (DIRNO_RTL + 3)     // credlist.cxx
#define FILENO_CREDLOCK         (DIRNO_RTL + 4)     // credlock.cxx
#define FILENO_DBUTIL           (DIRNO_RTL + 5)     // dbutil.cxx
#define FILENO_DBOPEN           (DIRNO_RTL + 6)     // domain.cxx
#define FILENO_DOMCACHE         (DIRNO_RTL + 7)     // domcache.cxx
#define FILENO_FILTER           (DIRNO_RTL + 8)     // filter.cxx
#define FILENO_MAPERR           (DIRNO_RTL + 9)     // maperr.cxx
#define FILENO_MAPSECER         (DIRNO_RTL + 10)    // mapsecerr.cxx
#define FILENO_MISCID           (DIRNO_RTL + 11)    // miscid.cxx
#define FILENO_PAC              (DIRNO_RTL + 12)    // pac.cxx
#define FILENO_PAC2             (DIRNO_RTL + 13)    // pac2.cxx
#define FILENO_PARMCHK          (DIRNO_RTL + 14)    // parmchk.cxx
#define FILENO_REG	            (DIRNO_RTL + 15)    // reg.cxx
#define FILENO_SECSTR           (DIRNO_RTL + 16)    // secstr.cxx
#define FILENO_SERVICES         (DIRNO_RTL + 17)    // services.c
#define FILENO_STRING           (DIRNO_RTL + 18)    // string.cxx
#define FILENO_TIMESERV         (DIRNO_RTL + 19)    // timeserv.cxx
#define FILENO_TOKENUTL         (DIRNO_RTL + 20)    // tokenutl.cxx
#define FILENO_TRNSPORT         (DIRNO_RTL + 21)    // trnsport.cxx

// Server directory       
#define FILENO_DEBUG            (DIRNO_SERVER + 0)     // debug.cxx
#define FILENO_DGUTIL           (DIRNO_SERVER + 1)     // dgutil.cxx
#define FILENO_EVENTS           (DIRNO_SERVER + 2)     // events.cxx
#define FILENO_GETAS            (DIRNO_SERVER + 3)     // getas.cxx
#define FILENO_GETTGS           (DIRNO_SERVER + 4)     // gettgs.cxx
#define FILENO_KDC              (DIRNO_SERVER + 5)     // kdc.cxx
#define FILENO_KDCTRACE         (DIRNO_SERVER + 6)     // kdctrace.cxx
#define FILENO_KPASSWD          (DIRNO_SERVER + 7)     // kpasswd.cxx
#define FILENO_NOTIFY2          (DIRNO_SERVER + 8)     // notify2.cxx
#define FILENO_SRVPAC           (DIRNO_SERVER + 9)     // pac.cxx
#define FILENO_PKSERV           (DIRNO_SERVER + 10)    // pkserv.cxx
#define FILENO_REFER            (DIRNO_SERVER + 11)    // refer.cxx
#define FILENO_RPCIF            (DIRNO_SERVER + 12)    // rpcif.cxx
#define FILENO_SECDATA          (DIRNO_SERVER + 13)    // secdata.cxx
#define FILENO_SOCKUTIL         (DIRNO_SERVER + 14)    // sockutil.cxx
#define FILENO_TKTUTIL          (DIRNO_SERVER + 15)    // tktutil.cxx
#define FILENO_TRANSIT          (DIRNO_SERVER + 16)    // transit.cxx

// KDB interface
#define FILENO_KDBSAM		(DIRNO_KDB + 0)	       // kdbsam.cxx
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\getas.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       getas.cxx
//
//  Contents:   GetASTicket and support functions
//
//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//              16-Sept-2001 yordanr    modified for new interfaces
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"
//#include "kdctrace.h"
#include "krb5p.h"
#include "traceinterface.hxx"
#include "kdctrace.hxx"

#include "fileno.h"
#define FILENO FILENO_GETAS

//
//  Interface methods to the memory manager to signal start/end of request processing.
//
#include "kdcmem.hxx"

LARGE_INTEGER tsInfinity = {0xffffffff,0x7fffffff};
LONG lInfinity = 0x7fffffff;

#ifdef DBG
ULONG
NetpDcElapsedTime(
    IN ULONG StartTime
)

/*++

Routine Description:

    Returns the time (in milliseconds) that has elapsed is StartTime.

Arguments:

    StartTime - A time stamp from GetTickCount()

Return Value:

    Returns the time (in milliseconds) that has elapsed is StartTime.

--*/
{
    ULONG CurrentTime;

    //
    // If time has has wrapped,
    //  account for it.
    //

    CurrentTime = GetTickCount();

    if ( CurrentTime >= StartTime ) {
        return CurrentTime - StartTime;
    } else {
        return (0xFFFFFFFF-StartTime) + CurrentTime;
    }
}
#endif  // DBG

//+---------------------------------------------------------------------------
//
//  Function:   FailedLogon
//
//  Synopsis:   Processes a failed logon.
//
//  Effects:    May raise an exception, audit, event, lockout, etc.
//
//  Arguments:  [PrincInfo] -- [in] Client who didn't log on.
//              [ClientAddress] -- Address of client making request
//
//  Requires:
//
//  Returns:    HRESULT to return to client.
//
//  Algorithm:
//
//  History:    03-May-94   wader   Created
//
//  Notes:      This usually returns hrReason, but it may map it to
//              something else.
//              yordanr - has to be changed to use new Aidut interfaces
//
//----------------------------------------------------------------------------

VOID
FailedLogon(
    IN PIKdbProvider        piKdb,
    IN PIKerbPrincipal      UserInfo,
    IN OPTIONAL PSOCKADDR   ClientAddress,
    OUT PKERB_EXT_ERROR     pExtendedError
    )
{

    //  BUGBUG todo: fix failed logon auditing
#if 0
    LARGE_INTEGER CurrentTime = {0};
    KDB_PRINC_INFO UpdateInfo = {0};
    KERBERR KerbErr;

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    UpdateInfo.DataFlags = KERB_KDB_DATA_LOGON_TIME;
    UpdateInfo.LastFailedLogon = CurrentTime;
    UpdateInfo.LastLogon.QuadPart = KERB_KDB_TIME_NEVER;
    UpdateInfo.LastLogonClient = *ClientAddress;

    KerbErr = piKdb->PutPrincipal(
                 UserInfo->GetName(),
                 KerbAs,
                 &UpdateInfo,
                 pExtendedError
                 );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to update failed logon time for ",KLIN(FILENO,__LINE__)));
        KerbPrintKdcName(DEB_ERROR, UserInfo->Princ);
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   SuccessfulLogon
//
//  Synopsis:   Processes a successful logon.
//
//  Effects:    May raise an event, create an audit, throw a party.
//
//  Arguments:  [UserInfo] -- Client who logged on.
//              [ClientAddress] -- Address of client making request
//
//
//  Algorithm:
//
//  History:    03-May-94   wader   Created
//
//  Notes:      On successful logon, we discard the history of failed logons
//              (as far as lockout is concerned).
//              yordanr - has to be changed for new audit interfaces
//
//----------------------------------------------------------------------------

VOID
SuccessfulLogon(
    IN PIKdbProvider      KdbHandle,
    IN PIKerbPrincipal    UserInfo,
    IN PSOCKADDR OPTIONAL ClientAddress,
    OUT PKERB_EXT_ERROR   pExtendedError
    )
{
    //  BUGBUG todo: fix successful logon audit
#if 0
    LARGE_INTEGER CurrentTime = {0};
    KDB_PRINC_INFO UpdateInfo = {0};
    KERBERR KerbErr;

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    UpdateInfo.DataFlags = KERB_KDB_DATA_LOGON_TIME;
    UpdateInfo.LastLogon = CurrentTime;
    UpdateInfo.LastFailedLogon.QuadPart = KERB_KDB_TIME_NEVER;
    UpdateInfo.LastLogonClient = *ClientAddress;

    KerbErr = KdbPutPrincipal(
                 KdbHandle,
                 UserInfo->Princ,
                 KerbAs,
                 &UpdateInfo,
                 pExtendedError
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to update successful logon time for ",KLIN(FILENO,__LINE__)));
        KerbPrintKdcName(DEB_ERROR, UserInfo->Princ);
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildTicketAS
//
//  Synopsis:   Builds an AS ticket, including filling inthe name fields
//              and flag fields.
//
//  Arguments:  IN ClientInfo  -- client principal interface
//              IN ClientName  -- name of client from the request
//              IN ClientRealm -- realm from the request
//              IN ServiceInfo -- service ticket is for
//              IN ServerName  -- name of service
//              IN OPTIONAL  HostAddresses -- client host
//              IN RequestBody   -- ticket request body
//              IN PreAuthenticated -- is the client preauth
//              IN TransitedRealm --
//              OUT NewTicket    -- (out) ticket
//              OUT pExtendedError - extended error info
//
//  History:    24-May-93   WadeR   Created
//              12-Sept-2001 yordanr    modified for new interfaces
//
//  Notes:      See 3.1.3, A.2 of the Kerberos V5 R5.2 spec
//              (yordanr) does not make sence to take both client info and name
//              as params. Same for the server
//              only explanation is that with name canonicalization the
//              client name in the req and actual client name may differ.
//              but why have the former?
//
//----------------------------------------------------------------------------

KERBERR
BuildTicketAS(
    IN CKerbRequest          *pReq,
    IN PIKdbProvider          piProv,
    IN PKERB_REALM            ClientRealm,
    IN BOOLEAN                PreAuthenticated,
    IN PUNICODE_STRING        TransitedRealm,
    OUT PKERB_TICKET          NewTicket,
    OUT PKERB_EXT_ERROR       pExtendedError
    )
{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    LARGE_INTEGER TicketLifespan;
    LARGE_INTEGER TicketRenewspan, Expire;
    ULONG KdcOptions = 0;
    ULONG CommonEType = 0;
    PKERB_INTERNAL_NAME pkinClient;
    PIKerbPrincipal  ClientInfo = pReq->GetIPrincClient();
    PIKerbPrincipal ServiceInfo = pReq->GetIPrincService();
    const KERB_KDC_REQUEST_BODY *RequestBody = &pReq->GetKdcRequest()->request_body;

    TRACER(L"BuildTicketAS", (PVOID *) &Status);

    TRACE(KDC, BuildTicketAS, DEB_FUNCTION);

    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) NewTicket->encrypted_part.cipher_text.value;

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    NewTicket->ticket_version = KERBEROS_VERSION;

    D_DebugLog(( DEB_T_TICKETS, "Building an AS ticket to %ws for %ws\n",
                ClientInfo->GetName()->Names[0].Buffer,
                ServiceInfo->GetName()->Names[0].Buffer ));

    //
    // Pickup the lifespan from the client principal. KDB enforces
    // any global restrictions.
    //

    TicketLifespan = ClientInfo->MaxLifeTime();
    TicketRenewspan = ClientInfo->MaxRenewTime();
    Expire = ClientInfo->Expiration();

    Status = KdcBuildTicketTimesAndFlags(
                ClientInfo->GetPrincFlags(),
                ServiceInfo->GetPrincFlags(),
                piProv->GetKdcPolicy(),
                &TicketLifespan,
                &TicketRenewspan,
                &Expire,
                RequestBody,
                NULL,           // no source ticket
                EncryptedTicket,
                pExtendedError
                );

    if (!KERB_SUCCESS(Status))
    {
        D_DebugLog((DEB_TRACE,"KLIN(%x) Failed to build ticket times and flags: 0x%x\n",
                  KLIN(FILENO,__LINE__), Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }


    //
    // Make this an Initial ticket (issued by the AS)
    //

    *((PULONG)EncryptedTicket->flags.value) |= KerbConvertUlongToFlagUlong(KERB_TICKET_FLAGS_initial);

    //
    // Turn on preauth flag if necessary
    //

    if (PreAuthenticated)
    {
        *((PULONG)EncryptedTicket->flags.value) |= KerbConvertUlongToFlagUlong(KERB_TICKET_FLAGS_pre_authent);
    }

    //  compute the common ETYPE
    const ETYPE*    pETypes = NULL;
    ULONG   cEtypes = 0;
    ClientInfo->GetEtypes(&pETypes, &cEtypes);
    Status = KerbFindCommonEType(RequestBody->encryption_type,
                                  cEtypes,
                                  pETypes,
                                  &CommonEType);
    if (!KERB_SUCCESS(Status))
    {
        //  BUGBUG todo: log/trace
        goto    Cleanup;
    }

    Status = KerbMakeKey(
                CommonEType,
                &EncryptedTicket->key
                );

    if (!KERB_SUCCESS(Status))
    {
       FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
       goto Cleanup;
    }


    //
    // Insert the service names. If the client requested canoncalization,
    // return our realm name & sam account name. Otherwise copy what the
    // client requested
    //
#ifdef DO_NAME_CANONICALIZATION
    if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
        ((ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
    {
        PKERB_INTERNAL_NAME TempServiceName = NULL;
        //
        // Build the service name for the ticket. For interdomain trust
        // accounts, this is "krbtgt / domain name"
        //

        if (ServiceTicketInfo->UserId == DOMAIN_USER_RID_KRBTGT)
        {

            Status = KerbBuildFullServiceKdcName(
                        KdcDnsRealmName(KdbHandle),
                        KdcServiceName(KdbHandle),
                        KRB_NT_SRV_INST,
                        &TempServiceName
                        );

            if (!KERB_SUCCESS(Status))
            {
                FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                goto Cleanup;
            }

            Status = KerbConvertKdcNameToPrincipalName(
                        &NewTicket->server_name,
                        TempServiceName
                        );

            KerbFreeKdcName(&TempServiceName);

            if (!KERB_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else if ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) != 0)
        {

            Status = KerbBuildFullServiceKdcName(
                        &ServiceTicketInfo->AccountName,
                        KdcServiceName(),
                        KRB_NT_SRV_INST,
                        &TempServiceName
                        );

            if (!KERB_SUCCESS(Status))
            {
                FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                goto Cleanup;
            }

            Status = KerbConvertKdcNameToPrincipalName(
                        &NewTicket->server_name,
                        TempServiceName
                        );

            KerbFreeKdcName(&TempServiceName);

            if (!KERB_SUCCESS(Status))
            {
               FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
               goto Cleanup;
            }
        }
        else
        {
            Status = KerbConvertStringToPrincipalName(
                        &NewTicket->server_name,
                        &ServiceTicketInfo->AccountName,
                        KRB_NT_PRINCIPAL
                        );
            if (!KERB_SUCCESS(Status))
            {
               FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
               goto Cleanup;
            }
        }

    }
    else
#endif
    {
        //
        // No canonicalzation, so copy in all the names as the client
        // requested them.
        //

        Status = KerbDuplicatePrincipalName(
                    &NewTicket->server_name,
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                    );
        if (!KERB_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    Status = KerbConvertUnicodeStringToRealm(
                 &NewTicket->realm,
                 ClientInfo->GetRealm()
                 );

    if ( !KERB_SUCCESS( Status ))
    {
       FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
       goto Cleanup;
    }

    //
    // Insert the client names. If the client requested canoncalization,
    // return our realm name & sam account name. Otherwise copy what the
    // client requested
    //
    if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
        (pkinClient = ClientInfo->GetCanonicalName())
        )
    {
        Status = KerbConvertKdcNameToPrincipalName(
                    &EncryptedTicket->client_name,
                    pkinClient
                    );
    }
    else
    {
        Status = KerbConvertKdcNameToPrincipalName(
                     &EncryptedTicket->client_name,
                     ClientInfo->GetName()
                     );
    }

    if (!KERB_SUCCESS(Status))
    {
       FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
       goto Cleanup;
    }

    //
    //  convert unicode realm to kerb realm
    //

    EncryptedTicket->client_realm = *ClientRealm;

    if ((RequestBody->bit_mask & addresses_present) != 0 &&
        RequestBody->addresses &&
        KdcUseClientAddresses)
    {
        EncryptedTicket->bit_mask |= KERB_ENCRYPTED_TICKET_client_addresses_present;
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = RequestBody->addresses;
    }
    else
    {
        EncryptedTicket->bit_mask &= ~KERB_ENCRYPTED_TICKET_client_addresses_present;
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = NULL;
    }

    if (TransitedRealm->Length > 0)
    {
        STRING TempString;
        Status = KerbUnicodeStringToKerbString(
                    &TempString,
                    TransitedRealm
                    );
        if (!KERB_SUCCESS(Status))
        {
           FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
           goto Cleanup;
        }
        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) TempString.Buffer;
        EncryptedTicket->transited.contents.length = (int) TempString.Length;

    }
    else
    {
        ZeroMemory(
            &EncryptedTicket->transited,
            sizeof(KERB_TRANSITED_ENCODING)
            );
    }

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;

#if DBG
    PrintTicket( DEB_T_TICKETS, "BuildTicketAS: Final ticket", NewTicket );
#endif
Cleanup:
    if (!KERB_SUCCESS(Status))
    {
        KdcFreeInternalTicket(NewTicket);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   I_GetASTicket
//
//  Synopsis:   Gets an authentication service ticket to the requested
//              service.
//
//  Effects:    Allocates and encrypts a KDC reply
//
//  Arguments:
//              IN ClientAddress
//              IN RequestMessage - Contains the AS request message
//              IN RequestRealm -- client realm
//              IN Pdu - PDU to pack the reply body with.
//              IN ReplyPdu -- outer Pdu
//              IN InputMessage - buffer client sent, used for replay detection
//              OUT OutputMessage - Contains the AS reply message
//              OUT ErrorData - contains any error data for an error message
//              OUT pExtendedError - ext. err
//              OUT ClientRealm - client realm from the principal interface
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
I_GetASTicket(
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN PKERB_AS_REQUEST RequestMessage,
    IN PUNICODE_STRING RequestRealm,
    IN ULONG Pdu,
    IN ULONG ReplyPdu,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage,
    OUT PKERB_MESSAGE_BUFFER ErrorData,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT PUNICODE_STRING ClientRealm
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;

    IKdbProvider *piKdb = NULL;

    PIKerbPrincipal ClientInfo = NULL;
    PIKerbPrincipal ServiceInfo = NULL;

    KERB_ENCRYPTION_KEY EncryptionKey = {0};

    KERB_TICKET Ticket = {0};
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    KERB_ENCRYPTED_KDC_REPLY ReplyBody = {0};
    KERB_KDC_REPLY Reply = {0};
    PKERB_KDC_REQUEST_BODY RequestBody = NULL;
    KERB_REALM ClientRealmName = {0};

    PKERB_AUTHORIZATION_DATA AuthData = NULL;
    PKERB_PA_DATA_LIST OutputPreAuthData = NULL;

    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_INTERNAL_NAME ServerName = NULL;

    UNICODE_STRING ServerStringName = {0};
    UNICODE_STRING ClientStringName = {0};
    UNICODE_STRING TransitedRealm = {0};

    ULONG NameFlags = 0;
    ULONG PreAuthType = 0;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG ReplyTicketFlags = 0;

    BOOLEAN AuditedFailure = FALSE;
    BOOLEAN LoggedFailure = FALSE;

    CKerbRequest KdcReq;
    KdcReq.m_pKdcRequest = RequestMessage;
    KdcReq.m_pClientAddress = ClientAddress;
    PUNICODE_STRING ReferralRealm = NULL;

#ifdef KDC_WMI_TRACING
    KDC_AS_EVENT_INFO ASEventTraceInfo = {0};
#endif

    TRACE(KDC, I_GetASTicket, DEB_FUNCTION);
    TRACER(L"I_GetASTicket", (PVOID *) &KerbErr);

    //  init KDC request and handlers
    Status = KdcReq.CreateHandlerInstances();
    if (Status != STATUS_SUCCESS)
    {
        //  todo: BUGBUG log/trace?
        return  KRB_ERR_GENERIC;
    }
    KdcReq.m_ServId = KerbAs;

    //
    //  Initialize local variables
    //

    EncryptedTicket.flags.value = (PUCHAR) &TicketFlags;
    EncryptedTicket.flags.length = sizeof(ULONG) * 8;
    ReplyBody.flags.value = (PUCHAR) &ReplyTicketFlags;
    ReplyBody.flags.length = sizeof(ULONG) * 8;
    RtlInitUnicodeString( ClientRealm, NULL );
    Ticket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    //
    // Initialize return variables
    //
    ClientRealm->Length = ClientRealm->MaximumLength = 0;


    //
    // Assume that this isn't a logon request.  If we manage to fail before
    // we've determined it's a logon attempt, we won't mark it as a failed
    // logon.
    //

    RequestBody = &RequestMessage->request_body;

    //
    // There are many options that are invalid for an AS ticket.
    //

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    //
    // Start event tracing (capture error cases too)
    //
#ifdef KDC_WMI_TRACING
    if (KdcEventTraceFlag){

        ASEventTraceInfo.EventTrace.Guid = KdcGetASTicketGuid;
        ASEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        ASEventTraceInfo.EventTrace.Flags = WNODE_FLAG_TRACED_GUID;
        ASEventTraceInfo.EventTrace.Size = sizeof (EVENT_TRACE_HEADER) + sizeof (ULONG);
        ASEventTraceInfo.KdcOptions = KdcOptions;

        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&ASEventTraceInfo
            );
    }
#endif

    if (KdcOptions &
        (KERB_KDC_OPTIONS_forwarded |
         KERB_KDC_OPTIONS_proxy |
         KERB_KDC_OPTIONS_unused7 |
         KERB_KDC_OPTIONS_unused9 |
         KERB_KDC_OPTIONS_renew |
         KERB_KDC_OPTIONS_validate |
         KERB_KDC_OPTIONS_reserved |
         KERB_KDC_OPTIONS_enc_tkt_in_skey ) )
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    if (( RequestBody->bit_mask & addresses_present ) &&
        ( RequestBody->addresses == NULL ))
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Make sure a client name was supplied
    //


    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_client_name_present) != 0)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ClientName,
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        KerbErr = KerbConvertKdcNameToString(
                    &ClientStringName,
                    ClientName,
                    NULL
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) No principal name supplied to AS request - not allowed\n",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }


    //
    // Copy out the service name. This is not an optional field.
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) == 0)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Client %wZ sent AS request with no server name\n",
                  KLIN(FILENO,__LINE__),
                  &ClientStringName));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ServerName,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToString(
                &ServerStringName,
                ServerName,
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Check if the client said to canonicalize the name
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
    {
        NameFlags |= KDC_KDB_GET_PRINC_CANONICALIZE;
    }

    D_DebugLog((DEB_TRACE, "Getting an AS ticket to "));
    D_KerbPrintKdcName( DEB_TRACE, ServerName );
    D_DebugLog((DEB_TRACE, "\tfor " ));
    D_KerbPrintKdcName( DEB_TRACE, ClientName );

    KerbErr = KdbRealmLocate(RequestRealm, &piKdb);
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to locate handle for realm %wZ",
                  KLIN(FILENO,__LINE__), &RequestRealm));
        goto Cleanup;
    }

    KdbPerfCount(piKdb, KerbKdcAsReqCounter);

    KerbErr = piKdb->GetPrincipal(
                 NameFlags | KDC_KDB_GET_PRINC_CLIENT | KDC_KDB_GET_PRINC_FOLLOW_REFERRALS,
                 ClientName,
                 RequestRealm->Buffer,
                 &KdcReq,
                 &ClientInfo,
                 pExtendedError,
                 &ReferralRealm
                 );

    // Store principal regardless of whether an error occurred. Our Xbox ASKDC 
    // hangs logging data off the principal object. It's weird, but since it 
    // does all its work in GetPrincipal(), it makes some sense.
    KdcReq.m_piClientPrincipal = ClientInfo;

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // The Xbox KDC has co-opted the KDC_ERR_PREAUTH_REQUIRED and made it an expected 
        // error code, for the echo preauth system in the ASKDC. So let's not spew stuff 
        // in that case.
        //
        if (KerbErr == KDC_ERR_PREAUTH_REQUIRED)
        {
            goto Cleanup;
        }

        //
        //  Do AS-referral if KerbErr == KDC_ERR_WRONG_REALM
        //
        if (KerbErr == KDC_ERR_WRONG_REALM)
        {
            DsysAssert(NameFlags & KDC_KDB_GET_PRINC_CANONICALIZE);
            DsysAssert(ReferralRealm);
            TRACE_FILELINE(TRACE_ERR,
                        (FILE_AND_LINE, L"Failed to get client name but doing a referral")
                        );
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to get client name but doing a referral",KLIN(FILENO,__LINE__)));

            KerbErr = KerbDuplicateStringEx(
                          ClientRealm,
                          ReferralRealm,
                          FALSE
                          );

            if ( !KERB_SUCCESS( KerbErr ))
            {
                goto Cleanup;
            }
        }
        else
        {
            TRACE_FILELINE(TRACE_ERR,
                        (FILE_AND_LINE, L"Failed to get client name")
                        );
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to get client name ",KLIN(FILENO,__LINE__)));
        }
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    //
    //  fill in the req. struct. Ultimately, get rid
    //  of the local vars
    //
    KdcReq.m_pETypes           = (PKERB_CRYPT_LIST)(RequestBody->encryption_type);

    KerbErr = KerbDuplicateStringEx(
                  ClientRealm,
                  ClientInfo->GetRealm(),
                  FALSE
                  );

    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertUnicodeStringToRealm(
                  &ClientRealmName,
                  ClientRealm
                  );

    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    //  client keys are not accessible anymore
    //

    //
    // Setup some reasonable defaults for expiry
    //
    //  all info is in the principal. No need to carry extra stuff
    //    AccountExpiry = ClientInfo->Expiration;

    KerbErr = KerbProcessPaCompoundIdentity(&KdcReq, pExtendedError);
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;

    }

    //
    // Unpack the pre-auth data.
    //

    KerbErr = KdcCheckPreAuthData(
                 piKdb,
                 KerbAs,
                 ClientInfo,
                 RequestMessage->KERB_KDC_REQUEST_preauth_data,
                 RequestBody,
                 &PreAuthType,
                 &OutputPreAuthData,
                 &EncryptionKey,
                 &TransitedRealm,
                 pExtendedError,
                 &KdcReq
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KdbAuditEvent(
                    piKdb,
                    PreauthFailure,
                    (PIKerbRequest)&KdcReq,
                    &KerbErr,
                    &KdcOptions,
                    NULL,
                    &PreAuthType,
                    ClientAddress
                    );

        if (NT_SUCCESS(Status))
        {
            AuditedFailure = TRUE;
        }

        //
        // Only handle failed logon if pre-auth fails. Otherwise the error
        // was something the client couldn't control, such as memory
        // allocation or clock skew.
        //
        if (KerbErr == KDC_ERR_PREAUTH_FAILED)
        {
            FailedLogon(
                piKdb,
                ClientInfo,
                ClientAddress,
                pExtendedError
                );
        }
        LoggedFailure = TRUE;
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to check pre-auth data: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Figure out who the ticket is for. First break the name into
    // a local name and a referral realm
    //

    //
    //  Note:   We don't allow referrals here, because we should only get AS
    //          requests for our realm, and the krbtgt\server should always be
    //          in our realm.

    KerbErr = piKdb->GetPrincipal(
                 NameFlags | KDC_KDB_GET_PRINC_SERVER,
                 ServerName,
                 RequestRealm->Buffer,
                 &KdcReq,
                 &ServiceInfo,
                 pExtendedError,
                 NULL
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to get principal 0x%x ",
                  KLIN(FILENO,__LINE__), KerbErr ));
        KerbPrintKdcName(DEB_ERROR, ServerName);
        goto Cleanup;
    }
    KdcReq.m_piServerPrincipal = ServiceInfo;

    //
    // Check KDB ticket restrictions - unless you are requesting a ticket
    // to yourself.
    //

    if (!KerbEqualKdcNames(ClientName, ServerName))
    {
        if (ServiceInfo->GetPrincFlags() & KERB_KDB_DISALLOW_SVR)
        {
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;

            DebugLog((DEB_ERROR,"KLIN(%x) Service principal not allowed ",
                      KLIN(FILENO,__LINE__), KerbErr ));
            KerbPrintKdcName(DEB_ERROR, ServerName);
            goto Cleanup;
        }

        if (ServiceInfo->GetPrincFlags() & KERB_KDB_REQUIRE_USER2USER)
        {
            KerbErr = KDC_ERR_MUST_USE_USER2USER;

            DebugLog((DEB_ERROR,"KLIN(%x) Service principal requires user2user ",
                      KLIN(FILENO,__LINE__), KerbErr ));
            KerbPrintKdcName(DEB_ERROR, ServerName);
            goto Cleanup;
        }
    }

#if 0
    //  core does not deal with principal keys any more
    //
    // Find a common crypto system.  Do it now in case we need
    // to return the password for a service.
    //
    if (EncryptionKey.keyvalue.value == NULL)
    {
        KerbErr = KerbFindCommonCryptSystem(
                    RequestBody->encryption_type,
                    ClientInfo->Keys,
                    NULL, //ServiceInfo.Keys,
                    &ClientEType,
                    &ClientKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            KdcReportKeyError(
                KdbHandle,
                ClientInfo->Princ,
                ClientInfo->Realm,
                NULL,
                NULL,
                KDCEVENT_NO_KEY_UNION_AS,
                RequestBody->encryption_type,
                ClientInfo->Keys
                );

            DebugLog((DEB_ERROR,"KLIN(%x) Failed to find common ETYPE: 0x%x\n",
                      KLIN(FILENO,__LINE__),KerbErr));
            goto Cleanup;
        }
    }
    else
    {
        //
        // BUG 453284: this doesn't take into account the service ticket
        // info. If the PKINIT code generated a key that the service
        // doesn't suport, this key may not be usable by the client &
        // server. However, in the pkinit code it is hard to know what
        // types the server supports.
        //

        ClientEType = EncryptionKey.keytype;
    }
    KdcReq.m_ulCommonEType = ClientEType;
    //
    // Get the etype to use for the ticket itself from the server's
    // list of keys
    //

    KerbErr = KerbFindCommonCryptSystem(
                RequestBody->encryption_type,
                ServiceInfo->Keys,
                NULL,   // no additional passwords
                &CommonEType,
                &ServerKey
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        KdcReportKeyError(
            KdbHandle,
            ServiceInfo->Princ,
            ServiceInfo->Realm,
            NULL,
            NULL,
            KDCEVENT_NO_KEY_UNION_AS,
            RequestBody->encryption_type,
            ServiceInfo->Keys
            );

        DebugLog((DEB_ERROR,"KLIN(%x) Failed to find common ETYPE: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }
#endif

    //
    // We need to save the full domain name of the service regardless
    // of whether it was provided or not. This is so name changes
    // can be detected. Instead of creating a mess of trying to figure out
    // which deallocator to use, allocate new memory and copy data.
    //

    KerbErr = BuildTicketAS(
                &KdcReq,
                piKdb,
                &ClientRealmName,
                (PreAuthType != 0),
                &TransitedRealm,
                &Ticket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN , "KLIN(%x) Failed to build AS ticket: 0x%x\n",
                  KLIN(FILENO,__LINE__),KerbErr));
        goto Cleanup;
    }
    //  save the (to be) encrypted tgt part
    KdcReq.m_pEncTicket = &EncryptedTicket;
    //  and common etype
    KdcReq.m_ulCommonEType = EncryptedTicket.key.keytype;

    //
    // Return any authorization data for the ticket
    //

    AuthData = NULL;    // authdata starts out clean for AS

    //
    //  build auth data to return in the ticket
    //
    KerbErr = KdcReturnAuthData(
                 &KdcReq,
                 &AuthData,
                 pExtendedError);


    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to return auth data : 0x%x\n",
                    KLIN(FILENO,__LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // Stick the auth data into the AS ticket
    //

    if (AuthData)
    {
        EncryptedTicket.KERB_ENCRYPTED_TICKET_authorization_data = AuthData;
        EncryptedTicket.bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
        AuthData = NULL;        // Leak??
    }

    //
    // Now build the reply
    //

    KerbErr = BuildReply(
                ClientInfo,
                RequestBody->nonce,
                &Ticket.server_name,
                Ticket.realm,
                ((RequestBody->bit_mask & addresses_present) != 0) ? RequestBody->addresses : NULL,
                &Ticket,
                &ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now build the real reply and return it.
    //

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AS_REP;
    Reply.KERB_KDC_REPLY_preauth_data = NULL;
    Reply.bit_mask = 0;

    Reply.client_realm = EncryptedTicket.client_realm;

    //
    // Return any PA-DATA (like pw-salt)
    //

    KerbErr = KdcReturnPreAuthData(
                 &KdcReq,
                 &OutputPreAuthData
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (OutputPreAuthData != NULL)
    {
        Reply.bit_mask |= KERB_KDC_REPLY_preauth_data_present;
        Reply.KERB_KDC_REPLY_preauth_data = (PKERB_REPLY_PA_DATA_LIST) OutputPreAuthData;

        //
        // Zero this out so we don't free the preauth data twice
        //

        OutputPreAuthData = NULL;
    }


    //
    // Copy in the ticket
    //

    KerbErr = KerbPackTicket(
                &KdcReq,
                &Ticket,
                ServiceInfo,
                RequestBody->encryption_type,    // use to figure out enc type
                &Reply.ticket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack ticket: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Note: these are freed elsewhere, so zero them out after
    // using them
    //

    Reply.client_name = EncryptedTicket.client_name;

    //
    // Copy in the encrypted part
    //

    KerbErr = KerbPackKdcReplyBody(
                &KdcReq,
                &ReplyBody,
                //  pass the client info if there's no session key to use
                &EncryptionKey,
                ClientInfo,
                //  no key version for session keys
                //  version for client key will come from the principal
//                (EncryptionKey.keyvalue.value != NULL) ? KERB_NO_KEY_VERSION : ClientKey->KeyVersion,
                RequestBody->encryption_type, // chose etype of using client
                Pdu,
                &Reply.encrypted_part,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack KDC reply body: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    Status = KdbAuditEvent(
        piKdb,
        AsTicket,
        (PIKerbRequest)&KdcReq,
        &KerbErr,
        &KdcOptions,
        NULL,
        &PreAuthType,
        ClientAddress
        );

    if (!NT_SUCCESS(Status))
        {
            LoggedFailure = TRUE;
            KerbErr = KDC_ERR_CLIENT_REVOKED;
            goto Cleanup;
        }

    //
    // Pack the reply
    //

    KerbErr = KerbPackData(
                &Reply,
                ReplyPdu,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        DsysAssert(RequestBody != NULL);

        if (!AuditedFailure)
        {
            KdbAuditEvent(
                piKdb,
                AsFailure,
                (PIKerbRequest)&KdcReq,
                &KerbErr,
                &KdcOptions,
                NULL,
                NULL,
                ClientAddress
                );
        }

        //
        // If there was any preauth data to return, pack it for return now.
        //

        if (OutputPreAuthData != NULL)
        {
            if (ErrorData->Buffer != NULL)
            {
                D_DebugLog((DEB_ERROR,
                          "KLIN(%x) Freeing return error data to return preauth data\n",
                          KLIN(FILENO,__LINE__)));
                MIDL_user_free(ErrorData->Buffer);
                ErrorData->Buffer = NULL;
                ErrorData->BufferSize = 0;
            }

            (VOID) KerbPackData(
                    &OutputPreAuthData,
                    PKERB_PREAUTH_DATA_LIST_PDU,
                    &ErrorData->BufferSize,
                    &ErrorData->Buffer
                    );
        }

    }

    if (piKdb && (ClientInfo != NULL))
    {
        if (!KERB_SUCCESS(KerbErr))
        {
            // XXX Call krb-error hook

            if (!LoggedFailure && KerbErr == KDC_ERR_PREAUTH_FAILED)
            {
                FailedLogon(
                    piKdb,
                    ClientInfo,
                    ClientAddress,
                    pExtendedError
                    );
            }
        }
        else
        {
            SuccessfulLogon(
                piKdb,
                ClientInfo,
                ClientAddress,
                pExtendedError
                );
        }
    }

    //
    // Complete the WMI event
    //
#ifdef KDC_WMI_TRACING

    if (KdcEventTraceFlag){

        //These variables point to either a unicode string struct containing
        //the corresponding string or a pointer to KdcNullString

        PUNICODE_STRING pStringToCopy;
        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};

        ASEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        ASEventTraceInfo.EventTrace.Flags = WNODE_FLAG_USE_MOF_PTR |
                                            WNODE_FLAG_TRACED_GUID;

        // Always output error code.  KdcOptions was captured on the start event

        ASEventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) &KerbErr;
        ASEventTraceInfo.eventInfo[0].Length  = sizeof(ULONG);
        ASEventTraceInfo.EventTrace.Size =
            sizeof (EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        // Build counted MOF strings from the unicode strings

        if (ClientStringName.Buffer != NULL &&
            ClientStringName.Length > 0)
        {
            pStringToCopy = &ClientStringName;
        }
        else {
            pStringToCopy = &UnicodeEmptyString;
        }

        ASEventTraceInfo.eventInfo[1].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        ASEventTraceInfo.eventInfo[1].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[2].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        ASEventTraceInfo.eventInfo[2].Length =
            pStringToCopy->Length;
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (ServerStringName.Buffer != NULL &&
            ServerStringName.Length > 0)
        {
            pStringToCopy = &ServerStringName;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }


        ASEventTraceInfo.eventInfo[3].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        ASEventTraceInfo.eventInfo[3].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[4].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        ASEventTraceInfo.eventInfo[4].Length =
            pStringToCopy->Length;
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (RequestRealm->Buffer != NULL &&
            RequestRealm->Length > 0)
        {
            pStringToCopy = RequestRealm;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        ASEventTraceInfo.eventInfo[5].DataPtr =
            (ULONGLONG) &(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[5].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[6].DataPtr =
            (ULONGLONG) (pStringToCopy->Buffer);
        ASEventTraceInfo.eventInfo[6].Length =
            (pStringToCopy->Length);
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&ASEventTraceInfo
            );
    }
#endif
    //  principals are deleted in the req.
    //  ultimately get rid of teh local vars
    if (ClientInfo)
    {
//        ClientInfo->Release();
    }
    if (ServiceInfo  && !KdcReq.m_piServerPrincipal)
    {
        ServiceInfo->Release();
    }
    KerbFreeAuthData( AuthData );
    KdcFreeInternalTicket( &Ticket );
    KerbFreeKey( &EncryptionKey );
    KerbFreeKdcName( &ClientName );
    KerbFreeString( &ClientStringName );
    KerbFreeString( &TransitedRealm );
    KerbFreeString( &ServerStringName );
    KerbFreeKdcName( &ServerName );
    KdcFreeKdcReplyBody( &ReplyBody );
    KdcFreeKdcReply( &Reply );
    KerbFreePreAuthData( OutputPreAuthData );
    KerbFreeRealm(&ClientRealmName);

    if (ReferralRealm)
        MIDL_user_free(ReferralRealm);


    //  destructor takes care of CKdcRequest


    D_DebugLog(( DEB_TRACE, "I_GetASTicket() returning 0x%x\n", KerbErr ));

    return KerbErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcGetTicket
//
//  Synopsis:   Generic ticket getting entrypoint to get a ticket from the KDC
//
//  Effects:
//
//  Arguments:  IN Context       - ATQ context - only present for TCP/IP callers
//              IN ClientAddress - Client's IP addresses. Only present for UDP & TPC callers
//              IN ServerAddress - address the client used to contact this KDC.
//                      Only present for UDP & TPC callers
//              IN InputMessage  - the input KDC request message, in ASN.1 format
//              OUT OutputMessage - Receives the KDC reply message, allocated by
//                  the KDC.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine is exported from the DLL and called from the
//              client dll.
//
//
//--------------------------------------------------------------------------

extern "C"
KERBERR
NTAPI
KdcGetTicket(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    )
{
    KERBERR KerbErr;
    KERB_EXT_ERROR  ExtendedError = {0,0};
    PKERB_EXT_ERROR pExtendedError = &ExtendedError; // needed for macro
    PKERB_KDC_REQUEST RequestMessage = NULL;
    KERB_KDC_REPLY ReplyMessage = {0};
    KERB_MESSAGE_BUFFER ErrorData = {0};
    ULONG InputPdu = KERB_TGS_REQUEST_PDU;
    ULONG OutputPdu = KERB_TGS_REPLY_PDU;
    ULONG InnerPdu = KERB_ENCRYPTED_TGS_REPLY_PDU;
    UNICODE_STRING RequestRealm = {0};
    PKERB_INTERNAL_NAME RequestServer = NULL;
    UNICODE_STRING ClientRealm = {0};
    PUNICODE_STRING ExtendedErrorServerRealm = NULL;
    PKERB_INTERNAL_NAME ExtendedErrorServerName = NULL;

#if DBG
    DWORD StartTime = 0;
#endif

    InitializeTlsPerRequest();
    TRACER(L"KdcGetTicket", (PVOID *) &KerbErr);
    TRACE_FILELINE(TRACE_VERB, ( FILE_AND_LINE, L"Entered KdcGetTicket"));

    //
    // Make sure we are allowed to execute
    //

    if (!NT_SUCCESS(EnterApiCall()))
    {
        return(KDC_ERR_NOT_RUNNING);
    }

    ZeroMemory(
        &ReplyMessage,
        sizeof(KERB_KDC_REPLY)
        );

    //
    // First initialize the return parameters.
    //

    OutputMessage->Buffer = NULL;
    OutputMessage->BufferSize = 0;

    //
    // Check the first byte of the message to indicate the type of message
    //

    if ((InputMessage->BufferSize > 0) && (
        (InputMessage->Buffer[0] & KERB_BER_APPLICATION_TAG) != 0))
    {
        if ((InputMessage->Buffer[0] & KERB_BER_APPLICATION_MASK) == KERB_AS_REQ_TAG)
        {
            InputPdu = KERB_AS_REQUEST_PDU;
            OutputPdu = KERB_AS_REPLY_PDU;
            InnerPdu = KERB_ENCRYPTED_AS_REPLY_PDU;
        }
        else if ((InputMessage->Buffer[0] & KERB_BER_APPLICATION_MASK) != KERB_TGS_REQ_TAG)
        {
        TRACE_FILELINE(TRACE_ERR, ( FILE_AND_LINE, L"Bad message sent to KDC - not AS or TGS request\n"));
            D_DebugLog((DEB_T_SOCK,
                      "KLIN(%x) Bad message sent to KDC - not AS or TGS request\n",
                      KLIN(FILENO,__LINE__)));

            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto NoMsgCleanup;
        }
    }
    else
    {
        TRACE_FILELINE(TRACE_ERR, ( FILE_AND_LINE, L"Bad message sent to KDC - length too short or bad first byte\n"));
        D_DebugLog((DEB_T_SOCK,"KLIN(%x) Bad message sent to KDC - length to short or bad first byte\n",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KRB_ERR_FIELD_TOOLONG;
        goto NoMsgCleanup;

    }

    //
    // First decode the input message
    //

    KerbErr = (KERBERR) KerbUnpackData(
                            InputMessage->Buffer,
                            InputMessage->BufferSize,
                            InputPdu,
                            (PVOID *) &RequestMessage
                            );

    if (KerbErr == KDC_ERR_MORE_DATA || !KERB_SUCCESS(KerbErr))
    {
        //  ERR_MORE_DATA is unacceptable at this point.
        //  the transport layer guarantees the whole packet is received
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to unpack KDC request: 0x%x\n",
                  KLIN(FILENO,__LINE__),KerbErr));

        //
        // We don't want to return an error on a badly formed
        // packet,as it can be used to set up a flood attack
        //

        goto NoMsgCleanup;
    }

    //
    // First check the version of the request.
    //

    if (RequestMessage->version != KERBEROS_VERSION)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Bad request version: 0x%x\n",
                  KLIN(FILENO,__LINE__), RequestMessage->version));
        //
        //  We don't want to return an error when a bad version is encountered.
        //  This adheres to MIT version.
        //
        KerbErr = KDC_ERR_NONE;
        goto NoMsgCleanup;
    }

    //
    // now call the internal version to do all the hard work
    //

    //
    // Verify the realm name in the request
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                  &RequestRealm,
                  &RequestMessage->request_body.realm
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (RequestMessage->request_body.bit_mask & KERB_KDC_REQUEST_BODY_server_name_present)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                      &RequestServer,
                      &RequestMessage->request_body.server_name
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else if (RequestMessage->message_type != KRB_TGS_REQ)
    {
        //  missing server name allowed only for TGS
        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto    Cleanup;
    }

    //
    // Now that we have the request realm and request server, any subsequent
    // error will result in those values being placed into the extended error
    //

    ExtendedErrorServerRealm = &RequestRealm;
    ExtendedErrorServerName = RequestServer;

    if (RequestMessage->message_type == KRB_AS_REQ)
    {
        if (InputPdu != KERB_AS_REQUEST_PDU) {
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST,FILENO,__LINE__);
            goto Cleanup;
        }

        //
        // If WMI event tracing is enabled, notify it of the begin and end
        // of the ticket request
        //

#if DBG
        StartTime = GetTickCount();
#endif

        KerbErr = I_GetASTicket(
                      ClientAddress,
                      RequestMessage,
                      &RequestRealm,
                      InnerPdu,
                      OutputPdu,
                      InputMessage,
                      OutputMessage,
                      &ErrorData,
                      &ExtendedError,
                      &ClientRealm
                      );
#if DBG
        D_DebugLog((DEB_T_PERF_STATS, "I_GetASTicket took %d m seconds\n", NetpDcElapsedTime(StartTime)));
#endif
        TRACE_FILELINE(TRACE_VERB, (FILE_AND_LINE,
                                        L"I_GetASTicket returned with 0x%x", KerbErr)
                                    );
    }
    else if (RequestMessage->message_type == KRB_TGS_REQ)
    {

#if DBG
        StartTime = GetTickCount();
#endif

        KerbErr = HandleTGSRequest(
                      ClientAddress,
                      RequestMessage,
                      &RequestRealm,
                      OutputMessage,
                      &ExtendedError
                      );
#if DBG
        D_DebugLog((DEB_T_PERF_STATS, "HandleTGSRequest took %d m seconds\n", NetpDcElapsedTime(StartTime)));
#endif
        }
    else
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Invalid message type: %d\n",
                  KLIN(FILENO,__LINE__),
                  RequestMessage->message_type));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST,FILENO,__LINE__);
        KerbErr = KRB_AP_ERR_MSG_TYPE;
        goto Cleanup;
    }


    //
    // If the response is too big and we are using UDP, make the client
    // change transports. We can tell the caller is UDP because it doesn't
    // have an ATQ context but it does provide the client address.
    //

    if ((Context == NULL) && (ClientAddress != NULL))
    {
        if (OutputMessage->BufferSize >= KERB_MAX_KDC_RESPONSE_SIZE)
        {
            D_DebugLog((DEB_WARN,"KLIN(%x) KDC response too big for UDP: %d bytes\n",
                      KLIN(FILENO,__LINE__), OutputMessage->BufferSize ));
            TRACE_FILELINE(TRACE_ERR,
                                            (FILE_AND_LINE,
                                            L"KDC response too big for UDP: %d bytes",
                                            OutputMessage->BufferSize
                                            )
                                        );
            KerbErr = KRB_ERR_RESPONSE_TOO_BIG;
            MIDL_user_free(OutputMessage->Buffer);
            OutputMessage->Buffer = NULL;
            OutputMessage->BufferSize = 0;
        }
    }

Cleanup:

    // TBD:  Put in extended error return goo here for client
    //
    // If the KerbErr is KDC_ERR_MORE_DATA, we don't want to return anything. This is a 
    // malformed packet that *should* never be received since we use UDP and all packets 
    // should be complete. Fuzzers or hackers may generate this error, though, and rather 
    // than put in a bajillion checks elsewhere, we're just putting the check in here.

    if (!KERB_SUCCESS(KerbErr) && KerbErr != KDC_ERR_MORE_DATA)
    {
        //
        // We may have a message built by someone else - the PDC
        //
        if (OutputMessage->Buffer == NULL)
        {
#ifdef XBOX_KDC
            DWORD SaveBufferSize = ErrorData.BufferSize;
            BYTE* SaveBuffer = ErrorData.Buffer;
            
            if (RequestMessage)
            {
                ErrorData.Buffer = (PUCHAR)&(RequestMessage->request_body.nonce);
                ErrorData.BufferSize = sizeof(RequestMessage->request_body.nonce);
            }
#endif
            KerbBuildErrorMessageEx(
                KerbErr,
                &ExtendedError,
                ExtendedErrorServerRealm,
                ExtendedErrorServerName,
                &ClientRealm,
                ErrorData.Buffer,
                ErrorData.BufferSize,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );
#ifdef XBOX_KDC
            ErrorData.BufferSize = SaveBufferSize;
            ErrorData.Buffer = SaveBuffer;
#endif
        }
     }

NoMsgCleanup:

    KerbFreeString(&RequestRealm);
    MIDL_user_free(RequestServer);

    KerbFreeString(&ClientRealm);

    if (RequestMessage != NULL)
    {
        KerbFreeData(InputPdu,RequestMessage);
    }

    if (ErrorData.Buffer != NULL)
    {
        MIDL_user_free(ErrorData.Buffer);
    }
    LeaveApiCall();



  //PTRACE_INFO_BLOCK newBlock = (PTRACE_INFO_BLOCK)TlsGetValue(g_TraceTlsIndex);
    //LocalFree(newBlock);
    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\dsysdbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dsysdbg.h
//
//  Contents:   Merged all the debug code together
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DSYSDBG_H__
#define __DSYSDBG_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

typedef struct _DEBUG_KEY {
    DWORD   Mask;
    PCHAR   Tag;
} DEBUG_KEY, * PDEBUG_KEY;

#define DSYSDBG_OPEN_ONLY       0x00000001
#define DSYSDBG_DEMAND_OPEN     0x00000002
#define DSYSDBG_BREAK_ON_ERROR  0x00000004

#define DSYSDBG_ASSERT_CONTINUE 0
#define DSYSDBG_ASSERT_BREAK    1
#define DSYSDBG_ASSERT_SUSPEND  2
#define DSYSDBG_ASSERT_PROMPT   4
#define DSYSDBG_ASSERT_DEBUGGER 5

//
// Global Flags exposed to callers:
//

#define DEBUG_HEAP_CHECK    0x00000040      // Check Heap on every debug out
#define DEBUG_MULTI_THREAD  0x00000080      // Use critical section in header
#define DEBUG_BREAK_ON_ERROR 0x00000400     // Break on an error out

VOID    _DsysAssertEx(PVOID FailedAssertion, PVOID FileName, ULONG LineNumber,
                        PCHAR Message, ULONG ContinueCode);
VOID    _DebugOut(PVOID pControl, ULONG Mask, CHAR * Format, va_list ArgList);
VOID    _InitDebug(DWORD Flags, DWORD * InfoLevel, PVOID * Control, char * ModuleName, PDEBUG_KEY pKey);
VOID    _UnloadDebug( PVOID pControl );
VOID    _DbgSetOption(PVOID pControl, DWORD Flag, BOOL On, BOOL Global);
VOID    _DbgSetLoggingOption(PVOID pControl, BOOL On);
VOID    DbgpDumpException(PVOID p);

//  Hack to allow retail builds to include debug support
//  define RETAIL_LOG_SUPPORT in your sources to do it!
#ifdef RETAIL_LOG_SUPPORT
#define DEBUG_SUPPORT
#else
#if DBG
#define DEBUG_SUPPORT
#endif
#endif


#ifdef DEBUG_SUPPORT
//
// Use this in your header file.  It declares the variables that we need
//

#define DECLARE_DEBUG2(comp)                                \
extern PVOID    comp##ControlBlock;                         \
extern DWORD    comp##InfoLevel;                            \
void   comp##DebugPrint(ULONG Mask, CHAR * Format, ... );   \

//
// Use this when you control when you are initialized, for example a DLL or
// EXE.  This defines the wrapper functions that will call into dsysdbg.lib
//

#define DEFINE_DEBUG2(comp)                                 \
PVOID   comp##ControlBlock = NULL ;                         \
DWORD   comp##InfoLevel;                                    \
PVOID   comp##__DebugKeys;                                  \
void comp##DebugPrint(                                      \
    ULONG Mask,                                             \
    CHAR * Format,                                          \
    ... )                                                   \
{                                                           \
    va_list ArgList;                                        \
    va_start(ArgList, Format);                              \
    _DebugOut( comp##ControlBlock, Mask, Format, ArgList);  \
}                                                           \
void                                                        \
comp##InitDebugEx(DWORD Flags, PDEBUG_KEY pKey)             \
{                                                           \
    comp##__DebugKeys = pKey;                               \
    _InitDebug(Flags, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##InitDebug(PDEBUG_KEY  pKey)                           \
{                                                           \
    _InitDebug(0, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##SetOption(DWORD Option, BOOL On, BOOL Global)         \
{                                                           \
    _DbgSetOption( comp##ControlBlock, Option, On, Global); \
}                                                           \
void                                                        \
comp##SetLoggingOption(BOOL On)                             \
{                                                           \
   _DbgSetLoggingOption(comp##ControlBlock, On);            \
}                                                           \
void                                                        \
comp##UnloadDebug(void)                                     \
{                                                           \
    _UnloadDebug( comp##ControlBlock );                     \
    comp##ControlBlock = NULL ;                             \
}


//
// Use this when you don't control when you are initialized, e.g. a static
// library like the gluon code.
//
#define DEFINE_DEBUG_DEFER(comp,keys)                       \
PVOID       comp##ControlBlock = INVALID_HANDLE_VALUE;      \
DWORD       comp##InfoLevel;                    \
PDEBUG_KEY  comp##__DebugKeys = keys;                       \
void comp##DebugPrint(                                      \
    ULONG Mask,                                             \
    CHAR * Format,                                          \
    ... )                                                   \
{                                                           \
    va_list ArgList;                                        \
    va_start(ArgList, Format);                              \
    if (comp##ControlBlock == INVALID_HANDLE_VALUE)         \
    {                                                       \
        _InitDebug(DSYSDBG_DEMAND_OPEN, & comp##InfoLevel, & comp##ControlBlock, #comp, comp##__DebugKeys); \
    }                                                       \
    _DebugOut( comp##ControlBlock, Mask, Format, ArgList);  \
}                                                           \
void                                                        \
comp##InitDebugEx(DWORD Flags, PDEBUG_KEY pKey)             \
{                                                           \
    comp##__DebugKeys = pKey;                               \
    _InitDebug(Flags, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##InitDebug(PDEBUG_KEY  pKey)                           \
{                                                           \
    _InitDebug(DSYSDBG_DEMAND_OPEN, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##UnloadDebug(void)                                     \
{                                                           \
    _UnloadDebug( comp##ControlBlock );                     \
}


#else   // NOT DEBUG_SUPPORT

//
// Empty defines for the retail case:
//
#define DECLARE_DEBUG2(comp)

#define DEFINE_DEBUG2(comp)

#define DEFINE_DEBUG_DEFER(x, y)


#endif // DEBUG_SUPPORT 



#if DBG
//
// Moved assertions to new section, so no asserts occur in retail builds
// with DEBUG_SUPPORT. 
//
// Assertions:  Most should use DsysAssert or DsysAssertMsg.  These forward on
// the call to dsysdbg.lib, with the continue code set to drop into the
// debugger.  The more sophisticated can call DsysAssertEx, which allows you
// to specify one of the assert codes from above:
//

#define DsysAssertEx(exp, ContinueCode) \
            if (!(exp)) \
                _DsysAssertEx( #exp, __FILE__, __LINE__, NULL, ContinueCode);

#define DsysAssertMsgEx(exp, Message, ContinueCode) \
            if (!(exp)) \
                _DsysAssertEx( #exp, __FILE__, __LINE__, Message, ContinueCode);

#define DsysAssertMsg(exp, Message) DsysAssertMsgEx(exp, Message, DSYSDBG_ASSERT_DEBUGGER)


#define DsysAssert(exp) DsysAssertMsgEx(exp, NULL, DSYSDBG_ASSERT_DEBUGGER)

#define DsysException(p)    DbgpDumpException(p)

#define SZ_DEFAULT_PROFILE_STRING   "Error"         

#else // retail builds cannot contain asserts...


#define DsysAssertEx(x,y)
#define DsysAssertMsgEx(x, y, z)
#define DsysAssert(x)
#define DsysAssertMsg(x, y)

#define DsysException(p)

#define SZ_DEFAULT_PROFILE_STRING   ""

#endif // dbg


#ifndef DEB_ERROR
#define DEB_ERROR   0x00000001
#endif

#ifndef DEB_WARN
#define DEB_WARN    0x00000002
#endif

#ifndef DEB_TRACE
#define DEB_TRACE   0x00000004
#endif

#define DSYSDBG_FORCE   0x80000000
#define DSYSDBG_CLEAN   0x40000000


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSYSDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\gettgs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       gettgs.cxx
//
//  Contents:   GetTGSTicket and support functions
//
//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//              16-Sept-2001 yordanr modified for new interfaces
//
//----------------------------------------------------------------------------
#include "kdcsvr.hxx"
//#include "kdctrace.h"
#include <tostring.hxx>
#include "traceinterface.hxx"

#include "fileno.h"


#define FILENO  FILENO_GETTGS

extern LARGE_INTEGER tsInfinity;
extern LONG lInfinity;

UNICODE_STRING KdcNullString = {0,0,NULL};

//----------------------------------------------------------------
//
//  Name:       KdcInsertAuthorizationData
//
//  Synopsis:   Inserts auth data into a newly created ticket.
//
//  Arguments:
//              IN piKdb        - Provider Interface
//              IN RequestBody  - TGS request
//              IN SourceTicket - Source ticket - TGT
//              IN ServiceInfo  - Target service principal
//              IN TgtInfo      - TGT principal
//              IN TargetServiceKey - unused
//              IN pKdcReq      -   KDC request
//              OUT FinalTicket - Ticket to insert Auth data into
//              OUT pExtendedError - extended err info
//
//  Notes:      This copies the authorization data from the source ticket
//              to the destiation ticket, and adds the authorization data
//              passed in.  It is called by GetTGSTicket.
//
//              This assumes that pedAuthData is an encrypted
//              KERB_AUTHORIZATION_DATA.
//              It will copy all the elements of that list to the new ticket.
//              If pedAuthData is not supplied (or is empty), and there is
//              auth data in the source ticket, it is copied to the new
//              ticket.  If no source ticket, and no auth data is passed
//              in, nothing is done.
//
//----------------------------------------------------------------

KERBERR
KdcInsertAuthorizationData(
    IN PIKdbProvider piKdb,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET SourceTicket,
    IN OPTIONAL PIKerbPrincipal ServiceInfo,
    IN OPTIONAL PIKerbPrincipal TgtInfo,
    IN OPTIONAL PKERB_ENCRYPTION_KEY TargetServiceKey,
    IN OUT CKerbRequest* pKdcReq,
    OUT PKERB_ENCRYPTED_TICKET FinalTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    PKERB_AUTHORIZATION_DATA SourceAuthData = NULL;
    PKERB_AUTHORIZATION_DATA FinalAuthData = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    //NTSTATUS    Status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA_LIST * TempAuthData = NULL;
    PKERB_AUTHORIZATION_DATA SuppliedAuthData = NULL;
    PKERB_ENCRYPTED_DATA EncryptedAuthData = NULL;
    TRACER(L"KdcInsertAuthorizationData", (PVOID *) &KerbErr);

    D_DebugLog(( DEB_T_TICKETS, "Inserting authorization data into ticket.\n" ));

    //
    // First try to decrypt the supplied authorization data
    // from the TGS request
    //

    if (RequestBody->bit_mask & enc_authorization_data_present)
    {
        EncryptedAuthData = &RequestBody->enc_authorization_data;

        KerbErr = KerbDecryptDataEx(
                      EncryptedAuthData,
                      &SourceTicket->key,
                      KERB_NON_KERB_SALT,         // WAS BUG: wrong salt, removed per MikeSw
                      &EncryptedAuthData->cipher_text.length,
                      EncryptedAuthData->cipher_text.value
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to decrypt encrypted auth data: 0x%x", KerbErr));
            DebugLog((DEB_WARN,
                      "KLIN(%x) Failed to decrypt encrypted auth data: 0x%x\n",
                      KLIN(FILENO, __LINE__),
                      KerbErr));
            goto Cleanup;
        }

        //
        // Now decode user supplied authdata
        //

        KerbErr = KerbUnpackData(
            EncryptedAuthData->cipher_text.value,
            EncryptedAuthData->cipher_text.length,
            PKERB_AUTHORIZATION_DATA_LIST_PDU,
            (PVOID *) &TempAuthData
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to unpack auth data: 0x%x", KerbErr));
            goto Cleanup;
        }
        if (TempAuthData != NULL)
        {
            SuppliedAuthData = *TempAuthData;
        }
    }

    //
    // Check for authdata in the source ticket (TGT)
    //

    if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present)
    {
        DsysAssert(SourceTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL);
        SourceAuthData = SourceTicket->KERB_ENCRYPTED_TICKET_authorization_data;
    }


    //
    // Copy source authdata (from TGT)
    //

    if (SourceAuthData != NULL)
    {
        KerbErr = KerbCopyAndAppendAuthData(
            &FinalAuthData,
            SourceAuthData
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Copy supplied authdata (from TGS-REQ)
    //

    if (SuppliedAuthData != NULL)
    {
        KerbErr = KerbCopyAndAppendAuthData(
            &FinalAuthData,
            SuppliedAuthData
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Call authdata return handlers
    //

    KerbErr = KdcReturnAuthData(
                 pKdcReq,
                 &FinalAuthData,
                 pExtendedError);

    if (!KERB_SUCCESS(KerbErr))
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to return auth data: 0x%x", KerbErr));
        goto Cleanup;
    }


    //
    // setup ticket to return the data
    //
    if (FinalAuthData != NULL)
    {
        FinalTicket->bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
        FinalTicket->KERB_ENCRYPTED_TICKET_authorization_data = FinalAuthData;
        FinalAuthData = NULL;
    }

    KerbErr = KDC_ERR_NONE;

 Cleanup:

    KerbFreeAuthData(
        FinalAuthData
        );

    if (TempAuthData != NULL)
    {
        KerbFreeData(
            PKERB_AUTHORIZATION_DATA_LIST_PDU,
            TempAuthData
            );
    }

    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   BuildTicketTGS
//
//  Synopsis:   Builds (most of) a TGS ticket
//
//  Arguments:
//              IN piKdb          - provider interface
//              IN ServiceInfo    - service principal
//              IN RequestBody    - The request causing this ticket to be built
//              IN SourceTicke    - The TGT used to make this request
//              IN Referral       - TRUE if this is an inter-realm referral ticke
//              IN S4UClientName  - S4U client
//              INS4UClientRealm  - S4U Realm
//              IN pReq           - kerb request info
//              OUT NewTicket - The new ticket built here.
//              IN OUT pExtendedError
//
//
//  History:    24-May-93   WadeR   Created
//              16-Sept-201 yordanr modified for new interface
//
//  Notes:      see 3.3.3, A.6 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------


KERBERR
BuildTicketTGS(
    IN PIKdbProvider piKdb,
    IN PIKerbPrincipal           ServiceInfo,
    IN PKERB_KDC_REQUEST_BODY    RequestBody,
    IN PKERB_TICKET              SourceTicket,
    IN BOOLEAN                   Referral,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClientName,
    IN OPTIONAL PUNICODE_STRING S4UClientRealm,
    IN CKerbRequest             *pReq,
    OUT PKERB_TICKET             NewTicket,
    IN OUT PKERB_EXT_ERROR       ExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_TICKET OutputTicket;
    PKERB_ENCRYPTED_TICKET EncryptedTicket;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart;
    LARGE_INTEGER TicketLifespan;
    LARGE_INTEGER TicketRenewspan;
    UNICODE_STRING NewTransitedInfo = {0,0,NULL};
    UNICODE_STRING ClientRealm = {0,0,NULL};
    UNICODE_STRING TransitedRealm = {0,0,NULL};
    UNICODE_STRING OldTransitedInfo = {0,0,NULL};
    STRING OldTransitedString;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG SourceTicketFlags = 0;
    PKERB_HOST_ADDRESSES Addresses = NULL;

    TRACER(L"BuildTicketTGS", (PVOID *) &KerbErr);

    D_DebugLog(( DEB_T_TICKETS, "Building a TGS ticket\n" ));

    SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    OutputTicket = *NewTicket;
    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) OutputTicket.encrypted_part.cipher_text.value;

    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );

    //
    // Determine ticket lifetime
    //
    TicketLifespan = ServiceInfo->MaxLifeTime();
    TicketRenewspan = ServiceInfo->MaxRenewTime();

    KerbErr = KdcBuildTicketTimesAndFlags(
                0,                      // no client policy
                ServiceInfo->GetPrincFlags(),
                piKdb->GetKdcPolicy(),
                &TicketLifespan,
                &TicketRenewspan,
                NULL,                   // no acct expiry.
                RequestBody,
                SourceEncryptPart,
                EncryptedTicket,
                ExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build ticket times and flags: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    TicketFlags = KerbConvertFlagsToUlong( &EncryptedTicket->flags );
    SourceTicketFlags = KerbConvertFlagsToUlong( &SourceEncryptPart->flags );

    KerbErr = KerbMakeKey(
                pReq->GetCommonEType(),
                &EncryptedTicket->key
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    OldTransitedString.Buffer = (PCHAR) SourceEncryptPart->transited.contents.value;
    OldTransitedString.Length = OldTransitedString.MaximumLength = (USHORT) SourceEncryptPart->transited.contents.length;


    //
    // Fill in the service names
    //

    if (Referral)
    {

        //
        // For referral tickets we put a the name
        //   "krbtgt/remoterealm@localrealm"
        //

        KerbErr = KerbConvertKdcNameToPrincipalName(
                    &OutputTicket.server_name,
                    ServiceInfo->GetName()
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        //
        // If we got here on a referral ticket and are generating one
        // and the referral ticket we received was not from the client's
        // realm, add in the transited information.
        //

        if (!KerbCompareRealmNames(
                &SourceEncryptPart->client_realm,
                &SourceTicket->realm))
        {


            KerbErr = KerbStringToUnicodeString(
                        &OldTransitedInfo,
                        &OldTransitedString
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                        &TransitedRealm,
                        &SourceTicket->realm
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                        &ClientRealm,
                        &SourceEncryptPart->client_realm
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KdcInsertTransitedRealm(
                        &NewTransitedInfo,
                        &OldTransitedInfo,
                        &ClientRealm,
                        &TransitedRealm,
                        //  realm is in the request
                        pReq->GetRequestRealm()
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }

        KerbErr = KerbConvertUnicodeStringToRealm(
                     &OutputTicket.realm,
                     ServiceInfo->GetRealm()
                     );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }
    else
    {

        //
        // If the client didn't request name canonicalization, use the
        // name supplied by the client
        //

        if ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
        {
            if (KdcIsKrbtgt(ServiceInfo->GetName()))
            {
                PKERB_INTERNAL_NAME TempServiceName = NULL;
                NTSTATUS Status;

                //
                //  Get TGT name from realm
                //

                Status = KerbBuildFullServiceKdcName(
                             pReq->GetRequestRealm(),
                             &KrbtgtName,
                             KRB_NT_SRV_INST,
                             &TempServiceName);

//                Status = KdcRealmGetKrbTgtName(KdbHandle, &TempServiceName);

                if (!NT_SUCCESS(Status))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }

                KerbErr = KerbConvertKdcNameToPrincipalName(
                            &OutputTicket.server_name,
                            TempServiceName
                            );

                KerbFreeKdcName(&TempServiceName);

            }
            else

            //
            //  if NC is requested, use the name from the principal interface
            //
            {
                KerbErr = KerbConvertKdcNameToPrincipalName(
                            &OutputTicket.server_name,
                            ServiceInfo->GetName()
                            );
            }
        }
        else
        {

            KerbErr = KerbDuplicatePrincipalName(
                        &OutputTicket.server_name,
                        &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                        );
        }

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        KerbErr = KerbDuplicateRealm(
                     &OutputTicket.realm,
                     RequestBody->realm
                     );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }

    //
    // Copy all the other strings over
    //

    EncryptedTicket->client_realm = SourceEncryptPart->client_realm;


    //
    // S4U dance...  Get the client name and realm from
    //
    if (ARGUMENT_PRESENT(S4UClientName) &&
        ARGUMENT_PRESENT(S4UClientRealm) &&
        !Referral)
    {
        KerbErr = KerbConvertKdcNameToPrincipalName(
                        &EncryptedTicket->client_name,
                        S4UClientName
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertUnicodeStringToRealm(
                    &EncryptedTicket->client_realm,
                    S4UClientRealm
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }
    else
    {
        KerbErr = KerbDuplicatePrincipalName(
                    &EncryptedTicket->client_name,
                    &SourceEncryptPart->client_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        EncryptedTicket->client_realm = SourceEncryptPart->client_realm;

    }


    //
    // Insert transited realms, if present
    //

    if (NewTransitedInfo.Length != 0)
    {
        STRING TempString;
        KerbErr = KerbUnicodeStringToKerbString(
                    &TempString,
                    &NewTransitedInfo
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) TempString.Buffer;
        EncryptedTicket->transited.contents.length = (int) TempString.Length;

    }
    else
    {

        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) MIDL_user_allocate(OldTransitedString.Length);
        if (EncryptedTicket->transited.contents.value == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        EncryptedTicket->transited.contents.length = (int) OldTransitedString.Length;
        memcpy(
            EncryptedTicket->transited.contents.value,
            OldTransitedString.Buffer,
            OldTransitedString.Length
            );

    }

    //
    // Insert the client addresses. We only update them if the new ticket
    // is forwarded of proxied and the source ticket was forwardable or proxiable
    // - else we copy the old ones
    //

    if ((((TicketFlags & KERB_TICKET_FLAGS_forwarded) != 0) &&
         ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) != 0)) ||
        (((TicketFlags & KERB_TICKET_FLAGS_proxy) != 0) &&
         ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) != 0)))
    {
        if ((RequestBody->bit_mask & addresses_present) != 0)
        {
            Addresses = RequestBody->addresses;
        }
    }
    else
    {
        if ((SourceEncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0)
        {
            Addresses = SourceEncryptPart->KERB_ENCRYPTED_TICKET_client_addresses;
        }
    }

    if (Addresses != NULL)
    {
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = Addresses;
        EncryptedTicket->bit_mask |= KERB_ENCRYPTED_TICKET_client_addresses_present;
    }
    else
    {
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = NULL;
        EncryptedTicket->bit_mask &= ~KERB_ENCRYPTED_TICKET_client_addresses_present;
    }

    //
    // The authorization data will be added by the caller, so set it
    // to NULL here.
    //

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;


    OutputTicket.ticket_version = KERBEROS_VERSION;
    *NewTicket = OutputTicket;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(&OutputTicket);
    }

    KerbFreeString(&NewTransitedInfo);
    KerbFreeString(&OldTransitedInfo);
    KerbFreeString(&ClientRealm);
    KerbFreeString(&TransitedRealm);
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildReferralInfo
//
//  Synopsis:   Builds the referral information to return to the client.
//              We only return the realm name and no server name
//
//  Effects:
//
//  Arguments:  ReferralRealm - realm to refer client to
//              ReferralInfo - recevies encoded referral info
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE        success
//              KDC_ERR_GENERIC     out of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildReferralInfo(
    IN const UNICODE_STRING * ReferralRealm,
    OUT PKERB_PA_DATA_LIST *ReferralInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST ListElem = NULL;
    KERB_PA_SERV_REFERRAL ReferralData = {0};
    TRACER(L"KdcBuildReferralInfo", (PVOID *) &KerbErr);

    //
    // Fill in the unencoded structure.
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                  &ReferralData.referred_server_realm,
                  ReferralRealm
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    ListElem = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElem == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ZeroMemory(ListElem, sizeof(KERB_PA_DATA_LIST));

    ListElem->value.preauth_data_type = KRB5_PADATA_REFERRAL_INFO;

    KerbErr = KerbPackData(
                  &ReferralData,
                  KERB_PA_SERV_REFERRAL_PDU,
                  (PULONG) &ListElem->value.preauth_data.length,
                  &ListElem->value.preauth_data.value
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    *ReferralInfo = ListElem;
    ListElem = NULL;

Cleanup:
    if (ListElem != NULL)
    {
        if (ListElem->value.preauth_data.value != NULL)
        {
            KdcFreeEncodedData(ListElem->value.preauth_data.value);
        }
        MIDL_user_free(ListElem);
    }

    KerbFreeRealm(&ReferralData.referred_server_realm);

    return KerbErr;
}


//--------------------------------------------------------------------
//
//  Name:       KdcGetReferralTicket
//
//  Synopsis:   Find a trust to a realm that may have this service
//
//  Arguments:
//              IN piKdb          - provider interface
//              IN Referral realm - realm name
//              OUT ServiceInfo   - realm principal
//              OUT pExtendedError
//
//  Notes:
//
//
//--------------------------------------------------------------------

KERBERR
KdcGetReferralTicket(
    IN PIKdbProvider piKdb,
    IN const UNICODE_STRING * ReferralRealm,
    OUT PIKerbPrincipal *ServiceInfo,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
    NTSTATUS Status;
    PKERB_INTERNAL_NAME CrossRealmTgtName = NULL;
    TRACER(L"KdcGetReferralTicket", (PVOID *) &KerbErr);

    Status = KerbBuildFullServiceKdcName(
                  ReferralRealm,
                  &KrbtgtName,
                  KRB_NT_SRV_INST,
                  &CrossRealmTgtName
                  );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = piKdb->GetPrincipal(
                  KDC_KDB_GET_PRINC_SERVER,
                  CrossRealmTgtName,
                  NULL,
                  NULL,  // may need to carry IKerbRequest
                  ServiceInfo,
                  pExtendedError,
                  NULL
                  );

    KerbFreeKdcName(&CrossRealmTgtName);

Cleanup:

    return KerbErr;
}


//--------------------------------------------------------------------
//
//  Name:       I_RenewTicket
//
//  Synopsis:   Renews an internal ticket.
//
//  Arguments:  IN piKdb         - provider interface
//              IN SourceTicket - Source ticket for this request
//              IN ServiceName - Name of service for ticket
//              IN ServiceInfo - service principal
//              IN RequestBody - Body of ticket request
//              IN pKerbReq    - Request info
//              OUT CommonEType - Receives common encryption type for service ticket
//              OUT NewTicket - Receives new ticket
//              OUT pExtendedError -
//
//  Notes:      Validates the ticket, gets the service's current key,
//              and builds the reply.
//
//
//--------------------------------------------------------------------


KERBERR
I_RenewTicket(
    IN PIKdbProvider piKdb,
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PIKerbPrincipal ServiceInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN CKerbRequest *pKerbReq,
    OUT PULONG CommonEType,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart =
        (PKERB_ENCRYPTED_TICKET)
            SourceTicket->encrypted_part.cipher_text.value;
    PKERB_ENCRYPTED_TICKET NewEncryptPart =
        (PKERB_ENCRYPTED_TICKET)
            NewTicket->encrypted_part.cipher_text.value;
//    PKERB_KEY_DATA ServerKey;
    BOOLEAN NamesEqual = FALSE;

    TRACER(L"I_RenewTicket", (PVOID *) &KerbErr);



    D_DebugLog(( DEB_TRACE, "Trying to renew a ticket to "));
    D_KerbPrintKdcName(DEB_TRACE, ServiceName );


    //
    // Make sure the original is renewable.
    //

    if ((KerbConvertFlagsToUlong(&SourceEncryptPart->flags) & KERB_TICKET_FLAGS_renewable) == 0)
    {
        D_DebugLog((DEB_WARN, "KLIN(%x) Attempt made to renew non-renewable ticket\n",
            KLIN(FILENO, __LINE__)));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Make sure the source ticket service equals the service from the ticket info
    //

    KerbErr = KerbCompareKdcNameToPrincipalName(
                &SourceTicket->server_name,
                ServiceName,
                &NamesEqual
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (!NamesEqual)
    {
        //
        // Make sure we the renewed ticket is for the same service as the original.
        //
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);

        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Build the renewal ticket
    //

    KerbErr = BuildTicketTGS(
                piKdb,
                ServiceInfo,
                RequestBody,
                SourceTicket,
                FALSE,          // not referral
                NULL,           // not doing s4u
                NULL,           // not doing s4u
                pKerbReq,
                NewTicket,
                pExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,
            "KLIN(%x) Failed to build TGS ticket for renewal: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }


    //
    // BuildTicket puts a random session key in the ticket,
    // so replace it with the one from the source ticket.
    //

    KerbFreeKey(
        &NewEncryptPart->key
        );

    KerbErr = KerbDuplicateKey(
                &NewEncryptPart->key,
                &SourceEncryptPart->key
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    //
    // Insert the auth data into the new ticket.
    //

    //
    // BUG 455049: if the service password changes, this will cause problems
    // because we don't resign the pac.
    //


    KerbErr = KdcInsertAuthorizationData(
                piKdb,
                RequestBody,
                SourceEncryptPart,
                ServiceInfo,
                NULL,   // oldkey
                NULL,   // newkey
                pKerbReq,
                NewEncryptPart,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert authorization data: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(
            NewTicket
            );
    }

    return(KerbErr);

}

//--------------------------------------------------------------------
//
//  Name:       I_Validate
//
//  Synopsis:   Validates a post-dated ticket so that it can be used.
//              This is not implemented.
//
//  Arguments:  IN piKdb            - provider interface
//              IN SourceTicket     - ticket to be validated
//              IN ServiceName      - unused
//              IN ClientRealm      - LSA only
//              IN RequestBody      - holds nonce for new ticket
//              IN pKdcReq
//              OUT CommonEType
//              OUT NewTicket       - new ticket
//              OUT pExtendedError
//
//  Notes:      See 3.3 of the Kerberos V5 R5.2 spec
//              yordanr - these needs more detailed comments
//
//--------------------------------------------------------------------


KERBERR
I_Validate(
    IN PIKdbProvider piKdb,
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN CKerbRequest *pKdcReq,
    OUT PULONG CommonEType,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    return(KRB_ERR_GENERIC);
#ifdef notdef
    TRACER(L"I_Validate", (PVOID *) &KerbErr);

    HRESULT hr;
    const KDC_POLICY_VALUES *pPolicy = piKdc->GetKdcPolicy();

    D_DebugLog(( DEB_TRACE, "Trying to validate a ticket to '%ws' for '%ws'...\n",
                pkitSourceTicket->ServerName.accsid.pwszDisplayName,
                pkitSourceTicket->kitEncryptPart.Principal.accsid.pwszDisplayName ));
    PrintRequest( DEB_T_TICKETS, pktrRequest );
    PrintTicket( DEB_T_TICKETS, "Ticket to validate:", pkitSourceTicket );


    if ( (pkitSourceTicket->kitEncryptPart.fTicketFlags &
            (KERBFLAG_POSTDATED | KERBFLAG_INVALID))
         != (KERBFLAG_POSTDATED | KERBFLAG_INVALID) )
    {
        hr = KDC_E_BADOPTION;
    }
    else if (_wcsicmp(pkitSourceTicket->ServerName.accsid.pwszDisplayName,
                     pasService->pwszDisplayName) != 0)
    {
        hr = KDC_E_BADOPTION;
    }
    else
    {
        TimeStamp tsNow, tsMinus, tsPlus;
        GetCurrentTimeStamp( &tsNow );
        tsMinus = tsNow - pPolicy->TimeSkew;
        tsPlus = tsNow + pPolicy->TimeSkew;
        PrintTime(DEB_TRACE, "Current time: ", tsNow );
        PrintTime(DEB_TRACE, "Past time: ", tsMinus );
        PrintTime(DEB_TRACE, "Future time: ", tsPlus );

        if (pkitSourceTicket->kitEncryptPart.tsStartTime > tsPlus )
            hr = KRB_E_TKT_NYV;
        else if (pkitSourceTicket->kitEncryptPart.tsEndTime < tsMinus )
            hr = KRB_E_TKT_EXPIRED;
        else
        {

            *pkitTicket = *pkitSourceTicket;
            pkitTicket->kitEncryptPart.fTicketFlags &= (~KERBFLAG_INVALID);
            hr = S_OK;
        }
    }
    return(hr);
#endif // notdef
}



//--------------------------------------------------------------------
//
//  Name:       I_GetTGSTicket
//
//  Synopsis:   Gets an internal ticket using a KDC ticket (TGT).
//
//  Arguments:  IN piKdb        - provider interface
//              IN SourceTicket - TGT for the client
//              IN ClientName   - client requesting a tkt
//              IN ServiceName  - Service to get a ticket to
//              IN ServiceRealm - realm of the service
//              IN RequestBody  - Body of KDC request message
//              IN ApServiceInfo - Ticket info for the service of the
//                      source ticket
//              IN TicketEncryptionKey - If present, then this is a
//                      enc_tkt_in_skey request and the PAC should be
//                      encrypted with this key.
//              OUT RetServiceInfo - target service principal
//              IN  pKerbReq    - request info
//              OUT Ticket      - Receives newly created ticket
//              OUT ReplyPaData - Contains any PA data to put in the reply
//              OUT pExtendedError
//
//  Notes:      See GetTGSTicket.
//
//
//--------------------------------------------------------------------


KERBERR
I_GetTGSTicket(
    IN PIKdbProvider piKdb,
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN const UNICODE_STRING * ServiceRealm,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PIKerbPrincipal ApServiceInfo,                   // i.e. krbtgt
    IN OPTIONAL PKERB_ENCRYPTION_KEY TicketEncryptionKey,
    OUT PIKerbPrincipal *RetServiceInfo,
    IN CKerbRequest *pKerbReq,
    OUT PULONG CommonEType,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_PA_DATA_LIST * ReplyPaData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS    Status = STATUS_SUCCESS;
    UNICODE_STRING LocalServiceName;
    BOOLEAN Referral = FALSE;
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    PKERB_ENCRYPTED_TICKET OutputEncryptedTicket = NULL;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = NULL;
    KERB_TICKET NewTicket = {0};
//    PKERB_KEY_DATA ServerKey = NULL;
//    PKERB_ENCRYPTION_KEY OldServerKey;
    PIKerbPrincipal ServiceInfo = NULL;
    ULONG NameFlags = 0;
    ULONG KdcOptions = 0;
    TRACER(L"I_GetTGSTicket", (PVOID *) &KerbErr);


    //
    // Store away the encrypted ticket from the output ticket to
    // assign it at the end.
    //
    SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    OutputEncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;

    NewTicket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    //
    // Copy the space for flags from the real destination.
    //

    EncryptedTicket.flags = OutputEncryptedTicket->flags;

    LocalServiceName.Buffer = NULL;

    D_DebugLog(( DEB_TRACE, "Trying to build a new ticket to "));
    D_KerbPrintKdcName( DEB_TRACE, ServiceName );


    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );
    if (KdcOptions & (KERB_KDC_OPTIONS_unused7 |
                        KERB_KDC_OPTIONS_reserved |
                        KERB_KDC_OPTIONS_unused9) )
    {
        DebugLog(( DEB_ERROR,"KLIN(%x) Bad options in TGS request: 0x%x\n",
            KLIN(FILENO, __LINE__), KdcOptions ));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Check if the client said to canonicalize the name
    //

    //if ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
    {
        NameFlags |= KDC_KDB_GET_PRINC_CANONICALIZE;
    }


    //
    // Verify this account is allowed to issue tickets.
    //

    if (!KdcIsKrbtgt(ApServiceInfo->GetName()))
    {
        D_DebugLog((DEB_ERROR,"Trying to make a TGS request with a ticket to\n"));
        KerbPrintKdcName(DEB_ERROR, ApServiceInfo->GetName());

        KerbErr = KRB_AP_ERR_NOT_US;
        goto Cleanup;
    }

    //
    // Get the requested target principal
    //

    KerbErr = piKdb->GetPrincipal(
                 NameFlags | KDC_KDB_GET_PRINC_SERVER |
                        KDC_KDB_GET_PRINC_FOLLOW_REFERRALS,
                 ServiceName,
                 ServiceRealm->Buffer,
                 pKerbReq,
                 &ServiceInfo,                 // ServiceName
                 pExtendedError,
                 NULL
                 );

    //
    // If the KDB cannot provide a principal, try to create
    // a referral as long as the request indicates that
    // a referral will be accepted.
    //
    if ((KerbErr == KDC_ERR_S_PRINCIPAL_UNKNOWN) &&
        (ServiceRealm == NULL) &&
        ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0))
    {

        //
        // See if we can manufacture a referral
        //

        KerbErr = KdcGetReferralTicket(
                     piKdb,
                     ServiceRealm,
                     &ServiceInfo,
                     pExtendedError
                     );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"KLIN(%x) Failed to find target in requested realm ", KLIN(FILENO, __LINE__)));
        KerbPrintKdcName(DEB_WARN,ServiceName);
        DebugLog((DEB_WARN,"\t 0x%x\n",KerbErr));
        goto Cleanup;
    }

    DsysAssert(ServiceInfo != NULL);
    pKerbReq->m_piServerPrincipal = ServiceInfo;
    //  here we can also recalculate the etype
    const ETYPE*    pETypes = NULL;
    ULONG   cEtypes = 0;
    ServiceInfo->GetEtypes(&pETypes, &cEtypes);
    Status = KerbFindCommonEType(RequestBody->encryption_type,
                                 cEtypes,
                                 pETypes,
                                 CommonEType);
    if (!NT_SUCCESS(Status))
    {
        //  no etype match
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto    Cleanup;
    }

    if ((!KdcIsKrbtgt(ServiceInfo->GetName())) &&
        ((ServiceInfo->GetPrincFlags() & KERB_KDB_DISALLOW_ALL_TIX) != 0))
    {
        KerbErr = KDC_ERR_CLIENT_REVOKED;
        D_DebugLog((DEB_WARN,"KLIN(%x) Failed to normalize, account is disabled ",
                    KLIN(FILENO, __LINE__)));
        KerbPrintKdcName(DEB_WARN, ServiceName);
        D_DebugLog((DEB_WARN,"\t 0x%x\n",KerbErr));
        FILL_EXT_ERROR(pExtendedError, STATUS_ACCOUNT_DISABLED, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // If we got back a krbtgt but didn't request one, then this is a referral
    //

    if (KdcIsKrbtgt(ServiceInfo->GetName()) &&
        !KdcIsKrbtgt(ServiceName))
    {
        //  hmmm what kind of assignment should we do here?
        ServiceRealm = ServiceInfo->GetRealm();
        Referral = TRUE;
    }

    //
    // Check KDB ticket restrictions - unless you are requesting a ticket
    // to yourself.
    //

    if (!KerbEqualKdcNames(ClientName, ServiceName))
    {
        if (ServiceInfo->GetPrincFlags() & KERB_KDB_DISALLOW_SVR)
        {
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;

            DebugLog((DEB_ERROR,"KLIN(%x) Service principal not allowed ",
                      KLIN(FILENO,__LINE__), KerbErr ));
            KerbPrintKdcName(DEB_ERROR, ServiceName);
            goto Cleanup;
        }

        if (ServiceInfo->GetPrincFlags() & KERB_KDB_REQUIRE_USER2USER)
        {
            KerbErr = KDC_ERR_MUST_USE_USER2USER;

            DebugLog((DEB_ERROR,"KLIN(%x) Service principal requires user2user ",
                      KLIN(FILENO,__LINE__), KerbErr ));
            KerbPrintKdcName(DEB_ERROR, ServiceName);
            goto Cleanup;
        }
    }

    //
    // If this isn't an interdomain trust account, go ahead and issue a normal
    // ticket.
    //

    if (!KdcIsKrbtgt(ServiceInfo->GetName()))
    {
        //
        // Check whether service is interactive, 'cause you can't
        // get a ticket to an interactive service.
        //
        KerbErr = BuildTicketTGS(
                    piKdb,
                    ServiceInfo,
                    RequestBody,
                    SourceTicket,
                    Referral,
                    NULL,
                    NULL,
                    pKerbReq,
                    &NewTicket,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build TGS ticket for %wZ : 0x%x\n",
                    KLIN(FILENO, __LINE__), &LocalServiceName, KerbErr ));
            goto Cleanup;
        }
    }
    else
    {
        //
        // Need to build a referal ticket.
        //

        D_DebugLog(( DEB_T_KDC, "GetTGSTicket: referring to domain "));
        KerbPrintKdcName(
            DEB_WARN,
            ServiceInfo->GetName()
            );

        //
        // build the tgs
        //
        KerbErr = BuildTicketTGS(
                    piKdb,
                    ServiceInfo,
                    RequestBody,
                    SourceTicket,
                    TRUE,
                    NULL,  // not doing s4u
                    NULL,  // not doing s4u
                    pKerbReq,
                    &NewTicket,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build TGS ticket 0x%x for: ",
                    KLIN(FILENO, __LINE__), KerbErr ));
            D_KerbPrintKdcName(
                DEB_ERROR,
                ApServiceInfo->GetName()
                );

            goto Cleanup;
        }


        //
        // If this is a referral, return the target realm
        //

        if (Referral && ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0))
        {

            D_DebugLog((DEB_TRACE,"Building referral info for realm %wZ\n",
                        ServiceRealm ));

            KerbErr = KdcBuildReferralInfo(
                        ServiceRealm,
                        ReplyPaData
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }

    }

    //
    // Insert the auth data into the new ticket.
    //

    KerbErr = KdcInsertAuthorizationData(
                piKdb,
                RequestBody,
                (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value,
                ServiceInfo,
                ApServiceInfo,
                // only possibility is the ticket key. If it's NULL
                //  the API should use the server key
                TicketEncryptionKey,
                pKerbReq,
                &EncryptedTicket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert authorization data: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    *Ticket = NewTicket;
    *OutputEncryptedTicket = EncryptedTicket;
    Ticket->encrypted_part.cipher_text.value = (PUCHAR) OutputEncryptedTicket;

    *RetServiceInfo = ServiceInfo;
    ServiceInfo = NULL;

    if (Referral)
        KdbPerfCount(piKdb, KerbKdcTgsReferralCounter);

Cleanup:

    //
    //  only release if ownership has not been taken
    //
    if (ServiceInfo && !pKerbReq->m_piServerPrincipal)
        ServiceInfo->Release();

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(
            &NewTicket
            );
    }

    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackAdditionalTickets
//
//  Synopsis:   Unpacks the AdditionalTickets field of a KDC request
//              and (a) verifies that the ticket is TGT for this realm
//              and (b) the ticket is encrypted with the corret key and
//              (c) the ticket is valid
//
//  Effects:    allocate output ticket
//
//  Arguments:  IN piKdb      - provider
//              IN KdcOptions - request flags
//              IN TicketList - tickets to unpack
//              OUT U2UTicket - resulting U2U ticket
//              IN pKerbReq   - request info
//
//  Requires:
//
//  Returns:
//
//  Notes:      there can only be one additional ticket
//
//
//--------------------------------------------------------------------------


KERBERR
KdcUnpackAdditionalTickets(
    IN PIKdbProvider piKdb,
    IN ULONG KdcOptions,
    IN PKERB_TICKET_LIST TicketList,
    OUT PKERB_ENCRYPTED_TICKET * U2UTicket,
    IN  CKerbRequest *pKerbReq,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
//    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    UNICODE_STRING ServerNames[1] = {0};
//    PKERB_ENCRYPTION_KEY EncryptionKey = NULL;
    PKERB_TICKET Ticket;
    KERB_REALM LocalRealm = NULL;
    PIKerbPrincipal KrbtgtInfo = NULL;
    TRACER(L"KdcUnpackAdditionalTickets", (PVOID *) &KerbErr);

    *U2UTicket = NULL;

    //
    // Verify that there is a ticket & that there is only one ticket
    //

    if (TicketList == NULL)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Trying to unpack null ticket\n",
                  KLIN(FILENO, __LINE__)));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    //
    // Handle User2User additional ticket
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0)
    {

        //
        // Ticket is encrypted in the KRBTGT key
        //

        //  BUGBUG todo: check that logic!!!
        //  krbtgt should be already known, why get it again???
        //  let's assume KerbTgt is kept in ClientPrincipal in KerbRequest
        KrbtgtInfo = pKerbReq->GetIPrincClient();
        Ticket = &TicketList->value;

        //
        // Verify the ticket, first with the normal password list
        //


        KerbErr = KerbConvertKdcNameToString(
                      &ServerNames[0],
                      KrbtgtInfo->GetName(),
                      NULL
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto    Cleanup;
        }

        //
        // NOTE: we only allow additional tickets from our realm. This
        // means cross-realm TGTs can't be used as additional tickets.
        //

        KerbErr = KerbVerifyTicket(
                     pKerbReq,
                     Ticket,
                     1,
                     ServerNames,
                     // hmm ... this could be multiple realms
                     KrbtgtInfo->GetRealm(),
                     KrbtgtInfo,
                     // pass the enc. type along with principal
                     // actually assume the etype is the same as the request
                     // match. there's no reason to be otherwise for tickets
                     // coming from the same client
                  //   Ticket->encrypted_part.encryption_type,
                     &piKdb->GetKdcPolicy()->TimeSkew,
                     &EncryptedTicket,
                     pExtendedError
                     );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to verify additional ticket: 0x%x\n",
                      KLIN(FILENO, __LINE__),KerbErr));
            goto Cleanup;
        }

        //  hmm again this needs to be changed for multiple realms support!
        //  most likely the realm has to come from the req.

        KerbErr = KerbConvertUnicodeStringToRealm(
                      &LocalRealm,
                      pKerbReq->GetRequestRealm()
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto    Cleanup;
        }
//        Status = KdcRealmGetName(piKdb, &LocalRealm);

        //
        // Verify the realm of the ticket
        //

        if (!KerbCompareRealmNames(
                &LocalRealm,
                &Ticket->realm
            ))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Additional ticket realm is wrong: %s instead of %s\n",
                        KLIN(FILENO, __LINE__), Ticket->realm, LocalRealm));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }

        //
        // Verify the realm of the client is the same as our realm
        //

        if (!KerbCompareRealmNames(
                &LocalRealm,
                &EncryptedTicket->client_realm
            ))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Additional ticket client realm is wrong: %s instead of %s\n",
                        KLIN(FILENO, __LINE__),EncryptedTicket->client_realm, LocalRealm));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }

        *U2UTicket = EncryptedTicket;
        EncryptedTicket = NULL;

        //
        // Pickup the next additional ticket
        //

        TicketList = TicketList->next;
    }


    //
    // Handle Service4User additional ticket
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_cname_in_addl_tkt) != 0)
    {

        //
        // Ticket is encrypted in the service key
        //


        //
        // Locate and extract the PAC in the ticket, then save (replace)
        // the current PAC in the context.
        //
    }


Cleanup:
    KerbFreeString(&ServerNames[0]);
    KerbFreeRealm(&LocalRealm);

    if (EncryptedTicket != NULL)
    {
        KerbFreeTicket(EncryptedTicket);
    }

    return(KerbErr);

}

//--------------------------------------------------------------------
//
//  Name:       KdcFindS4UClientAndRealm
//
//  Synopsis:   Decodes PA DATA to find PA_DATA_FOR_USER entry.
//
//  Effects:    Get a client name and realm for processing S4U request
//
//  Arguments:  PAList       - Preauth data list from TGS_REQ
//              ClientRealm  - Target for client realm
//              ClientName   - Principal to get S4U ticket for
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:  Free client name and realm w/
//
//
//--------------------------------------------------------------------------
KERBERR
KdcFindS4UClientAndRealm(
    IN      PKERB_PA_DATA_LIST PaList,
    IN OUT  PUNICODE_STRING ClientRealm,
    IN OUT  PKERB_INTERNAL_NAME * ClientName
    )
{

    KERBERR KerbErr = KRB_ERR_GENERIC;
    PKERB_PA_DATA PaData = NULL;
    PKERB_PA_FOR_USER S4URequest = NULL;
    TRACER(L"KdcFindS4UClientAndRealm", (PVOID *) &KerbErr);

    *ClientName = NULL;
    RtlInitUnicodeString(
        ClientRealm,
        NULL
        );


    PaData = KerbFindPreAuthDataEntry(
                KRB5_PADATA_S4U,
                PaList
                );

    if (NULL == PaData)
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                    PaData->preauth_data.value,
                    PaData->preauth_data.length,
                    KERB_PA_FOR_USER_PDU,
                    (PVOID* ) &S4URequest
                    );


    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to unpack PA_FOR_USER\n"));
        goto Cleanup;
    }


    KerbErr = KerbConvertRealmToUnicodeString(
                    ClientRealm,
                    &S4URequest->userRealm
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbConvertPrincipalNameToKdcName(
                    ClientName,
                    &S4URequest->userName
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


Cleanup:


    if (S4URequest != NULL)
    {
        KerbFreeData(
            KERB_PA_FOR_USER_PDU,
            S4URequest
            );

    }

    return KerbErr;

}


//--------------------------------------------------------------------
//
//  Name:       HandleTGSRequest
//
//  Synopsis:   Gets a ticket using a KDC ticket (TGT).
//
//  Effects:    Allocates and encrypts a KDC reply
//
//  Arguments:  IN ClientAddress - Optionally contains client IP address
//              IN RequestMessage - contains the TGS request message
//              IN RequestRealm - The realm of the request, from the request
//                      message
//              OUT OutputMessage - Contains the buffer to send back to the client
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
HandleTGSRequest(
    IN OPTIONAL SOCKADDR * ClientAddress,
    IN PKERB_TGS_REQUEST RequestMessage,
    IN PUNICODE_STRING RequestRealm,
    OUT PKERB_MESSAGE_BUFFER OutputMessage,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;

    IKdbProvider *piKdb = NULL;                // RequestRealm

    PIKerbPrincipal ServerInfo = NULL;          // i.e. server
    PIKerbPrincipal TgtClientInfo = NULL;       // i.e. user
    PIKerbPrincipal TgtServerInfo = NULL;       // i.e. krbtgt

    KERB_TICKET SourceTicket = {0};
    KERB_TICKET NewTicket = {0};
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = NULL;
    PKERB_ENCRYPTED_TICKET User2UserTicket = NULL;

    PKERB_KDC_REQUEST_BODY RequestBody = &RequestMessage->request_body;
    KERB_TGS_REPLY Reply = {0};
    KERB_ENCRYPTED_KDC_REPLY ReplyBody = {0};
    PKERB_AP_REQUEST UnmarshalledApRequest = NULL;
    PKERB_PA_DATA ApRequest = NULL;
    PKERB_PA_DATA_LIST ReplyPaData = NULL;
    PKERB_PA_DATA_LIST OutputPreAuthData = NULL;
    KERB_ENCRYPTION_KEY ReplyKey = {0};
    KERB_ENCRYPTION_KEY EncryptionKey = {0};
    PIKerbPrincipal Tgt = NULL;
    KERB_KEY_DATA SessionKey = {0};
    PKERB_KEY_DATA ServerKey;
    PKERB_INTERNAL_NAME ServerName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING ClientStringName = {0};
    UNICODE_STRING ServerStringName = {0};

    ULONG CommonEType;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG ReplyTicketFlags = 0;
    ULONG PreAuthType = 0;

    BOOLEAN Validating = FALSE;
    BOOLEAN UseSubKey = FALSE;
    BOOLEAN Renew = FALSE;
    BOOLEAN CheckAdditionalTicketMatch = FALSE;

    CKerbRequest KdcReq;
    KdcReq.m_pKdcRequest = RequestMessage;
    KdcReq.m_pClientAddress = ClientAddress;

#ifdef KDC_WMI_TRACING
    KDC_TGS_EVENT_INFO TGSEventTraceInfo = {0};
#endif

    TRACE(KDC, HandleTGSRequest, DEB_FUNCTION);
    TRACER(L"HandleTGSRequest", (PVOID *) &KerbErr);
    //
    // Initialize [out] structures, so if we terminate early, they can
    // be correctly marshalled by the stub
    //

    NewTicket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    EncryptedTicket.flags.value = (PUCHAR) &TicketFlags;
    EncryptedTicket.flags.length = sizeof(ULONG) * 8;
    ReplyBody.flags.value = (PUCHAR) &ReplyTicketFlags;
    ReplyBody.flags.length = sizeof(ULONG) * 8;

    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );

    //
    // Initialize the Request context
    //
    Status = KdcReq.CreateHandlerInstances();
    if (!NT_SUCCESS(Status))
    {
        //  todo: BUGBUG log/trace?
        KerbErr =   KRB_ERR_GENERIC;
        goto Cleanup;
    }
    KdcReq.m_ServId = KerbTgs;
    KdcReq.m_pETypes= (PKERB_CRYPT_LIST)(RequestBody->encryption_type);

    //
    // Start event tracing
    //
#ifdef KDC_WMI_TRACING
    if (KdcEventTraceFlag){

        TGSEventTraceInfo.EventTrace.Guid = KdcHandleTGSRequestGuid;
        TGSEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        TGSEventTraceInfo.EventTrace.Flags = WNODE_FLAG_TRACED_GUID;
        TGSEventTraceInfo.EventTrace.Size = sizeof (EVENT_TRACE_HEADER) + sizeof (ULONG);
        TGSEventTraceInfo.KdcOptions = KdcOptions;

        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TGSEventTraceInfo
            );
    }
#endif

    //
    // Get IKdbProvider interface for RequestRealm
    //
    KerbErr = KdbRealmLocate(RequestRealm, &piKdb);
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to locate database for realm %wZ",
                  KLIN(FILENO,__LINE__), RequestRealm));
        goto Cleanup;
    }
    KdbPerfCount(piKdb, KerbKdcTgsReqCounter);

    //
    // The TGS and authenticator are in an AP request in the pre-auth data.
    // Find it and decode the AP request now.
    //

    if ((RequestMessage->bit_mask & KERB_KDC_REQUEST_preauth_data_present) == 0)
    {
        D_DebugLog((DEB_ERROR,
                  "KLIN(%x) No pre-auth data in TGS request - not allowed.\n",
                  KLIN(FILENO, __LINE__)));
        KerbErr = KDC_ERR_PADATA_TYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Get the TGT from the PA data.
    //

    ApRequest = KerbFindPreAuthDataEntry(
                    KRB5_PADATA_TGS_REQ,
                    RequestMessage->KERB_KDC_REQUEST_preauth_data
                    );
    if (ApRequest == NULL)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) No pre-auth data in TGS request - not allowed.\n",
                  KLIN(FILENO, __LINE__)));
        FILL_EXT_ERROR(pExtendedError, STATUS_NO_PA_DATA, FILENO, __LINE__);
        KerbErr = KDC_ERR_PADATA_TYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Verify the request. This includes decoding the AP request,
    // finding the appropriate key to decrypt the ticket, and checking
    // the ticket.
    //

    KerbErr = KdcVerifyKdcRequest(
                piKdb,
                &KdcReq,
                ApRequest->preauth_data.value,
                ApRequest->preauth_data.length,
                ClientAddress,
                TRUE,                           // this is a kdc request
                &UnmarshalledApRequest,
                &KdcReq.m_pUnmarshalledAuthenticator,
                &SourceEncryptPart,
                &ReplyKey,
                &TgtServerInfo,                 // Info about service in AP-REQ
                &UseSubKey,
                pExtendedError
                );

    //
    // If you want to validate a ticket, then it's OK if it isn't
    // currently valid.
    //

    if (KerbErr == KRB_AP_ERR_TKT_NYV && (KdcOptions & KERB_KDC_OPTIONS_validate))
    {
        D_DebugLog((DEB_TRACE,"Validating a not-yet-valid ticket\n"));
        KerbErr = KDC_ERR_NONE;
    }
    else if (KerbErr == KRB_AP_ERR_MODIFIED)
    {
        //
        // Bug 276943: When the authenticator is encrypted with something other
        //             than the session key, KRB_AP_ERR_BAD_INTEGRITY must be
        //             returned per RFC 1510
        //
        D_DebugLog((DEB_TRACE,"Could not decrypt the ticket\n"));
        KerbErr = KRB_AP_ERR_BAD_INTEGRITY;
    }

    //
    // Verify the checksum on the ticket, if present
    //

    if ( KERB_SUCCESS(KerbErr) &&
        (KdcReq.m_pUnmarshalledAuthenticator != NULL) &&
        (KdcReq.m_pUnmarshalledAuthenticator->bit_mask & checksum_present) != 0)
    {
        KerbErr = KdcVerifyTgsChecksum(
                    &RequestMessage->request_body,
                    &ReplyKey,
                    &KdcReq.m_pUnmarshalledAuthenticator->checksum
                    );

    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to verify TGS request: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        goto Cleanup;
    }
    //
    //  if everything went well save what we got in the req.
    //

    // LSG bug 6999. Found crash during fuzzing. TgtServerInfo is NULL at this point when 
    // clearly it shoudn't be. Root cause unknown so far.
    assert(TgtServerInfo);
    if (!TgtServerInfo)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    //  Don't release TgtServerInfo since it belongs to KdcReq now.
    //
    KdcReq.m_piClientPrincipal = TgtServerInfo;
    KdcReq.m_pSessionKey = &ReplyKey;
    KdcReq.m_pEncTicket = SourceEncryptPart;
    KdcReq.m_pustrRealm = const_cast<PUNICODE_STRING>
                (TgtServerInfo->GetRealm());
    CommonEType = KdcReq.m_ulCommonEType = ReplyKey.keytype;

    //
    // Now that we've validated the request,
    // Check to see if the cname in padata bit is set, and
    // we have the KDC option set.
    //
    KerbErr = KdcCheckPreAuthData(
                  piKdb,
                  KerbTgs,
                  TgtServerInfo,
                  RequestMessage->KERB_KDC_REQUEST_preauth_data,
                  RequestBody,
                  &PreAuthType,
                  &OutputPreAuthData,
                  &EncryptionKey,
                  NULL,
                  pExtendedError,
                  &KdcReq
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                  &ClientName,
                  &SourceEncryptPart->client_name
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToString(
                  &ClientStringName,
                  ClientName,
                  NULL
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // And the realm
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                  &ClientRealm,
                  &SourceEncryptPart->client_realm
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Build a ticket struture to pass to the worker functions
    //

    SourceTicket = UnmarshalledApRequest->ticket;
    SourceTicket.encrypted_part.cipher_text.value = (PUCHAR) SourceEncryptPart;

    //
    // Check any authorization data in the krbtgt ticket.
    //

    if (SourceEncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present)
    {
        PKERB_AUTHORIZATION_DATA AuthData = NULL;

        AuthData = SourceEncryptPart->KERB_ENCRYPTED_TICKET_authorization_data;

        KerbErr = KdcCheckAuthData(
                     TgtServerInfo,
                     &KdcReq,
                     AuthData,
                     pExtendedError);

        if (!KERB_SUCCESS(KerbErr))
        {
            //  do anything with the status
            goto Cleanup;
        }
    }


    //
    // Check for additional tickets (User2User and Service4User)
    //

    if ((RequestBody->bit_mask & additional_tickets_present) != 0)
    {
        //
        // The ticket must be unpacked with the krbtgt key
        //

        KerbErr = KdcUnpackAdditionalTickets(
                    piKdb,
                    KdcOptions,
                    RequestBody->additional_tickets,
                    &User2UserTicket,
                    &KdcReq,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to unpack additional tickets: 0x%x\n",
                      KLIN(FILENO, __LINE__),KerbErr));
            goto Cleanup;
        }
    }

    //
    // Make sure that if there is a ticket, then enc_tkt_in_skey is set and
    // if not, then it isn't set
    //

    if ((((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0) ^
        (User2UserTicket != NULL)))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Client didn't match enc_tkt_in_skey with additional tickts : %d vs %d\n",
                  KLIN(FILENO, __LINE__),((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0),
                  (User2UserTicket != NULL)));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }


    //
    // The server name is optional only for the enc_tkt_in_skey case.
    // When not present the cname of the user2user ticket is the server name.
    // Otherwise it is required.
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) != 0)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ServerName,
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

#ifdef KDC_BUG
        //
        // According to the RFC, this can't happen. For u2u, the sname is not
        // present and should not be used.
        //

        //
        // Verify that the server name is the same as the client name
        // from the additional ticket by getting the ticket info for supplied
        // TGT for the server. Later on we will compare it against the real
        // ticket info.
        //

        if (User2UserTicket != NULL)
        {
            PKERB_INTERNAL_NAME TgtClientName = NULL;
            UNICODE_STRING TgtRealmName = {0};

            KerbErr = KerbConvertPrincipalNameToKdcName(
                        &TgtClientName,
                        &User2UserTicket->client_name
                        );

            if (KERB_SUCCESS(KerbErr))
            {

                KerbErr = KerbConvertRealmToUnicodeString(
                            &TgtRealmName,
                            &User2UserTicket->client_realm
                            );
                if (KERB_SUCCESS(KerbErr))
                {

                    // TBD:  make sure GetPrincipal takes into account
                    // deleg restrictions, but not here, for god' sake.

                    KerbErr = KdbGetPrincipal(
                                 KdbHandle,
                                 TgtClientName,
                                 &TgtRealmName,
                                 KDC_KDB_GET_PRINC_CLIENT,
                                 KerbTgs,
                                 &TgtClientInfo,
                                 pExtendedError
                                 );

                    if (!KERB_SUCCESS(KerbErr))
                    {
                        DebugLog((DEB_ERROR,"KLIN(%x) Failed to find client name from supplied ticket\n",
                                  KLIN(FILENO, __LINE__)));
                        KerbPrintKdcName(DEB_WARN, TgtClientName);
                        DebugLog((DEB_WARN,"\t 0x%x\n",KerbErr));
                        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                        goto Cleanup;
                    }

                    KerbFreeString(&TgtRealmName);
                }

                CheckAdditionalTicketMatch = FALSE;

                KerbFreeKdcName(&TgtClientName);
            }
        }
#endif
    }
    else
    {

        //
        // There must be an additional ticket if no server name is present
        //

        if (User2UserTicket == NULL)
        {
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ServerName,
                    &User2UserTicket->client_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }


    //
    // Convert the server name to a string for auditing.
    //

    KerbErr = KerbConvertKdcNameToString(
                &ServerStringName,
                ServerName,
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "GetTGSTicket called. Service=" ));
    D_KerbPrintKdcName(DEB_TRACE, ServerName );

    //
    // Build the new ticket
    //
#if DBG
    {
        D_DebugLog((DEB_TRACE, "Handle TGS request: Client = %wZ,\n ",&ClientRealm));
        D_KerbPrintKdcName(DEB_TRACE, ClientName);
        D_DebugLog((DEB_TRACE, "\t ServerName = \n"));
        D_KerbPrintKdcName(DEB_TRACE, ServerName);
    }
#endif

    //
    // Pass off the work to the worker routines
    //

    if (KdcOptions & KERB_KDC_OPTIONS_renew)
    {
        D_DebugLog((DEB_T_KDC,"Renewing ticket ticket\n"));

        Renew = TRUE;
        KerbErr = I_RenewTicket(
                    piKdb,
                    &SourceTicket,
                    ServerName,
                    TgtServerInfo,
                    RequestBody,
                    &KdcReq,
                    &CommonEType,
                    &NewTicket,
                    pExtendedError
                    );
    }
    else if (KdcOptions & KERB_KDC_OPTIONS_validate)
    {
        D_DebugLog((DEB_T_KDC,"Validating ticket\n"));

        KerbErr = I_Validate(
                    piKdb,
                    &SourceTicket,
                    ServerName,
                    &ClientRealm,
                    RequestBody,
                    &KdcReq,
                    &CommonEType,
                    &NewTicket,
                    pExtendedError
                    );

        Validating = TRUE;

    }
    else
    {
        D_DebugLog((DEB_T_KDC,"Getting TGS ticket\n"));


        KerbErr = I_GetTGSTicket(
                    piKdb,
                    &SourceTicket,
                    ClientName,
                    ServerName,
                    RequestRealm,
                    RequestBody,
                    TgtServerInfo,
                    User2UserTicket != NULL ? &User2UserTicket->key : NULL,
                    &ServerInfo,
                    &KdcReq,
                    &CommonEType,
                    &NewTicket,
                    &ReplyPaData,
                    pExtendedError
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"KLIN(%x) TGS ticket worker failed: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }
    //  set the common etype again
    KdcReq.m_ulCommonEType = CommonEType;

    //  no server info keys
//    DsysAssert(ServerInfo->Keys != NULL);


    //
    // Check to see if the additional ticket supplied is the one for this
    // server, if necessary
    //

    if (CheckAdditionalTicketMatch)
    {
        //  this is kerb_internal_name comparison ... maybe the
        //  names should be made simpler
        if (!KerbEqualKdcNames(
                    ServerInfo->GetName(),
                    TgtClientInfo->GetName()))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Supplied ticket is not for server: server vs. tgt\n",
                        KLIN(FILENO, __LINE__)));
            D_KerbPrintKdcName(DEB_ERROR,
                ServerInfo->GetName());
            D_KerbPrintKdcName(DEB_ERROR,
                TgtClientInfo->GetName());
            KerbErr = KRB_AP_ERR_BADMATCH;
            goto Cleanup;
        }
    }

    //
    // Determine the keys to encrypt the ticket with.  (The key to encrypt the
    // reply with was determined by CheckTicket.)

    if ((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) &&
        (User2UserTicket != NULL))
    {

        //
        // Use the session key from the tgt
        //

        SessionKey.Key = User2UserTicket->key;
        SessionKey.KeyVersion = KERB_NO_KEY_VERSION;
        SessionKey.SaltType = KerbKdbSaltTypeDefault;
        ServerKey = &SessionKey;

    }

    KerbErr = BuildReply(
                NULL,
                RequestBody->nonce,
                &NewTicket.server_name,
                NewTicket.realm,
                ((EncryptedTicket.bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0) ?
                    EncryptedTicket.KERB_ENCRYPTED_TICKET_client_addresses : NULL,
                &NewTicket,
                &ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Get any PA-DATA to return
    //

    KerbErr = KdcReturnPreAuthData(
                 &KdcReq,
                 &OutputPreAuthData
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Put in any encrypted PA data for the reply (non-standard - deprecate)
    //

    if (ReplyPaData != NULL)
    {
        ReplyBody.encrypted_pa_data = (struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s *) ReplyPaData;
        ReplyBody.bit_mask |= encrypted_pa_data_present;
    }

    //
    // Now build the real reply and return it.
    //

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_TGS_REP;
    Reply.KERB_KDC_REPLY_preauth_data = NULL;
    Reply.bit_mask = 0;


    //
    // Put the client name into the reply
    //

    Reply.client_realm = SourceEncryptPart->client_realm;
    Reply.client_name = SourceEncryptPart->client_name;


    //
    // Put in any PA data for the reply
    //
    if (OutputPreAuthData != NULL)
    {
        Reply.KERB_KDC_REPLY_preauth_data = (PKERB_REPLY_PA_DATA_LIST) OutputPreAuthData;
        Reply.bit_mask |= KERB_KDC_REPLY_preauth_data_present;

        //
        // Zero this out so we don't free the preauth data twice
        //

        OutputPreAuthData = NULL;
    }


    //
    // Copy in the ticket
    //

    KerbErr = KerbPackTicket(
                &KdcReq,
                &NewTicket,
                ServerInfo,
                //  where do we get the common etype from?
                RequestBody->encryption_type,
                &Reply.ticket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack ticket: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // Copy in the encrypted part of the reply
    //

    KerbErr = KerbPackKdcReplyBody(
                &KdcReq,
                &ReplyBody,
                &ReplyKey,
                NULL,           // no principal
                // KERB_NO_KEY_VERSION, // no version
                NULL,           // no keytypes - replykey has all
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                &Reply.encrypted_part,
                pExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x)Failed to pack KDC reply body: 0x%x\n",
                KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // Now build the real reply message
    //

    KerbErr = KerbPackData(
                &Reply,
                KERB_TGS_REPLY_PDU,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    //
    // Audit the successful ticket generation
    //
   Status = KdbAuditEvent(
                            piKdb,
                            (Renew) ? TicketRenewSuccess : TgsTicketRequest,
                            (PIKerbRequest)&KdcReq,
                            NULL,
                            &KdcOptions,
                            RequestBody->encryption_type,
                            NULL,
                            ClientAddress
                            );

    if (!NT_SUCCESS(Status))
        {
            KerbErr = KDC_ERR_SERVICE_REVOKED;
            goto Cleanup;
        }


Cleanup:

    //
    // Complete the event
    //
#ifdef KDC_WMI_TRACING
    if (KdcEventTraceFlag){

        //These variables point to either a unicode string struct containing
        //the corresponding string or a pointer to KdcNullString

        PUNICODE_STRING pStringToCopy;
        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};

        TGSEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        TGSEventTraceInfo.EventTrace.Flags = WNODE_FLAG_USE_MOF_PTR |
                                             WNODE_FLAG_TRACED_GUID;

        // Always output error code.  KdcOptions was captured on the start event

        TGSEventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) &KerbErr;
        TGSEventTraceInfo.eventInfo[0].Length  = sizeof(ULONG);
        TGSEventTraceInfo.EventTrace.Size =
            sizeof (EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        // Build counted MOF strings from the unicode strings.
        // If data is unavailable then output a NULL string

        if (ClientStringName.Buffer != NULL &&
            ClientStringName.Length > 0)
        {
            pStringToCopy = &ClientStringName;
        }
        else {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[1].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[1].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[2].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[2].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;

        if (ServerStringName.Buffer != NULL &&
            ServerStringName.Length > 0)
        {
            pStringToCopy = &ServerStringName;

        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[3].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[3].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[4].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[4].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (ClientRealm.Buffer != NULL &&
            ClientRealm.Length > 0)
        {
            pStringToCopy = &ClientRealm;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[5].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[5].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[6].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[6].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        TraceEvent(
             KdcTraceLoggerHandle,
             (PEVENT_TRACE_HEADER)&TGSEventTraceInfo
             );
    }
#endif

    //
    // Audit *most* failures (see bug 37126)
    //

    if (piKdb &&
        !KERB_SUCCESS(KerbErr) &&
        KerbErr != KDC_ERR_S_PRINCIPAL_UNKNOWN)
    {
        Status = KdbAuditEvent(
                            piKdb,
                            TgsFailure,
                            (PIKerbRequest)&KdcReq,
                            &KerbErr,
                            &KdcOptions,
                            NULL,
                            NULL,
                            ClientAddress
                            );
    }

    KerbFreeKdcName(
        &ClientName
        );
    KerbFreeString(
        &ClientRealm
        );

    KerbFreeKdcName(
        &ServerName
        );
    KerbFreeKey(
        &ReplyKey
        );

    KdcFreeKdcReplyBody(
        &ReplyBody
        );
    KerbFreeString(
        &ClientStringName
        );
    KerbFreeString(
        &ServerStringName
        );

    //
    // If we are validating the ticket key is in the serverinfo
    //

    if (User2UserTicket != NULL)
    {
        KerbFreeTicket(User2UserTicket);
    }

    if (ReplyPaData != NULL)
    {
        KerbFreePreAuthData(ReplyPaData);
    }

    if (OutputPreAuthData != NULL)
    {
        KerbFreePreAuthData(OutputPreAuthData);
    }

    KerbFreeApRequest(UnmarshalledApRequest);
    KerbFreeTicket(SourceEncryptPart);

    KdcFreeInternalTicket(&NewTicket);

    //
    //  ownership could be transferred in I_GetTGSTicket( )
    //
#ifdef DBG
    assert(!ServerInfo || !KdcReq.m_piServerPrincipal || (ServerInfo == KdcReq.m_piServerPrincipal));
#endif
    if (ServerInfo && !KdcReq.m_piServerPrincipal)
        ServerInfo->Release();

    //
    //  only release if ownership has not been transferred
    //
#ifdef DBG
    assert(!TgtServerInfo || !KdcReq.m_piClientPrincipal || (TgtServerInfo == KdcReq.m_piClientPrincipal));
#endif
    if (TgtServerInfo && !KdcReq.m_piClientPrincipal)
        TgtServerInfo->Release();

    if (TgtClientInfo)
        TgtClientInfo->Release();

    KdcFreeKdcReply(
        &Reply
        );

    if (Tgt)
        Tgt->Release();

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog(( DEB_ERROR, "HandleTGSRequest(): KdcFreeContext failed 0x%x\n",
                     Status ));
    }

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\cryptdll.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        cryptdll.h
//
// Contents:    How to use the crypt support dll
//
//
// History:     04 Jun 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __CRYPTDLL_H__
#define __CRYPTDLL_H__

typedef PVOID   PCRYPT_STATE_BUFFER;

typedef NTSTATUS (NTAPI * PCRYPT_INITIALIZE_FN)(
    PUCHAR,
    ULONG,
    ULONG,
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_ENCRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DECRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DISCARD_FN)(
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_HASH_STRING_FN)(
    PUNICODE_STRING String,
    PUCHAR Buffer
    );
typedef NTSTATUS (NTAPI * PCRYPT_RANDOM_KEY_FN)(
    OPTIONAL PUCHAR Seed,
    OPTIONAL ULONG SeedLength,
    PUCHAR Key
    );

typedef NTSTATUS (NTAPI * PCRYPT_CONTROL_FN)(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    );

//
// functions for CryptControl
#define CRYPT_CONTROL_SET_INIT_VECT     0x1


typedef struct _CRYPTO_SYSTEM {
    ULONG EncryptionType;
    ULONG BlockSize;
    ULONG ExportableEncryptionType;
    ULONG KeySize;
    ULONG HeaderSize;
    ULONG PreferredCheckSum;
    ULONG Attributes;
    PWSTR Name;
    PCRYPT_INITIALIZE_FN Initialize;
    PCRYPT_ENCRYPT_FN Encrypt;
    PCRYPT_DECRYPT_FN Decrypt;
    PCRYPT_DISCARD_FN Discard;
    PCRYPT_HASH_STRING_FN HashString;
    PCRYPT_RANDOM_KEY_FN RandomKey;
    PCRYPT_CONTROL_FN Control;
} CRYPTO_SYSTEM, *PCRYPTO_SYSTEM;

#define CSYSTEM_USE_PRINCIPAL_NAME      0x01
#define CSYSTEM_EXPORT_STRENGTH         0x02
#define CSYSTEM_INTEGRITY_PROTECTED     0x04

NTSTATUS NTAPI
CDRegisterCSystem(PCRYPTO_SYSTEM);

NTSTATUS NTAPI
CDBuildVect(
    PULONG EncryptionTypesAvailable,
    PULONG EncryptionTypes
    );

NTSTATUS NTAPI
CDBuildIntegrityVect(
    PULONG      pcCSystems,
    PULONG      pdwEtypes
    );


NTSTATUS NTAPI
CDLocateCSystem(
    ULONG EncryptionType,
    PCRYPTO_SYSTEM * CryptoSystem
    );


NTSTATUS NTAPI
CDFindCommonCSystem(
    ULONG EncryptionTypeCount,
    PULONG EncryptionTypes,
    PULONG CommonEncryptionType
    );

NTSTATUS NTAPI
CDFindCommonCSystemWithKey(
    IN ULONG EncryptionEntries,
    IN PULONG EncryptionTypes,
    IN ULONG KeyTypeCount,
    IN PULONG KeyTypes,
    OUT PULONG CommonEtype
    );



////////////////////////////////////////////////////////////////////

typedef PVOID PCHECKSUM_BUFFER;

typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZE_FN)(ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX_FN)(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
// add the ex2 function to allow the checksum to be passed in for verification
// this is passed in the 4th parameter
// this is necessary for checksums which use confounders, where the confounder must
// be pulled from the checksum in order to calculate a new checksum when verifying
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX2_FN)(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_SUM_FN)(PCHECKSUM_BUFFER, ULONG, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINALIZE_FN)(PCHECKSUM_BUFFER, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINISH_FN)(PCHECKSUM_BUFFER *);

typedef struct _CHECKSUM_FUNCTION {
    ULONG CheckSumType;
    ULONG CheckSumSize;
    ULONG Attributes;
    PCHECKSUM_INITIALIZE_FN Initialize;
    PCHECKSUM_SUM_FN Sum;
    PCHECKSUM_FINALIZE_FN Finalize;
    PCHECKSUM_FINISH_FN Finish;
    PCHECKSUM_INITIALIZEEX_FN InitializeEx;
    PCHECKSUM_INITIALIZEEX2_FN InitializeEx2;  // allows passing in the checksum on intialization for verification 
} CHECKSUM_FUNCTION, *PCHECKSUM_FUNCTION;

#define CKSUM_COLLISION     0x00000001
#define CKSUM_KEYED         0x00000002


#define CHECKSUM_SHA1       131

NTSTATUS NTAPI
CDRegisterCheckSum( PCHECKSUM_FUNCTION);


NTSTATUS NTAPI
CDLocateCheckSum( ULONG, PCHECKSUM_FUNCTION *);



//////////////////////////////////////////////////////////////



typedef BOOLEAN (NTAPI * PRANDOM_NUMBER_GENERATOR_FN)(PUCHAR, ULONG);


typedef struct _RANDOM_NUMBER_GENERATOR {
    ULONG GeneratorId;
    ULONG Attributes;
    ULONG Seed;
    PRANDOM_NUMBER_GENERATOR_FN GenerateBitstream;
} RANDOM_NUMBER_GENERATOR, *PRANDOM_NUMBER_GENERATOR;

#define RNG_PSEUDO_RANDOM   0x00000001  // Pseudo-random function
#define RNG_NOISE_CIRCUIT   0x00000002  // Noise circuit (ZNR diode, eg)
#define RNG_NATURAL_PHENOM  0x00000004  // Natural sampler (geiger counter)

BOOLEAN NTAPI
CDGenerateRandomBits(PUCHAR pBuffer,
                     ULONG  cbBuffer);

BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng);

BOOLEAN NTAPI
CDLocateRng(ULONG                       Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng);

#define CD_BUILTIN_RNG  1


///////////////////////////////////////////////////////////
//
// Error codes
//
///////////////////////////////////////////////////////////


#define SEC_E_ETYPE_NOT_SUPP            0x80080341
#define SEC_E_CHECKSUM_NOT_SUPP         0x80080342
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\kerbcrypt.cxx ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    KerbCrypt.cpp

Abstract:

    This module wraps cryptdll with IKerbCrypt using the
    CKerbCryptDll

Revision History:

--*/
#include "kdcsvr.hxx"

//
//    omit KDC_AUDIT_EVENT and KERB_PERF_COUNTERS
//
#include "kerbinterface.h"
#include "kerbcrypt.hxx"
#include "cryptdll.h"
#include <malloc.h>

//
//  for alloca( )
//
#include <malloc.h>

//
//    max. cryptos (same as KERB_MAX_CRYPTO_SYSTEMS)
//
#define MAX_ETYPES    20

CKerbCryptDll::CKerbCryptDll()
    : m_cEtypes( 0 ),
      m_pEtypes( NULL )
{
}

CKerbCryptDll::~CKerbCryptDll()
{
    if ( m_pEtypes ) {

        assert( m_cEtypes > 0 );
        MIDL_user_free( m_pEtypes );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetEtypes
//
//  Synopsis:   Get the encryption types supported by this implementation
//              of IKerbCrypt.
//
//  Effects:
//
//  Arguments:  ppEtypes -  array of ETYPEs that is supported.
//              pcEtypes -  number of ETYPEs in the array
//
//  Returns:    STATUS_SUCCESS              indicates success
//              STATUS_INVALID_PARAMETER    parms are bad pointers
//              STATUS_NO_MEMORY            out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CKerbCryptDll::GetEtypes(
    OUT ETYPE const             **ppEtypes,
    OUT PULONG                    pcEtypes
    )
{
    NTSTATUS Status;

    if ( NULL == ppEtypes ||
         NULL == pcEtypes ) {

        assert( FALSE );
        return STATUS_INVALID_PARAMETER;
    }

    *ppEtypes = NULL;
    *pcEtypes = 0;

    if (m_pEtypes == NULL)
    {
        assert(m_cEtypes == 0);

        m_pEtypes = ( ETYPE * )MIDL_user_allocate( sizeof( ETYPE ) * MAX_ETYPES );

        if ( !m_pEtypes ) {

            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        Status = CDBuildIntegrityVect(
                     &m_cEtypes,
                     m_pEtypes
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }
    }

    assert( m_cEtypes <= MAX_ETYPES );
    assert( m_cEtypes > 0 );

    *ppEtypes = m_pEtypes;
    *pcEtypes = m_cEtypes;

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    assert( !NT_SUCCESS( Status ));

    MIDL_user_free( m_pEtypes );
    m_pEtypes = NULL;
    m_cEtypes = 0;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetAttributes
//
//  Synopsis:   Retrieves the attributes of a given encryption type
//
//  Effects:
//
//  Arguments:  Etype       - encryption type
//              Attributes  - used to return the attributes of the Etype
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::GetAttributes(
    IN  ETYPE                     Etype,
    OUT PCRYPTATT                 Attributes
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt  = NULL;

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    *Attributes = pcsCrypt->Attributes;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    *Attributes = 0;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetCiphertextSize
//
//  Synopsis:   Computes the number of bytes necessary to encrypt a given buffer
//
//  Effects:
//
//  Arguments:  Etype                   encryption type
//              cbIn                    size of cleartext
//              pcbOut                  used to return size of ciphertext
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::GetCiphertextSize(
    IN  ETYPE                     Etype,
    IN  ULONG                     cbIn,
    OUT PULONG                    pcbOut
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt;
    ULONG Overhead;
    ULONG BlockSize;

    assert( pcbOut );
    if (!pcbOut)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    Overhead = pcsCrypt->HeaderSize;
    BlockSize = pcsCrypt->BlockSize;

    *pcbOut  = ROUND_UP_COUNT( Overhead + cbIn, BlockSize );

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    *pcbOut = 0;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::Encrypt
//
//  Synopsis:   Encrypts a given buffer using the given key.
//                The etype comes from the given key.
//
//  Effects:
//
//  Arguments:  pKey           - encryption key
//              saltflags      - usage flags
//              KeyVersion     - key version (or KERB_NO_KEY_VERSION)
//              pbIn           - data to encrypt
//              cbIn           - number of bytes to encrypt
//              EncryptedData  - used to return the encrypted buffer
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//              KRB_ERR_GENERIC         out of memory, internal error
//                                      bad pointer
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::Encrypt(
    IN  PKERB_ENCRYPTION_KEY      pKey,
    IN  ULONG                     ulKeyVersion,
    IN  SALTFLAGS                 saltflags,
    IN  PBYTE                     pbIn,
    IN  ULONG                     cbIn,
    OUT PKERB_ENCRYPTED_DATA      pEncryptedData
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;

    TRACER(L"CKerbCryptDll::Encrypt", (PVOID *) &KerbErr);
    if ( NULL == pKey ||
         NULL == pEncryptedData ||
         NULL == pbIn ||
         0 == cbIn ) {

        assert( FALSE );
        return KRB_ERR_GENERIC;
    }

    Status = CDLocateCSystem(
                 pKey->keytype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    //
    // Initialize header
    //

    pEncryptedData->encryption_type = pKey->keytype;

    Status = pcsCrypt->Initialize(
                 ( PUCHAR )pKey->keyvalue.value,
                 pKey->keyvalue.length,
                 saltflags,
                 &psbCryptBuffer
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status =  pcsCrypt->Encrypt(
                  psbCryptBuffer,
                  pbIn,
                  cbIn,
                  pEncryptedData->cipher_text.value,
                  &pEncryptedData->cipher_text.length
                  );

    ( VOID )pcsCrypt->Discard( &psbCryptBuffer );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    if ( ulKeyVersion != KERB_NO_KEY_VERSION ) {

        pEncryptedData->version = ulKeyVersion;
        pEncryptedData->bit_mask |= version_present;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::Decrypt
//
//  Synopsis:   Decrypts a given buffer
//
//  Effects:
//
//  Arguments:  pKey           - encryption key
//              saltflags      - usage flags
//              EncryptedData  - buffer to decrypt
//              pbOut          - used to return the decrypted buffer
//              pcbOut         - used to return the size of decrypted buffer
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//              KRB_ERR_GENERIC         out of memory, internal error or parameters
//                                      are bad
//              KRB_AP_ERR_MODIFIED     decryption failed -- the key is wrong
//
//  Notes:      this routine allows in-place decryption
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::Decrypt(
    IN  const KERB_ENCRYPTED_DATA * pEncryptedData,
    IN  const KERB_ENCRYPTION_KEY * pKey,
    IN  SALTFLAGS saltflags,
    OUT PBYTE pbOut,
    OUT PULONG pcbOut
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;

    TRACER(L"CKerbCryptDll::Decrypt", (PVOID *) &KerbErr);
    if ( NULL == pEncryptedData ||
         NULL == pKey ||
         NULL == pbOut ||
         NULL == pcbOut ) {

        assert( FALSE );
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = CDLocateCSystem(
                 pEncryptedData->encryption_type,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    //
    // This check makes sure that the length of EncryptedData->cipher_text is a
    // multiple of pcsCrypt->BlockSize.  In this case, it looks like an
    // "almost catch-all" check to make sure that the encryption_type is correct
    // since it's definitely incorrect if the returned pcsCrypt->BlockSize won't
    // line up with the length of the passed-in cipher text.
    // ( Explanation courtesy of JSchwart )
    //

    if ( pEncryptedData->cipher_text.length & ( pcsCrypt->BlockSize - 1 )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = pcsCrypt->Initialize(
                 ( PUCHAR )pKey->keyvalue.value,
                 pKey->keyvalue.length,
                 saltflags,
                 &psbCryptBuffer
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = pcsCrypt->Decrypt(
                 psbCryptBuffer,
                 pEncryptedData->cipher_text.value,
                 pEncryptedData->cipher_text.length,
                 pbOut,
                 pcbOut
                 );

    ( VOID )pcsCrypt->Discard( &psbCryptBuffer );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Error;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:
    assert( !KERB_SUCCESS( KerbErr ));
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetKeySize
//
//  Synopsis:   Retrieves the key size for given encryption type
//
//  Effects:
//
//  Arguments:  Etype       - encryption type
//              pcbOut      - used to return the size of the key
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::GetKeySize(
    IN  ETYPE                     Etype,
    OUT PULONG                    pcbOut
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt  = NULL;

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    *pcbOut = pcsCrypt->KeySize;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    *pcbOut = 0;

    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::MakeKey
//
//  Synopsis:   Creates a key for an encryption type
//
//  Effects:
//
//  Arguments:  Etype - encryption type requested
//              ppKey - returned key that should be freed with
//                      CKerbCryptDll::FreeKey
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//              KRB_ERR_GENERIC         out of memory, internal error or parameters
//                                      are bad
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::MakeKey(
    IN  ETYPE                     Etype,
    OUT KERB_ENCRYPTION_KEY     **ppKey
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt  = NULL;
    PKERB_ENCRYPTION_KEY pKey = NULL;

    TRACER(L"CKerbCryptDll::MakeKey", (PVOID *) &KerbErr);

    if ( NULL == ppKey ) {

        assert( FALSE );
        return KRB_ERR_GENERIC;
    }

    pKey = ( PKERB_ENCRYPTION_KEY )MIDL_user_allocate( sizeof( KERB_ENCRYPTION_KEY ));

    if ( NULL == pKey ) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    ZeroMemory( pKey, sizeof( KERB_ENCRYPTION_KEY ));
    pKey->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    pKey->keyvalue.value = ( PUCHAR )MIDL_user_allocate( pcsCrypt->KeySize );

    if ( pKey->keyvalue.value == NULL ) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = pcsCrypt->RandomKey(
                 NULL,   // no seed
                 0,      // no seed length
                 pKey->keyvalue.value
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    pKey->keyvalue.length = pcsCrypt->KeySize;
    pKey->keytype = Etype;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    *ppKey = pKey;

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    FreeKey( pKey );
    pKey = NULL;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::FreeKey
//
//  Synopsis:   Frees memory for key created using CKerbCryptDll::MakeKey
//
//  Arguments:  pKey - key to free, can be NULL
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void
__stdcall
CKerbCryptDll::FreeKey(
    IN  PKERB_ENCRYPTION_KEY      pKey
    )
{
    if ( pKey )
    {
        MIDL_user_free(pKey->keyvalue.value);
        MIDL_user_free(pKey);
    }

    return;
}



//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetChecksumSize
//
//  Synopsis:   Calculates the checksum length for a given checksum type
//
//  Effects:
//
//  Arguments:  Ctype                 - checksum type requested
//              pcbOut                - used to return the checksum size
//
//  Returns:    STATUS_SUCCESS              indicates success
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CKerbCryptDll::GetChecksumSize(
    IN  CTYPE                     Ctype,
    OUT PULONG                    pcbOut
    )
{
    NTSTATUS Status;
    PCHECKSUM_FUNCTION pcsChecksum = NULL;

    Status = CDLocateCheckSum(
                 Ctype,
                 &pcsChecksum
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    *pcbOut = pcsChecksum->CheckSumSize;

Cleanup:

    return Status;

Error:

    assert( !NT_SUCCESS( Status ));

    *pcbOut = 0;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::Checksum
//
//  Synopsis:   Calculates the checksum for a CTYPE (checksum type) using the
//                key, pKey across cBuffers number of buffers.  The sum operation
//                will start with ppbBuffers[0].  The resulting
//                checksum is written to ppbChecksum and pcbChecksum
//                If pbVerify and cbVerify are present, the resulting checksum
//                is compared against pbVerify and pfVerified is set TRUE if
//                it is a match.
//
//  Effects:
//
//  Arguments:  Ctype                 - checksum type requested
//              saltflags             - salt flags
//              pKey                  - key to use.  If this is NULL, no key is used.
//              rgpbBuffers           - array of buffers to checksum
//              rgcbBuffers           - array of byte lengths for each corresponding buffer
//              cBuffers              - number of buffers
//              pbChecksum            - used to return calculated checksum
//              pcbChecksum           - used to return length of checksum
//              pbVerify              - checksum that needs to be verified ( OPTIONAL )
//              cbVerify              - byte length of the checksum to be verified ( OPTIONAL )
//              pfVerified            - did the checksum verify ? ( OPTIONAL )
//
//  Returns:    STATUS_SUCCESS              indicates success
//              STATUS_INVALID_PARAMETER    one or more invalid parameter
//              SEC_E_CHECKSUM_NOT_SUPP     checksum type is not supported
//              STATUS_NO_MEMORY            out of memory
//              STATUS_BUFFER_TOO_SMALL     passed in buffer insufficient
//                                          to compute the checksum
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CKerbCryptDll::Checksum(
    IN  CTYPE                     Ctype,
    IN  SALTFLAGS                 saltflags,
    IN  PKERB_ENCRYPTION_KEY      pKey,
    IN  PBYTE                    *rgpbBuffers,
    IN  ULONG                    *rgcbBuffers,
    IN  ULONG                     cBuffers,
    IN  PBYTE                     pbVerify,
    IN  ULONG                     cbVerify,
    OUT PBYTE                     pbChecksum,
    OUT PULONG                    pcbChecksum,
    OUT PBOOLEAN                  pfVerified
    )
{
    NTSTATUS Status;
    PCHECKSUM_FUNCTION pcsChecksum = NULL;
    PCHECKSUM_BUFFER pcsBuffer = NULL;
    ULONG i;
    ULONG cbChecksum;

    if (( NULL == rgpbBuffers || cBuffers == 0 || rgcbBuffers == NULL ) ||
        (( pbChecksum != NULL ) ^ ( pcbChecksum != NULL )) ||
        (( pbVerify != NULL ) ^ ( cbVerify != 0 ))) {

        return STATUS_INVALID_PARAMETER;
    }

    Status = CDLocateCheckSum(
                 Ctype,
                 &pcsChecksum
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // TBD: do we always want to use InitializeEx2 ?
    //

    if (pcsChecksum->InitializeEx2)
    {
        Status = pcsChecksum->InitializeEx2(
                     pKey->keyvalue.value,
                     pKey->keyvalue.length,
                     NULL,
                     saltflags,
                     &pcsBuffer
                     );
    }
    else
    {
        Status = pcsChecksum->InitializeEx(
                     pKey->keyvalue.value,
                     pKey->keyvalue.length,
                     saltflags,
                     &pcsBuffer
                     );
    }

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // Do the checksumming
    //

    for ( i = 0; i < cBuffers; i++ ) {

        Status = pcsChecksum->Sum(
                     pcsBuffer,
                     rgcbBuffers[i],
                     rgpbBuffers[i]
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }
    }

    if ( pcbChecksum == NULL ) {

        cbChecksum = pcsChecksum->CheckSumSize;
        pcbChecksum = &cbChecksum;
    }

    if ( *pcbChecksum < pcsChecksum->CheckSumSize ) {

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Error;
    }

    if ( pbChecksum == NULL ) {
        __try
        {
            pbChecksum = ( BYTE * ) _alloca( *pcbChecksum );
        }
         __except ( GetExceptionCode() == STATUS_STACK_OVERFLOW )
        {    
            _resetstkoflw();
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
    }

    ZeroMemory( pbChecksum, *pcbChecksum );

    Status = pcsChecksum->Finalize( pcsBuffer, pbChecksum );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    //    Is verification required ?
    //

    if ( pfVerified ) {

        *pfVerified = ( pcsChecksum->CheckSumSize == cbVerify ) &&
                      ( pbVerify != NULL ) &&
                      ( memcmp( pbChecksum, pbVerify, cbVerify ) == 0 );
    }

    *pcbChecksum = pcsChecksum->CheckSumSize;

    Status = STATUS_SUCCESS;

Cleanup:

    if ( pcsBuffer ) {

        pcsChecksum->Finish( &pcsBuffer );
    }

    return Status;

Error:

    assert( !NT_SUCCESS( Status ));
    if ( pcsBuffer ) {

        pcsChecksum->Finish( &pcsBuffer );
    }

    if ( pcbChecksum ) {

        *pcbChecksum = 0;
    }

    if ( pfVerified ) {

        *pfVerified = FALSE;
    }

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::HashString
//
//  Synopsis:   Hashes a given string
//
//  Effects:
//
//  Arguments:  Etype       - encryption type requested
//              String      - string to hash
//              pbOut       - buffer used to return the hash
//              pcbOut      - used to return the size of the hash,
//                            contains the number of bytes in pbOut on input
//                            this number should be at least as the key size
//                            for Etype (use GetKeySize to figure that out)
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//              KRB_ERR_GENERIC         internal error or parameters are bad
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::HashString(
    IN  ETYPE                     Etype,
    IN  PUNICODE_STRING           String,
    OUT PBYTE                     pbOut,
    OUT PULONG                    pcbOut
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt  = NULL;

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    if ( *pcbOut < pcsCrypt->KeySize ) {

        assert( FALSE );
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = pcsCrypt->HashString(
                 String,
                 pbOut
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    *pcbOut = pcsCrypt->KeySize;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    *pcbOut = NULL;

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\kdcreq.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       kdcext.cxx
//
//  Contents:   KDC Extensions Support functions
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//              09-Sept-2001    yordanr - modified for new Kdc interface
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include "traceinterface.hxx"

//  handler factory lists
CKerbList KdcPAHandlerFactoryList;
CKerbList KdcADHandlerFactoryList;
extern IKerbCrypt   *g_piKerbCrypt;

#if 0   // add these later
//
// List for ticket ext handlers
//  add these as needed. unused for now (yordanr)
//
typedef struct _KDC_TE_HANDLER_LIST_ENTRY
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_TICKET_EXT_HANDLER     Handler;
} KDC_TE_HANDLER_LIST_ENTRY, *PKDC_TE_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcTEHandlerList;
BOOLEAN KdcTEHandlerListInitialized = FALSE;
CRWLock KdcTEHandlerListLock;
#endif

//
// List for PAC handlers
//
CKerbList g_KdcPacHandlerList;


//
//  Create handler instances for the request
//
NTSTATUS CKerbRequest::CreateHandlerInstances()
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (KdcPAHandlerFactoryList.cElem > 0)
    {
        m_ppiPAHandlers = (PIPAHandler*)MIDL_user_allocate(KdcPAHandlerFactoryList.cElem *
                                                sizeof(IPAHandler*));
        if (m_ppiPAHandlers == NULL)
            return  STATUS_NO_MEMORY;
        memset(m_ppiPAHandlers,
               0,
               KdcPAHandlerFactoryList.cElem * sizeof(IPAHandler*));
    }
    if (KdcADHandlerFactoryList.cElem > 0)
    {
        m_ppiADHandlers = (IADHandler**)MIDL_user_allocate(KdcADHandlerFactoryList.cElem *
                                                sizeof(IADHandler*));
        if (m_ppiADHandlers == NULL)
            return  STATUS_NO_MEMORY;
        memset(m_ppiADHandlers,
               0,
               KdcADHandlerFactoryList.cElem * sizeof(IADHandler*));
    }
    //  walk the factory lists and instantiate handlers
    PLIST_ENTRY ListEntry;
    ULONG iha = 0;
    KdcPAHandlerFactoryList.Lock.ReadLock();
    for (ListEntry = KdcPAHandlerFactoryList.Head.Flink, iha = 0;
         ListEntry && (ListEntry != &KdcPAHandlerFactoryList.Head);
         ListEntry = ListEntry->Flink, iha++)
    {
        PKDC_LIST_ENTRY HandlerEntry =
            (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);
        Status = ((IPAHandlerFactory*)HandlerEntry->pData)->
                CreateInstance(this, &m_ppiPAHandlers[iha]);
        if (Status != STATUS_SUCCESS)
            break;
    }
    KdcPAHandlerFactoryList.Lock.ReadUnlock();
    if (Status != STATUS_SUCCESS)
    {
        //  memory will be dealloc'd by destructor
        return  Status;
    }
    //
    //  alloc AD handlers as well
    //
    KdcADHandlerFactoryList.Lock.ReadLock();
    for (ListEntry = KdcADHandlerFactoryList.Head.Flink, iha = 0;
         ListEntry && (ListEntry != &KdcADHandlerFactoryList.Head);
         ListEntry = ListEntry->Flink, iha++)
    {
        PKDC_LIST_ENTRY pHandlerEntry =
            (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);
        Status = ((IADHandlerFactory*)pHandlerEntry->pData)->
                CreateInstance(this, &m_ppiADHandlers[iha]);
        if (Status != STATUS_SUCCESS)
            break;
    }
    KdcADHandlerFactoryList.Lock.ReadUnlock();

    return  Status;
}


//
//  Allocate a complete context state
//  A context is a list of AD and PA handler instances
//
NTSTATUS
KdcAllocContext(
    IN OUT CKerbRequest& Context
    )
{
    return  Context.CreateHandlerInstances();
}

//
//  should we expand this to allow for multiple handlers?
//
NTSTATUS WINAPI KdcRegisterPAHandlerFactory(
    // factory to create the IPAHandler
    IN  IPAHandlerFactory   *piPAHandlerFactory
    )
{
    if (piPAHandlerFactory == NULL)
        return  STATUS_INVALID_PARAMETER;
    PKDC_LIST_ENTRY pNewHandler = (PKDC_LIST_ENTRY)
        MIDL_user_allocate(sizeof(KDC_LIST_ENTRY));
    if (pNewHandler == NULL)
        return  STATUS_NO_MEMORY;
    pNewHandler->pData = (PVOID)piPAHandlerFactory;
    KdcPAHandlerFactoryList.InsertElement(&pNewHandler->Next);

    return  STATUS_SUCCESS;
}


//
//  clear the lists for the factories
//
void
WINAPI
KdcDeleteAllHandlerLists(
    )
{
    //  lists to clear
    CKerbList* pLists[] = {
            &KdcPAHandlerFactoryList,
            &KdcADHandlerFactoryList,
            &g_KdcPacHandlerList
                          };
    //
    //  loop thru all lists

    for (ULONG iList = 0; iList < sizeof(pLists)/sizeof(CKerbList*); iList++)
    {
        pLists[iList]->Lock.WriteLock();
        //  loop thru all list elements
        for (PLIST_ENTRY pNext = pLists[iList]->Head.Flink;
            pNext != NULL && pNext != &pLists[iList]->Head;
            )
        {
            //  get the ptr to delete
            PKDC_LIST_ENTRY pEntry =
                (PKDC_LIST_ENTRY)
                ((PBYTE)pNext - FIELD_OFFSET(KDC_LIST_ENTRY, Next));
            //  move to the next
            pNext = pNext->Flink;
            //  all elements are allocated with midl_user_xxx
            MIDL_user_free(pEntry);
        }
        //  finally reset the list
        InitializeListHead(&pLists[iList]->Head);
        pLists[iList]->cElem = 0;
        pLists[iList]->Lock.WriteUnlock();
    }
}


//
//  locate a handler of specific type
//
NTSTATUS __stdcall CKerbRequest::GetADHandler(REFIID intf, PVOID *ppv)
{
    IADHandler **iAD = m_ppiADHandlers;
    ULONG cHandlers = KdcADHandlerFactoryList.cElem;
    NTSTATUS Status = STATUS_NOT_FOUND;

    *ppv = NULL;
    while(cHandlers-- && *iAD)
    {
        if ((*iAD)->QueryInterface(intf, ppv) == S_OK)
        {
            Status = S_OK;
            break;
        }
        iAD++;
    }

    return  Status;
}
//
//  get AD handler by AD type
//
NTSTATUS __stdcall CKerbRequest::GetADHandler(ULONG ulADType, PIADHandler *pph)
{
    IADHandler **iAD = m_ppiADHandlers;
    ULONG cHandlers = KdcADHandlerFactoryList.cElem;
    NTSTATUS Status = STATUS_NOT_FOUND;

    *pph = NULL;
    while(cHandlers-- && *iAD)
    {
        if ((*iAD)->GetADType() == ulADType)
        {
            *pph = *iAD;
            Status = S_OK;
            break;
        }
        iAD++;
    }

    return  Status;
}

//
//  get PAC handler based on the PAC type
//
NTSTATUS __stdcall CKerbRequest::GetPACHandler(ULONG ulPacType, PIPACHandler *pph)
{
    NTSTATUS    Status = STATUS_NOT_FOUND;
    g_KdcPacHandlerList.Lock.ReadLock();
    for (PLIST_ENTRY ListEntry = g_KdcPacHandlerList.Head.Flink;
         ListEntry && (ListEntry != &g_KdcPacHandlerList.Head);
         ListEntry = ListEntry->Flink)
    {
        PKDC_LIST_ENTRY HandlerEntry =
            (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);

        if (((IPACHandler*)HandlerEntry->pData)->GetPacType() == ulPacType)
        {
            *pph = (IPACHandler*)HandlerEntry->pData;
            Status = STATUS_SUCCESS;
            break;
        }
    }
    g_KdcPacHandlerList.Lock.ReadUnlock();

    return  Status;
}

NTSTATUS __stdcall CKerbRequest::GetPAHandler(REFIID intf, PVOID *ppv)
{
    IPAHandler **iPA = m_ppiPAHandlers;
    ULONG cHandlers = KdcPAHandlerFactoryList.cElem;
    NTSTATUS Status = STATUS_NOT_FOUND;
    TRACER(L"CKerbRequest::GetPAHandler", (PVOID *) &Status);
    *ppv = NULL;
    while(cHandlers-- && *iPA)
    {
        if ((*iPA)->QueryInterface(intf, ppv) == S_OK)
        {
            Status = S_OK;
            break;
        }
        iPA++;
    }

    return  Status;
}
//
//  get specific PA handler type
//
NTSTATUS __stdcall CKerbRequest::GetPAHandler(ULONG ulPAType, IPAHandler **pph)
{
    IPAHandler **iPA = m_ppiPAHandlers;
    ULONG cHandlers = KdcPAHandlerFactoryList.cElem;
    NTSTATUS Status = STATUS_NOT_FOUND;
    TRACER(L"CKerbRequest::GetPAHandler", (PVOID *) &Status);

    *pph = NULL;
    while(cHandlers-- && *iPA)
    {
        if ((*iPA)->GetPAType() == ulPAType)
        {
            Status = S_OK;
            (*pph) = *iPA;
            break;
        }
        iPA++;
    }
    return  Status;
}




NTSTATUS WINAPI KdcRegisterADHandlerFactory(
        IN  IADHandlerFactory   *piADHandlerFactory   // factory to create the IADHandler
    )
{
    if (piADHandlerFactory == NULL)
        return  STATUS_INVALID_PARAMETER;
    PKDC_LIST_ENTRY pNewHandler = (PKDC_LIST_ENTRY)
        MIDL_user_allocate(sizeof(KDC_LIST_ENTRY));
    if (pNewHandler == NULL)
        return  STATUS_NO_MEMORY;
    pNewHandler->pData = (PVOID)piADHandlerFactory;
    KdcADHandlerFactoryList.InsertElement(&pNewHandler->Next);

    return  STATUS_SUCCESS;
}




//
//  PAC handlers are static. Registration is for a handler, not a factory
//
NTSTATUS
WINAPI
KdcRegisterPACHandler(
    IN IPACHandler      *piPacHandler
    )
{
    if (piPacHandler == NULL)
        return  STATUS_INVALID_PARAMETER;
    PKDC_LIST_ENTRY pNewHandler = (PKDC_LIST_ENTRY)
        MIDL_user_allocate(sizeof(KDC_LIST_ENTRY));
    if (pNewHandler == NULL)
        return  STATUS_NO_MEMORY;
    pNewHandler->pData = (PVOID)piPacHandler;
    g_KdcPacHandlerList.InsertElement(&pNewHandler->Next);

    return STATUS_SUCCESS;
}

//  global crypt interface
//  it is a bit more complicated, since a crypt is per provider ...
//  but how would extensions that do not have crypt acquire the intf?
//  for now it's ok cause there's a single crypt
IKerbCrypt * __stdcall KdcGetICrypt(void)
{
    return  g_piKerbCrypt;
}



#if 0
//  unused API. Replace with PAC enum if necessary
//
// Iterate over each registered Pac handler can call the supplied
// function with the supplied data
//
KERBERR
KdcIteratePacHandler(
    IN PIKdbProvider            piKdb,
    IN PIKerbPrincipal          User,
    IN PIKerbRequest            pReq,
    IN BOOLEAN                  IsUpdate,
    OUT PPAC_INFO_BUFFER        *Info,
    OUT PKERB_EXT_ERROR         pExtendedError,
    IN KDC_PAC_ITERATE_FN       Func,
    IN OUT PVOID                Data
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PKDC_LIST_ENTRY HandlerEntry;

    g_KdcPacHandlerList.Lock.ReadLock();
    for (ListEntry = g_KdcPacHandlerList.Head.Flink;
         ListEntry && (ListEntry != &g_KdcPacHandlerList.Head);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);

        // Called holding PAC lock
        KerbErr = (*Func)(
                      piKdb,
                      User,
                      IsUpdate,
                      Info,
                      pExtendedError,
                      pReq,
                      (IPACHandler*)HandlerEntry->pData,
                      Data
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    g_KdcPacHandlerList.Lock.ReadUnlock();

    return KerbErr;
}
#endif


# if 0 // do later
NTSTATUS
WINAPI
KdcAddTicketExtHandler(
    IN SHORT            num_handlers,
    IN PKDC_TICKET_EXT_HANDLER handlers,
    OUT LONG            *ContextHandleIndex
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
WINAPI
KdcDeleteTicketExtHandler(
    IN LONG ContextHandleIndex
    )
{
    return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\kdctrace.cxx ===
//------------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File Name    :   kdctrace.cxx
// Abstract :   Core Trace initialization and globals.
// Created  :   vikask on 10/23/01   
// Revision History:
//
//------------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "kdctrace.hxx"

static HKEY hKdcParams = NULL;
static HMODULE hTraceLib = NULL;

//  GlobalTlsIndex
DWORD                   g_TraceTlsIndex = TLS_OUT_OF_INDEXES;
TRACE_INFO_BLOCK        g_tlsBlock;
PTRACE_INFO_BLOCK       g_ptlsBlock     = NULL;
TLS_BLOCK_LIST          g_tlsBlockList, *g_ptlsBlockList = NULL;
CRITICAL_SECTION    g_CriticalTlsSection;

//  This flag is needed to indicate whether a TLS index has been allocated by 
//  the core, in which case it needs to be freed during shutdown
BOOL                    g_fDefaultTracing                   = FALSE;
BOOL                    g_fCriticalTlsSectionInitialized    = FALSE;

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeTrace
//
//  Synopsis:   Initializes Tracing for the core
//              Initializes the TLS index, either by obtaining it from a trace 
//              dll if provided, or by allocating one.
//
//  Effects:    Initializes tracing
//
//  Arguments:  TraceDll    Dll from which to obtain the TlsIndex
//
//  Returns:    NTSTATUS
//                  STATUS_DLL_NOT_FOUND
//                  STATUS_PROCEDURE_NOT_FOUND
//                  STATUS_SUCCESS
//  Notes:                  
//
//--------------------------------------------------------------------------
NTSTATUS KdcInitializeTrace(
        IN OPTIONAL LPWSTR TraceDll
        )
{
    NTSTATUS NtStatus           = STATUS_SUCCESS;
    LPWSTR String               = NULL;
    DWORD cbSize                = 0;
    DWORD cbType;
    DWORD dwErr;
    
    g_ptlsBlockList             = &g_tlsBlockList;
    g_ptlsBlockList->next       = NULL;
    g_ptlsBlockList->infoBlock  = NULL;
    
    g_fCriticalTlsSectionInitialized = FALSE;
    InitializeCriticalSection(&g_CriticalTlsSection);

    g_fCriticalTlsSectionInitialized = TRUE;

    if (TraceDll)
    {
        g_fDefaultTracing = FALSE;
        hTraceLib = LoadLibraryW( TraceDll );
        if ( NULL == hTraceLib )
        {
            NtStatus = STATUS_DLL_NOT_FOUND;
        }
    }
    else
    {
        if (NULL == hKdcParams)
        {
            LONG lRes = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Services\\Kdc\\Parameters",
                   0,
                   KEY_READ,
                   &hKdcParams
                   );

            if (ERROR_SUCCESS != lRes)
            {
                DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            }
            else
            {
            }
        }
            
        //
        // Get trace DLL to load from registry
        //
        // HKLM/System/CCS/Services/Kdc/Parameters/TraceDll [REG_SZ] kdctrace.dll
        //
        
        dwErr = RegQueryValueExW(
                       hKdcParams,
                       L"TraceDll",
                       NULL,
                       &cbType,
                       NULL,
                       &cbSize
                       );

        if (dwErr == ERROR_SUCCESS)
        {
            if (cbType == REG_SZ && cbSize > 0)
            {
                String = (LPWSTR)MIDL_user_allocate(cbSize);
                if (NULL == String)
                {
                    goto Init;
                }
            }
            
            dwErr = RegQueryValueExW(
                          hKdcParams,
                          L"TraceDll",
                          NULL,
                          &cbType,
                          (LPBYTE)String,
                          &cbSize
                          );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_SZ &&
                cbSize > 0)
            {
                g_fDefaultTracing = FALSE;
                hTraceLib = LoadLibraryW( String );
                if ( NULL == hTraceLib )
                {
                    NtStatus = STATUS_DLL_NOT_FOUND;
                }
                if (String != NULL)
                {
                    MIDL_user_free(String);
                }
            }
        }
    }

Init:
    if (NT_SUCCESS(NtStatus) && hTraceLib) 
    {
        g_fDefaultTracing = FALSE;

        INITIALIZE_TRACE pfnInitializeTrace = (INITIALIZE_TRACE) GetProcAddress(
                                                hTraceLib, 
                                                "InitializeTrace"
                                                );
        if ( pfnInitializeTrace == NULL ) 
        {
            NtStatus = STATUS_PROCEDURE_NOT_FOUND;                
            goto Exit; 
        }
        else
        {
            if ( !pfnInitializeTrace() )
            {
                NtStatus = STATUS_DATA_ERROR;
                goto Exit;
            }
        }
            
        GET_TLS_INDEX pfnGetTlsIndex = (GET_TLS_INDEX) GetProcAddress(
                                                hTraceLib, 
                                                "GetTlsIndex"
                                                );
        if ( pfnGetTlsIndex == NULL ) 
        {
            NtStatus = STATUS_PROCEDURE_NOT_FOUND;                
            goto Exit; 
        } 
        else 
        {
            g_TraceTlsIndex = pfnGetTlsIndex();
            g_ptlsBlock  = (PTRACE_INFO_BLOCK)TlsGetValue(g_TraceTlsIndex);
            if (g_ptlsBlock) 
            {   
                //Tracing successfully initialized
                goto Exit;
            }
            //TlsBlock not initialized                
        }
    }
    else 
    {
        // Provide default implementation
        g_fDefaultTracing = TRUE;
        g_TraceTlsIndex = TlsAlloc();
        if (g_TraceTlsIndex == TLS_OUT_OF_INDEXES) 
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Exit;
        }
    }
    
    g_ptlsBlock = &g_tlsBlock;
    g_ptlsBlock->Categories = 0;    //Default Trace level
    g_ptlsBlock->pfnTrace   = NULL; //TODO : Write a default fn which calls debuglog
    g_ptlsBlock->pfnShutdown  = NULL;
    g_ptlsBlock->Buffer[0]  = L'\0';
    
    if (!TlsSetValue(g_TraceTlsIndex, (LPVOID)g_ptlsBlock)) 
    {                
        TlsFree(g_TraceTlsIndex);
        NtStatus = STATUS_DATA_ERROR;                
    }
    //end default
            
Exit:
    return NtStatus;
    
}

//+-------------------------------------------------------------------------
//
//  Function:   CheckIfTraceInitialized
//
//  Synopsis:   Prints trace message in the function which is doing intialization
//
//  Effects:    Initializes tracing
//
//  Notes:      This fn has been created because the TRACER utility cannot be 
//              used anywhere in the function which initializes tracing                 
//
//--------------------------------------------------------------------------

VOID CheckIfTraceInitialized() {
    TRACER(L"CheckIfTraceInitialized", NULL);
    TRACE_FILELINE(TRACE_VERB, (FILE_AND_LINE, L"Tracing initialized in Core"));   
}

//+-------------------------------------------------------------------------
//
//  Function:   AddTlsBlockToGlobalList
//
//  Synopsis:   Adds the newly allocated TlsBlock to the global list so that it
//              can be freed, or modified later
//
//  Arguments:  newBlock - ptr to TRACE_INFO_BLOCK to be added to the global list
//
//  Effects:    
//
//  Notes:                       
//
//--------------------------------------------------------------------------
NTSTATUS AddTlsBlockToGlobalList(
        IN PTRACE_INFO_BLOCK newBlock
        )
{
    NTSTATUS        NtStatus    = STATUS_SUCCESS;
    PTLS_BLOCK_LIST newNode     = 
            (PTLS_BLOCK_LIST)LocalAlloc(LPTR, sizeof(TLS_BLOCK_LIST));
    if (!newNode)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto exit;
    }
    newNode->infoBlock = newBlock;
    EnterCriticalSection(&g_CriticalTlsSection);
    newNode->next = g_ptlsBlockList;
    g_ptlsBlockList = newNode;
    LeaveCriticalSection(&g_CriticalTlsSection);
exit:
    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownTrace
//
//  Synopsis:   Frees the TLS block allocated to each thread serving KDC 
//              requests, and the TLS index if it was allocated by the core
//
//  Effects:    Tracing is disabled once this function is executed
//
//  Notes:                       
//
//--------------------------------------------------------------------------
VOID KdcShutdownTrace() 
{
    PTLS_BLOCK_LIST temp;

    if (g_fCriticalTlsSectionInitialized)
    {
        DeleteCriticalSection(&g_CriticalTlsSection);
    }
    
    if (g_ptlsBlock && g_ptlsBlock->pfnShutdown != NULL) 
    {
        g_ptlsBlock->pfnShutdown();
    }
    
    if (!g_ptlsBlockList)
    {
        return;
    }

    if (g_fDefaultTracing && (g_TraceTlsIndex != TLS_OUT_OF_INDEXES))
    {
        TlsFree(g_TraceTlsIndex);
    }
    
    while(g_ptlsBlockList && g_ptlsBlockList->infoBlock) 
    {    
        LocalFree(g_ptlsBlockList->infoBlock);
        temp = g_ptlsBlockList->next;
        LocalFree(g_ptlsBlockList);
        g_ptlsBlockList = temp;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeTlsPerRequest
//
//  Synopsis:   Copies global data to tls
//
//  Effects:
//
//  Arguments:  
//
//  Returns:   NTSTATUS : Request need not fail in case of error, 
//                 but no tracing will be done for that thread
//
//  Notes:     written by vikask (10.22.01)
//
//--------------------------------------------------------------------------
NTSTATUS InitializeTlsPerRequest() 
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PTRACE_INFO_BLOCK newBlock;

    newBlock = (PTRACE_INFO_BLOCK) TlsGetValue(g_TraceTlsIndex);
    if (!newBlock) 
    {
        //This thread is being accessed for the first time
        newBlock = (PTRACE_INFO_BLOCK) LocalAlloc(LPTR, sizeof(TRACE_INFO_BLOCK));
        if (newBlock == NULL) 
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        assert(g_ptlsBlock);
        if (!g_ptlsBlock)
        {
            //Need to find more appropriate error code - initialization no done
            NtStatus = STATUS_INVALID_SERVER_STATE;                                    
            goto Error;
        }
        newBlock->Categories = g_ptlsBlock->Categories;   
        newBlock->pfnTrace   = g_ptlsBlock->pfnTrace;

        if (!TlsSetValue(g_TraceTlsIndex, (LPVOID)newBlock)) 
        {
            //TODO: Find out if some other error code is more appropriate
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        // Add this block synchronously to global list so that it can be freed 
        // during shutdown
        NtStatus = AddTlsBlockToGlobalList(newBlock);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }
    else 
    {
        //This thread's TLS was initialized by a previous request
        //Any modifications on a per request basis can be done here
    }
    return NtStatus;
        
Error:
    if (newBlock) 
    {
        LocalFree(newBlock);
    } 
    TlsSetValue(g_TraceTlsIndex, NULL);
    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateTraceTLS
//
//  Synopsis:   Updates the Trace Level in all the threads
//
//  Effects:    
//
//  Arguments:  dwLevel - Trace level of TLS blocks in all threads is set to 
//              this
//
//  Returns:    None
//
//  Notes:      written by vikask (02.04.02)
//
//--------------------------------------------------------------------------
VOID KdcUpdateTraceLevel(IN DWORD dwLevel) 
{
    PTLS_BLOCK_LIST temp = g_ptlsBlockList;
    if (!temp)
    {
        return;
    }

    EnterCriticalSection(&g_CriticalTlsSection);
    while(temp && temp->infoBlock) 
    {
        (temp->infoBlock)->Categories = dwLevel;
        temp = temp->next;
    }
    LeaveCriticalSection(&g_CriticalTlsSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\kdb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       kdb.cxx
//
//  Contents:   KDB Support functions
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//              11-Sept-2001    yordanr - change to use new interfaces
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include "traceinterface.hxx"
#include "fileno.h"
#define FILENO FILENO_KDC

// Global table of KDB functions - Only modified at startup/shutdown

CKerbList ProvidersList;

PIKdbProvider KdbReferralRealm = NULL;
UNICODE_STRING KrbtgtName = {0};        // "krbtgt"

NTSTATUS WINAPI KdcRegisterProvider(
    IN  IKdbProvider    *piKdbProvider
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdcRegisterProvider", (PVOID *) &Status);

    if (piKdbProvider == NULL)
        return  STATUS_INVALID_PARAMETER;
    //  note the core does not set prov's tgt name ...

    //  see if it's a referral realm
    if (piKdbProvider->Flags() & KERB_KDB_REALM_REFERRAL)
    {
        if (KdbReferralRealm)
        {
            Status = STATUS_DOMAIN_EXISTS;
            return Status;
        }
        else
        {
            KdbReferralRealm = piKdbProvider;
        }
    }

    //  alloc a new list entry
    PKDC_LIST_ENTRY pNewEntry = (PKDC_LIST_ENTRY)MIDL_user_allocate(sizeof(KDC_LIST_ENTRY));
    if (pNewEntry == NULL)
    {
        Status = STATUS_NO_MEMORY;
        return  Status;
    }

    //  and initialize
    pNewEntry->pData = (PVOID)piKdbProvider;
    //  insert in prov list
    ProvidersList.InsertElement(&pNewEntry->Next);

    return  Status;
}


//
//  walk the providers to find one supporting the
//  requested realm
//
KERBERR
KdbRealmLocate(
    IN OPTIONAL PUNICODE_STRING Realm,
    OUT PIKdbProvider *ppiKdb
    )
{
    KERBERR KerbErr = KDC_ERR_WRONG_REALM;
    TRACER(L"KdbRealmLocate", (PVOID *) &KerbErr);

    PLIST_ENTRY ListEntry;
    PKDC_LIST_ENTRY KdbProvider = NULL;

    *ppiKdb = NULL;

    if (Realm != NULL)
    {
        ProvidersList.Lock.ReadLock();

        for (ListEntry = ProvidersList.Head.Flink;
             ListEntry && (ListEntry != &ProvidersList.Head);
             ListEntry = ListEntry->Flink)
        {
            KdbProvider = (PKDC_LIST_ENTRY)
                CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);
            ULONG cRealms = 0;
            LPCWSTR const *ppcwszRealms;
            if (((PIKdbProvider)
                KdbProvider->pData)->GetRealms(&cRealms,
                                                &ppcwszRealms) !=
                                                    STATUS_SUCCESS)
            {
                //  BUGBUG todo: log/trace prov could not return realms
                KerbErr = KRB_ERR_GENERIC;
                break;
            }
            while(cRealms--)
            {
                //  case insensitive?
                if (_wcsicmp(ppcwszRealms[cRealms], Realm->Buffer) == 0)
                {
                    *ppiKdb = (PIKdbProvider)KdbProvider->pData;
                    KerbErr = KDC_ERR_NONE;
                    break;
                }
            }
            if (*ppiKdb)
                break;
        }
        ProvidersList.Lock.ReadUnlock();
    }

    // No specific realm found, use the first one that supports referrals
    if (!KERB_SUCCESS(KerbErr) && KdbReferralRealm)
    {
        *ppiKdb = KdbReferralRealm;
        KerbErr = KDC_ERR_NONE;
    }

    return KerbErr;
}

//
//  kerbinterface uses slightly different signature
//
IKdbProvider* KdcGetProvider(PUNICODE_STRING pustrRealm)
{
    IKdbProvider *piKdb = NULL;
    KdbRealmLocate(pustrRealm, &piKdb);
    return  piKdb;
}


//
//  BUGBUG todo: fix these thru ILog etc interfaces
//  these will be
//

NTSTATUS
KdbAuditEvent(
    IN PIKdbProvider       KdbHandle,      // Realm handle
    IN KDC_AUDIT_EVENT  AuditId,
    IN PIKerbRequest  pIKerbRequest,
    IN PKERBERR         KerbStatus,
    IN PULONG           KdcOptions,
    IN PKERB_CRYPT_LIST EncryptionType,
    IN PULONG           PreauthType,
    IN PSOCKADDR        ClientAddress
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdbAuditEvent", (PVOID *)&Status);
    IAudit *pIAudit = KdbHandle ? KdbHandle->GetIAudit() : NULL;
    if (pIAudit == NULL) {
        Status = STATUS_NOT_IMPLEMENTED;
        goto Exit;
        }
    Status = pIAudit->Audit(
                    AuditId,
                    pIKerbRequest,
                    ClientAddress,
                    KerbStatus,
                    KdcOptions,
                    EncryptionType,
                    PreauthType
                    );
Exit:
    return Status;
}

//
//  Increment the perf counter 
//
NTSTATUS
KdbPerfCount(
    IN PIKdbProvider       KdbHandle,      // Realm handle
    IN KERB_PERF_COUNTER   counter
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdbPerfCount", (PVOID *)&Status);
    
    IPerfctr *pIPerfctr = KdbHandle ? KdbHandle->GetIPerfctr() : NULL;
    if (pIPerfctr == NULL) {
        Status = STATUS_NOT_IMPLEMENTED;
        goto Exit;
        }
    Status = pIPerfctr->Increment(
                    counter
                    );
Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\kdcext.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       kdcext.cxx
//
//  Contents:   KDC Extensions Support functions
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

//
// List for Context data
//
typedef struct _KDC_CONTEXT_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    KDC_CTX_FREE_FN FreeFn;
} KDC_CONTEXT_LIST_ENTRY, *PKDC_CONTEXT_LIST_ENTRY;

LIST_ENTRY KdcContextList;
LONG NextContextId = 0;
LONG CurrentContextCount = 0;

#define NO_CONTEXT_ID (-1)


CRWLock KdcContextListLock;
BOOLEAN KdcContextListInitialized = FALSE;

VOID KdcInitializeContextList(
    VOID
    )
{
    InitializeListHead(&KdcContextList);
    KdcContextListInitialized = TRUE;
}

//
// List for Pre-auth data handlers
//
typedef struct _KDC_PA_HANDLER_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_PADATA_HANDLER Handler;
} KDC_PA_HANDLER_LIST_ENTRY, *PKDC_PA_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcPAHandlerList;
BOOLEAN KdcPAHandlerListInitialized = FALSE;
CRWLock KdcPAHandlerListLock;

//
// List for auth data handlers
//
typedef struct _KDC_AD_HANDLER_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_AD_HANDLER     Handler;
} KDC_AD_HANDLER_LIST_ENTRY, *PKDC_AD_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcADHandlerList;
BOOLEAN KdcADHandlerListInitialized = FALSE;
CRWLock KdcADHandlerListLock;

//
// List for ticket ext handlers
//
typedef struct _KDC_TE_HANDLER_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_TICKET_EXT_HANDLER     Handler;
} KDC_TE_HANDLER_LIST_ENTRY, *PKDC_TE_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcTEHandlerList;
BOOLEAN KdcTEHandlerListInitialized = FALSE;
CRWLock KdcTEHandlerListLock;

//
// List for PAC handlers
//
typedef struct _KDC_PAC_HANDLER_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_PAC_HANDLER     Handler;
} KDC_PAC_HANDLER_LIST_ENTRY, *PKDC_PAC_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcPacHandlerList;
BOOLEAN KdcPacHandlerListInitialized = FALSE;
CRWLock KdcPacHandlerListLock;
LONG KdcPacHandlerCount = 0;

//
// Allocate and save a new Context
//
LONG
KdcAllocContextId(
    IN KDC_CTX_FREE_FN CtxFreeFn
    )
{
    PKDC_CONTEXT_LIST_ENTRY NewEntry = NULL;
    LONG Id = 0;
    
    if (!KdcContextListInitialized)
    {
        KdcInitializeContextList();
    }

    NewEntry = (PKDC_CONTEXT_LIST_ENTRY) MIDL_user_allocate(sizeof(KDC_CONTEXT_LIST_ENTRY));
    if (NewEntry == NULL) {
        Id = NO_CONTEXT_ID;
        goto Cleanup;
    }

    Id = NewEntry->Id = NextContextId;
    InterlockedIncrement(&NextContextId);
    NewEntry->FreeFn = CtxFreeFn;
    
    KdcContextListLock.WriteLock();
    InsertTailList(&KdcContextList, &NewEntry->Next);
    InterlockedIncrement(&CurrentContextCount);
    KdcContextListLock.WriteUnlock();

Cleanup:
    if (NewEntry && Id == NO_CONTEXT_ID)
    {
        MIDL_user_free(NewEntry);
    }

    return Id;
}

//
// Free and release a context
//
NTSTATUS
KdcFreeContextId(
    IN LONG Id
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PLIST_ENTRY ListEntry;
    PKDC_CONTEXT_LIST_ENTRY Entry;

    if (Id == NO_CONTEXT_ID)
        return STATUS_SUCCESS;
    
    KdcContextListLock.ReadLock();

    for (ListEntry = KdcContextList.Flink;
         ListEntry && (ListEntry != &KdcContextList);
         ListEntry = ListEntry->Flink)
    {
        Entry = (PKDC_CONTEXT_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_CONTEXT_LIST_ENTRY, Next);

        if (Entry->Id == Id)
        {
            KdcContextListLock.ReadToWriteLock();

            RemoveEntryList(&Entry->Next);
            // Don't adjust NextContextID

            InterlockedDecrement(&CurrentContextCount);
            MIDL_user_free(Entry);

            Status = STATUS_SUCCESS;
            break;
        }
    }

    KdcContextListLock.ReadUnlock();
    
    return Status;
}

//
// Allocate a complete context state
//
NTSTATUS
KdcAllocContext(
    OUT PKDC_REQUEST_CONTEXT *Context
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_CONTEXT_LIST_ENTRY Entry;
    PKDC_REQUEST_CONTEXT RetContext;
    INT ReqContextSize = 0;
    INT Index = 0;
    
    if (!KdcContextListInitialized)
    {
        KdcInitializeContextList();
    }

    // Allocate the context blob

    ReqContextSize = sizeof(KDC_REQUEST_CONTEXT) + 
                        (sizeof(KDC_REQUEST_CTX_PRIVATE) *
                         (CurrentContextCount - ANYSIZE_ARRAY));

    RetContext = (PKDC_REQUEST_CONTEXT) MIDL_user_allocate(ReqContextSize);

    if (RetContext == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ZeroMemory(
        RetContext, 
        ReqContextSize
        );

    RetContext->NumberOfContexts = CurrentContextCount;
    
    // Setup return structure
    KdcContextListLock.ReadLock();
    for (ListEntry = KdcContextList.Flink;
         ListEntry && (ListEntry != &KdcContextList);
         ListEntry = ListEntry->Flink)
    {
        Entry = (PKDC_CONTEXT_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_CONTEXT_LIST_ENTRY, Next);

        RetContext->Contexts[Index].FreeFn = Entry->FreeFn;
        RetContext->Contexts[Index].Context = NULL;
        Index++;
    }
    KdcContextListLock.ReadUnlock();
    
    *Context = RetContext;
    
    return STATUS_SUCCESS;
}

//
// Free a context state - also call the deallocators if
//      any private data has been allocated
//
NTSTATUS
KdcFreeContext(
    IN PKDC_REQUEST_CONTEXT Context
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS FreeStatus;
    INT Index;
    
    for (Index = 0; Index < Context->NumberOfContexts; Index++)
    {
        if (Context->Contexts[Index].Context &&
            Context->Contexts[Index].FreeFn)
        {
            FreeStatus = Context->Contexts[Index].FreeFn(
                             &Context->Contexts[Index]
                             );
            if (!NT_SUCCESS(FreeStatus))
            {
                // Remember first error
                if (NT_SUCCESS(Status))
                    Status = FreeStatus;
            }
        }
    }
    MIDL_user_free(Context);    // Allocated as a blob
    
    return Status;
}

NTSTATUS
KdcAddContextData(
    IN PKDC_REQUEST_CONTEXT Context,
    IN LONG Id,
    IN PVOID Data
    )
{
    DsysAssert(Context->NumberOfContexts > Id);
    Context->Contexts[Id].Context = Data;

    return STATUS_SUCCESS;
}

//
// Helper functions for add/delete handlers
//
NTSTATUS
WINAPI
KdcAddPADataHandler(
    IN SHORT            NumberOfHandlers,
    IN PKDC_PADATA_HANDLER Handlers,
    OUT OPTIONAL LONG   *ContextIndex
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG ContextId = NO_CONTEXT_ID;    
    INT i;
    PKDC_PA_HANDLER_LIST_ENTRY NewHandler;
    
    if (!KdcPAHandlerListInitialized)
    {
        InitializeListHead(&KdcPAHandlerList);
        KdcPAHandlerListInitialized = TRUE;
    }

    if (NumberOfHandlers == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    // All handlers share the same context ID and free function
    // Note: Context ID is only allocated if needed. If omitted
    // There is no context data space reserved.
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        ContextId = KdcAllocContextId(
                       Handlers[0].ctx_free
                       );
        if (ContextId == NO_CONTEXT_ID)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    // Register the handlers
    for (i = 0; i < NumberOfHandlers; i++)
    {
        NewHandler = (PKDC_PA_HANDLER_LIST_ENTRY)
            MIDL_user_allocate(sizeof(KDC_PA_HANDLER_LIST_ENTRY));

        if (NewHandler == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NewHandler->Id = ContextId;
        NewHandler->Handler = &Handlers[i];

        KdcPAHandlerListLock.WriteLock();
        InsertTailList(&KdcPAHandlerList, &NewHandler->Next);
        KdcPAHandlerListLock.WriteUnlock();
    }
    
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        *ContextIndex = ContextId;
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KdcFreeContextId(ContextId);
    }
    return Status;
}


NTSTATUS
WINAPI
KdcDeletePADataHandler(
    IN LONG ContextIndex
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PLIST_ENTRY ListEntry;
    PKDC_PA_HANDLER_LIST_ENTRY Handler;
    BOOL WriteLock = FALSE ;
    
    KdcPAHandlerListLock.ReadLock();
    for (ListEntry = KdcPAHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPAHandlerList);
         ListEntry = ListEntry->Flink)
    {
        Handler = (PKDC_PA_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PA_HANDLER_LIST_ENTRY, Next);

        if (Handler->Id == ContextIndex)
        {
            KdcPAHandlerListLock.ReadToWriteLock();
            WriteLock = TRUE ;
            RemoveEntryList(&Handler->Next);
            MIDL_user_free(Handler);
            Status = STATUS_SUCCESS;
            break;
        }
    }
    if ( !WriteLock )
    {
        KdcPAHandlerListLock.ReadUnlock();
        
    }
    else
    {
        KdcPAHandlerListLock.WriteUnlock();
    }
    
    return Status;
}

PKDC_PADATA_HANDLER
KdcLocatePADataHandler(
    IN DWORD PaType,
    IN BOOLEAN IsTgs
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_PA_HANDLER_LIST_ENTRY HandlerEntry;
    PKDC_PADATA_HANDLER RetHandler = NULL;
    
    KdcPAHandlerListLock.ReadLock();
    for (ListEntry = KdcPAHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPAHandlerList);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_PA_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PA_HANDLER_LIST_ENTRY, Next);

        if ((HandlerEntry->Handler->pa_type == PaType) &&
            (((HandlerEntry->Handler->pa_flags & KERB_PADATA_TGS) && IsTgs) ||
             ((HandlerEntry->Handler->pa_flags & KERB_PADATA_AS) && !IsTgs)))
        {
            RetHandler = HandlerEntry->Handler;
            break;
        }
    }
    KdcPAHandlerListLock.ReadUnlock();
    
    return RetHandler;
}

//
// Iterate over each registered PA handler can call the supplied
// function with the supplied data
//

KERBERR
KdcIteratePADataHandler(
    IN KDB_HANDLE Kdb,
    IN KERB_SERVICE_ID ServiceId,
    IN PKDB_PRINC_INFO ClientPrinc,
    IN OPTIONAL PKDB_PRINC_INFO ServicePrinc,
    IN PKERB_KDC_REQUEST_BODY Request,
    IN CONST ULONG PreAuthType,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY ServiceKey,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext,
    IN KDC_PADATA_ITERATE_FN Func,
    IN OUT PVOID Data
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PKDC_PA_HANDLER_LIST_ENTRY HandlerEntry;
    
    KdcPAHandlerListLock.ReadLock();
    for (ListEntry = KdcPAHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPAHandlerList);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_PA_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PA_HANDLER_LIST_ENTRY, Next);

        // Call holding PA-DATA lock
        KerbErr = (*Func)(
                      Kdb,
                      ServiceId,
                      ClientPrinc,
                      ServicePrinc,
                      Request,
                      PreAuthType,
                      SessionKey,
                      ServiceKey,
                      ReqContext,
                      HandlerEntry->Handler,
                      Data
                      );
        
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    KdcPAHandlerListLock.ReadUnlock();
    
    return KerbErr;
}


NTSTATUS
WINAPI
KdcAddADHandler(
    IN SHORT            NumberOfHandlers,
    IN PKDC_AD_HANDLER  Handlers,
    OUT LONG            *ContextIndex
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG ContextId = NO_CONTEXT_ID;    
    INT i;
    PKDC_AD_HANDLER_LIST_ENTRY NewHandler;
    
    if (!KdcADHandlerListInitialized)
    {
        InitializeListHead(&KdcADHandlerList);
        KdcADHandlerListInitialized = TRUE;
    }

    if (NumberOfHandlers == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    // All handlers share the same context ID and free function
    // Note: Context ID is only allocated if needed. If omitted
    // There is no context data space reserved.
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        ContextId = KdcAllocContextId(
                       Handlers[0].ctx_free
                       );
        if (ContextId == NO_CONTEXT_ID)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    // Register the handlers
    for (i = 0; i < NumberOfHandlers; i++)
    {
        NewHandler = (PKDC_AD_HANDLER_LIST_ENTRY)
            MIDL_user_allocate(sizeof(KDC_AD_HANDLER_LIST_ENTRY));

        if (NewHandler == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NewHandler->Id = ContextId;
        NewHandler->Handler = &Handlers[i];

        KdcADHandlerListLock.WriteLock();
        InsertTailList(&KdcADHandlerList, &NewHandler->Next);
        KdcADHandlerListLock.WriteUnlock();
    }
    
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        *ContextIndex = ContextId;
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KdcFreeContextId(ContextId);
    }
    return Status;
}


NTSTATUS
WINAPI
KdcDeleteADHandler(
    IN LONG ContextIndex
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PLIST_ENTRY ListEntry;
    PKDC_AD_HANDLER_LIST_ENTRY Handler;
    BOOL WriteLock = FALSE ;
    
    KdcADHandlerListLock.ReadLock();
    for (ListEntry = KdcADHandlerList.Flink;
         ListEntry && (ListEntry != &KdcADHandlerList);
         ListEntry = ListEntry->Flink)
    {
        Handler = (PKDC_AD_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_AD_HANDLER_LIST_ENTRY, Next);

        if (Handler->Id == ContextIndex)
        {
            KdcADHandlerListLock.ReadToWriteLock();
            WriteLock = TRUE ;
            RemoveEntryList(&Handler->Next);
            MIDL_user_free(Handler);
            Status = STATUS_SUCCESS;
            break;
        }
    }

    if ( !WriteLock )
    {
        KdcADHandlerListLock.ReadUnlock();
        
    }
    else 
    {
        KdcADHandlerListLock.WriteUnlock();
    }
    
    return Status;
}

//
// Iterate over each registered PA handler can call the supplied
// function with the supplied data
//

KERBERR
KdcIterateAuthDataHandler(
    IN KDB_HANDLE		KdbHandle,
    IN KERB_SERVICE_ID		Service,
    IN PKDB_PRINC_INFO		ClientInfo,
    IN PKDB_PRINC_INFO		ServiceInfo,
    IN PKERB_KDC_REQUEST_BODY	RequestBody,
    IN CONST ULONG    		PreAuthType,
    IN PKERB_ENCRYPTION_KEY	SessionKey,
    IN PKERB_ENCRYPTION_KEY 	OldServiceKey,
    IN PKERB_ENCRYPTION_KEY 	NewServiceKey,
    IN OUT PKERB_ENCRYPTED_TICKET EncryptedTicket,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext,
    IN KDC_AD_ITERATE_FN        Func,
    IN OUT PVOID                Data
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PKDC_AD_HANDLER_LIST_ENTRY HandlerEntry;
    
    KdcADHandlerListLock.ReadLock();
    for (ListEntry = KdcADHandlerList.Flink;
         ListEntry && (ListEntry != &KdcADHandlerList);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_AD_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_AD_HANDLER_LIST_ENTRY, Next);

        // Called holding AUTHDATA lock
        KerbErr = (*Func)(
                      KdbHandle,
                      Service,
                      ClientInfo,
                      ServiceInfo,
                      RequestBody,
                      PreAuthType,
                      SessionKey,
                      OldServiceKey,
                      NewServiceKey,
                      EncryptedTicket,
                      ExtendedError,
                      ReqContext,
                      HandlerEntry->Handler,
                      Data
                      );
        
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    KdcADHandlerListLock.ReadUnlock();
    
    return KerbErr;
}

NTSTATUS
WINAPI
KdcAddPacHandler(
    IN SHORT            NumberOfHandlers,
    IN PKDC_PAC_HANDLER  Handlers,
    OUT LONG            *ContextIndex
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG ContextId = NO_CONTEXT_ID;    
    INT i;
    PKDC_PAC_HANDLER_LIST_ENTRY NewHandler;
    
    if (!KdcPacHandlerListInitialized)
    {
        InitializeListHead(&KdcPacHandlerList);
        KdcPacHandlerListInitialized = TRUE;
    }

    if (NumberOfHandlers == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    // All handlers share the same context ID and free function
    // Note: Context ID is only allocated if needed. If omitted
    // There is no context data space reserved.
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        ContextId = KdcAllocContextId(
                       Handlers[0].ctx_free
                       );
        if (ContextId == NO_CONTEXT_ID)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    // Register the handlers
    for (i = 0; i < NumberOfHandlers; i++)
    {
        NewHandler = (PKDC_PAC_HANDLER_LIST_ENTRY)
            MIDL_user_allocate(sizeof(KDC_PAC_HANDLER_LIST_ENTRY));

        if (NewHandler == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NewHandler->Id = ContextId;
        NewHandler->Handler = &Handlers[i];

        KdcPacHandlerListLock.WriteLock();
        InsertTailList(&KdcPacHandlerList, &NewHandler->Next);
        InterlockedIncrement(&KdcPacHandlerCount);
        KdcPacHandlerListLock.WriteUnlock();
    }
    
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        *ContextIndex = ContextId;
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KdcFreeContextId(ContextId);
    }
    return Status;
}


NTSTATUS
WINAPI
KdcDeletePacHandler(
    IN LONG ContextIndex
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PLIST_ENTRY ListEntry;
    PKDC_PAC_HANDLER_LIST_ENTRY Handler;
    BOOL WriteLock = FALSE ;
    
    KdcPacHandlerListLock.ReadLock();
    for (ListEntry = KdcPacHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPacHandlerList);
         ListEntry = ListEntry->Flink)
    {
        Handler = (PKDC_PAC_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PAC_HANDLER_LIST_ENTRY, Next);

        if (Handler->Id == ContextIndex)
        {
            KdcPacHandlerListLock.ReadToWriteLock();
            WriteLock = TRUE ;
            RemoveEntryList(&Handler->Next);
            MIDL_user_free(Handler);
            InterlockedDecrement(&KdcPacHandlerCount);
            Status = STATUS_SUCCESS;
            break;
        }
    }

    if ( !WriteLock )
    {
        KdcPacHandlerListLock.ReadUnlock();
        
    }
    else 
    {
        KdcPacHandlerListLock.WriteUnlock();
    }

    
    return Status;
}

//
// Iterate over each registered Pac handler can call the supplied
// function with the supplied data
//

KERBERR
KdcIteratePacHandler(
    IN KDB_HANDLE               KdbHandle,
    IN PKDB_PRINC_INFO          User,
    IN BOOLEAN                  IsUpdate,
    IN PKERB_ENCRYPTED_TICKET   EncryptedTicket,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PPAC_INFO_BUFFER        *Info,
    OUT PKERB_EXT_ERROR         pExtendedError,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext,
    IN KDC_PAC_ITERATE_FN       Func,
    IN OUT PVOID                Data
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PKDC_PAC_HANDLER_LIST_ENTRY HandlerEntry;
    
    KdcPacHandlerListLock.ReadLock();
    for (ListEntry = KdcPacHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPacHandlerList);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_PAC_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PAC_HANDLER_LIST_ENTRY, Next);

        // Called holding PAC lock
        KerbErr = (*Func)(
                      KdbHandle,
                      User,
                      IsUpdate,
                      EncryptedTicket,
                      CredentialKey,
                      Info,
                      pExtendedError,
                      ReqContext,
                      HandlerEntry->Handler,
                      Data
                      );
        
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    KdcPacHandlerListLock.ReadUnlock();
    
    return KerbErr;
}


INT
KdcNumberOfPacHandlers(
    VOID
    )
{
    return KdcPacHandlerCount;
}


NTSTATUS
WINAPI
KdcAddTicketExtHandler(
    IN SHORT            num_handlers,
    IN PKDC_TICKET_EXT_HANDLER handlers,
    OUT LONG            *ContextHandleIndex
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
WINAPI
KdcDeleteTicketExtHandler(
    IN LONG ContextHandleIndex
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\KdcEvent.cxx ===
//------------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File Name    :   KerbEvent.cxx
// Abstract :   interface for the IEvent class.
// Created  :   vikask on 9/27/01   
// Revision History:
//
//------------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "KdcEventInterface.hxx"

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgPtr) ( (CHAR*)(ArgPtr) != (CHAR*)(NULL) )
#endif

#define HKEY_EVENTLOG TEXT("System\\CurrentControlSet\\Services\\Eventlog\\Application")
#define TYPES_SUPPORTED TEXT("TypesSupported")
#define EVENT_MSGFILE TEXT("EventMessageFile")
#define CATEGORY_COUNT TEXT("CategoryCount")
#define DISABLE_EVENTS TEXT("DisableEvents")

class CEvent : public IEvent
{
private:
    static WORD convertEvent ( 
        const IEvent::TYPE type )
    {
        switch (type)
        {
            case IEvent::ERROR_TYPE:
                return EVENTLOG_ERROR_TYPE;
            case IEvent::WARNING_TYPE:
                return EVENTLOG_WARNING_TYPE;
            case IEvent::INFORMATION_TYPE:
                return EVENTLOG_INFORMATION_TYPE;
            case IEvent::AUDIT_SUCCESS:
                return EVENTLOG_AUDIT_SUCCESS;
            case IEvent::AUDIT_FAILURE:
                return EVENTLOG_AUDIT_FAILURE;
            default:
                return EVENTLOG_ERROR_TYPE;
        }
    };
public:
    CEvent(){};
    ~CEvent(){};

    //
    //    IEvent methods
    //
    
    virtual BOOL ReportEventFullU(
                IN IEvent::TYPE                     EventType,
                IN DWORD                            EventId,
                IN DWORD                            dwRawDataSize,
                IN const VOID                      *pvRawData,
                IN ULONG                              uUnicodeStringCount,
                ...
                ) ;
    
        virtual BOOL ReportEventFullW(
                IN IEvent::TYPE                     EventType,
                IN DWORD                            EventId,
                IN DWORD                            dwRawDataSize,
                IN const VOID                      *pvRawData,
                IN ULONG                             uStringCount,
                ...
                ) ;
};

//+-------------------------------------------------------------------------
//
//  Function:   CEvent::ReportEventFullU
//
//  Synopsis:   Report an Event, i.e. writes an entry at the end of the event
//              log (IEvent::m_eventSource - Handle to the event log)
//
//  Effects:
//
//  Arguments:  EventType          - {INFORMATION,WARNING,ERROR}_TYPE
//              EventId            -    Message that goes with this event
//              dwRawDataSize      - # of VOIDs of event-specific raw data
//              pvRawData           - Raw Data
//              uUnicodeStringCount - # of unicode strings 
//
//  Returns:    TRUE    success
//              FALSE   failure
//
//  Notes:
//
//--------------------------------------------------------------------------
          
BOOL CEvent::ReportEventFullU(
                IN IEvent::TYPE                     EventType,
                IN DWORD                            dwEventId,
                IN DWORD                            dwRawDataSize,
                IN const VOID                      *pvRawData,
                IN ULONG                              uUnicodeStringCount,
                ...
                )
{
    if(IEvent::m_bDisabled)
    {
        return TRUE;
    }
    
    if (!IEvent::m_inited)
    {
        return FALSE;
    }
    
    BOOL result;
    WCHAR **pszStrings = NULL;

    pszStrings = (WCHAR **)
                LocalAlloc(0, uUnicodeStringCount * sizeof(WCHAR *));  
    if (!pszStrings) 
    {
        return FALSE;
    }
    
    va_list     parms;
    va_start(parms, uUnicodeStringCount);
    
    for (int i = 0; i < (WORD)uUnicodeStringCount; i++ ) 
    {
        PUNICODE_STRING pustrTempStr = va_arg(parms, PUNICODE_STRING);   
        pszStrings[i] = (WCHAR *) LocalAlloc(0, MAX_STR * sizeof(WCHAR));
        if (!pszStrings[i]) 
        {
            for (int j = 0; j < i; j++) 
            {
                LocalFree(pszStrings[j]);            
            }
            LocalFree(pszStrings);
            return FALSE;
        }
        wcsncpy(pszStrings[i], pustrTempStr->Buffer, pustrTempStr->Length);
        pszStrings[i][pustrTempStr->Length] = L'\0';
    }
    
    result = ReportEvent(IEvent::m_eventSource,
                        (WORD)convertEvent(EventType),
                        (WORD)IEvent::m_defaultCategoryID,
                        dwEventId,
                        NULL,                   
                        (WORD)uUnicodeStringCount,
                        dwRawDataSize,
                        (LPCTSTR*)pszStrings,
                        (LPVOID)pvRawData
                        );  
    for (int i =0; i < (WORD)uUnicodeStringCount; i++ ) 
    {
        LocalFree(pszStrings[i]);
    }
    LocalFree(pszStrings);
    return result;
}

//+-------------------------------------------------------------------------
//
//  Function:   CEvent::ReportEventFullW
//
//  Synopsis:   Report an Event, i.e. writes an entry at the end of the event
//              log (IEvent::m_eventSource - Handle to the event log)
//
//  Effects:
//
//  Arguments:  
//              EventType          - {INFORMATION,WARNING,ERROR}_TYPE
//              dwEventId            -    Message that goes with this event
//              dwRawDataSize      - # of VOIDs of event-specific raw data
//              pvRawData           - Raw Data
//              uStringCount - # of unicode strings 
//
//  Returns:    TRUE    success
//              FALSE   failure
//
//  Notes:
//
//--------------------------------------------------------------------------
          
BOOL CEvent::ReportEventFullW(
                IN IEvent::TYPE                     EventType,
                IN DWORD                            dwEventId,
                IN DWORD                            dwRawDataSize,
                IN const VOID                      *pvRawData,
                IN ULONG                              uStringCount,
                ...
                )
{
    if(IEvent::m_bDisabled)
    {
        return TRUE;
    }
    
    if (!IEvent::m_inited)
    {
        return FALSE;
    }
    
    BOOL result;
    WCHAR **pszStrings;
    pszStrings = (WCHAR **)
                LocalAlloc(0, uStringCount * sizeof(WCHAR *));  
    if (!pszStrings) 
    {
        return FALSE;
    }
    
    va_list     parms;
    va_start(parms, uStringCount);
    
    for (int i=0; i < (WORD)uStringCount; i++ ) 
    {
        pszStrings[i] = va_arg(parms, LPWSTR);
    }
    
    result = ReportEvent(
                        IEvent::m_eventSource,
                        (WORD)convertEvent(EventType),
                        (WORD)IEvent::m_defaultCategoryID,
                        dwEventId,
                        NULL,       //OPTIONAL: current user's security identifier
                        (WORD)uStringCount,
                        dwRawDataSize,
                        (LPCTSTR*)pszStrings,
                        (LPVOID)pvRawData
                        );  

    LocalFree(pszStrings);
    return result;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeEventObject
//
//  Synopsis:   Initializes the event object, the registry key & retrieves
//              a handle to the event log.
//
//  Effects:
//
//  Arguments:  applicationName      - Source name
//              defaultCategoryID    - Optional Event Category (default 0)
//              eventResourceDllName - Optional EventMessageFile (default NULL)
//              numberCategories     - Optional Category Count (default 0)
//              ppObject                   - pointer to pointer to IEvent object
//
//  Returns:    TRUE    success
//              FALSE   failure
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOL KdcInitializeEventObject(
                        IN LPWSTR                   applicationName,
                        IN OPTIONAL DWORD   defaultCategoryID,
                        IN OPTIONAL LPWSTR  eventResourceDllName,  // full path
                        IN OPTIONAL DWORD   numberCategories,
                        OUT IEvent                  **ppObject                        
                        )
{
    CEvent  *pCEvent = NULL;
    pCEvent = new CEvent;

    if (!pCEvent) 
    {
        return FALSE;
    }
    
    *ppObject = pCEvent;
    
    HKEY hkResult = NULL;
    
    if ( !ARGUMENT_PRESENT(defaultCategoryID) )
    {
        defaultCategoryID = 0;
    }
    
    if ( !ARGUMENT_PRESENT(eventResourceDllName) )
    {
        eventResourceDllName = NULL;
    }
    
    if ( !ARGUMENT_PRESENT(numberCategories) )
    {
        numberCategories = 0;
    }
    
    if (pCEvent->m_inited)
    {
        return FALSE;
    }

    pCEvent->m_defaultCategoryID = defaultCategoryID;

    WCHAR szEventLogKey[MAX_STR];   //TODO: Must allocate using safe alloc    
    size_t length = 0, tempLen = 0;
    while ((length < (MAX_STR-1)) && (tempLen < wcslen(HKEY_EVENTLOG)))
    {
        szEventLogKey[length++] = applicationName[tempLen++];
    }
    if (length < (MAX_STR-1))
    {
        szEventLogKey[length++] = L'\\';
    }
    tempLen = 0;
    while ((length < (MAX_STR-1)) && (tempLen < wcslen(applicationName)))
    {
        szEventLogKey[length++] = HKEY_EVENTLOG[tempLen++];
    }
    szEventLogKey[length] = L'\0';
   
    if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szEventLogKey,
                    0,
                    KEY_READ,
                    &hkResult
                    ) != ERROR_SUCCESS)
    {
        ;//this is OK, events can still be logged w/o strings
    }

    const DWORD dwType = 0x07;  //bitmask of supported types
    DWORD dwLen = sizeof(DWORD);

    
    // TODO : Check for hkResult
    if (!hkResult || (RegSetValueEx(
                                hkResult, 
                                TYPES_SUPPORTED, 
                                0,
                                REG_DWORD,
                                (UCHAR*)&dwType, 
                                 dwLen
                                ) != ERROR_SUCCESS
                            )
        ) 
    {
        ;////this is OK, events can still be logged w/o strings
    }

    if (eventResourceDllName)
    {
        if (!hkResult || (RegSetValueEx(
                                hkResult, 
                                EVENT_MSGFILE, 
                                0,
                                REG_SZ, 
                                (const BYTE *)eventResourceDllName,
                                lstrlen(eventResourceDllName) * sizeof(WCHAR)
                                ) != ERROR_SUCCESS)
            )
        {
            ;////this is OK, events can still be logged w/o strings
        }
       
        if (!hkResult || (RegSetValueEx(
                                hkResult,
                                CATEGORY_COUNT,
                                0,
                                REG_DWORD,
                                (UCHAR*)&numberCategories,
                                dwLen
                                ) != ERROR_SUCCESS)
            )                      
        {
            ;////this is OK, events can still be logged w/o strings
        }
    }

    if (hkResult) {
        RegQueryValueEx(hkResult,
                    DISABLE_EVENTS,
                    0,
                    NULL,
                    (UCHAR*)&pCEvent->m_bDisabled,
                    &dwLen
                    );
        RegCloseKey(hkResult);
        }

    pCEvent->m_eventSource = RegisterEventSource(NULL, applicationName);
    
    if ( pCEvent->m_eventSource != NULL )
    {
        pCEvent->m_inited = TRUE;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


void 
KdcFreeEventObject ( IN IEvent * pObject )
{
    if (pObject) 
    {
        DeregisterEventSource(pObject->m_eventSource);
        delete (pObject);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\kdc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KDC.CXX
//
// Contents:    Base part of the KDC.  Global vars, main functions, init
//
//
// History:
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
//  service interface
#include <kerbserv.hxx>

extern "C" {
#include <lmserver.h>
#include <dsgetdc.h>
#include <windns.h>
}
//#include <alloca.h>
#include "rpcif.h"
#include "fileno.h"
#define  FILENO FILENO_KDC

#ifndef SERVICE_KDC
#define SERVICE_KDC TEXT("KDC")
#endif

#include "kdctrace.hxx"
#include "kdceventinterface.hxx"
#include "kdccoreEvents.h"
#include "kerbinterface.h"
#include "kerbcrypt.hxx"

#include "kdcmem.hxx"
#include "kdccore.hxx"

//
// Global data
//

KDC_STATE KdcState = Stopped;                   // used to signal when
                                                // authenticated RPC is
                                                // ready to use - e.g.
                                                // spmgr has found the
                                                // kdc

NTSTATUS ShutdownStatus = STATUS_SUCCESS;

//  KdcService supplied functions
//  set status using this fn ptr
VOID (WINAPI *g_pfnSetStatus)(DWORD);
//  start/stop transport
FNKDC_START_TRANSPORT g_pfnStartTransport;
FNKDC_STOP_TRANSPORT  g_pfnStopTransport;

UNICODE_STRING KDCMachineName;                  // The computer name of this KDC

#if DBG
LARGE_INTEGER tsIn,tsOut;
#endif

//
// Registry config values
//

const BOOL KdcUseClientAddressesDefault = FALSE;
const BOOL KdcDontCheckAddressesDefault = TRUE;

BOOL KdcUseClientAddresses = KdcUseClientAddressesDefault;
BOOL KdcDontCheckAddresses = KdcDontCheckAddressesDefault;
LPTSTR_ARRAY KdcGlobalProviderDlls = NULL;
LPTSTR_ARRAY KdcParamProviders = NULL;


//
// This keeps a registry key handle to the
// HKLM\System\CCSet\Services\Kdc\Paramters key
//

HKEY hKdcParams = NULL;

//
// This keeps a registry key handle to the
// HKLM\System\CCSet\Services\Kdc\Paramters\Atq key
//

HKEY hAtqParams = NULL;

//
// This keeps any ATQ config params loaded
// from the registry.
//

ATQ_CONFIG_PARM AtqParms = {
    ATQ_CONFIG_PARM_DEFAULT,
    ATQ_CONFIG_PARM_DEFAULT,
    ATQ_CONFIG_PARM_DEFAULT,
    ATQ_CONFIG_PARM_DEFAULT
};

HANDLE hKdcWait = NULL;
HANDLE hKdcParamEvent = NULL ;


CRITICAL_SECTION ApiCriticalSection;
ULONG CurrentApiCallers;
HANDLE hKdcHandles[MAX_KDC_HANDLE] = {0};
HANDLE hKdcShutdownCompleteEvent = NULL;

//
//  TBD: move it elsewhere ?
//
CKerbCryptDll       g_cKerbCryptDll;
IKerbCrypt   *g_piKerbCrypt = &g_cKerbCryptDll;

//
//  KDCCore interface
//
IKdcCore g_KdcCore = {
    KdcAllocMemory,
    KdcFreeMemory,
    KdcRegisterProvider,
    KdcRegisterPAHandlerFactory,
    KdcRegisterADHandlerFactory,
    KdcRegisterPACHandler,
    KdcGetProvider,
    KdcGetICrypt,
    KdcCreateADHandlerInstance,
    KerbUnpackData,
    KerbPackData,
    KerbFreeData,
    KerbHashPasswordEx,
    KerbEqualKdcNames,
    KerbBuildKeySalt,
    KerbConvertStringToKdcName,
    KerbBuildFullServiceKdcName,
    KerbUnicodeStringToKerbString,
    KerbDuplicateKdcName,
    KerbConvertKdcNameToString,
    KerbConvertSidToString,
    KdcInitializeEventObject,
    KdcFreeEventObject,
    KerbConvertFlagsToUlong,
    KerbComputePaCompIdentityKeyForPrincipal,
}, *g_piKdcCore = &g_KdcCore;

IEvent  *coreEventObject;
//
// Prototypes
//

//+---------------------------------------------------------------------------
//
//  Function:   GetServiceStatus
//
//  Synopsis:   returns current service status
//
//  Effects:    none
//
//  Arguments:  none
//
//  History:    Oct-03-2001 yordanr Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG   WINAPI KdcGetServiceStatus()
{
    switch(KdcState)
    {
    case Running:
        return SERVICE_RUNNING;

    case Starting:
        return SERVICE_START_PENDING;

    case Stopped:
    default:
        return  SERVICE_STOPPED;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateStatus
//
//  Synopsis:   Hook to update the KDC's service status with the registered
//              service controller
//
//  Effects:
//
//  Arguments:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
UpdateStatus(DWORD   dwState)
{
    if (g_pfnSetStatus)
    {
        (*g_pfnSetStatus)(dwState);
    }
    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Name:       KerbGetKdcRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry
//
//  Arguments:  HKEY to HKLM/System/CCS/Services/Kdc/Parameters
//
//  Notes:      Sets KDCInfolevel for debug spew
//
//--------------------------------------------------------------------------

void
KerbGetKdcRegParams(HKEY ParamKey)
{
    DWORD       cbType, Value, cbSize;
    DWORD       dwErr;
    LPTSTR_ARRAY String = NULL;


    //
    // Check if KDC is to propogate addresses to tickets (in as-req)
    //
    // HKLM/System/CCS/Services/Kdc/Parameters/KdcUseClientAddresses [DWORD] 0
    //

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               L"KdcUseClientAddresses",
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        if ( Value != 0 )
        {
            KdcUseClientAddresses = TRUE;
        }
        else
        {
            KdcUseClientAddresses = FALSE;
        }
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       KdcUseClientAddresses = KdcUseClientAddressesDefault;
    }


    //
    // Check if KDC is not to check addresses in tickets
    //
    // HKLM/System/CCS/Services/Kdc/Parameters/KdcDontCheckAddresses [DWORD] 0
    //

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               L"KdcDontCheckAddresses",
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        if ( Value != 0 )
        {
            KdcDontCheckAddresses = TRUE;
        }
        else
        {
            KdcDontCheckAddresses = FALSE;
        }
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       KdcDontCheckAddresses = KdcDontCheckAddressesDefault;
    }


    //
    // Check if ATQ configuration parameters are specified
    //
    // HKLM/System/CCS/Services/Kdc/Parameters/Atq/Threads [DWORD] 128
    // HKLM/System/CCS/Services/Kdc/Parameters/Atq/ConcurrentThreads [DWORD] 0
    // HKLM/System/CCS/Services/Kdc/Parameters/Atq/SecThreadTimeOut [DWORD] 43200
    // HKLM/System/CCS/Services/Kdc/Parameters/Atq/MinKBTimeOut [DWORD] 1
    //
    if ( NULL == hAtqParams )
    {
        dwErr = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Services\\Kdc\\Parameters\\Atq",
                   0,
                   KEY_READ,
                   &hAtqParams
                   );

        if ( dwErr == ERROR_SUCCESS )
        {
            DWORD dwThreads = 0;
            DWORD dwConcurrentThreads = 0;
            DWORD dwSecThreadTimeOut = 0;
            DWORD dwMinKBTimeOut = 0;

            cbSize = sizeof(dwThreads);
            dwErr = RegQueryValueExW(
                       hAtqParams,
                       L"Threads",
                       NULL,
                       &cbType,
                       (LPBYTE)&dwThreads,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_DWORD &&
                cbSize == sizeof(DWORD))
            {
                AtqParms.dwThreads = dwThreads;
            }
            else
            {
                AtqParms.dwThreads = ATQ_CONFIG_PARM_DEFAULT;
            }

            cbSize = sizeof(dwConcurrentThreads);
            dwErr = RegQueryValueExW(
                       hAtqParams,
                       L"ConcurrentThreads",
                       NULL,
                       &cbType,
                       (LPBYTE)&dwConcurrentThreads,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_DWORD &&
                cbSize == sizeof(DWORD))
            {
                AtqParms.dwConcurrentThreads = dwConcurrentThreads;
            }
            else
            {
                AtqParms.dwConcurrentThreads = ATQ_CONFIG_PARM_DEFAULT;
            }

            cbSize = sizeof(dwSecThreadTimeOut);
            dwErr = RegQueryValueExW(
                       hAtqParams,
                       L"SecThreadTimeOut",
                       NULL,
                       &cbType,
                       (LPBYTE)&dwSecThreadTimeOut,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_DWORD &&
                cbSize == sizeof(DWORD))
            {
                AtqParms.dwsecThreadTimeOut = dwSecThreadTimeOut;
            }
            else
            {
                AtqParms.dwsecThreadTimeOut = ATQ_CONFIG_PARM_DEFAULT;
            }

            cbSize = sizeof(dwMinKBTimeOut);
            dwErr = RegQueryValueExW(
                       hAtqParams,
                       L"MinKBTimeOut",
                       NULL,
                       &cbType,
                       (LPBYTE)&dwMinKBTimeOut,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_DWORD &&
                cbSize == sizeof(DWORD))
            {
                AtqParms.dwMinKBTimeOut = dwMinKBTimeOut;
            }
            else
            {
                AtqParms.dwMinKBTimeOut = ATQ_CONFIG_PARM_DEFAULT;
            }

        }
    }

    //  see if provider list was passed in ...
    if (KdcParamProviders != NULL)
    {
        KdcGlobalProviderDlls = KdcParamProviders;
    }
    else
    {
        //
        // Get list of Providers to load from registry
        //
        // HKLM/System/CCS/Services/Kdc/Parameters/Providers [REG_MULTI_SZ] kdckdb.dll
        //

        cbSize = 0;

        dwErr = RegQueryValueExW(
                   ParamKey,
                   L"Providers",
                   NULL,
                   &cbType,
                   NULL,
                   &cbSize
                   );

        if (dwErr == ERROR_SUCCESS)
        {
            if (cbType == REG_MULTI_SZ && cbSize > 0)
            {
                String = (LPTSTR_ARRAY)MIDL_user_allocate(cbSize);
                if (String == NULL)
                    return;
            }

            dwErr = RegQueryValueExW(
                       ParamKey,
                       L"Providers",
                       NULL,
                       &cbType,
                       (LPBYTE)String,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_MULTI_SZ &&
                cbSize > 0)
            {
                if (KdcGlobalProviderDlls != NULL)
                {
                    MIDL_user_free(KdcGlobalProviderDlls);
                }
                KdcGlobalProviderDlls = String;

                // XXX - (Re)load Providers, but need to be careful about
                // requests in progress. For now just load once at startup

                //LoadKdcProviders();
            }
        }
    }

    return;
}


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchKdcParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
NTAPI
KerbWatchKdcParamKey(PVOID    pCtxt,
                  BOOLEAN  fWaitStatus)
{

    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;

    if (NULL == hKdcParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Services\\Kdc\\Parameters",
                   0,
                   KEY_READ,
                   &hKdcParams
                   );

        if (ERROR_SUCCESS != lRes)
        {
            DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != hKdcWait)
    {
        Status = UnregisterWait(hKdcWait);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }

    lRes = RegNotifyChangeKeyValue(
                hKdcParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes)
    {
        DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }

    KerbGetKdcRegParams(hKdcParams);

Reregister:

    Status = RegisterWaitForSingleObject(&hKdcWait,
                             (HANDLE) pCtxt,
                             KerbWatchKdcParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEONLYONCE);

}

////////////////////////////////////////////////////////////////////
//
//  Name:       WaitKdcCleanup
//
//  Synopsis:   Cleans up for KerbWatchKdcParamKey
//
//  Arguments:  <none>
//
//  Notes:      .
//
VOID
WaitKdcCleanup(HANDLE hEvent)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (NULL != hKdcWait) {
        Status = UnregisterWait(hKdcWait);
        hKdcWait = NULL;
    }

    if (NT_SUCCESS(Status) && NULL != hEvent) {
        CloseHandle(hEvent);
        hEvent = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   LoadKdcProviders
//
//  Synopsis:   Load all extension and KDB provider DLLs.
//
//  Effects:    Creates a list of all loaded providers.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      If there are no providers listed under the "Providers" rgy
//              key, then just load kdckdb.dll.
//
//
//--------------------------------------------------------------------------

typedef struct _KDC_PROVIDER {
    BOOL                DllLoaded;
    LPTSTR              DllName;
    HINSTANCE           DllHandle;
    KDC_EXT_MAIN_FN     DllExtMain;
} KDC_PROVIDER, *PKDC_PROVIDER;

PKDC_PROVIDER KdcProviders = NULL;
INT NumberOfProviders = 0;

LPTSTR KdcKdbDll = L"kdckdb.dll\0\0";

NTSTATUS
LoadKdcProviders(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LPTSTR CurrentEntry;
    INT i;
    TRACER(L"LoadKdcProviders", (PVOID *) &Status);

    for (CurrentEntry = (LPTSTR) KdcGlobalProviderDlls;
         CurrentEntry && *CurrentEntry != L'\0';
         CurrentEntry += ( wcslen( CurrentEntry ) + 1 ))
    {
        TRACE_FILELINE(TRACE_VERB, (FILE_AND_LINE, L"%s", CurrentEntry));
        D_DebugLog((DEB_TRACE, "%s\n", CurrentEntry));
        NumberOfProviders++;
    }
    TRACE_FILELINE(TRACE_VERB, ( FILE_AND_LINE,
                                    L"%d Providers to load", NumberOfProviders));
    D_DebugLog((DEB_TRACE, "%d Providers to load\n", NumberOfProviders));

    if (NumberOfProviders == 0)
    {
        //
        // Just load the default kdckdb.dll
        //
        TRACE_FILELINE(TRACE_VERB, ( FILE_AND_LINE, L"Loading default KDB provider."));
        D_DebugLog((DEB_TRACE, "Loading default KDB provider.\n"));

        CurrentEntry = KdcKdbDll;
        NumberOfProviders = 1;
    }
    else
    {
        CurrentEntry = (LPTSTR) KdcGlobalProviderDlls;
    }

    KdcProviders = (PKDC_PROVIDER) MIDL_user_allocate(
        NumberOfProviders * sizeof(KDC_PROVIDER));

    if (KdcProviders == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    for (i = 0; i < NumberOfProviders; i++)
    {
        KdcProviders[i].DllName = CurrentEntry;
        KdcProviders[i].DllLoaded = FALSE;

        KdcProviders[i].DllHandle = LoadLibrary(CurrentEntry);
        if (KdcProviders[i].DllHandle == NULL)
        {
            DebugLog((DEB_ERROR, "LoadKDCProviders: Cannot find DLL %S\n",
                      CurrentEntry));
            Status = STATUS_DLL_NOT_FOUND;

            KdbReportEventW(
                                        IEvent::ERROR_TYPE,
                                        PROVIDER_LOAD_FAILED,
                                        0,
                                        NULL,
                                        1,
                                        CurrentEntry
                                        );
            goto Cleanup;
        }

        KdcProviders[i].DllLoaded = TRUE;
        KdcProviders[i].DllExtMain = (KDC_EXT_MAIN_FN) GetProcAddress(
                                         KdcProviders[i].DllHandle,
                                         KDC_EXT_MAIN
                                         );

        if (KdcProviders[i].DllExtMain)
        {

            Status = KdcProviders[i].DllExtMain(DLL_PROCESS_ATTACH,
                                                g_piKdcCore);
            if (!NT_SUCCESS(Status))
            {
                TRACE_FILELINE(TRACE_ERR, (FILE_AND_LINE,
                                                L"LoadKDCProviders: %s failed to initialize - %x",
                                                CurrentEntry, Status));
                DebugLog((DEB_ERROR, "LoadKDCProviders: %S failed to initialize - %x\n",
                          CurrentEntry, Status));

                KdbReportEventW(
                                    IEvent::ERROR_TYPE,
                                    PROVIDER_LOAD_FAILED,
                                    0,
                                    NULL,
                                    1,
                                    CurrentEntry
                                    );

                goto Cleanup;
            }
            else {
// Xbox Ops doesn't want this informational event generated since it tells
// us nothing that we don't already know from our own provider's events.
#ifndef XBOX_KDC
                KdbReportEventW(
                                        IEvent::INFORMATION_TYPE,
                                        PROVIDER_LOADED,
                                        0,
                                        NULL,
                                        1,
                                        CurrentEntry
                                        );
#endif
                }
        }

        CurrentEntry += (wcslen(CurrentEntry) + 1);
    }

Cleanup:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnloadKdcProviders
//
//  Synopsis:   return the UNICODE_STRING of the KDC machine name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
UnloadKdcProviders(
    VOID
    )
{
    INT i;
    TRACER(L"UnloadKdcProviders", NULL);

    if (!KdcProviders)
    {
        return;
    }

    for (i = 0; i < NumberOfProviders; i++)
    {
        if (KdcProviders[i].DllLoaded)
        {
            if (KdcProviders[i].DllExtMain)
            {
                (VOID) KdcProviders[i].DllExtMain(DLL_PROCESS_DETACH, NULL);
            }

            FreeLibrary(KdcProviders[i].DllHandle);
        }
    }

    MIDL_user_free(KdcProviders);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcMachineName
//
//  Synopsis:   return the UNICODE_STRING of the KDC machine name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
PUNICODE_STRING
NTAPI
KdcMachineName(
    VOID
    )
{
    return &KDCMachineName;
}

//+-------------------------------------------------------------------------
//
//  Name:       KdcServiceMain
//
//  Synopsis:   This is the main KDC thread.
//
//  Arguments:  dwArgc   -
//              pszArgv  -
//
//  Notes:      This intializes everything, and starts the working threads.
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
WINAPI KdcServiceMain(PKDCCORE_PARAMS pParams)
{
    HANDLE    hKerbParamEvent = NULL ;
    ULONG     ulStates = 0;
    NTSTATUS  NtStatus = STATUS_SUCCESS;

    //
    // Initialize the Safe alloca package
    //

    if (pParams)
    {
        if(!KdcInitializeMemoryManager(  g_piKdcCore, pParams->pszMemMgr))
        {
            D_DebugLog((DEB_ERROR, "Failed to initialize memory manager: LastError=0x%X\n", GetLastError()));
            goto Shutdown;
        }

        g_pfnSetStatus = pParams->pfnSetStatus;
        KdcParamProviders = pParams->pszProviders;
        KdcGlobalProviderDlls = KdcParamProviders;
        //  Initialize tracing....if pszTraceDll is NULL, initializes default
        NtStatus = KdcInitializeTrace(pParams->pszTraceDll);
    }
    else
    {
        NtStatus = KdcInitializeTrace(NULL);                                //Initialize tracing
    }

    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to initialize trace: 0x%X\n", NtStatus));
        goto Shutdown;
    }
    CheckIfTraceInitialized();

    //Initialize Events
    KdcInitializeEventObject(
            L"KDC Core",
            EVCAT_CORE,
            NULL,
            NULL,
            &coreEventObject
            );

    //  initialize transport entry points
    if (!pParams || !pParams->pfnStartTransport || !pParams->pfnStopTransport)
    {
        D_DebugLog((DEB_ERROR, "No transport entry points found"));
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Shutdown;
    }

    //  use supplied transport
    g_pfnStartTransport = pParams->pfnStartTransport;
    g_pfnStopTransport = pParams->pfnStopTransport;

#define RPCDONE        0x1
#define LOCATORSTARTED 0x2
#define CRITSECSDONE   0x4

    KdcState = Starting;


    //
    // Get the debugging parameters
    //

    GetDebugParams();

    //
    // Get other parameters, register wait on registry keys
    //

    //if (KdcParamProviders == NULL)
    //{
        hKdcParamEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,
                        NULL
                        );

        if (NULL == hKdcParamEvent)
        {
            D_DebugLog((DEB_WARN, "CreateEvent for KdcParamEvent failed - 0x%x\n", GetLastError()));
        }
        else
        {
            KerbWatchKdcParamKey( hKdcParamEvent, FALSE );
        }

        hKerbParamEvent = CreateEvent(
                          NULL,
                          FALSE,
                          FALSE,
                          NULL
                          );

        if (NULL == hKerbParamEvent)
        {
            D_DebugLog((DEB_WARN, "CreateEvent for ParamEvent failed - 0x%x\n", GetLastError()));
        }
        else
        {
            KerbWatchKerbParamKey( hKerbParamEvent, FALSE );
        }
    //}
    //else
    //{
        //KdcGlobalProviderDlls = KdcParamProviders;
    //}
    D_DebugLog((DEB_TRACE, "Start KdcServiceMain\n"));

    //
    // Notify the service controller that we are starting.
    //

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

#ifdef KPASSWD
    //
    // Build our Kpasswd name, so we don't have to alloc on
    // every TGS request.
    //
    NtStatus = KerbBuildKpasswdName(
                  &GlobalKpasswdName
                  );

    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to build KPASSWED name, error 0x%X\n", NtStatus));
        goto Shutdown;
    }
#endif

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Get KDC computer name
    //

    WCHAR TempMachineName[DNS_MAX_NAME_BUFFER_LENGTH];
    ULONG MachineNameLength = sizeof(TempMachineName)/sizeof(TempMachineName[0]);

    if (!GetComputerNameEx(
            ComputerNameDnsHostname,
            TempMachineName,
            &MachineNameLength
            ))
    {
        DebugLog((DEB_ERROR, "Failed to get computer name: 0x%x\n",GetLastError()));
        goto Shutdown;
    }

    RtlInitUnicodeString(
        &KDCMachineName,
        TempMachineName
        );

    //
    //  Initalize whatever that is needed by the provider
    //
    g_piKerbCrypt = static_cast<IKerbCrypt*>(&g_cKerbCryptDll);
    RtlInitUnicodeString(&KrbtgtName, KDC_PRINCIPAL_NAME);

    //
    // Load the KDC providers
    //

    NtStatus = LoadKdcProviders();

    if (!NT_SUCCESS(NtStatus))
    {

        DebugLog((DEB_ERROR, "Failed to load providers: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Initialize internal extension handlers
    //
    NtStatus = RegisterCorePAHandlerFactories();
    if (NT_SUCCESS(NtStatus))
        NtStatus = KdcInitializeInternalADHandlers();
    if (NT_SUCCESS(NtStatus))
        NtStatus = KdcInitializeInternalPacHandlers();

    if (!NT_SUCCESS(NtStatus))
    {

        DebugLog((DEB_ERROR, "Failed to initialize internal handlers: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Load all global data into the SecData structure.
    //

    NtStatus = SecData.Init();
    if (!NT_SUCCESS(NtStatus))
    {

        D_DebugLog((DEB_ERROR, "Failed to init SecData error 0x%X\n", NtStatus));
        goto Shutdown;
    }


    //
    // Set the flag to indicate this is a trust account
    //

    // KdcTicketInfo.UserAccountControl |= USER_INTERDOMAIN_TRUST_ACCOUNT;



    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Create the KDC shutdown event, set to FALSE
    //
    hKdcShutdownEvent = CreateEvent( NULL,      // no security attributes
                                     TRUE,      // manual reset
                                     FALSE,     // initial state
                                     NULL );    // unnamed event.
    if (hKdcShutdownEvent == NULL)
    {
        NtStatus = (NTSTATUS) GetLastError();

        D_DebugLog(( DEB_ERROR, "KDC can't create shutdown event: wincode=%d.\n",
                    NtStatus ));

        goto Shutdown;
    }


    //
    // Create the KDC shutdown complete event, set to FALSE
    //
    hKdcShutdownCompleteEvent = CreateEvent( NULL,  // no security attributes
                                     TRUE,      // manual reset
                                     FALSE,     // initial state
                                     NULL );    // unnamed event.
    if (hKdcShutdownCompleteEvent == NULL)
    {
        NtStatus = (NTSTATUS) GetLastError();

        D_DebugLog(( DEB_ERROR, "KDC can't create shutdown-complete event: wincode=%d.\n",
                    NtStatus ));

        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }


    ulStates |= RPCDONE;

    //
    // 1 is the minimum number of threads.
    // TRUE means the call will return, rather than waiting until the
    //     server shuts down.
    //

    //
    // We combine the callers params with default on individual basis
    // The caller gets precedence when providing a value.
    //
    ATQ_CONFIG_PARM AtqCurrentParmeters;
    memcpy(&AtqCurrentParmeters, &AtqParms, sizeof(AtqCurrentParmeters));
    if( pParams && pParams->pAtqConfigParm )
    {
        if (ATQ_CONFIG_PARM_DEFAULT != pParams->pAtqConfigParm->dwThreads )
        {
            AtqCurrentParmeters.dwThreads = pParams->pAtqConfigParm->dwThreads;
        }

        if (ATQ_CONFIG_PARM_DEFAULT != pParams->pAtqConfigParm->dwConcurrentThreads )
        {
            AtqCurrentParmeters.dwConcurrentThreads = pParams->pAtqConfigParm->dwConcurrentThreads;
        }

        if (ATQ_CONFIG_PARM_DEFAULT != pParams->pAtqConfigParm->dwsecThreadTimeOut )
        {
            AtqCurrentParmeters.dwsecThreadTimeOut = pParams->pAtqConfigParm->dwsecThreadTimeOut;
        }

        if (ATQ_CONFIG_PARM_DEFAULT != pParams->pAtqConfigParm->dwMinKBTimeOut )
        {
            AtqCurrentParmeters.dwMinKBTimeOut = pParams->pAtqConfigParm->dwMinKBTimeOut;
        }
    }

    NtStatus = g_pfnStartTransport((FNKdcGetTicket)KdcGetTicket,// callback for transport
                                    &g_KdcCore,                 // table of utility fcns for transport
                                    &AtqCurrentParmeters);       // transport configuration
    if (!NT_SUCCESS(NtStatus))
    {

        D_DebugLog((DEB_ERROR, "Failed to initialize sockets\n"));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Check to see if there is a CSP registered for replacing the StringToKey calculation
    //
    CheckForOutsideStringToKey();

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // At this point the KDC is officially started.
    // 3 * ( 2*(hip) horray! )
    //

    if (!UpdateStatus(SERVICE_RUNNING) )
    {
        goto Shutdown;
    }

#if DBG
    GetSystemTimeAsFileTime((PFILETIME)&tsOut);
    D_DebugLog((DEB_TRACE, "Time required for KDC to start up: %d ms\n",
                         (tsOut.LowPart-tsIn.LowPart) / 10000));
#endif


    KdcState = Running;

    // This function will loop until the event is true.

    // WAS BUG: turn off cache manager for now.
    // This bug comment is a stale piece of code from
    // Cairo days - per MikeSw
    //


    // XXX Need to wait for multiple events - like KdcWinsockPnpEvent

    WaitForSingleObject(hKdcShutdownEvent, INFINITE);

    D_DebugLog((DEB_TRACE, "KDC shutting down.\n" ));

Shutdown:

#ifdef KPASSWD
    if (NULL != GlobalKpasswdName)
    {
       KerbFreeKdcName(&GlobalKpasswdName);
    }
#endif

    UpdateStatus(SERVICE_STOP_PENDING);


    if (g_pfnStopTransport)
    {
        g_pfnStopTransport();
    }

    UpdateStatus(SERVICE_STOP_PENDING);

    //
    // Close all of the events.
    //

    {
        PHANDLE ph = &hKdcHandles[0];

        for(;ph < &hKdcHandles[MAX_KDC_HANDLE]; ph++)
        {
            if(*ph)
            {
                CloseHandle(*ph);
                *ph = NULL;
            }
        }
    }

#ifdef  RETAIL_LOG_SUPPORT
    if (hKerbParamEvent) {
        WaitKerbCleanup( hKerbParamEvent );
    }
#endif

    if ( hKdcParamEvent ) {
        WaitKdcCleanup( hKdcParamEvent );
    }

    //
    // Cleanup handles to SAM & LSA and global variables
    //

    UpdateStatus(SERVICE_STOP_PENDING);

    //
    // Unload providers
    //

    UnloadKdcProviders();

    //  and clear factory lists
    KdcDeleteAllHandlerLists();

    UpdateStatus(SERVICE_STOP_PENDING);


    //
    // Cleanup allocated memory
    //  if providers were read from registry, not provided as param
    //

    if (KdcGlobalProviderDlls && KdcGlobalProviderDlls != KdcParamProviders)
    {
        MIDL_user_free(KdcGlobalProviderDlls);
        KdcGlobalProviderDlls = NULL;
    }


    ShutdownStatus = NtStatus;

    KdcShutdownTrace();

    if (!SetEvent( hKdcShutdownCompleteEvent ) )
    {

        //D_DebugLog(( DEB_ERROR, "Couldn't set KDC shutdown-complete event.  winerr=%d.\n",
              //       GetLastError() ));
    }

    //D_DebugLog((DEB_TRACE, "End KdcServiceMain\n"));
    KdcFreeEventObject(coreEventObject);

    return  NtStatus;
}



////////////////////////////////////////////////////////////////////
//
//  Name:       KdcShutDown
//
//  Synopsis:   Shuts the KDC down.
//
//  Arguments:  pszMessage   - message to print to debug port
//
//  Notes:      Stops RPC from accepting new calls, waits for pending calls
//              to finish, and sets the global event "hKdcShutDownEvent".
//
extern "C"
NTSTATUS
WINAPI
KdcShutDown(LPWSTR pszMessage)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    D_DebugLog((DEB_WARN, "Server Shutdown:  %ws\n", pszMessage));


    //
    // Notify the all threads that we are exiting.
    //


    //
    // First set the started flag to false so nobody will try any more
    // direct calls to the KDC.
    //

    KdcState = Stopped;

    //
    // If there are any outstanding calls, let them trigger the shutdown event.
    // Otherwise set the shutdown event ourselves.
    //

    EnterCriticalSection(&ApiCriticalSection);
    if (CurrentApiCallers == 0)
    {

        if (!SetEvent( hKdcShutdownEvent ) )
        {

            D_DebugLog(( DEB_ERROR, "Couldn't set KDC shutdown event.  winerr=%d.\n",
                        GetLastError() ));
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        //
        // Wait for the KDC to shutdown
        //

        WaitForSingleObject(hKdcShutdownCompleteEvent, 10*1000 ); // 10 Seconds

        CloseHandle(hKdcShutdownCompleteEvent);

        SecData.Cleanup();

#ifdef KDC_WMI_TRACING
        if (KdcTraceRegistrationHandle != (TRACEHANDLE)0)
        {
            UnregisterTraceGuids( KdcTraceRegistrationHandle );
        }
#endif
        /* TODO: call KdcShutdownTrace(); ? */
    }
    LeaveCriticalSection(&ApiCriticalSection);
    UpdateStatus(SERVICE_STOPPED);
    return(NtStatus);
}


//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   DLL initialization routine
//
//--------------------------------------------------------------------------

extern "C" BOOL WINAPI
DllMain (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    )
{
    BOOL bReturn = TRUE;

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls ( hInstance );

        //
        // WAS BUG: call the Rtl version here because it returns an error
        // instead of throwing an exception.  Leave it here, as we don't
        // really need to put a try/except around InitCritSec.
        //

        InitializeCriticalSection( &ApiCriticalSection );
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DeleteCriticalSection(&ApiCriticalSection);
        KdcShutdownMemoryManager(  );
    }

    return bReturn;
    UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\kdcmem.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001 - 2002
//
// File:        KDCMEM.CXX
//
// Contents:    KDC memory management interfaces
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "kdcmem.hxx"

//
// Memory management functions (NULL unless overloaded by a custom memory manager)
//

PFN_KDC_MEM_INIT g_pfnKdcMemInit = NULL;
PFN_KDC_MEM_SHUTDOWN g_pfnKdcMemShutdown = NULL;
PFN_KDC_MEM_ALLOCATE g_pfnKdcMemAllocate = NULL;
PFN_KDC_MEM_REALLOC g_pfnKdcMemRealloc = NULL;
PFN_KDC_MEM_FREE g_pfnKdcMemFree = NULL;

//
// Handle to the custom memory management DLL
//

HMODULE g_hMemoryManagerLib;


//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeMemoryManager
//
//  Synopsis:   Initializes the custom memory manager if appropriate
//              From Registry:
//                  HKLM\CurrentControlSet\Services\KDC\Parameters\Static\MemoryManagerDll
//                  Which should be a value of type REG_SZ
//              Or passed in form provider (pszMemMgr)
//              The DLL should expose five entry points:
//                  o InitializeMemoryManager
//                  o ShutdownMemoryManager
//                  o AllocateMemory
//                  o ReallocateMemory
//                  o FreeMemory
//
//              If any other error occurs during initialization, the deafult
//              memory manager will be used.
//
//              This routine must be called first thing during service startup,
//              before any memory management activity has taken place.
//
//  Effects:    All subsequent memory operations will be performed using
//              the loaded memory manager
//
//  Arguments:  hInstance   instance of the process being initialized
//                      pszMemMgr - full path of the memory manger dll if any.
//
//  Returns:    TRUE or FALSE; caller can call GetLastError() to get
//              the reason for failure if FALSE is returned
//
//  Notes:      A default memory manager will be used if this routine fails;
//              The caller need not fail initialization in that case.
//
//--------------------------------------------------------------------------

BOOL
KdcInitializeMemoryManager(
    IN IKdcCore  *pIKdcCore,
    IN LPWSTR  pszMemMgr
    )
{
    DWORD       dwErr = ERROR_SUCCESS;
    NTSTATUS    Status = STATUS_SUCCESS;
    BOOL        fDoSetLastErr = TRUE;

    //
    //  if null, TRY to find it from reg.
    //  Since the mem. mgr is OPTIONAL, failure to locate the registry value is NOT an error
    //  condition
    //
    if(!pszMemMgr)
    {
        HKEY hKey;
        DWORD dwType;
        WCHAR Buffer[MAX_PATH];
        DWORD dwSize= sizeof( Buffer );

        //
        // The name of the memory manager DLL is under
        // HKLM\System\CurrentControlSet\Services\KDC\Parameters\Static\MemoryManagerDll
        //

        dwErr = RegOpenKeyW(
                    HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Services\\KDC\\Parameters\\Static",
                    &hKey
                    );

        if ( dwErr != ERROR_SUCCESS ) {
            //
            //  Memory manager not specified in registry either
            //  Use default in this case
            //
            dwErr = ERROR_SUCCESS;
            goto Cleanup;
        }

        dwErr = RegQueryValueExW(
                    hKey,
                    L"MemoryManagerDll",
                    NULL,
                    &dwType,
                    ( LPBYTE )Buffer,
                    &dwSize
                    );

        RegCloseKey(hKey);

        if ( dwErr != ERROR_SUCCESS ) {

            dwErr = ERROR_SUCCESS;
            goto Cleanup;

        } else if ( dwType != REG_SZ ) {

            dwErr = ERROR_INVALID_PARAMETER;
            goto Error;
        }
        pszMemMgr = Buffer;
    }

    if (!pszMemMgr)
        goto Cleanup;

    g_hMemoryManagerLib = LoadLibraryW((LPCWSTR)pszMemMgr);
    if ( g_hMemoryManagerLib == NULL )
    {
        dwErr = GetLastError();
        goto Error;
    }

    g_pfnKdcMemInit = ( PFN_KDC_MEM_INIT )GetProcAddress( g_hMemoryManagerLib, "InitializeMemoryManager" );
    g_pfnKdcMemShutdown = ( PFN_KDC_MEM_SHUTDOWN )GetProcAddress( g_hMemoryManagerLib, "ShutdownMemoryManager" );
    g_pfnKdcMemAllocate = ( PFN_KDC_MEM_ALLOCATE )GetProcAddress( g_hMemoryManagerLib, "AllocateMemory" );
    g_pfnKdcMemRealloc = ( PFN_KDC_MEM_REALLOC )GetProcAddress( g_hMemoryManagerLib, "ReallocateMemory" );
    g_pfnKdcMemFree = ( PFN_KDC_MEM_FREE )GetProcAddress( g_hMemoryManagerLib, "FreeMemory" );

    if ( g_pfnKdcMemInit == NULL ||
         g_pfnKdcMemShutdown == NULL ||
         g_pfnKdcMemAllocate == NULL ||
         g_pfnKdcMemRealloc == NULL ||
         g_pfnKdcMemFree == NULL )
    {
        dwErr = ERROR_PROC_NOT_FOUND;
        goto Error;
    }

    //
    //  InitializeMemoryMemory( ) will return STATUS_RESOURCE_REQUIREMENTS_CHANGED if
    //  the default memory manager should be used, i.e., InitializeMemoryMemory( ) has
    //  decided, perhaps from its configuration, that its dll should be unloaded and the
    //  default manager be used.
    //
    Status = g_pfnKdcMemInit(pIKdcCore);
    if (STATUS_RESOURCE_REQUIREMENTS_CHANGED == Status)
    {
        //
        //  Shuts down the memory manager, free library and clear global pointers.
        //  But we are returning OK for the core to continue with service startup.
        //
        dwErr = ERROR_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(Status))
    {
        // g_pfnKdcMemInit is expected to have set last error in this case
        fDoSetLastErr = FALSE;
        goto Error;
    }
    else
    {
        dwErr = ERROR_SUCCESS;
    }


Cleanup:

    return ( dwErr == ERROR_SUCCESS );

Error:

    KdcShutdownMemoryManager( );

    if (fDoSetLastErr)
    {
        SetLastError( dwErr );
    }
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownMemoryManager
//
//  Synopsis:   Terminates the memory manager.  Can only be called as part
//              of application shutdown, after all memory management activity
//              has ceased.
//
//  Effects:    Sets all global memory management functions to NULL
//              Unloads the custom memory manager DLL
//
//  Arguments:  hInstance           instance being shut down
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

void
KdcShutdownMemoryManager(
    )
{
    if ( g_pfnKdcMemShutdown ) {

        g_pfnKdcMemShutdown( );
    }

    g_pfnKdcMemInit = NULL;
    g_pfnKdcMemShutdown = NULL;
    g_pfnKdcMemAllocate = NULL;
    g_pfnKdcMemRealloc = NULL;
    g_pfnKdcMemFree = NULL;

    if ( g_hMemoryManagerLib ) {

        FreeLibrary( g_hMemoryManagerLib );
        g_hMemoryManagerLib = NULL;
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAllocMemory
//
//  Synopsis:   Allocates a block of memory, using either the default allocator
//              or the loaded custom memory manager
//
//  Effects:
//
//  Arguments:  Size        size of block to allocate
//
//  Returns:    Address of allocated block of memory or NULL if out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C"
void *
WINAPI
KdcAllocMemory(
    IN size_t Size
    )
{
    if ( !g_pfnKdcMemAllocate ) {

        return HeapAlloc(
                   GetProcessHeap(),
                   0, // do not zeroinit
                   Size
                   );

    } else {

        return g_pfnKdcMemAllocate( Size );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcReallocMemory
//
//  Synopsis:   Reallocates a block of memory to a new size
//
//  Effects:
//
//  Arguments:  Address     address of an existing block to reallocate
//              Size        new size of the block
//
//  Returns:    Address of allocated block of memory or NULL if out of memory
//
//  Notes:      Address parameter must not be NULL, it must be allocated
//              with KdcAllocateMemory
//
//--------------------------------------------------------------------------

extern "C"
void *
WINAPI
KdcReallocMemory(
    IN void * Address,
    IN size_t Size
    )
{
    if ( !g_pfnKdcMemRealloc ) {

        //
        // ISSUE-markpu-10/03/01
        // Should really stop zero-initializing allocated memory
        //

        return HeapReAlloc(
                   GetProcessHeap(),
                   0, // do not zeroinit
                   Address,
                   Size
                   );

    } else {

        return g_pfnKdcMemRealloc( Address, Size );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeMemory
//
//  Synopsis:   Frees a block of memory allocated with KdcAllocateMemory
//
//  Effects:
//
//  Arguments:  Address     address of a block to free
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C"
VOID
WINAPI
KdcFreeMemory(
    IN void * Address
    )
{
    if ( Address ) {

        if ( !g_pfnKdcMemFree ) {

            HeapFree(
                GetProcessHeap(),
                0,
                Address
                );

        } else {

            g_pfnKdcMemFree( Address );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\msber.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    8269
//  $AgreementName:  software license agreement
//  $AgreementType:  inbound license
//  $ExternalOrigin: boris nikolaus
//$ENDTAG

//$TAG ENGR 
//  $Owner:    denisi
//  $Module:   ds_published
//
//$ENDTAG

/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_BER_H__
#define __MS_BER_H__

#include <msasn1.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif


/*****************************************************************************
  ASN1BEREncCharString

  encode a string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncCharString(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t len, 
    __in_ecount( len )
                ASN1char_t *val 
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncCharString(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t len, 
    __in_ecount( len )
                ASN1char_t *val 
    );

/*****************************************************************************
  ASN1BEREncChar16String

  encode a 16 bit string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncChar16String(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t len, 
    __in_ecount( len )
                ASN1char16_t *val
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncChar16String(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t len, 
    __in_ecount( len )
                ASN1char16_t *val
    );

/*****************************************************************************
  ASN1BEREncChar32String

  encode a 32 bit string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncChar32String(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t len, 
    __in_ecount( len )
                ASN1char32_t *val
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncChar32String(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t len, 
    __in_ecount( len )
                ASN1char32_t *val
    );

/*****************************************************************************
  ASN1BEREncOctetString

  encode an octet string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncOctetString(
    __in        ASN1encoding_t enc,
                ASN1uint32_t tag, 
                ASN1uint32_t len, 
    __in_bcount_opt( len )
                ASN1octet_t *val
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncOctetString(
    __in        ASN1encoding_t enc,
                ASN1uint32_t tag, 
                ASN1uint32_t len, 
    __in_bcount( len )
                ASN1octet_t *val
    );

/*****************************************************************************
  ASN1BEREncBitString

  encode a bit string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncBitString(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t bitlen, 
    __in_bcount( (bitlen + 7) / 8 )
                ASN1octet_t *val
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncBitString(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t bitlen, 
    __in_bcount( (bitlen + 7) / 8 )
                ASN1octet_t *val
    );

/*****************************************************************************
  ASN1BEREncGeneralizedTime

  encode a generalized time value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncGeneralizedTime(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1generalizedtime_t *
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncGeneralizedTime(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1generalizedtime_t *
    );

/*****************************************************************************
  ASN1BEREncS32

   encode a signed integer value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncS32(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1int32_t
    );

/*****************************************************************************
  ASN1BEREncSX

   encode a signed multibyte integer value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncSX(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1intx_t *
    );

/*****************************************************************************
  ASN1BEREncZeroMultibyteString

   encode a multibyte string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncZeroMultibyteString(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in_z      ASN1ztcharstring_t
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncZeroMultibyteString(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in_z      ASN1ztcharstring_t
    );

/*****************************************************************************
  ASN1BEREncMultibyteString

   encode a multibyte string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncMultibyteString(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1charstring_t *
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncMultibyteString(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1charstring_t *
    );

/*****************************************************************************
  ASN1BEREncNull

   encode a null value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncNull(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag
    );

/*****************************************************************************
  ASN1BEREncObjectIdentifier

   encode an object identifier value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncObjectIdentifier(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1objectidentifier_t *
    );

/*****************************************************************************
  ASN1BEREncObjectIdentifier2

   encode an object identifier value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncObjectIdentifier2(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1objectidentifier2_t *val
    );

/*****************************************************************************
  ASN1BEREncRemoveZeroBits

   remove trailing zero bits
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncRemoveZeroBits(
    __inout     ASN1uint32_t *nbits, 
    __in_bcount( (*nbits+7) / 8 )
                ASN1octet_t *val
    );

/*****************************************************************************
  ASN1BEREncRemoveZeroBits2

   remove trailing zero bits preserving min len
*****************************************************************************/
extern 
__success( return > 0 )
int 
ASN1API 
ASN1BEREncRemoveZeroBits2(
    __inout     ASN1uint32_t *nbits, 
    __in_bcount( (*nbits+7) / 8 )
                ASN1octet_t *val, 
                ASN1uint32_t minlen
    );


/*****************************************************************************
  ASN1BEREncUTCTime

   encode an utc time value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncUTCTime(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1utctime_t *
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncUTCTime(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1utctime_t *
    );

/*****************************************************************************
  ASN1BEREncFlush

  end of encoding
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncFlush(
    __in        ASN1encoding_t enc
    );

/*****************************************************************************
  ASN1BEREncOpenType

  encode an open type value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncOpenType(
    __in        ASN1encoding_t enc, 
    __in        ASN1open_t *
    );

/*****************************************************************************
  ASN1BERDecExplicitTag

  decode an explicit tag
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecExplicitTag(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __deref_out ASN1decoding_t *dd, 
    __deref_out ASN1octet_t **ppBufEnd
    );

/*****************************************************************************
  ASN1BERDecEndOfContents

  
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecEndOfContents(
    __in        ASN1decoding_t dec, 
    __in        ASN1decoding_t dd, 
    __in        ASN1octet_t *pBufEnd 
    );

/*****************************************************************************
  ASN1BERDecOctetString

  decode octet string value, making copy
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecOctetString(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1octetstring_t *val
    );

/*****************************************************************************
  ASN1BERDecOctetString2

  decode octet string value, no copy
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecOctetString2(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1octetstring_t *val
    );

/*****************************************************************************
  ASN1BERDecBitString

  decode bit string value, making copy
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecBitString(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1bitstring_t *val
    );

/*****************************************************************************
  ASN1BERDecBitString2

  decode bit string value, no copy
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecBitString2(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1bitstring_t *val
    );

/*****************************************************************************
  ASN1BERDecChar16String

  decode 16 bit string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecChar16String(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1char16string_t *val
    );

/*****************************************************************************
  ASN1BERDecChar32String

  decode 32 bit string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecChar32String(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1char32string_t *val
    );

/*****************************************************************************
  ASN1BERDecCharString

  decode string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecCharString(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1charstring_t *val
    );


/*****************************************************************************
  ASN1BERDecGeneralizedTime

  decode generalized time value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecGeneralizedTime(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1generalizedtime_t *
    );

/*****************************************************************************
  ASN1BERDecZeroMultibyteString

  decode zero terminated string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecZeroMultibyteString(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __deref_out_z
                ASN1ztcharstring_t *
    );

/*****************************************************************************
  ASN1BERDecMultibyteString

  decode multibyte string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecMultibyteString(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1charstring_t *
    );

/*****************************************************************************
  ASN1BERDecNull

  decode NULL value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecNull(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag
    );

/*****************************************************************************
  ASN1BERDecObjectIdentifier

  decode object identifier value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecObjectIdentifier(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __deref_out ASN1objectidentifier_t *
    );

/*****************************************************************************
  ASN1BERDecObjectIdentifier2

  decode object identifier value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecObjectIdentifier2(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1objectidentifier2_t *val
    );

/*****************************************************************************
  ASN1BERDecS8Val

  decode integer into signed 8 bit value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecS8Val(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1int8_t *val
    );

/*****************************************************************************
  ASN1BERDecS16Val

  decode integer into signed 16 bit value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecS16Val(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1int16_t *val
    );

/*****************************************************************************
  ASN1BERDecS32Val

  decode integer into signed 32 bit value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecS32Val(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1int32_t *val
    );

/*****************************************************************************
  ASN1BERDecSXVal

  decode integer into intx value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecSXVal(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1intx_t *val
    );

/*****************************************************************************
  ASN1BERDecU8Val

  decode integer into unsigned 8 bit value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecU8Val(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1uint8_t *val
    );

/*****************************************************************************
  ASN1BERDecU16Val

  decode integer into unsigned 16 bit value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecU16Val(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1uint16_t *val
    );

/*****************************************************************************
  ASN1BERDecU32Val

  decode integer into unsigned 32 bit value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecU32Val(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1uint32_t *val
    );

/*****************************************************************************
  ASN1BERDecUTCTime

  decode utc time value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecUTCTime(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1utctime_t *val
    );


/*****************************************************************************
  ASN1BERDecZeroCharString

  decode zero terminated string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecZeroCharString(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __deref_out_z
                ASN1ztcharstring_t *val
    );

/*****************************************************************************
  ASN1BERDecZeroCharString16

  decode zero terminated 16 bit string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecZeroChar16String(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __deref_out_z
                ASN1ztchar16string_t *val
    );

/*****************************************************************************
  ASN1BERDecZeroCharString32

  decode zero terminated 32 bit string value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecZeroChar32String(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __deref_out_z
                ASN1ztchar32string_t *val
    );

/*****************************************************************************
  ASN1BERDecSkip

  skip a value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecSkip(
    __in  ASN1decoding_t dec
    );

/*****************************************************************************
  ASN1BERDecFlush

  finish decoding
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecFlush(
    __in  ASN1decoding_t dec
    );

/*****************************************************************************
  ASN1BERDecOpenType

  decode an open type value, make copy
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecOpenType(
    __in        ASN1decoding_t dec, 
    __out       ASN1open_t *val
    );

/*****************************************************************************
  ASN1BERDecOpenType2

  decode an open type value, no copy
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecOpenType2(
    __in        ASN1decoding_t dec, 
    __out       ASN1open_t *val
    );

/*****************************************************************************
 ASN1BEREncCheck
    
    check for space in encoding buffer
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncCheck(
    __in    ASN1encoding_t enc, 
            ASN1uint32_t noctets
    );

/*****************************************************************************
 ASN1BEREncTag
    
    encode a tag
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncTag(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag
    );

/*****************************************************************************
 ASN1BEREncExplicitTag
    
    encode explicit tag
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncExplicitTag(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __out       ASN1uint32_t *pnLenOff
    );

/*****************************************************************************
 ASN1BEREncEndOfContents
    
    encode definite length
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncEndOfContents(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t nLenOff
    );

/*****************************************************************************
 ASN1BEREncLength
    
    encode length
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncLength(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t len
    );

/*****************************************************************************
 ASN1BERDecCheck
    
    check if len octets are left in decoding stream
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecCheck(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t len
    );

/*****************************************************************************
 ASN1BERDecTag
    
    decode a tag value; return constructed bit if desired 
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecTag(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out_opt   ASN1uint32_t *constructed
    );

/*****************************************************************************
 ASN1BERDecLength
    
    decode length
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecLength(
    __in        ASN1decoding_t dec, 
    __out       ASN1uint32_t *len, 
    __out_opt   ASN1uint32_t *infinite
    );

/*****************************************************************************
 ASN1BERDecNotEndOfContents
    
    check if end of contents (of a constructed value) has been reached
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecNotEndOfContents(
    __in        ASN1decoding_t dec, 
    __in        ASN1octet_t *pBufEnd
    );

/*****************************************************************************
 ASN1BERDecPeekTag
    
    peek the following tag without advancing the read position
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecPeekTag(
    __in        ASN1decoding_t dec, 
    __out       ASN1uint32_t *tag
    );

/*****************************************************************************
 ASN1BEREncU32
    
    encode a unsigned integer value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncU32(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t
    );

/*****************************************************************************
 ASN1BEREncBool
    
    encode a boolean value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncBool(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1bool_t val
    );

/*****************************************************************************
 ASN1BERDecBool
    
    decode boolean into ASN1boot_t
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecBool(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1bool_t *val
    );

/*****************************************************************************
 ASN1BEREncEoid
    
    encode an object identifier value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncEoid(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
    __in        ASN1encodedOID_t *
    );

/*****************************************************************************
 ASN1BERDecEoid
    
    decode object identifier value
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecEoid(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1encodedOID_t *val
    );

/*****************************************************************************
 ASN1BERDotVal2Eoid
    
    convert ObjID string value to encoded
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDotVal2Eoid(
    __in        ASN1encoding_t enc, 
    __in_z      char *pszDotVal, 
    __out       ASN1encodedOID_t *pOut
    );

/*****************************************************************************
 ASN1BERDotVal2Eoid
    
    convert object identifier value to string
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREoid2DotVal(
    __in        ASN1decoding_t dec, 
    __in        ASN1encodedOID_t *pIn, 
    __deref_out char **ppszDotVal
    );

/*****************************************************************************
 ASN1BEREoid_free
    
*****************************************************************************/
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1BEREoid_free(
    __in        ASN1encodedOID_t *val
    );

/*****************************************************************************
 ASN1BEREncUTF8String
    
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BEREncUTF8String(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t length, 
    __in_ecount( length )
                WCHAR *value
    );

extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncUTF8String(
    __in        ASN1encoding_t enc, 
                ASN1uint32_t tag, 
                ASN1uint32_t length, 
    __in_ecount( length )
                WCHAR *value
    );

/*****************************************************************************
 ASN1BEREncUTF8String
    
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1BERDecUTF8String(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t tag, 
    __out       ASN1wstring_t *val
    );


/*****************************************************************************
 ASN1DEREncBeginBlk
    
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncBeginBlk(
    __in        ASN1encoding_t enc, 
                ASN1blocktype_e eBlkType, 
    __deref_out void **ppBlk
    );

/*****************************************************************************
 ASN1DEREncNewBlkElement
    
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncNewBlkElement(
    __in        void *pBlk, 
    __deref_out ASN1encoding_t *enc2
    );

/*****************************************************************************
 ASN1DEREncFlushBlkElement
    
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncFlushBlkElement(
    __in        void *pBlk
    );

/*****************************************************************************
 ASN1DEREncEndBlk
    
*****************************************************************************/
extern ASN1_PUBLIC
__success( return > 0 )
int
ASN1API
ASN1DEREncEndBlk(
    __in        void *pBlk
    );


/*****************************************************************************
 DEPRECATED APIs - DO NOT USE
    
*****************************************************************************/

extern ASN1_PUBLIC int ASN1API ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double);
extern ASN1_PUBLIC int ASN1API ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1ztcharstring_t);


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_BER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\msasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_ASN1_H__
#define __MS_ASN1_H__

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;


/* ------ Function modifiers ------ */

#ifdef ASN1LIB
#define ASN1_PUBLIC
#elif defined(ASN1C)
#define ASN1_PUBLIC
#else
#define ASN1_PUBLIC     __declspec(dllimport)
#endif
#define ASN1API         __stdcall
#define ASN1CALL        __stdcall

#ifdef _M_CEE_PURE
#define ASN1API_INLINE  __clrcall
#else
#define ASN1API_INLINE  ASN1API
#endif

/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;

typedef ASN1uint8_t ASN1bool_t;

typedef struct tagASN1intx_t
{
    ASN1uint32_t length;
   
    __field_bcount(length) 
    ASN1octet_t *value;
}
ASN1intx_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;

    __field_bcount(length) 
    ASN1octet_t *value;
}
ASN1octetstring_t;

typedef struct tagASN1octetstring2_t
{
    ASN1uint32_t length;
    ASN1octet_t value[1];
}
ASN1octetstring2_t;

typedef struct ASN1iterator_s
{
    struct ASN1iterator_s *next;
    void *value;
}
ASN1iterator_t;

typedef struct tagASN1bitstring_t
{
    ASN1uint32_t length;
    
    __field_bcount(length) 
    ASN1octet_t *value;
}
ASN1bitstring_t;

typedef char ASN1char_t;

typedef struct tagASN1charstring_t
{
    ASN1uint32_t length;
    
    __field_ecount(length) 
    ASN1char_t *value;
}
ASN1charstring_t;

typedef ASN1uint16_t ASN1char16_t;

typedef struct tagASN1char16string_t
{
    ASN1uint32_t length;
    
    __field_ecount(length) 
    ASN1char16_t *value;
}
ASN1char16string_t;

typedef ASN1uint32_t ASN1char32_t;

typedef struct tagASN1char32string_t
{
    ASN1uint32_t length;
    
    __field_ecount(length) 
    ASN1char32_t *value;
}
ASN1char32string_t;

typedef ASN1char_t *ASN1ztcharstring_t;
typedef ASN1char16_t *ASN1ztchar16string_t;
typedef ASN1char32_t *ASN1ztchar32string_t;

typedef struct tagASN1wstring_t
{
    ASN1uint32_t length;
    
    __field_ecount(length) 
    WCHAR *value;
}
ASN1wstring_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}
*ASN1objectidentifier_t;

typedef struct tagASN1objectidentifier2_t
{
    __range(0, 16)
    ASN1uint16_t count;
    ASN1uint32_t value[16];
}
ASN1objectidentifier2_t;

typedef struct tagASN1encodedOID_t
{
    ASN1uint16_t length;
    
    __field_bcount(length) 
    ASN1octet_t  *value;
}
ASN1encodedOID_t;

typedef ASN1ztcharstring_t ASN1objectdescriptor_t;

typedef struct tagASN1generalizedtime_t
{
    ASN1uint16_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1uint16_t millisecond;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
ASN1generalizedtime_t;

typedef struct tagASN1utctime_t
{
    ASN1uint8_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
ASN1utctime_t;

typedef struct tagASN1open_t
{
    // encoded
    ASN1uint32_t    length;
    union
    {
        __field_bcount(length) 
        void           *encoded;

        __field_bcount(length) 
        void           *value;
    };
}
ASN1open_t;

typedef enum tagASN1blocktype_e
{
    ASN1_DER_SET_OF_BLOCK,
}
ASN1blocktype_e;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type

typedef ASN1uint16_t    ASN1choice_t;   // choice

typedef ASN1uint32_t    ASN1magic_t;

/* ------ Current version of this ASN.1 software ------ */

#define ASN1_MAKE_VERSION(major,minor)  (((major) << 16) | (minor))
#define ASN1_THIS_VERSION               ASN1_MAKE_VERSION(1,0)

enum
{
    ASN1_CHOICE_BASE      = 1,
    ASN1_CHOICE_INVALID   = -1,     // invalid choice
    ASN1_CHOICE_EXTENSION = 0,      // extension choice
};



/*
   Error codes for decoding functions:
   - err == 0:    data has been successfully decoded
   - err <  0:    fatal error has occured, no data has been generated
                  err contains the error number
   - err >  0:    non-fatal event has occured, data has been generated
                  err is a bit set of occured events
 */

typedef enum tagASN1error_e
{
    ASN1_SUCCESS        = 0,            /* success */

    // Teles specific error codes
    ASN1_ERR_INTERNAL   = (-1001),      /* internal error */
    ASN1_ERR_EOD        = (-1002),      /* unexpected end of data */
    ASN1_ERR_CORRUPT    = (-1003),      /* corrupted data */
    ASN1_ERR_LARGE      = (-1004),      /* value too large */
    ASN1_ERR_CONSTRAINT = (-1005),      /* constraint violated */
    ASN1_ERR_MEMORY     = (-1006),      /* out of memory */
    ASN1_ERR_OVERFLOW   = (-1007),      /* buffer overflow */
    ASN1_ERR_BADPDU     = (-1008),      /* function not supported for this pdu*/
    ASN1_ERR_BADARGS    = (-1009),      /* bad arguments to function call */
    ASN1_ERR_BADREAL    = (-1010),      /* bad real value */
    ASN1_ERR_BADTAG     = (-1011),      /* bad tag value met */
    ASN1_ERR_CHOICE     = (-1012),      /* bad choice value */
    ASN1_ERR_RULE       = (-1013),      /* bad encoding rule */
    ASN1_ERR_UTF8       = (-1014),      /* bad unicode (utf8) */

    // New error codes
    ASN1_ERR_PDU_TYPE   = (-1051),      /* bad pdu type */
    ASN1_ERR_NYI        = (-1052),      /* not yet implemented */

    // Teles specific warning codes
    ASN1_WRN_EXTENDED   = 1001,         /* skipped unknown extension(s) */
    ASN1_WRN_NOEOD      = 1002,         /* end of data expected */
}
ASN1error_e;

#define ASN1_SUCCEEDED(ret)     (((int) (ret)) >= 0)
#define ASN1_FAILED(ret)        (((int) (ret)) < 0)


/* ------ Encoding rules ------ */

typedef enum
{
    ASN1_BER_RULE_BER           = 0x0100,
    ASN1_BER_RULE_CER           = 0x0200,
    ASN1_BER_RULE_DER           = 0x0400,
    ASN1_BER_RULE               = ASN1_BER_RULE_BER | ASN1_BER_RULE_CER | ASN1_BER_RULE_DER,
}
ASN1encodingrule_e;

/* ------ public structures ------ */

typedef struct ASN1encoding_s   *ASN1encoding_t;
typedef struct ASN1decoding_s   *ASN1decoding_t;

typedef ASN1int32_t (ASN1CALL *ASN1BerEncFun_t)( __in ASN1encoding_t enc, ASN1uint32_t tag, __in void *data);
typedef ASN1int32_t (ASN1CALL *ASN1BerDecFun_t)( __in ASN1decoding_t enc, ASN1uint32_t tag, __out void *data);

typedef struct tagASN1BerFunArr_t
{
    const ASN1BerEncFun_t *apfnEncoder;
    const ASN1BerDecFun_t *apfnDecoder;
}
ASN1BerFunArr_t;

typedef void (ASN1CALL *ASN1GenericFun_t)(void);
typedef void (ASN1CALL *ASN1FreeFun_t)( __in void *data);

typedef struct tagASN1module_t
{
    ASN1magic_t             nModuleName;
    ASN1encodingrule_e      eRule;
    ASN1uint32_t            dwFlags;
    ASN1uint32_t            cPDUs;

    __field_xcount(cPDUs)
    const ASN1FreeFun_t    *apfnFreeMemory;
    
    __field_xcount(cPDUs)
    const ASN1uint32_t     *acbStructSize;
    
    ASN1BerFunArr_t         BER;
}
*ASN1module_t;


struct ASN1encoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this encoding_t depends to */
    __field_bcount(size)
    ASN1octet_t        *buf;    /* buffer to encode into */
    ASN1uint32_t        size;   /* current size of buffer */
    ASN1uint32_t        len;    /* len of encoded data in buffer */
    ASN1error_e         err;    /* error code for last encoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1uint32_t        cbExtraHeader;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};

struct ASN1decoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this decoding_t depends to */
    __field_bcount(size)
    ASN1octet_t        *buf;    /* buffer to decode from */
    ASN1uint32_t        size;   /* size of buffer */
    ASN1uint32_t        len;    /* len of decoded data in buffer */
    ASN1error_e         err;    /* error code for last decoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};


/* --- flags for functions --- */

#define ASN1DECFREE_NON_PDU_ID    ((ASN1uint32_t) -1)

enum
{
    ASN1FLAGS_NONE              = 0x00000000L, /* no flags */
    ASN1FLAGS_NOASSERT          = 0x00001000L, /* no asertion */
};

enum
{
    ASN1ENCODE_APPEND           = 0x00000001L, /* append to current buffer*/
    ASN1ENCODE_REUSEBUFFER      = 0x00000004L, /* empty destination buffer */
    ASN1ENCODE_SETBUFFER        = 0x00000008L, /* use a user-given destination buffer */
    ASN1ENCODE_ALLOCATEBUFFER   = 0x00000010L, /* do not free/reuse buffer */
    ASN1ENCODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

enum
{
    ASN1DECODE_APPENDED         = 0x00000001L, /* continue behind last pdu*/
    ASN1DECODE_REWINDBUFFER     = 0x00000004L, /* rescan from buffer start*/
    ASN1DECODE_SETBUFFER        = 0x00000008L, /* use a user-given src buffer */
    ASN1DECODE_AUTOFREEBUFFER   = 0x00000010L, /* Assume responsibility for allocated buffer */
    ASN1DECODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

/*****************************************************************************
  ASN1_CreateModule

*****************************************************************************/
extern ASN1_PUBLIC 
ASN1module_t 
ASN1API 
ASN1_CreateModule(
                ASN1uint32_t            nVersion,
                ASN1encodingrule_e      eRule,
                ASN1uint32_t            dwFlags, /* ASN1FLAGS_NONE or ASN1FLAGS_NOASSERT */
                ASN1uint32_t            cPDU,
                const ASN1GenericFun_t  apfnEncoder[],
                const ASN1GenericFun_t  apfnDecoder[],
                const ASN1FreeFun_t     apfnFreeMemory[],
                const ASN1uint32_t      acbStructSize[],
                ASN1magic_t             nModuleName
    );

/*****************************************************************************
  ASN1_CloseModule

*****************************************************************************/
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1_CloseModule(
    __in        ASN1module_t        pModule
    );

/*****************************************************************************
  ASN1_CreateEncoder

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_CreateEncoder(
    __in        ASN1module_t        pModule,
    __deref_out ASN1encoding_t     *ppEncoderInfo,
    __in_bcount_opt( cbBufSize )
                ASN1octet_t        *pbBuf,
                ASN1uint32_t        cbBufSize,
    __in_opt    ASN1encoding_t      pParent
    );

/*****************************************************************************
  ASN1_Encode

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_Encode(
    __in        ASN1encoding_t      pEncoderInfo,
    __in        void               *pDataStruct,
                ASN1uint32_t        nPduNum,
                ASN1uint32_t        dwFlags,
    __out_bcount_opt( cbBufSize )          
                ASN1octet_t        *pbBuf,
                ASN1uint32_t        cbBufSize
    );

/*****************************************************************************
  ASN1_CloseEncoder

*****************************************************************************/
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1_CloseEncoder(
    __in        ASN1encoding_t      pEncoderInfo
    );

/*****************************************************************************
  ASN1_CloseEncoder2

*****************************************************************************/
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1_CloseEncoder2(
    __in        ASN1encoding_t      pEncoderInfo
    );

/*****************************************************************************
  ASN1_CreateDecoder

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_CreateDecoder(
    __in        ASN1module_t        pModule,
    __deref_out ASN1decoding_t     *ppDecoderInfo,
    __in_bcount_opt(cbBufSize)
                ASN1octet_t        *pbBuf,
                ASN1uint32_t        cbBufSize,
    __in_opt    ASN1decoding_t      pParent
    );

/*****************************************************************************
  ASN1_CreateDecoderEx

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_CreateDecoderEx(
    __in        ASN1module_t        pModule,
    __deref_out ASN1decoding_t     *ppDecoderInfo,
    __in_bcount_opt(cbBufSize)
                ASN1octet_t        *pbBuf,
                ASN1uint32_t        cbBufSize,
    __in_opt    ASN1decoding_t      pParent,
                ASN1uint32_t        dwFlags
    );

/*****************************************************************************
  ASN1_Decode

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_Decode(
    __in        ASN1decoding_t      pDecoderInfo,
    __deref_out void              **ppDataStruct,
                ASN1uint32_t        nPduNum,
                ASN1uint32_t        dwFlags,
    __in_bcount(cbBufSize)
                ASN1octet_t        *pbBuf,
                ASN1uint32_t        cbBufSize
    );

/*****************************************************************************
  ASN1_CloseDecoder

*****************************************************************************/
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1_CloseDecoder(
    __in        ASN1decoding_t      pDecoderInfo
    );


/*****************************************************************************
  ASN1_FreeEncoded

*****************************************************************************/
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1_FreeEncoded(
    __in        ASN1encoding_t      pEncoderInfo,
    __in        void               *pBuf
    );

/*****************************************************************************
  ASN1_FreeDecoded

*****************************************************************************/
extern 
ASN1_PUBLIC 
void 
ASN1API 
ASN1_FreeDecoded(
    __in        ASN1decoding_t      pDecoderInfo,
    __in        void               *pDataStruct,
                ASN1uint32_t        nPduNum
    );


/*****************************************************************************
  Options

*****************************************************************************/
typedef enum
{
    // common set option
    ASN1OPT_CHANGE_RULE                 = 0x101,

    // common get option
    ASN1OPT_GET_RULE                    = 0x201,

    // set encoder option
    ASN1OPT_NOT_REUSE_BUFFER            = 0x301,
    ASN1OPT_REWIND_BUFFER               = 0x302,

    // get encoder option

    // set decoder option
    ASN1OPT_SET_DECODED_BUFFER          = 0x501,
    ASN1OPT_DEL_DECODED_BUFFER          = 0x502,

    // get decoder option
    ASN1OPT_GET_DECODED_BUFFER_SIZE     = 0x601,
}
ASN1option_e;

typedef struct tagASN1optionparam_t
{
    ASN1option_e    eOption;
    union
    {
        ASN1encodingrule_e              eRule;
        ASN1uint32_t                    cbRequiredDecodedBufSize;
        struct
        {
            ASN1octet_t    *pbBuf;
            ASN1uint32_t    cbBufSize;
        }                               Buffer;
    };
}
ASN1optionparam_t, ASN1optionparam_s;


/*****************************************************************************
  ASN1_SetEncoderOption

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_SetEncoderOption(
    __in        ASN1encoding_t      pEncoderInfo,
    __in        ASN1optionparam_t  *pOptParam
    );

/*****************************************************************************
  ASN1_GetEncoderOption

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_GetEncoderOption(
    __in        ASN1encoding_t      pEncoderInfo,
    __inout     ASN1optionparam_t  *pOptParam
    );

/*****************************************************************************
  ASN1_SetDecoderOption

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_SetDecoderOption(
    __in        ASN1decoding_t      pDecoderInfo,
    __in        ASN1optionparam_t  *pOptParam
    );

/*****************************************************************************
  ASN1_GetDecoderOption

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1_GetDecoderOption(
    __in        ASN1decoding_t      pDecoderInfo,
    __inout     ASN1optionparam_t  *pOptParam
    );


/*****************************************************************************
  XXX_free

*****************************************************************************/
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1bitstring_free(
    __in ASN1bitstring_t *
    );

extern ASN1_PUBLIC 
void 
ASN1API 
ASN1octetstring_free(
    __in ASN1octetstring_t *
    );

extern ASN1_PUBLIC 
void 
ASN1API 
ASN1objectidentifier_free(
    __in ASN1objectidentifier_t *
    );
    
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1charstring_free(
    __in ASN1charstring_t *
    );
    
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1char16string_free(
    __in ASN1char16string_t *
    );
    
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1char32string_free(
    __in ASN1char32string_t *
    );
    
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1ztcharstring_free(
    __in ASN1ztcharstring_t
    );
    
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1ztchar16string_free(
    __in ASN1ztchar16string_t
    );
    
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1ztchar32string_free(
    __in ASN1ztchar32string_t
    );
    
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1open_free(
    __in ASN1open_t *
    );
    
extern ASN1_PUBLIC 
void 
ASN1API 
ASN1utf8string_free(
    __in ASN1wstring_t *
    );

/*****************************************************************************
  ASN1DecAlloc

*****************************************************************************/
extern ASN1_PUBLIC 
__out_bcount_opt( size )
LPVOID 
ASN1API 
ASN1DecAlloc(
    __in        ASN1decoding_t dec, 
                ASN1uint32_t size
    );

/*****************************************************************************
  ASN1DecRealloc

*****************************************************************************/
extern ASN1_PUBLIC 
__out_bcount_opt( size )
LPVOID 
ASN1API 
ASN1DecRealloc(
    __in        ASN1decoding_t dec, 
    __in        LPVOID ptr, 
                ASN1uint32_t size
                );

/*****************************************************************************
  ASN1Free

*****************************************************************************/
extern ASN1_PUBLIC 
void   
ASN1API 
ASN1Free(
    __in        LPVOID  ptr
    );

/*****************************************************************************
  ASN1EncSetError

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API ASN1EncSetError(
    __in        ASN1encoding_t enc, 
                ASN1error_e err
    );
    
/*****************************************************************************
  ASN1EncSetError

*****************************************************************************/
extern ASN1_PUBLIC 
__success( return >= 0 )
ASN1error_e 
ASN1API 
ASN1DecSetError(
    __in        ASN1decoding_t dec, 
                ASN1error_e err
    );

/*****************************************************************************
  intx conversions

*****************************************************************************/
extern ASN1_PUBLIC 
ASN1uint32_t 
ASN1API 
ASN1intx_uoctets(
    __in ASN1intx_t *
    );
    
extern ASN1_PUBLIC 
void         
ASN1API 
ASN1intx_free(
    __in ASN1intx_t *
    );
    
extern ASN1_PUBLIC 
ASN1int32_t  
ASN1API 
ASN1intx2int32(
    __in ASN1intx_t *
    );
    
extern ASN1_PUBLIC 
ASN1uint32_t 
ASN1API 
ASN1intx2uint32(
    __in ASN1intx_t *
    );
    
extern ASN1_PUBLIC 
int          
ASN1API 
ASN1intxisuint32(
    __in ASN1intx_t *
    );
    
extern ASN1_PUBLIC 
void         
ASN1API 
ASN1intx_setuint32(
    __out   ASN1intx_t *dst, 
            ASN1uint32_t val 
    );
    
/*****************************************************************************
 ASN1uint32_uoctets

    count octets for unsigned encoding of an uint32 value 

*****************************************************************************/
extern ASN1_PUBLIC 
ASN1uint32_t 
ASN1API 
ASN1uint32_uoctets(
    ASN1uint32_t
    );

/*****************************************************************************
  Comparisson APIs

*****************************************************************************/
extern ASN1_PUBLIC 
int 
ASN1API 
ASN1intx_cmp(
    __in        ASN1intx_t *, 
    __in        ASN1intx_t *
    );

extern ASN1_PUBLIC 
int 
ASN1API 
ASN1objectidentifier_cmp(
    __in        ASN1objectidentifier_t *,
    __in        ASN1objectidentifier_t *
    );
    
extern ASN1_PUBLIC 
int 
ASN1API 
ASN1objectidentifier2_cmp(
    __in        ASN1objectidentifier2_t *, 
    __in        ASN1objectidentifier2_t *
    );
    
extern ASN1_PUBLIC 
int 
ASN1API 
ASN1bitstring_cmp(
    __in        ASN1bitstring_t *, 
    __in        ASN1bitstring_t *, 
                int
    );
    
extern ASN1_PUBLIC 
int 
ASN1API 
ASN1octetstring_cmp(
    __in        ASN1octetstring_t *, 
    __in        ASN1octetstring_t *
    );
    
extern ASN1_PUBLIC 
int 
ASN1API 
ASN1charstring_cmp(
    __in        ASN1charstring_t *, 
    __in        ASN1charstring_t *
    );

extern ASN1_PUBLIC 
int 
ASN1API 
ASN1char16string_cmp(
    __in        ASN1char16string_t *, 
    __in        ASN1char16string_t *
    );

extern ASN1_PUBLIC 
int 
ASN1API 
ASN1char32string_cmp(
    __in        ASN1char32string_t *, 
    __in        ASN1char32string_t *
    );

extern ASN1_PUBLIC 
int 
ASN1API 
ASN1ztcharstring_cmp(
    __in_z      ASN1ztcharstring_t, 
    __in_z      ASN1ztcharstring_t
    );

extern ASN1_PUBLIC 
int 
ASN1API 
ASN1ztchar16string_cmp(
    __in_z      ASN1ztchar16string_t, 
    __in_z      ASN1ztchar16string_t
    );

extern ASN1_PUBLIC 
int 
ASN1API 
ASN1ztchar32string_cmp(
    __in_z      ASN1ztchar32string_t, 
    __in_z      ASN1ztchar32string_t
    );

extern ASN1_PUBLIC 
int 
ASN1API 
ASN1open_cmp(
    __in        ASN1open_t *, 
    __in        ASN1open_t *
    );

extern ASN1_PUBLIC 
int 
ASN1API
ASN1generalizedtime_cmp(
    __in        ASN1generalizedtime_t *, 
    __in        ASN1generalizedtime_t *
    );
 
extern ASN1_PUBLIC 
int 
ASN1API 
ASN1utctime_cmp(
    __in        ASN1utctime_t *, 
    __in        ASN1utctime_t *
    );


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\midluser.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       midluser.cxx
//
//  Contents:   KDC core memory allocation routines
//
//  Classes:
//
//  Functions:
//
//  History:    17-August-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

void * __RPC_USER
MIDL_user_allocate(size_t size)
{
//    TRACE(KDC, MIDL_user_allocate, DEB_FUNCTION);

    PVOID pvMem;

    //
    // The ASN.1 marshalling code may allocate odd sizes that can't be
    // encrypted with a block cipher. By rounding up the size to 8 we can
    // handle block sizes up to 8 bytes.
    //

    pvMem = KdcAllocMemory(
                ROUND_UP_COUNT(size,8)
                );

    if ( pvMem == NULL )
    {
        DebugLog((DEB_ERROR, "MIDL allocate failed\n"));
    }
    else
    {
        ZeroMemory(pvMem, ROUND_UP_COUNT(size,8));
    }

    return(pvMem);


}

void __RPC_USER
MIDL_user_free(void * ptr)
{
//    TRACE(KDC, MIDL_user_free, DEB_FUNCTION);

    KdcFreeMemory( ptr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\krb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s * PKERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_COMPOUND_IDENTITY_s * PKERB_PA_COMPOUND_IDENTITY;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1int32_t KERB_PA_PAC_REQUEST_EX_pac_sections_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s {
    PKERB_PA_PAC_REQUEST_EX_pac_sections next;
    KERB_PA_PAC_REQUEST_EX_pac_sections_Seq value;
} KERB_PA_PAC_REQUEST_EX_pac_sections_Element, *KERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;
#define KERB_TYPED_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_TYPED_DATA)

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
//#ifdef XBOX_KDC
    ASN1uint32_t echo_length;
    ASN1octet_t echo_data[40];
//#endif
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(KERB_EXT_ERROR)

typedef struct KERB_PA_FOR_USER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PRINCIPAL_NAME userName;
    KERB_REALM userRealm;
    KERB_CHECKSUM cksum;
    ASN1ztcharstring_t authentication_package;
#   define KERB_PA_FOR_USER_authorization_data_present 0x80
    ASN1octetstring_t authorization_data;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_PA_PAC_REQUEST_EX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t include_pac;
#   define pac_sections_present 0x80
    PKERB_PA_PAC_REQUEST_EX_pac_sections pac_sections;
} KERB_PA_PAC_REQUEST_EX;
#define KERB_PA_PAC_REQUEST_EX_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_PA_PAC_REQUEST_EX)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER_LARGE sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_COMPOUND_IDENTITY_s {
    PKERB_PA_COMPOUND_IDENTITY next;
    KERB_TICKET value;
} KERB_PA_COMPOUND_IDENTITY_Element, *KERB_PA_COMPOUND_IDENTITY;
#define KERB_PA_COMPOUND_IDENTITY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_PA_COMPOUND_IDENTITY_Element)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 49
#define SIZE_KRB5_Module_PDU_49 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 50
#define SIZE_KRB5_Module_PDU_50 sizeof(KERB_PA_PK_AS_REQ2)


extern ASN1module_t KRB5_Module;
extern void ASN1CALL KRB5_Module_Startup(void);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\krb5p.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krb5p.h
//
// Contents:    pointer type definitions for ASN.1 stub types
//
//
// History:     8-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERB5P_H__
#define __KERB5P_H__

typedef KERB_HOST_ADDRESS *PKERB_HOST_ADDRESS;
typedef KERB_PRINCIPAL_NAME *PKERB_PRINCIPAL_NAME;
typedef KERB_REALM *PKERB_REALM;
typedef KERB_TIME *PKERB_TIME;
typedef KERB_ENCRYPTED_DATA *PKERB_ENCRYPTED_DATA;
typedef KERB_TICKET *PKERB_TICKET;
typedef KERB_TRANSITED_ENCODING *PKERB_TRANSITED_ENCODING;
typedef KERB_ENCRYPTION_KEY *PKERB_ENCRYPTION_KEY;
typedef KERB_ENCRYPTED_TICKET *PKERB_ENCRYPTED_TICKET;
typedef KERB_CHECKSUM *PKERB_CHECKSUM;
typedef KERB_AUTHENTICATOR *PKERB_AUTHENTICATOR;
typedef KERB_PA_DATA *PKERB_PA_DATA;
typedef KERB_KDC_REQUEST_BODY *PKERB_KDC_REQUEST_BODY;
typedef KERB_KDC_REQUEST *PKERB_KDC_REQUEST;
typedef KERB_AS_REQUEST *PKERB_AS_REQUEST;
typedef KERB_TGS_REQUEST *PKERB_TGS_REQUEST;
typedef KERB_KDC_REPLY *PKERB_KDC_REPLY;
typedef KERB_AS_REPLY *PKERB_AS_REPLY;
typedef KERB_TGS_REPLY *PKERB_TGS_REPLY;
typedef KERB_ENCRYPTED_KDC_REPLY *PKERB_ENCRYPTED_KDC_REPLY;
typedef KERB_ENCRYPTED_AS_REPLY *PKERB_ENCRYPTED_AS_REPLY;
typedef KERB_ENCRYPTED_TGS_REPLY *PKERB_ENCRYPTED_TGS_REPLY;
typedef KERB_AP_OPTIONS *PKERB_AP_OPTIONS;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;
typedef KERB_AP_REPLY *PKERB_AP_REPLY;
typedef KERB_ENCRYPTED_AP_REPLY *PKERB_ENCRYPTED_AP_REPLY;
typedef KERB_SAFE_BODY *PKERB_SAFE_BODY;
typedef KERB_SAFE_MESSAGE *PKERB_SAFE_MESSAGE;
typedef KERB_PRIV_MESSAGE *PKERB_PRIV_MESSAGE;
typedef KERB_ENCRYPTED_PRIV *PKERB_ENCRYPTED_PRIV;
typedef KERB_ERROR *PKERB_ERROR;
typedef KERB_EXT_ERROR *PKERB_EXT_ERROR;
typedef KERB_ERROR_METHOD_DATA *PKERB_ERROR_METHOD_DATA;
typedef struct PKERB_AUTHORIZATION_DATA_s KERB_AUTHORIZATION_DATA;
typedef struct PKERB_TICKET_EXTENSIONS_s KERB_TICKET_EXTENSIONS;
typedef KERB_CRED *PKERB_CRED;
typedef KERB_ENCRYPTED_CRED *PKERB_ENCRYPTED_CRED;
typedef KERB_CRED_INFO *PKERB_CRED_INFO;
typedef struct PKERB_LAST_REQUEST_s KERB_LAST_REQUEST;
typedef struct PKERB_HOST_ADDRESSES_s KERB_HOST_ADDRESSES;
typedef struct PKERB_ETYPE_INFO_s KERB_ETYPE_INFO;
typedef KERB_ETYPE_INFO_ENTRY * PKERB_ETYPE_INFO_ENTRY;
typedef KERB_ENCRYPTED_TIMESTAMP *PKERB_ENCRYPTED_TIMESTAMP;
typedef struct PKERB_PREAUTH_DATA_LIST_s KERB_PREAUTH_DATA_LIST, *PKERB_PREAUTH_DATA_LIST;
typedef KERB_TICKET_FLAGS *PKERB_TICKET_FLAGS;
typedef KERB_PA_PAC_REQUEST *PKERB_PA_PAC_REQUEST;
typedef KERB_PA_PAC_REQUEST_EX *PKERB_PA_PAC_REQUEST_EX;
typedef KERB_PA_FOR_USER *PKERB_PA_FOR_USER;

#ifndef MIDL_PASS

typedef struct KERB_PRINCIPAL_NAME_name_string_s KERB_PRINCIPAL_NAME_ELEM, *PKERB_PRINCIPAL_NAME_ELEM;
typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s KERB_CRYPT_LIST, *PKERB_CRYPT_LIST;
typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s KERB_TICKET_LIST, *PKERB_TICKET_LIST;
typedef struct KERB_KDC_REQUEST_preauth_data_s KERB_PA_DATA_LIST, *PKERB_PA_DATA_LIST;
typedef struct KERB_KDC_REPLY_preauth_data_s KERB_REPLY_PA_DATA_LIST, *PKERB_REPLY_PA_DATA_LIST;
typedef struct KERB_CRED_tickets_s KERB_CRED_TICKET_LIST, *PKERB_CRED_TICKET_LIST;
typedef struct KERB_ENCRYPTED_CRED_ticket_info_s KERB_CRED_INFO_LIST, *PKERB_CRED_INFO_LIST;
typedef struct KERB_PA_PK_AS_REQ2_user_certs_s KERB_CERTIFICATE_LIST, *PKERB_CERTIFICATE_LIST;
typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s KERB_CERTIFIER_LIST, *PKERB_CERTIFIER_LIST;
typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s KERB_KDC_AUTH_DATA_LIST, *PKERB_KDC_AUTH_DATA_LIST;

#endif // MIDL_PASS

typedef KERB_KDC_ISSUED_AUTH_DATA *PKERB_KDC_ISSUED_AUTH_DATA;
typedef struct PKERB_IF_RELEVANT_AUTH_DATA_ KERB_IF_RELEVANT_AUTH_DATA;
typedef KERB_DH_PARAMTER *PKERB_DH_PARAMTER;
typedef KERB_PA_PK_AS_REQ *PKERB_PA_PK_AS_REQ;
typedef KERB_PA_PK_AS_REQ2 *PKERB_PA_PK_AS_REQ2;
typedef KERB_SIGNED_AUTH_PACKAGE *PKERB_SIGNED_AUTH_PACKAGE;
typedef KERB_AUTH_PACKAGE *PKERB_AUTH_PACKAGE;
typedef KERB_PK_AUTHENTICATOR *PKERB_PK_AUTHENTICATOR;
typedef KERB_SIGNED_REPLY_KEY_PACKAGE *PKERB_SIGNED_REPLY_KEY_PACKAGE;
typedef struct ASN1objectidentifier_s KERB_OBJECT_ID, *PKERB_OBJECT_ID;
typedef KERB_REPLY_KEY_PACKAGE *PKERB_REPLY_KEY_PACKAGE;
typedef KERB_PA_PK_AS_REP *PKERB_PA_PK_AS_REP;
typedef KERB_PA_PK_AS_REP2 *PKERB_PA_PK_AS_REP2;
typedef KERB_CERTIFICATE *PKERB_CERTIFICATE;
typedef KERB_SIGNED_KDC_PUBLIC_VALUE *PKERB_SIGNED_KDC_PUBLIC_VALUE;
typedef KERB_SUBJECT_PUBLIC_KEY_INFO *PKERB_SUBJECT_PUBLIC_KEY_INFO;
typedef KERB_ALGORITHM_IDENTIFIER *PKERB_ALGORITHM_IDENTIFIER;
typedef KERB_SIGNATURE *PKERB_SIGNATURE;
typedef KERB_TGT_REPLY *PKERB_TGT_REPLY;
typedef KERB_TGT_REQUEST *PKERB_TGT_REQUEST;
typedef KERB_PA_SERV_REFERRAL *PKERB_PA_SERV_REFERRAL;
typedef KERB_CHANGE_PASSWORD_DATA *PKERB_CHANGE_PASSWORD_DATA;
#define                     KERB_KDC_OPTIONS_reserved 0x80000000
#define                     KERB_KDC_OPTIONS_forwardable 0x40000000
#define                     KERB_KDC_OPTIONS_forwarded 0x20000000
#define                     KERB_KDC_OPTIONS_proxiable 0x10000000
#define                     KERB_KDC_OPTIONS_proxy 0x08000000
#define                     KERB_KDC_OPTIONS_postdated 0x02000000
#define                     KERB_KDC_OPTIONS_allow_postdate 0x04000000
#define                     KERB_KDC_OPTIONS_unused7 0x01000000
#define                     KERB_KDC_OPTIONS_renewable 0x00800000
#define                     KERB_KDC_OPTIONS_unused9 0x00400000
#define                     KERB_KDC_OPTIONS_name_canonicalize 0x00010000
#define                     KERB_KDC_OPTIONS_cname_in_addl_tkt 0x00020000
#define                     KERB_KDC_OPTIONS_cname_in_pa_data  0x00040000
#define                     KERB_KDC_OPTIONS_renewable_ok 0x00000010
#define                     KERB_KDC_OPTIONS_enc_tkt_in_skey 0x00000008
#define                     KERB_KDC_OPTIONS_renew 0x00000002
#define                     KERB_KDC_OPTIONS_validate 0x00000001


#define                     KERB_AP_OPTIONS_reserved 0x80000000
#define                     KERB_AP_OPTIONS_use_session_key 0x40000000
#define                     KERB_AP_OPTIONS_mutual_required 0x20000000
#define                     KERB_AP_OPTIONS_reserved1 0x00000001

//
// these #define's are done for the conversion from the old oss compiler to the
// new telis compiler.
//
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_TICKET_client_addresses          client_addresses
#define KERB_ENCRYPTED_TICKET_renew_until                       renew_until
#define KERB_CRED_INFO_renew_until                                      renew_until
#define KERB_KDC_REQUEST_BODY_renew_until                       renew_until
#define KERB_KDC_REQUEST_BODY_server_name                       server_name
#define KERB_KDC_REQUEST_preauth_data                           preauth_data
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_AP_REPLY_sequence_number         sequence_number
#define KERB_AUTHENTICATOR_subkey                                       subkey
#define KERB_ENCRYPTED_AP_REPLY_subkey                          subkey
#define KERB_TGT_REQUEST_server_name                            server_name
#define KERB_ERROR_client_name                                          client_name
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_KDC_REQUEST_BODY_client_name                       client_name
#define KERB_KDC_REPLY_preauth_data                                     preauth_data
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_ENCRYPTED_KDC_REPLY_starttime                      starttime
#define KERB_CRED_INFO_starttime                                        starttime
#define KERB_ENCRYPTED_KDC_REPLY_renew_until            renew_until
#define KERB_ENCRYPTED_TICKET_authorization_data        authorization_data
#define KERB_ENCRYPTED_TICKET_starttime                         starttime
#define KERB_ENCRYPTED_PRIV_sequence_number                     sequence_number
#define KERB_KDC_REQUEST_BODY_starttime                         starttime
#define KERB_ENCRYPTED_KDC_REPLY_client_addresses       client_addresses


#endif // __KERB5P_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\netdebug.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    NetDebug.h

Abstract:

    This header file declares various debug routines for use in the
    networking code.

Author:

    John Rogers (JohnRo) 11-Mar-1991

Environment:

    ifdef'ed for NT, any ANSI C environment, or none of the above (which
    implies nondebug).  The interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Mar-1991 JohnRo
        Created.
    25-Mar-1991 JohnRo
        Added more FORMAT_ strings.  Got rid of tabs in file.
    28-Mar-1991 JohnRo
        Added FORMAT_HEX_ strings.
    08-Apr-1991 JohnRo
        Added temporary versions of wide char stuff (FORMAT_LPTSTR, etc).
    16-Apr-1991 JohnRo
        Added PC-LINT version of NetpAssert(), to avoid occasional constant
        Boolean value messages.  Added wrappers for NT debug code, to avoid
        recompile hits from <nt.h> all over the place.
    25-Apr-1991 JohnRo
        Created procedure version of NetpDbgHexDump().
    13-May-1991 JohnRo
        Added FORMAT_LPVOID to replace FORMAT_POINTER.  Changed nondebug
        definition of NetpDbgHexDump() to avoid evaluating parameters.
    15-May-1991 JohnRo
        FORMAT_HEX_WORD was wrong.
    19-May-1991 JohnRo
        Improve LINT handling of assertions.
    21-May-1991 JohnRo
        Added NetpDbgReasonable() for partial hex dumps.
    13-Jun-1991 JohnRo
        Added NetpDbgDisplay routines.
        Moved DBGSTATIC here from <Rxp.h>.
    02-Jul-1991 JohnRo
        Added display routines for print job, print queue, and print dest.
    05-Jul-1991 JohnRo
        Avoid FORMAT_WORD name (used by MIPS header files).
    22-Jul-1991 JohnRo
        Implement downlevel NetConnectionEnum.
    25-Jul-1991 JohnRo
        Wksta debug support.
    03-Aug-1991 JohnRo
        Rename wksta display routine for consistency.
    20-Aug-1991 JohnRo
        Allow use in nondebug builds.
    20-Aug-1991 JohnRo
        Downlevel NetFile APIs.
    11-Sep-1991 JohnRo
        Downlevel NetService APIs.  Added UNICODE versions of some FORMAT_
        equates.  Added FORMAT_ULONG for NT use.
    13-Sep-1991 JohnRo
        Change "reasonable" debug amount to be an even number of lines.
        Create an equate for it.  Added LPDEBUG_STRING and a FORMAT_ for that.
    15-Oct-1991 JohnRo
        Implement remote NetSession APIs.
    11-Nov-1991 JohnRo
        Implement remote NetWkstaUserEnum().  Added FORMAT_RPC_STATUS.
    26-Dec-1991 JohnRo
        Added stuff for replicator APIs.
    07-Jan-1992 JohnRo
        Added NetpDbgDisplayWStr() for UNICODE strings.
        Added NetpDbgDisplayTStr() to be consistent.
    26-Feb-1992 JohnRo
        Added NetpDbgDisplayTimestamp() (seconds since 1970).
    15-Apr-1992 JohnRo
        Moved FORMAT_ equates into /nt/private/inc/debugfmt.h (so they
        can be used by the service controller as well).
    13-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    24-Aug-1992 JohnRo
        Fixed free build again (misnamed repl import/export display macros).
    02-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo (from downlevel) level=3 rc=124.
        (Added NetpDbgDisplayPrintQArray.)
    05-Jan-1993 JohnRo
        Repl WAN support (get rid of repl name list limits).
        Made changes suggested by PC-LINT 5.0
    04-Mar-1993 JohnRo
        RAID 12237: replicator tree depth exceeded (add display of FILETIME
        and LARGE_INTEGER time).
    31-Mar-1993 JohnRo
        Allow others to display replicator state too.

--*/

#ifndef _NETDEBUG_
#define _NETDEBUG_

// These must be included first:
#include <windef.h>             // BOOL, DWORD, FALSE, LPBYTE, etc.

// These may be included in any order:
#include <stdarg.h>

#if DBG

// Normal netlib debug version.  No extra includes.

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#include <assert.h>             // assert().
#include <stdio.h>              // printf().

#else // ndef CDEBUG

// Nondebug version.

#endif // ndef CDEBUG

#endif // not DBG


#if !DBG || defined(lint) || defined(_lint)
#define DBGSTATIC static        // hidden function
#else
#define DBGSTATIC               // visible for use in debugger.
#endif


//
// printf-style format strings for some possibly nonportable stuff...
// These are passed to NetpDbgPrint(); use with other routines at your
// own risk.
//
// Most FORMAT_ equates now reside in /nt/private/inc/debugfmt.h.
//

typedef LPSTR LPDEBUG_STRING;

#define FORMAT_API_STATUS       "%lu"
#define FORMAT_LPDEBUG_STRING   "%s"

#ifdef __cplusplus
extern "C" {
#endif


// NetpAssert: continue if Predicate is true; otherwise print debug message
// (if possible) and hit a breakpoint (if possible).  Do nothing at all if
// this is a nondebug build.
//
// VOID
// NetpAssert(
//     IN BOOL Predicate
//     );
//

#if DBG

VOID
NetpAssertFailed(
    IN LPDEBUG_STRING FailedAssertion,
    IN LPDEBUG_STRING FileName,
    IN DWORD LineNumber,
    IN LPDEBUG_STRING Message OPTIONAL
    );

// Normal networking debug version.
#define NetpAssert(Predicate) \
    { \
        /*lint -save -e506 */  /* don't complain about constant values here */ \
        if (!(Predicate)) \
            NetpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
        /*lint -restore */ \
    }

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#define NetpAssert(Predicate)   assert(Predicate)

#else // ndef CDEBUG

// Nondebug version.
#define NetpAssert(Predicate)   /* no output; ignore arguments */

#endif // ndef CDEBUG

#endif // not DBG


// NetpBreakPoint: if this is a debug version of some sort, cause a breakpoint
// somehow.  (This may just be an assertion failure in ANSI C.)  Do nothing at
// all in nondebug builds.
//
// VOID
// NetpBreakPoint(
//     VOID
//     );
//

#if DBG

// NT debug version.  Calls DbgBreakPoint.
VOID
NetpBreakPoint(
    VOID
    );

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#define NetpBreakPoint          NetpAssert(FALSE)

#else // ndef CDEBUG

// Nondebug version.
#define NetpBreakPoint()          /* no effect. */

#endif // ndef CDEBUG

#endif // not DBG


#if DBG
VOID
NetpDbgDisplayDword(
    IN LPDEBUG_STRING Tag,
    IN DWORD Value
    );

VOID
NetpDbgDisplayDwordHex(
    IN LPDEBUG_STRING Tag,
    IN DWORD Value
    );

VOID
NetpDbgDisplayLong(
    IN LPDEBUG_STRING Tag,
    IN LONG Value
    );

VOID
NetpDbgDisplayString(
    IN LPDEBUG_STRING Tag,
    IN LPTSTR Value
    );

VOID
NetpDbgDisplayTag(
    IN LPDEBUG_STRING Tag
    );

VOID
NetpDbgDisplayTimestamp(
    IN LPDEBUG_STRING Tag,
    IN DWORD Time               // Seconds since 1970.
    );

VOID
NetpDbgDisplayTod(
    IN LPDEBUG_STRING Tag,
    IN LPVOID TimePtr           // LPTIME_OF_DAY_INFO.
    );

#else // not DBG

#define NetpDbgDisplayDword(Tag,Value)        /* nothing */
#define NetpDbgDisplayDwordHex(Tag,Value)     /* nothing */
#define NetpDbgDisplayLong(Tag,Value)         /* nothing */
#define NetpDbgDisplayString(Tag,Value)       /* nothing */
#define NetpDbgDisplayTimestamp(Tag,Time)     /* nothing */
#define NetpDbgDisplayTag(Tag)                /* nothing */
#define NetpDbgDisplayTod(Tag,Tod)            /* nothing */

#endif // not DBG

//
//  NetpKdPrint() & NetpDbgPrint() are net equivalents of
//  KdPrint()     & DbgPrint().  Suggested usage:
//
//  NetpKdPrint() & KdPrint()   -   OK
//  NetpDbgPrint()              -   so,so; produces warnings in the free build
//  DbgPrint                    -   bad
//

#if DBG

#define NetpKdPrint(_x_) NetpDbgPrint _x_

VOID
NetpDbgPrint(
    IN LPDEBUG_STRING FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

VOID
NetpHexDump(
    LPBYTE Buffer,
    DWORD BufferSize
    );

#else // not DBG

#ifdef CDEBUG

//  ANSI C debug version.

#define NetpKdPrint(_x_)        NetpDbgPrint _x_
#define NetpDbgPrint            (void) printf

#else // ndef CDEBUG

//  Nondebug version.  Note that NetpKdPrint() eliminates all its
//  arguments.

#define NetpKdPrint(_x_)

#endif // ndef CDEBUG
#endif // not DBG


// NetpDbgHexDump: do a hex dump of some number of bytes to the debug
// terminal or whatever.  This is a no-op in a nondebug build.

#if DBG || defined(CDEBUG)

VOID
NetpDbgHexDump(
    IN LPBYTE StartAddr,
    IN DWORD Length
    );

#else

#define NetpDbgHexDump(StartAddr,Length)     // no output; ignore arguments

#endif

//
// Define a number of bytes to dump for partial dumps.  Each line dumps
// 16 bytes, so do an even number of lines.
//
#define REASONABLE_DUMP_SIZE  (6*16)

// NetpDbgReasonable: pick a number for partial hex dumps.
//
// DWORD
// NetpDbgReasonable(
//     IN DWORD MaxSize
//     );
#define NetpDbgReasonable(MaxSize) \
    /*lint -save -e506 */  /* don't complain about constant values here */ \
    ( ((MaxSize) < REASONABLE_DUMP_SIZE) ? (MaxSize) : REASONABLE_DUMP_SIZE ) \
    /*lint -restore */

#ifdef __cplusplus
}
#endif

//
// Generic log managment funtions.  Present in debug and free builds.
// All logs are relative to %WINDIR%\\debug\\.  DebugLog will automatically
// have a .LOG appended
//

VOID
NetpInitializeLogFile(
    VOID
    );

VOID
NetpShutdownLogFile(
    VOID
    );

HANDLE
NetpOpenDebugFile(
    IN LPWSTR DebugLog,
    IN BOOLEAN ReopenFlag
    );

VOID
NetpCloseDebugFile(
    IN HANDLE LogHandle
    );

VOID
NetpLogPrintRoutine(
    IN HANDLE LogHandle,
    IN LPSTR Format,
    ...
    );

VOID
NetpLogPrintRoutineVEx(
    IN HANDLE LogHandle,
    IN PDWORD OpenLogThreadId OPTIONAL,
    IN LPSTR Format,
    IN va_list arglist
    );

VOID
NetpLogPrintRoutineV(
    IN HANDLE LogHandle,
    IN LPSTR Format,
    IN va_list arglist
    );

VOID
NetpResetLog(
    IN HANDLE LogHandle
    );


#endif // ndef _NETDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\krbprgma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    krbprgma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let Kerberos compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Zero-sized array in struct/union

#pragma warning (disable: 4200)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// Structure was padded due to __declspec(align())

#pragma warning (disable: 4324)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\pachandlers.cxx ===
//+-----------------------------------------------------------------------
//
// File:        pachandlers.cxx
//
// Contents:    KDC core internal PAC handlers
//
//
// History:     13-Aug-2001   yordanr   Created.
//              22-Jul-2011   splante   Updated for Xbox Identity
//------------------------------------------------------------------------

#include "kdcsvr.hxx"

//
//  pac interface ...
//
#include "pac.hxx"
#define DEFINE_GUIDS
#include "pacext.h"

#include "kerbinterface.h"
#include "kerbhelper.h"
#include "pachandlers.hxx"

//
// Xbox Identity
// 
CPACHandlerXboxIdentity::CPACHandlerXboxIdentity()
{
}

CPACHandlerXboxIdentity::~CPACHandlerXboxIdentity()
{
}

KERBERR
__stdcall
CPACHandlerXboxIdentity::AddClientPrincipal(
    IN  IKerbRequest    *pIKerbRequest,
    OUT PXBOX_IDENTITY   pXboxIdentity,
    OUT BOOL            *pbIdentityPresent
    )
/*++

Routine Description:

    Query the current principal for identity information and
    use id to build the XBOX_IDENTITY

Arguments:

    pIKerbRequest     - Where to find the current principal
    PXboxIdentity     - Current Xbox Identity
    pbIdentityPresent - Where or not hte Xbox Identity was modified

Return Value:

    KERBERR

--*/
{
    HRESULT         hr;
    IKerbPrincipal *pIPrincClient  = NULL;
    IKDBLogonInfo  *pIKdbLogonInfo = NULL;
    KERBERR         kerbErr        = KDC_ERR_NONE;
    NTSTATUS        status         = STATUS_SUCCESS;
    PCIDENTITY      pIdentityInfo  = NULL;

    //
    // Assume that we won't find anything
    // 
    *pbIdentityPresent = FALSE;

    //
    // Get the principal client so that we can figure out
    // what the main identity will be
    // 
    pIPrincClient = pIKerbRequest->GetIPrincClient();
    if (NULL == pIPrincClient)
    {
        status = STATUS_INVALID_PARAMETER_3;
        goto Cleanup;
    }

    //
    // Get the main identity from the client principal
    //
    hr = pIPrincClient->QueryInterface(
        IID_IKDBLogonInfo, 
        (PVOID*)&pIKdbLogonInfo
        );
    if (S_OK != hr || NULL == pIKdbLogonInfo)
    {
        status = STATUS_INVALID_USER_BUFFER;
        goto Cleanup;
    }

    status = pIKdbLogonInfo->GetIdentityInfo(&pIdentityInfo);
    if (NULL == pIdentityInfo)
    {
        goto Cleanup;
    }

    // 
    // We have identity info, remember that
    // 
    *pbIdentityPresent = TRUE;

    //
    // Merge in the IDENTITY into the XBOX_IDENTITY
    // 
    if (pIdentityInfo->IdentityAttributes == IA_MACHINE) 
    {
        pXboxIdentity->MachineIdentity           = * (ULONGLONG *) pIdentityInfo->Identity;
        pXboxIdentity->MachineIdentityCredential =   (BYTE)        pIdentityInfo->CredentialIdType;
    }
    else
    {
        // Find the next available slot
        for (DWORD i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
        {
            if (pXboxIdentity->UserIdentity[i] == 0) 
            {
                pXboxIdentity->UserIdentity[i]           = * (ULONGLONG *) pIdentityInfo->Identity;
                pXboxIdentity->UserIdentityCredential[i] =   (BYTE)        pIdentityInfo->CredentialIdType;
                break;
            }
        }
    }

Cleanup:
    if ( !NT_SUCCESS(status) )
    {
        kerbErr = KRB_ERR_GENERIC;
    }
    return kerbErr;
}

KERBERR
__stdcall
CPACHandlerXboxIdentity::AddClientIdentity(
    IN  IKerbRequest    *pIKerbRequest,
    OUT PXBOX_IDENTITY   pXboxIdentity,
    OUT BOOL            *pbIdentityPresent
    )
/*++

Routine Description:

    Query the current request for identity information and
    use id to build the XBOX_IDENTITY.

    Translation: This copies in data from the PAC_COMPOUND_IDENTITY
    sent for the current request into the XBOX_IDENTITY for
    current request.

Arguments:

    pIKerbRequest     - Where to find the current client
    PXboxIdentity     - Current Xbox Identity
    pbIdentityPresent - Where or not hte Xbox Identity was modified

Return Value:

    KERBERR

--*/
{
    DWORD                i,j;
    HRESULT              hr;
    IPAIdentity         *pIPAIdentity   = NULL;
    KERBERR              kerbErr        = KDC_ERR_NONE;
    NTSTATUS             status         = STATUS_SUCCESS;
    const XBOX_IDENTITY *pXboxId        = NULL;
    XBOX_IDENTITY        tempIdentity;

    //
    // Assume that we won't find anything
    // 
    *pbIdentityPresent = FALSE;

    //
    // Get the current identity handler for this request
    //
    status = pIKerbRequest->GetPAHandler(IID_IPAIdentity, (PVOID*)&pIPAIdentity);
    if (!NT_SUCCESS(status) || NULL == pIPAIdentity)
    {
        goto Cleanup;
    }

    //
    // Get the current identity for this request
    // 
    status = pIPAIdentity->GetXboxIdentity( &pXboxId );
    if (!NT_SUCCESS(status) || NULL == pXboxId) 
    {
        goto Cleanup;
    }

    // 
    // We have identity info, remember that
    // 
    *pbIdentityPresent = TRUE;

    //
    // We are going to build a temporary identity. Start with a copy
    // of the new one
    // 
    memcpy( &tempIdentity, pXboxId, sizeof(XBOX_IDENTITY) );

    //
    // Copy over the machine identity if none is set
    // 
    if (pXboxIdentity->MachineIdentity != 0) 
    {
        if (tempIdentity.MachineIdentity == 0) 
        {
            tempIdentity.MachineIdentity           = pXboxIdentity->MachineIdentity;
            tempIdentity.MachineIdentityCredential = pXboxIdentity->MachineIdentityCredential;
        }
        else
        {
            status = STATUS_OBJECT_NAME_EXISTS;
            goto Cleanup;
        }
    }

    //
    // We already have the new identities in the structure. We did this
    // in order to make sure that the test code could find the identities
    // in the order that that it expects.
    // 
    // At this point, fill in all the identies that were passed into
    // the current request on a no-duplicates, no overwrites manner
    // 
    for (i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
    {
        if (pXboxIdentity->UserIdentity[i] == 0) 
        {
            continue;
        }

        for (j = 0; j < XBOX_IDENTITY_MAX_USERS; ++j) 
        {
            if (tempIdentity.UserIdentity[j] == pXboxIdentity->UserIdentity[i]) 
            {
                break;
            }
            if (tempIdentity.UserIdentity[j] != 0) 
            {
                continue;
            }
            tempIdentity.UserIdentity[j]           = pXboxIdentity->UserIdentity[i];
            tempIdentity.UserIdentityCredential[j] = pXboxIdentity->UserIdentityCredential[i];
            break;
        }

        //
        // Did we find a slot?
        // 
        if (j >= XBOX_IDENTITY_MAX_USERS) 
        {
            status = STATUS_TOO_MANY_NAMES;
            goto Cleanup;
        }
    }

    //
    // Copy the temp identity structure to the output
    // 
    memcpy( pXboxIdentity, &tempIdentity, sizeof(XBOX_IDENTITY) );

Cleanup:
    if (status == STATUS_OBJECT_NAME_EXISTS ||
        status == STATUS_TOO_MANY_NAMES) 
    {
        kerbErr = KDC_ERR_PREAUTH_FAILED;
    }
    else if ( !NT_SUCCESS(status) )
    {
        kerbErr = KRB_ERR_GENERIC;
    }
    return kerbErr;

}


KERBERR
__stdcall
CPACHandlerXboxIdentity::Build(
    IN  IKerbRequest     *pIKerbRequest,
    IN  BOOLEAN          fUpdatePac,
    OUT PPAC_INFO_BUFFER *ppPacInfo,
    OUT NTSTATUS         *pNTStatus
    )
{
    BOOL                 bHaveXboxIdentity   = FALSE;
    BOOL                 bHaveXboxPrincipal  = FALSE;
    KERBERR              kerbErr             = KDC_ERR_NONE;
    NTSTATUS             status              = STATUS_SUCCESS;
    PPAC_INFO_BUFFER     pPacInfoReturn      = NULL;
    ULONG                cbReturn            = 0;
    XBOX_IDENTITY        xboxIdentity        = { 0 };

    //
    // If we aren't updating the PAC, then we need to check for a client principal
    // 

    if (FALSE == fUpdatePac)
    {
        if (NULL != *ppPacInfo) 
        {
            //
            // We expected no previous pac. This is an error condition
            // from the old KDC code
            // 
            status = STATUS_INVALID_PARAMETER_3;
            goto Cleanup;
        }

        kerbErr = AddClientPrincipal( pIKerbRequest, &xboxIdentity, &bHaveXboxPrincipal );
        if (!KERB_SUCCESS(kerbErr))
        {
            status = STATUS_INVALID_PARAMETER_1;
            goto Cleanup;
        }
    }

    //
    // We expect an empty previous pac here, but it a do-nothing condition
    // 
    if (NULL != *ppPacInfo) 
    {
        goto Cleanup;
    }

    //
    // We probably have a client identity
    // 
    kerbErr = AddClientIdentity( pIKerbRequest, &xboxIdentity, &bHaveXboxIdentity );
    if (!KERB_SUCCESS(kerbErr)) 
    {
        status = STATUS_INVALID_PARAMETER_2;
        goto Cleanup;
    }

    //
    // Do we have an interesting identity?
    // 
    // The previous KDC code didn't return a failure for this
    // condition, so continue that trend
    // 
    if (FALSE == bHaveXboxIdentity &&
        FALSE == bHaveXboxPrincipal) 
    {
       goto Cleanup; 
    }

    //
    // Compute the size of the blob returned and allocate it
    //
    cbReturn       = sizeof(PAC_INFO_BUFFER) + sizeof(XBOX_IDENTITY);
    pPacInfoReturn = (PPAC_INFO_BUFFER) MIDL_user_allocate(cbReturn);
    if (NULL == pPacInfoReturn)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Fill in the outer structure.  Encoded in little endian.
    //
    pPacInfoReturn->ulType       = PAC_XBOX_IDENTITY;
    pPacInfoReturn->cbBufferSize = cbReturn - sizeof(PAC_INFO_BUFFER);
    pPacInfoReturn->Data         = (PBYTE)(pPacInfoReturn + 1);

    //
    // Fill in the inner structure.
    // 
    memcpy( pPacInfoReturn->Data, &xboxIdentity, sizeof(XBOX_IDENTITY) );

    //
    // Let the caller know
    // 
    *ppPacInfo = pPacInfoReturn;
    pPacInfoReturn = NULL;

Cleanup:
    if (!NT_SUCCESS(status) && KERB_SUCCESS(kerbErr))
    {
        kerbErr = KRB_ERR_GENERIC;
    }

    *pNTStatus = status;

    if (pPacInfoReturn)
    {
        MIDL_user_free(pPacInfoReturn);
    }

    return kerbErr;
}

//
//  global PAC handlers
//
CPACHandlerXboxIdentity     g_PACHandlerXboxIdentity;
IPACHandler                *g_rgpIPACHandlers[] = {
    &g_PACHandlerXboxIdentity
    };

NTSTATUS
KdcInitializeInternalPacHandlers(
    VOID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    TRACER(L"KdcInitializeInternalPacHandlers", (PVOID *) &Status);

    //
    //  register all PAC handlers
    //
    for (int i = 0;
         i < sizeof(g_rgpIPACHandlers)/sizeof(IPACHandler*);
         i++)
    {
        Status = KdcRegisterPACHandler(g_rgpIPACHandlers[i]);
        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\preauth.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       preauth.h
//
//  Contents:   KDC Preauth function interfaces
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//              12-Sept-2001    yordanr modified for new interface
//
//----------------------------------------------------------------------------

#ifndef _PREAUTH_H_
#define _PREAUTH_H_

KERBERR
KdcCheckPreAuthData(
    IN PIKdbProvider            piKdb,
    IN KERB_SERVICE_ID          Service,
    IN PIKerbPrincipal              ClientInfo,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY   RequestBody,
    OUT OPTIONAL PULONG         PreAuthType,
    OUT PKERB_PA_DATA_LIST      *OutputPreAuthData,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT OPTIONAL PUNICODE_STRING TransitedRealms,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN  CKerbRequest*            pKerbReq
    );

KERBERR
KdcReturnPreAuthData(
    IN CKerbRequest             *pReq,
    OUT PKERB_PA_DATA_LIST      *OutputPreAuthData
    );


NTSTATUS __stdcall
RegisterCorePAHandlerFactories(
    VOID
    );



#endif // _PREAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\pkserv.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pkserv.cxx
//
// Contents:    Server side public key support for Kerberos
//
//
// History:     24-Nov-1997     MikeSw          Created
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <wininet.h>    // for SECURITY_FLAG_xxx
#include <sclogon.h>    // ScHelperXXX
//#include <certca.h>     // for CA*XXX

//
//  do avoid typedef collision
//
#include "kerbinterface.h"

#define FILENO FILENO_PKSERV
//
// This is the cert store containing the CTL used to verify client certificates
//

HCERTSTORE  g_hCryptCertStore = NULL;
HCRYPTPROV g_hCryptClientProvider = NULL;

PCCERT_CONTEXT GlobalKdcCert = NULL;
HANDLE   KdcCertStoreChangeEvent = NULL;
TimeStamp KdcLastChangeEventTime;

CRITICAL_SECTION KdcGlobalCertCritSect;
BOOLEAN              KdcGlobalCertCritSectInitialized = FALSE;

HANDLE KdcCertStoreWait = NULL;
BOOLEAN KdcPKIInitialized = FALSE;

BOOLEAN g_fKdc3DesSupported = TRUE;
HANDLE KdcCaNotificationHandle = NULL;
#define KDC_ROOT_STORE L"ROOT"
#define KDC_PRIVATE_MY_STORE L"MY"

#define MAX_TEMPLATE_NAME_VALUE_SIZE             80 // sizeof (CERT_NAME_VALUE) + wcslen(SmartcardLogon)

KERB_OBJECT_ID g_KdcSignatureAlg[10];


NTSTATUS
KdcGetKdcCertificate(PCCERT_CONTEXT *KdcCert);

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckCertificate
//
//  Synopsis:   a helper routine to verify the certificate. It will check
//              CRLs, CTLs
//
//  Effects:
//
//  Arguments:
//          CertContext - the certificate to check
//          EmbeddedUPNOk - returns TRUE if the certificate can
//                           be translated to a user by looking at the
//                           subject name.
//                           returns FALSE if the certificate must be
//                           mapped by looking in the user's mapped certificate
//                           ds attribute.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckCertificate(
    IN PCCERT_CONTEXT  CertContext,
    OUT PBOOLEAN EmbeddedUPNOk,
    IN OUT PKERB_EXT_ERROR pExtendedError,
    IN OUT OPTIONAL PCERT_CHAIN_POLICY_STATUS FinalChainStatus,
    IN BOOLEAN KdcCert
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    CERT_CHAIN_PARA ChainParameters = {0};
    LPSTR Usage = (KdcCert ? KERB_PKINIT_KDC_CERT_TYPE : KERB_PKINIT_CLIENT_CERT_TYPE);
    PCCERT_CHAIN_CONTEXT ChainContext = NULL;
    CERT_CHAIN_POLICY_STATUS PolicyStatus ={0};

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &Usage;

    *EmbeddedUPNOk = FALSE;


    if (!CertGetCertificateChain(
                          HCCE_LOCAL_MACHINE,
                          CertContext,
                          NULL,                 // evaluate at current time
                          NULL,                 // no additional stores
                          &ChainParameters,
                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                          NULL,                 // reserved
                          &ChainContext
                          ))
    {
        D_DebugLog((DEB_WARN,"Failed to verify certificate chain: %0x%x\n",GetLastError()));
        KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
        goto Cleanup;

    }
    else
    {
        CERT_CHAIN_POLICY_PARA ChainPolicy;
        ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));

        ChainPolicy.cbSize = sizeof(ChainPolicy);

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize = sizeof(PolicyStatus);
        PolicyStatus.lChainIndex = -1;
        PolicyStatus.lElementIndex = -1;


        if (!CertVerifyCertificateChainPolicy(
                                        CERT_CHAIN_POLICY_NT_AUTH,
                                        ChainContext,
                                        &ChainPolicy,
                                        &PolicyStatus))
        {
           D_DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy failure: %0x%x\n", GetLastError()));
           KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
           goto Cleanup;
        }

        if(PolicyStatus.dwError == S_OK)
        {
            *EmbeddedUPNOk = TRUE;
        }
        else if(CERT_E_UNTRUSTEDCA == PolicyStatus.dwError)
        {
            // We can't use this cert for fast-mapping, but we can still
            // slow-map it.
            *EmbeddedUPNOk = FALSE;
        }
        else
        {
            D_DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy - Chain Status failure: %0x%x\n",PolicyStatus.dwError));
            KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
            goto Cleanup;
        }
    }

Cleanup:
    if (PolicyStatus.dwError != S_OK)
    {
       FILL_EXT_ERROR_EX(pExtendedError, PolicyStatus.dwError,FILENO,__LINE__);
       if (ARGUMENT_PRESENT(FinalChainStatus))
       {
           memcpy(
               FinalChainStatus,
               &PolicyStatus,
               sizeof(CERT_CHAIN_POLICY_STATUS)
               );
       }
    }

    if (ChainContext != NULL)
    {
        CertFreeCertificateChain(ChainContext);
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyClientCertName
//
//  Synopsis:   Verifies that the mapping of a client's cert name matches
//              the mapping of the client name from the AS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KdcVerifyClientCertName(
    IN  IKdbProvider        *pIKdbProvider,
    IN  IKerbRequest        *pIKerbRequest,
    IN  PCCERT_CONTEXT      ClientCert,
    IN  PKERB_INTERNAL_NAME pkinClientName,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    UNICODE_STRING      NameString = {0};
    PKERB_INTERNAL_NAME ClientName = NULL;
    KERBERR             KerbErr = KDC_ERR_NONE;
    IKerbPrincipal      *pIPrincTicket = NULL;

    //
    // Get the client name from the cert
    //
    if (STATUS_SUCCESS != KerbGetPrincipalNameFromCertificate(ClientCert, &NameString))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"Email name from certificate is %wZ\n",&NameString));

    KerbErr = KerbConvertStringToKdcName(
                &ClientName,
                &NameString
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    ClientName->NameType = KRB_NT_ENTERPRISE_PRINCIPAL;


    //
    // Now crack the name & see if it refers to us
    //

    KerbErr = pIKdbProvider->GetPrincipal(
                 KDC_KDB_GET_PRINC_CLIENT,
                 ClientName,
                 NULL,
                 pIKerbRequest,
                 &pIPrincTicket,
                 pExtendedError,
                 NULL
                 );


    //
    // If this is a referral, return an error and the true realm name
    // of the client
    //
    if (KerbErr == KDC_ERR_WRONG_REALM)
    {
        DebugLog((DEB_WARN,"Client tried to logon to account in another realm\n"));
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to lookup client name "));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    //
    // Verify the client cert matches the client
    //
    //
    // Compare the princ and realm names since the UserID is not visable
    //
    if (!KerbEqualKdcNames((PKERB_INTERNAL_NAME)pIPrincTicket->GetName(), pkinClientName))
    {
        DebugLog((DEB_ERROR,"Cert name doesn't match user name: %wZ\n",
            &NameString));
        KerbErr = KDC_ERR_CLIENT_NAME_MISMATCH;
        goto Cleanup;
    }

Cleanup:

    KerbFreeString( &NameString);
    KerbFreeKdcName( &ClientName );

    if (pIPrincTicket)
        pIPrincTicket->Release();

    return(KerbErr);


}


//+-------------------------------------------------------------------------
//
//  Function:   KdcConvertNameString
//
//  Synopsis:   Converts the cr-lf to , in a dn
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void
KdcConvertNameString(
    IN PUNICODE_STRING Name,
    IN WCHAR ReplacementChar
    )
{
    PWCHAR Comma1, Comma2;

    //
    // Scan through the name, converting "\r\n" to the replacement char.  This
    // should be done by the CertNameToStr APIs, but that won't happen for
    // a while.
    //

    Comma1 = Comma2 = Name->Buffer ;
    while ( *Comma2 )
    {
        *Comma1 = *Comma2 ;

        if ( *Comma2 == L'\r' )
        {
            if ( *(Comma2 + 1) == L'\n' )
            {
                *Comma1 = ReplacementChar;
                Comma2++ ;
            }
        }

        Comma1++;
        Comma2++;
    }

    *Comma1 = L'\0';

    Name->Length = (USHORT) wcslen( Name->Buffer ) * sizeof( WCHAR );
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyMappedClientCertIdentity
//
//  Synopsis:   Verifies that the mapping of a client's cert identity
//              the mapping of the client name from the AS request.  The
//              cert should be in the list of mapped ceritificates for this
//              user.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


#define ISSUER_HEADER       L"<I>"
#define CCH_ISSUER_HEADER   3
#define SUBJECT_HEADER      L"<S>"
#define CCH_SUBJECT_HEADER  3

KERBERR
KdcVerifyMappedClientCertIdentity(
    IN PCCERT_CONTEXT ClientCert,
    IN PKERB_INTERNAL_NAME  pkinClient,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_CLIENT_NAME_MISMATCH;
    //
    // Disable this code for now
    //
#ifdef notdef
    UNICODE_STRING CompoundName = {0};
    ULONG SubjectLength ;
    ULONG IssuerLength ;
    NTSTATUS Status ;
    PWCHAR Current ;
    KDC_PRINC_INFO TicketInfo = {0};
    DWORD dwNameToStrFlags = CERT_X500_NAME_STR |
                                   CERT_NAME_STR_NO_PLUS_FLAG |
                                   CERT_NAME_STR_CRLF_FLAG;


    //
    // Build the name of the form <i>issuer <s> subject
    //

    IssuerLength = CertNameToStr( ClientCert->dwCertEncodingType,
                                   &ClientCert->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );

    SubjectLength = CertNameToStr( ClientCert->dwCertEncodingType,
                            &ClientCert->pCertInfo->Subject,
                            dwNameToStrFlags,
                            NULL,
                            0 );

    if ( ( IssuerLength == 0 ) ||
         ( SubjectLength == 0 ) )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    CompoundName.MaximumLength = (USHORT) (SubjectLength + IssuerLength +
                                 CCH_ISSUER_HEADER + CCH_SUBJECT_HEADER) *
                                 sizeof( WCHAR ) ;

    CompoundName.Buffer = (LPWSTR) MIDL_user_allocate( CompoundName.MaximumLength );

    if ( CompoundName.Buffer == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    wcscpy( CompoundName.Buffer, ISSUER_HEADER );
    Current = CompoundName.Buffer + CCH_ISSUER_HEADER ;

    IssuerLength = CertNameToStr( ClientCert->dwCertEncodingType,
                               &ClientCert->pCertInfo->Issuer,
                               dwNameToStrFlags,
                               Current,
                               IssuerLength );

    Current += IssuerLength - 1 ;
    wcscpy( Current, SUBJECT_HEADER );
    Current += CCH_SUBJECT_HEADER ;

    SubjectLength = CertNameToStr( ClientCert->dwCertEncodingType,
                        &ClientCert->pCertInfo->Subject,
                        dwNameToStrFlags,
                        Current,
                        SubjectLength );

    KdcConvertNameString(
        &CompoundName,
        L','
        );

    //
    // Get ticket info for this name
    //

    KerbErr = KdbGetPrincipalInfo(
                &CompoundName,
                SAM_OPEN_BY_ALTERNATE_ID,
                NULL,                   // no kerb principal name
                NULL,
                &TicketInfo,
                NULL,                   // no handle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no user all
                NULL                    // no membership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to get ticket info for %wZ to verify certZ\n",
            &CompoundName));
        goto Cleanup;
    }

    if (TicketInfo.UserId != ClientTicketInfo->UserId)
    {
        D_DebugLog((DEB_ERROR,"Cert name doesn't match user name: %wZ, %wZ\n",
            &TicketInfo.AccountName, &ClientTicketInfo->AccountName));
        KerbErr = KRB_AP_ERR_BADMATCH;
        goto Cleanup;
    }


Cleanup:
    KerbFreeString(&CompoundName);
    FreeTicketInfo( &TicketInfo );
#endif
    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckForEtype
//
//  Synopsis:   Checks if a client supports a particular etype
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if it does, false if it doesn't
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    )
{
    PKERB_CRYPT_LIST List = CryptList;

    while (List != NULL)
    {
        if ((ULONG) List->value == Etype)
        {
            return(TRUE);
        }
        List=List->next;
    }

    return(FALSE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPkinitPreAuthData
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcCheckPkinitPreAuthData(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST           pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    NTSTATUS                    Status;
    KERBERR                     KerbErr                 = KDC_ERR_NONE;
    PCCERT_CONTEXT              pKdcCert                = NULL;
    LARGE_INTEGER               CurrentTime;
    PKERB_PA_PK_AS_REQ          pPkAsReq                = NULL;
    PKERB_PA_PK_AS_REQ2         pPkAsReq2               = NULL;
    PBYTE                       pbPackedAuthenticator    = NULL;
    ULONG                       cbPackedAuthenticator= NULL;
    PKERB_AUTH_PACKAGE          pAuthPack               = NULL;
    PKERB_PK_AUTHENTICATOR      pPkAuthenticator        = NULL;
    PKERB_CERTIFICATE           pUserCert               = NULL;
    PCCERT_CONTEXT              pCertContext            = NULL;
    PKERB_SIGNATURE             pSignature              = NULL;
    HCRYPTKEY                   hClientKey              = NULL;
    KERB_EXT_ERROR              ExtendedError           = {0};
    IKerbPrincipal              *pIPrincipalClient      = NULL;
    PKERB_INTERNAL_NAME         pkinClient              = NULL;
    UNICODE_STRING              ustrClientKdcName = {0};
    ULONG                       ulClientKdcNameType;
    UNICODE_STRING              ustrKdcKrbTgtName={0};
    LARGE_INTEGER               ClientTime;
    ULONG                       Nonce                   = 0L;
    PULONG                      pulEtypeArray           = NULL;
    ULONG                       cEtypes                 = 0;
    ULONG                       CommonEtype;
    IKerbCrypt                  *pIKerbCrypt            = NULL;
    PKERB_PA_DATA_LIST          pPackedPkAsRep          = NULL;
    KERB_SIGNED_REPLY_KEY_PACKAGE KeyPack               = {0};
    PBYTE                       pbPackedKeyPack         = NULL;
    ULONG                       cbPackedKeyPack;
    HCRYPTPROV                  hKdcProvider            = NULL;
    BOOL                        fFreeProvider           = FALSE;
    PBYTE                       pbSignedKeyPack         = NULL;
    ULONG                       cbSignedKeyPack;
    PBYTE                       pbPackedKey             = NULL;
    ULONG                       cbPackedKey             = 0;
    ULONG                       cbRequired              = 0;
    BOOLEAN                     fUsed3Des               = FALSE;
    CERT_CHAIN_POLICY_STATUS    FinalChainStatus        = {0};
    BOOLEAN                     fEmbeddedUPNOk          = FALSE;
    KERB_REPLY_KEY_PACKAGE      ReplyKey                = {0};

#define KERB_PK_MAX_SIGNATURE_SIZE 128
    BYTE                        rgbPkSignature[KERB_PK_MAX_SIGNATURE_SIZE];
    ULONG                       cbPkSignature           = KERB_PK_MAX_SIGNATURE_SIZE;
    CRYPT_ALGORITHM_IDENTIFIER  CryptAlg                = {0};
    PBYTE                       pbEncryptedKeyPack      = NULL;
    PKERB_CERTIFICATE_LIST      CertList                = NULL;
    PUNICODE_STRING             pustrClientRealm        = NULL;
    IKdbProvider                *pIKdbProvider          = NULL;


    //
    // Prepare the output variables
    //

    *ppOutPadata = NULL;
    ZeroMemory(
        pEncryptionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );

    //
    // If we don't do this preauth, return such
    //

    Status = KdcGetKdcCertificate(&pKdcCert);
    if (!NT_SUCCESS(Status))
    {
#ifdef TBD
       //
       // Log an event
       //
       KdbReportEventW(
           IEvent::ERROR_TYPE,
           KDCEVENT_NO_KDC_CERTIFICATE,
           0,
           NULL,
           0
           );
#endif
       FILL_EXT_ERROR_EX(&ExtendedError, STATUS_PKINIT_FAILURE, FILENO, __LINE__);
       return(KDC_ERR_PADATA_TYPE_NOSUPP);
    }


    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime );

    //
    // First, unpack the outer KRB-PA-PK-AS-REQ
    //


    KerbErr = KerbUnpackData(
                pPreAuthData->value.preauth_data.value,
                pPreAuthData->value.preauth_data.length,
                KERB_PA_PK_AS_REQ_PDU,
                (PVOID *) &pPkAsReq
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Try the older variation
        //

        KerbErr = KerbUnpackData(
                    pPreAuthData->value.preauth_data.value,
                    pPreAuthData->value.preauth_data.length,
                    KERB_PA_PK_AS_REQ2_PDU,
                    (PVOID *) &pPkAsReq2
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to unpack PA-PK-AS-REQ(2): 0x%x\n",KerbErr));
            goto Cleanup;
        }
    }

    if (pPkAsReq != NULL)
    {
        //
        // Verify the signature
        //

        Status = ScHelperVerifyPkcsMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pPkAsReq->signed_auth_pack.value,
                    pPkAsReq->signed_auth_pack.length,
                    pbPackedAuthenticator,
                    &cbPackedAuthenticator,
                    NULL        // don't return certificate context
                    );

        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        pbPackedAuthenticator = (PBYTE) MIDL_user_allocate(cbPackedAuthenticator);
        if (pbPackedAuthenticator == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Status = ScHelperVerifyPkcsMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pPkAsReq->signed_auth_pack.value,
                    pPkAsReq->signed_auth_pack.length,
                    pbPackedAuthenticator,
                    &cbPackedAuthenticator,
                    &pCertContext
                    );
        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Unpack the auth package
        //

        KerbErr = KerbUnpackData(
                    pbPackedAuthenticator,
                    cbPackedAuthenticator,
                    KERB_AUTH_PACKAGE_PDU,
                    (PVOID *)&pAuthPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        pPkAuthenticator = &pAuthPack->pk_authenticator;

    }
    else
    {
        DsysAssert(pPkAsReq2 != NULL);
        if (!pPkAsReq2)
        {
            // TODO: Put more appropriate error code
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        //
        // Get the user certificate & verify
        //

        if ((pPkAsReq2->bit_mask & user_certs_present) == 0)
        {
            DebugLog((DEB_ERROR,"Client tried to use pkinit w/o client cert\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Just use the first of the certificates
        //

        pUserCert = &pPkAsReq2->user_certs->value;

        //
        // We only handle x509 certificates
        //

        if (pUserCert->cert_type != KERB_CERTIFICATE_TYPE_X509)
        {
            DebugLog((DEB_ERROR,"User supplied bad cert type: %d\n",pUserCert->cert_type));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Decode the certificate.
        //

        pCertContext = CertCreateCertificateContext(
                        X509_ASN_ENCODING,
                        pUserCert->cert_data.value,
                        pUserCert->cert_data.length
                        );
        if (pCertContext == NULL)
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR,"Failed to create certificate context: 0x%x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }



        //
        // Verify the authenticator
        //

        pSignature = &pPkAsReq2->signed_auth_pack.auth_package_signature;

        //
        // Now import the key from the certificate
        //

        if (!CryptImportPublicKeyInfo(
                g_hCryptClientProvider,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &pCertContext->pCertInfo->SubjectPublicKeyInfo,
                &hClientKey
                ))
        {
            DebugLog((DEB_ERROR,"Failed to import public key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(&ExtendedError, GetLastError(), FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Encode the data to be verified
        //

        KerbErr = KerbPackData(
                    &pPkAsReq2->signed_auth_pack.auth_package,
                    KERB_AUTH_PACKAGE_PDU,
                    &cbPackedAuthenticator,
                    &pbPackedAuthenticator
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Verify the signature on the message
        //

        if (!KerbCompareObjectIds(
                pSignature->signature_algorithm.algorithm,
                g_KdcSignatureAlg
                ))
        {
            DebugLog((DEB_ERROR,"Unsupported signature algorithm (not MD5)\n"));
            KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
            goto Cleanup;
        }

        Status = ScHelperVerifyMessage(
                    NULL,                           // no logon info
                    g_hCryptClientProvider,
                    pCertContext,
                    KERB_PKINIT_SIGNATURE_ALG,
                    pbPackedAuthenticator,
                    cbPackedAuthenticator,
                    pSignature->pkcs_signature.value,
                    pSignature->pkcs_signature.length / 8            // because it is a bit string
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to verify message: 0x%x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KDC_ERR_INVALID_SIG;
            goto Cleanup;
        }

        //
        // Now check the information in the authenticator itself.
        //

        pPkAuthenticator = &pPkAsReq2->signed_auth_pack.auth_package.pk_authenticator;

    }

    //
    // Call a helper routine to verify the certificate. It will check
    // CRLs, CTLs,
    //

    KerbErr = KdcCheckCertificate(
                pCertContext,
                &fEmbeddedUPNOk,
                &ExtendedError,
                &FinalChainStatus,
                FALSE // not a kdc certificate
                );

    //
    // Assume B3 certs aren't being used
    // anymore
    //
    /*if(!KERB_SUCCESS(KerbErr))
    {
        KerbErr = KdcCheckB3Certificate(
                    CertContext,
                    &EmbeddedUPNOk
                    );
    } */

    //
    //  get the client principal. This is only for AS request
    //
    assert( pIKerbRequest->GetServId() == KerbAs );
    pIPrincipalClient = pIKerbRequest->GetIPrincClient();
    if ( NULL == pIPrincipalClient )
    {
        KerbErr = KRB_ERR_GENERIC;
        DebugLog((DEB_ERROR,"Failed to get CLIENT Principal : 0x%x\n",KerbErr));
        goto Cleanup;
    }

    pkinClient = (const PKERB_INTERNAL_NAME)pIPrincipalClient->GetName();
    if ( NULL == pkinClient )
    {
        KerbErr = KRB_ERR_GENERIC;
        DebugLog((DEB_ERROR,"Failed to get Client principal name: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Dumb this down for release?  FESTER
        //
        if ((KDCInfoLevel & DEB_T_PKI) != 0)
        {
            UNICODE_STRING UTmp = {0};
            LPWSTR Tmp = NULL;

            KerbConvertKdcNameToString(&UTmp, pkinClient, NULL);
            if (UTmp.Buffer != NULL)
                Tmp = KerbBuildNullTerminatedString(&UTmp);

            if (Tmp != NULL)
            {
#ifdef TBD
                KdbReportEventW(
                    IEvent::WARNING_TYPE,
                    KDCEVENT_INVALID_CLIENT_CERTIFICATE,
                    sizeof(FinalChainStatus) - sizeof(void*),  // don't need ptr.
                    &FinalChainStatus,
                    1,
                    Tmp
                    );
#endif
                MIDL_user_free(Tmp);
            }
            KerbFreeString(&UTmp);
        }

        DebugLog((DEB_ERROR,"Failed to check CLIENT certificate: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Verify the cert is for the right client
    //
    pustrClientRealm = (const PUNICODE_STRING)pIPrincipalClient->GetRealm();
    if ( !pustrClientRealm )
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to locate handle for referral realm",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KDC_ERR_WRONG_REALM;
        goto Cleanup;
    }
    pIKdbProvider = KdcGetProvider(pustrClientRealm);

    if(fEmbeddedUPNOk)
    {
        KerbErr = KdcVerifyClientCertName(
                    pIKdbProvider,
                    pIKerbRequest,
                    pCertContext,
                    pkinClient,
                    pExtendedError
                    );
    }
    else
    {
        KerbErr = KdcVerifyMappedClientCertIdentity(
                    pCertContext,
                    pkinClient,
                    &ExtendedError
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KDC failed to verify client's identity from cert\n"));
        goto Cleanup;
    }

#ifdef later
    //
    // BUG 455112: this code breaks MIT KDCs, which can't handle a strange
    // x.500 name in the transited field. So, for NT5, disable the code
    //

    //
    // Put the issuer name in as a transited realm, as it is invovled in
    // the authentication decision.
    //

    TransitedLength = CertNameToStr( CertContext->dwCertEncodingType,
                                   &CertContext->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );


    if ( TransitedLength == 0 )
    {
        D_DebugLog((DEB_ERROR,"Failed to get issuer name: 0x%x\n",GetLastError()));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    TransitedRealm->MaximumLength = (USHORT) TransitedLength * sizeof(WCHAR) + sizeof(WCHAR);
    TransitedRealm->Length = (USHORT) TransitedLength * sizeof(WCHAR);
    TransitedRealm->Buffer = (LPWSTR) MIDL_user_allocate( TransitedRealm->MaximumLength );

    if ( TransitedRealm->Buffer == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    TransitedLength = CertNameToStr( CertContext->dwCertEncodingType,
                               &CertContext->pCertInfo->Issuer,
                               dwNameToStrFlags,
                               TransitedRealm->Buffer,
                               TransitedLength );

    if ( TransitedLength == 0 )
    {
        D_DebugLog((DEB_ERROR,"Failed to get issuer name: 0x%x\n",GetLastError()));
        FILL_EXT_ERROR(&ExtendedError, GetLastError(), FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Convert the "." to "/"
    //


    KdcConvertNameString(
        TransitedRealm,
        L'/'
        );

#endif // later

    KerbErr = KerbConvertPrincipalNameToString(
                &ustrClientKdcName,
                &ulClientKdcNameType,
                &pPkAuthenticator->kdc_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Verify the realm name is correct
    //
    if (!KerbCompareUnicodeRealmNames(
            pustrClientRealm,
            &ustrClientKdcName
            ))

    {
        DebugLog((DEB_ERROR,"Client used wrong realm in PK authenticator: %s\n",
            pPkAuthenticator->kdc_realm
            ));

        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;

    }


    KerbErr = KerbBuildFullServiceName(
                pustrClientRealm,
                &KrbtgtName,
                &ustrKdcKrbTgtName);
    if (!KERB_SUCCESS(KerbErr))
    {
        //TBD:log ?
        goto Cleanup;
    }
    if (!RtlEqualUnicodeString(
            &ustrKdcKrbTgtName,
            &ustrClientKdcName,
            TRUE))
    {
        DebugLog((DEB_ERROR,"Client provided KDC name is wrong: %wZ\n",
                  &ustrClientKdcName));

        KerbErr = KDC_ERR_KDC_NAME_MISMATCH;
        goto Cleanup;
    }

    //
    // Now verify the time
    //

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientTime,
        &pPkAuthenticator->client_time,
        pPkAuthenticator->cusec
        );

    if (!KerbCheckTimeSkew(
            &CurrentTime,
            &ClientTime,
            &pIKdbProvider->GetKdcPolicy()->TimeSkew))
    {
        KerbErr = KRB_AP_ERR_SKEW;
        goto Cleanup;
    }

    Nonce = pPkAuthenticator->nonce;

    //
    // Generate a temporary key. First find a good encryption type
    //
    KerbErr = KerbConvertCryptListToArray(
                &pulEtypeArray,
                &cEtypes,
                pIKerbRequest->GetEncryptionTypes()
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    Status = CDFindCommonCSystem(
                cEtypes,
                pulEtypeArray,
                &CommonEtype
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    //
    //  get to the IKerbCrypt
    //
    pIKerbCrypt = KdcGetICrypt();

    assert(pIKerbCrypt);
    assert(pEncryptionKey);
    KerbErr = pIKerbCrypt->MakeKey(
                CommonEtype,
                &pEncryptionKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Build the return structure
    //

    pPackedPkAsRep = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (pPackedPkAsRep == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    ZeroMemory(
        pPackedPkAsRep,
        sizeof(KERB_PA_DATA_LIST)
        );

    pPackedPkAsRep->next = NULL;
    pPackedPkAsRep->value.preauth_data_type = KRB5_PADATA_PK_AS_REP;

    //
    // Success. Now build the reply
    //

    if (pPkAsReq2 != NULL)
    {
        KERB_PA_PK_AS_REP2 Reply = {0};

        //
        // Create the reply key package
        //

        //
        // Create the reply key package, which contains the key used to encrypt
        // the AS_REPLY.
        //

        KeyPack.reply_key_package.nonce = Nonce;
        KeyPack.reply_key_package.reply_key = *pEncryptionKey;

        KerbErr = KerbPackData(
                    &KeyPack.reply_key_package,
                    KERB_REPLY_KEY_PACKAGE2_PDU,
                    &cbPackedKeyPack,
                    &pbPackedKeyPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Acquire a crypt context for the private key of the certificate
        //

        if (!CryptAcquireCertificatePrivateKey(
                    pKdcCert,
                    0,              // no flags
                    NULL,           // reserved
                    &hKdcProvider,
                    NULL,           // no key spec
                    &fFreeProvider
                    ))
        {
            DebugLog((DEB_ERROR,"Failed to acquire KDC certificate private key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(&ExtendedError, GetLastError(), FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now, to sign the reply key package
        //

        Status = ScHelperSignMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    hKdcProvider,
                    KERB_PKINIT_SIGNATURE_ALG,
                    pbPackedKeyPack,
                    cbPackedKeyPack,
                    rgbPkSignature,
                    &cbPkSignature
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to sign keypack: 0x%x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Copy the temporary signature into the return structure
        //

        KeyPack.reply_key_signature.pkcs_signature.length = cbPkSignature * 8;  // because it is a bit string
        KeyPack.reply_key_signature.pkcs_signature.value = rgbPkSignature;
        KeyPack.reply_key_signature.signature_algorithm.algorithm = g_KdcSignatureAlg;

        //
        // Now marshall the signed key package
        //

        KerbErr = KerbPackData(
                    &KeyPack,
                    KERB_SIGNED_REPLY_KEY_PACKAGE_PDU,
                    &cbSignedKeyPack,
                    &pbSignedKeyPack
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Just encrypt the key package
        //

        pbPackedKey = pbSignedKeyPack;
        cbPackedKey = cbSignedKeyPack;

        //
        // Zero these out so we don't free them twice
        //

        pbSignedKeyPack = NULL;
        cbSignedKeyPack = 0;


        //
        // Compute the size of the encrypted temp key
        //
        //


ChangeCryptAlg2:

        if (g_fKdc3DesSupported && KdcCheckForEtype(pIKerbRequest->GetEncryptionTypes(), KERB_PKINIT_SEAL_ETYPE))
        {
            fUsed3Des = TRUE;
            CryptAlg.pszObjId = KERB_PKINIT_SEAL_OID;
        }
        else
        {
            CryptAlg.pszObjId = KERB_PKINIT_EXPORT_SEAL_OID;
            if (!KdcCheckForEtype(pIKerbRequest->GetEncryptionTypes(), KERB_PKINIT_EXPORT_SEAL_ETYPE))
            {
                DebugLog((DEB_WARN,"Client doesn't claim to support exportable pkinit encryption type %d\n",
                    KERB_PKINIT_EXPORT_SEAL_ETYPE));
            }
        }

        cbRequired = 0;
        Status = ScHelperEncryptMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pCertContext,
                    &CryptAlg,
                    pbPackedKey,
                    cbPackedKey,
                    NULL,
                    (PULONG) &cbRequired
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            //
            // 3des is only supported on domestic builds with the
            // strong cryptography pack installed.
            //

            if ((Status == NTE_BAD_ALGID) && (fUsed3Des))
            {
                g_fKdc3DesSupported = FALSE;
                goto ChangeCryptAlg2;
            }
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }


        //
        // Allocate the output size
        //

        pbEncryptedKeyPack  = (PBYTE) MIDL_user_allocate(cbRequired);
        if (pbEncryptedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Really do the encryption
        //


        Status = ScHelperEncryptMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pCertContext,
                    &CryptAlg,
                    pbPackedKey,
                    cbPackedKey,
                    pbEncryptedKeyPack,
                    &cbRequired
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Create the cert list for the reply
        //

        KerbErr = KerbCreateCertificateList(
                    &CertList,
                    pKdcCert
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        //
        // We will be returning the KDC cert as well as a package containing
        // a temporary key
        //

        Reply.bit_mask |= KERB_PA_PK_AS_REP2_kdc_cert_present;


        //
        // Now, to finish the reply, we need a handle to the KDCs certificate
        //

        Reply.kdc_cert = (KERB_PA_PK_AS_REP2_kdc_cert) CertList;

        Reply.temp_key_package.choice = pkinit_enveloped_data_chosen;
        Reply.temp_key_package.u.pkinit_enveloped_data.length = (int) cbRequired;
        Reply.temp_key_package.u.pkinit_enveloped_data.value = pbEncryptedKeyPack;

        KerbErr = KerbPackData(
                    &Reply,
                    KERB_PA_PK_AS_REP2_PDU,
                    (PULONG) &pPackedPkAsRep->value.preauth_data.length,
                    &pPackedPkAsRep->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        KERB_PA_PK_AS_REP Reply = {0};

        //
        // Create the reply key package
        //

        //
        // Create the reply key package, which contains the key used to encrypt
        // the AS_REPLY.
        //

        ReplyKey.nonce = Nonce;
        ReplyKey.reply_key = *pEncryptionKey;

        KerbErr = KerbPackData(
                    &ReplyKey,
                    KERB_REPLY_KEY_PACKAGE_PDU,
                    &cbPackedKeyPack,
                    &pbPackedKeyPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Acquire a crypt context for the private key of the certificate
        //

        if (!CryptAcquireCertificatePrivateKey(
                    pKdcCert,
                    0,              // no flags
                    NULL,           // reserved
                    &hKdcProvider,
                    NULL,           // no key spec
                    &fFreeProvider
                    ))
        {
            DebugLog((DEB_ERROR,"Failed to acquire KDC certificate private key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now, to sign the reply key package
        //

        CryptAlg.pszObjId = KERB_PKINIT_SIGNATURE_OID;

        Status = ScHelperSignPkcsMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    hKdcProvider,
                    pKdcCert,
                    &CryptAlg,
                    CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                    pbPackedKeyPack,
                    cbPackedKeyPack,
                    pbSignedKeyPack,
                    &cbSignedKeyPack
                    );



        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        pbSignedKeyPack = (PBYTE) MIDL_user_allocate(cbSignedKeyPack);
        if (pbSignedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Status = ScHelperSignPkcsMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    hKdcProvider,
                    pKdcCert,
                    &CryptAlg,
                    CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                    pbPackedKeyPack,
                    cbPackedKeyPack,
                    pbSignedKeyPack,
                    &cbSignedKeyPack
                    );

        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to sign pkcs message: 0x%x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now encrypt the content
        //

        //
        // Compute the size of the encrypted temp key
        //
        //


ChangeCryptAlg:
        if (g_fKdc3DesSupported && KdcCheckForEtype(pIKerbRequest->GetEncryptionTypes(), KERB_PKINIT_SEAL_ETYPE))
        {
            fUsed3Des = TRUE;
            CryptAlg.pszObjId = KERB_PKINIT_SEAL_OID;
        }
        else
        {
            CryptAlg.pszObjId = KERB_PKINIT_EXPORT_SEAL_OID;
            if (!KdcCheckForEtype(pIKerbRequest->GetEncryptionTypes(), KERB_PKINIT_EXPORT_SEAL_ETYPE))
            {
                DebugLog((DEB_WARN,"Client doesn't claim to support exportable pkinit encryption type %d\n",
                    KERB_PKINIT_EXPORT_SEAL_ETYPE));
            }
        }

        cbRequired = 0;
        Status = ScHelperEncryptMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pCertContext,
                    &CryptAlg,
                    pbSignedKeyPack,
                    cbSignedKeyPack,
                    NULL,
                    (PULONG) &cbRequired
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            //
            // 3des is only supported on domestic builds with the
            // strong cryptography pack installed.
            //

            if ((Status == NTE_BAD_ALGID) && (fUsed3Des))
            {
                g_fKdc3DesSupported = FALSE;
                goto ChangeCryptAlg;
            }

            DebugLog((DEB_ERROR,"Failed to encrypt message (crypto mismatch?): %x\n",Status));
            FILL_EXT_ERROR_EX(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }


        //
        // Allocate the output size
        //

        pbEncryptedKeyPack  = (PBYTE) MIDL_user_allocate(cbRequired);
        if (pbEncryptedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Really do the encryption
        //


        Status = ScHelperEncryptMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pCertContext,
                    &CryptAlg,
                    pbSignedKeyPack,
                    cbSignedKeyPack,
                    pbEncryptedKeyPack,
                    &cbRequired
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        Reply.u.key_package.value = pbEncryptedKeyPack;
        Reply.u.key_package.length = cbRequired;
        Reply.choice = pkinit_enveloped_data_chosen;

        KerbErr = KerbPackData(
                    &Reply,
                    KERB_PA_PK_AS_REP_PDU,
                    (PULONG) &pPackedPkAsRep->value.preauth_data.length,
                    &pPackedPkAsRep->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }

#ifdef TBD
    if (Nonce != 0)
        pIKerbRequest->SetNonce(Nonce);
        ClientRequest->nonce = Nonce;
#endif

    *ppOutPadata = pPackedPkAsRep;
    pPackedPkAsRep = NULL;

Cleanup:

    if (fFreeProvider)
    {
        CryptReleaseContext(
            hKdcProvider,
            0
            );
    }
    if (pPkAsReq != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REQ_PDU,
            pPkAsReq
            );
    }
    if (pPkAsReq2 != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REQ2_PDU,
            pPkAsReq2
            );
    }
    if (pbSignedKeyPack != NULL)
    {
        KdcFreeEncodedData(pbSignedKeyPack);
    }
    if (pbPackedKeyPack != NULL)
    {
        KdcFreeEncodedData(pbPackedKeyPack);
    }
    if (pbPackedAuthenticator != NULL)
    {
        KdcFreeEncodedData(pbPackedAuthenticator);
    }
    if (hClientKey != NULL)
    {
        CryptDestroyKey(hClientKey);
    }
    if (pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }
    if(pKdcCert)
    {
        CertFreeCertificateContext(pKdcCert);
    }
    if (pbEncryptedKeyPack != NULL)
    {
        MIDL_user_free(pbEncryptedKeyPack);
    }
    if (pulEtypeArray != NULL)
    {
        MIDL_user_free(pulEtypeArray);
    }
    KerbFreeCertificateList(
        CertList
        );
    if (pbPackedKey != NULL)
    {
        MIDL_user_free(pbPackedKey);
    }
    if (pPackedPkAsRep != NULL)
    {
        if (pPackedPkAsRep->value.preauth_data.value != NULL)
        {
            MIDL_user_free(pPackedPkAsRep->value.preauth_data.value);
        }
        MIDL_user_free(pPackedPkAsRep);
    }

    KerbFreeString(&ustrKdcKrbTgtName);
    KerbFreeString(&ustrClientKdcName);

    if (pIPrincipalClient)
        pIPrincipalClient->Release();

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetKdcCertificate
//
//  Synopsis:   Retrieves a copy of the KDC cert
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcGetKdcCertificate(
    PCCERT_CONTEXT *KdcCert
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(!KdcGlobalCertCritSectInitialized)
    {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
    EnterCriticalSection(&KdcGlobalCertCritSect);


    if (GlobalKdcCert == NULL)
    {
        DebugLog((DEB_WARN,"Unable to find KDC certificate in KDC store\n"));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

    // Increment the ref count, so if we change certs while the caller of this
    // is still using this cert, we won't delete it out from under.

    *KdcCert = CertDuplicateCertificateContext(GlobalKdcCert);
    if(*KdcCert == NULL)
    {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

Cleanup:


    LeaveCriticalSection(&KdcGlobalCertCritSect);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\pkserv.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pkserv.h
//
// Contents:    types and prototypes for pk authentication
//
//
// History:     1-Dec-1997      MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __PKSERV_H__
#define __PKSERV_H__


KERBERR
KdcCheckPkinitPreAuthData(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST           pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT PKERB_EXT_ERROR pExtendedError      
	);

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    );

#endif // __PKSERV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\paid.cxx ===
//+-----------------------------------------------------------------------
//
// File:        paid.cxx
//
// Contents:    PA IDentities handler
//
//
// History:     3-Sept-2001   yordanr   Created.
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <malloc.h>


#include <krb5.h>
#include <krb5p.h>
#include <kerberr.h>

//  the new interface
#include <kerbinterface.h>
#include <padata.hxx>

//
//  interface implementation of IPAHandler for PA-Identity
//
class CPAIdentityHandler : public IPAHandler, public IPAIdentity
{
//  prealloc a number of ids
public:
    CPAIdentityHandler() :
        m_cKeys(0),
        m_pKeys(NULL),
        m_pXboxId(NULL)
    {
    }

    ~CPAIdentityHandler()
    {
        if (m_pKeys)
        {
            while(m_cKeys--)
            {
                KdcFreeMemory(m_pKeys[m_cKeys].keyvalue.value);
            }
            KdcFreeMemory(m_pKeys);
        }
        if (m_pXboxId) 
        {
            KdcFreeMemory(m_pXboxId);
        }
    }

    void __stdcall Release(void)
    {
        delete  this;
    };

    //
    // Implement IPAHandler
    //
    virtual ULONG GetPAType()
    {
        return  KRB5_PADATA_COMPOUND_IDENTITY ;
    }

    //
    // We support the IPAIdentity interface
    //
    virtual HRESULT __stdcall QueryInterface(
        REFIID intf,
        PVOID *ppv
        )
    {
        if (IsEqualIID(intf, IID_IPAIdentity))
        {
            *ppv = (PVOID)(IPAIdentity*)this;
            return  S_OK;
        }
        return  E_NOINTERFACE;
    }

    virtual KERBERR __stdcall Check(
        IN  IKerbRequest               *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST         *ppOutPadata,
        OUT BOOLEAN                    *pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
        );

    virtual NTSTATUS __stdcall GetCompoundIdentity(
        OUT const COMPOUND_IDENTITY  **ppCompId
        )
    {
        *ppCompId = NULL;
        return  STATUS_NOT_IMPLEMENTED;
    }

    virtual NTSTATUS __stdcall GetXboxIdentity(
        OUT const XBOX_IDENTITY      **ppXboxId
        )
    {
        *ppXboxId = m_pXboxId;
        return  STATUS_SUCCESS;
    }

    //  return number of logon info structs present in compound identity
    virtual ULONG __stdcall GetNumLogonInfos()
    {
        return 0;
    }

    virtual NTSTATUS __stdcall GetTgtKeys(
        OUT PULONG                      pcKeys,
        OUT const KERB_ENCRYPTION_KEY **pKeys
        )
    {
        if (m_pKeys == 0)
        {
            return  STATUS_NOT_FOUND;
        }
        *pcKeys = m_cKeys;
        *pKeys = m_pKeys;

        return  STATUS_SUCCESS;
    }

private:

    PXBOX_IDENTITY          m_pXboxId;   //  compacted identity
    ULONG                   m_cKeys;     //  stored session keys
    PKERB_ENCRYPTION_KEY    m_pKeys;

    //  private APIs

    //  add an identity from XBOX_IDENTITY
    NTSTATUS AddXboxIdentity(PXBOX_IDENTITY pXboxIdentity);

    //  Build the identity
    KERBERR CheckCredsAndGetAuthData(
        PKERB_TICKET              pTicket,
        ULONG                     iTicket,
        IKerbRequest             *piReq,
        PKERB_EXT_ERROR pExtendedError
        );
};


//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::Check
//
//  Synopsis:   Extracts the krb_cred msg, decrypts and unpacks it after which
//              Identities are extracted from the PAC and stored for further use.
//              Verification is performed to ensure the cred msg is legit by
//              comparing the keys in the msg to the keys in the tickets.
//
//  Effects:
//
//  Arguments:  pIKerbRequest
//              pPreAuthData
//              pEncryptionKey
//              ppOutPadata
//              pbSufficient
//              pStatus
//
//              See IPAHandler::Check documentation for parameter descriptions
//
//  Requires:
//
//  Returns:    KDC_ERR_GENERIC        - pStatus contains the reason for failure
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CPAIdentityHandler::Check(
    IN  IKerbRequest                *pIKerbRequest,
    IN  PKERB_PA_DATA_LIST           pPreAuthData,
    OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
    OUT PKERB_PA_DATA_LIST          *ppOutPadata,
    OUT BOOLEAN                     *pbSufficient,
    OUT PKERB_EXT_ERROR              pExtendedError
    )
{
    KERBERR                     KerbErr = KDC_ERR_NONE;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PKERB_PA_COMPOUND_IDENTITY  pPaTemp = NULL;
    PKERB_PA_COMPOUND_IDENTITY *pPaCompId = NULL;
    ULONG                       iTicket;

    *pbSufficient = FALSE;

    if ( pPreAuthData->value.preauth_data_type != KRB5_PADATA_COMPOUND_IDENTITY)
    {
        //
        // Called with wrong PA
        //

        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    //  decrypt the preauth
    //  KerbUnpack is exported by the core, but what is the free function
    //

    KerbErr = KerbUnpackData(
        pPreAuthData->value.preauth_data.value,
        pPreAuthData->value.preauth_data.length,
        KERB_PA_COMPOUND_IDENTITY_PDU,
        (PVOID*)&pPaCompId
        );
    if ( !KERB_SUCCESS( KerbErr ) )
    {
        goto Cleanup;
    }


    //
    // count the tickets
    //

    pPaTemp = *pPaCompId;
    for (iTicket = 0; pPaTemp != NULL; iTicket++, pPaTemp = pPaTemp->next);

    if (m_pKeys)
    {
        KdcFreeMemory(m_pKeys);
        m_pKeys = NULL;
    }

    //
    //  alloc space for the keys
    // 

    m_pKeys = (PKERB_ENCRYPTION_KEY)KdcAllocMemory(iTicket * sizeof(KERB_ENCRYPTION_KEY));
    if (m_pKeys == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto    Cleanup;
    }
    m_cKeys = iTicket;
    memset(m_pKeys, 0, iTicket * sizeof(KERB_ENCRYPTION_KEY));

    //
    // Free existing structures
    // 

    if (m_pXboxId) 
    {
        KdcFreeMemory(m_pXboxId);
    }

    //
    // Alloc the Xbox Identity
    // 

    m_pXboxId = (PXBOX_IDENTITY)KdcAllocMemory( sizeof(XBOX_IDENTITY) );
    if (m_pXboxId == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the fields to empty
    // 

    memset( m_pXboxId, 0, sizeof(XBOX_IDENTITY) );

    //
    // check tickets and auth data
    //

    for (pPaTemp = *pPaCompId, iTicket = 0;
         pPaTemp != NULL;
         pPaTemp = pPaTemp->next, iTicket++)
    {
        KerbErr = CheckCredsAndGetAuthData(
            &pPaTemp->value,
            iTicket,
            pIKerbRequest,
            pExtendedError
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }

Cleanup:

    D_DebugLog((
        DEB_TRACE,
        "PAIdentity::Check returning 0x%lx Status=0x%lx\n",
        KerbErr,
        Status
        ));

    if (pPaCompId)
    {
        KerbFreeData(KERB_PA_COMPOUND_IDENTITY_PDU, pPaCompId);
    }

    pExtendedError->status = Status;

    return  KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::CheckCredsAndGetAuthData
//
//  Synopsis:   Checks the ticket against the cred and if there's a match
//              fills in the auth data at the index passed in
//
//  Effects:
//
//  Arguments:  pTicket     - TGT containing identities
//              iCred       - ticket index
//              piReq       - request in the context of which the operation
//                            takes place
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE if happy
//              KDC_ERR_GENERIC     - out of memory or some other generic error
//              KDC_ERR_PREAUTH_FAILED
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
CPAIdentityHandler::CheckCredsAndGetAuthData(
    IN  PKERB_TICKET              pTicket,
    IN  ULONG                     iTicket,
    IN  IKerbRequest             *piReq,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR                 KerbErr     = KDC_ERR_NONE;
    IADHandler             *piAuthData  = NULL;
    IADPacSection          *iPacSect    = NULL;
    IKdbProvider           *iProv       = NULL;
    IKerbPrincipal         *piPrinc     = NULL;
    NTSTATUS                Status      = STATUS_SUCCESS;
    const PAC_INFO_BUFFER  *pPacBuf     = NULL;
    PKERB_ENCRYPTED_TICKET  pEncTicket  = NULL;
    PKERB_INTERNAL_NAME     pServerName = NULL;
    UNICODE_STRING          ustrRealm   = {0};


    KerbErr = KerbConvertRealmToUnicodeString(
        &ustrRealm,
        &pTicket->realm
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Get server principal to decrypt the ticket
    //

    iProv = KdcGetProvider(&ustrRealm);
    if (iProv == NULL)
    {
        //
        // No realm for this ticket
        //
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
        &pServerName,
        &pTicket->server_name
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = iProv->GetPrincipal(
        KDC_KDB_GET_PRINC_SERVER,
        pServerName,
        ustrRealm.Buffer,
        piReq,
        &piPrinc,
        pExtendedError,
        NULL
        );
    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    //  Decrypt the ticket with the principal's key
    //
    //  Note that the implicit assumption is that the
    //  ticket is encrypted with the same etype as the request
    //

    Status = piPrinc->Decrypt(
        piReq->GetEncryptionTypes(),
        KERB_TICKET_SALT,
        &pTicket->encrypted_part,
        pTicket->encrypted_part.cipher_text.value,
        &pTicket->encrypted_part.cipher_text.length,
        NULL, // don't care what etype?
        pExtendedError
        );
    if ( !NT_SUCCESS( Status ) )
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    //
    //  unpack encrypted ticket
    //

    KerbErr = KerbUnpackData(
        pTicket->encrypted_part.cipher_text.value,
        pTicket->encrypted_part.cipher_text.length,
        KERB_ENCRYPTED_TICKET_PDU,
        (PVOID*)&pEncTicket
        );

    if ( !KERB_SUCCESS( KerbErr ) )
    {
        goto Cleanup;
    }

    //
    //  save the session key from the ticket
    //  need to copy the ticket value
    //

    m_pKeys[iTicket] = pEncTicket->key;
    m_pKeys[iTicket].keyvalue.value = (ASN1octet_t *)KdcAllocMemory(pEncTicket->key.keyvalue.length);
    if (m_pKeys[iTicket].keyvalue.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto    Cleanup;
    }
    memcpy(
        m_pKeys[iTicket].keyvalue.value,
        pEncTicket->key.keyvalue.value,
        pEncTicket->key.keyvalue.length
        );

    //
    // extract auth data from ticket
    //

    Status = KdcCreateADHandlerInstance(
        KERB_AUTH_DATA_PAC,
        &piAuthData
        );
    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Failed to create a handler???
        //

        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Check the auth Data
    //
    KerbErr = piAuthData->Check(
        piReq,
        piPrinc,
        pEncTicket->authorization_data,
        pExtendedError
        );
    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    // Checked out ok, now get the auth data
    //
    //
    // Query PUIDs PAC section
    //

    Status = piAuthData->QueryInterface(
        IID_IADPacSection,
        (PVOID*)&iPacSect
        );
    if ( !NT_SUCCESS( Status ))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // If we find a CLIENT_IDENTITY or COMPOUND_IDENTITY then this
    // this pre-auth is invalid
    // 

    Status = iPacSect->GetPacSection(
        PAC_CLIENT_IDENTITY,
        &pPacBuf
        );
    if (NT_SUCCESS( Status ) ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }
    Status = iPacSect->GetPacSection(
        PAC_COMPOUND_IDENTITY,
        &pPacBuf
        );
    if (NT_SUCCESS( Status ) ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    // We only care about XBOX_IDENTITY
    // 

    Status = iPacSect->GetPacSection(
        PAC_XBOX_IDENTITY,
        &pPacBuf
        );
    if ( NT_SUCCESS( Status ) ) 
    {
        //
        // PAC Buffer contains the XBOX_IDENTITY. Extract and save
        // it 'as-is'
        // 

        Status = AddXboxIdentity( (PXBOX_IDENTITY) pPacBuf->Data );
        if ( !NT_SUCCESS( Status) ) 
        {
            KerbErr = KDC_ERR_PREAUTH_FAILED;
        }

        //
        // Do not attempt to look at the other IDENTITY types
        // 

        goto Cleanup;
    }
    else if ( Status != STATUS_NOT_FOUND ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

Cleanup:

    if ( piAuthData )
    {
        piAuthData->Release();
    }
    if (piPrinc)
    {
        piPrinc->Release();
    }

    //
    // Free data allocated by asn1 decoding
    //

    KerbFreeData(KERB_ENCRYPTED_TICKET_PDU, pEncTicket);

    if (pServerName)
    {
        //  hmm... KdcFreeName is not part of the core.
        //  use KdcFreeMemory, but is it the same ...
        KerbFreeKdcName(&pServerName);
    }

    KdcFreeMemory( ustrRealm.Buffer );

    return  KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAHandlerIdentityFactory::CreateInstance
//
//  Synopsis:   Constructor-like function for creating a new object instance
//
//  Effects:
//
//  Arguments:  pIKerbRequest     - unused
//              ppIPAHandler      - used to return the new instance
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_NO_MEMORY if out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CPAHandlerIdentityFactory::CreateInstance(
    IN  IKerbRequest     *pIKerbRequest,
    OUT IPAHandler      **ppIPAHandler
    )
{
    *ppIPAHandler = new CPAIdentityHandler;

    if (*ppIPAHandler == NULL)
    {
        return  STATUS_NO_MEMORY;
    }

    return  STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::AddXboxIdentity
//
//  Synopsis:   Appends the identities in XboxIdentity to m_pXboxId
//
//  Effects:
//
//  Arguments:  pXboxId - compound identity to add
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_NO_MEMORY if out of memory
//              STATUS_INVALID_PARAMETER if unhappy
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CPAIdentityHandler::AddXboxIdentity(
    IN PXBOX_IDENTITY pXboxIdentity
    )
{
    if ( NULL == pXboxIdentity) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy over the fields one at a time, after they are
    // sanity checked
    // 

    if (pXboxIdentity->MachineIdentity != 0) 
    {
        m_pXboxId->MachineIdentity           = pXboxIdentity->MachineIdentity;
        m_pXboxId->MachineIdentityCredential = pXboxIdentity->MachineIdentityCredential;
    }

    for (DWORD i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
    {
        if (pXboxIdentity->UserIdentity[i] != 0) 
        {
            m_pXboxId->UserIdentity[i]           = pXboxIdentity->UserIdentity[i];
            m_pXboxId->UserIdentityCredential[i] = pXboxIdentity->UserIdentityCredential[i];
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\padata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       preauth.cxx
//
//  Contents:   KDC Internal Preauth types
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include <wininet.h>    // for SECURITY_FLAG_xxx
#include <sclogon.h>    // ScHelperXXX
//#include <certca.h>     // for CA*XXX

#define FILENO FILENO_PKSERV
#include "fileno.h"

#include "kerbinterface.h"
#include "kerbhelper.h"
#include "padata.hxx"
#include "pkserv.h"
//
//  global PA handler factories
//

CPAHandlerETypeFactory  PAf1;
CPAHandlerPwSaltFactory PAf2;
CPAHandlerEncryptedTimeFactory PAf3;
CPAHandlerPACReqExFactory PAf4;
CPAHandlerPkinitFactory PAf5;
CPAHandlerPkinitCompatFactory   PAf6;
CPAHandlerIdentityFactory   PAf7;

IPAHandlerFactory*   g_pIPAHandlerFactories[] = {&PAf1,
//                                                 &PAf2,
                                                 &PAf3,
                                                 &PAf4,
                                                 &PAf5,
                                                 &PAf6,
                                                 &PAf7};


//
//    Helper routine to register handlers
//

NTSTATUS
__stdcall
RegisterCorePAHandlerFactories(
    VOID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    int         i;


    for ( i = 0;
        i < sizeof(g_pIPAHandlerFactories)/sizeof(IPAHandlerFactory*);
        i++ )
    {
        Status = KdcRegisterPAHandlerFactory(g_pIPAHandlerFactories[i]);
        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }


    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildEtypeInfo
//
//  Synopsis:   Builds a list of supported etypes & salts
//
//  Effects:
//
//  Arguments:  TicketInfo - client's ticket info
//              OutputPreAuth - receives any preauth data to return to client
//
//  Requires:
//
//  Returns:    kerberr
//
//  Notes:
//
//
//--------------------------------------------------------------------------
CPAHandlerETypeInfo::CPAHandlerETypeInfo( )
{
}

CPAHandlerETypeInfo::~CPAHandlerETypeInfo( )
{
}

KERBERR
__stdcall
CPAHandlerETypeInfo::Get(
    IN  IKerbRequest        *pIKerbRequest,
    OUT PKERB_PA_DATA_LIST  *ppPADataList)
{
    KERBERR                 KerbErr             = KDC_ERR_NONE;
    IKerbPrincipal          *pIPrincipalClient  = NULL;
    PKERB_ETYPE_INFO        petypeinfo          = NULL;
    PKERB_CRYPT_LIST        pEtypes             = NULL;
    PKERB_PA_DATA_LIST      pPADataList         = NULL;

    *ppPADataList = NULL;

    pIPrincipalClient = pIKerbRequest->GetIPrincClient();
    if (NULL == pIPrincipalClient)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    pEtypes = pIKerbRequest->GetEncryptionTypes();
    if (NULL == pEtypes)
        goto Cleanup;

    KerbErr = pIPrincipalClient->GetEtypeMatch(
                    pEtypes,
                    &petypeinfo);


    if ( !KERB_SUCCESS(KerbErr) || NULL == petypeinfo )
    {
           KerbErr = KDC_ERR_ETYPE_NOTSUPP;
           DebugLog((DEB_ERROR,"There is no union between client and server Etypes!\n"));

        //
        //    TBD:
        //
#ifdef TBD
           KdcReportKeyError(
            KdbHandle,
            ClientInfo->Princ,
            ClientInfo->Realm,
            NULL,
            NULL,
            KDCEVENT_NO_KEY_UNION_AS,
            RequestBody->encryption_type,
            ClientInfo->Keys
            );
#endif
    }

    else
    {
       pPADataList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
       if (pPADataList == NULL)
       {
          KerbErr = KRB_ERR_GENERIC;
          goto Cleanup;
       }

       ZeroMemory(
          pPADataList,
          sizeof(KERB_PA_DATA_LIST)
          );

       pPADataList->value.preauth_data_type = KRB5_PADATA_ETYPE_INFO;

       KerbErr = KerbPackData(
          &petypeinfo,
          PKERB_ETYPE_INFO_PDU,
          (PULONG) &pPADataList->value.preauth_data.length,
          &pPADataList->value.preauth_data.value
          );

       if (!KERB_SUCCESS(KerbErr))
       {
          goto Cleanup;
       }

       // Link to other PA-DATA if present
       pPADataList->next = *ppPADataList;
       *ppPADataList = pPADataList;
       pPADataList = NULL;       // So it doesn't get freed in cleanup
    }


Cleanup:
    while (petypeinfo != NULL)
    {
        PKERB_ETYPE_INFO petypeinfoNextEntry = petypeinfo->next;
        if (petypeinfo->value.salt.value != NULL)
        {
            STRING strTemp;

            strTemp.Buffer = (PCHAR) petypeinfo->value.salt.value;
            strTemp.Length = (USHORT) petypeinfo->value.salt.length;
            KerbFreeString((PUNICODE_STRING) &strTemp);
        }

        KdcFreeMemory(petypeinfo);
        petypeinfo = petypeinfoNextEntry;
    }

    if (pPADataList != NULL)
    {
        KerbFreePreAuthData(pPADataList);
    }
    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPwSalt
//
//  Synopsis:   builds the pw-salt pa data type
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

CPAHandlerPwSalt::CPAHandlerPwSalt()
{
}

CPAHandlerPwSalt::~CPAHandlerPwSalt()
{
}

//
//    TBD: currently just use default salt.
//
KERBERR
__stdcall
CPAHandlerPwSalt::ReturnToClient(
        IN  IKerbRequest            *pIKerbRequest,
        OUT PKERB_PA_DATA_LIST      *ppPADataList
)
{
    KERBERR             KerbErr             = KDC_ERR_NONE;
#if 0
    PKERB_PA_DATA_LIST  pPADataList         = NULL;
    PUNICODE_STRING     pustrSaltUsed       = NULL;
    STRING              strSalt             = {0};
    IKerbPrincipal      *pIPrincClient      = NULL;
    UNICODE_STRING      ustrDummySalt           = {0};


    //  this handler breaks w2k clients for no apparent reason
    //  take out the functionality
    //
    //  This handler should never be invoked for TGS request
    //
    //  TBD: temporarily remove this assert since the iterator goes through
    //  all handlers regardless of serv. id.
    // assert(KerbAs == pIKerbRequest->GetServId());
    //
    if (pIKerbRequest->GetServId() != KerbAs)
        goto Cleanup;

    //
    //  If pre-authentication is done, then don't have to do this
    //
#ifdef TBD
    if (pIKerbRequest->IsPreAuthenticated())
    {
        KerbErr = KDC_ERR_NONE;
        goto Cleanup;
    }


    //
    //
    //  The service key is from the client (for AS)
    //
    pIPrincClient = pIKerbRequest->GetIPrincClient();
    if (NULL == pIPrincClient)
    {
        //TBD: log error
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    //  Get salt for the first common key in the ecnryption types from the request
    //  only if the request does not have a session key already
    //
    if (pIKerbRequest->GetSessionKey() == NULL)
    {
        KerbErr = pIPrincClient->GetSaltForFirstEType(
                        pIKerbRequest->GetEncryptionTypes(),
                        pustrSaltUsed);
    }
    if (!KERB_SUCCESS(KerbErr))
        goto Cleanup;

#else
    // use empty salt
    pustrSaltUsed = &ustrDummySalt;
#endif

    //
    // Convert the salt to a kerb string
    //

    KerbErr = KerbUnicodeStringToKerbString(
                &strSalt,
                pustrSaltUsed
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Allocate and fill in the first item
    //

    pPADataList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (pPADataList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ZeroMemory(
        pPADataList,
        sizeof(KERB_PA_DATA_LIST)
        );

    pPADataList->value.preauth_data_type = KRB5_PADATA_PW_SALT;
    pPADataList->value.preauth_data.length = strSalt.Length;
    pPADataList->value.preauth_data.value = (PUCHAR) strSalt.Buffer;
    strSalt.Buffer = NULL;

    pPADataList->next = *ppPADataList;
    *ppPADataList = pPADataList;
    pPADataList = NULL;

Cleanup:

    if (pPADataList != NULL)
    {
        KerbFreePreAuthData((PKERB_PA_DATA_LIST)pPADataList);
    }

    if (strSalt.Buffer != NULL)
    {
        MIDL_user_free(strSalt.Buffer);
    }

#endif

    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckEncryptedTimeStamp
//
//  Synopsis:   Verifies an encrypted time stamp pre-auth data
//
//  Effects:
//
//  Arguments:  PreAuthData - preauth data from client
//              TicketInfo - client's ticket info
//              UserHandle - handle to client's account
//              OutputPreAuth - receives any preauth data to return to client
//
//  Requires:
//
//  Returns:    KDC_ERR_PREAUTH_FAILED - the password was bad
//              Other errors - preauth failed but shouldn't trigger lockout
//
//  Notes:
//
//
//--------------------------------------------------------------------------
CPAHandlerEncryptedTime::CPAHandlerEncryptedTime()
{
    m_ClientTime.LowPart = m_ClientTime.HighPart = 0;
}

CPAHandlerEncryptedTime::~CPAHandlerEncryptedTime()
{
}

KERBERR
__stdcall
CPAHandlerEncryptedTime::Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST           pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    KERBERR                     KerbErr;
    PIKerbPrincipal             pIPrincipal    = NULL;
    KERB_SERVICE_ID             ServId;
    PRINC_FLAGS                 princflags = 0;
    PKERB_ENCRYPTED_DATA        pEncryptedData = NULL;
    PKERB_ENCRYPTED_TIMESTAMP   pEncryptedTime = NULL;
    LARGE_INTEGER               CurrentTime;
    KERB_CRYPT_LIST             Etype;
    LARGE_INTEGER               SkewTime;
    PKERB_ENCRYPTION_KEY        pNewKey = NULL;
    IPAHandler*                 piPA = NULL;
    IPAIdentity*                pICompId = NULL;
    IKDCPrincipalWithMultipleKeys* piMK = NULL;
    BYTE*                       pbScratch = NULL;
    DWORD                       cbScratch = 0;
    
    ServId = pIKerbRequest->GetServId();
    switch(ServId)
    {
        case KerbAs:
            pIPrincipal = pIKerbRequest->GetIPrincClient();
            break;

        case KerbTgs:
            pIPrincipal = pIKerbRequest->GetIPrincService();
            break;

        default:
            //TBD: log ?
            assert(FALSE);
            break;
    }

    if (NULL == pIPrincipal)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    princflags = pIPrincipal->GetPrincFlags();

    if ((princflags & KERB_KDB_DISALLOW_ALL_TIX))
    {
        KerbErr = KDC_ERR_CLIENT_REVOKED;
        goto Cleanup;
    }

    //
    // Unpack the pre-auth data into an encrypted data first.
    //

    KerbErr = KerbUnpackEncryptedData(
                pPreAuthData->value.preauth_data.value,
                pPreAuthData->value.preauth_data.length,
                &pEncryptedData
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    // Support principals with multiple keys
    pIPrincipal->QueryInterface(IID_IKDCPrincipalWithMultipleKeys, (void**)&piMK);

lComputeCompoundKey:    
    
    if (NT_SUCCESS(pIKerbRequest->GetPAHandler(KRB5_PADATA_COMPOUND_IDENTITY, &piPA)))
    {
        //  save the handler in the request for easier access later on
        piPA->QueryInterface(IID_IPAIdentity, (PVOID*)&pICompId);

        //
        //  finally check if the session key in the ecrypted part needs
        //  to be changed
        //  that will be the case if compound identity is present
        //
        if (pICompId)
        {
            ULONG   cKeys = 0;
            const KERB_ENCRYPTION_KEY *pcKeys;
            NTSTATUS    Status = pICompId->GetTgtKeys(&cKeys, &pcKeys);
            if (NT_SUCCESS(Status))
            {
                //  change the session key
                Status = KerbComputePaCompIdentityKeyForPrincipal(
                                                  pEncryptedData->encryption_type,
                                                  pIKerbRequest,
                                                  &pNewKey,
                                                  cKeys,
                                                  pcKeys);
                if (!NT_SUCCESS(Status))
                {
                    //  key derivation failed
                    //  treat this as preauth error
                    KerbErr = KDC_ERR_PREAUTH_FAILED;
                    DebugLog(( DEB_WARN,
                    "KLIN(%x) CPAHandlerEncryptedTime::Check: failed to derived compid key 0x%lx.\n",
                    KLIN(FILENO, __LINE__), Status));
                    goto    Cleanup;
                }
            }
        }
    }
    
    //
    // Now decrypt the encrypted data
    //
    if (pNewKey != NULL)
    {
        // Use the session key of the request
        IKerbCrypt *piCrypt = NULL;
        pIPrincipal->GetIKdbProvider()->GetIKerbCrypt(&piCrypt);

        // We can't decrypt in place because decryption might fail and change the
        // original cyphertext making it impossible to try to decrypt using a 
        // different key. Allocate a buffer to copy the ciphertext
        if(!pbScratch)
        {
            pbScratch = (BYTE*) MIDL_user_allocate(pEncryptedData->cipher_text.length);
            if(!pbScratch)
            {
                KerbErr = KDC_ERR_PREAUTH_FAILED;
                goto Cleanup;
            }            
        }

        cbScratch = pEncryptedData->cipher_text.length;
        memcpy(pbScratch, pEncryptedData->cipher_text.value, cbScratch);

        KerbErr = piCrypt->Decrypt(
                    pEncryptedData,
                    pNewKey,
                    KERB_ENC_TIMESTAMP_SALT,
                    pbScratch,
                    (PULONG) &cbScratch);

        if (KERB_SUCCESS(KerbErr))
        {
            // Copy cleartext back in
            assert(cbScratch <= pEncryptedData->cipher_text.length);
            memcpy(pEncryptedData->cipher_text.value, pbScratch, cbScratch);

            *pEncryptionKey = *pNewKey;
            MIDL_user_free(pNewKey);
            pNewKey = NULL;
        }
        else
        {
            MIDL_user_free(pNewKey->keyvalue.value);
            MIDL_user_free(pNewKey);
            pNewKey = NULL;

            // If principal supports multiple keys (piMK != NULL), try a 
            // different key to generate the compound key.
            if(piMK && piMK->NextKey())
            {
                goto lComputeCompoundKey;
            }
        }
    }
    else
    {
        Etype.next = NULL;
        Etype.value= pEncryptedData->encryption_type;
        KerbErr = pIPrincipal->Decrypt(
                    &Etype,
                    KERB_ENC_TIMESTAMP_SALT,
                    pEncryptedData,
                    pEncryptedData->cipher_text.value,
                    (PULONG) &pEncryptedData->cipher_text.length,
                    NULL,
                    pExtendedError);
    }
    
    //
    //    if the no keys were found for the preferred etype
    //
    if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
    {
        // fakeit
        KERB_CRYPT_LIST pcryptlistFake;
        pcryptlistFake.next = NULL;
        pcryptlistFake.value = pEncryptedData->encryption_type ;

#ifdef TBD
        KdcReportKeyError(
            KdbHandle,
            TicketInfo->Princ,
            TicketInfo->Realm,
            NULL,
            NULL,
            KDCEVENT_NO_KEY_UNION_AS,
            &FakeList,
            TicketInfo->Keys
            );
#endif
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,
                  "KLIN(%x) Failed to decrypt timestamp pre-auth data: 0x%x\n",
                  KLIN(FILENO,__LINE__),
                  KerbErr));
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }


    //
    // unpack the decrypted data into a KERB_ENCRYPTED_TIMESTAMP
    //

    KerbErr = KerbUnpackData(
                pEncryptedData->cipher_text.value,
                pEncryptedData->cipher_text.length,
                KERB_ENCRYPTED_TIMESTAMP_PDU,
                (PVOID *) &pEncryptedTime
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,"KLIN(%x) Failed to unpack preauth data to encrpyted_time\n",
                  KLIN(FILENO,__LINE__)));

        goto Cleanup;
    }

    //
    // Now verify the time.
    //

    KerbConvertGeneralizedTimeToLargeInt(
        &m_ClientTime,
        &pEncryptedTime->timestamp,
        ((pEncryptedTime->bit_mask & KERB_ENCRYPTED_TIMESTAMP_usec_present) != 0) ?
          pEncryptedTime->KERB_ENCRYPTED_TIMESTAMP_usec : 0
        );

    GetSystemTimeAsFileTime(
        (PFILETIME) &CurrentTime
        );

    //
    // We don't want to check too closely, so allow for skew
    //
    SkewTime = pIPrincipal->GetIKdbProvider()->GetKdcPolicy()->TimeSkew;

    if ((CurrentTime.QuadPart + SkewTime.QuadPart < m_ClientTime.QuadPart) ||
        (CurrentTime.QuadPart - SkewTime.QuadPart > m_ClientTime.QuadPart))
    {
#ifdef TBD
        D_DebugLog((DEB_ERROR, "KLIN(%x) Client %wZ time is incorrect:\n",
                  KLIN(FILENO,__LINE__),
                  &TicketInfo->Princ));
#endif
        PrintTime(DEB_ERROR, "Client Time is", &m_ClientTime );
        PrintTime(DEB_ERROR, "KDC Time is", &CurrentTime );

        //
        // We don't want to lockout the account if the time is off
        //

        KerbErr = KRB_AP_ERR_SKEW;
        goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (KERB_SUCCESS(KerbErr))
    {
        *pbSufficient = TRUE;
    }
    if (pEncryptedData != NULL)
    {
        KerbFreeEncryptedData(pEncryptedData);
    }
    if (pEncryptedTime != NULL)
    {
        KerbFreeData(KERB_ENCRYPTED_TIMESTAMP_PDU, pEncryptedTime);
    }
    if (pNewKey != NULL)
    {
        if (pNewKey->keyvalue.value != NULL)
        {
            MIDL_user_free(pNewKey->keyvalue.value);
        }        
        MIDL_user_free(pNewKey);
    }
    if(pbScratch != NULL)
    {
        MIDL_user_free(pbScratch);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPacRequestPreAuthData
//
//  Synopsis:   Gets the status of whether the client wants a PAC from the
//              pre-auth data
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
CPAHandlerPACRequestEx::CPAHandlerPACRequestEx()
    : m_pPacContext(NULL),
      m_cDefaultSections(NUM_PA_PACREQ_DEFAULT_SECTIONS)
{
    //
    //  Default to only client identity section
    //
    m_rgulDefaultSections[0] = PAC_XBOX_IDENTITY;
}

CPAHandlerPACRequestEx::~CPAHandlerPACRequestEx()
{
    if (m_pPacContext)
        MIDL_user_free( m_pPacContext );

}

HRESULT
__stdcall
CPAHandlerPACRequestEx::QueryInterface(REFIID intf, PVOID *ppv)
{
    HRESULT    hr = E_NOINTERFACE;

    *ppv = NULL;
    if ( IsEqualGUID( intf, IID_IPAPacReqEx ) )
    {
        *ppv = static_cast<IPAPacReqEx*>(this);
        hr = S_OK;
    }
    return hr;
}


KERBERR
__stdcall
CPAHandlerPACRequestEx::Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    KERBERR                     KerbErr         = KDC_ERR_NONE;
    PKERB_PA_PAC_REQUEST_EX     pPacRequest     = NULL;
    BUILD_PAC_OPTIONS           BuildPac;
    PKERB_PA_PAC_REQUEST_EX_pac_sections pSect  = NULL;
    INT                         iSectionCount   = 0;
    INT                         i;
    PPAC_CONTEXT                pPacContext     = NULL;

    DsysAssert(
        pPreAuthData->value.preauth_data_type == KRB5_PADATA_PAC_REQUEST ||
        pPreAuthData->value.preauth_data_type == KRB5_PADATA_PAC_REQUEST_EX
        );

    //
    // Multiple PACs are strictly not allowed
    // 

    if (m_pPacContext != NULL) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    // New KERB_PA_PAC_REQUEST_EX_PDU can decode KERB_PA_PAC_REQUEST_PDU
    //

    KerbErr = KerbUnpackData(
                pPreAuthData->value.preauth_data.value,
                pPreAuthData->value.preauth_data.length,
                KERB_PA_PAC_REQUEST_EX_PDU,
                (PVOID *) &pPacRequest
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (pPacRequest->include_pac)
    {
        BuildPac = IncludePac;

        if (pPacRequest->bit_mask & pac_sections_present)
        {
            for (pSect = pPacRequest->pac_sections;
                 pSect;
                 pSect = pSect->next)
            {
                iSectionCount++;
            }
        }
    }
    else
    {
        BuildPac = DontIncludePac;
    }

    D_DebugLog((DEB_T_TICKETS,"Setting BuildPac from pa-data to %d for %d sections\n",BuildPac,iSectionCount));

    if (iSectionCount > 0)
    {
        pPacContext = (PPAC_CONTEXT) MIDL_user_allocate(
                                sizeof(*pPacContext) +
                                (sizeof(ULONG) * (iSectionCount - ANYSIZE_ARRAY))
                                );
    }
    else
    {
        pPacContext = (PPAC_CONTEXT) MIDL_user_allocate( sizeof( PAC_CONTEXT ));
    }

    if (pPacContext == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    pPacContext->PacOptions     = BuildPac;
    pPacContext->SectionCount     = iSectionCount;

    if (iSectionCount)
    {
        i = 0;
        for (pSect = pPacRequest->pac_sections;
             pSect;
             pSect = pSect->next)
        {
            pPacContext->Sections[i++] = pSect->value;
        }
    }

    m_pPacContext = pPacContext;
    pPacContext   = NULL;

Cleanup:
    if (pPacContext)
        MIDL_user_free( pPacContext );

    if (pPacRequest != NULL)
    {
        KerbFreeData(
            KERB_PA_PAC_REQUEST_EX_PDU,
            pPacRequest
            );
    }
    return(KerbErr);
}



//
//    IPAPacReqEx methods
//

//  not allocating. The info is maintained by the interface
//  and released when it goes away
NTSTATUS __stdcall CPAHandlerPACRequestEx::GetRequestedPacSections(
    OUT    ULONG&   cSections,
    OUT    PULONG&  pulSections
)
{
    if (m_pPacContext)
    {
        cSections   = m_pPacContext->SectionCount;
        pulSections = m_pPacContext->Sections;
    }
    else
    {
        //
        //  default to Passport Puid section
        //
        cSections   = m_cDefaultSections;
        pulSections = m_rgulDefaultSections;
    }
    return STATUS_SUCCESS;
}


//
// allows provs to query for specific PAC sections
//
BOOL __stdcall CPAHandlerPACRequestEx::IsPacSectionRequested(
    IN    ULONG ulSectionId)
{
    ULONG   i;
    BOOL    fRC = FALSE;
    ULONG   cSec = 0, *pulSec = NULL;

    //  compound identity does not have to be requested
    //
    if (ulSectionId == PAC_COMPOUND_IDENTITY)
    {
        return  TRUE;
    }

    if (m_pPacContext)
    {
        //  use passed in PA data
        cSec = m_pPacContext->SectionCount;
        pulSec = m_pPacContext->Sections;
    }
    else
    {
        //  if not present, use defaults
        cSec = m_cDefaultSections;
        pulSec = m_rgulDefaultSections;
    }
    for (i = 0; i < cSec; i++)
    {
        if (ulSectionId == pulSec[i])
        {
            fRC = TRUE;
            break;
        }
    }

    return fRC;
}

BOOL
__stdcall
CPAHandlerPACRequestEx::IsPacRequested()
{
    //
    //  default to returning the Passport PUID section
    //
    BOOL fRC = TRUE;

    if (m_pPacContext)
    {
        fRC = m_pPacContext->PacOptions != DontIncludePac;
    }
    else
    {
        fRC = (m_cDefaultSections > 0);
    }
    return fRC;
}

CPAHandlerPkinit::CPAHandlerPkinit()
{
}

CPAHandlerPkinit::~CPAHandlerPkinit()
{
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAHandlerPkinit::Check
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Returns:    KDC_ERR_NONE                indicates success
//              KDC_ERR_PADATA_TYPE_NOSUPP  no support for KDC cert
//              KRB_AP_ERR_MODIFIED         ScHelperVerifyPkcsMessage failed
//                                              & the return code is in *pNTStatus
//              KDC_ERR_BADOPTION           cert type is not supported
//              KDC_ERR_SUMTYPE_NOSUPP      signature did not match
//              KDC_ERR_S_PRINCIPAL_UNKNOWN realm name in the authenticator does not match the
//                                          request
//
//  Notes:      this routine allows in-place decryption
//
//--------------------------------------------------------------------------
KERBERR __stdcall CPAHandlerPkinit::Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    return KdcCheckPkinitPreAuthData(
                    pIKerbRequest,
                    pPreAuthData,
                    pEncryptionKey,
                    ppOutPadata,
                    pExtendedError);
}

CPAHandlerPkinitCompat::CPAHandlerPkinitCompat()
{
}

CPAHandlerPkinitCompat::~CPAHandlerPkinitCompat()
{
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAHandlerPkinitCompat::Check
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Returns:    KDC_ERR_NONE                indicates success
//              KDC_ERR_PADATA_TYPE_NOSUPP  no support for KDC cert
//              KRB_AP_ERR_MODIFIED         ScHelperVerifyPkcsMessage failed
//                                              & the return code is in *pNTStatus
//              KDC_ERR_BADOPTION           cert type is not supported
//              KDC_ERR_SUMTYPE_NOSUPP      signature did not match
//              KDC_ERR_S_PRINCIPAL_UNKNOWN realm name in the authenticator does not match the
//                                          request
//
//  Notes:      this routine allows in-place decryption
//
//--------------------------------------------------------------------------
KERBERR __stdcall CPAHandlerPkinitCompat::Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    return KdcCheckPkinitPreAuthData(
                    pIKerbRequest,
                    pPreAuthData,
                    pEncryptionKey,
                    ppOutPadata,
                    pExtendedError);
}

//------------------------------------------------------------------------------------------
//                            F a c t o r i e s
//------------------------------------------------------------------------------------------



//
//  Since CPAHandlerEType is stateless, the factory will just use a member var. for
//  the handler.
//
//  Obviously, the factory must be released only when all PA handling is completed.
//
NTSTATUS __stdcall CPAHandlerETypeFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerPwSaltFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerEncryptedTimeFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerPACReqExFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler= new CPAHandlerPACRequestEx;
    if (*ppIPAHandler == NULL)
        return  STATUS_NO_MEMORY;

    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerPkinitFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerPkinitCompatFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\pacint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       pacint.h
//
//  Contents:   KDC pacint function interfaces
//
//  Classes:
//
//  Functions:
//
//  History:    19-July-2001    JBrezak
//
//----------------------------------------------------------------------------

#ifndef _PACINT_H_
#define _PACINT_H_

NTSTATUS
KdcInitializeInternalPacHandlers(
    VOID
    );

//
typedef KERBERR (*KDC_PAC_ITERATE_FN) (
    IN PIKdbProvider            piKdb,
    IN PIKerbPrincipal              User,
    IN BOOLEAN                  IsUpdate,
    IN PKERB_ENCRYPTED_TICKET   EncryptedTicket,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PPAC_INFO_BUFFER        *Info,
    OUT PKERB_EXT_ERROR         pExtendedError,
    IN CKerbRequest*            pReq,
    IN PIPACHandler             pHandler,
    IN OUT PVOID                pData
    );

KERBERR
KdcIteratePacHandler(
    IN PIKdbProvider            pKdb,
    IN PIKerbPrincipal              User,
    IN BOOLEAN                  IsUpdate,
    IN PKERB_ENCRYPTED_TICKET   EncryptedTicket,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PPAC_INFO_BUFFER        *Info,
    OUT PKERB_EXT_ERROR         pExtendedError,
    IN CKerbRequest*            pReq,
    IN KDC_PAC_ITERATE_FN       Func,
    IN OUT PVOID                Data
    );


INT
KdcNumberOfPacHandlers(
    VOID
    );

#endif // _PACINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\realm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       realm.cxx
//
//  Contents:   Manage realm to KDB associations
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

//
// Return: "realm.com"
//
#if 0
//  that is really unnecessary
//  realm is present in the request and that's how the
//  provider was located
NTSTATUS
KdcRealmGetName(
    IN  KdbHandle,
    OUT PKERB_REALM Realm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDB_REALM pRealm;

    pRealm = KdbGetRealm(KdbHandle);
    if (!pRealm)
        return STATUS_NO_SUCH_DOMAIN;

    Status = KerbConvertUnicodeStringToRealm(
                 Realm,
                 &pRealm->Name
                 );

    return Status;
}
#endif

#if 0
//  same here
BOOLEAN
KdcIsOurRealm(
    IN KDB_HANDLE KdbHandle,
    IN PKERB_REALM Realm
    )
{
    BOOLEAN Result;
    KERB_REALM RealmName = {0};

    if (!NT_SUCCESS(KdcRealmGetName(
                       KdbHandle,
                       &RealmName)))
    {
        return(FALSE);
    }

    Result = KerbCompareRealmNames(
                Realm,
                &RealmName
                );

    KerbFreeRealm(&RealmName);

    return(Result);
}

//
// Return "krbtgt/realm.com"
//
NTSTATUS
KdcRealmGetKrbTgtName(
    IN PKERB_INTERNAL_NAME pRealm,
    OUT PUNICODE_STRING KrbtgtString
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDB_REALM pRealm;

    pRealm = KdbGetRealm(KdbHandle);
    if (!pRealm)
        return STATUS_NO_SUCH_DOMAIN;

    if (!KERB_SUCCESS(KerbConvertKdcNameToString(
                         KrbtgtString,
                         pRealm->KrbtgtName,
                         NULL)))
    {
        return STATUS_NO_MEMORY;
    }

    return Status;
}

NTSTATUS
KdcRealmGetKrbTgtName(
    IN PKERB_INTERNAL_NAME pRealmName,
    OUT PKERB_INTERNAL_NAME *KrbtgtServiceName
    )
{
    return KerbBuildFullServiceKdcName(
                                &pRealmName,
                                &KrbtgtName,
                                KRB_NT_SRV_INST,
                                KrbtgtServiceName
            );
}
#endif

#if 0
// Not supporting these - update the certs!
// KdcFullServiceDnsName: TEST.COM\krbtgt
PUNICODE_STRING
KdcFullServiceDnsName(
    KDB_HANDLE KdbHandle
    )
{
    return NULL;
}

// KdcFullServiceName: TEST.COM\krbtgt
PUNICODE_STRING
KdcFullServiceName(
    KDB_HANDLE KdbHandle
    )
{
    return NULL;
}
#endif

#if 0
//  not sure what this means ....
// KdcDnsRealmName: TEST.COM
PUNICODE_STRING
KdcDnsRealmName(
    KDB_HANDLE KdbHandle
    )
{
    PKDB_REALM pRealm;

    pRealm = KdbGetRealm(KdbHandle);
    if (!pRealm)
        return NULL;

    return (&pRealm->Name);
}

//  not really needed.
//  provider has a method for this
BOOLEAN
KdcRealmSupportsPac(
    KDB_HANDLE KdbHandle
    )
{
    PKDB_REALM pRealm;

    pRealm = KdbGetRealm(KdbHandle);
    if (!pRealm)
        return FALSE;

    return ((pRealm->Flags & KERB_KDB_REALM_DOES_PAC) != 0);
}
#endif


KERBERR
KdcRealmGetKrbTGT(
    PIKerbProvider KdbHandle,
    PKDB_PRINC_INFO *KrbtgtInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_EXT_ERROR ExtendedError;
    PKERB_INTERNAL_NAME KrbtgtName;
    NTSTATUS Status;

    TRACER(L"KdcRealmGetKrbTGT", (PVOID *) &KerbErr);
    
    Status = KdcRealmGetKrbTgtName(
                KdbHandle,
                &KrbtgtName
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    KerbErr =  KdbGetPrincipal(
                  KdbHandle,
                  KrbtgtName,
                  NULL,
                  KDC_KDB_GET_PRINC_CLIENT,
                  KerbTgs,
                  KrbtgtInfo,
                  &ExtendedError
                  );

Cleanup:

    KerbFreeKdcName(&KrbtgtName);

    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\preauth.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       preauth.cxx
//
//  Contents:   KDC Internal Preauth types
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include "traceinterface.hxx"
#include "fileno.h"
#define FILENO FILENO_GETAS

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPreauthTypeList
//
//  Synopsis:   For returning with a PREAUTH-REQUIRED message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcBuildPreauthTypeList(
    IN CKerbRequest           *pReq,
    IN OUT PKERB_PA_DATA_LIST *PreauthTypeList
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    IPAHandler **iPA = pReq->m_ppiPAHandlers;
    ULONG cHandlers = KdcPAHandlerFactoryList.cElem;
    TRACER(L"KdcBuildPreauthTypeList", (PVOID *) &KerbErr);

    while(cHandlers-- && *iPA)
    {
        PKERB_PA_DATA_LIST DataList = NULL;
        KerbErr = (*iPA)->Get(pReq, &DataList);

        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        if (!DataList)
        {
            //  if the handler did not allocate anything, do
            //  it on its behalf
            DataList = (PKERB_PA_DATA_LIST)
                    MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
            if (DataList == NULL)
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }
            ZeroMemory(
                DataList,
                sizeof(KERB_PA_DATA_LIST)
                );

            DataList->value.preauth_data_type = (*iPA)->GetPAType();
        }
        //  and finally put in the list
        DataList->next = *PreauthTypeList;
        *PreauthTypeList = DataList;
        iPA++;
    }

Cleanup:

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPreAuthData
//
//  Synopsis:   Checks the pre-auth data in an AS request. This routine
//              may return pre-auth data to caller on both success and
//              failure.
//
//  Effects:
//
//  Arguments:  ClientTicketInfo - client account's ticket info
//              UserHandle - Handle to client's user object
//              PreAuthData - Pre-auth data supplied by client
//              PreAuthType - The type of pre-auth used
//              OutputPreAuthData - pre-auth data to return to client
//
//  Requires:
//
//  Returns:    KDC_ERR_PREAUTH_REQUIRED, KDC_ERR_PREAUTH_FAILED
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckPreAuthData(
    IN PIKdbProvider piKdb,
    IN KERB_SERVICE_ID ServiceId,
    IN PIKerbPrincipal ClientInfo,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PULONG PreAuthType,
    OUT PKERB_PA_DATA_LIST * OutputPreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PUNICODE_STRING TransitedRealms,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN CKerbRequest *pReq
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERBERR TempKerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST OutputElement = NULL;
    PKERB_PA_DATA_LIST ListElement = NULL;
    BOOLEAN ValidPreauthPresent = FALSE;
    IPAHandler *piPAHandler;
    TRACER(L"KdcCheckPreAuthData", (PVOID *) &KerbErr);

    *OutputPreAuthData = NULL;

    //
    // Loop through the supplied pre-auth data elements and handle each one
    //

    for (ListElement = PreAuthData;
         ListElement != NULL ;
         ListElement = ListElement->next )
    {
        if (
           ListElement->value.preauth_data_type == KRB5_PADATA_COMPOUND_IDENTITY &&
           (ServiceId == KerbTgs || ServiceId == KerbAs)
        )
        {
            //  for as and tgs, this PA handler is already processed
            continue;
        }

        NTSTATUS Status = pReq->GetPAHandler(
                           ListElement->value.preauth_data_type,
                           &piPAHandler
                           );
        BOOLEAN bSufficient = FALSE;

        if (!NT_SUCCESS(Status))
        {
            //
            //  handler not found, ignore this PA then
            //
            Status = STATUS_SUCCESS;
            continue;
        }
        //  skip AS/TGS checks
        KerbErr = piPAHandler->Check(pReq,
                                    ListElement,
                                    EncryptionKey,
                                    &OutputElement,
                                    &bSufficient,
                                    pExtendedError);
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }

        if (bSufficient)
        {
            ValidPreauthPresent = TRUE;
            *PreAuthType = ListElement->value.preauth_data_type;
        }

        if (OutputElement != NULL)
        {
            OutputElement->next = *OutputPreAuthData;
            *OutputPreAuthData = OutputElement;
            OutputElement = NULL;
        }
    }

    //
    // We need to check preauth data by default, unless the account tells
    // us not to or preauth failed.
    //

    if (ClientInfo &&
        ((ClientInfo->GetPrincFlags() & KERB_KDB_REQUIRES_PRE_AUTH) &&
         !ValidPreauthPresent))
    {
        if (KERB_SUCCESS(KerbErr))
            KerbErr = KDC_ERR_PREAUTH_REQUIRED;

        //
        // Return the list of supported types, if we don't have other
        // data to return.
        //

        if (*OutputPreAuthData == NULL)
        {

            TempKerbErr = KdcBuildPreauthTypeList(
                             pReq,
                             OutputPreAuthData
                             );

            //
            // In this case, we can't find any ETypes that both the client and
            // server support, so we've got to bail w/ proper error message...
            //
            if (TempKerbErr == KDC_ERR_ETYPE_NOTSUPP)
            {
                KerbErr = KDC_ERR_ETYPE_NOTSUPP;
            }
        }
    }

    return(KerbErr);
}


//
//  iterate on all handlers passing the output preauth data
//
KERBERR
KdcReturnPreAuthData(
    IN CKerbRequest             *pReq,
    OUT PKERB_PA_DATA_LIST      *OutputPreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    IPAHandler **iPA = pReq->m_ppiPAHandlers;
    ULONG cHandlers = KdcPAHandlerFactoryList.cElem;

    while(cHandlers-- && *iPA)
    {
        KerbErr = (*iPA)->ReturnToClient(pReq, OutputPreAuthData);

        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        iPA++;
    }


    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\rpcif.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        rpcif.h
//
// Contents:    RPC interface support functions
//
//
// History:     20-May-1996     Labeled         MikeSw
//
//------------------------------------------------------------------------

#ifndef __RPCIF_H__
#define __RPCIF_H__

// #define USE_SECURE_RPC

#define MAX_CONCURRENT_CALLS 10

NTSTATUS   StartRPC(LPTSTR, LPTSTR);
NTSTATUS   StartAllProtSeqs(void);
NTSTATUS   StopRPC(void);
NTSTATUS   SetAuthData();
NTSTATUS RegisterKdcEps();
NTSTATUS UnRegisterKdcEps();

NTSTATUS   RpcTransportNameRegister();
NTSTATUS   RpcTransportNameDeRegister();
BOOLEAN    RpcTransportCheckRegistrations();
LPSTR   RpcString(LPSTR);
SECURITY_STATUS   RPC_SECNTSTATUS(ULONG);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\refer.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        refer.h
//
// Contents:    Structurs and prototypes for interdomain referrals
//
//
// History:     26-Mar-1997     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __REFER_H__
#define __REFER_H__

extern LIST_ENTRY KdcDomainList;
extern LIST_ENTRY KdcReferralCache;

//
// For NT5 domains in the enterprise the dns name will contain the
// real DNS name. For non- tree domains it will contain the name from
// the trusted domain object
//

#define KDC_DOMAIN_US           0x0001
#define KDC_DOMAIN_TREE_ROOT    0x0002
#define KDC_TRUST_INBOUND       0x0004

// cache flags
#define KDC_NO_ENTRY            0x0000
#define KDC_UNTRUSTED_REALM     0x0001
#define KDC_TRUSTED_REALM       0x0002

typedef struct _KDC_DOMAIN_INFO {
    LIST_ENTRY Next;
    UNICODE_STRING DnsName;
    UNICODE_STRING NetbiosName;
    struct _KDC_DOMAIN_INFO * ClosestRoute;     // Points to referral target for this domain or NULL if unreachable
    ULONG Flags;
    ULONG Attributes;
    ULONG Type;
    LONG References;

    //
    // Types used during building the tree
    //

    struct _KDC_DOMAIN_INFO * Parent;
    ULONG Touched;
    PSID Sid;
} KDC_DOMAIN_INFO, *PKDC_DOMAIN_INFO;


typedef struct _REFERRAL_CACHE_ENTRY {
    LIST_ENTRY ListEntry;
    LONG References;
    TimeStamp EndTime;
    UNICODE_STRING RealmName;
    ULONG CacheFlags;
} REFERRAL_CACHE_ENTRY, *PREFERRAL_CACHE_ENTRY;


VOID
KdcFreeReferralCache(
    IN PLIST_ENTRY ReferralCache
    );

KERBERR
KdcCheckForCrossForestReferral(
    OUT PIKerbPrincipal ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN ULONG NameFlags
    );


KERBERR
KdcFindReferralTarget(
    OUT PIKerbPrincipal *pReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN BOOLEAN ExactMatch,
    IN BOOLEAN InboundWanted
    );


KERBERR
KdcGetTicketInfoForDomain(
    OUT PIKerbPrincipal *TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PKDC_DOMAIN_INFO DomainInfo,
    IN KDC_DOMAIN_INFO_DIRECTION Direction
    );

KERBERR
KdcLookupDomainName(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    );

KERBERR
KdcLookupDomainRoute(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    OUT PKDC_DOMAIN_INFO * ClosestRoute,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    );

NTSTATUS
KdcBuildDomainTree(
    );

ULONG __stdcall
KdcReloadDomainTree(
    PVOID Dummy
    );

VOID
KdcFreeDomainList(
    IN PLIST_ENTRY DomainList
    );

VOID
KdcDereferenceDomainInfo(
    IN PKDC_DOMAIN_INFO DomainInfo
    );

VOID
KdcLockDomainListFn(
   );

VOID
KdcUnlockDomainListFn(
   );

#endif // __REFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\secdata.cxx ===
//+-----------------------------------------------------------------------
//
// File:        secdata.cxx
//
// Contents:    Global data and methods on it.
//
//
// History:
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include <tostring.hxx>
#include <kpasswd.h>

///////////////////////////////////////////////////////////////
//
//
// Global data
//

// This is all the security information that gets cached.

CSecurityData SecData;

CAuthenticatorList * Authenticators;
CAuthenticatorList * FailedRequests;

////////////////////////////////////////////////////////////////////
//
//  Name:       CSecurityData::CSecurityData
//
//  Synopsis:   Constructor.
//
//  Arguments:  <none>
//
//  Notes:      .
//
CSecurityData::CSecurityData()
{
    TRACE(KDC, CSecurityData::CSecurityData, DEB_FUNCTION);

    InitializeCriticalSection(&_Monitor);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::Init
//
//  Synopsis:   Initializes the global data.
//
//  Effects:    Allocates memory
//
//  Arguments:  (none)
//
//  Returns:    STATUS_SUCCESS or error code
//
//  Signals:    May raise exception on out of memory.
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:      This must be called before any other method of
//              CSecurityData.  It gets data from the registry, the domain
//              object, and the kdc.ini file.
//
//----------------------------------------------------------------------------

NTSTATUS
CSecurityData::Init()
{
    TRACE(KDC, CSecurityData::Init, DEB_FUNCTION);

    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER MaxAuthenticatorAge;


    D_DebugLog(( DEB_TRACE, "Entered CSecurityData::Init()\n" ));


    //
    // Create the authenticators.
    //

    //
    //  In reality, set skew time to 5 minutes and same for authenticators.
    //  this is default skew time. providers can override
    //

    MaxAuthenticatorAge.QuadPart = (LONGLONG) 10000000 * 60 * 5;


    //
    // Create the authenticator list
    //

    Authenticators = new CAuthenticatorList( MaxAuthenticatorAge );
    if (Authenticators == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Setup a list to track failed requests - we don't fail the
    // same request twice for the timeout time
    //

    FailedRequests = new CAuthenticatorList( MaxAuthenticatorAge );
    if (FailedRequests == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:
    return(Status);

}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::~CSecurityData
//
//  Synopsis:   Destructor
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
CSecurityData::Cleanup()
{
    TRACE(KDC, CSecurityData::Cleanup, DEB_FUNCTION);

    if (Authenticators != NULL)
    {
        delete Authenticators;
        Authenticators = NULL;
    }
    if (FailedRequests != NULL)
    {
        delete FailedRequests;
        FailedRequests = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::~CSecurityData
//
//  Synopsis:   Destructor
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSecurityData::~CSecurityData()
{
    TRACE(KDC, CSecurityData::~CSecurityData, DEB_FUNCTION);

    Cleanup();

    //
    // This doesn't happen during Cleanup() because we want to
    // make sure it only happens once.
    //

    DeleteCriticalSection(&_Monitor);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\realm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       realm.h
//
//  Contents:   KdcRealm interfaces
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#ifndef _REALM_H_
#define _REALM_H_

#if 0
//  this should not be needed!
NTSTATUS
KdcRealmGetName(
    IN PIKdbProvider    piKdb,
    OUT PKERB_REALM     Realm
    );

BOOLEAN
KdcIsOurRealm(
    IN PIKdbProvider    piKdb,
    IN PKERB_REALM Realm
    );

//
//  hmm... this may take a realm as a param ...
NTSTATUS
KdcRealmGetKrbTgtName(
    IN PIKdbProvider    piKdb,
    OUT PUNICODE_STRING KrbtgtString
    );


//
//  should take realm name ...
//  
PUNICODE_STRING
KdcDnsRealmName(
    IN PIKdbProvider    piKdb
    );

//
//  should take realm name ...
//  
KERBERR
KdcRealmGetKrbTGT(
    IN PIKdbProvider    piKdb,
    PIKerbPrincipal         *KrbtgtInfo
    );
#endif

#if 0
//  not needed
BOOLEAN
KdcRealmSupportsPac(
    KDB_HANDLE KdbHandle
    );
#endif
#endif // _REALM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\srvbuf.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        sockutil.cxx
//
// Contents:    Server support routines for sockets
//
//
// History:     10-July-1996    MikeSw  Created
//
//------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include <atq.h>
extern "C"
{
}
#include <issched.hxx>


ULONGLONG   TotalBytes ;
ULONG       Messages ;
ULONG       DefaultMessageSize ;


typedef struct _KDC_ATQ_BUFFER_REGION {
    LIST_ENTRY List ;
    PVOID   RegionBase ;
    SIZE_T  RegionSize ;
    ULONG   Count ;
    ULONG   Granularity ;
    LONG    Active ;
} KDC_ATQ_BUFFER_REGION, * PKDC_ATQ_BUFFER_REGION ;

typedef struct _KDC_ATQ_BUFFER {
    SINGLE_LIST_ENTRY List ;
    PKDC_ATQ_BUFFER_REGION Region ;
    ULONG   Size ;
} KDC_ATQ_BUFFER, * PKDC_ATQ_BUFFER ;

typedef struct _KDC_ATQ_BUFFER_CONTROL {

    ULONG                   Granularity ;
    LIST_ENTRY              BufferPools ;
    SLIST_HEADER            BufferList ;
    CRITICAL_SECTION    PoolLock ;

    PKDC_ATQ_BUFFER_REGION  SpillRegion ;
    CRITICAL_SECTION    SpillLock ;
    SINGLE_LIST_ENTRY       SpillList ;

} KDC_ATQ_BUFFER_CONTROL, *PKDC_ATQ_BUFFER_CONTROL ;



NTSTATUS
KdcInitializeDatagramSockets(
    VOID
    );

NTSTATUS
KdcShutdownDatagramSockets(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\strarray.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    StrArray.h

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

    These functions are useful for the NetServerDiskEnum and NetConfigGetAll
    APIs, and possibly others.

Author:

    John Rogers (JohnRo) 03-Jan-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Jan-1992 JohnRo
        Created this file from bits and pieces in RxCommon and NetLib.
    01-Sep-1992 JohnRo
        RAID 5016: NetConfigGetAll heap trash.

--*/

#ifndef _STRARRAY_
#define _STRARRAY_


// These must be included first:

#include <windef.h>             // IN, LPTSTR, LPVOID, etc.

// These may be included in any order:

// (none)


//
//////////////////////////////// LPTSTR_ARRAY stuff //////////////////////////
//

typedef LPTSTR LPTSTR_ARRAY;


VOID
NetpAddTStrToTStrArray (
    IN OUT LPTSTR_ARRAY Dest,
    IN LPTSTR Src
    );


VOID
NetpCopyStrArrayToTStrArray (
    OUT LPTSTR_ARRAY Dest,  // string array: TCHARs
    IN  LPSTR  Src    // string array: 8-bit input in default codepage for LAN
    );


#if DBG

VOID
NetpDisplayTStrArray (
    IN LPTSTR_ARRAY Array
    );

#else // not DBG

#define NetpDisplayTStrArray(Array)     /* nothing */

#endif // not DBG


// BOOL
// NetpIsTStrArrayEmpty (
//     IN LPTSTR_ARRAY Array
//     );
#define NetpIsTStrArrayEmpty( Array )  \
    ( ( (*(Array)) == (TCHAR) '\0') ? TRUE : FALSE )


// LPTSTR_ARRAY
// NetpNextTStrArrayEntry (
//     IN LPTSTR_ARRAY Array
//     );
#define NetpNextTStrArrayEntry(Array) \
    ( ((LPTSTR)(Array)) + (STRLEN(Array) + 1) )


//
// Return number of entries in this string array.
//
DWORD
NetpTStrArrayEntryCount (
    IN LPTSTR_ARRAY Array
    );


//
// Return number of bytes to allocate for this string array.
// This includes the "extra" trailing null char.
//
DWORD
NetpTStrArraySize(
    IN LPTSTR_ARRAY Array
    );


//
//////////////////////////////// LPSTR_ARRAY stuff //////////////////////////
//

typedef LPSTR  LPSTR_ARRAY;

DWORD
NetpStrArraySize(
    IN LPSTR_ARRAY Array
    );


#endif // ndef _STRARRAY_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\secmisc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:        secmisc.h
//
//  Contents:    Helper functions and macros for security packages
//
//  Classes:
//
//  Functions:
//
//  History:    10-Dec-91 Richardw    Created
//
//--------------------------------------------------------------------------

#ifndef __SECMISC_H__
#define __SECMISC_H__

#ifdef __cplusplus
extern "C" {
#endif



///////////////////////////////////////////////////////////////////////////
//
//  Common TimeStamp Manipulation Functions
//
///////////////////////////////////////////////////////////////////////////


// Functions to get/set current local time, or time in UTC:

void    GetCurrentTimeStamp(PLARGE_INTEGER);

// Some convenient "functions"




//
//  BOOL
//  TSIsZero(PLARGE_INTEGER pTS)
//
#define TSIsZero(pTS)   ((pTS)->QuadPart == 0)


#define SetMaxTimeStamp(ts)      \
        (ts).HighPart = 0x7FFFFFFF; \
        (ts).LowPart = 0xFFFFFFFF;

#define SetZeroTimeStamp(ts)      \
        (ts).QuadPart = 0;

void    AddSecondsToTimeStamp(PLARGE_INTEGER, ULONG);
BOOLEAN TSIsNearlyLessThan(PLARGE_INTEGER, PLARGE_INTEGER, PLARGE_INTEGER, LONG);
ULONG   TimeStampDiffInSeconds( PLARGE_INTEGER t1, PLARGE_INTEGER t2);

#define TS_NO_TEND          0
#define TS_TEND_TO_FALSE    1
#define TS_TEND_TO_TRUE     2



// RPC transport constants and routines

#define TRANS_NB        0
#define TRANS_XNS       1
#define TRANS_TCPIP     2
#define TRANS_NP        3

NTSTATUS
GetRpcTransports(PDWORD         pTransports);


NTSTATUS
NewQueryValue(  HKEY            hKey,
                LPWSTR          Key,
                PBYTE *         pValue,
                PULONG          pcbValue);

NTSTATUS
GetMachineName( LPWSTR *        pszMachName);

NTSTATUS
GetLocalDomain( LPWSTR *        pszLocalDomain);

typedef enum _MACHINE_STATE {
    Standalone,
    Workstation,
    StandardServer,
    BackupDomainController,
    DomainController
} MACHINE_STATE;

MACHINE_STATE
GetMachineState(VOID);


//
// Misc. checking routines
//

void
SRtlCheckSecBufferDesc( PSecBufferDesc pData);

void
SRtlCheckSecBuffer( PSecBuffer pBuffer);






#ifdef __cplusplus
}
#endif


#endif  // __SECMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\tktutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       tktutil.cxx
//
//  Contents:   x//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//
//----------------------------------------------------------------------------


// Place any local #includes files here.

#include "kdcsvr.hxx"

#include "malloc.h"

//#include <kdctrace.h>

#define FILENO FILENO_TKTUTIL

#define MAX_ETYPE_LONG   999
#define MIN_ETYPE_LONG  -999
#define MAX_ETYPE_STRING 16  // 4wchar + , + 2 space
#define WSZ_NO_KEYS L"< >"

//  local functions
KERBERR
KerbProcessPaCompoundIdentity(CKerbRequest *pKdcReq,
                              PKERB_EXT_ERROR pExtErr);

//
// Static data
//



//
// Fudge factor for comparing timestamps, because network clocks may
// be out of sync.
// Note: The lowpart is first!
//

//LARGE_INTEGER SkewTime;

//+---------------------------------------------------------------------------
//
//  Function:   GetTimeStamps
//
//  Synopsis:   Gets the current time and clock skew envelope.
//
//  Arguments:  [ptsFudge]    -- (in) amount of clock skew to allow.
//              [ptsNow]      -- (out) the current time
//              [ptsNowPlus]  -- (out) the current time plus the skew.
//              [ptsNowMinus] -- (out) the current time less the skew
//
//  History:    4-23-93   WadeR   Created
//
//----------------------------------------------------------------------------
void
GetTimeStamps(  IN  PLARGE_INTEGER ptsFudge,
                OUT PLARGE_INTEGER ptsNow,
                OUT PLARGE_INTEGER ptsNowPlus,
                OUT PLARGE_INTEGER ptsNowMinus )
{
    TRACE(KDC, GetTimeStamps, DEB_FUNCTION);

    GetSystemTimeAsFileTime((PFILETIME) ptsNow );
    ptsNowPlus->QuadPart = ptsNow->QuadPart + ptsFudge->QuadPart;
    ptsNowMinus->QuadPart = ptsNow->QuadPart - ptsFudge->QuadPart;
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildTicketTimesAndFlags
//
//  Synopsis:   Computes the times and flags for a new ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcBuildTicketTimesAndFlags(
    IN ULONG ClientPolicyFlags,
    IN ULONG ServerPolicyFlags,
    IN const KDC_POLICY_VALUES* pKdcPolicy,
    IN PLARGE_INTEGER MaxTicketLifespan,
    IN PLARGE_INTEGER MaxTicketRenewspan,
    IN OPTIONAL PLARGE_INTEGER AccountExpiry,
    IN const KERB_KDC_REQUEST_BODY *RequestBody,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET SourceTicket,
    IN OUT PKERB_ENCRYPTED_TICKET Ticket,
    IN OUT OPTIONAL PKERB_EXT_ERROR ExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    LARGE_INTEGER RequestEndTime;
    LARGE_INTEGER RequestStartTime;
    LARGE_INTEGER RequestRenewTime;

    LARGE_INTEGER SourceEndTime;
    LARGE_INTEGER SourceRenewTime;
    LARGE_INTEGER SourceStartTime;
    ULONG SourceTicketFlags = 0;
    ULONG FinalTicketFlags = 0;
    ULONG KdcOptions = 0;

    LARGE_INTEGER FinalEndTime;
    LARGE_INTEGER FinalStartTime;
    LARGE_INTEGER FinalRenewTime;
    BOOLEAN Renewable = FALSE;

    LARGE_INTEGER CurrentTime;

    TRACER(L"KdcBuildTicketTimesAndFlags", (PVOID *) &KerbErr);
    TRACE(KDC, KdcBuildTicketTimesAndFlags, DEB_FUNCTION);

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    FinalEndTime.QuadPart = 0;
    FinalStartTime.QuadPart = 0;
    FinalRenewTime.QuadPart = 0;

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    //
    // Get the request times out of the request
    //

    if (RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_starttime_present)
    {
        //  start time can be present only in postdated ticket
        //  request
        if ((KdcOptions & KERB_KDC_OPTIONS_postdated) == 0)
        {
            KerbErr = KDC_ERR_BADOPTION;
            goto    Cleanup;
        }
        KerbConvertGeneralizedTimeToLargeInt(
            &RequestStartTime,
            &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
            NULL
            );
    }
    else
    {
        RequestStartTime.QuadPart = 0;
    }

    KerbConvertGeneralizedTimeToLargeInt(
        &RequestEndTime,
        &RequestBody->endtime,
        NULL
        );

    if (RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_renew_until_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &RequestRenewTime,
            &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
            NULL
            );
    }
    else
    {
        RequestRenewTime.QuadPart = 0;
    }

    //
    // Get the times out of the source ticket (if present)
    //

    if (ARGUMENT_PRESENT(SourceTicket))
    {
        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &SourceStartTime,
                &SourceTicket->KERB_ENCRYPTED_TICKET_starttime,
                NULL
                );

        }
        else
        {
            SourceStartTime.QuadPart = 0;
        }

        KerbConvertGeneralizedTimeToLargeInt(
            &SourceEndTime,
            &SourceTicket->endtime,
            NULL
            );

        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &SourceRenewTime,
                &SourceTicket->KERB_ENCRYPTED_TICKET_renew_until,
                NULL
                );

        }
        else
        {
            SourceRenewTime.QuadPart = 0;
        }
        SourceTicketFlags = KerbConvertFlagsToUlong(&SourceTicket->flags);
    }
    else
    {
        //
        // Set the maximums in this case, which is probably an AS request.
        //

        SourceStartTime = CurrentTime;
        SourceEndTime = tsInfinity;
        SourceRenewTime = tsInfinity;
        SourceTicketFlags = 0;

        //
        // Fill in the source flags from what the client policy & domain policy
        // allow
        //

        if ((ClientPolicyFlags & KERB_KDB_DISALLOW_FORWARDABLE) == 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_forwardable;
        }
        if ((ClientPolicyFlags & KERB_KDB_DISALLOW_PROXIABLE) == 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_proxiable;
        }
        if ((ClientPolicyFlags & KERB_KDB_DISALLOW_POSTDATED) == 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_may_postdate;
        }
        if ((ClientPolicyFlags & KERB_KDB_DISALLOW_RENEWABLE) == 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_renewable;
        }

    }

    //
    // Start computing the flags, from algorithm in RFC1510 appendix A.6
    //

    //
    // Delegation flags
    //

    if ((ServerPolicyFlags & KERB_KDB_OK_AS_DELEGATE) != 0)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_ok_as_delegate;
    }

    //
    // Forward flags
    //

    if (KdcOptions & KERB_KDC_OPTIONS_forwardable)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_FORWARDABLE) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_forwardable;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for forwardable but not allowed\n"));
//            KerbErr = KDC_ERR_BADOPTION;
//            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_forwarded)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_FORWARDABLE) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_forwarded;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for forwarded but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    if (SourceTicketFlags & KERB_TICKET_FLAGS_forwarded)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_forwarded;
    }

    //
    // preauth flags
    //

    if (SourceTicketFlags & KERB_TICKET_FLAGS_pre_authent)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_pre_authent;
    }

    //  hw-auth flag has to be carried fwd
    if (SourceTicketFlags & KERB_TICKET_FLAGS_hw_authent)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_hw_authent;
    }

    //
    // Proxy flags
    //

    if (KdcOptions & KERB_KDC_OPTIONS_proxiable)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_PROXIABLE) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_proxiable;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for proxiable but not allowed\n"));
//            KerbErr = KDC_ERR_BADOPTION;
//            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_proxy)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_PROXIABLE) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_proxy;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for proxy but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    //
    // Postdate
    //

    if (KdcOptions & KERB_KDC_OPTIONS_allow_postdate)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_POSTDATED) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_may_postdate;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for postdate but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_postdated)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_POSTDATED) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_postdated | KERB_TICKET_FLAGS_invalid;

            //
            // Start time is required here
            //

            if (RequestStartTime.QuadPart == 0)
            {
                DebugLog((DEB_ERROR, "Asked for postdate but start time not present\n"));
                KerbErr = KDC_ERR_CANNOT_POSTDATE;
                goto Cleanup;
            }

        }
        else if ((ServerPolicyFlags & KERB_KDB_DISALLOW_POSTDATED))
        {
            KerbErr = KDC_ERR_POLICY;
        }
        else
        {
            KerbErr = KDC_ERR_BADOPTION;
        }
    }

    //
    // Validate
    //

    if (KdcOptions & KERB_KDC_OPTIONS_validate)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_invalid) == 0)
        {
            DebugLog((DEB_ERROR,"Trying to validate a valid ticket\n"));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }
        if ((SourceStartTime.QuadPart == 0) ||
            (SourceStartTime.QuadPart <
                CurrentTime.QuadPart - pKdcPolicy->TimeSkew.QuadPart))
        {
            DebugLog((DEB_ERROR,"Trying to validate a ticket before it is valid\n"));
            KerbErr = KRB_AP_ERR_TKT_NYV;
            goto Cleanup;
        }
    }

    //
    // Start filling in time fields
    //

    if (ARGUMENT_PRESENT(SourceTicket))
    {
        Ticket->authtime = SourceTicket->authtime;
    }
    else
    {
        KerbConvertLargeIntToGeneralizedTime(
            &Ticket->authtime,
            NULL,
            &CurrentTime
            );

    }

    //
    // The times are computed differently for renewing a ticket and for
    // getting a new ticket.
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_renew) != 0)
    {
        if ((SourceRenewTime.QuadPart == 0) ||
            (SourceStartTime.QuadPart == 0) ||
            ((SourceTicketFlags & KERB_TICKET_FLAGS_renewable) == 0) ||
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_RENEWABLE) != 0))
        {
            DebugLog((DEB_ERROR,"Trying to renew a non-renewable ticket or against policy\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Make sure the renew time is in the future
        //

        if (SourceRenewTime.QuadPart < CurrentTime.QuadPart)
        {
            DebugLog((DEB_ERROR, "Trying to renew a ticket past its renew time\n"));
#ifdef XBOX_KDC
            KerbErr = KDC_ERR_TGT_REVOKED;
#else           
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
#endif
            goto Cleanup;
        }

        //
        // Make sure the end time is in the past
        //

        if (SourceEndTime.QuadPart < CurrentTime.QuadPart)
        {
            DebugLog((DEB_ERROR, "Trying to renew an expired ticket\n"));
#ifdef XBOX_KDC
            KerbErr = KDC_ERR_TGT_REVOKED;
#else           
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
#endif
            goto Cleanup;
        }
        FinalStartTime = CurrentTime;

        //
        // The end time is the minimum of the current time plus lifespan
        // of the old ticket and the renew until time of the old ticket
        //

        FinalEndTime.QuadPart = CurrentTime.QuadPart + (SourceEndTime.QuadPart - SourceStartTime.QuadPart);
        if (FinalEndTime.QuadPart > SourceRenewTime.QuadPart)
        {
            FinalEndTime = SourceRenewTime;
        }
        FinalRenewTime = SourceRenewTime;
        FinalTicketFlags = SourceTicketFlags;

        Renewable = TRUE;
    }
    else
    {
        //
        // Compute start and end times for normal tickets
        //

        //
        // Set the start time
        //

        if (RequestStartTime.QuadPart == 0)
        {
            FinalStartTime = CurrentTime;
        }
        else
        {
            FinalStartTime = RequestStartTime;
        }

        //
        // Set the end time
        //

        if (RequestEndTime.QuadPart == 0)
        {
            FinalEndTime = tsInfinity;
        }
        else
        {
            FinalEndTime = RequestEndTime;
        }

        if (FinalEndTime.QuadPart > SourceEndTime.QuadPart)
        {
            FinalEndTime = SourceEndTime;
        }

        if (FinalEndTime.QuadPart > CurrentTime.QuadPart + MaxTicketLifespan->QuadPart)
        {
            FinalEndTime.QuadPart = CurrentTime.QuadPart + MaxTicketLifespan->QuadPart;
        }

        //
        // Check for renewable-ok
        //

        if ((KdcOptions & KERB_KDC_OPTIONS_renewable_ok) &&
            (FinalEndTime.QuadPart < RequestEndTime.QuadPart) &&
            (SourceTicketFlags & KERB_TICKET_FLAGS_renewable))
        {
            KdcOptions |= KERB_KDC_OPTIONS_renewable;
            RequestRenewTime = RequestEndTime;

            //
            // Make sure that the source ticket had a renewtime (it
            // should because it is renewable)
            //

            DsysAssert(SourceRenewTime.QuadPart != 0);
            if (RequestRenewTime.QuadPart > SourceRenewTime.QuadPart)
            {
                RequestRenewTime = SourceRenewTime;
            }
        }
    }

    if (!Renewable)
    {
        //
        // Compute renew times
        //

        if (RequestRenewTime.QuadPart == 0)
        {
            RequestRenewTime = tsInfinity;
        }

        if ((KdcOptions & KERB_KDC_OPTIONS_renewable) &&
            (SourceTicketFlags & KERB_TICKET_FLAGS_renewable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_RENEWABLE) == 0))
        {
            FinalRenewTime = RequestRenewTime;
            if (FinalRenewTime.QuadPart > FinalStartTime.QuadPart + MaxTicketRenewspan->QuadPart)
            {
                FinalRenewTime.QuadPart = FinalStartTime.QuadPart + MaxTicketRenewspan->QuadPart;
            }

            DsysAssert(SourceRenewTime.QuadPart != 0);

            if (FinalRenewTime.QuadPart > SourceRenewTime.QuadPart)
            {
                FinalRenewTime = SourceRenewTime;
            }
            FinalTicketFlags |= KERB_TICKET_FLAGS_renewable;

        }
        else
        {
            FinalRenewTime.QuadPart = 0;
        }
    }

    //
    // Make sure the final ticket is valid
    //

    if (FinalStartTime.QuadPart > FinalEndTime.QuadPart)
    {
        DebugLog((DEB_ERROR,"Client asked for endtime before starttime\n"));
        KerbErr = KDC_ERR_BADOPTION;

        FILL_EXT_ERROR_EX(ExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Don't bother with this check - it doesn't really hurt to have a
    // renew time less than an end time
    //
//
//    if ((FinalRenewTime.QuadPart != 0) &&
//        (FinalRenewTime.QuadPart < FinalEndTime.QuadPart))
//    {
//        DebugLog((DEB_ERROR,"Client asked for renew time before endtime\n"));
//        KerbErr = KDC_ERR_BADOPTION;
//        goto Cleanup;
//    }
//

    //
    // Incorporate the logoff time (according to logon hours) by reseting
    // both the final end time and final renew time
    //

    //
    //  Tickets good only until acct expires.
    //  We make the assumption that the sam has
    //  already checked this against the current time
    //  when we're checking the logon restrictions.
    //
    if ((ARGUMENT_PRESENT(AccountExpiry) &&
         (AccountExpiry->QuadPart != KERB_KDB_TIME_NEVER)))
    {
        if (FinalEndTime.QuadPart > AccountExpiry->QuadPart)
        {
            FinalEndTime.QuadPart = AccountExpiry->QuadPart;
        }


        if (FinalRenewTime.QuadPart > AccountExpiry->QuadPart)
        {
            FinalRenewTime.QuadPart = AccountExpiry->QuadPart;
        }

    }


    //
    // Fill in the times in the ticket
    //

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->KERB_ENCRYPTED_TICKET_starttime,
        NULL,
        &FinalStartTime
        );
    Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_starttime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->endtime,
        NULL,
        &FinalEndTime
        );

    if (FinalRenewTime.QuadPart != 0)
    {
        KerbConvertLargeIntToGeneralizedTime(
            &Ticket->KERB_ENCRYPTED_TICKET_renew_until,
            NULL,
            &FinalRenewTime
            );
        Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_renew_until_present;


    }

    //
    // Copy in the flags
    //

    DsysAssert(Ticket->flags.length == sizeof(ULONG) * 8);
    *((PULONG) Ticket->flags.value) = KerbConvertUlongToFlagUlong(FinalTicketFlags);
Cleanup:
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateCredentials
//
//  Synopsis:   Copies a set of credentials (passwords)
//
//  Effects:    allocates output with MIDL_user_allocate
//
//  Arguments:  NewCredentials - recevies new set of credentials
//              OldCredentials - contains credentials to copy
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcDuplicateCredentials(
    OUT PKERB_STORED_CREDENTIAL * NewCredentials,
    OUT PULONG ReturnCredentialSize,
    IN PKERB_STORED_CREDENTIAL OldCredentials,
    IN BOOLEAN MarshallKeys
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_STORED_CREDENTIAL Credential = NULL;
    ULONG CredentialSize;
    USHORT Index;
    PBYTE Where;
    LONG_PTR Offset;

    TRACE(KDC, KdcDuplicateCredentials, DEB_FUNCTION);
    TRACER(L"KdcDuplicateCredentials", (PVOID *) &KerbErr);

    //
    // If there were no credentials, so be it. We can live with that.
    //

    if (OldCredentials == NULL)
    {
        *NewCredentials = NULL;
        goto Cleanup;
    }

    //
    // Calculate the size of the new credentials by summing the size of
    // the base structure plus the keys
    //

    CredentialSize = sizeof(KERB_STORED_CREDENTIAL)
                        - ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)
                        + OldCredentials->CredentialCount * sizeof(KERB_KEY_DATA)
                        + OldCredentials->DefaultSalt.Length;
    for ( Index = 0;
          Index < OldCredentials->CredentialCount;
          Index++ )
    {
        CredentialSize += OldCredentials->Credentials[Index].Key.keyvalue.length +
                          OldCredentials->Credentials[Index].Salt.Length;
    }

    //
    // Allocate the new credential and copy over the old credentials
    //


    Credential = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(CredentialSize);
    if (Credential == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Credential->CredentialCount = OldCredentials->CredentialCount;

    //
    // Set the offset for data to be after the last array element
    //

    memcpy(
        &Credential->Credentials[0],
        &OldCredentials->Credentials[0],
        OldCredentials->CredentialCount * sizeof(KERB_KEY_DATA)
        );

    Where = (PBYTE) &Credential->Credentials[Credential->CredentialCount];

    if (MarshallKeys)
    {
        Offset = (LONG_PTR) Credential;
    }
    else
    {
        Offset = 0;
    }

    Credential->DefaultSalt = OldCredentials->DefaultSalt;
    if (Credential->DefaultSalt.Buffer != NULL)
    {
        Credential->DefaultSalt.Buffer = (LPWSTR) (Where - Offset);
        memcpy(
            Where,
            OldCredentials->DefaultSalt.Buffer,
            Credential->DefaultSalt.Length
            );
        Where +=  Credential->DefaultSalt.Length;
    }

    for ( Index = 0;
          Index < OldCredentials->CredentialCount;
          Index++ )
    {
        Credential->Credentials[Index] = OldCredentials->Credentials[Index];
        Credential->Credentials[Index].Key.keyvalue.value = (Where - Offset);
        memcpy(
            Where,
            OldCredentials->Credentials[Index].Key.keyvalue.value,
            OldCredentials->Credentials[Index].Key.keyvalue.length
            );
        Where += OldCredentials->Credentials[Index].Key.keyvalue.length;

        if (Credential->Credentials[Index].Salt.Buffer != NULL)
        {
            Credential->Credentials[Index].Salt.Buffer = (LPWSTR) (Where - Offset);

            memcpy(
                Where,
                OldCredentials->Credentials[Index].Salt.Buffer,
                OldCredentials->Credentials[Index].Salt.Length
                );
            Where += OldCredentials->Credentials[Index].Salt.Length;
        }
    }
    DsysAssert(Where - (PUCHAR) Credential == (LONG) CredentialSize);

    *NewCredentials = Credential;
    Credential = NULL;
    *ReturnCredentialSize = CredentialSize;

Cleanup:
    if (Credential != NULL)
    {
        MIDL_user_free(Credential);
    }
    return(KerbErr);
}


//--------------------------------------------------------------------
//
//  Name:       BuildReply
//
//  Synopsis:   Extracts reply information from an internal ticket
//
//  Arguments:  pkitTicket  - (in) ticket data comes from
//              dwNonce     - (in) goes into the reply
//              pkrReply    - (out) reply that is built
//
//  Notes:      BUG 456265: Need to set tsKeyExpiry properly.
//              See 3.1.3, 3.3.3 of the Kerberos V5 R5.2 spec
//              tsKeyExpiry is zero for GetTGSTicket, and the
//              expiry time of the client's key for GetASTicket.
//
//--------------------------------------------------------------------

KERBERR
BuildReply(
    IN OPTIONAL PIKerbPrincipal ClientInfo,
    IN ULONG Nonce,
    IN PKERB_PRINCIPAL_NAME ServerName,
    IN KERB_REALM ServerRealm,
    IN PKERB_HOST_ADDRESSES HostAddresses,
    IN PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY ReplyMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;
    KERB_ENCRYPTED_KDC_REPLY ReplyBody;
    LARGE_INTEGER CurrentTime;

    TRACE(KDC, BuildReply, DEB_FUNCTION);
    TRACER(L"BuildReply", (PVOID *) &KerbErr);

    ZeroMemory(
        &ReplyBody,
        sizeof(KERB_ENCRYPTED_KDC_REPLY)
        );

    //
    // Use the same flags field
    //

    ReplyBody.flags = ReplyMessage->flags;



    ReplyBody.session_key = EncryptedTicket->key;


    ReplyBody.last_request = (PKERB_LAST_REQUEST) MIDL_user_allocate(sizeof(KERB_LAST_REQUEST));
    if (ReplyBody.last_request == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ZeroMemory(
        ReplyBody.last_request,
        sizeof(KERB_LAST_REQUEST)
        );

    ReplyBody.last_request->next = NULL;
    ReplyBody.last_request->value.last_request_type = 0;
    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    KerbConvertLargeIntToGeneralizedTime(
        &ReplyBody.last_request->value.last_request_value,
        NULL,           // no usec
        &CurrentTime
        );

    ReplyBody.nonce = Nonce;

    DsysAssert((ReplyBody.flags.length == EncryptedTicket->flags.length) &&
               (ReplyBody.flags.length== 8 * sizeof(ULONG)));

    //
    // Assign the flags over
    //

    *((PULONG)ReplyBody.flags.value) = *((PULONG)EncryptedTicket->flags.value);

    if (ARGUMENT_PRESENT(ClientInfo) &&
    ClientInfo->Expiration().QuadPart != KERB_KDB_TIME_NEVER)
    {
        LARGE_INTEGER Exp =  ClientInfo->Expiration();
        KerbConvertLargeIntToGeneralizedTime(
            &ReplyBody.key_expiration,
            NULL,
            &Exp);
        ReplyBody.bit_mask |= key_expiration_present;
    }


    //
    // Fill in the times
    //


    ReplyBody.authtime = EncryptedTicket->authtime;
    ReplyBody.endtime = EncryptedTicket->endtime;

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_starttime =
            EncryptedTicket->KERB_ENCRYPTED_TICKET_starttime;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_starttime_present;

    }

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_renew_until =
            EncryptedTicket->KERB_ENCRYPTED_TICKET_renew_until;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_renew_until_present;
    }

    ReplyBody.server_realm = ServerRealm;

    ReplyBody.server_name = *ServerName;

    //
    // Fill in the host addresses
    //


    if (HostAddresses != NULL)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_client_addresses = HostAddresses;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_client_addresses_present;
    }

    *ReplyMessage = ReplyBody;
Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (ReplyBody.last_request != NULL)
        {
            MIDL_user_free(ReplyBody.last_request);
            ReplyBody.last_request = NULL;
        }

    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeInternalTicket
//
//  Synopsis:   frees a constructed ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeInternalTicket(
    IN PKERB_TICKET Ticket
    )
{
    PKERB_ENCRYPTED_TICKET EncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;

    TRACE(KDC, KdcFreeInternalTicket, DEB_FUNCTION);
    TRACER(L"KdcAtqRetrySocketRead", NULL);

    if (EncryptedTicket != NULL)
    {
        KerbFreeKey(
            &EncryptedTicket->key
            );
        KerbFreePrincipalName(&EncryptedTicket->client_name);
        if (EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL)
        {
            KerbFreeAuthData(EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data);
        }
        if (EncryptedTicket->transited.contents.value != NULL)
        {
            MIDL_user_free(EncryptedTicket->transited.contents.value);
        }
    }


    KerbFreePrincipalName(
        &Ticket->server_name
        );

    KerbFreeRealm(
        &Ticket->realm
        );

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcReply
//
//  Synopsis:   frees a kdc reply
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeKdcReply(
    IN PKERB_KDC_REPLY Reply
    )
{
    TRACE(KDC, KdcFreeKdcReply, DEB_FUNCTION);
    TRACER(L"KdcFreeKdcReply", NULL);

    KerbFreePrincipalName(&Reply->ticket.server_name);

    KerbFreeRealm(&Reply->ticket.realm);

    if (Reply->ticket.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->ticket.encrypted_part.cipher_text.value);
    }

    if (Reply->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->encrypted_part.cipher_text.value);
    }
    if (Reply->KERB_KDC_REPLY_preauth_data != NULL)
    {
        KerbFreePreAuthData((PKERB_PA_DATA_LIST) Reply->KERB_KDC_REPLY_preauth_data);
    }


}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcReplyBody
//
//  Synopsis:   frees a constructed KDC reply body
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcFreeKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody
    )
{

    TRACE(KDC, KdcFreeKdcReplyBody, DEB_FUNCTION);
    TRACER(L"KdcFreeKdcReplyBody", NULL);
    //
    // The names & the session key are just pointers into the ticket,
    // so they don't need to be freed.
    //

    if (ReplyBody->last_request != NULL)
    {
        MIDL_user_free(ReplyBody->last_request);
        ReplyBody->last_request = NULL;
    }
    ReplyBody->KERB_ENCRYPTED_KDC_REPLY_client_addresses = NULL;

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyClientAddress
//
//  Synopsis:   Verifies that the client address is an allowed sender of
//              the KDC request.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KdcVerifyClientAddress(
    IN SOCKADDR * ClientAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    TRACER(L"KdcVerifyClientAddress", NULL);

    PKERB_HOST_ADDRESSES TempAddress = Addresses;

    //
    // ISSUE-2001/03/05-markpu
    // This routine is wholly inadequate in that it only deals with IPv4
    // addresses.  Address matching has to be more elaborate than that
    //

    while (TempAddress != NULL)
    {
        if ( TempAddress->value.address_type == KERB_ADDRTYPE_INET &&
             ClientAddress->sa_family == AF_INET )
        {
            struct sockaddr_in * InetAddress = (struct sockaddr_in *) ClientAddress;

            //
            // Check that the addresses match
            //

            if (TempAddress->value.address.length == sizeof(ULONG))
            {
                if (!memcmp(
                        TempAddress->value.address.value,
                        &InetAddress->sin_addr.S_un.S_addr,
                        sizeof(ULONG)
                        ))
                {
                    return(KDC_ERR_NONE);
                }
            }

        }

        TempAddress = TempAddress->next;
    }

    D_DebugLog((DEB_WARN,"Client address not in address list\n"));

    //
    // Need to return KRB_AP_ERR_BADADDR but a couple of things must
    // be fixed first (client code notified of changes to the machine's IP
    // address, copying addresses from the TGT into the TGS request)
    //

    return(KDC_ERR_NONE);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyTgsChecksum
//
//  Synopsis:   Verify the checksum on a TGS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyTgsChecksum(
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_CHECKSUM OldChecksum
    )
{
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    KERB_MESSAGE_BUFFER MarshalledRequestBody = {0, NULL};
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_CHECKSUM Checksum = {0};

    TRACER(L"KdcVerifyTgsChecksum", (PVOID *) &KerbErr);

    Status = CDLocateCheckSum(
                OldChecksum->checksum_type,
                &ChecksumFunction
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Allocate enough space for the checksum
    //

    Checksum.checksum.value = (PUCHAR) MIDL_user_allocate(ChecksumFunction->CheckSumSize);
    if (Checksum.checksum.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    Checksum.checksum.length = ChecksumFunction->CheckSumSize;

    //
    // Initialize the checksum
    //

    if ((OldChecksum->checksum_type == KERB_CHECKSUM_REAL_CRC32) ||
        (OldChecksum->checksum_type == KERB_CHECKSUM_CRC32))
    {
        if (ChecksumFunction->Initialize)
        {
            Status = ChecksumFunction->Initialize(
                        0,
                        &CheckBuffer
                        );
            }
        else
        {

            KerbErr = KRB_ERR_GENERIC;
        }
    }
    else
    {
        if (NULL != ChecksumFunction->InitializeEx2)
        {
            Status = ChecksumFunction->InitializeEx2(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        OldChecksum->checksum.value,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else if (ChecksumFunction->InitializeEx)
        {
            Status = ChecksumFunction->InitializeEx(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbPackData(
                        RequestBody,
                        KERB_MARSHALLED_REQUEST_BODY_PDU,
                        &MarshalledRequestBody.BufferSize,
                        &MarshalledRequestBody.Buffer
                        );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now checksum the buffer
    //

    ChecksumFunction->Sum(
        CheckBuffer,
        MarshalledRequestBody.BufferSize,
        MarshalledRequestBody.Buffer
        );

    ChecksumFunction->Finalize(
        CheckBuffer,
        Checksum.checksum.value
        );

    //
    // Now compare
    //

    if ((OldChecksum->checksum.length != Checksum.checksum.length) ||
        memcmp(
            OldChecksum->checksum.value,
            Checksum.checksum.value,
            Checksum.checksum.length
            ))
    {
        DebugLog((DEB_ERROR,"Checksum on TGS request body did not match\n"));
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

Cleanup:
    if (CheckBuffer != NULL)
    {
        ChecksumFunction->Finish(&CheckBuffer);
    }
    if (MarshalledRequestBody.Buffer != NULL)
    {
        MIDL_user_free(MarshalledRequestBody.Buffer);
    }
    if (Checksum.checksum.value != NULL)
    {
        MIDL_user_free(Checksum.checksum.value);
    }
    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyKdcRequest
//
//  Synopsis:   Verifies that the AP request accompanying a TGS or PAC request
//              is valid.
//
//  Effects:
//
//  Arguments:  ApRequest - The AP request to verify
//              UnmarshalledRequest - The unmarshalled request,
//                      returned to avoid needing to
//              EncryptedTicket - Receives the ticket granting  ticket
//              SessionKey - receives the key to use in the reply
//
//  Requires:
//
//  Returns:    kerberos errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcVerifyKdcRequest(
    IN PIKdbProvider piKdb,
    IN CKerbRequest*    pKdcReq,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN OPTIONAL SOCKADDR * ClientAddress,
    IN BOOLEAN IsKdcRequest,
    OUT OPTIONAL PKERB_AP_REQUEST * UnmarshalledRequest,
    OUT OPTIONAL PKERB_AUTHENTICATOR * UnmarshalledAuthenticator,
    OUT PKERB_ENCRYPTED_TICKET *EncryptedTicket,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PIKerbPrincipal *RetServerInfo,
    OUT PBOOLEAN UseSubKey,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    PIKerbPrincipal ServerInfo = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AP_REQUEST Request = NULL;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    PKERB_INTERNAL_NAME ServerName = NULL;
    UNICODE_STRING ServerRealm = {0};
    //NTSTATUS    Status = STATUS_SUCCESS;

    TRACE(KDC, KdcVerifyKdcRequest, DEB_FUNCTION);
    TRACER(L"KdcVerifyKdcRequest", (PVOID *) &KerbErr);

    *RetServerInfo = NULL;

    ServerRealm.Buffer = NULL;


    //
    // First unpack the KDC request.
    //

    KerbErr = KerbUnpackApRequest(
                RequestMessage,
                RequestSize,
                &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unpack KDC request: 0x%x\n",KerbErr));
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto Cleanup;
    }

    //  check version and msg type
    if (Request->version != KERBEROS_VERSION)
    {
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto    Cleanup;
    }
    if (Request->message_type != KRB_AP_REQ)
    {
        KerbErr = KRB_AP_ERR_MSG_TYPE;
        goto    Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ServerName,
                &Request->ticket.server_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertRealmToUnicodeString(
                &ServerRealm,
                &Request->ticket.realm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;

    }

    KerbErr = KerbProcessPaCompoundIdentity(pKdcReq, pExtendedError);
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;

    }

    //
    // Get ticket info for the server
    //

    KerbErr = piKdb->GetPrincipal(
    KDC_KDB_GET_PRINC_SERVER | KDC_KDB_GET_PRINC_TRUST_INBOUND,
                  ServerName,
                  ServerRealm.Buffer,
                  pKdcReq,
                  &ServerInfo,
                  //&Status,
                  pExtendedError,
                  NULL
                 );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "Trying to get TGS ticket to service in another realm: "));
        KerbPrintKdcName(DEB_WARN, ServerName);
        goto Cleanup;
    }


    //
    // Now Check the ticket
    //


    //
    // We don't need to supply a service name or service because we've looked up
    // the account locally.
    //

    KerbErr = KerbCheckTicket(
                pKdcReq,
                &Request->ticket,
                &Request->authenticator,
                ServerInfo,
                Authenticators,
                &piKdb->GetKdcPolicy()->TimeSkew,
                0,                      // zero service names
                NULL,                   // any service
                NULL,
                FALSE,                  // don't check for replay
                IsKdcRequest,
                &EncryptPart,
                &Authenticator,
                NULL,
                SessionKey,
                UseSubKey,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to check ticket : 0x%x for",KerbErr));
        KerbPrintKdcName(DEB_ERROR,ServerName );


        //
        //  Here's the case where we're trying to use an expired TGT.  Have
        // the client retry using a new TGT
        //
#ifdef XBOX_KDC
        if (KerbErr == KRB_AP_ERR_TKT_EXPIRED || KerbErr == KDC_ERR_TGT_REVOKED)
#else           
        if (KerbErr == KRB_AP_ERR_TKT_EXPIRED)
#endif          
        {
            FILL_EXT_ERROR_EX(pExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        }

        goto Cleanup;
    }

    //
    // Verify the address from the ticket
    //

    if ((EncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) &&
        ARGUMENT_PRESENT(ClientAddress))

    {
        ULONG TicketFlags = KerbConvertFlagsToUlong(&EncryptPart->flags);

        //
        // Only check initial tickets
        //

        if ((TicketFlags & (KERB_TICKET_FLAGS_forwarded | KERB_TICKET_FLAGS_proxy)) == 0)
        {
            KerbErr = KdcVerifyClientAddress(
                        ClientAddress,
                        EncryptPart->KERB_ENCRYPTED_TICKET_client_addresses
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"Client sent request with wrong address\n"));
                goto Cleanup;
            }
        }
    }

    //
    // Verify that if the server is a trusted domain account, that it is an
    // acceptable ticket (transitively). Verify that for non transitive
    // trust the client realm is the same as the requesting ticket realm
    //

    *EncryptedTicket = EncryptPart;
    EncryptPart = NULL;
    if (ARGUMENT_PRESENT(UnmarshalledRequest))
    {
        *UnmarshalledRequest = Request;
        Request = NULL;
    }
    if (ARGUMENT_PRESENT(UnmarshalledAuthenticator))
    {
        *UnmarshalledAuthenticator = Authenticator;
        Authenticator = NULL;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        //  do we really need to free it
        //  or save it in the req.
        if (ServerInfo)
            ServerInfo->Release();
    }
    else
    *RetServerInfo = ServerInfo;

    KerbFreeApRequest(Request);
    KerbFreeKdcName(&ServerName);
    KerbFreeString(&ServerRealm);
    KerbFreeAuthenticator(Authenticator);
    KerbFreeTicket(EncryptPart);

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   EnterApiCall
//
//  Synopsis:   Makes sure that the KDC service is initialized and running
//              and won't terminate during the call.
//
//  Effects:    increments the CurrentApiCallers count.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_INVALID_SERVER_STATE - the KDC service is not
//                      running
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
EnterApiCall(
    VOID
    )
{
    NTSTATUS hrRet = STATUS_SUCCESS;
    EnterCriticalSection(&ApiCriticalSection);
    if (KdcState != Stopped)
    {
        CurrentApiCallers++;
    }
    else
    {
        hrRet = STATUS_INVALID_SERVER_STATE;
    }
    LeaveCriticalSection(&ApiCriticalSection);
    return(hrRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   LeaveApiCall
//
//  Synopsis:   Decrements the count of active calls and if the KDC is
//              shutting down sets an event to let it continue.
//
//  Effects:    Deccrements the CurrentApiCallers count.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
LeaveApiCall(
    VOID
    )
{
    EnterCriticalSection(&ApiCriticalSection);
    CurrentApiCallers--;

    if (KdcState == Stopped)
    {
        if (CurrentApiCallers == 0)
        {
            if (!SetEvent(hKdcShutdownEvent))
            {
                D_DebugLog((DEB_ERROR,"Failed to set shutdown event from LeaveApiCall: 0x%d\n",GetLastError()));
            }
            else
            {
                UpdateStatus(SERVICE_STOP_PENDING);
            }

            //
            // Free any DS libraries in use
            //

            SecData.Cleanup();
#ifdef KDC_WMI_TRACING
            if (KdcTraceRegistrationHandle != (TRACEHANDLE)0)
            {
                UnregisterTraceGuids( KdcTraceRegistrationHandle );
            }
#endif
        }

    }
    LeaveCriticalSection(&ApiCriticalSection);
}


NTSTATUS
KdcBuildEtypeStringFromStoredCredential(
    IN PKERB_STORED_CREDENTIAL Cred,
    IN OUT PWSTR * EtypeString
    )
{

    ULONG BuffSize;
    PWSTR Ret = NULL;
    WCHAR Buff[12];
    TRACER(L"KdcBuildEtypeStringFromStoredCredential", NULL);

    *EtypeString = NULL;


    if (Cred == NULL
         || (Cred->CredentialCount == 0))
    {
        BuffSize = (ULONG) sizeof(WCHAR) * (ULONG) (wcslen(WSZ_NO_KEYS)+1);
        *EtypeString = (LPWSTR)MIDL_user_allocate(BuffSize);

        if (NULL == *EtypeString)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        wcscpy(*EtypeString, WSZ_NO_KEYS);

        return STATUS_SUCCESS;
    }

    // Guess maximum buffer... Etypes are 4 chars at most
    BuffSize = (Cred->CredentialCount* MAX_ETYPE_STRING);
    Ret = (LPWSTR)MIDL_user_allocate(BuffSize);
    if (NULL == Ret)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *Ret = L'\0';
    for (LONG Index = 0;Index < Cred->CredentialCount; Index++ )
    {
        if (Cred->Credentials[Index].Key.keytype > MAX_ETYPE_LONG ||
            Cred->Credentials[Index].Key.keytype < MIN_ETYPE_LONG)
        {
            DebugLog((DEB_ERROR, "Keytype too large for string conversion\n"));
            DsysAssert(FALSE);
        }
        else
        {
            _itow(Cred->Credentials[Index].Key.keytype, Buff, 10);
            wcscat(Ret, Buff);
            wcscat(Ret, L"  ");
        }
    }
    *EtypeString = Ret;
    return STATUS_SUCCESS;
}

NTSTATUS
KdcBuildEtypeStringFromCryptList(
    IN PKERB_CRYPT_LIST CryptList,
    IN OUT LPWSTR * EtypeString
    )
{

    ULONG BuffSize = 0;
    PWSTR Ret = NULL;
    WCHAR Buff[30];

    TRACER(L"KdcBuildEtypeStringFromCryptList", NULL);

    PKERB_CRYPT_LIST ListPointer = CryptList;

    *EtypeString = NULL;


    if (CryptList == NULL)
    {
        BuffSize = (ULONG) sizeof(WCHAR) * (ULONG) (wcslen(WSZ_NO_KEYS)+1);
        *EtypeString = (LPWSTR)MIDL_user_allocate(BuffSize);

        if (NULL == *EtypeString)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        wcscpy(*EtypeString, WSZ_NO_KEYS);

        return STATUS_SUCCESS;
    }

    while (TRUE)
    {
        if (ListPointer->value > MAX_ETYPE_LONG || ListPointer->value < MIN_ETYPE_LONG)
        {
           DebugLog((DEB_ERROR, "Maximum etype exceeded\n"));
           return STATUS_INVALID_PARAMETER;
        }

        BuffSize += MAX_ETYPE_STRING;
        if (NULL == ListPointer->next)
        {
            break;
        }
        ListPointer = ListPointer->next;

    }

    Ret = (LPWSTR) MIDL_user_allocate(BuffSize);
    if (NULL == Ret)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *Ret = L'\0';
    while (TRUE)
    {
        _itow(CryptList->value, Buff, 10);
        wcscat(Ret,Buff);
        wcscat(Ret, L"  ");
        if (NULL == CryptList->next)
        {
            break;
        }

        CryptList = CryptList->next;

    }

    *EtypeString = Ret;

    return STATUS_SUCCESS;
}

void
KdcReportKeyError(
    IN PIKdbProvider KdbHandle,
    IN PKERB_INTERNAL_NAME ClientName,
    IN OPTIONAL PUNICODE_STRING ClientRealm,
    IN OPTIONAL PKERB_INTERNAL_NAME ServerName,
    IN OPTIONAL PUNICODE_STRING ServerRealm,
    IN ULONG EventId,
    IN OPTIONAL PKERB_CRYPT_LIST RequestEtypes
    //  actuall keys are not available. If necessary
    //  call the corresponding log/trace method in the provider
//    IN OPTIONAL PKERB_STORED_CREDENTIAL StoredCredential
    )
{
    ULONG NumberOfStrings;
    NTSTATUS Status;
    PWSTR Strings[ 4 ] = {NULL,NULL,NULL,NULL};
    PWSTR RequestEtypeString = NULL;
    PWSTR AccountNameEtypeString = NULL;
    UNICODE_STRING ClientString = {0};
    UNICODE_STRING ServerString = {0};

    TRACER(L"KdcReportKeyError", NULL);

    KerbConvertKdcNameToString(
    &ClientString,
    ClientName,
    ClientRealm
    );

    if (ARGUMENT_PRESENT(ServerName))
    {
    KerbConvertKdcNameToString(
        &ServerString,
        ServerName,
        ServerRealm
        );
    }

    Status = KdcBuildEtypeStringFromCryptList(
                    RequestEtypes,
                    &RequestEtypeString
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcBuildEtypeFromCryptList failed\n"));
        goto cleanup;
    }

#if 0
    Status = KdcBuildEtypeStringFromStoredCredential(
                    StoredCredential,
                    &AccountNameEtypeString
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcBuildEtypeFromStoredCredential failed\n"));
        goto cleanup;
    }
#endif

    if (EventId == KDCEVENT_NO_KEY_UNION_AS )
    {
        Strings[0] = ClientString.Buffer;
        Strings[1] = RequestEtypeString;
        Strings[2] = AccountNameEtypeString;
        NumberOfStrings = 3;
    }
    else if (EventId == KDCEVENT_NO_KEY_UNION_TGS )
    {
        if (!ARGUMENT_PRESENT(ServerName))
        {
            DebugLog((DEB_ERROR, "Invalid arg to KdcReportKeyError!\n"));
            DsysAssert(FALSE);
            goto cleanup;
        }
        Strings[0] = ServerString.Buffer;
        Strings[1] = ClientString.Buffer;
        Strings[2] = RequestEtypeString;
        Strings[3] = AccountNameEtypeString;
        NumberOfStrings = 4;

    }
    else
    {
        goto cleanup;
    }

    KdbReportEventW(
        IEvent::ERROR_TYPE,
        EventId,
        0,
        NULL,
        NumberOfStrings,
        Strings[0],
        Strings[1],
        Strings[2],
        Strings[3]
    );

cleanup:
    KerbFreeString(&ClientString);
    KerbFreeString(&ServerString);

    if (NULL != RequestEtypeString )
    {
        MIDL_user_free(RequestEtypeString);
    }

    if (NULL != AccountNameEtypeString )
    {
        MIDL_user_free(AccountNameEtypeString);
    }

    return;

}

BOOLEAN
KdcIsKrbtgt(
    IN const KERB_INTERNAL_NAME * Name
    )
{
    return ((Name->NameType == KRB_NT_SRV_INST) &&
            (Name->NameCount == 2) &&
            (RtlEqualUnicodeString(&Name->Names[0], &KrbtgtName, FALSE)));
}

#if DBG

void
PrintRequest( ULONG ulDebLevel, PKERB_KDC_REQUEST_BODY Request )
{
    TRACE(KDC, PrintRequest, DEB_FUNCTION);
}

void
PrintTicket( ULONG ulDebLevel,
             char * pszMessage,
             PKERB_TICKET pkitTicket)
{
    TRACE(KDC, PrintTicket, DEB_FUNCTION);
}

#endif // DBG

//+---------------------------------------------------------------------------
//
//  Function:   KerbProcessPaCompoundIdentity
//
//  Synopsis:   searches for PA-Compound-Identity and if found,
//              instantiatiates a handler to process it
//
//  Arguments:  [pKdcReq]    -- (in, out) ptr to kdc request
//
//  History:    11-15-01   yordanr   Created
//
//  remarks:    ptr to this PA handler is saved in the request for
//              future use
//
//----------------------------------------------------------------------------

KERBERR
KerbProcessPaCompoundIdentity(CKerbRequest *pKdcReq,
                              PKERB_EXT_ERROR pExtErr)
{
    PKERB_KDC_REQUEST_preauth_data pPAData = pKdcReq->m_pKdcRequest->preauth_data;

    while (pPAData)
    {
        if (pPAData->value.preauth_data_type == KRB5_PADATA_COMPOUND_IDENTITY )
            break;
        pPAData = pPAData->next;
    }
    if (pPAData)
    {
        IPAHandler *piPA = NULL;
        if (!NT_SUCCESS(
            pKdcReq->GetPAHandler(pPAData->value.preauth_data_type, &piPA)
            ))
        {
            DsysAssert(FALSE);
            return  KDC_ERR_PREAUTH_FAILED;
        }
        //  save the handler in the request for easier access later on
        piPA->QueryInterface(IID_IPAIdentity, (PVOID*)&pKdcReq->m_piCompId);

        //  have the PA handler process the data
        BOOLEAN fSuff;
        return  piPA->Check(pKdcReq,
                           pPAData,
                           //   no enc key
                           NULL,
                           //   no output
                           NULL,
                           &fSuff,
                           pExtErr);

    }

    //  no PA Identity data is ok
    return  KDC_ERR_NONE;
}


NTSTATUS
NTAPI
KerbComputePaCompIdentityKeyForPrincipal(
    IN ULONG                      etype,
    IN IKerbRequest*              pIKdcReq,
    OUT KERB_ENCRYPTION_KEY**     ppNewKey,
    IN ULONG                      cKeys,
    IN const KERB_ENCRYPTION_KEY  *ppPAKeys
    )
{
    CTYPE ctype;
    NTSTATUS Status;
    KERB_EXT_ERROR  ExtendedError = {0,0};
    PIKerbPrincipal pIPrinc = pIKdcReq->GetIPrincClient();
    PBYTE pHmacBuffer = NULL;
    ULONG ulHmacBufferSize;
    ULONG iKey;
    ULONG ulTotalKeyLen;
    ULONG* rgcbBuffers = NULL;
    PBYTE* rgpbBuffers;
    PBYTE pConcatKeys = NULL;
    PBYTE p;
    PCHECKSUM_FUNCTION pcsChecksum = NULL;
    PCRYPTO_SYSTEM  pCSystem = NULL;
    PKERB_ENCRYPTION_KEY pKey = NULL;
    
    //
    //  figure out what chksum type to use
    //

    switch (etype)
    {
    //  hmac for DES types
    case KERB_ETYPE_DES_CBC_MD5_NT:
    case KERB_ETYPE_DES_CBC_CRC:
    case KERB_ETYPE_DES_CBC_MD4:
    case KERB_ETYPE_DES_CBC_MD5:
        ctype = (CTYPE)KERB_CHECKSUM_MD5_DES;
        break;
    default:
        //  anything else is rc4_md5
        ctype = (CTYPE)KERB_CHECKSUM_HMAC_MD5;
    }

    Status = CDLocateCSystem(etype, &pCSystem);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    Status = CDLocateCheckSum(
                 ctype,
                 &pcsChecksum
                 );
    if ( !NT_SUCCESS( Status ))
    {
        goto Error;
    }

    //
    //  now check if the chksum size is big enough
    //
    if (pcsChecksum->CheckSumSize < pCSystem->KeySize)
    {
        DsysAssert(FALSE);
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    // alloc various buffers on the stack
    ulHmacBufferSize = pcsChecksum->CheckSumSize;
    pHmacBuffer = (PBYTE)_alloca(ulHmacBufferSize);

    rgcbBuffers = (ULONG*)_alloca(cKeys * sizeof(ULONG));
    rgpbBuffers = (PBYTE*)_alloca(cKeys * sizeof(PBYTE));
    ulTotalKeyLen = 0;
    for (iKey = 0; iKey < cKeys; iKey++)
    {
        rgcbBuffers[iKey] = ppPAKeys[iKey].keyvalue.length;
        ulTotalKeyLen += ppPAKeys[iKey].keyvalue.length;
    }

    pConcatKeys = (PBYTE)_alloca(ulTotalKeyLen);
    p = pConcatKeys;
    for (iKey = 0; iKey < cKeys; iKey++)
    {
        memcpy(p, ppPAKeys[iKey].keyvalue.value, rgcbBuffers[iKey]);
        rgpbBuffers[iKey] = p;
        p += rgcbBuffers[iKey];
    }

    Status = pIPrinc->Checksum( ctype,
                              KERB_PA_COMPOUND_IDENTITY_REPLY_SALT,
                              pIKdcReq->GetEncryptionTypes(),
                              rgpbBuffers,
                              rgcbBuffers,
                              cKeys,
                              NULL, 
                              NULL,
                              pHmacBuffer,
                              &ulHmacBufferSize,
                              NULL,
                              &ExtendedError);
    if ( !NT_SUCCESS( Status ))
    {
        goto Error;
    }

    //
    //  now check again if the chksum size is big enough
    //
    if (ulHmacBufferSize < pCSystem->KeySize)
    {
        DsysAssert(FALSE);
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    pKey = ( PKERB_ENCRYPTION_KEY )MIDL_user_allocate( sizeof( KERB_ENCRYPTION_KEY ));
    if ( NULL == pKey ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    ZeroMemory( pKey, sizeof( KERB_ENCRYPTION_KEY ));
    pKey->keyvalue.value = ( PUCHAR )MIDL_user_allocate( pCSystem->KeySize );
    if ( pKey->keyvalue.value == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    pKey->keyvalue.length = pCSystem->KeySize;
    pKey->keytype = etype;


    memcpy(pKey->keyvalue.value,
           pHmacBuffer,
           pKey->keyvalue.length);

    *ppNewKey = pKey;
    pKey = NULL;

Error:
    if (pKey != NULL)
    {
        if (pKey->keyvalue.value != NULL)
        {
            MIDL_user_free(pKey->keyvalue.value);
        }        
        MIDL_user_free(pKey);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\transit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        transit.cxx
//
// Contents:    Code for compressing transitive realm list
//
//
// History:
//
//------------------------------------------------------------------------
#include "kdcsvr.hxx"


//+-----------------------------------------------------------------------
//
// Function:    KerbAppendString
//
// Synopsis:    Appends to unicode strings together and allocates the output
//
// Effects:
//
// Parameters:  Output - Output appended String
//              InputTail - Trailing portion of input
//              InputHead - Head potion of input
//
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------
NTSTATUS
KerbAppendString(
    OUT PUNICODE_STRING Output,
    IN const UNICODE_STRING * InputTail,
    IN const UNICODE_STRING * InputHead
    )
{
    Output->Buffer = NULL;
    Output->Length = InputHead->Length + InputTail->Length;
    if ((InputHead->Buffer == NULL) || (InputTail->Buffer == NULL))
    {
        Output->MaximumLength = 0;
        return STATUS_SUCCESS;
    }
    else
    {
        Output->MaximumLength = Output->Length + sizeof(WCHAR);
    }

    Output->Buffer = (LPWSTR) MIDL_user_allocate(Output->MaximumLength);
    if (Output->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    memcpy(
        Output->Buffer,
        InputHead->Buffer,
        InputHead->Length
        );

    memcpy(
        Output->Buffer + InputHead->Length / sizeof(WCHAR),
        InputTail->Buffer,
        InputTail->Length
        );

    Output->Buffer[Output->Length/sizeof(WCHAR)] = L'\0';

    return STATUS_SUCCESS;
}


typedef enum _KERB_DOMAIN_COMPARISON {
    Above,
    Below,
    Equal,
    NotEqual
} KERB_DOMAIN_COMPARISON, *PKERB_DOMAIN_COMPARISON;

//+-----------------------------------------------------------------------
//
// Function:    KerbCompareDomains
//
// Synopsis:    Compares two domain names and returns whether one is a
//              prefix of the other, and the offset of the prefix.
//
// Effects:
//
// Parameters:
//
// Return:      Above - domain1 is a postfix of domain2
//              Below - domain2 is a postfix of domain1
//              Equal - the domains are equal
//              NotEqual - the domains are not equal and not above or below
//
// Notes:       This does not work for x-500 realm names (/foo/bar)
//
//------------------------------------------------------------------------

KERB_DOMAIN_COMPARISON
KerbCompareDomains(
    IN const UNICODE_STRING * Domain1,
    IN const UNICODE_STRING * Domain2,
    OUT PULONG PostfixOffset
    )
{
    UNICODE_STRING TempString;

    if (Domain1->Length > Domain2->Length)
    {
        TempString.Length = TempString.MaximumLength = Domain2->Length;
        TempString.Buffer = Domain1->Buffer + (Domain1->Length - Domain2->Length) / sizeof(WCHAR);

        if (RtlEqualUnicodeString(
                &TempString,
                Domain2,
                TRUE) && TempString.Buffer[-1] == '.')
        {
            *PostfixOffset = (Domain1->Length - Domain2->Length) / sizeof(WCHAR);
            return Below;
        }
        else
        {
            return NotEqual;
        }
    }
    else if (Domain1->Length < Domain2->Length)
    {
        TempString.Length = TempString.MaximumLength = Domain1->Length;
        TempString.Buffer = Domain2->Buffer + (Domain2->Length - Domain1->Length) / sizeof(WCHAR);

        if (RtlEqualUnicodeString(
                &TempString,
                Domain1,
                TRUE) && TempString.Buffer[-1] == '.')
        {
            *PostfixOffset = (Domain2->Length - Domain1->Length) / sizeof(WCHAR);
            return Above;
        }
        else
        {
            return NotEqual;
        }
    }
    else if (RtlEqualUnicodeString(Domain1,Domain2, TRUE))
    {
        *PostfixOffset = 0;
        return Equal;
    }
    else
    {
        return NotEqual;
    }
}

//+-----------------------------------------------------------------------
//
// Function:    KdcExpandTranistedRealms
//
// Synopsis:    Expands the transited realm field into an array of realms
//
// Effects:     Allocates an array of realm names
//
// Parameters:  FullRealmList - receives the full list of realms
//              CountOfRealms - receveies the number of entries in the list
//              TranistedList - The transited field to expand
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcExpandTransitedRealms(
    OUT PUNICODE_STRING * FullRealmList,
    OUT PULONG CountOfRealms,
    IN PUNICODE_STRING TransitedList
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG RealmCount;
    ULONG Index;
    ULONG RealmIndex;
    PUNICODE_STRING RealmList = NULL;
    UNICODE_STRING CurrentRealm;

    TRACER(L"KdcExpandTransitedRealms", (PVOID *) &KerbErr);
    *FullRealmList = NULL;
    *CountOfRealms = 0;

    //
    // First count the number of realms in the tranisted list. We can do
    // this by counting the number of ',' in the list. Note: if the encoding
    // is compressed by using a null entry to include all domains in a path
    // up or down a hierarchy, this code will fail.
    //

    if (TransitedList->Length == 0)
    {
        return(KDC_ERR_NONE);
    }


    RealmCount = 1;
    for (Index = 0; Index < TransitedList->Length / sizeof(WCHAR) ; Index++ )
    {
        if (TransitedList->Buffer[Index] == ',')
        {
            RealmCount++;

            //
            // Check for a ',,' compression indicating that all the
            // realms between two names have been traversed.
            // BUG 453997: we don't handle this yet.
            //

            if ( (Index == 0) ||
                 (Index == (TransitedList->Length / sizeof(WCHAR)) -1) ||
                 (TransitedList->Buffer[Index-1] == L','))

            {
                DebugLog((DEB_ERROR,"BUG 453997:: hit overcompressed transited encoding: %wZ\n",
                    TransitedList ));
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }
        }
    }

    //
    // We now have a the count of realms. Allocate an array of UNICODE_STRING
    // structures to hold the realms.
    //

    RealmList = (PUNICODE_STRING) MIDL_user_allocate(RealmCount * sizeof(UNICODE_STRING));
    if (RealmList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ZeroMemory(
        RealmList,
        RealmCount * sizeof(UNICODE_STRING)
        );



    //
    // Now loop through and insert the full names of all the domains into
    // the list
    //

    RealmIndex = 0;
    CurrentRealm = *TransitedList;
    for (Index = 0; Index <= TransitedList->Length / sizeof(WCHAR) ; Index++ )
    {
        //
        // If we hit the end of the string or found a ',', split off a
        // new realm.
        //

        if ((Index == TransitedList->Length / sizeof(WCHAR)) ||
            (TransitedList->Buffer[Index] == ',' ))
        {

            //
            // Check for a ',,' compression indicating that all the
            // realms between two names have been traversed.
            // BUG 453997:: we don't handle this yet.
            //

            if ( (Index == 0) ||
                 (Index == (TransitedList->Length / sizeof(WCHAR)) -1) ||
                 (TransitedList->Buffer[Index-1] == L','))

            {
                DebugLog((DEB_ERROR,"BUG 453997:: hit overcompressed transited encoding: %wZ\n",
                    TransitedList ));
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            CurrentRealm.Length = CurrentRealm.MaximumLength =
                (USHORT)(&TransitedList->Buffer[Index] - CurrentRealm.Buffer) * sizeof(WCHAR);

            //
            // Check for a trailing '.' - if so, append it
            // to the parent
            //

            if (TransitedList->Buffer[Index-1] == '.')
            {
                //
                // This is a compressed name, so append it to the previous
                // name
                //
                if (RealmIndex == 0)
                {
                    DebugLog((DEB_ERROR,"First element in transited encoding has a trailing '.': %wZ\n",
                        TransitedList ));
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
                if (!NT_SUCCESS(KerbAppendString(
                        &RealmList[RealmIndex],
                        &RealmList[RealmIndex-1],
                        &CurrentRealm)))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
            else if ((RealmIndex != 0) && (CurrentRealm.Buffer[0] == '/'))
            {
                if (!NT_SUCCESS(KerbAppendString(
                        &RealmList[RealmIndex],
                        &CurrentRealm,
                        &RealmList[RealmIndex-1]
                        )))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
            else if (!NT_SUCCESS(KerbDuplicateString(
                    &RealmList[RealmIndex],
                    &CurrentRealm)))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            CurrentRealm.Buffer =CurrentRealm.Buffer + 1 + CurrentRealm.Length/sizeof(WCHAR);
            RealmIndex++;
        }
    }
    DsysAssert(RealmIndex == RealmCount);

    *FullRealmList = RealmList;
    *CountOfRealms = RealmCount;
Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (RealmList != NULL)
        {
            for (RealmIndex = 0; RealmIndex < RealmCount ; RealmIndex++ )
            {
                KerbFreeString(&RealmList[RealmIndex]);
            }
            MIDL_user_free(RealmList);
        }
    }

    return(KerbErr);
}


//+-----------------------------------------------------------------------
//
// Function:    KdcCompressTransitedRealms
//
// Synopsis:    Compresses an ordered list of realms by removing
//              redundant information.
//
// Effects:     Allocates an output string
//
// Parameters:  CompressedRealms - receives the compressed list of realms
//              RealmList - List of domains to compress
//              RealmCount - number of entries in realm list
//              NewRealm - new realm to add to the lsit
//              NewRealmIndex - Location before which to insert the new
//                      realm
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcCompressTransitedRealms(
    OUT PUNICODE_STRING CompressedRealms,
    IN PUNICODE_STRING RealmList,
    IN ULONG RealmCount,
    IN PUNICODE_STRING NewRealm,
    IN ULONG NewRealmIndex
    )
{
    UNICODE_STRING OutputRealms;
    WCHAR OutputRealmBuffer[1000];
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    ULONG InsertionIndex = NewRealmIndex;
    PWCHAR Where;
    PUNICODE_STRING PreviousName = NULL;
    PUNICODE_STRING CurrentName = NULL;
    ULONG PostfixOffset;
    UNICODE_STRING NameToAdd;

    TRACER(L"KdcCompressTransitedRealms", (PVOID *) &KerbErr);
    
    RtlInitUnicodeString(
        CompressedRealms,
        NULL
        );

    OutputRealms.Buffer = OutputRealmBuffer;
    OutputRealms.MaximumLength = sizeof(OutputRealmBuffer);
    OutputRealms.Length = 0;
    Where = OutputRealms.Buffer;

    Index = 0;
    while (Index <= RealmCount)
    {
        PreviousName = CurrentName;

        //
        // If this is the index to insert, add the new realm
        //

        if (InsertionIndex == Index)
        {
            CurrentName = NewRealm;
        }
        else if (Index == RealmCount)
        {
            //
            // If we already added all the original realms, get out now
            //

            break;
        }
        else
        {
            CurrentName = &RealmList[Index];
        }

        NameToAdd = *CurrentName;

        //
        // If the previous name is above this one, lop off the postfix from
        // this name
        //

        if ((PreviousName != NULL) &&
            KerbCompareDomains(
                PreviousName,
                CurrentName,
                &PostfixOffset
                ) == Above)
        {
            NameToAdd.Length = (USHORT) PostfixOffset * sizeof(WCHAR);
        }


        DsysAssert(OutputRealms.Length + NameToAdd.Length + sizeof(WCHAR) < OutputRealms.MaximumLength);
        if (OutputRealms.Length + NameToAdd.Length + sizeof(WCHAR) > OutputRealms.MaximumLength)
        {
            //
            // BUG 453652: wrong error
            //

            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        if (OutputRealms.Length != 0)
        {
            *Where++ = L',';
            OutputRealms.Length += sizeof(WCHAR);

        }
        memcpy(
            Where,
            NameToAdd.Buffer,
            NameToAdd.Length
            );
        Where += NameToAdd.Length/sizeof(WCHAR);
        OutputRealms.Length = OutputRealms.Length + NameToAdd.Length;

        //
        // If we inserted the transited realm here, run through the loop
        // again with the same index.
        //

        if (InsertionIndex == Index)
        {
            InsertionIndex = 0xffffffff;
        }
        else
        {
            Index++;
        }
    }

    *Where++ = L'\0';


    if (!NT_SUCCESS(KerbDuplicateString(
            CompressedRealms,
            &OutputRealms)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
Cleanup:
    return(KerbErr);
}


//+-----------------------------------------------------------------------
//
// Function:    KdcInsertTransitedRealm
//
// Synopsis:    Inserts the referree's realm into the tranisted encoding
//              in a ticket. This uses domain-x500-compress which
//              eliminates redundant information when one domain is the
//              prefix or suffix of another.
//
// Effects:     Allocates output buffer
//
// Parameters:  NewTransitedField - receives the new tranisted field, to
//                      be freed with KerbFreeString
//              OldTransitedField - the existing transited frield.
//              ClientRealm - Realm of client (from ticket)
//              TransitedRealm - Realm of referring domain
//              OurRealm - Our realm name
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcInsertTransitedRealm(
    OUT PUNICODE_STRING NewTransitedField,
    IN PUNICODE_STRING OldTransitedField,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING TransitedRealm,
    IN const UNICODE_STRING * OurRealm
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUNICODE_STRING FullDomainList = NULL;
    ULONG CountOfDomains;
    ULONG NewEntryIndex = 0xffffffff;
    ULONG PostfixOffset;
    ULONG Index;
    KERB_DOMAIN_COMPARISON Comparison = NotEqual;
    KERB_DOMAIN_COMPARISON LastComparison;

    TRACER(L"KdcInsertTransitedRealm", (PVOID *) &KerbErr);
    
    //
    // The first thing to do is to expand the existing transited field. This
    // is because the compression scheme does not allow new domains to simply
    // append or insert information - the encoding of existing realms
    // can change. For example, going from a domain to its parent means
    // that the original domain can be encoded as a prefix of the parent
    // whereas originally it was a name unto itself.
    //

    D_DebugLog((DEB_T_TRANSIT, "Inserted realm %wZ into list %wZ for client fomr %wZ\n",
        TransitedRealm, OldTransitedField, ClientRealm ));

    KerbErr = KdcExpandTransitedRealms(
                &FullDomainList,
                &CountOfDomains,
                OldTransitedField
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now loop through the domains. Based on the compression, we know that
    // higher up domains come first.
    //

    for (Index = 0; Index < CountOfDomains ; Index++ )
    {
        LastComparison = Comparison;

        Comparison = KerbCompareDomains(
                        TransitedRealm,
                        &FullDomainList[Index],
                        &PostfixOffset
                        );
        if (Comparison == Above)
        {
            //
            // If the new domain is above an existing domain, it gets inserted
            // before the existing domain because all the existing domains
            // are ordered from top to bottom
            //
            NewEntryIndex = Index;
            break;
        }
        else if (Comparison == Below)
        {
            //
            // There may be other domains below which are closer, so
            // store the result and continue.
            //
            LastComparison = Comparison;
        }
        else if (Comparison == NotEqual)
        {
            //
            // The domains aren't above or below each other. If the last
            // comparison was below, stick the domain underneath it.
            //
            if (LastComparison == Below)
            {
                NewEntryIndex = Index;
                break;
            }
        }
    }

    //
    // If we didn't find a place for it, stick it in at the end.
    //

    if (NewEntryIndex == 0xffffffff)
    {
        NewEntryIndex = Index;
    }

    //
    // Now build the new encoding
    //

    KerbErr = KdcCompressTransitedRealms(
                NewTransitedField,
                FullDomainList,
                CountOfDomains,
                TransitedRealm,
                NewEntryIndex
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:
    if (FullDomainList != NULL)
    {
        for (Index = 0; Index < CountOfDomains ; Index++ )
        {
            KerbFreeString(&FullDomainList[Index]);
        }
        MIDL_user_free(FullDomainList);
    }

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\win2000.cxx ===
#include "kdcsvr.hxx"

typedef ULONG (*DBGPRINTEX)(ULONG, ULONG, PCH, va_list);

extern "C" ULONG
vDbgPrintEx(
    ULONG ComponentId,
    ULONG Level,
    PCH Format,
    va_list arglist
    )
/*++

Routine Description:

    This routine has been written to help load the service on Win2K machines.
    The debug version of some libraries call vDbgPrintfEx which has been
    implemented in Whistler and hence does not exist in Win2k's ntdll.dll.
    BryanT added it to help solve this problem.

Arguments:

    ComponentId -
    
    Level -
    
    Format -
    
    arglist -

Return Value:

    ERROR_SUCCESS or the Win32 error code.

--*/
{

    DBGPRINTEX pfnDbgPrintEx = (DBGPRINTEX) GetProcAddress(GetModuleHandle(L"ntdll"), "vDbgPrintEx");
    if (pfnDbgPrintEx) {
        return (*pfnDbgPrintEx)(ComponentId, Level, Format, arglist);
    } else {
        char Buf[2048];
        _vsnprintf(Buf, sizeof(Buf), Format, arglist);
        Buf[ (sizeof(Buf)/sizeof(Buf[0])) - 1 ] = '\0';
        DbgPrint(Buf);
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_2\build\makefile.inc ===
!INCLUDE $(INETROOT)\tools\build\makefiles\makefile.inc
!include $(INETROOT)\build\makefiles\makefile.cspp
!include $(INETROOT)\build\makefiles\makefile.hf
#!include $(INETROOT)\build\makefiles\makefile.wix
!include $(INETROOT)\build\makefiles\makefile.sqlcltarget
!include $(INETROOT)\build\makefiles\makefile.sqltoktarget
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\vc\server\server\transit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        transit.h
//
// Contents:    Prototypes for transited realm encoding
//
//
// History:     2-April-1997    MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __TRANSIT_H__
#define __TRANSIT_H__

KERBERR
KdcInsertTransitedRealm(
    OUT PUNICODE_STRING NewTransitedField,
    IN PUNICODE_STRING OldTransitedField,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING TransitedRealm,
    IN const UNICODE_STRING * OurRealm
    );

KERBERR
KdcExpandTransitedRealms(
    OUT PUNICODE_STRING * FullRealmList,
    OUT PULONG CountOfRealms,
    IN PUNICODE_STRING TransitedList
    );


#endif // __TRANSIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_2\build\projects.inc ===
#
#  CoreXT Include Paths.  
#  Utilize this file to define your project custom paths
#

COREXT_INC_PATH=$(PUBLIC_INTERNAL_PATH)\CoreXT\inc
COREXT_REF_PATH=$(PUBLIC_INTERNAL_PATH)\CoreXT\ref
COREXT_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\CoreXT\lib
COREXT_LIB_PATH=$(COREXT_LIB_DEST)\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_2\build\fxcop\override.securityrules.inc ===
<Rule Name="DoNotIndirectlyExposeMethodsWithLinkDemands" Enabled="False" />
<Rule Name="ReviewSuppressUnmanagedCodeSecurityUsage" Enabled="False" />
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_2\build\environment\Environment.cs ===
namespace System  
{ public class Enlistment {  
    public const string Root = @"d:\Depot\XONLINE_MAIN\";  
}}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_2\build\fxcop\referenceddirectories.wstadmin.inc ===
<Directory>%EXTPATH%\xonline-ext\Webstore\5.5.2421.0000\sdk\fre\dll\</Directory>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_2\build\fxcop\referenceddirectories.inc ===
<Directory>%INETROOT%\private\common\adsi\iis\</Directory>
<Directory>%INETROOT%\drop\debug\xqry\bin\</Directory>
<Directory>%INETROOT%\drop\debug64\xqry\bin\</Directory>
<Directory>%INETROOT%\drop\debug\test\StfTests\</Directory>
<Directory>%INETROOT%\drop\debug64\test\StfTests\</Directory>
<Directory>%INETROOT%\drop\debug\test\StfTests\Suites\</Directory>
<Directory>%INETROOT%\drop\debug64\test\StfTests\Suites\</Directory>
<Directory>%EXTPATH%\xonline-ext\wmrmsdk\WMRM10.1\managedbin\</Directory>
<Directory>%EXTPATH%\xonline-ext\SCS\7.5\bin\</Directory>
<Directory>%EXTPATH%\xonline-ext\Webstore\6.0.1217.0001\SDK64\release\dll\</Directory>
<Directory>%INETROOT%\drop\debug\tools\Utils\</Directory>
<Directory>%INETROOT%\drop\debug64\tools\Utils\</Directory>
<Directory>%INETROOT%\drop\debug\cron\bin\</Directory>
<Directory>%INETROOT%\drop\debug64\cron\bin\</Directory>
<Directory>%EXTPATH%\MSCOMGeoInfo\2.2.0.0\Binaries\Release\</Directory>
<Directory>%EXTPATH%\MSCOMGeoInfo\2.2.0.0\Binaries\Debug\</Directory>
<Directory>%EXTPATH%\MSCOMGeoInfo\1.1.0.0\GeoLocationAPI\</Directory>
<Directory>%EXTPATH%\sql\2005\SDKAssemblies\</Directory>
<Directory>%EXTPATH%\sql\2008\SDKAssemblies\</Directory>
<Directory>%INETROOT%\drop\debug\tools\lsmonitor\service\bin\</Directory>
<Directory>%INETROOT%\drop\debug64\tools\lsmonitor\service\bin\</Directory>
<Directory>%INETROOT%\drop\debug\tools\lsmonitor\service\bin\</Directory>
<Directory>%INETROOT%\drop\debug64\tools\lsmonitor\service\bin\</Directory>
<Directory>%INETROOT%\drop\debug\tools\lsmonitor\service\bin\extensions\</Directory>
<Directory>%INETROOT%\drop\debug64\tools\lsmonitor\service\bin\extensions\</Directory>
<Directory>%INETROOT%\drop\debug\common\</Directory>
<Directory>%INETROOT%\drop\debug64\common\</Directory>
<Directory>%EXTPATH%\Sharepoint\</Directory>
<Directory>%INETROOT%\drop\debug64\ESearchPerfDad\ESearch\webroot\bin\</Directory>
<Directory>%EXTPATH%\xonline-ext\Mom\5.0.2911.0\dll\</Directory>
<Directory>%EXTPATH%\xonline-ext\Reporting\</Directory>
<Directory>%INETROOT%\private\server\ContentIngestion\PropManager\PropManagerCore\PropManagerUI\PropManager\</Directory>
<Directory>%INETROOT%\drop\debug\server\ContentIngestion\PropManager\PropManagerCore\PropManagerUI\bin\</Directory>
<Directory>%INETROOT%\drop\debug64\server\ContentIngestion\PropManager\PropManagerCore\PropManagerUI\bin\</Directory>
<Directory>%INETROOT%\drop\debug64\MemCache\</Directory>
<Directory>%EXTPATH%\xonline-ext\PassportRPS\4.5.2135\bin\amd64\</Directory>
<Directory>%EXTPATH%\xonline-ext\PassportRPS\4.5.2135\bin\i386\</Directory>
<Directory>%EXTPATH%\xonline-ext\velocity\1.0.0.0\client\</Directory>
<Directory>%EXTPATH%\xonline-ext\ems\</Directory>
<Directory>%INETROOT%\drop\debug\act\uacs\</Directory>
<Directory>%INETROOT%\target\debug\TitlePropPro\</Directory>
<Directory>%EXTPATH%\codesign\</Directory>
<Directory>%INETROOT%\drop\debug\tools\WSMonitor\</Directory>
<Directory>%INETROOT%\drop\debug\test\LiveInfra\LiveLib\</Directory>
<Directory>%INETROOT%\drop\debug64\test\LiveInfra\LiveLib\</Directory>
<Directory>%EXTPATH%\soup\</Directory>
<Directory>%EXTPATH%\xnals\1.0.0.19966\Debug\</Directory>
<Directory>%EXTPATH%\xnals\1.0.0.19966\Release\</Directory>
<Directory>%INETROOT%\drop\debug\test\Ls3iStress\App\Pages\Bin\</Directory>
<Directory>%EXTPATH%\DBSchema\</Directory>
<Directory>%EXTPATH%\XmlDiffReport\</Directory>
<Directory>%INETROOT%\drop\debug\test\tools\SchemaDiff\</Directory>
<Directory>%EXTPATH%\FCL\Libraries\</Directory>
<Directory>%INETROOT%\drop\debug\tools\iisrunner\</Directory>
<Directory>%INETROOT%\drop\debug64\tools\iisrunner\</Directory>
<Directory>%INETROOT%\drop\debug\tools\deployment\sql\</Directory>
<Directory>%INETROOT%\drop\debug\tools\XonWatch2\remoting\</Directory>
<Directory>%EXTPATH%\nunit\2.4.1\x86\</Directory>
<Directory>%INETROOT%\drop\debug\test\H2PcExt\</Directory>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_3\private\server\signature\PlayReady\inc\drmbuild_pk.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBUILD_PK__
#define __DRMBUILD_PK__

#ifdef __cplusplus
extern "C" {
#endif


#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PK
#error "Wrong build profile header file"
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Anti-rollback clock feature. If this
# flag is set to '0', device clock rollback will not be detected. Hence all
# date-time based content/licenses would not be able to be maintained
# accurately.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_ANTIROLLBACK_CLOCK
#define DRM_SUPPORT_ANTIROLLBACK_CLOCK          1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable application revocation functionality.
#
# If this flag is '0', the application revocation list storage and application revocation checks
# do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_APP_REVOCATION
#define DRM_SUPPORT_APP_REVOCATION              0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable block header caching support
#
# If this flag is '1', HDS block headers may be cached for improved
# performace. Note that the sample OEM implementation in oemimpl.c
# is not adequate if multiple instances of the porting kit are running
# concurrently. The cache must be global to all instances sharing the
# same HDS file, and should have appropriate resource locking.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_BLOCK_HEADER_CACHING
#define DRM_SUPPORT_BLOCK_HEADER_CACHING        0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable optimizations that cache the certificates
# validated when verifying a certificate chain.  This allows the asymmetric
# validation of a particular certificate to be performed only once.  Each
# subsequent validation is a symmetric validation, and is therefore much quicker.
# If this flag is set to '0', devices will use more expensive asymmetric operations.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_CERTIFICATE_CACHING
#define DRM_SUPPORT_CERTIFICATE_CACHING         1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable expired license cleanup functionality
#
# If this flag is '1', calling Drm_StoreMgmt_CleanupStore will iterate
# through all licenses and delete those that have expired and are no
# longer usable.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_CLEANUP
#define DRM_SUPPORT_CLEANUP                     1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable device revocation functionality.
#
# If this flag is '0', the Device revocation list storage and device revocation checks
# do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DEVICE_REVOCATION
#define DRM_SUPPORT_DEVICE_REVOCATION           1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable device store functionality.
#
# If this flag is '0', the device store functionality will not be compiled.
# The device store is used by the WMDRM-NDT porting kit, and so is only needed if
# linking with it.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DEVICESTORE
#define DRM_SUPPORT_DEVICESTORE                 1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the supoort for the Direct License
# Acquisition. If this flag is '0', devices will only acquire licenses
# via content transfer via a host PC or the License Sync (see below).
#
# The Following License Acquisition API and the supporting 
# functions will be included (if this flag is set to '1'):
# - Drm_LicenseAcq_GenerateChallenge
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DLA
#define DRM_SUPPORT_DLA                         1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the support for License store Sync'ing
# with PC host. It this flag is '0', devices will only be able to acquire
# licenses via content transfer from a host, or through Direct License
# Acquisition with a WMRM license server.
#
# The following License Acquisition, Sync, and Sync List APIs and the 
# supporting functions will be included (if this flag is set to '1'):
# - Drm_LicenseAcq_GetContentHeader,
# - Drm_Sync_GenerateChallenge,
# - Drm_SyncListItem_InitEnum (also requires DRM_SUPPORT_DLA), and
# - Drm_SyncListItem_EnumNext (also requires DRM_SUPPORT_DLA)
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_LICENSE_SYNC
#define DRM_SUPPORT_LICENSE_SYNC                1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable file locking support
# 
# If this flag is '1', file locking support will be enabled
# in oemfileio.c. File locking support is required if the porting
# kit code is ever executed concurrently using the same HDS file
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_LOCKING
#define DRM_SUPPORT_LOCKING                     1
#endif
/*
#------------------------------------------------------------------------------
#
# Set this flag to '1' to enable multithreading support
#
# Note that you must fully implement critical section and locking support in the 
# OEM layer.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_MULTI_THREADING
#define DRM_SUPPORT_MULTI_THREADING             1
#endif
#if DRM_SUPPORT_MULTI_THREADING && !DRM_SUPPORT_LOCKING
#error "We cannot be thread safe unless file locking is supported"
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Metering feature. If this flag is '0',
# licenses with a Metering ID (MID) will not be usable.
#
# The following Metering and Metering Certificate APIs and the supporting 
# functions will be included (if this flag is set to '1'):
# - Drm_MeterCert_InitEnum,
# - Drm_MeterCert_EnumNext,
# - Drm_MeterCert_Update,
# - Drm_MeterCert_Invalidate,
# - Drm_MeterCert_Delete,
# - Drm_Metering_GenerateChallenge,
# - Drm_Metering_ProcessResponse,
# - Drm_MeterCert_GenerateChallenge, and
# - Drm_MeterCert_ProcessResponse
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_METERING
#define DRM_SUPPORT_METERING                    1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Secure Clock feature when clock is set 
# by using a secure time Web service and support a grace period 
# if the content license allows it. Setting the flag into '0' disables this capability.
#
# The Following Secure Clock APIs and the supporting functions will be
# included (if this flag is set to '1'):
# - Drm_SecureClock_ProcessResponse,
# - Drm_SecureClock_GenerateChallenge, and
# - Drm_SecureClock_GetValue
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_SECURE_CLOCK
#define DRM_SUPPORT_SECURE_CLOCK                1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable optimizations that offload asymmetric crypto
# operations to symmetric operations.  For example, some signatures after being
# verified once asymmetrically can be converted to a symmetric signature such that
# subsequent verifications are faster.  The same is true for some asymmetric decrypt
# operations.  If this flag is set to '0', devices will always choose more expensive
# asymmetric operations.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
#define DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS     1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable revocation support for WMDRM Network Devices 
# Transmitter functionality. Setting this flag will enable support for WMDRMNET 
# revocation list storage and revocation checks.
#
# If this flag is '0', the WMDRMNET revocation storage checks do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_WMDRMNET
#define DRM_SUPPORT_WMDRMNET                    1
#endif
/*
#------------------------------------------------------------------------------
#
# Set this flag to '1' to disable native 64 bit types
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_NO_NATIVE_64_TYPES
#if defined( _WIN64)
/* When building for a 64bit target, there needs to be native 64-bit type support */
#define DRM_NO_NATIVE_64_TYPES                  0
#else
/* Otherwise, we'll not use the native 64-bit types even if available */
#define DRM_NO_NATIVE_64_TYPES                  0
#endif
#endif

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_TEST_SETTINGS
# Set this flag to '1' to enable various test flags:
# TEST_USE_OFFSET_CLOCK
# DRM_TEST_MEM_ALLOC_CHECK
# DRM_TEST_SUPPORT_NET_IO
# DRM_ERROR_CONTRACT_TEST_MODE
# DRM_TEST_IGNORE_UNIQUE_ID
# 
# If the flag is not set it is 0 by default.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_TEST_SETTINGS
#define DRM_SUPPORT_TEST_SETTINGS               1
#endif

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_PC_FLAGS
#
# Turns several compile flags for use in PC/host components only. 
# They should be unset or set to 0 for all PlayReady implementations:
#    DRM_SUPPORT_V1_LICENSES
#    DRM_SUPPORT_GRL                 
#    DRM_SUPPORT_THUMBNAIL           
#    DRM_BACKUP_RESTORE_SUPPORT      
#    DRM_SUPPORT_CONTENT_REVOCATION  
#    DRM_SUPPORT_PLAYLIST_BURN       
#    DRM_SUPPORT_PMLICENSE           
#    DRM_SUPPORT_COPY_OPL            
#    DRM_SUPPORT_DELETEDSTORE        
#    DRM_NO_FORCE_ALIGN              
#    DRM_TEMP_LICENSE_STORE_HDS      
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_PC_FLAGS
#define DRM_SUPPORT_PC_FLAGS    0
#endif

/*
#------------------------------------------------------------------------------
# NO_DRM_CRT
# Choose CRT functions implementation, using own DRM version is default for PK
#------------------------------------------------------------------------------
*/
#ifndef NO_DRM_CRT
#define NO_DRM_CRT                      0
#endif

/*
#------------------------------------------------------------------------------
# DRM_USE_ASSEMBLY
# Set to 1 to enable assembly optimized routines where available
#------------------------------------------------------------------------------
*/
#ifndef DRM_USE_ASSEMBLY
#define DRM_USE_ASSEMBLY                0
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable pre-computation of G table to enable speed-up
# in ECC operations at a cost of higher memory footprint
#------------------------------------------------------------------------------
*/
#ifndef DRM_PRECOMPUTE_GTABLE
#define DRM_PRECOMPUTE_GTABLE           0
#endif


#ifdef __cplusplus
}
#endif

#endif  /* __DRMBUILD_PKNEXT_DBG__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_3\vc\server\server\paid.cxx ===
//+-----------------------------------------------------------------------
//
// File:        paid.cxx
//
// Contents:    PA IDentities handler
//
//
// History:     3-Sept-2001   yordanr   Created.
//
//------------------------------------------------------------------------

#include <kdcsvr.hxx>
#include <malloc.h>


#include <krb5.h>
#include <krb5p.h>
#include <kerberr.h>

//  the new interface
#include <kerbinterface.h>
#include <padata.hxx>

//
//  interface implementation of IPAHandler for PA-Identity
//
class CPAIdentityHandler : public IPAHandler, public IPAIdentity
{
//  prealloc a number of ids
public:
    CPAIdentityHandler() :
        m_cKeys(0),
        m_pKeys(NULL),
        m_pXboxId(NULL)
    {
    }

    ~CPAIdentityHandler()
    {
        if (m_pKeys)
        {
            while(m_cKeys--)
            {
                KdcFreeMemory(m_pKeys[m_cKeys].keyvalue.value);
            }
            KdcFreeMemory(m_pKeys);
        }
        if (m_pXboxId) 
        {
            KdcFreeMemory(m_pXboxId);
        }
    }

    void __stdcall Release(void)
    {
        delete  this;
    };

    //
    // Implement IPAHandler
    //
    virtual ULONG GetPAType()
    {
        return  KRB5_PADATA_COMPOUND_IDENTITY ;
    }

    //
    // We support the IPAIdentity interface
    //
    virtual HRESULT __stdcall QueryInterface(
        REFIID intf,
        PVOID *ppv
        )
    {
        if (IsEqualIID(intf, IID_IPAIdentity))
        {
            *ppv = (PVOID)(IPAIdentity*)this;
            return  S_OK;
        }
        return  E_NOINTERFACE;
    }

    virtual KERBERR __stdcall Check(
        IN  IKerbRequest               *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST         *ppOutPadata,
        OUT BOOLEAN                    *pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
        );

    virtual NTSTATUS __stdcall GetCompoundIdentity(
        OUT const COMPOUND_IDENTITY  **ppCompId
        )
    {
        *ppCompId = NULL;
        return  STATUS_NOT_IMPLEMENTED;
    }

    virtual NTSTATUS __stdcall GetXboxIdentity(
        OUT const XBOX_IDENTITY      **ppXboxId
        )
    {
        *ppXboxId = m_pXboxId;
        return  STATUS_SUCCESS;
    }

    //  return number of logon info structs present in compound identity
    virtual ULONG __stdcall GetNumLogonInfos()
    {
        return 0;
    }

    virtual NTSTATUS __stdcall GetTgtKeys(
        OUT PULONG                      pcKeys,
        OUT const KERB_ENCRYPTION_KEY **pKeys
        )
    {
        if (m_pKeys == 0)
        {
            return  STATUS_NOT_FOUND;
        }
        *pcKeys = m_cKeys;
        *pKeys = m_pKeys;

        return  STATUS_SUCCESS;
    }

private:

    PXBOX_IDENTITY          m_pXboxId;   //  compacted identity
    ULONG                   m_cKeys;     //  stored session keys
    PKERB_ENCRYPTION_KEY    m_pKeys;

    //  private APIs

    //  add an identity from XBOX_IDENTITY
    NTSTATUS AddXboxIdentity(PXBOX_IDENTITY pXboxIdentity);

    //  Build the identity
    KERBERR CheckCredsAndGetAuthData(
        PKERB_TICKET              pTicket,
        ULONG                     iTicket,
        IKerbRequest             *piReq,
        PKERB_EXT_ERROR pExtendedError
        );
};


//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::Check
//
//  Synopsis:   Extracts the krb_cred msg, decrypts and unpacks it after which
//              Identities are extracted from the PAC and stored for further use.
//              Verification is performed to ensure the cred msg is legit by
//              comparing the keys in the msg to the keys in the tickets.
//
//  Effects:
//
//  Arguments:  pIKerbRequest
//              pPreAuthData
//              pEncryptionKey
//              ppOutPadata
//              pbSufficient
//              pStatus
//
//              See IPAHandler::Check documentation for parameter descriptions
//
//  Requires:
//
//  Returns:    KDC_ERR_GENERIC        - pStatus contains the reason for failure
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CPAIdentityHandler::Check(
    IN  IKerbRequest                *pIKerbRequest,
    IN  PKERB_PA_DATA_LIST           pPreAuthData,
    OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
    OUT PKERB_PA_DATA_LIST          *ppOutPadata,
    OUT BOOLEAN                     *pbSufficient,
    OUT PKERB_EXT_ERROR              pExtendedError
    )
{
    KERBERR                     KerbErr = KDC_ERR_NONE;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PKERB_PA_COMPOUND_IDENTITY  pPaTemp = NULL;
    PKERB_PA_COMPOUND_IDENTITY *pPaCompId = NULL;
    ULONG                       iTicket;

    *pbSufficient = FALSE;

    if ( pPreAuthData->value.preauth_data_type != KRB5_PADATA_COMPOUND_IDENTITY)
    {
        //
        // Called with wrong PA
        //

        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    //  decrypt the preauth
    //  KerbUnpack is exported by the core, but what is the free function
    //

    KerbErr = KerbUnpackData(
        pPreAuthData->value.preauth_data.value,
        pPreAuthData->value.preauth_data.length,
        KERB_PA_COMPOUND_IDENTITY_PDU,
        (PVOID*)&pPaCompId
        );
    if ( !KERB_SUCCESS( KerbErr ) )
    {
        goto Cleanup;
    }


    //
    // count the tickets
    //

    pPaTemp = *pPaCompId;
    for (iTicket = 0; pPaTemp != NULL; iTicket++, pPaTemp = pPaTemp->next);

    if (m_pKeys)
    {
        KdcFreeMemory(m_pKeys);
        m_pKeys = NULL;
    }

    //
    //  alloc space for the keys
    // 

    m_pKeys = (PKERB_ENCRYPTION_KEY)KdcAllocMemory(iTicket * sizeof(KERB_ENCRYPTION_KEY));
    if (m_pKeys == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto    Cleanup;
    }
    m_cKeys = iTicket;
    memset(m_pKeys, 0, iTicket * sizeof(KERB_ENCRYPTION_KEY));

    //
    // Free existing structures
    // 

    if (m_pXboxId) 
    {
        KdcFreeMemory(m_pXboxId);
    }

    //
    // Alloc the Xbox Identity
    // 

    m_pXboxId = (PXBOX_IDENTITY)KdcAllocMemory( sizeof(XBOX_IDENTITY) );
    if (m_pXboxId == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the fields to empty
    // 

    memset( m_pXboxId, 0, sizeof(XBOX_IDENTITY) );

    //
    // check tickets and auth data
    //

    for (pPaTemp = *pPaCompId, iTicket = 0;
         pPaTemp != NULL;
         pPaTemp = pPaTemp->next, iTicket++)
    {
        KerbErr = CheckCredsAndGetAuthData(
            &pPaTemp->value,
            iTicket,
            pIKerbRequest,
            pExtendedError
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }

Cleanup:

    D_DebugLog((
        DEB_TRACE,
        "PAIdentity::Check returning 0x%lx Status=0x%lx\n",
        KerbErr,
        Status
        ));

    if (pPaCompId)
    {
        KerbFreeData(KERB_PA_COMPOUND_IDENTITY_PDU, pPaCompId);
    }

    pExtendedError->status = Status;

    return  KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::CheckCredsAndGetAuthData
//
//  Synopsis:   Checks the ticket against the cred and if there's a match
//              fills in the auth data at the index passed in
//
//  Effects:
//
//  Arguments:  pTicket     - TGT containing identities
//              iCred       - ticket index
//              piReq       - request in the context of which the operation
//                            takes place
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE if happy
//              KDC_ERR_GENERIC     - out of memory or some other generic error
//              KDC_ERR_PREAUTH_FAILED
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
CPAIdentityHandler::CheckCredsAndGetAuthData(
    IN  PKERB_TICKET              pTicket,
    IN  ULONG                     iTicket,
    IN  IKerbRequest             *piReq,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR                 KerbErr     = KDC_ERR_NONE;
    IADHandler             *piAuthData  = NULL;
    IADPacSection          *iPacSect    = NULL;
    IKdbProvider           *iProv       = NULL;
    IKerbPrincipal         *piPrinc     = NULL;
    NTSTATUS                Status      = STATUS_SUCCESS;
    const PAC_INFO_BUFFER  *pPacBuf     = NULL;
    PKERB_ENCRYPTED_TICKET  pEncTicket  = NULL;
    PKERB_INTERNAL_NAME     pServerName = NULL;
    UNICODE_STRING          ustrRealm   = {0};


    KerbErr = KerbConvertRealmToUnicodeString(
        &ustrRealm,
        &pTicket->realm
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Get server principal to decrypt the ticket
    //

    iProv = KdcGetProvider(&ustrRealm);
    if (iProv == NULL)
    {
        //
        // No realm for this ticket
        //
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
        &pServerName,
        &pTicket->server_name
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = iProv->GetPrincipal(
        KDC_KDB_GET_PRINC_SERVER,
        pServerName,
        ustrRealm.Buffer,
        piReq,
        &piPrinc,
        pExtendedError,
        NULL
        );
    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    //  Decrypt the ticket with the principal's key
    //
    //  Note that the implicit assumption is that the
    //  ticket is encrypted with the same etype as the request
    //

    Status = piPrinc->Decrypt(
        piReq->GetEncryptionTypes(),
        KERB_TICKET_SALT,
        &pTicket->encrypted_part,
        pTicket->encrypted_part.cipher_text.value,
        &pTicket->encrypted_part.cipher_text.length,
        NULL, // don't care what etype?
        pExtendedError
        );
    if ( !NT_SUCCESS( Status ) )
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    //
    //  unpack encrypted ticket
    //

    KerbErr = KerbUnpackData(
        pTicket->encrypted_part.cipher_text.value,
        pTicket->encrypted_part.cipher_text.length,
        KERB_ENCRYPTED_TICKET_PDU,
        (PVOID*)&pEncTicket
        );

    if ( !KERB_SUCCESS( KerbErr ) )
    {
        goto Cleanup;
    }

    //
    //  save the session key from the ticket
    //  need to copy the ticket value
    //

    m_pKeys[iTicket] = pEncTicket->key;
    m_pKeys[iTicket].keyvalue.value = (ASN1octet_t *)KdcAllocMemory(pEncTicket->key.keyvalue.length);
    if (m_pKeys[iTicket].keyvalue.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto    Cleanup;
    }
    memcpy(
        m_pKeys[iTicket].keyvalue.value,
        pEncTicket->key.keyvalue.value,
        pEncTicket->key.keyvalue.length
        );

    //
    // extract auth data from ticket
    //

    Status = KdcCreateADHandlerInstance(
        KERB_AUTH_DATA_PAC,
        &piAuthData
        );
    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Failed to create a handler???
        //

        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Check the auth Data
    //
    KerbErr = piAuthData->Check(
        piReq,
        piPrinc,
        pEncTicket->authorization_data,
        pExtendedError
        );
    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    // Checked out ok, now get the auth data
    //
    //
    // Query PUIDs PAC section
    //

    Status = piAuthData->QueryInterface(
        IID_IADPacSection,
        (PVOID*)&iPacSect
        );
    if ( !NT_SUCCESS( Status ))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // If we find a CLIENT_IDENTITY or COMPOUND_IDENTITY then this
    // this pre-auth is invalid
    // 

    Status = iPacSect->GetPacSection(
        PAC_CLIENT_IDENTITY,
        &pPacBuf
        );
    if (NT_SUCCESS( Status ) ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }
    Status = iPacSect->GetPacSection(
        PAC_COMPOUND_IDENTITY,
        &pPacBuf
        );
    if (NT_SUCCESS( Status ) ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    // We only care about XBOX_IDENTITY
    // 

    Status = iPacSect->GetPacSection(
        PAC_XBOX_IDENTITY,
        &pPacBuf
        );
    if ( NT_SUCCESS( Status ) ) 
    {
        //
        // PAC Buffer contains the XBOX_IDENTITY. Extract and save
        // it 'as-is'
        // 

        Status = AddXboxIdentity( (PXBOX_IDENTITY) pPacBuf->Data );
        if ( !NT_SUCCESS( Status) ) 
        {
            KerbErr = KDC_ERR_PREAUTH_FAILED;
        }

        //
        // Do not attempt to look at the other IDENTITY types
        // 

        goto Cleanup;
    }
    else if ( Status != STATUS_NOT_FOUND ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

Cleanup:

    if ( piAuthData )
    {
        piAuthData->Release();
    }
    if (piPrinc)
    {
        piPrinc->Release();
    }

    //
    // Free data allocated by asn1 decoding
    //

    KerbFreeData(KERB_ENCRYPTED_TICKET_PDU, pEncTicket);

    if (pServerName)
    {
        //  hmm... KdcFreeName is not part of the core.
        //  use KdcFreeMemory, but is it the same ...
        KerbFreeKdcName(&pServerName);
    }

    KdcFreeMemory( ustrRealm.Buffer );

    return  KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAHandlerIdentityFactory::CreateInstance
//
//  Synopsis:   Constructor-like function for creating a new object instance
//
//  Effects:
//
//  Arguments:  pIKerbRequest     - unused
//              ppIPAHandler      - used to return the new instance
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_NO_MEMORY if out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CPAHandlerIdentityFactory::CreateInstance(
    IN  IKerbRequest     *pIKerbRequest,
    OUT IPAHandler      **ppIPAHandler
    )
{
    *ppIPAHandler = new CPAIdentityHandler;

    if (*ppIPAHandler == NULL)
    {
        return  STATUS_NO_MEMORY;
    }

    return  STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::AddXboxIdentity
//
//  Synopsis:   Appends the identities in XboxIdentity to m_pXboxId
//
//  Effects:
//
//  Arguments:  pXboxId - compound identity to add
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_NO_MEMORY if out of memory
//              STATUS_INVALID_PARAMETER if unhappy
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CPAIdentityHandler::AddXboxIdentity(
    IN PXBOX_IDENTITY pXboxIdentity
    )
{
    if ( NULL == pXboxIdentity) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy over the fields one at a time, after they are
    // sanity checked
    // 

    if (pXboxIdentity->MachineIdentity != 0) 
    {
        m_pXboxId->MachineIdentity           = pXboxIdentity->MachineIdentity;
        m_pXboxId->MachineIdentityCredential = pXboxIdentity->MachineIdentityCredential;
    }

    for (DWORD i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
    {
        if (pXboxIdentity->UserIdentity[i] != 0) 
        {
            m_pXboxId->UserIdentity[i]           = pXboxIdentity->UserIdentity[i];
            m_pXboxId->UserIdentityCredential[i] = pXboxIdentity->UserIdentityCredential[i];
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\ntos\init\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=init

TARGETNAME=init
TARGETPATH=obj
TARGETTYPE=LIBRARY

TARGETPATH2=..\..\obj

SYNCHRONIZE_DRAIN=1
SYNCHRONIZE_BLOCK=1

INCLUDES=..;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\private\genx\ntos\nls\$(O);$(BASEDIR)\private\inc\crypto;$(BASEDIR)\private\inc\aug01
GPSIZE=32

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

SOURCES=..\xboxkrnl.c \
        ..\init.c \
        ..\fatal.cpp

EXPORT_FILE=$(O)\$(NTTEST).exp

!IF defined(ARCADE)
KERNEL_LIB_SUFFIX=arc
!ELSE
KERNEL_LIB_SUFFIX=con
!ENDIF

KERNEL_LIBS = \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ex.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\halx.lib \
    $(TARGETPATH)\$(TARGET_DIRECTORY)\init.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\io.lib \
!IF !defined(NODEVKIT)
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\kd.lib \
!ELSE
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\kdlite.lib \
!ENDIF
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ke.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\mm$(KERNEL_LIB_SUFFIX).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ob.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ps.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ntosrtl.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\idex$(KERNEL_LIB_SUFFIX).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\raw.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\fatx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\gdfx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\udfx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\phy.lib \
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\libcntpr$(D).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ldr$(KERNEL_LIB_SUFFIX).lib \
    $(BASEDIR)\private\lib\$(TARGET_DIRECTORY)\rsa32k.lib      \
    $(BASEDIR)\private\lib\$(TARGET_DIRECTORY)\xcryptk.lib     \
    $(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\randlibk.lib \
!IF !defined(ARCADE)
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ani.lib \
!ENDIF
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\av.lib

LINKLIBS = $(EXPORT_FILE)

!IF !defined(ARCADE)
LINKLIBS = $(LINKLIBS) \
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\d3d8ntpr$(D).lib \
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\xgraphics$(D).lib \
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\bootsnd$(D).lib
!ENDIF

LINKER_FLAGS=$(LINKER_FLAGS) /map
LINKER_FLAGS=$(LINKER_FLAGS) /merge:.edata=.text /merge:.XBLD=INIT
LINKER_FLAGS=$(LINKER_FLAGS) /merge:PAGER32C=.text /merge:PAGER32R=.rdata /merge:PAGER32D=.data
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\inc\crypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsubauth

#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
// end_ntsubauth

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

// begin_ntsubauth
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
// end_ntsubauth



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

// begin_ntsubauth
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
// end_ntsubauth



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

// begin_ntsubauth
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
// end_ntsubauth


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

// begin_ntsubauth
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
// end_ntsubauth


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
// begin_ntsubauth
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;
// end_ntsubauth


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN_3\public\ext\xonline-ext\MAUI\Suites\Products\Visual Studio\Whidbey\Maui.VisualStudio.Whidbey.Whitehorse\LogicalInfrastructureDesignerSuite\LogicalInfrastructureDesignerSuite.cs ===
#region Imports
using System;
using System.Reflection;
using Maui.Core;
using Maui.TestLog;
using Maui.VisualStudio.Whidbey;
using Maui.VisualStudio.Whidbey.Ide;
using Maui.VisualStudio.Whidbey.Ide.ToolWindows;
using Maui.VisualStudio.Whidbey.ProjectItems;
using Maui.VisualStudio.Whidbey.Whitehorse;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows.MemberNodes;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.Dialogs;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.ApplicationDesign;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.LogicalInfrastructureDesign;
#endregion

namespace Maui.Suites.WhitehorseSuite
{
	/// <summary>
	///		Whitehorse Logical Infrastructure _Designer suite.
	/// </summary>
	/// <timeout>
	///		This suite usually completes within 55 seconds (on P4 CPU 1.6 GHz, 1.00 GB RAM).
	/// </timeout>
	/// <requirements>
	///		To run this suite you need Visual Studio .NET Enterprise Architect installed.
	///		Sometimes might not run correctly on CHK builds.
	/// </requirements>
	/// <remarks>
	///		This check-in suite will create blank solution with Distributed Application Diagram
	///		in it.  It will then add a LIM diagram through the solution model explorer.
	///		A zone shape will be added to the diagram, with an IIS 6 host added inside it.
	///		It then connects the host to the zone with a delegation, adds another IIS6 host,
	///		and connects the external host to the zone ports.
	///		
	///		Most common possible failures:
	///			- (will add these as we find failures to identify the cause of)
	///			- Other failures - please see mcosner, v-alexha or dmitriv.
	/// </remarks>
	/// <history>
	///		[mcosner]	07/26/2003	Created
	///		[jliperi]	09/18/2003	Removed hack (for bug 153504) from Run method
    ///		[crickman]	01/26/2004	Updated
    /// </history>
	public class LogicalInfrastructuer_DesignerSuite : WhidbeySuite
	{
        private bool _AutoHidePropertyBrowser;
        private bool _AutoHide_Toolbox;
        private Toolbox _Toolbox;
        private LogicalInfrastructureDesigner _Designer;

		/// <summary>
		///     Whether the suite is to be used when (e.g. if you want to disable it, use this property).
		/// </summary>
		public override bool IsEnabled
		{
			get
			{
				return false;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		///    The suite owner.
		/// </summary>
		///-----------------------------------------------------------------------------
		public override string Owner
		{
			get
			{
				return "jliperi";
			}
		}

		/// <summary>
		/// Initializes the suite.
		/// </summary>
		public override void Initialize()
		{
			base.Initialize();

			Maui.Core.Resources.ManagedStringHandler.EnableWhidbeyResourceBridge = true;

			LogManager.InitScenario("Make sure tool windows are docked as we want.");
			_AutoHidePropertyBrowser = App.PropertyBrowser.AutoHide;
			App.PropertyBrowser.AutoHide = false;
			_Toolbox = new Toolbox(App);
			_AutoHide_Toolbox = _Toolbox.AutoHide;
			_Toolbox.AutoHide = false;
		}

        /// <summary>
        /// Creates a blank solution
        /// </summary>
        private void CreateSolution()
        {
            LogManager.InitScenario("Create a blank solution.");
            SolutionParameters sp = new SolutionParameters(App);
            sp.CreationMode = SolutionCreationMode.CreateNew;
            App.Solution = new Solution(sp);
        }

        /// <summary>
        /// Creates a blank LSAD
        /// </summary>
        private void CreateDesigner()
        {             
            LogManager.InitScenario("Create LSAD.");
            ProjectItemParameters pp = new ProjectItemParameters();
            pp.App = App;
            pp.CreationMode = ProjectItemCreationMode.AddNew;
            pp.UseCodemarkers = false;
            pp.Parent = App.Solution;
            LogicalInfrastructureModelFile modelFile = new LogicalInfrastructureModelFile(pp);
            App.PropertyBrowser.Show();
            App.MainWindow.Extended.State = Core.WindowState.Maximize;
            _Designer = modelFile.Designer;
//            _Designer.Diagram.Zoom( ZoomFactor.Zoom75, ZoomMethod.Toolbar );
        }

        /// <summary>
        /// Close solution w/o saving
        /// </summary>
        private void CloseSolution()
        {
            LogManager.InitScenario("Close solution without saving it (otherwise HUGE perf impact).");
            App.Solution.Close(SaveSolution.No);
        }
        
        /// <summary>
		/// Runs the suite.
		/// </summary>
		public override void Run()
		{
            CreateSolution();
            CreateDesigner();

			LogManager.InitScenario("Add a new host to the diagram." );
            Iis60Host host = new Iis60Host( new ContextMenuCreateAction( _Designer.Diagram ) );

            LogManager.InitScenario("Resize the host.");
            host.Resize(Direction.BottomRight, 20);

            LogManager.InitScenario("Add a new zone to the diagram." );
            Zone zone = new Zone(_Designer.Diagram, ToolboxCreateMethod.DragDrop, host, Direction.BottomLeft, 0, 50 );

            LogManager.InitScenario("Move the host inside the zone." );
            host.MoveToZone(zone);

            // Note: Creating connection causes suite to timeout
            //LogManager.InitScenario("Wire the host's web site port to the zone's inbound port." );
            //WebSitePort webSitePort = (WebSitePort)host.GetDefaultPort( typeof( WebSitePort ) );
            //ZonePort zoneInboundPort = (ZonePort)zone.GetPort( ZonePortRole.Inbound );
            //LidDelegation delegateConnection = new LidDelegation(webSitePort, zoneInboundPort);

            //LogManager.InitScenario( "Verify wiring has occurred correctly." );
            //if( zone.Delegations.Count != 1 )
            //    LogManager.LogFailure( "Number of delegations was not found to be 1!", "expected 1", "actual " + zone.Delegations.Count.ToString() );

            LogManager.InitScenario("Verify zone delete dialog functionality.");
            zone.Delete(ZoneDeleteAction.ClickDeleteAll);

            if (_Designer.Diagram.Zones.Count != 0)
                LogManager.LogFailure("Number of zones was not found to be 0!", "expected 0", "actual " + _Designer.Diagram.Zones.Count.ToString());

            if (_Designer.Diagram.Hosts.Count != 0)
                LogManager.LogFailure("Number of hosts was not found to be 0!", "expected 0", "actual " + _Designer.Diagram.Hosts.Count.ToString());

            CloseSolution();
        }

		/// <summary>
		/// Cleans VS IDE after the suite.
		/// </summary>
		public override void Cleanup()
		{
			LogManager.InitScenario("Restore docking of windows.");
			try
			{
				_Toolbox.AutoHide = _AutoHide_Toolbox;
				App.PropertyBrowser.AutoHide = _AutoHidePropertyBrowser;
			}
			catch (Exception e)
			{
				LogManager.LogFailure(e);
			}

			base.Cleanup();
		}

		[STAThread()]
		public static new int Main()
		{
			return Suite.Main();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\sdktools\factory\xtest\sources.inc ===
TARGETPATH=..\lib
TARGETTYPE=LIBRARY

386_STDCALL=0
USE_NATIVE_EH=1
USE_LIBCMT=1

XDK_LIB_PATH=$(BASEDIR)\public\xdk\lib-mar02
XDK_INC_PATH=$(BASEDIR)\public\xdk\inc-mar02

INCLUDES=$(XDK_INC_PATH);$(INCLUDES);..
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\sdktools\factory\xtest\xgrafx\xgrafx\xgrafx.cpp ===
//-----------------------------------------------------------------------------
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// xgrafx.cpp - Graphics testing module for xmta.
//
//-----------------------------------------------------------------------------

#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"
#include "crc32.h"
//********************************************************
//Some special code for performing the hardware CRC check.
//
DWORD g_DoChecksum = 0;
DWORD g_Channel = 0;
DWORD g_Value[3];


void __cdecl ChecksumCallback(D3DVBLANKDATA *pData)
{
	if(g_DoChecksum)
	{
		if(g_Channel > 0)
		{
			//OutputDebugString(L"Local CRC callback");
			g_Value[g_Channel - 1] = *(volatile DWORD *)0xFD680840 & 0x00FFFFFF;
		}

		if(g_Channel < 3)
		{
			*(volatile DWORD *)0xFD680844 = 0x411 | (g_Channel << 8);
			*(volatile DWORD *)0xFD680844 = 0x410 | (g_Channel << 8);

			g_Channel++;
		}
		else
		{
			g_Channel = 0;
			g_DoChecksum = 0;
		}
	}
}


/*
void __cdecl ChecksumCallback(DWORD Frame)
{
	if(g_DoChecksum)
	{
		if(g_Channel < 3)
		{
			//OutputDebugString(L"Local CRC callback");
			g_Value[g_Channel ] = *(volatile DWORD *)0xFD680840 & 0x00FFFFFF;
		}

		if(g_Channel > 0)
		{
			*(volatile DWORD *)0xFD680844 = 0x411 | ((g_Channel-1) << 8);
			*(volatile DWORD *)0xFD680844 = 0x410 | ((g_Channel-1) << 8);

			g_Channel--;
		}
		else
		{
			g_Channel = 3;
			g_DoChecksum = 0;
		}
	}
}
*/


void GetScreenChecksum(DWORD *pRed, DWORD *pGreen, DWORD *pBlue)
{
	g_Value[0] = g_Value[1] = g_Value[2] = 0;
	g_DoChecksum = 1;
	g_Channel = 0;

	D3DDevice_BlockUntilVerticalBlank();
	
	g_DoChecksum = 1;
	g_Channel = 0;

	while(g_DoChecksum)
	{
		D3DDevice_BlockUntilVerticalBlank();
	}
	
	*pRed	= g_Value[0];
	*pGreen	= g_Value[1];
	*pBlue	= g_Value[2];
}



IMPLEMENT_MODULELOCKED (CXModuleGrafx);

bool CXModuleGrafx::InitializeParameters ()
{
	if (!CTestObj::InitializeParameters ())
		return false;

	//Init params before attempting to retrieve.
	//Params for all tests
	m_pBackBuffer       = NULL;
    m_BackBufferFormat  = g_d3dpp.BackBufferFormat;
    m_DepthBufferFormat = g_d3dpp.AutoDepthStencilFormat;
	m_hardwareCRC = GetCfgInt( L"hardware_crc", 1);

	//Params for 3DSurface Test
	m_pBackgroundVB		= NULL;
	m_pSpotLightTexture = NULL;
	m_dwDisplayWidth    = g_d3dpp.BackBufferWidth;
    m_dwDisplayHeight   = g_d3dpp.BackBufferHeight;
	_stprintf(m_modeString, _T("%lux%lu"), m_dwDisplayWidth, m_dwDisplayHeight);
	m_bpp				= 32;
	


	//Params for vidmemory test
	m_pD3Ds = NULL;
	m_newSurfaces = 0;
	
	//Params for shapes test
	m_pVB = NULL;
	m_pVB2 = NULL;
	m_pVB3 = NULL;
	m_pTriangles = NULL;
	m_pTriangles2 = NULL;
	m_pTriangles3 = NULL;

	m_numTriangles = 0;

	if (CheckAbort (HERE)) return true;

	//Params required for all tests.
	m_expectedCRC = GetCfgUint( L"crc", 0xffffffff);
	m_testScenes = GetCfgInt( L"scenes", 1);
		
	//Video memory test
	m_mbytesTested = GetCfgUint( L"mbytes_tested", 32);

	//Video memory patern test
	m_vidmemPattern = (unsigned char)GetCfgInt( L"bit_pattern", 0xAA);
		
	//Params for Shapes test
	m_numTriangles = GetCfgInt(L"triangles", 21800);
		
	
	//---------------------------
	// ** Params for HDTV Test **
	//
	//Global params.
	m_HDTVTestPattern = GetCfgString( L"test", NULL);

	m_HDTVmode = GetCfgString( L"hdtv_mode", NULL);
	m_wPixelThreshold = (WORD)GetCfgUint( L"pixel_thresh", 0);
	m_wThresholdRangeStep = (WORD)GetCfgUint( L"range_step", 10);
	m_wHSyncThreshold = (WORD)GetCfgUint( L"hsync_thresh", 0);
	m_wVSyncThreshold = (WORD)GetCfgUint( L"vsync_thresh", 0);
	m_dwTolerance = GetCfgUint( L"tol", 0);
	m_testRetries = GetCfgInt( L"retries", 1);
	m_secondsToDisplay = 1000 * (GetCfgInt( L"std", 0));

	//Pixelcount test params.
	m_dwExpectedGreenCount = GetCfgUint( L"green", 0);
	m_dwExpectedRedCount = GetCfgUint( L"red", 0);
	m_dwExpectedBlueCount = GetCfgUint( L"blue", 0);
	m_PixelCountPattern = GetCfgInt( L"pattern", 2);
	m_bBitmapFromFile = GetCfgInt(L"bitmap_from_file", 0);
	_stprintf(m_BitmapFileName, _T("%s_pattern.bmp"),m_modeString);
	
	//Timings test params.
	m_VertFrontPorch1 = (BYTE)GetCfgInt( L"vfp1", -1);
	m_VertBackPorch1 = (BYTE)GetCfgInt( L"vbp1", -1);
	m_VertFrontPorch2 = (BYTE)GetCfgInt( L"vfp2", -1);
	m_VertBackPorch2 = (BYTE)GetCfgInt( L"vbp2", -1);
	m_wVertSyncLow = (WORD)GetCfgUint( L"vsl", -1);
	m_wVertSyncHigh = (WORD)GetCfgUint( L"vsh", -1);
	m_wHorizBackPorch = (WORD)GetCfgUint( L"hbp", -1);
	m_wHorizFrontPorch = (WORD)GetCfgUint( L"hfp", -1);
	m_wHorizSyncLow = (WORD)GetCfgUint( L"hsl", -1);
	m_wHorizSyncHigh = (WORD)GetCfgUint( L"hsh", -1);
	
	//AnalogColors test params.
	m_wNumLines = (WORD)GetCfgUint( L"lines", -1);
	m_wNumSamples = (WORD)GetCfgUint( L"samples", -1);
	m_wStartLine = (WORD)GetCfgUint( L"start_line", -1);
	m_hDelay = (BYTE)GetCfgInt( L"h_delay", -1);
	m_wLinearTolerance = (WORD)GetCfgUint( L"dac_tolerance", -1);
	m_GY_LowerThreshold = (WORD)GetCfgUint( L"gy_lower", -1);
	m_BPb_LowerThreshold = (WORD)GetCfgUint( L"bpb_lower", -1);
	m_RPr_LowerThreshold = (WORD)GetCfgUint( L"rpr_lower", -1);
	m_GY_UpperThreshold = (WORD)GetCfgUint( L"gy_upper", -1);
	m_BPb_UpperThreshold = (WORD)GetCfgUint( L"bpb_upper", -1);
	m_RPr_UpperThreshold = (WORD)GetCfgUint( L"rpr_upper", -1);
	
	//TriLevel Sync parameters
	m_syncMode = GetCfgInt(L"sync_mode", -1);
	m_syncType = GetCfgString( L"sync_type", NULL);
		
	//pColorData is used by both the DAC and TriLevel tests.
	pColorData = NULL;

		
	if(m_hardwareCRC)//Use hardware CRC.
	{
		ReportDebug(DEBUG_LEVEL1, L"Test will use HARDWARE CRC calculations.\n");
		D3DDevice_SetVerticalBlankCallback(ChecksumCallback);
		//D3DDevice_SetVerticalBlankCallback(D3DTest_ChecksumCallback);
	}

    return TRUE;
}


DWORD CXModuleGrafx::UpdateImageRectCRC(LONG height, BYTE *pBits, LONG pitch, int bytesPerLine)
{
	// Update the CRC with pixel data using the provided memory parameters
	DWORD crc = DEFAULT_CRC;
	LONG line;
	
	for (line=0; line<height; line++) {
		crc = ::updateCRC32(pBits, bytesPerLine, crc);
		pBits += pitch;
		ReportDebug(DEBUG_LEVEL2, _T("Line%d, CRC=0x%x\n"),line, crc);
	}
	
	return crc;
}

DWORD CXModuleGrafx::GetDisplayBufferCRC()
{
	// Update the CRC with pixel data using the provided memory parameters
	DWORD dwRed = 0;
	DWORD dwGreen = 0;
	DWORD dwBlue = 0;
	DWORD dwCompositeCRC = 0;

	//D3DTest_GetScreenChecksum(&dwRed, &dwGreen, &dwBlue);
	GetScreenChecksum(&dwRed, &dwGreen, &dwBlue);
	dwCompositeCRC = dwRed*dwGreen*dwBlue;
	
	ReportDebug(DEBUG_LEVEL1, _T("HardwareCRC: Red=0x%x, Green=0x%x, Blue=0x%x\n"),dwRed, dwGreen, dwBlue);
	ReportDebug(DEBUG_LEVEL1, _T("Composite HardwareCRC=0x%x\n"), dwCompositeCRC);
	
	return dwCompositeCRC;
}

VOID CXModuleGrafx::ReportD3DError(DWORD error)
{

	switch(error)
	{
		case D3D_OK:
			err_DIRECTX_API (m_modeString, error, L"D3D_OK - No error occurred");
			break;

		case D3DERR_CONFLICTINGRENDERSTATE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_CONFLICTINGRENDERSTATE - Currently set render states can't be used together");
			break;

		case D3DERR_CONFLICTINGTEXTUREFILTER:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_CONFLICTINGTEXTUREFILTER - Current texture filters can't be used together");
			break;

		case D3DERR_CONFLICTINGTEXTUREPALETTE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_CONFLICTINGTEXTUREPALETTE - Current textures can't be used simultaneously");
			break;

		case D3DERR_DEVICELOST:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_DEVICELOST - Device is lost and can't be restored, so rendering is not possible");
			break;

		case D3DERR_DEVICENOTRESET:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_DEVICENOTRESET - Device cannot be reset");
			break;

		case D3DERR_DRIVERINTERNALERROR:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_DRIVERINTERNALERROR - Internal driver error");
			break;

		case D3DERR_INVALIDCALL:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_INVALIDCALL - The method call is invalid. For example, a method's parameter may have an invalid value");
			break;

		case D3DERR_INVALIDDEVICE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_INVALIDDEVICE - The requested device type is not valid");
			break;

		case D3DERR_MOREDATA:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_MOREDATA - There is more data available than the specified buffer size can hold");
			break;

		case D3DERR_NOTAVAILABLE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_NOTAVAILABLE - This device does not support the queried technique");
			break;

		case D3DERR_NOTFOUND:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_NOTFOUND - The requested item was not found");
			break;

		case D3DERR_OUTOFVIDEOMEMORY:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_OUTOFVIDEOMEMORY - Direct3D does not have enough display memory to perform the operation");
			break;

		case D3DERR_TOOMANYOPERATIONS:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_TOOMANYOPERATIONS - Application is requesting more texture-filtering operations than the device supports");
			break;

		case D3DERR_UNSUPPORTEDALPHAARG:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDALPHAARG - Device does not support a specified texture-blending argument for the alpha channel");
			break;

		case D3DERR_UNSUPPORTEDALPHAOPERATION:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDALPHAOPERATION - Device does not support a specified texture-blending operation for the alpha channel");
			break;

		case D3DERR_UNSUPPORTEDCOLORARG:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDCOLORARG - Device does not support a specified texture-blending argument for color values");
			break;

		case D3DERR_UNSUPPORTEDCOLOROPERATION:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDCOLOROPERATION - Device does not support a specified texture-blending operation for color values");
			break;

		case D3DERR_UNSUPPORTEDFACTORVALUE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDFACTORVALUE - Device does not support the specified texture factor value");
			break;

		case D3DERR_UNSUPPORTEDTEXTUREFILTER:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDTEXTUREFILTER - Device does not support the specified texture filter");
			break;

		case D3DERR_WRONGTEXTUREFORMAT:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_WRONGTEXTUREFORMAT - Pixel format of the texture surface is not valid");
			break;

		case E_FAIL:
			err_DIRECTX_API (m_modeString, error, L"E_FAIL - An undetermined error occurred inside the Direct3D subsystem");
			break;

		case E_INVALIDARG:
			err_DIRECTX_API (m_modeString, error, L"E_INVALIDARG - An invalid parameter was passed to the returning function");
			break;

//		case E_INVALIDCALL:
//			err_DIRECTX_API (error, L"E_INVALIDCALL - The method call is invalid. For example, a method's parameter may have an invalid value.");
//			break;

		case E_OUTOFMEMORY:
			err_DIRECTX_API (m_modeString, error, L"E_OUTOFMEMORY - Direct3D could not allocate sufficient memory to complete the call");
			break;
	}

}


VOID CXModuleGrafx::MainCleanup()
{  //Called befor exiting under any condition.

	//Release all additional surfaces that may have been created.
	for(int i = 0; i < m_newSurfaces; i++)
	{
		SAFE_RELEASE(m_pD3Ds[i]);
	}

	SAFE_DELETE_ARRAY(m_pD3Ds);
	SAFE_DELETE_ARRAY(m_pTriangles);
	SAFE_DELETE_ARRAY(m_pTriangles2);
	SAFE_DELETE_ARRAY(m_pTriangles3);
	SAFE_RELEASE(m_pBackgroundVB);
	SAFE_RELEASE( m_pVB);
	SAFE_RELEASE( m_pVB2);
	SAFE_RELEASE( m_pVB3);
	SAFE_RELEASE( m_pBackBuffer);
	SAFE_RELEASE( m_pSpotLightTexture);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\test\inc\medialoader.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	medialoader.h

Abstract:

	copies media files from a server to the xbox

Author:

	Jeff Sullivan (jeffsul) 24-Jul-2001

Revision History:

	24-Jul-2001 jeffsul
		Initial Version

//------------------------------------------------------------------------------
//	Regular Expressions for finding files:
//
//	*	find 0 or more matches
//	+	find 1 or more matches
//	?	find 0 or 1 matches
//
//	()	grouping operator
//
//	\w  is the same as [a-z A-Z 0-9]	(alphanumeric)
//	\d	is the same as [0-9]			(numeric)
//	\s	is the same as [ \f\t\r\n]		(white space)
//
//	Example:
//	==> media_directory/file(\d*)(\w?).(/w/w/w)
//	would find any files in media_directory that begin with "file" followed by any number
//	of digits, then one or more alphanumeric characters, and finally a file extension of 
//	three alphanumeric characters (i.e., file112b.wav, file.txt, file336.1b3, etc. )
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//	Getting a certain number of files:
//	
//	%X	where X is the number of files to find
//
//	Example:
//	==> media_directory/(\w*).wav%3
//	would find 3 files that match the search criteria, in this case, 3 wav files in
//	the media_directory directory
//------------------------------------------------------------------------------


--*/

#ifndef __MEDIALOADER_H__
#define __MEDIALOADER_H__

#ifndef _X86_
#define _X86_
#endif

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <xbox.h>

#define MLCOPY_ALWAYS		0x0000
#define MLCOPY_IFNEWER		0x0001
#define MLCOPY_IFNOTEXIST	0x0002
#define MLCOPY_MAXVALUE		0x0002

#define COPY_ALWAYS			MLCOPY_ALWAYS
#define COPY_IF_NEWER		MLCOPY_IFNEWER
#define COPY_IF_NOT_EXIST	MLCOPY_IFNOTEXIST

typedef struct _MEDIAFILEDESC				// a structure describing which files to copy from
{											// a remote server and how to copy them...
	LPSTR	lpszFromPath;					// file to search for on remote server (can use wildcards)
	LPSTR	lpszToPath;						// directory where to store the remote file on xbox
	DWORD	dwFlags;						// flags describing how to copy the file
} MEDIAFILEDESC, *PMEDIAFILEDESC;


/*++

Routine Description:

	Grabs media files from a server to the xbox

Arguments:

	IN MEDIAFILEDESC MediaFileDesc[]	-	array of structures describing what files to copy to xbox

Return Value:

	S_OK on succes
	E_XX on failure

--*/
extern HRESULT _stdcall
LoadMedia( 
	IN MEDIAFILEDESC MediaFileDesc[]		// array of structures describing what files to copy to xbox
);


/*++

Routine Description:

	Gets media file descriptions from an .ini file and passes them to LoadMedia

Arguments:

	IN LPCSTR	lpszIniFile	-	path to an initialization file that describes which media files to load

Return Value:

	S_OK on succes
	E_XX on failure

--*/
#if 0
extern HRESULT _stdcall
LoadMediaFromIni( 
	IN LPCSTR	lpszIniFile					// path to an initialization file that describes which media files to load
);
#endif 0


/*++

Routine Description:

	sets the error level for media loader, any errors at or below this level will be output
	the default is set to 5 to output all information
	5  general info about what the medialoader is doing
	4  notifications about file states (already exists, up to date, overwriting, etc)
	3  warnings that are produced when media loader is given bad input (couldnt find as many files as requested, file missing from .ini, etc)
	2  warnings when media loader couldnt do what it was instructed to do for whatever reason
	1  errors generally having to do with file io (usually problems like file names that are too long), usually recoverable but doesnt guarantee that you get the results that you wanted
	0  hopefully youll never see these, if you do, it means I probably messed something up with my code or the network is down, not very recoverable


Arguments:

	IN INT nErrorLevel - level of errors to be displayed ( 0-1 = errors, 2-3 = warnings, 4-5 = info )

Return Value:

	None

--*/
extern VOID _stdcall
MLSetErrorLevel( 
	IN INT nErrorLevel 
);

#if 0
/*++

Routine Description:

	gets an integer value from an .ini file

Arguments:

	IN LPCSTR	lpAppName	-	section name
	IN LPCSTR	lpKeyName	-	key name
	IN INT		nDefault	-	return value if key name not found
	IN LPCSTR	lpFileName	-	initialization file name

Return Value:

	The value found in the .ini on success
	nDefault on failure

--*/
extern INT _stdcall
GetIniInt( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN INT		nDefault,					// return value if key name not found
	IN LPCSTR	lpFileName					// initialization file name
);


/*++

Routine Description:

	gets a floating point value from an .ini file

Arguments:

	IN LPCSTR	lpAppName	-	section name
	IN LPCSTR	lpKeyName	-	key name
	IN FLOAT	fDefault	-	return value if key name not found
	IN LPCSTR	lpFileName	-	initialization file name

Return Value:

	The value found in the .ini on success
	fDefault on failure

--*/
extern FLOAT _stdcall
GetIniFloat( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN FLOAT	fDefault,					// return value if key name not found
	IN LPCSTR	lpFileName					// initialization file name
);


/*++

Routine Description:

	gets a string from an .ini file and copies it into lpReturnedString

Arguments:

	IN LPCSTR	lpAppName			-	section name
	IN LPCSTR	lpKeyName,			-	key name
	IN LPCSTR	lpDefault,			-	return value if key name not found
	OUT LPSTR	lpReturnedString,	-	holds the returned string
	IN DWORD	nSize,				-	max size of returned string
	IN LPCSTR	lpFileName			-	initialization file name

Return Value:

	The string found in the .ini on success
	lpDefault on failure

--*/
extern INT _stdcall
GetIniString( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN LPCSTR	lpDefault,					// return value if key name not found
	OUT LPSTR	lpReturnedString,			// holds the returned string
	IN DWORD	nSize,						// max size of returned string
	IN LPCSTR	lpFileName					// initialization file name
);


/*++

Routine Description:

	gets a pre-defined constant value from an .ini file

Arguments:

	IN LPCSTR	lpAppName	-	section name
	IN LPCSTR	lpKeyName	-	key name
	IN DWORD	dwDefault	-	return value if key name not found
	IN LPCSTR	lpFileName	-	initialization file name

Return Value:

	The vlaue of the constant found in the .ini on success
	dwDefault on failure

--*/
extern DWORD _stdcall
GetIniConst( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN DWORD	dwDefault,					// return value if key name not found
	IN LPCSTR	lpFileName					// initialization file name
);


/*++

Routine Description:

	gets a constant or enumerated value from its string equivalent

Arguments:

	IN CONST CHAR*	szStr	-	constant's name
	IN INT			cchStr	-	length of szStr
	OUT PDWORD		pval	-	pointer to DWORd to store value

Return Value:

	returns TRUE if the constant is found, FALSE otherwise

--*/
extern BOOL _stdcall
GetConst(
	IN CONST CHAR*	szStr, 
	IN INT			cchStr, 
	OUT PDWORD		pval
);
#endif 0
	
#endif // #ifndef __MEDIALOADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\ui\xapp\DSound.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Camera.h"

#ifndef DSMIXBIN_VALID
#define DSMIXBIN_VALID 0x7FFFFFFF
#endif

extern "C" extern DWORD g_dwDirectSoundOverrideSpeakerConfig;

#ifdef _WINDOWS
#pragma comment(lib, "dxguid.lib")
#define _D3DTYPES_H_
#pragma comment(lib, "dsound.lib")
#endif

#ifdef _XBOX
#include <initguid.h>
#endif

#include <dsound.h>

#include "Sound.h"

static bool DSound_Init();

//
// BUGBUG: copied from disc.cpp
//
#define DISC_VIDEO      4
extern int g_nDiscType;

LPDIRECTSOUND g_pDirectSound = NULL;
HANDLE g_hDirectSoundThread = NULL;

DWORD WINAPI DirectSoundThreadProc(LPVOID pvParameter)
{
    while(g_pDirectSound)
    {
        DirectSoundDoWork();
        Sleep(100);
    }

    return 0;
}

LPDIRECTSOUNDBUFFER XAppCreateSoundBuffer(WAVEFORMATEX* pwfx, int nByteCount, DWORD dwFlags)
{/*
	if (g_pDirectSound == NULL && !DSound_Init())
		return NULL;

	LPDIRECTSOUNDBUFFER lpDirectSoundBuffer = NULL;
	DSBUFFERDESC dsbd;
	ZeroMemory(&dsbd, sizeof (DSBUFFERDESC));
	dsbd.dwSize = sizeof (DSBUFFERDESC);

	dsbd.dwFlags = dwFlags;
#ifndef _XBOX
	dsbd.dwFlags |= DSBCAPS_GLOBALFOCUS;
#endif
	dsbd.dwBufferBytes = nByteCount;
	dsbd.lpwfxFormat = pwfx;

	HRESULT hr = g_pDirectSound->CreateSoundBuffer(&dsbd, &lpDirectSoundBuffer, NULL);

#ifdef _XBOX

    if(SUCCEEDED(hr))
    {
        lpDirectSoundBuffer->SetHeadroom(1200);
    }

#endif

	return lpDirectSoundBuffer;
*/
	return NULL;
}

void XAppSetSoundBufferData(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, UINT nByteOffset, UINT nByteCount, const void* pvData)
{
/*
	LPVOID pbBuffer;
	DWORD dwBufferLength;

	ASSERT(pDirectSoundBuffer != NULL);

	VERIFYHR(pDirectSoundBuffer->Lock(nByteOffset, nByteCount, &pbBuffer, &dwBufferLength, NULL, NULL, 0L));

	CopyMemory(pbBuffer, pvData, nByteCount);

	VERIFYHR(pDirectSoundBuffer->Unlock(pbBuffer, dwBufferLength, NULL, 0));
*/
}

void XAppSetSoundBufferNotify(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, int nPositionCount, DSBPOSITIONNOTIFY* positions)
{
/*
#ifdef _XBOX
	pDirectSoundBuffer->SetNotificationPositions(nPositionCount, positions);
#else
	LPDIRECTSOUNDNOTIFY pDSNotify;
	VERIFYHR(pDirectSoundBuffer->QueryInterface(IID_IDirectSoundNotify, (void**)&pDSNotify));
	VERIFYHR(pDSNotify->SetNotificationPositions(nPositionCount, positions));
	VERIFYHR(pDSNotify->Release());
#endif
*/
}

static bool DSound_Init()
{
/*
	HRESULT hr;

	TRACE(_T("Initializing DirectSound...\n"));
	ASSERT(g_pDirectSound == NULL);

	//
	// BUGBUG: remove this hack to prevent dsound from initializing when we're playing a DVD
	//
	if (DISC_VIDEO == g_nDiscType)
	{
		//LogComError(E_FAIL, "DSound_Init: Not initializing with DVD-Video disc in drive");
		return false;
	}

#ifdef _XBOX

    DWORD dwSpeakerConfig = XAudioGetSpeakerConfig();

    if(DSSPEAKER_MONO == DSSPEAKER_BASIC(dwSpeakerConfig))
    {
        g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_COMBINED(DSSPEAKER_MONO, 0);
    }
    else
    {
        g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_COMBINED(DSSPEAKER_STEREO, 0);
    }

#endif

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDirectSound, NULL)))
	{
		LogComError(hr, "DSound_Init: DirectSoundCreate");
		return false;
	}

    if (FAILED(hr = g_pDirectSound->SetMixBinHeadroom(DSMIXBIN_VALID, 0)))
    {
		LogComError(hr, "DSound_Init: SetMixBinHeadroom");
	}

#ifdef _XBOX

    DWORD dwThreadId;
    g_hDirectSoundThread = CreateThread(NULL, 0, DirectSoundThreadProc, NULL, 0, &dwThreadId);
    if (!g_hDirectSoundThread)
    {
		LogComError(hr, "DSound_Init: failed to create DirectSound worker thread");
		return false;
	}

#else

	ASSERT(theApp.m_hWnd != NULL);
	if (FAILED(hr = g_pDirectSound->SetCooperativeLevel(theApp.m_hWnd, DSSCL_PRIORITY)))
	{
		LogComError(hr, "DSound_Init: SetCooperativeLevel");
		// Not fatal!
	}

	DSBUFFERDESC dsbdesc;
	dsbdesc.dwSize = sizeof (dsbdesc);
	dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_GLOBALFOCUS;
	dsbdesc.dwBufferBytes = 0;
	dsbdesc.dwReserved = 0;
	dsbdesc.lpwfxFormat = NULL;
	dsbdesc.guid3DAlgorithm = GUID_NULL;

	LPDIRECTSOUNDBUFFER pDSBPrimary;
	if (FAILED(hr = g_pDirectSound->CreateSoundBuffer(&dsbdesc, &pDSBPrimary, NULL)))
	{
		TRACE(_T("\002CreateSoundBuffer with DSBCAPS_GLOBALFOCUS failed, trying without...\n"));
		dsbdesc.dwFlags &= ~DSBCAPS_GLOBALFOCUS;
		if (FAILED(hr = g_pDirectSound->CreateSoundBuffer(&dsbdesc, &pDSBPrimary, NULL)))
		{
			LogComError(hr, "DSound_Init: CreateSoundBuffer");
			return false;
		}
	}

	WAVEFORMATEX wfx;
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 2;
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = wfx.wBitsPerSample / 8 * wfx.nChannels;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	TRACE(_T("SetFormat..."));
	if (FAILED(hr = pDSBPrimary->SetFormat(&wfx)))
		LogComError(hr, "DSound_Init: SetFormat");

	pDSBPrimary->Release();
#endif
*/
	return true;
}

void DSound_Exit()
{
/*
	if (g_pDirectSound != NULL)
    {
		g_pDirectSound->Release();
        g_pDirectSound = NULL;
    }

    if (g_hDirectSoundThread != NULL)
    {
        CloseHandle(g_hDirectSoundThread);
    }
 */
 }

void DSound_Frame()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\online\xodash\aseConv\ASEConv.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "std.h"
#include "ASEConv.h"
#include "ASEScene.h"

#include "utilities.h"
#include "XOConst.h"
#include "XBInput.h"
#include "Globals.h"
#include "CSVFile.h"
#include "TextureCache.h"
#include "MaterialLibrary.h"

#include "DSoundManager.h"
#include "ntiosvc.h"

//#include "ntiosvc.h"
//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
ASEConv*    g_pAseApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;
CMaterialLibrary g_MaterialLib;

float* g_fAppTime = 0;
TCHAR* g_szAppDir = NULL;

CNtIoctlCdromService g_cdrom;
int g_nDiscType = eDiscNone;
int GetDiscType();



//-----------------------------------------------------------------------------
// Name: ASEConv()
// Desc: Constructor
//-----------------------------------------------------------------------------
ASEConv::ASEConv()
{
    // Initialize member variables
    g_pAseApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
	m_d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
	m_d3dpp.MultiSampleType = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN;
	m_d3dpp.EnableAutoDepthStencil = 0;
	m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.Flags = D3DPRESENTFLAG_INTERLACED;	
	m_d3dpp.hDeviceWindow = NULL;
	m_d3dpp.Windowed = FALSE;


    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
	g_fAppTime = &m_fAppTime;
    _tcscpy( m_szAppDir, _T("d:\\") );
	g_szAppDir = m_szAppDir;

    curFile = 0;

    
    m_ConvertedFiles = NULL;
}

ASEConv::~ASEConv()
{
   
}


//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT ASEConv::Create()
{
    HRESULT hr = S_OK;

    // Create the Direct3D object
    DbgPrint( "XBApp: Creating Direct3D...\n" );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        DbgPrint( "XBApp: Unable to create Direct3D!\n");
        return E_FAIL;
    }

    // Create the device
    DbgPrint( "XBApp: Creating the D3D device...\n");
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        DbgPrint( "XBApp: Could not create D3D device!\n");
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    DbgPrint( "XBApp: Creating gamepad devices...\n");
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        DbgPrint( "XBApp: Call to CreateGamepads() failed!\n" );
        return hr;
    }

    // Initialize the app's device-dependent objects
    DbgPrint("XBApp: Initializing the app...\n");
    if( FAILED( hr = Initialize() ) )
    {
        DbgPrint("XBApp: Call to Initialize() failed!\n" );
        return hr;
    }

	// retreive the status of DVD/CD Rom 
		g_cdrom.Open(1);
        g_nDiscType = GetDiscType();
	
		// initialize DSound 
	if(!DSoundManager::Instance())
	{
		hr = E_OUTOFMEMORY; 
	}
	
	hr = DSoundManager::Instance()->Initialize();
    if ( FAILED( hr ) )
    {
	    ASSERT( !"XOApplication::InitAudio fail to init DSound");
	}

	return hr;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID ASEConv::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    m_pd3dDevice->Release();
    m_pD3D->Release(  );

    CTranslator::Instance()->Cleanup();

     for ( ULONG i =0; i < m_nConvertedFileCount; i++ )
    {
        if ( m_ConvertedFiles[i].m_pAseName )
            delete [] m_ConvertedFiles[i].m_pAseName;

       for ( int j = 0; j < m_ConvertedFiles[i].m_nTextButtonCount; j++ )
       {
           delete [] m_ConvertedFiles[i].m_pTextButtonNames[j];
       }
    }

    delete [] m_ConvertedFiles;
    m_ConvertedFiles = 0;
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT ASEConv::Run()
{
    
	HRESULT hr;
    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
    
        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------
		
		hr = Update();
        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}



HRESULT ASEConv::Update()
{
	HRESULT hr = S_OK;
	// Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;


        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Handle special input combo to trigger a reboot to the Xbox Dashboard
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }
        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------
        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        float oldTime = m_fTime;
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = oldTime - m_fTime;
        if ( m_fElapsedTime >.1f || m_fElapsedTime < 0.f )
            m_fElapsedTime = .1f;
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        if ( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] == 1)
        {
            curFile++;
            if ( curFile >= m_nConvertedFileCount )
                curFile = 0;
            m_pScene->SaveBinary( m_ConvertedFiles[curFile].m_pAseName );
            DbgPrint( "Saving\n" );
        }
        else if ( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] == 1 )
        {
            curFile++;
            if ( curFile >= m_nConvertedFileCount )
                curFile = 0;

            m_pScene->Cleanup();
            m_pScene->LoadFromXBG(g_pd3dDevice, m_ConvertedFiles[curFile].m_pAseName, m_ConvertedFiles[curFile].m_pTextButtonNames[0] );
            DbgPrint( "Loading\n" );
        }

		return hr;
}

//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT ASEConv::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}

HRESULT ASEConv::Cleanup()
{
	HRESULT hr = S_OK;


	if ( m_pScene )
		delete m_pScene;


    hr = DSoundManager::Instance()->Cleanup();
	if (FAILED(hr))
	{
		DbgPrint("XOApplication::Cleanup - fail to cleanup DirectSound, hr = 0x%x", hr);
	}
	else
	{
		DbgPrint("XOApplication::Cleanup - DirectSound clean");
	}

	return hr;
}

HRESULT ASEConv::Render()
{
	if ( m_pd3dDevice )
	{
	
		m_pd3dDevice->BeginScene();

		// Clear the backbuffer 
		m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB( (int)0, (int)0, (int)0 ), 1.0f, 0L );

		if ( m_Gamepad->bPressedAnalogButtons[0] )
		{
//			m_pButton->ToggleRotation();
		}

		m_pScene->Render( (DWORD)m_fElapsedTime );


		m_pd3dDevice->EndScene();
	}

	return S_OK;
}


HRESULT ASEConv::FrameMove()
{

	m_pScene->FrameMove( m_DefaultGamepad, m_fElapsedTime);
	return S_OK;
}



HRESULT ASEConv::Initialize()
{
	HRESULT hr = S_OK;
    CTranslator::Instance()->Initialize();
    if ( !m_pScene )
	{

        GetFilesToOpen( ASE_PATH_ANSI, ".ase" );

        char textPath[256];
        strcpy( textPath, MEDIA_PATH_ANSI );
        strcat( textPath, "text.csv" );
        CSVFile csvFile;
        csvFile.open( textPath );

		// BugBug: Testing
		//strcpy( pFileName, "d:\\media\\ase\\sphere.ase");

		//-----------------------------------------------------
		// Fully loads and parses an ASE File.  These files are
		// output by 3D Studio MAX's ASCII Scene Exporter.
        ULONG i = 0;
        while( true )
        {
            if ( i >= m_nConvertedFileCount )
                break;

		    HANDLE hFile = CreateFile( m_ConvertedFiles[i].m_pAseName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );

		    if ( hFile == INVALID_HANDLE_VALUE )
            {
                DbgPrint( "Couldn't open the ase file\n" );
                ASSERT( !"Couldn't open an ASE file\n" );
                return -1;
            }

		    //------------------------------------------
		    // Check if exists by getting size
		    long aseFileSize =  ::GetFileSize( hFile, 0 );

		    _ASSERT(aseFileSize > 0);

		    //---------------------------------------
		    // Create Buffer to read entire file into
		    char *aseContents = new char[aseFileSize+1];
		    aseContents[aseFileSize] = 0;
		    _ASSERT(aseContents != NULL);

		    unsigned long nBytesRead = 0;
		    
		    int dataRead = ::ReadFile( hFile, aseContents,sizeof( char )*aseFileSize, &nBytesRead, NULL);
		    _ASSERT(nBytesRead == aseFileSize);



		    ::CloseHandle( hFile );

            m_pScene = new ASEScene;

            char* pExt = strstr( m_ConvertedFiles[i].m_pAseName, ".ase" );
            *pExt = 0;
            char* pFileNoPath = ( m_ConvertedFiles[i].m_pAseName + strlen(  ASE_PATH_ANSI ) );

            char tmpFileName[256];
            strcpy( tmpFileName, pFileNoPath );

            void    LoadStrings( CSVFile* pFile, const char* aseName, const char** pSceneName, long sceneCount   );

            m_pScene->LoadStrings( &csvFile, pFileNoPath, (const char** )m_ConvertedFiles[i].m_pTextButtonNames, m_ConvertedFiles[i].m_nTextButtonCount );

            strcpy( m_ConvertedFiles[i].m_pAseName, XBG_PATH_ANSI );
            strcat( m_ConvertedFiles[i].m_pAseName, tmpFileName );
            strcat( m_ConvertedFiles[i].m_pAseName, ".xbg" );


		    m_pScene->Load( aseContents);

		    delete [] aseContents;
		    aseContents = NULL;

            m_pScene->SaveBinary( m_ConvertedFiles[i].m_pAseName );

            i++;
        }


	}	
    
    float fZero = 0.0f;
	float fOne = 1.0f;


    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, 0 );
	g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	g_pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
	g_pd3dDevice->SetRenderState(D3DRS_DITHERENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGCOLOR, 0);
	g_pd3dDevice->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_NONE);
//	g_pd3dDevice->SetRenderState(D3DRS_FOGSTART, ); // Undocumented!
//	g_pd3dDevice->SetRenderState(D3DRS_FOGEND, ); // Undocumented!
	g_pd3dDevice->SetRenderState(D3DRS_FOGDENSITY, *(LPDWORD)&fOne);
	g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZBIAS, 0);
	g_pd3dDevice->SetRenderState(D3DRS_RANGEFOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILREF, 0);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILMASK, 0xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);
//	g_pd3dDevice->SetRenderState(D3DRS_TEXTUREFACTOR, ); // Undocumented!
	g_pd3dDevice->SetRenderState(D3DRS_WRAP0, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP1, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP2, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP3, 0);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0);
	g_pd3dDevice->SetRenderState(D3DRS_COLORVERTEX, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LOCALVIEWER, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
	g_pd3dDevice->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR2);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	g_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, D3DVBF_DISABLE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE, *(LPDWORD)&fOne);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE_MIN, *(LPDWORD)&fOne);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_A, *(LPDWORD)&fOne);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_B, *(LPDWORD)&fZero);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_C, *(LPDWORD)&fZero);
	g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
//	g_pd3dDevice->SetRenderState(D3DRS_PATCHEDGESTYLE, ); // Undocumented!
//	g_pd3dDevice->SetRenderState(D3DRS_PATCHSEGMENTS, ); // Undocumented!
//	g_pd3dDevice->SetRenderState(D3DRS_DEBUGMONITORTOKEN, ); // Undocumented!
//	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE_MAX, ); // Undocumented!
	g_pd3dDevice->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);
//	g_pd3dDevice->SetRenderState(D3DRS_TWEENFACTOR, ); // Undocumented!
	return hr;
}


void    ASEConv::GetFilesToOpen( const char* path, const char* pExtension )
{   
    curFile = 0;
    char pInputFileName[255];
    strcpy( pInputFileName, MEDIA_PATH_ANSI );
    strcat( pInputFileName, "sceneToLoad.csv" );

    CSVFile file;
    long sceneToLoadFileOpenResult = file.open( pInputFileName );
    if ( NO_ERR == sceneToLoadFileOpenResult )
    {
        long rowCount = file.getTotalRows();
        m_ConvertedFiles = new XBGFileData[rowCount];
        memset( m_ConvertedFiles, 0, sizeof( XBGFileData ) * rowCount );

        m_nConvertedFileCount = rowCount;
        for ( int i = 0; i < rowCount; i++ )
        {
            char aseFileName[256];
            file.readString( i+1, 1, aseFileName, 255 );

            long len = strlen( path ) + strlen( pExtension ) + strlen( aseFileName ) + 1;

            m_ConvertedFiles[i].m_pAseName = new char[len];
            // make the path
            strcpy( m_ConvertedFiles[i].m_pAseName, path );
            strcat( m_ConvertedFiles[i].m_pAseName, aseFileName );

            // swap extensions
            char* pExt = strstr( m_ConvertedFiles[i].m_pAseName, "." );
            if ( pExt )
                strcpy( pExt, pExtension );
            else
                strcat( m_ConvertedFiles[i].m_pAseName, pExtension );

            // count the number of button and text objects
            for ( int j = 1; j < file.getTotalCols(); j++ )
            {
                char buttonTextName[256];
                buttonTextName[0] = 0;
                file.readString( i+1, j+1, buttonTextName, 255 );

                if ( strlen( buttonTextName ) )
                {
                    m_ConvertedFiles[i].m_nTextButtonCount++;
                }
            }

            // now figure go ahead and allocate...
            if ( m_ConvertedFiles[i].m_nTextButtonCount )
            {
                m_ConvertedFiles[i].m_pTextButtonNames = new char*[m_ConvertedFiles[i].m_nTextButtonCount];
            }

            // do it again
            for ( int j = 0; j < m_ConvertedFiles[i].m_nTextButtonCount; j++ )
            {
                char buttonTextName[256];
                file.readString( i+1, j+2, buttonTextName, 255 );

                if ( strlen( buttonTextName ) )
                {
                    m_ConvertedFiles[i].m_pTextButtonNames[j] = new char[strlen(buttonTextName)+1];
                    strcpy( m_ConvertedFiles[i].m_pTextButtonNames[j], buttonTextName );
                }
            }


            
        }
    }
    else
        ASSERT( sceneToLoadFileOpenResult == 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\sdktools\factory\xtest\sendhost.cpp ===
// File that contains XMTA Host communication routines via TCP/IP

/*

OVERVIEW
--------
All communications between the UUT and the host are initiated by the UUT.  Some messages
from the UUT to the host do not require a response (ex., status messages).  Other messages
from the UUT to the host do require a response (ex. a message that requests that the
host capture an audio buffer from an audio card installed in the host and return the results
to the UUT).  This application demonstrates a simple protocol that allows communication
between the UUT and the host.  This implementation uses TCP/IP through Windows sockets.  A
UUT opens a single socket connection with the host when the test suite first initializes, and
uses the single socket for communication until the test suite completes.  The UUT can not
re-open a socket to the host once it is closed: if a socket closes in the middle of the test
suite (typically only happens if the host crashes, the network crashes, or the UUT crashes)
then the test suite must be restarted with a new socket.  In some situations, a host
may communicate with more than one UUT at a time (like in a run-in systems test envirnment);
in this situation, each socket connection represents a different UUT.

FUNCTION IMPLEMENTATION
-----------------------
For XBox test applications, a single socket is opened by the main() routine before any test
routines are executed.  Communication with the host is accomplished through a single function
call:

int iSendHost(DWORD dwMID, char *pcBufferToHost, DWORD dwBufferToHostLength, CHostResponse& CHR, DWORD *pdwBytesReceivedFromHost, DWORD *pdwErrorCodeFromHost, DWORD dwTimeout)

(in)  DWORD dwMID - the Message ID of the message being sent to the host
(in)  char *pcBufferToHost - pointer to a buffer containing the data/message to send to the host
(in)  DWORD dwBufferToHostLength - the number of bytes in the pcBufferToHost to send to the host
(in/out) CHostResponse& CHR - reference to a CHostResponse structure that contains the pointer to the host response buffer
(out) DWORD *pdwBytesReceivedFromHost - the number of bytes actually returned in the buffer from the host
(out) DWORD *pdwErrorCodeFromHost - the partial error code returned from the host (0 is there was no error)
(in)  DWORD dwTimeout - the maximum number of seconds that the calling routine is willing to wait for a response from the host

returns: EVERYTHINGS_OK if the communication was successful
         some other error if communication was not successful

The iSendHost routine allocates a response buffer for messages that need a response from
the host.  In order to prevent memory leaks, the CHostResponse class is used to manage the
pointer to the response buffer.  A test that calls iSendHost and expects a response simply
needs to create a local instance of CHostResponse and pass it to iSendHost.  When the local
CHostResponse instance passes out of scope, the response buffer associated with it will be
deleted automatically.  If you decide to assign the response buffer pointer to another local
pointer to analyze the response data form the host
(for example, pMyStruct = (PMY_STRUCT)CHR.pvBufferFromHost), be sure to only make the
assignment AFTER the call to iSendHost, and be sure to only access the response buffer
when the CHostResponse instance is in scope.  Declaring the CHostResponse instance at
the top of the test can eliminate scope worries (it won't go out of scope until the test
exits).  The following code is an example of good usage of iSendHost.

An example of how a test can implement a call to iSendHost that requires a response
IMPLEMENT_TESTUNLOCKED (AUDIO, external_analog_loopback, 5)
{
	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD dwMID, dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost;
	DWORD dwTimeout = 3000; // 5 minute timeout
	int iError;

	.
	.
	.
	// Set up the send buffer (send_buf) here as well as dwMID and dwBufferToHostLength

	
	if ((iError = g_host.iSendHost(dwMID, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, dwTimeout)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
		}
		else
		{
			// Process a communication error
		}
	}

	else if (CHR.pvBufferFromHost == NULL) // Don't access the response buffer if it is NULL
	{
		// The response buffer is NULL, so take appropriate action (like an error message)
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		// Analyze the response data from the host
	}

	.
	.
	.
}

For messages where no response is needed, such as general Status messages or keep-alive
messages, etc.  The following version of iSendHost can be used instead:

int iSendHost(DWORD dwMID, char *pcBufferToHost, DWORD dwBufferToHostLength)

The parameters are the same as those in the long version of the iSendHost function.

Other functions can be written to wrap this function and make it easier to use for specific
message types.  For example, a routine could wrap up a Status message type so that tests
can send status messages using a much simpler function interface.

TCP/IP DATA PACKET FORMAT
-------------------------
The actual format that the socket communication routines use for data transmissions is rather
simple.  For UUT-to-host messages, the format is as follows:

Offset  0:  4 bytes - Total Length of Message
Offset  4:  4 bytes - Unique message number for this socket
Offset  8:  4 bytes - Message ID (MID) that indicates what type of message this is
Offset 12:  4 bytes - DWORD checksum of the above 3 DWORDs; this helps ensure the integrity of the header
Offset 16:  X bytes - Data (the actual message contents)

Total Length of Message is the length of the entire message, including itself.
This item is needed to inform the host exactly how big the message is.  Because TCP/IP is a
stream-based protocol instead of a message-based protocol, this length parameter is vital to
inform the host how big each message is (which then allows the host to determine where each message
starts and stops).

Unique message number for this socket is an identifier that is created by the sending
routines on the UUT that is unique for that message on that socket connection.  This
identifier is passed back from the host in the response message so that the UUT knows
which message to the host pairs up with which response from the host.

Message ID is the unique ID assigned to this message type.  Each message type whithin a
test architecture has a unique message ID, so that the host can determine what DLL,
service, or utility on the host can process the message.  Currently, message IDs are registered
in the MID.H file in the UHC 2000 project in SourceSafe. 

Data is the actual message that is sent to the host.  The Data blob will itself have a format that
tells the DLL, service, or utility on the host that processes the message what to do.
The format of the data blob, though, is of no significance to the communication routines
on the UUT and host; only the supporting routines and utilities that actually process
the contents of the data blob need to know its structure.

For Host-to-UUT messages, the format is as follows:

Offset  0:  4 bytes - Total Length of Message
Offset  4:  4 bytes - Unique message number for this socket
Offset  8:  4 bytes - Returned Error Code from Host
Offset 12:  X bytes - Data (the actual message contents)

Total Length of Message is the length of the entire message, including itself.
This item is needed to inform the UUT exactly how big the message is.  Because TCP/IP is a
stream-based protocol instead of a message-based protocol, this length parameter is vital to
inform the UUT how big each message is (which then allows the UUT to determine where each message
starts and stops).

Unique message number for this socket is an identifier that is created by the sending
routines on the UUT that is unique for that message on that socket connection.  This
identifier is passed back from the host in the response message so that the UUT knows
which message to the host pairs up with which response from the host.

Returned Error Code from Host is a partial error code (only values 0, and 0xF00 through 0xFFF
are allowed to be returned) that indicates what error happened on the host.  If this value
is zero, then no error happened and the Data buffer contains valid returned data.  If this
value is non-zero, then this value can be combined with the module number and test number
by the test that receives this response to form a complete error code; the data buffer
contains a unicode error message that describes the nature of the error (which can be
displayed in an error reporting routine by the calling test, if desired).  Please note
that the returned error codes are not unique across a test architecture.  For example, many
host utilities may use the error code 0xF30 to represent different errors, but the error
code is unique within a single utility.

Data is the actual response message that is sent to the UUT.  The Data blob will itself
have a format that provides the UUT with useful response information.  The format of the
data blob, though, is of no significance to the communication routines on the UUT and
host; only the supporting routines that actually process the contents of the data blob
need to know its structure.

*/

#include "stdafx.h"
#include "host.h"

// NTSTATUS
typedef LONG NTSTATUS;
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) 
#define NTHALAPI     DECLSPEC_IMPORT

// SMBus functions.
extern "C"
{
NTHALAPI
NTSTATUS
NTAPI
HalReadSMBusValue(
	IN UCHAR SlaveAddress,
	IN UCHAR CommandCode,
	IN BOOLEAN ReadWordValue,
	OUT ULONG *DataValue
	);

NTHALAPI
NTSTATUS 
NTAPI
HalWriteSMBusValue(
	IN UCHAR SlaveAddress,
	IN UCHAR CommandCode,
	IN BOOLEAN WriteWordValue,
	IN ULONG DataValue
	);
}
#if !defined( STAND_ALONE_MODE )
int CHost::iSendToHost(SOCKET sock, char *pcAppDataToSend, int iAppDataToSendLength)
{
	int iNumLeft = 0, iSendIndex = 0, iNumSent;

	iNumLeft = iAppDataToSendLength;
	iSendIndex = 0;
	while (iNumLeft > 0)
	{
		iNumSent = send(sock, &pcAppDataToSend[iSendIndex], iNumLeft, 0);

		if (iNumSent == SOCKET_ERROR)
		{
//			printf("Could not send data to the port\n");
			return (COULD_NOT_SEND_DATA_TO_PORT);
		}
		iNumLeft = iNumLeft - iNumSent;
		iSendIndex = iSendIndex + iNumSent;
	}

	return (EVERYTHINGS_OK);
}

// This routine spin-waits for a reception of data.  If the data is not received by the specified time, then
// the routine will return with a TIMEOUT failure.  Because this spin-waits, it should only be used
// for initialization, not for regular communication.
int CHost::iReceive(SOCKET sock, char *pcReceiveBuffer, DWORD dwSizeOfReceiveBuffer, DWORD *pdwActualSize, double local_timeout_value, LARGE_INTEGER *pliLocalTimeout)
{
	DWORD dwNumSentToHere = 4;
	int iNumLeft, iReceiveIndex;
	DWORD dwNumReceivedThisTime, dwFlags;
	int iStatus = EVERYTHINGS_OK;
	WSABUF DataBuf;
	WSAOVERLAPPED wsaRecvOverlapped;
	int iReceiveResult;
	int iError, iWTemp = 0;
	WSAEVENT WSAEvent = WSA_INVALID_EVENT;

	iNumLeft = sizeof(DWORD);
	iReceiveIndex = 0;
	if ((WSAEvent = WSACreateEvent()) == WSA_INVALID_EVENT)
		return (COULD_NOT_CREATE_SOCKET_EVENT);
	while ((iNumLeft > 0) && (!TimedOut(local_timeout_value, pliLocalTimeout))) // Receive the DWORD message length indicator
	{
		DataBuf.len = iNumLeft;
		DataBuf.buf = ((char *)&dwNumSentToHere) + iReceiveIndex;
		dwFlags = 0;
		wsaRecvOverlapped.hEvent = WSAEvent;
		if (!WSAResetEvent(WSAEvent))
		{
			WSACloseEvent(WSAEvent);
			return (COULD_NOT_RESET_SOCKET_EVENT);
		}
		iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
//		iNumReceivedThisTime = recv(sock, ((char *)&dwNumSentToHere) + iReceiveIndex, iNumLeft, 0);
		if (iReceiveResult == 0)
		{
			if (dwNumReceivedThisTime == 0)
			{
//				printf("Connection closed by client\n");
				WSACloseEvent(WSAEvent);
				return (CONNECTION_CLOSED);
			}
		}
		else if (iReceiveResult == SOCKET_ERROR)
		{
			if ((iWTemp = WSAGetLastError()) == WSA_IO_PENDING) // The reception is pending, so wait for it
			{
				while ((!WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags)) && (!TimedOut(local_timeout_value, pliLocalTimeout)))
				{
					iError = WSAGetLastError();
					if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
					{
/*
						switch (iError)
						{
							case WSANOTINITIALISED:
								printf("The socket wan't initialized\n");
								break;
							case WSAENETDOWN:
								printf("The network is down!\n");
								break;
							case WSAENOTSOCK:
								printf("This is not a valid socket\n");
								break;
							case WSA_INVALID_HANDLE:
								printf("The event handle is bad\n");
								break;
							case WSA_INVALID_PARAMETER:
								printf("One or more of the parameters is bad\n");
								break;
							case WSA_IO_INCOMPLETE:
								printf("This isn't a real failure, the transfer just isn't complete yet\n");
								break;
							case WSAEFAULT:
								printf("A parameter fault has happened\n");
								break;
							case WSA_IO_PENDING:
								printf("I/O operation is in progress\n");
								break;
							default:
								printf("Unknown error, %8.8lx\n", (DWORD)iError);
						}
*/
//						printf("Could not receive data from the client inside overlapped result routine size\n");
						WSACloseEvent(WSAEvent);
						return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
					}
				}
			}
			else
			{
//				printf("Could not receive data from the client\n");
				WSACloseEvent(WSAEvent);
				return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
			}
		}
		else // Some other bad error happened, so abort
		{
//			printf("Could not receive data from the client\n");
			WSACloseEvent(WSAEvent);
			return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
		}
		iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
		iReceiveIndex = iReceiveIndex + dwNumReceivedThisTime;
	}
	// Don't need an extra timeout check here because it will happen below the next while() loop
	if (dwNumSentToHere - 4 > dwSizeOfReceiveBuffer)
	{
		dwNumSentToHere = dwSizeOfReceiveBuffer + 4; // Do this so we don't overflow the receive buffer
//		printf("Receive buffer overrun\n");
		iStatus = RECEIVE_BUFFER_OVERRUN; // Don't return yet; actually try to receive the data
	}

	
	
	// Now receive the actual message
	iNumLeft = (int)(dwNumSentToHere-4);
	*pdwActualSize = 0; // Indicate that 0 bytes have been received so far
	while ((iNumLeft > 0) && (!TimedOut(local_timeout_value, pliLocalTimeout))) // Receive the DWORD message length indicator
	{
		DataBuf.len = iNumLeft;
		DataBuf.buf = &pcReceiveBuffer[*pdwActualSize];
		dwFlags = 0;
		wsaRecvOverlapped.hEvent = WSAEvent;
		if (!WSAResetEvent(WSAEvent))
		{
			WSACloseEvent(WSAEvent);
			return (COULD_NOT_RESET_SOCKET_EVENT);
		}
		iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
//		iNumReceivedThisTime = recv(sock, &pcReceiveBuffer[*pdwActualSize], iNumLeft, 0);
		if (iReceiveResult == 0)
		{
			if (dwNumReceivedThisTime == 0)
			{
//				printf("Connection closed by client\n");
				WSACloseEvent(WSAEvent);
				return (CONNECTION_CLOSED);
			}
		}
		else if (iReceiveResult == SOCKET_ERROR)
		{
			if (WSAGetLastError() == WSA_IO_PENDING) // The reception is pending, so wait for it
			{
				while ((!WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags)) && (!TimedOut(local_timeout_value, pliLocalTimeout)))
				{
					iError = WSAGetLastError();
					if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
					{
//						printf("Could not receive data from the client inside overlapped result routine data\n");
						WSACloseEvent(WSAEvent);
						return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
					}
				}
			}
			else
			{
//				printf("Could not receive data from the client\n");
				WSACloseEvent(WSAEvent);
				return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
			}
		}
		else // Some other bad error happened, so abort
		{
//			printf("Could not receive data from the client\n");
			WSACloseEvent(WSAEvent);
			return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
		}

		iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
		*pdwActualSize = *pdwActualSize + dwNumReceivedThisTime;
	}
	if (TimedOut(local_timeout_value, pliLocalTimeout))
	{
//		printf("Timed out waiting to receive data from the host\n");
		WSACloseEvent(WSAEvent);
		return (RECEIVE_TIMEOUT);
	}

	WSACloseEvent(WSAEvent);
	return (iStatus);
}



// Try to establish a connection with the host for up to dblTimeout seconds.  The
// returned socket is to be used for all future communication with the host.
int CHost::iInitHostCommunication(char *strHostName, LPCTSTR strSerialNumber, double dblTimeout, SOCKET *psock)
{
	UNREFERENCED_PARAMETER(dblTimeout);
	#define SOCKET_VERSION_TO_USE                0x0202
#ifdef RNR_MODE
	#define FIRST_SOCKET_PORT_TO_TRY             2001
#else
	#define FIRST_SOCKET_PORT_TO_TRY             2000
#endif
	#define LOCAL_TIMEOUT_VALUE                  50.0 // This is the max number of seconds the send/receive handshake should take
	#define MAX_RANDOM_RETRY_DELAY               3 // This is the max number of seconds to delay between socket connection retries
	#define DEFAULT_HOST_ADDRESS                 0x01018e8e 

	WSADATA wsaData;
//	HOSTENT *phent = NULL;
	struct sockaddr_in tcpaddr;
	int port = FIRST_SOCKET_PORT_TO_TRY;
	DWORD dwReceivedBufferSize;
	const DWORD MSG_HEADER_SIZE = 16;
	DWORD dwConnectSendBuffer[30], dwConnectReceiveBuffer[3];
//	LARGE_INTEGER liGlobalTimeout;
	LARGE_INTEGER liLocalTimeout;
//	int iTimedOut;
	int iStatus = EVERYTHINGS_OK;
	DWORD dwSleepTime;
	unsigned long ulReceiveFromHostThread;
	int iRT1 = 0, iS1 = 0;
//	char cHostName[100];
//	unsigned long ulMyAddr;
	DWORD dwMaxRetryDelay = MAX_RANDOM_RETRY_DELAY;
#if defined(_XBOX)
UNREFERENCED_PARAMETER(strHostName);

	// DWORD dwProtocolBufferSize;
	// LPWSAPROTOCOL_INFO pWSAProtocolInfoBuffer = NULL;
	// int iNumProtocolBuffers = 0;
	
	int XNetStartupError;

	XNetStartupParams xnsp;
	XNADDR xnaddr;

	memset(&xnsp, 0, sizeof(xnsp));
	xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
	xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
	if ((XNetStartupError = XNetStartup(&xnsp)) != NO_ERROR)
	{
		return (COULD_NOT_LOAD_SOCKET_LIBRARY);
	}
	memset(&xnaddr, 0, sizeof(xnaddr));
	/*xnaddr.bSizeOfStruct = sizeof(XNADDR);*/	// Volt - exists no more
	// Wait for the IP address to be assigned
	while ((XNetGetTitleXnAddr(&xnaddr) & (XNET_GET_XNADDR_DHCP | XNET_GET_XNADDR_GATEWAY)) == 0)
		Sleep(50);
/*
	int iSocketInit;
	if ((iSocketInit = XnetInitialize(NULL, TRUE)) != NO_ERROR)
	{
		return (COULD_NOT_LOAD_SOCKET_LIBRARY);
	}
*/
#endif

 	if (WSAStartup(SOCKET_VERSION_TO_USE, &wsaData) != 0)
	{
		// Could not find a usable WinSock DLL.
//		printf("Could not use at least socket version %x\n", SOCKET_VERSION_TO_USE);
		return (SOCKET_VERSION_NOT_SUPPORTED);
	}
 
	// Confirm that the WinSock DLL supports 2.2.  Note that if the DLL supports
	// versions greater than 2.2 in addition to 2.2, it will still return
	// 2.2 in wVersion since that is the version we requested
 	if ( wsaData.wVersion != SOCKET_VERSION_TO_USE)
	{
		// Tell the user that we could not find a usable WinSock DLL.
//		printf("Could not use at least socket version %x\n", SOCKET_VERSION_TO_USE);
		return (SOCKET_VERSION_NOT_SUPPORTED);
	}
#if defined(_XBOX)
	// The routine below will find the server address and restrict it to one of the following values:
	// unsigned long ulHostAddresses[] = {0x01018e8e, 0x01108e8e, 0x01208e8e, 0x01308e8e, 0x01408e8e, 0x01508e8e};
	DWORD dwMyAddress = (DWORD)xnaddr.ina.S_un.S_addr;
	if ((dwMyAddress & 0x0000FFFF) != 0x00008e8e) // Make sure it is 142.142.x.x
		ulHost = DEFAULT_HOST_ADDRESS;
	else
	{
		if ((dwMyAddress & 0x00F00000) > 0x00500000) // 142.142.80 through 95.x is the highest address allowed
			ulHost = DEFAULT_HOST_ADDRESS;
		else
		{
			ulHost = (dwMyAddress & 0x00F0FFFF) | 0x01000000; // Form the address of the host
			if ((dwMyAddress & 0x00F00000) == 0x00000000) // 142.142.1 through 15.x has a host address of 142.142.1.0 (not 142.142.0.0)
				ulHost = ulHost | 0x00010000;
		}
	}
#else
	// Lets try looking up the host IP address using the host name
	//
	HOSTENT *phent = gethostbyname(strHostName);
	if (phent)
	{
		ulHost = *(unsigned long *)(phent->h_addr_list[0]);
	}
#endif 
	// The WinSock DLL is acceptable. Proceed.

	SeedRand(0);  // Seed the random number function here because we may need it to generate a random delay below

	// Now we know what the host IP address is, and we are connected
	// Try to handshake with the host
	for (;;)
	{
		for (;;) // Connect a socket again
		{
			if ((*psock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) != INVALID_SOCKET)
			{
				tcpaddr.sin_family = AF_INET;
				tcpaddr.sin_port = htons((unsigned short)port);
				tcpaddr.sin_addr.s_addr = ulHost;
				// Connect to the destination port.  This could timeout for around 50 seconds if the host
				// is not on the network.  This is a long time, but not too problematic because the UUT won't
				// have much to do if it can't communicate with the host anyway.  If the host is on the network
				// but not listening, then this will timeout in just a couple of seconds.
				if (connect(*psock, (SOCKADDR *)&tcpaddr, sizeof(tcpaddr)) == 0)
				{
					break; // We connected, so we know that this is the host
				}
				else
				{
					iStatus = COULD_NOT_CONNECT_TO_SOCKET;
				}
				closesocket(*psock);
			}
			else
			{
				iStatus =  COULD_NOT_GET_SOCKET_HANDLE;
			}
		}

		// Build the connection request message
		// 
		if (strSerialNumber)
		{
			DWORD length = (_tcslen (strSerialNumber) + 1) * sizeof (_TCHAR);

			dwConnectSendBuffer[0] = MSG_HEADER_SIZE + length;
			dwConnectSendBuffer[1] = (DWORD)rand();
			dwConnectSendBuffer[2] = MID_CONNECT_BY_UNIQUE_ID;

			memcpy (&dwConnectSendBuffer[4], strSerialNumber, length);
		}
		else
		{
#ifdef RNR_MODE
			BYTE SerialNumber[13];
			ULONG Size, Type, Error;
			TCHAR tSerialNumber[13];

			Error = XQueryValue(0x100, &Type, SerialNumber, sizeof SerialNumber, &Size);
			if(Error != NO_ERROR)  // Set the serial number to all 9s
			{
				memset(SerialNumber, '9', sizeof SerialNumber);
			}
			SerialNumber[12] = 0;
			if (sizeof(TCHAR) == sizeof(wchar_t))
				_stprintf(tSerialNumber, _T("%S"), SerialNumber);
			else
				_stprintf(tSerialNumber, _T("%s"), SerialNumber);

			dwConnectSendBuffer[0] = MSG_HEADER_SIZE + ((_tcslen(tSerialNumber) + 1) * sizeof(TCHAR));
			dwConnectSendBuffer[1] = (DWORD)rand();
			dwConnectSendBuffer[2] = MID_CONNECT_BY_UNIQUE_ID;

			memcpy (&dwConnectSendBuffer[4], tSerialNumber, ((_tcslen(tSerialNumber) + 1) * sizeof(TCHAR)));
#else
			dwConnectSendBuffer[0] = MSG_HEADER_SIZE;
			dwConnectSendBuffer[1] = (DWORD)rand();
			dwConnectSendBuffer[2] = MID_CONNECT_BY_MAC_ADDRESS;
#endif
		}
		dwConnectSendBuffer[3] = dwConnectSendBuffer[0] + dwConnectSendBuffer[1] + dwConnectSendBuffer[2];

		iStatus = EVERYTHINGS_OK;
		StartTimer(&liLocalTimeout); // Get the starting time for the loop
		if ((iS1 = iSendToHost(*psock, (char *)dwConnectSendBuffer, dwConnectSendBuffer[0])) == EVERYTHINGS_OK)
		{
			dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
			if ((iRT1 = iReceive(*psock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
			{
				if (dwConnectReceiveBuffer[0] == dwConnectSendBuffer[1]) // Received the ACK
				{
					dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
					if ((iRT1 = iReceive(*psock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
					{
						if ((dwConnectReceiveBuffer[0] == dwConnectSendBuffer[1]) && (dwConnectReceiveBuffer[1] == 0)) // Received proper response
							break;
					}
					else
					{
						iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
					}
				}
				else
				{
					iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
				}
			}
			else
			{
				iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
			}
		}
		else
		{
			iStatus = COULD_NOT_SEND_CONNECT_HANDSHAKE;
		}
		// We did not get the correct handshake, so tear down the socket and start over
		closesocket(*psock);
		dwSleepTime = (DWORD)((((double)((unsigned int)rand()))/(double)RAND_MAX) * (double)(dwMaxRetryDelay-1) * (double)1000);
		dwSleepTime = dwSleepTime + 1000;
		Sleep(dwSleepTime); // Sleep a random amount of time
		if (dwMaxRetryDelay < 20)
			dwMaxRetryDelay += 2;
	}

	// We must have had a successful handshake.

	if (iStatus == EVERYTHINGS_OK)
	{
		// Do whatever global initialization required by vReceiveFromHostThread here
		InitializeCriticalSection(&HostResponseEntryListCriticalSection); // Initialize the critical section before it is used
		InitializeCriticalSection(&SendToHostCriticalSection);
		InitializeCriticalSection(&SocketAccessCriticalSection);
		// Create a manual-reset event.  Non-signaled to start with
		if ((hAckReceivedEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
			iStatus =  COULD_NOT_CREATE_ACK_EVENT;
		else
		{
			pHostResponsesPendingList = NULL;
			gdwLocalID = 1;
			g_dwLocalIDToAck = 0; // Zero is a reserved value indicating that no ACK is expected
			// Start the thread that receives results from the host
			ulReceiveFromHostThread = _beginthread(&vReceiveFromHostThreadEntry, 0, this);  // Start the thread; no parameters need to be passed here
			if (ulReceiveFromHostThread == -1) // Couldn't start the thread
				iStatus = COULD_NOT_START_RECEIVE_THREAD;
/*
// Starts a thread that blinks the LED green or orange once every second
			unsigned long ulAlivePrintThread = _beginthread(&vAlivePrintThreadEntry, 0, this);  // Start the thread; no parameters need to be passed here
			if (ulAlivePrintThread == -1) // Couldn't start the thread
				iStatus = COULD_NOT_START_RECEIVE_THREAD;
*/
		}
	}
	return (iStatus);
}


// This routine will perform communication with the host computer.  Any function can use this routine to
// pass a command to the host computer and receive a response.
int CHost::iSendHost(DWORD dwMID, char *pcBufferToHost, DWORD dwBufferToHostLength, CHostResponse& CHR, DWORD *pdwBytesReceivedFromHost, DWORD *pdwErrorCodeFromHost, DWORD dwTimeout)
{
	int iStatus = EVERYTHINGS_OK;
	DWORD dwNumToSend = 0, dwNumLeft = 0, dwSendIndex = 0, dwNumSent;
	char *pcSendBuffer = NULL;
	double dblTimeout = (double)dwTimeout;
	LARGE_INTEGER liTimeout;
	PHOST_RESPONSE_ENTRY pListTemp = NULL;
	DWORD dwLocalID;
	bool bExpectResponse;
	CTestObj *test = GET_TESTOBJ_PTR;


	while(bSocketRestarting)
		Sleep(1000);
	// Set up returned variables to a "no response" status initially
	if (CHR.pvBufferFromHost != NULL) // Make sure the response buffer is deleted if it had contained something
	{
		delete [] CHR.pvBufferFromHost;
		CHR.pvBufferFromHost = NULL;
	}
	if (pdwBytesReceivedFromHost != NULL)
		*pdwBytesReceivedFromHost = 0;
	if (pdwErrorCodeFromHost != NULL)
		*pdwErrorCodeFromHost = 0;

	// Determine whether a response is expected/possible to return to the caller or not.
	if ((pdwBytesReceivedFromHost == NULL) || (pdwErrorCodeFromHost == NULL) || ((dwMID & 0x40000000) == 0))
		bExpectResponse = false;
	else
		bExpectResponse = true;

	StartTimer(&liTimeout); // Start the timeout timer right away

	// This should be the only code that ever accesses gdwLocalID so that we can guarantee its uniqueness across multiple
	// threads.  Using HostResponseEntryListCriticalSection is cheating; this really should have its own critical section,
	// but it seems silly to create another global critical section just for this.
	// Copy gdwLocalID to a stack-based variable so that future accesses to the value from the stack-based variable
	// will return the correct value, even if other threads have incremented the global variable in the mean time
	EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list
	gdwLocalID ++; // Increment the message ID to make sure it is a new value
	dwLocalID = gdwLocalID;
	LeaveCriticalSection(&HostResponseEntryListCriticalSection);

	// Create the full message to send (total length, ID, message ID, data)
	if ((pcSendBuffer = new char[dwBufferToHostLength + 16]) == NULL) // Allocate a buffer to send the data
	{
//		printf("Send: Could not allocate memory for a send buffer\n");
		return (COULD_NOT_ALLOCATE_SEND_BUFFER);
	}
	dwNumToSend = dwBufferToHostLength + 16; // Add space to contain message size, ID, MID, and header checksum
	if (dwBufferToHostLength > 0)
		memcpy(pcSendBuffer + 16, pcBufferToHost, dwBufferToHostLength); // Copy the data into the send buffer
//	dwMID = dwMID | MID_NO_ACK_EXPECTED; // Disabling QQQACKs
	*((DWORD *)(&pcSendBuffer[0])) = dwNumToSend; // The length field includes the length of everything that is sent
	*((DWORD *)(&pcSendBuffer[4])) = dwLocalID; // The ID for this specific message to the host
	*((DWORD *)(&pcSendBuffer[8])) = dwMID; // The message ID of this message to the host
	*((DWORD *)(&pcSendBuffer[12])) = dwNumToSend + dwLocalID + dwMID; // Checksum of the header

	if (bExpectResponse) // There should be a response from the host, so add an entry into the HostResponsesPendingList
	{
		// Allocate a new list entry here
		if ((pListTemp = new HOST_RESPONSE_ENTRY) == NULL)
		{
			if (pcSendBuffer != NULL)
			{
				delete [] pcSendBuffer;
				pcSendBuffer = NULL;
			}
//			printf("Send: Could not allocate memory for a pending host response list entry\n");
			return (COULD_NOT_ALLOCATE_RESPONSE_LIST_ENTRY);
		}
		pListTemp->pcBufferFromHost = NULL;
		pListTemp->dwID = dwLocalID;
		pListTemp->dwActualBytesReceived = 0;
		pListTemp->iStatus = EVERYTHINGS_OK;
		pListTemp->dwReturnedErrorCode = 0;
		// Create an event and report an error if creation fails
		// Create an event for signaling when the response from the host has been captured
		// This handle cannot be inherited by a child process; Auto-reset the state to non-signaled Initial state is non-signaled
		if ((pListTemp->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
		{
			if (pcSendBuffer != NULL)
			{
				delete [] pcSendBuffer;
				pcSendBuffer = NULL;
			}
			if (pListTemp != NULL)
			{
				delete pListTemp;
				pListTemp = NULL;
			}
//			printf("Send: Could not create an event for signalling response reception from the host\n");
			return (COULD_NOT_CREATE_RESPONSE_EVENT);
		}
		
		EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list

		// Add the new list entry to the front of the list
		pListTemp->pNextEntry = pHostResponsesPendingList;
		pHostResponsesPendingList = pListTemp;

		LeaveCriticalSection(&HostResponseEntryListCriticalSection);
	}

	// Now that the response entry has been made, if applicable, send the message to the host
	dwNumLeft = dwNumToSend;
	dwSendIndex = 0;
	EnterCriticalSection(&SendToHostCriticalSection); // Make sure we send the whole message to the host without being interrupted by other threads' sends.
	g_dwLocalIDToAck = dwLocalID; // This is the Local ID to wait for an ACK
	ResetEvent(hAckReceivedEvent);
	while (dwNumLeft > 0) // Send the data
	{
		// Only allow a timeout if we haven't sent any data successfully yet.
		// Once we have started sending the message, we cannot stop until complete or
		// the communication with the host will go out of sync because TCP is a stream
		// protocol, not a message protocol.

//		do not check the timeout before sending
//		if (dwNumLeft == dwNumToSend)
//		{
//			if (TimedOut(dblTimeout, &liTimeout))
//				break;
			// Probably don't want to check for timeouts here because if a test aborts, we want
			// to be able to send any abort or error messages associated with the abort to the host
//			if (test != NULL)
//			{
//				if (test->CheckAbort(HERE))
//					break;
//			}
//		}
		// Since send() is blocking, we may be stuck here much longer than the specified timout
		// but that shouldn't matter too much because if we timeout due to a network problem
		// then we have nothing better to do then wait around because we can't communicate
		// our problem to the world anyway.
		EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
		dwNumSent = (DWORD)send(sock, &pcSendBuffer[dwSendIndex], (int)dwNumLeft, 0);
		LeaveCriticalSection(&SocketAccessCriticalSection);
		if (dwNumSent == SOCKET_ERROR)
		{
			int iE = WSAGetLastError();
			if (pcSendBuffer != NULL)
			{
				delete [] pcSendBuffer;
				pcSendBuffer = NULL;
			}
			LeaveCriticalSection(&SendToHostCriticalSection);
			vDeleteHostResponseListEntry(dwLocalID);
			g_dwLocalIDToAck = 0;
			if ((iE != WSAEINPROGRESS) && (iE != WSAENOBUFS))
			{
				SOCKET lsock = INVALID_SOCKET;
				struct sockaddr_in tcpaddr;
				int port = FIRST_SOCKET_PORT_TO_TRY;
				DWORD dwConnectSendBuffer[16], dwConnectReceiveBuffer[3];
				LARGE_INTEGER liLocalTimeout;
				int iRT1 = 0, iS1 = 0;
				DWORD MSG_HEADER_SIZE = 16;
				DWORD dwReceivedBufferSize;
				DWORD dwSleepTime;
				DWORD dwLocalMaxRetryDelay = MAX_RANDOM_RETRY_DELAY;

				bSocketRestarting = true;  // Block all other threads from accessing this routine
				Sleep(2000);  // Wait awhile for any threads to exit that might be in here
				// The socket is gone.  Reconnect and send an error at least
				shutdown (sock, SD_BOTH);
				closesocket(sock);
				sock = INVALID_SOCKET;

				// This is a bad socket error, so open a new socket to the host and complain
				for(;;) // Try to talk to the host again forever
				{
					WSADATA wsaData;

					dwSleepTime = (DWORD)((((double)((unsigned int)rand()))/(double)RAND_MAX) * (double)(dwLocalMaxRetryDelay-1) * (double)1000);
					dwSleepTime = dwSleepTime + 1000;
					Sleep(dwSleepTime); // Sleep a random amount of time
					if (dwLocalMaxRetryDelay < 10)
						dwLocalMaxRetryDelay += 2;
					if (lsock != INVALID_SOCKET)
						closesocket(lsock);
					lsock = INVALID_SOCKET;
					WSACleanup();
#ifdef _XBOX
					int XNetStartupError;
					XNetStartupParams xnsp;
					XNADDR xnaddr;
					DWORD dwWaitForIP;

					XNetCleanup();
					memset(&xnsp, 0, sizeof(xnsp));
					xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
					xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
					while ((XNetStartupError = XNetStartup(&xnsp)) != NO_ERROR)
					{
						Sleep(3000);
					}
					memset(&xnaddr, 0, sizeof(xnaddr));
					/*xnaddr.bSizeOfStruct = sizeof(XNADDR); */	// Volt - exists no more
					// Wait for the IP address to be assigned
					dwWaitForIP = 80;
					while ((XNetGetTitleXnAddr(&xnaddr) & (XNET_GET_XNADDR_DHCP | XNET_GET_XNADDR_GATEWAY)) == 0)
					{
						dwWaitForIP--;
						if (dwWaitForIP == 0)
							break;
						Sleep(50);
					}
					if (dwWaitForIP == 0) // No address was issued
						continue;
#endif
					if (WSAStartup(SOCKET_VERSION_TO_USE, &wsaData) != 0)
					{
						// Could not find a usable WinSock DLL.
						continue;
					}
#ifdef _XBOX
					// The routine below will find the server address and restrict it to one of the following values:
					// unsigned long ulHostAddresses[] = {0x01018e8e, 0x01108e8e, 0x01208e8e, 0x01308e8e, 0x01408e8e, 0x01508e8e};
					DWORD dwMyAddress = (DWORD)xnaddr.ina.S_un.S_addr;
					if ((dwMyAddress & 0x0000FFFF) != 0x00008e8e) // Make sure it is 142.142.x.x
						ulHost = DEFAULT_HOST_ADDRESS;
					else
					{
						if ((dwMyAddress & 0x00F00000) > 0x00500000) // 142.142.80 through 95.x is the highest address allowed
							ulHost = DEFAULT_HOST_ADDRESS;
						else
						{
							ulHost = (dwMyAddress & 0x00F0FFFF) | 0x01000000; // Form the address of the host
							if ((dwMyAddress & 0x00F00000) == 0x00000000) // 142.142.1 through 15.x has a host address of 142.142.1.0 (not 142.142.0.0)
								ulHost = ulHost | 0x00010000;
						}
					}
#else
					// Lets try looking up the host IP address using the host name
					//
					HOSTENT *phent = gethostbyname(m_strHostName);
					if (phent)
					{
						ulHost = *(unsigned long *)(phent->h_addr_list[0]);
					}
#endif
					if ((lsock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) != INVALID_SOCKET)
					{
						tcpaddr.sin_family = AF_INET;
						tcpaddr.sin_port = htons((unsigned short)port);
						tcpaddr.sin_addr.s_addr = ulHost;
						// Connect to the destination port.  This could timeout for around 50 seconds if the host
						// is not on the network.  This is a long time, but not too problematic because the UUT won't
						// have much to do if it can't communicate with the host anyway.  If the host is on the network
						// but not listening, then this will timeout in just a couple of seconds.
						if (connect(lsock, (SOCKADDR *)&tcpaddr, sizeof(tcpaddr)) == 0)
						{
							// Build the connection request message
							// 
#ifdef RNR_MODE
							BYTE SerialNumber[13];
							ULONG Size, Type, Error;
							TCHAR tSerialNumber[13];

							Error = XQueryValue(0x100, &Type, SerialNumber, sizeof SerialNumber, &Size);
							if(Error != NO_ERROR)  // Set the serial number to all 9s
							{
								memset(SerialNumber, '9', sizeof SerialNumber);
							}
							SerialNumber[12] = 0;
							if (sizeof(TCHAR) == sizeof(wchar_t))
								_stprintf(tSerialNumber, _T("%S"), SerialNumber);
							else
								_stprintf(tSerialNumber, _T("%s"), SerialNumber);

							dwConnectSendBuffer[0] = MSG_HEADER_SIZE + ((_tcslen(tSerialNumber) + 1) * sizeof(TCHAR));
							dwConnectSendBuffer[1] = (DWORD)rand();
							dwConnectSendBuffer[2] = MID_CONNECT_BY_UNIQUE_ID;

							memcpy (&dwConnectSendBuffer[4], tSerialNumber, ((_tcslen(tSerialNumber) + 1) * sizeof(TCHAR)));
#else
							dwConnectSendBuffer[0] = MSG_HEADER_SIZE;
							dwConnectSendBuffer[1] = (DWORD)rand();
							dwConnectSendBuffer[2] = MID_CONNECT_BY_MAC_ADDRESS;
#endif
							dwConnectSendBuffer[3] = dwConnectSendBuffer[0] + dwConnectSendBuffer[1] + dwConnectSendBuffer[2];

							iStatus = EVERYTHINGS_OK;
							StartTimer(&liLocalTimeout); // Get the starting time for the loop
							if ((iS1 = iSendToHost(lsock, (char *)dwConnectSendBuffer, dwConnectSendBuffer[0])) == EVERYTHINGS_OK)
							{
								dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
								if ((iRT1 = iReceive(lsock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
								{
									if (dwConnectReceiveBuffer[0] == dwConnectSendBuffer[1]) // Received the ACK
									{
										dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
										if ((iRT1 = iReceive(lsock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
										{
											if ((dwConnectReceiveBuffer[0] == dwConnectSendBuffer[1]) && (dwConnectReceiveBuffer[1] == 0)) // Received proper response
											{
												// We have connected and had a handshake.  Now send an error message
												TCHAR SendPrivateError[100];
												int iCurrent;
												CHostResponse CHRTemp;
												DWORD *pdwSendPrivateError = (DWORD *)SendPrivateError;
												
												pdwSendPrivateError[1] = (DWORD)rand();
												pdwSendPrivateError[2] = MID_UUT_ERROR;

												iCurrent = 16/sizeof(TCHAR);
												_stprintf(&SendPrivateError[iCurrent], _T("%s"), _T("SendHost.Main"));
												iCurrent += _tcslen(&SendPrivateError[iCurrent]) + 1;
												*((DWORD *)&SendPrivateError[iCurrent]) = 0x2E; // Socket dropped error code
												iCurrent += (4/sizeof(TCHAR));
												_stprintf(&SendPrivateError[iCurrent], _T("%s"), _T("The socket connection to the host was dropped"));
												iCurrent += _tcslen(&SendPrivateError[iCurrent]) + 1;

												pdwSendPrivateError[0] = iCurrent*sizeof(TCHAR);
												pdwSendPrivateError[3] = pdwSendPrivateError[0] + pdwSendPrivateError[1] + pdwSendPrivateError[2];

												iStatus = EVERYTHINGS_OK;
												StartTimer(&liLocalTimeout); // Get the starting time for the loop
												if ((iS1 = iSendToHost(lsock, (char *)pdwSendPrivateError, pdwSendPrivateError[0])) == EVERYTHINGS_OK)
												{
													dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
													if ((iRT1 = iReceive(lsock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
													{
														if (dwConnectReceiveBuffer[0] == pdwSendPrivateError[1]) // Received the ACK
														{
															// Error message sent correctly, now send a testing ended message
															pdwSendPrivateError[0] = 16;
															pdwSendPrivateError[1] = (DWORD)rand();
															pdwSendPrivateError[2] = MID_UUT_ENDING;
															pdwSendPrivateError[3] = pdwSendPrivateError[0] + pdwSendPrivateError[1] + pdwSendPrivateError[2];
															if ((iS1 = iSendToHost(lsock, (char *)pdwSendPrivateError, pdwSendPrivateError[0])) == EVERYTHINGS_OK)
															{
																dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
																if ((iRT1 = iReceive(lsock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
																{
																	if (dwConnectReceiveBuffer[0] == pdwSendPrivateError[1]) // Received the ACK
																	{
																		// Testing Ended message sent correctly
																		break;
																	}
																	else
																	{
																		iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
																	}
																}
																else
																{
																	iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
																}
															}
														}
														else
														{
															iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
														}
													}
													else
													{
														iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
													}
												}
											}
										}
										else
										{
											iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
										}
									}
									else
									{
										iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
									}
								}
								else
								{
									iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
								}
							}
							// We did not get the correct handshake, so tear down the socket and start over
						}
						else
						{
							iStatus = COULD_NOT_CONNECT_TO_SOCKET;
						}
					}
				} // end for(;;)
				// We only get here if we successfully sent the error and ended messages
				for (;;){}
			}
			return (COULD_NOT_SEND_DATA_TO_PORT);
		}
		dwNumLeft = dwNumLeft - dwNumSent;
		dwSendIndex = dwSendIndex + dwNumSent;
	}
// QQQAKC
///*
	while (!(TimedOut(dblTimeout, &liTimeout)))
	{
		if (WaitForSingleObject(hAckReceivedEvent, 1000) == WAIT_OBJECT_0)
			break;
		if (test != NULL)
		{
			if (test->CheckAbort(HERE))
				break;
		}
	}
//*/
	if (TimedOut(dblTimeout, &liTimeout))
	{
		g_dwLocalIDToAck = 0;

		vDeleteHostResponseListEntry(dwLocalID);
		LeaveCriticalSection(&SendToHostCriticalSection);
		return (ACK_TIMEOUT);
	}

	LeaveCriticalSection(&SendToHostCriticalSection);
	delete [] pcSendBuffer;
	pcSendBuffer = NULL;
	if (TimedOut(dblTimeout, &liTimeout))
	{
		vDeleteHostResponseListEntry(dwLocalID);
//		printf("Send: Timeout out trying to send data to the host\n");
		return (SEND_TIMEOUT);
	}
	if (test != NULL)
	{
		if (test->CheckAbort(HERE))
		{
			vDeleteHostResponseListEntry(dwLocalID);
			return (ABORT_RECEIVED);
		}
	}

	// Wait for a reply from the host only if applicable
	if (bExpectResponse)
	{
		// Wait for a response or a timeout condition
		// It is possible that this whole routine may take 2x iTimeOut if we wait almost
		// iTimeout seconds above and then iTimeout seconds here too.  That is not too big a deal
		// though and avoids having to do the time math here.
		while (!(TimedOut(dblTimeout, &liTimeout)))
		{
			if (WaitForSingleObject(pListTemp->hEvent, 1000) == WAIT_OBJECT_0)
				break;
			if (test != NULL)
			{
				if (test->CheckAbort(HERE))
					break;
			}
		}
		if (TimedOut(dblTimeout, &liTimeout))
		{
			vDeleteHostResponseListEntry(dwLocalID);
			return (RECEIVE_TIMEOUT);
		}
		if (test != NULL)
		{
			if (test->CheckAbort(HERE))
			{
				vDeleteHostResponseListEntry(dwLocalID);
				return (ABORT_RECEIVED);
			}
		}

		// The data is back, so let's parse it
		// pListTemp should still be a valid pointer to our list entry (even though its position in the list may have moved around)
		// Use the critical section just in case the receive routine gets another response that matches this ID (shouldn't happen)
		// and starts to muck with our data while we are parsing it out
		EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list

		CHR.pvBufferFromHost = pListTemp->pcBufferFromHost;
		*pdwBytesReceivedFromHost = pListTemp->dwActualBytesReceived;
		*pdwErrorCodeFromHost = pListTemp->dwReturnedErrorCode;
		iStatus = pListTemp->iStatus;

		LeaveCriticalSection(&HostResponseEntryListCriticalSection);

		vDeleteHostResponseListEntry(dwLocalID); // Close the event and remove this entry from the list
	}

	return (iStatus);
}

// Delete an entry from the Host Response List, if it exists
// WARNING: Do not access this routine from within the HostResponseEntryListCriticalSection.  Deadlock will result
void CHost::vDeleteHostResponseListEntry(DWORD dwID)
{
	PHOST_RESPONSE_ENTRY pListTemp = NULL, pPreviousListEntryTemp = NULL;

	EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list
	pPreviousListEntryTemp = pHostResponsesPendingList;
	pListTemp = pHostResponsesPendingList;
	if (pListTemp != NULL) // There is at least one entry in the list
	{
		while (pListTemp != NULL)
		{
			if (pListTemp->dwID == dwID)
			{
				if (pListTemp == pHostResponsesPendingList) // This is the first entry in the list
				{
					pHostResponsesPendingList = pHostResponsesPendingList->pNextEntry;
				}
				else // This is not the first entry in the list
				{
					pPreviousListEntryTemp->pNextEntry = pListTemp->pNextEntry;
				}
				pListTemp->pNextEntry = NULL;
				// This is how to close out an Event (whether or not it was set)
				CloseHandle(pListTemp->hEvent);
				delete pListTemp;
				break;
			}
			pPreviousListEntryTemp = pListTemp;
			pListTemp = pListTemp->pNextEntry;
		}
	}
	LeaveCriticalSection(&HostResponseEntryListCriticalSection);
	return;
}


// The entry point to the new thread that will allow access to the real vReceiveFromHostThread routine
void CHost::vReceiveFromHostThreadEntry(void *pthis)
{
	CHost *pHost = (CHost *)pthis;

	pHost->vReceiveFromHostThread();
}
// This thread receives all communication from the host after initial communication has
// been established.  Whenever a function sends a command to the host, this thread will
// capture and pass back the respose.
void CHost::vReceiveFromHostThread(void)
{
	DWORD dwNumSentToHere = 4;
	int iForever = 1;
	int iNumLeft, iReceiveIndex;
	DWORD dwNumReceivedThisTime;
	char *pcLocalBuffer;
	char *pcCopyBuffer;
	int iStatus;
	PHOST_RESPONSE_ENTRY pListTemp = NULL;
	int iActualBytesReceived; // Used to hold information about the received data
	DWORD dwID;                // Used to hold the message ID of the received data
	DWORD dwReturnedErrorCode;
	WSAEVENT WSAEvent = WSA_INVALID_EVENT;
	WSABUF DataBuf;
	WSAOVERLAPPED wsaRecvOverlapped;
	int iReceiveResult, iWTemp, iError;
	DWORD dwFlags;
	BOOL bResult;
	char pcDefaultBuffer[100]; // This buffer is use to receive useful data if the buffer allocation fails
	char pcScratchBuffer[100]; // This buffer is use to receive scratch data if the buffer allocation fails


	if ((WSAEvent = WSACreateEvent()) == WSA_INVALID_EVENT)
		return;
	while (iForever == 1) // This will be in a forever while() loop	
	{
		pcLocalBuffer = NULL;
		iStatus = EVERYTHINGS_OK;
		iNumLeft = sizeof(DWORD);
		iReceiveIndex = 0;
		while (iNumLeft > 0) // Receive the DWORD message length indicator
		{
			DataBuf.len = iNumLeft;
			DataBuf.buf = ((char *)&dwNumSentToHere) + iReceiveIndex;
			dwFlags = 0;
			wsaRecvOverlapped.hEvent = WSAEvent;
			WSAResetEvent(WSAEvent);

			EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
			iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
			LeaveCriticalSection(&SocketAccessCriticalSection);
			if (iReceiveResult == 0)
			{
				if (dwNumReceivedThisTime == 0) // The socket closed, so we can't do anything
				{
					WSACloseEvent(WSAEvent);
					return;
				}
			}
			else if (iReceiveResult == SOCKET_ERROR)
			{
				if ((iWTemp = WSAGetLastError()) == WSA_IO_PENDING) // The reception is pending, so wait for it
				{
					WSAWaitForMultipleEvents(1, &WSAEvent, FALSE, WSA_INFINITE, FALSE); // Wait for the data to be received
					for(;;)
					{
						EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
						bResult = WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags);
						LeaveCriticalSection(&SocketAccessCriticalSection);
						if (bResult)
							break;
						iError = WSAGetLastError();
						if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
						{
							WSACloseEvent(WSAEvent);
							return;
						}
						Sleep(5); // Don't hog all of the CPU time
					}
				}
				else // Could not receive data from the client for some reason, so exit
				{
					WSACloseEvent(WSAEvent);
					return;
				}
			}
			else // Some other bad error happened, so abort
			{
				WSACloseEvent(WSAEvent);
				return;
			}
			iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
			iReceiveIndex = iReceiveIndex + (int)dwNumReceivedThisTime;
		}

		if ((pcLocalBuffer = new char[dwNumSentToHere - 4]) == NULL) // Allocate a buffer to receive the data
		{
			pcCopyBuffer = pcDefaultBuffer;
			if ((int)(dwNumSentToHere-4) > sizeof(pcDefaultBuffer)) // Ensure we bring in the right amount of data
				iNumLeft = sizeof(pcDefaultBuffer);
			else
				iNumLeft = (int)(dwNumSentToHere-4);
			iStatus = COULD_NOT_ALLOCATE_RECEIVE_BUFFER;
		}
		else
		{
			pcCopyBuffer = pcLocalBuffer;
			iNumLeft = (int)(dwNumSentToHere-4);
		}

		iActualBytesReceived = iNumLeft; // This is the actual number of bytes that will be received
		// Now receive the actual message
		iReceiveIndex = 0; // Indicate that 0 bytes have been received so far
		while (iNumLeft > 0) // Receive the full message
		{
			DataBuf.len = iNumLeft;
			DataBuf.buf = &pcCopyBuffer[iReceiveIndex];
			dwFlags = 0;
			wsaRecvOverlapped.hEvent = WSAEvent;
			WSAResetEvent(WSAEvent);
			EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
			iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
			LeaveCriticalSection(&SocketAccessCriticalSection);
			if (iReceiveResult == 0)
			{
				if (dwNumReceivedThisTime == 0) // The socket closed, so we can't do anything
				{
					WSACloseEvent(WSAEvent);
					return;
				}
			}
			else if (iReceiveResult == SOCKET_ERROR)
			{
				if ((iWTemp = WSAGetLastError()) == WSA_IO_PENDING) // The reception is pending, so wait for it
				{
					WSAWaitForMultipleEvents(1, &WSAEvent, FALSE, WSA_INFINITE, FALSE); // Wait for the data to be received
					for(;;)
					{
						EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
						bResult = WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags);
						LeaveCriticalSection(&SocketAccessCriticalSection);
						if (bResult)
							break;
						iError = WSAGetLastError();
						if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
						{
							WSACloseEvent(WSAEvent);
							return;
						}
						Sleep(5); // Don't hog all of the CPU time
					}
				}
				else // Could not receive data from the client for some reason, so exit
				{
					WSACloseEvent(WSAEvent);
					return;
				}
			}
			else // Some other bad error happened, so abort
			{
				WSACloseEvent(WSAEvent);
				return;
			}

			iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
			iReceiveIndex = iReceiveIndex + (int)dwNumReceivedThisTime;
		}

		// If the buffer allocation failed above, read in the rest of the data and throw it away (we have the important stuff already)
		if ((iStatus == COULD_NOT_ALLOCATE_RECEIVE_BUFFER) && ((int)(dwNumSentToHere-4) > sizeof(pcDefaultBuffer)))
		{
			// There is still some data to read, so let's get to it.
			iNumLeft = (int)(dwNumSentToHere - 4) - sizeof(pcDefaultBuffer);
			while (iNumLeft > 0)
			{
				DataBuf.len = (iNumLeft < sizeof(pcScratchBuffer)) ? iNumLeft : sizeof(pcScratchBuffer);
				DataBuf.buf = &pcScratchBuffer[0];
				dwFlags = 0;
				wsaRecvOverlapped.hEvent = WSAEvent;
				WSAResetEvent(WSAEvent);
				EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
				iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
				LeaveCriticalSection(&SocketAccessCriticalSection);
				if (iReceiveResult == 0)
				{
					if (dwNumReceivedThisTime == 0) // The socket closed, so we can't do anything
					{
						WSACloseEvent(WSAEvent);
						return;
					}
				}
				else if (iReceiveResult == SOCKET_ERROR)
				{
					if ((iWTemp = WSAGetLastError()) == WSA_IO_PENDING) // The reception is pending, so wait for it
					{
						WSAWaitForMultipleEvents(1, &WSAEvent, FALSE, WSA_INFINITE, FALSE); // Wait for the data to be received
						for(;;)
						{
							EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
							bResult = WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags);
							LeaveCriticalSection(&SocketAccessCriticalSection);
							if (bResult)
								break;
							iError = WSAGetLastError();
							if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
							{
								WSACloseEvent(WSAEvent);
								return;
							}
							Sleep(5); // Don't hog all of the CPU time
						}
					}
					else // Could not receive data from the client for some reason, so exit
					{
						WSACloseEvent(WSAEvent);
						return;
					}
				}
				else // Some other bad error happened, so abort
				{
					WSACloseEvent(WSAEvent);
					return;
				}

				iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
			}
		}

		// At this point, all of the data for this command has been received
		// iStatus should indicate EVERYTHINGS_OK, or COULD_NOT_ALLOCATE_RECEIVE_BUFFER
		// From here below is the only code that knows the format of the returned data (ID, Host error code, and data)
		dwID = *(DWORD *)&pcCopyBuffer[0];  // ID value returned from host
		dwReturnedErrorCode = (*(DWORD *)&pcCopyBuffer[4]);  // Error Code value from the host
		iActualBytesReceived = iActualBytesReceived - 12; // Subtract the space used by the error code and the ID to get the number of data bytes

		pListTemp = NULL; // Do this so that the buffer delete below will happen if the response is an ACK or not in the list at all
		if (dwID == g_dwLocalIDToAck) // If this was just a command ACK, process it here
//		if (dwID == dwID+10)  // Always false, just to disable QQQACKs
		{
			g_dwLocalIDToAck = 0;
			SetEvent(hAckReceivedEvent);
		}
		else // This wasn't an ACK, so maybe it was a real response
		{
			EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list
			pListTemp = pHostResponsesPendingList;
			while (pListTemp != NULL)
			{
				if (pListTemp->dwID == dwID)
					break;
				pListTemp = pListTemp->pNextEntry;
			}
			if (pListTemp != NULL) // We found a match!
			{
				// Point the destination buffer pointer to the one we allocated
				pListTemp->iStatus = iStatus;  // Relay the status back to the thread that is waiting for this response
				pListTemp->pcBufferFromHost = pcLocalBuffer; // The pointer to the local buffer, or NULL
				if (pcLocalBuffer == NULL)
					pListTemp->dwActualBytesReceived = 0;
				else
				{
					pListTemp->dwActualBytesReceived = (DWORD)iActualBytesReceived;
					memcpy(&pcCopyBuffer[0], &pcCopyBuffer[12], pListTemp->dwActualBytesReceived); // Shift the reponse data to the start of the buffer
					pListTemp->dwReturnedErrorCode = dwReturnedErrorCode;
					if ((pListTemp->iStatus == EVERYTHINGS_OK) && (dwReturnedErrorCode != 0)) // If the host returned an error, but iStatus is still OK, change iStatus to indicate that there is a host error
						pListTemp->iStatus = HOST_ERROR_RETURNED;
				}
				SetEvent(pListTemp->hEvent); // Trigger the event to wake up the thread that is waiting for this response
			}
			LeaveCriticalSection(&HostResponseEntryListCriticalSection); // Relinquish access to the list
		}
		// If there is no match, discard the data and do nothing
		if ((pListTemp == NULL) && (pcLocalBuffer != NULL)) // If a buffer was allocated, but not sent back to a calling thread, delete the allocated buffer
		{
			delete [] pcLocalBuffer;
			pcLocalBuffer = NULL;
		}
	}
	return;
}

void CHost::vAlivePrintThreadEntry(void *pthis)
{
	CHost *pHost = (CHost *)pthis;

	pHost->vAlivePrintThread();
}
void CHost::vAlivePrintThread(void)
{
#ifdef _XBOX
	DWORD dwValueToWrite = 0;

	// Set LED Override to use the requested LED Behavior
	HalWriteSMBusValue(0x20, 0x07, FALSE, 0x01);
	for (;;)
	{
		if (dwValueToWrite == 0)
		{
			// Set LED Off
			// Orange
			HalWriteSMBusValue(0x20, 0x08, FALSE, 0xFF);
			dwValueToWrite = 1;
		}
		else
		{
			// Green
			HalWriteSMBusValue(0x20, 0x08, FALSE, 0x0F);
			dwValueToWrite = 0;
		}
		Sleep(1000);
	}
#endif
}


// StartTimer is really just a reuse of QueryPerformanceCounter
void CHost::StartTimer(LARGE_INTEGER *StartCount)
{
	QueryPerformanceCounter(StartCount);
	return;
}

// Returns TRUE if the specified amount of time has elapsed, FALSE otherwise.  This should only
// be use to perform periodic checks on a timer for a timeout condition
int CHost::TimedOut(double dblDelayTime, LARGE_INTEGER *StartCount)
{
// Assume that a high-perfmance counter is supported (it is on all Pentiums and higher)
	LARGE_INTEGER PerformanceFrequency, CurrentCount;
	double dblFrequency;

	QueryPerformanceFrequency(&PerformanceFrequency);
	dblFrequency = (double)(PerformanceFrequency.QuadPart);
	QueryPerformanceCounter(&CurrentCount);

	if ((((double)(CurrentCount.QuadPart - StartCount->QuadPart))/dblFrequency) < dblDelayTime)
		return (FALSE);
	return (TRUE);
}

// Delay for a specified number of Microseconds.  This should only be used for very small
// delays because it uses lots of CPU time.  Use Sleep() when the delay is in the millisecond
// or longer range and can be a bit longer than specified.
void CHost::MicroSecondDelay(DWORD dwDelayTime)
{
// Assume that a high-perfmance counter is supported (it is on all Pentiums and higher)
	LARGE_INTEGER PerformanceFrequency, StartCount, CurrentCount;
	double dblFrequency;

	QueryPerformanceFrequency(&PerformanceFrequency);
	dblFrequency = (double)(PerformanceFrequency.QuadPart) / 1000000; // Microsecond resolution
	QueryPerformanceCounter(&StartCount);
	CurrentCount.QuadPart = StartCount.QuadPart;

	while ((((double)(CurrentCount.QuadPart - StartCount.QuadPart))/dblFrequency) < (double)dwDelayTime)
		QueryPerformanceCounter(&CurrentCount);
	return;
}

// This function will seed the random number generator rand() with either the value passed in
// or the current time (if the value passed in is 0)
void CHost::SeedRand(int iSeed)
{
	SYSTEMTIME systimeSeed;
	FILETIME filetimeSeed;

	if (iSeed == 0)
	{
		GetSystemTime(&systimeSeed);
		SystemTimeToFileTime(&systimeSeed, &filetimeSeed);
		iSeed = (int)filetimeSeed.dwLowDateTime;
	}
	srand(iSeed);
	return;
}

LPTSTR CHost::OpenIniFile (LPCTSTR filename)
{
	#define INI_HOST_TIMEOUT 15*60 // 15 minutes timeout

	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	int iError;
// The file name may have path information that we don't want.  Clean up XMTA.CPP

	if ((iError = g_host.iSendHost(MID_GET_FILE, (char *)filename, (wcslen(filename) + 1) * sizeof(WCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, INI_HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			g_error.err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			return(NULL);
		}
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			g_error.err_HostCommunicationError(iError);
			return(NULL);
		}
	}
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		g_error.err_INIBufferIsEmpty();
		return(NULL);
	}
	// The response is not NULL, and is not an error message, so process it

	// We are reading an ASCII file and converting it to UNICODE.
	// The following algorithm is designed to use a single buffer
	// for reading and conversion.  To do this we create a buffer large
	// enough to hold the converted file, then write the original
	// data to the upper half of the file.
	//
	DWORD fileSize = dwActualBytesReceived;
	m_start = new _TCHAR [fileSize + 2];
	BYTE *m_startBYTE = (BYTE *)m_start;
	char *middle = (char *) &m_start [(fileSize + 2)/2];

	// Copy the file contents to the allocated buffer
	memcpy(middle, CHR.pvBufferFromHost, dwActualBytesReceived);  // Copy the ini file contents
	
	for (DWORD q = 0; q < dwActualBytesReceived; q++)
	{
		m_startBYTE[q+q] = middle[q];
		m_startBYTE[q+q+1] = 0;
	}
/*
	int len = MultiByteToWideChar (CP_ACP, 0, middle, dwActualBytesReceived, m_start, fileSize + 1);
	if (len == 0)
	{
		g_error.ReportUnicodeConversionFailed (filename, (LPCTSTR) CGetLastError());
		return NULL;
	}
*/
	m_start [fileSize] = _T('\0');
	LPTSTR current = m_start;

	// Skip over initial unicode designator character
	//
	if (0xfffe == (int) *current)
		return NULL; // This code represents little endian format
	if (0xfeff == (int) *current)
		current++;

	return current;
}

DWORD CHost::GetHostDword (DWORD mid, DWORD alternate)
{
	CHostResponse CHR;

	const DWORD FIVEMINUTES = 30000;
	DWORD result, bytes, status;
	iSendHost (mid, NULL, 0, CHR, &bytes, &status, FIVEMINUTES);
	if ((CHR.pvBufferFromHost == NULL) || (bytes < 4) || (status != 0)) // Don't access the response buffer if it does not at least contain a DWORD
		result = alternate;
	else
		result = *((DWORD *)(CHR.pvBufferFromHost));
	return result;
}

void CHost::Init (char *strHostName, LPCTSTR strSerialNumber)
{
	// Only in remote mode
	sock = INVALID_SOCKET;
	if (iInitHostCommunication(strHostName, strSerialNumber,
		HOST_COMMUNICATION_INITIALIZATION_TIMEOUT, &sock) != EVERYTHINGS_OK)
	{
		DisconnectFromHost ();
	}
}

void CHost::DisconnectFromHost()
{
	if ((sock != NULL) && (sock != INVALID_SOCKET))
	{
		shutdown (sock, SD_BOTH);
		closesocket(sock);
		WSACleanup();
		sock = INVALID_SOCKET;
	}			
}

#endif // STAND_ALONE_MODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\ui\xapp\main.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "xip.h"
#include "Node.h"
#include "Screen.h"
#include "Runner.h"
#include "Lerper.h"
#include "Camera.h"
#include "NavInfo.h"
#include "Viewpoint.h"
#include "Background.h"
#include "xlaunch.h"

extern void DSound_Exit();

extern void Memory_Init();

extern void Debug_Init();
extern void Debug_Exit();

extern void Class_Init();
extern void Class_Exit();

#ifdef _DEBUG
extern void Debug_Frame();
#endif // _DEBUG

extern void Xbox_Init();

extern void DiscDrive_Init();

extern void BackgroundLoader_Frame();

extern void Text_Exit();

extern void Locale_Exit();

extern void TitleArray_Init();

extern void Material_Init();
extern float g_nEffectAlpha;

#ifdef _DEBUG
bool g_bWireframe = false;
#endif // _DEBUG

////////////////////////////////////////////////////////////////////////////

CXApp theApp;

D3DXMATRIX g_matView;
D3DXMATRIX g_matPosition;
D3DXMATRIX g_matProjection;
D3DRECT	   g_scissorRect;
D3DRECT	   g_scissorRectx2;

D3DXMATRIX g_matIdentity(
	1.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 1.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 1.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 1.0f);

#ifdef COOL_XDASH
UINT g_uMesh;
UINT g_uMeshRef;
#endif

extern "C" void Alert(const TCHAR* szMsg, ...)
{
	va_list args;
	va_start(args, szMsg);

	TCHAR szBuffer [512];
	_vsntprintf(szBuffer, countof(szBuffer), szMsg, args);
	Trace(_T("\007%s\n"), szBuffer);
	va_end(args);
}

#ifdef _UNICODE
void Unicode(TCHAR* wsz, const char* sz, int nMaxChars)
{
	while (nMaxChars-- > 0)
	{
		if ((*wsz++ = (unsigned char)*sz++) == 0)
			return;
	}
}

void Ansi(char* sz, const TCHAR* wsz, int nMaxChars)
{
	while (nMaxChars-- > 0)
	{
		if ((*sz++ = (char)*wsz++) == 0)
			return;
	}
}
#endif // _UNICODE

extern "C" PLAUNCH_DATA_PAGE* LaunchDataPage;

CXApp::CXApp()
{
	m_dwStartTick = m_dwFrameTick = GetTickCount();
	m_now = (float)m_dwFrameTick / 1000.0f;

	m_pD3D = NULL;
    m_pD3DDev = NULL;

	m_pViewpoint = NULL;
	m_pNavigationInfo = NULL;
	m_pBackground = NULL;

	m_worldStack = NULL;
	m_bProjectionDirty = true;

	m_bZBuffer = false;

	m_pScreen = NULL;

	m_pClass = new CClass;
	m_pObject = NULL;

	m_bStretchWidescreen = false;

	m_szAppDir = NULL;

    // Retrieve the launch data, if any
    if (*LaunchDataPage && (*LaunchDataPage)->Header.dwLaunchDataType == LDT_LAUNCH_DASHBOARD) {
        PLD_LAUNCH_DASHBOARD pLaunchDashboard =
            (PLD_LAUNCH_DASHBOARD) ((*LaunchDataPage)->LaunchData);

        m_bHasLaunchData = true;
        m_dwTitleID = (*LaunchDataPage)->Header.dwTitleId;
        m_dwLaunchReason = pLaunchDashboard->dwReason;
        m_dwLaunchContext = pLaunchDashboard->dwContext;
        m_dwLaunchParameter1 = pLaunchDashboard->dwParameter1;
        m_dwLaunchParameter2 = pLaunchDashboard->dwParameter2;

        PLAUNCH_DATA_PAGE pTemp = *LaunchDataPage;
        *LaunchDataPage = NULL;
        MmFreeContiguousMemory(pTemp);
    } else {
        m_bHasLaunchData = false;
        m_dwTitleID =
        m_dwLaunchReason =
        m_dwLaunchContext =
        m_dwLaunchParameter1 =
        m_dwLaunchParameter2 = 0;
    }

    m_dwMainThreadId = GetCurrentThreadId();
}

CXApp::~CXApp()
{
	// All cleanup code should be in CleanupApp or the debug code
	// will complain about it not happening!
}

// REVIEW: Nuke this when GetRenderState is implemented!

DWORD xapp_rgdwRenderStateCache [256];
bool xapp_rgbRenderStateCache [256];
float g_transitionMotionBlur;

void XboxInitRenderState()
{
	float fZero = 0.0f;
	float fOne = 1.0f;

	XAppSetRenderState(D3DRS_ZENABLE, theApp.m_bZBuffer ? D3DZB_TRUE : D3DZB_FALSE);
	XAppSetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	XAppSetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	XAppSetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	XAppSetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	XAppSetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	XAppSetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
	XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	XAppSetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	XAppSetRenderState(D3DRS_ALPHAREF, 0);
	XAppSetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
	XAppSetRenderState(D3DRS_DITHERENABLE, TRUE);
	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	XAppSetRenderState(D3DRS_FOGENABLE, FALSE);
	XAppSetRenderState(D3DRS_SPECULARENABLE, FALSE);
	XAppSetRenderState(D3DRS_FOGCOLOR, 0);
	XAppSetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_NONE);
//	XAppSetRenderState(D3DRS_FOGSTART, ); // Undocumented!
//	XAppSetRenderState(D3DRS_FOGEND, ); // Undocumented!
	XAppSetRenderState(D3DRS_FOGDENSITY, *(LPDWORD)&fOne);
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	XAppSetRenderState(D3DRS_ZBIAS, 0);
	XAppSetRenderState(D3DRS_RANGEFOGENABLE, FALSE);
	XAppSetRenderState(D3DRS_STENCILENABLE, FALSE);
	XAppSetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);
	XAppSetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);
	XAppSetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
	XAppSetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);
	XAppSetRenderState(D3DRS_STENCILREF, 0);
	XAppSetRenderState(D3DRS_STENCILMASK, 0xffffffff);
	XAppSetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);
//	XAppSetRenderState(D3DRS_TEXTUREFACTOR, ); // Undocumented!
	XAppSetRenderState(D3DRS_WRAP0, 0);
	XAppSetRenderState(D3DRS_WRAP1, 0);
	XAppSetRenderState(D3DRS_WRAP2, 0);
	XAppSetRenderState(D3DRS_WRAP3, 0);
	XAppSetRenderState(D3DRS_LIGHTING, TRUE);
	XAppSetRenderState(D3DRS_AMBIENT, 0);
	XAppSetRenderState(D3DRS_COLORVERTEX, TRUE);
	XAppSetRenderState(D3DRS_LOCALVIEWER, TRUE);
	XAppSetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
	XAppSetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
	XAppSetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
	XAppSetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR2);
	XAppSetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	XAppSetRenderState(D3DRS_VERTEXBLEND, D3DVBF_DISABLE);
	XAppSetRenderState(D3DRS_POINTSIZE, *(LPDWORD)&fOne);
	XAppSetRenderState(D3DRS_POINTSIZE_MIN, *(LPDWORD)&fOne);
	XAppSetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
	XAppSetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
	XAppSetRenderState(D3DRS_POINTSCALE_A, *(LPDWORD)&fOne);
	XAppSetRenderState(D3DRS_POINTSCALE_B, *(LPDWORD)&fZero);
	XAppSetRenderState(D3DRS_POINTSCALE_C, *(LPDWORD)&fZero);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	XAppSetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
//	XAppSetRenderState(D3DRS_PATCHEDGESTYLE, ); // Undocumented!
//	XAppSetRenderState(D3DRS_PATCHSEGMENTS, ); // Undocumented!
//	XAppSetRenderState(D3DRS_DEBUGMONITORTOKEN, ); // Undocumented!
//	XAppSetRenderState(D3DRS_POINTSIZE_MAX, ); // Undocumented!
	XAppSetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);
//	XAppSetRenderState(D3DRS_TWEENFACTOR, ); // Undocumented!

	// Initalize the motion blur
	g_transitionMotionBlur = 1.0f;
}

bool CXApp::InitD3D()
{
	m_pD3D = Direct3DCreate8(D3D_SDK_VERSION);
	if (m_pD3D == NULL)
	{
		Alert(_T("Cannot initialize Direct3D! (D3D_SDK_VERSION=%d)"), D3D_SDK_VERSION);
		return false;
	}

	D3DDEVTYPE devtype = D3DDEVTYPE_HAL;

	ZeroMemory(&m_pp, sizeof (m_pp));
	m_pp.BackBufferCount = 1;
	m_pp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
	m_pp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
	//m_pp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
	m_pp.SwapEffect = D3DSWAPEFFECT_DISCARD;
	//m_pp.MultiSampleType = D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR;
	m_pp.MultiSampleType = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN;
	m_pp.EnableAutoDepthStencil = m_bZBuffer;
	if (m_bZBuffer)
		m_pp.AutoDepthStencilFormat = D3DFMT_D24S8;

    DWORD dwBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING;

    m_pp.Flags = D3DPRESENTFLAG_INTERLACED;
	
    m_bStretchWidescreen = (XGetVideoFlags() & XC_VIDEO_FLAGS_WIDESCREEN) != 0;
    if (m_bStretchWidescreen)
    {
        m_pp.Flags |= D3DPRESENTFLAG_WIDESCREEN;
    }

    switch (XGetAVPack())
    {
    default:
        m_pp.BackBufferWidth = 640;
        m_pp.BackBufferHeight = 480;
        break;

    case XC_AV_PACK_STANDARD:
    case XC_AV_PACK_SVIDEO:
    case XC_AV_PACK_RFU:
    case XC_AV_PACK_SCART:
        m_pp.BackBufferWidth = g_nDiscType == DISC_VIDEO ? 720 : 640;
        if (XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I)
            m_pp.BackBufferHeight = 576;
        else
            m_pp.BackBufferHeight = 480;
        break;

    case XC_AV_PACK_HDTV:
        m_pp.BackBufferWidth = g_nDiscType == DISC_VIDEO ? 720 : 640;
        m_pp.BackBufferHeight = 480;

        // If we are about to play DVD, check if 480p is enabled
#ifdef COOL_XDASH
        if (g_nDiscType == DISC_VIDEO)
#else
        if ((XBOX_480P_MACROVISION_ENABLED & XboxHardwareInfo->Flags) && g_nDiscType == DISC_VIDEO)
#endif
        {
            DWORD dwFlags, dwType;
            if (XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL) == ERROR_SUCCESS)
            {
                if (dwFlags & AV_FLAGS_HDTV_480p)
                {
                    m_pp.Flags &= ~D3DPRESENTFLAG_INTERLACED;
                    m_pp.Flags |= D3DPRESENTFLAG_PROGRESSIVE;
                }
            }
        }

        break;
    }

	TRACE(_T("\001\nVideo Settings: %dx%d%c %s\n"), m_pp.BackBufferWidth, m_pp.BackBufferHeight,
          m_pp.Flags & D3DPRESENTFLAG_PROGRESSIVE ? 'p' : 'i', m_bStretchWidescreen ? _T("16:9") : _T("4:3"));

	m_pp.BackBufferFormat = D3DFMT_X8R8G8B8;//D3DFMT_R5G6B5; // REVIEW: Really want D3DFMT_R8G8B8
//	m_pp.AutoDepthStencilFormat = D3DFMT_D16; // REVIEW: Really want D3DFMT_D24S8

	m_pp.hDeviceWindow = NULL;
	m_pp.Windowed = FALSE;

#ifdef _DEBUG
	m_pp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_UNLIMITED;
#endif

	m_nViewWidth = (float)m_pp.BackBufferWidth;
	m_nViewHeight = (float)m_pp.BackBufferHeight;

	HRESULT hr = m_pD3D->CreateDevice(D3DADAPTER_DEFAULT, devtype, m_pp.hDeviceWindow, dwBehavior, &m_pp, &m_pD3DDev);
	if (FAILED(hr))
	{
		LogComError(hr, "InitD3D");
		return false;
	}

	LPDIRECT3DSURFACE8 pFrontBuffer;
	D3DSURFACE_DESC d3dsd;
	m_pD3DDev->GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
	pFrontBuffer->GetDesc(&d3dsd);
	pFrontBuffer->Release();
	g_scissorRect.x1 = 0;
	g_scissorRect.y1 = 0;
	g_scissorRect.x2 = d3dsd.Width;
	g_scissorRect.y2 = d3dsd.Height;

	m_pD3DDev->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
	pFrontBuffer->GetDesc(&d3dsd);
	pFrontBuffer->Release();
	g_scissorRectx2.x1 = 0;
	g_scissorRectx2.y1 = 0;
	g_scissorRectx2.x2 = d3dsd.Width;
	g_scissorRectx2.y2 = d3dsd.Height;

	

#ifdef _DEBUG
	{
		D3DCAPS8 d3dCaps;

		m_pD3DDev->GetDeviceCaps(&d3dCaps);

		// Does this device support the two bump mapping blend operations?
		if ((d3dCaps.TextureOpCaps & (D3DTEXOPCAPS_BUMPENVMAP | D3DTEXOPCAPS_BUMPENVMAPLUMINANCE)) == 0)
			TRACE(_T("Device does not support bump mapping\n"));

		// Does this device support up to three blending stages?
		if (d3dCaps.MaxTextureBlendStages < 3)
			TRACE(_T("Device supports less than 3 blending stages\n"));
	}
#endif


    // REVIEW: Nuke this when GetRenderState is implemented!
	XboxInitRenderState();

	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	XAppSetRenderState(D3DRS_AMBIENT, 0xffffffff);

	XAppSetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC);
	XAppSetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC);

	XAppSetTextureStageState(1, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC);
	XAppSetTextureStageState(1, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC);

	XAppSetTextureStageState(0,D3DTSS_MIPFILTER, D3DTEXF_LINEAR);

	TRACE(_T("Display sub-system initialized.\n"));

	return true;
}

void CXApp::ReleaseD3D()
{
	RELEASENULL(m_worldStack);

	if (m_pD3D != NULL)
	{
		m_pD3D->Release();
		m_pD3D = NULL;
	}
}

struct COLORVERTEX
{
	float dvX, dvY, dvZ;
	DWORD color;
};

void CXApp::Draw()
{
	// Setup projection transform...
	if (m_bProjectionDirty)
	{
		m_bProjectionDirty = false;

		float nNear = 0.1f;
		float nFar = 1000.0f;
		float fieldOfView = D3DX_PI / 2.0f;

		if (m_pNavigationInfo != NULL)
		{
			nNear = m_pNavigationInfo->m_avatarSize.x / 2.0f;
			if (m_pNavigationInfo->m_visibilityLimit != 0.0f)
				nFar = m_pNavigationInfo->m_visibilityLimit;
		}

		if (m_pViewpoint != NULL)
		{
			fieldOfView = m_pViewpoint->m_fieldOfView;
		}

		//float aspect = m_nViewWidth / m_nViewHeight;
		float aspect = 720.0f / 480.0f;
		if (m_bStretchWidescreen)
		{
			// This adjusts for 4x3 style resolutions being displayed widescreen on a 16x9 monitor...
			aspect *= 1.25f;
		}

		D3DXMatrixPerspectiveFovLH(&g_matProjection, fieldOfView, aspect, nNear, nFar);
		XAppSetTransform(D3DTS_PROJECTION, &g_matProjection);
	}

#ifdef COOL_XDASH
    g_uMesh = 0;
    g_uMeshRef = 0;
#endif

	XAppBeginScene();

#ifdef _DEBUG
	XAppSetRenderState(D3DRS_FILLMODE, g_bWireframe ? D3DFILL_WIREFRAME : D3DFILL_SOLID);
#endif

	//const float blurAlpha = 0.25f; // bigger number -> less blur
	//const float blurAlpha = 1.0f; // bigger number -> less blur
	const float blurAlpha = g_transitionMotionBlur;

	D3DCOLOR color;
	bool bBackdrop = false;
	if (m_pBackground == NULL)
		color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.3f, 1.0f);
	else
		color = D3DCOLOR_COLORVALUE(m_pBackground->m_skyColor.x, m_pBackground->m_skyColor.y, m_pBackground->m_skyColor.z, 1.0f);

	if (m_pBackground != NULL && m_pBackground->m_backdrop != NULL)
		bBackdrop = true;

	// REVIEW: don't clear the back buffer if we're going to fill it with a background anyway!
	static int nBeenHere;
	if (blurAlpha >= 1.0f || nBeenHere++ < 2 || color != D3DCOLOR_XRGB(0, 0, 0) || bBackdrop)
	{
		XAppClear(color); // NOTE: Clears back and Z buffers (if Z buffer is enabled)

		if (bBackdrop)
			m_pBackground->RenderBackdrop();
	}
	else
	{
		static LPDIRECT3DVERTEXBUFFER8 m_pVB;
		if (m_pVB == NULL)
		{
			VERIFYHR(XAppGetD3DDev()->CreateVertexBuffer(4 * sizeof(COLORVERTEX), D3DUSAGE_WRITEONLY, D3DFVF_XYZ | D3DFVF_DIFFUSE, D3DPOOL_MANAGED, &m_pVB));

			COLORVERTEX* verts;
			VERIFYHR(m_pVB->Lock(0, 4 * sizeof (COLORVERTEX), (BYTE**)&verts, 0));

			verts[0].dvX = (float)theApp.m_nViewWidth / 2.0f;
			verts[0].dvY = -(float)theApp.m_nViewHeight / 2.0f;
			verts[0].dvZ = 0.0f;
			verts[0].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, blurAlpha);

			verts[1].dvX = -(float)theApp.m_nViewWidth / 2.0f;
			verts[1].dvY = -(float)theApp.m_nViewHeight / 2.0f;
			verts[1].dvZ = 0.0f;
			verts[1].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, blurAlpha);

			verts[2].dvX = (float)theApp.m_nViewWidth / 2.0f;
			verts[2].dvY = (float)theApp.m_nViewHeight / 2.0f;
			verts[2].dvZ = 0.0f;
			verts[2].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, blurAlpha);

			verts[3].dvX = -(float)theApp.m_nViewWidth / 2.0f;
			verts[3].dvY = (float)theApp.m_nViewHeight / 2.0f;
			verts[3].dvZ = 0.0f;
			verts[3].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, blurAlpha);

			VERIFYHR(m_pVB->Unlock());
		}

    	D3DXMATRIX matProjection, matProjectionSave, matWorldSave, matViewSave;

    	XAppGetTransform(D3DTS_PROJECTION, &matProjectionSave);
    	XAppGetTransform(D3DTS_WORLD, &matWorldSave);
    	XAppGetTransform(D3DTS_VIEW, &matViewSave);

    	//D3DXMatrixOrthoLH(&matProjection, 720.0f, 480.0f, -10000.0f, 10000.0f);
		D3DXMatrixOrthoLH(&matProjection, theApp.m_nViewWidth, theApp.m_nViewHeight, -10000.0f, 10000.0f);
    	XAppSetTransform(D3DTS_PROJECTION, &matProjection);
    	XAppSetTransform(D3DTS_WORLD, &g_matIdentity);
    	XAppSetTransform(D3DTS_VIEW, &g_matIdentity);

        XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
        XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
        XAppSetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
        XAppSetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
        XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
        XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    	XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
    	XAppSetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

        VERIFYHR(XAppGetD3DDev()->SetStreamSource(0, m_pVB, sizeof (COLORVERTEX)));
        VERIFYHR(XAppGetD3DDev()->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE));
        VERIFYHR(XAppGetD3DDev()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2));

    	XAppSetTransform(D3DTS_PROJECTION, &matProjectionSave);
    	XAppSetTransform(D3DTS_WORLD, &matWorldSave);
    	XAppSetTransform(D3DTS_VIEW, &matViewSave);
    }

#ifdef _LIGHTS
	// Setup lights...
	{
		static int nLastLight = -1;
		int nLight = 0;
		D3DCOLORVALUE ambient;
		ambient.r = 0.0f;
		ambient.g = 0.0f;
		ambient.b = 0.0f;

		// Headlight...
		if (m_pNavigationInfo == NULL || m_pNavigationInfo->m_headlight)
		{
			XAppSetTransform(D3DTS_WORLD, &g_matIdentity);

			D3DLIGHT8 d3dLight;
			ZeroMemory(&d3dLight, sizeof(d3dLight));

			d3dLight.Type = D3DLIGHT_DIRECTIONAL;

			d3dLight.Diffuse.r = 0.5f;
			d3dLight.Diffuse.g = 0.5f;
			d3dLight.Diffuse.b = 0.5f;

			d3dLight.Specular.r = 0.75f;
			d3dLight.Specular.g = 0.75f;
			d3dLight.Specular.b = 0.75f;

			d3dLight.Ambient.r = 0.2f;
			d3dLight.Ambient.g = 0.2f;
			d3dLight.Ambient.b = 0.2f;

			ambient.g += d3dLight.Ambient.r;
			ambient.g += d3dLight.Ambient.g;
			ambient.b += d3dLight.Ambient.b;

			D3DXVECTOR3 dir(0.0f, 0.0f, -1.0f);
			D3DXVec3TransformNormal(&dir, &dir, &g_matPosition);
			d3dLight.Direction = dir;

			// BLOCK: Extra spotlight stuff...
			if (0)
			{
				d3dLight.Type = D3DLIGHT_SPOT;
				d3dLight.Position = theCamera.m_position;
				d3dLight.Range = 100.0f;
				d3dLight.Falloff = 1.0f;
				d3dLight.Attenuation0 = 1.0f;
				d3dLight.Attenuation1 = 0.0f;
				d3dLight.Attenuation2 = 0.0f;
				d3dLight.Theta = 0.1f;
				d3dLight.Phi = 0.7f;
			}

			XAppSetLight(nLight, &d3dLight);
			XAppLightEnable(nLight, true);
			nLight += 1;
		}

		m_pObject->SetLight(nLight, ambient);

		if (ambient.r < 0.0f)
			ambient.r = 0.0f;
		else if (ambient.r > 1.0f)
			ambient.r = 1.0f;
		if (ambient.g < 0.0f)
			ambient.g = 0.0f;
		else if (ambient.g > 1.0f)
			ambient.g = 1.0f;
		if (ambient.b < 0.0f)
			ambient.b = 0.0f;
		else if (ambient.b > 1.0f)
			ambient.b = 1.0f;

		XAppSetRenderState(D3DRS_AMBIENT, D3DCOLOR_COLORVALUE(ambient.r, ambient.g, ambient.b, 1.0f));

#ifdef _DEBUG
		{
			if (nLight != nLastLight)
			{
				nLastLight = nLight;
				TRACE(_T("Lighting: %s (%d lights)\n"), nLight > 0 ? _T("enabled") : _T("disabled"), nLight);
			}
		}
#endif

		// Turn off lights we are not using...
		for (int i = nLight; i < nLastLight; i += 1)
			XAppLightEnable(i, false);

		XAppSetRenderState(D3DRS_LIGHTING, nLight > 0);
		nLastLight = nLight;
	}
#else // !_LIGHTS
	XAppSetRenderState(D3DRS_LIGHTING, FALSE);
#endif // _LIGHTS

#ifndef _XBOX
	if (m_pNavigator != NULL)
		m_pNavigator->Render();
#endif

    // BLOCK: Setup a default material
	{
		static D3DMATERIAL8 mat;
		if (mat.Diffuse.r == 0.0f)
		{
			mat.Diffuse.r = 0.5f;
			mat.Diffuse.g = 0.5f;
			mat.Diffuse.b = 0.5f;
			mat.Diffuse.a = 1.0f;

			mat.Ambient.r = 0.5f;
			mat.Ambient.g = 0.5f;
			mat.Ambient.b = 0.5f;
			mat.Ambient.a = 1.0f;

			mat.Specular.r = 0.5f;
			mat.Specular.g = 0.5f;
			mat.Specular.b = 0.5f;
			mat.Specular.a = 1.0f;

			mat.Emissive.r = 0.5f;
			mat.Emissive.g = 0.5f;
			mat.Emissive.b = 0.5f;
			mat.Emissive.a = 1.0f;

			mat.Power = 0.0f;
		}

		XAppSetMaterial(&mat);
	}

//		if (m_pGround != NULL)
//			m_pGround->RenderGround();

	// Draw the world...
	{
		XAppPushWorld();
		XAppIdentityWorld();
		XAppUpdateWorld();
		m_pObject->Render();
		XAppPopWorld();
	}

	XAppEndScene();
    XAppSetRenderState(D3DRS_SWATHWIDTH, D3DSWATH_OFF);
	XAppPresent();
    XAppSetRenderState(D3DRS_SWATHWIDTH, D3DSWATH_128);

	m_dwFrameTick = GetTickCount();
}

bool CXApp::InitApp()
{
//	START_PROFILE();

	Memory_Init();
	Xbox_Init();

	srand(GetTickCount());

#ifdef _DEBUG
	Debug_Init();
#endif

	TRACE(_T("Initializing XApp...\n"));

	DiscDrive_Init();

	if (!InitD3D())
		return false;

	LoadXIP(_T("y:\\default.xip"), true);

	Class_Init();
	TitleArray_Init();
	Material_Init();

	// BLOCK: Load the appropriate class file...
	{
		TCHAR szFileToLoad [MAX_PATH];
		szFileToLoad[0] = 0;

		GetStartupClassFile(szFileToLoad);
		ASSERT(szFileToLoad[0] != 0);

		TRACE(_T("Loading %s\n"), szFileToLoad);
		if (!m_pClass->Load(szFileToLoad))
		{
			extern bool g_bParseError;
			if (!g_bParseError)
				Alert(_T("%s\n\nCannot open file."), szFileToLoad);
			return false;
		}
	}

	m_pObject = (CInstance*)m_pClass->CreateNode();
	ASSERT(m_pObject != NULL);


	VERIFYHR(D3DXCreateMatrixStack(0, &m_worldStack));
	ASSERT(m_worldStack != NULL);

	CallFunction(m_pObject, _T("initialize"));

//	END_PROFILE();
	return true;
}

void CXApp::CleanupApp()
{
	ReleaseD3D();

	delete m_pObject;
	m_pObject = NULL;

	delete m_pClass;
	m_pClass = NULL;

	Class_Exit();
	Locale_Exit();
	Text_Exit();

	DSound_Exit();

	delete [] m_szAppDir;
	m_szAppDir = NULL;

#ifdef _DEBUG
	Debug_Exit();
#endif
}

void CXApp::Advance()
{
	XTIME now = (float)GetTickCount() / 1000.0f;
	float nDelta = (float) (now - m_now);
	if (nDelta == 0.0f)
		nDelta = 0.001f;
	m_now = now;

	ASSERT(g_nEffectAlpha == 1.0f); // this should always have been restored here!

#ifndef _XBOX
	if (m_pNavigator != NULL)
		m_pNavigator->Advance(nDelta);
#endif

	theCamera.Advance(nDelta);

	CLerper::AdvanceAll();
	m_pObject->Advance(nDelta);

	BackgroundLoader_Frame();

#ifdef _DEBUG
	Debug_Frame();
#endif
}

void XApp()
{
	if (!theApp.InitApp())
	{
		TRACE(_T("\001Initialization failed; exiting...\n"));
		theApp.CleanupApp();
		return;
	}

	TRACE(_T("Initialization completed...\n"));

	for (;;)
	{
		theApp.Advance();
		theApp.Draw();
	}

	theApp.CleanupApp();
}

void CXApp::GetStartupClassFile(TCHAR* szFileToLoad)
{
	TCHAR szAppDir [MAX_PATH];

	_tcscpy(szFileToLoad, _T("y:\\default.xap"));
	_tcscpy(szAppDir, _T("y:\\"));
	_tcscpy(g_szCurDir, _T("y:/default.xap"));

	m_szAppDir = new TCHAR [_tcslen(szAppDir) + 1];
	_tcscpy(m_szAppDir, szAppDir);
}

LONG XdashUnhandledExceptionFilter(LPEXCEPTION_POINTERS *pEx)
{
    HalReturnToFirmware(HalRebootRoutine);
    __asm { hlt }   // Shouldn't be here
}

void __cdecl main(int /*argc*/, char* /*argv*/ [])
{
#ifndef DEVKIT
    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)XdashUnhandledExceptionFilter);
#endif
	XApp();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\Assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\vc6addon\ide\wizards\appwiz\makefile.inc ===
!include $(IDE_ROOT)\makefile.inc

# ---------------------------------------------------------------------------
# Set up dependance on package versioning file
# ---------------------------------------------------------------------------
..\mfcappwz.cpp: $(PACKVERCHECK)

# ---------------------------------------------------------------------------
# General macros
# ---------------------------------------------------------------------------

APPWIZ_OBJDIR=$(APPWIZ_ROOT)\\$(O)


# ---------------------------------------------------------------------------
# Rules for building $(NEW_RC_FILE) "mfcappwz.rc_"
# ---------------------------------------------------------------------------

TPL_NOLOC_FILES=*.*
NEW_RC_FILE=$(APPWIZ_OBJDIR)\\mfcappwz.rc_

mfcappwz.rc : $(NEW_RC_FILE)
$(NEW_RC_FILE) : $(TPL_NOLOC_DIR)\$(TPL_NOLOC_FILES)
    cd $(TPL_NOLOC_DIR)
    echo // Code templates                                                       > $*.tm2
    @for %%f in ($(TPL_NOLOC_FILES)) do echo %%f TEMPLATE "$(TPL_NOLOC_DIR)\\%%f" >> $*.tm2
    fixwhack < $*.tm2 > $@
    cd $(APPWIZ_ROOT)


# ---------------------------------------------------------------------------
# Build the resource DLL
# ---------------------------------------------------------------------------

LINKFLAGS_RES = -dll -noentry -machine:$(TARGET_DIRECTORY) -debug:none -release
NEW_LANG_FILE=$(APPWIZ_OBJDIR)\\$(APPWIZ_LANG).rc_
LANG_RC_FILE=$(APPWIZ_ROOT)\\$(APPWIZ_LANG).rc
TPL_LOC_FILES= *.*

$(LANG_RC_FILE): $(NEW_LANG_FILE)

$(NEW_LANG_FILE): $(TPL_LOC_DIR)\$(TPL_LOC_FILES) $(TPL_TAG_DIR)\$(TPL_LOC_FILES)
    cd $(TPL_LOC_DIR)
    echo // Resource templates                                                >  $*.tm2
    @for %%f in ($(TPL_LOC_FILES)) do echo %%f TEMPLATE "$(TPL_LOC_DIR)\\%%f" >> $*.tm2
    cd $(APPWIZ_ROOT)
    cd $(TPL_TAG_DIR)
    echo // Tagged resource templates                                         >>  $*.tm2
    @for %%f in ($(TPL_LOC_FILES)) do echo %%f TEMPLATE_TAG "$(TPL_TAG_DIR)\\%%f" >> $*.tm2
    fixwhack < $*.tm2 > $@
    cd $(APPWIZ_ROOT)


$O\$(APPWIZ_LANG).res: $(LANG_RC_FILE)

$(RESDLL_NAME): $O\$(APPWIZ_LANG).res
    $(LINKER) $(LINKFLAGS_RES) $O\$(APPWIZ_LANG).res


# ---------------------------------------------------------------------------
# rules for generating a .def file from hell
# ---------------------------------------------------------------------------

!if "$(DEBUG)"=="0"
DESCRIPTION="APPWIZ_DLL"
DLL=dllretail
!else
DESCRIPTION="APPWIZD_DLL"
DLL=dlldebug
!endif

SHARE=shared

!ifdef REDEFPASS

$O\$(TARGETNAME).def:
    -del /f/q $O\$(TARGETNAME).def
    echo LIBRARY $(TARGETNAME) > $@

!else

$(DLLDEF): $O\$(TARGETNAME).map
#   strip the map file to symbols leave 1 space at the beginning of line
    maptweak $** $O\tmp.1
#   filter out what we don't want to export (blank at start of each line)
    qgrep -v -f $(APPWIZ_ROOT)\filter.no $O\tmp.1 > $O\tmp.3
    qgrep < $O\tmp.3 -f $(APPWIZ_ROOT)\filter.yes > $O\tmp.4
    sort < $O\tmp.4 > $O\tmp.2
    type $O\tmp.2 > $O\$(TARGETNAME).tmp
#   -del $O\tmp.1 $O\tmp.2 $O\tmp.3 $O\tmp.4
#   build the real .DEF file
    echo LIBRARY $(TARGETNAME)           > $@
    echo DESCRIPTION $(DESCRIPTION)     >> $@
    echo EXPORTS                        >> $@
    type canned.exp     >> $@
!if "$(DEBUG)"=="0"
    genord 2 < $O\$(TARGETNAME).tmp >> $@
!else
    type $O\$(TARGETNAME).tmp >> $@
!endif
#   -del $O\$(TARGETNAME).tmp

$O\$(TARGETNAME).map: $(LIBRARY_OBJS)
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp
    -del $(DLLDEF)
    set LINKER_FLAGS=-map:$@
    set NOLINK=
    $(MAKE) MAKEDLL=1 REDEFPASS=1 LINKER_NOREF=1
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\windows\directx\dsound\test\lnktest.h ===
#include <xtl.h>

#ifdef __cplusplus
#define REF_GUID_NULL GUID_NULL
#else // __cplusplus
#define REF_GUID_NULL 0
#endif // __cplusplus

static void
LinkTest
(
    void
)
{
    DirectSoundCreate(0, 0, 0);
    DirectSoundCreateBuffer(0, 0);
    DirectSoundCreateStream(0, 0);
    DirectSoundDoWork();
    DirectSoundUseFullHRTF();
    DirectSoundUseLightHRTF();
    /*DirectSoundUsePan3D();*/	// Volt - that API is not present in public API
    DirectSoundOverrideSpeakerConfig(0);
    DirectSoundGetSampleTime();
    DirectSoundDumpMemoryUsage(0);
    XAudioCreatePcmFormat(0, 0, 0, 0);
    XAudioCreateAdpcmFormat(0, 0, 0);
    XAudioCalculatePitch(0);
    WmaCreateDecoder(0, 0, 0, 0, 0, 0, 0, 0);
    WmaCreateInMemoryDecoder(0, 0, 0, 0, 0);
    WmaCreateDecoderEx(0, 0, 0, 0, 0, 0, 0, 0);
    WmaCreateInMemoryDecoderEx(0, 0, 0, 0, 0);
    Ac97CreateMediaObject(0, 0, 0, 0);
    XFileCreateMediaObject(0, 0, 0, 0, 0, 0);
    XFileCreateMediaObjectEx(0, 0);
    XWaveFileCreateMediaObject(0, 0, 0);
    XWaveFileCreateMediaObjectEx(0, 0, 0);
    XAudioDownloadEffectsImage(0, 0, 0, 0);
    IDirectSound_QueryInterface(0, REF_GUID_NULL, 0);
    IDirectSound_AddRef(0);
    IDirectSound_Release(0);
    IDirectSound_GetCaps(0, 0);
    IDirectSound_CreateSoundBuffer(0, 0, 0, 0);
    IDirectSound_CreateSoundStream(0, 0, 0, 0);
    IDirectSound_GetSpeakerConfig(0, 0);
    IDirectSound_SetCooperativeLevel(0, 0, 0);
    IDirectSound_Compact(0);
    IDirectSound_DownloadEffectsImage(0, 0, 0, 0, 0);
    IDirectSound_SetEffectData(0, 0, 0, 0, 0, 0);
    IDirectSound_CommitEffectData(0);
    IDirectSound_EnableHeadphones(0, 0);
    IDirectSound_SetMixBinHeadroom(0, 0, 0);
    IDirectSound_SetAllParameters(0, 0, 0);
    IDirectSound_SetDistanceFactor(0, 0, 0);
    IDirectSound_SetDopplerFactor(0, 0, 0);
    IDirectSound_SetOrientation(0, 0, 0, 0, 0, 0, 0, 0);
    IDirectSound_SetPosition(0, 0, 0, 0, 0);
    IDirectSound_SetRolloffFactor(0, 0, 0);
    IDirectSound_SetVelocity(0, 0, 0, 0, 0);
    IDirectSound_SetI3DL2Listener(0, 0, 0);
    IDirectSound_CommitDeferredSettings(0);
    IDirectSound_GetTime(0, 0);
    IDirectSoundBuffer_QueryInterface(0, REF_GUID_NULL, 0);
    IDirectSoundBuffer_AddRef(0);
    IDirectSoundBuffer_Release(0);
    IDirectSoundBuffer_SetFrequency(0, 0);
    IDirectSoundBuffer_SetVolume(0, 0);
    IDirectSoundBuffer_SetPitch(0, 0);
    IDirectSoundBuffer_SetLFO(0, 0);
    IDirectSoundBuffer_SetEG(0, 0);
    IDirectSoundBuffer_SetFilter(0, 0);
    IDirectSoundBuffer_SetOutputBuffer(0, 0);
    IDirectSoundBuffer_SetMixBins(0, 0);
    IDirectSoundBuffer_SetMixBinVolumes(0, 0);
    IDirectSoundBuffer_SetAllParameters(0, 0, 0);
    IDirectSoundBuffer_SetConeAngles(0, 0, 0, 0);
    IDirectSoundBuffer_SetConeOrientation(0, 0, 0, 0, 0);
    IDirectSoundBuffer_SetConeOutsideVolume(0, 0, 0);
    IDirectSoundBuffer_SetMaxDistance(0, 0, 0);
    IDirectSoundBuffer_SetMinDistance(0, 0, 0);
    IDirectSoundBuffer_SetMode(0, 0, 0);
    IDirectSoundBuffer_SetPosition(0, 0, 0, 0, 0);
    IDirectSoundBuffer_SetVelocity(0, 0, 0, 0, 0);
    IDirectSoundBuffer_SetRolloffFactor(0, 0, 0);
    IDirectSoundBuffer_SetRolloffCurve(0, 0, 0, 0);
    IDirectSoundBuffer_SetI3DL2Source(0, 0, 0);
    IDirectSoundBuffer_Play(0, 0, 0, 0);
    IDirectSoundBuffer_PlayEx(0, 0, 0);
    IDirectSoundBuffer_Stop(0);
    IDirectSoundBuffer_StopEx(0, 0, 0);
    IDirectSoundBuffer_SetPlayRegion(0, 0, 0);
    IDirectSoundBuffer_SetLoopRegion(0, 0, 0);
    IDirectSoundBuffer_GetStatus(0, 0);
    IDirectSoundBuffer_GetCurrentPosition(0, 0, 0);
    IDirectSoundBuffer_SetCurrentPosition(0, 0);
    IDirectSoundBuffer_SetBufferData(0, 0, 0);
    IDirectSoundBuffer_Lock(0, 0, 0, 0, 0, 0, 0, 0);
    IDirectSoundBuffer_Unlock(0, 0, 0, 0, 0);
    IDirectSoundBuffer_Restore(0);
    IDirectSoundBuffer_SetNotificationPositions(0, 0, 0);
    IDirectSoundStream_QueryInterface(0, REF_GUID_NULL, 0);
    IDirectSoundStream_AddRef(((LPDIRECTSOUNDSTREAM)0));
    IDirectSoundStream_Release(((LPDIRECTSOUNDSTREAM)0));
    IDirectSoundStream_GetInfo(((LPDIRECTSOUNDSTREAM)0), 0);
    IDirectSoundStream_GetStatus(((LPDIRECTSOUNDSTREAM)0), 0);
    IDirectSoundStream_Process(((LPDIRECTSOUNDSTREAM)0), 0, 0);
    IDirectSoundStream_Discontinuity(((LPDIRECTSOUNDSTREAM)0));
    IDirectSoundStream_Flush(((LPDIRECTSOUNDSTREAM)0));
    IDirectSoundStream_SetFrequency(0, 0);
    IDirectSoundStream_SetVolume(0, 0);
    IDirectSoundStream_SetPitch(0, 0);
    IDirectSoundStream_SetLFO(0, 0);
    IDirectSoundStream_SetEG(0, 0);
    IDirectSoundStream_SetFilter(0, 0);
    IDirectSoundStream_SetOutputBuffer(0, 0);
    IDirectSoundStream_SetMixBins(0, 0);
    IDirectSoundStream_SetMixBinVolumes(0, 0);
    IDirectSoundStream_SetAllParameters(0, 0, 0);
    IDirectSoundStream_SetConeAngles(0, 0, 0, 0);
    IDirectSoundStream_SetConeOrientation(0, 0, 0, 0, 0);
    IDirectSoundStream_SetConeOutsideVolume(0, 0, 0);
    IDirectSoundStream_SetMaxDistance(0, 0, 0);
    IDirectSoundStream_SetMinDistance(0, 0, 0);
    IDirectSoundStream_SetMode(0, 0, 0);
    IDirectSoundStream_SetPosition(0, 0, 0, 0, 0);
    IDirectSoundStream_SetVelocity(0, 0, 0, 0, 0);
    IDirectSoundStream_SetRolloffFactor(0, 0, 0);
    IDirectSoundStream_SetRolloffCurve(0, 0, 0, 0);
    IDirectSoundStream_SetI3DL2Source(0, 0, 0);
    IDirectSoundStream_Pause(0, 0);
    IDirectSoundStream_FlushEx(0, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\private\windows\directx\dsound\test\testds.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       testds.cpp
 *  Content:    DirectSound test functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    dereks  Created.
 *
 ****************************************************************************/

#include "testds.h"
#include "pcm.h"
#include "adpcm.h"
#include "compress.h"
#include "8bit.h"
#include "pcmaiff.h"
#include "loop.h"
#include "mixed.h"

#ifdef DEBUG

EXTERN_C BOOL g_fDirectSoundSimulateDeltaPanic;

#endif // DEBUG

LPDIRECTSOUND g_pDirectSound = NULL;


/****************************************************************************
 *
 *  RotateVectorAzimuth
 *
 *  Description:
 *      Rotates a vector in a circle or elipse around a point.
 *
 *  Arguments:
 *      FLOAT [in]: circle size in radians.
 *      FLOAT [in]: theta in radians.
 *      LPD3DXVECTOR3 [in/out]: vector.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RotateVectorAzimuth"

__inline void
RotateVectorAzimuth
(
    FLOAT                   flDistance,
    FLOAT                   flTheta,
    LPD3DVECTOR             pvrPosition
)
{
    pvrPosition->x = (float)cos(flTheta) * flDistance;
    pvrPosition->z = (float)sin(flTheta) * flDistance;
}


/****************************************************************************
 *
 *  Test3d
 *
 *  Description:
 *      Moves a sound source around a circle.
 *
 *  Arguments:
 *      FLOAT [in]: listener position (X).
 *      FLOAT [in]: listener position (Y).
 *      FLOAT [in]: listener position (Z).
 *      FLOAT [in]: source circle radians.
 *      FLOAT [in]: source angular velocity.
 *      DWORD [in]: time, in ms, to run the test.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Test3d"

HRESULT
Test3d
(
    FLOAT                   flListenerPositionX,
    FLOAT                   flListenerPositionY,
    FLOAT                   flListenerPositionZ,
    FLOAT                   flDistance,
    FLOAT                   flAngularVelocity,
    DWORD                   dwTime
)
{
    static const LPCSTR     pszFile                 = "t:\\media\\audio\\pcm\\heli.wav";
    LPDIRECTSOUNDBUFFER     pBuffer                 = NULL;
    INT                     nLastX                  = -1;
    INT                     nLastY                  = -1;
    INT                     nLastZ                  = -1;
    DSMIXBINVOLUMEPAIR      aMixBinVolumePairs[]    = { DSMIXBINVOLUMEPAIRS_REQUIRED_3D, { DSMIXBIN_FRONT_CENTER, 0 } };
    DSMIXBINS               MixBins;
    FLOAT                   flTheta;
    D3DXVECTOR3             vrPreviousPosition;
    D3DXVECTOR3             vrCurrentPosition;
    D3DXVECTOR3             vrVelocity;
    DWORD                   dwStartTime;
    DWORD                   dwCurrentTime;
    FLOAT                   flTimeDelta;
    HRESULT                 hr;

    MixBins.dwMixBinCount = NUMELMS(aMixBinVolumePairs);
    MixBins.lpMixBinVolumePairs = aMixBinVolumePairs;

    //
    // Convert angular velocity to radians
    //

    flAngularVelocity = (flAngularVelocity * D3DX_PI) / 180.0f;
    flTheta = (90.0f * D3DX_PI) / 180.0f;

    //
    // Calculate the buffer's initial position
    //

    vrPreviousPosition.x = 0;
    vrPreviousPosition.y = 0;
    vrPreviousPosition.z = flDistance;

    vrCurrentPosition = vrPreviousPosition;

    //
    // Set the listener position
    //
    
    hr = ValidateResult(g_pDirectSound->SetPosition(flListenerPositionX, flListenerPositionY, flListenerPositionZ, DS3D_IMMEDIATE));

    //
    // Create the buffer
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(CreateBufferFromFile(pszFile, DSBCAPS_CTRL3D, &MixBins, NULL, &pBuffer));
    }

    //
    // Set the buffer's initial position
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetPosition(vrPreviousPosition.x, vrPreviousPosition.y, vrPreviousPosition.z, DS3D_IMMEDIATE));
    }

    //
    // Start the buffer playing
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
    }

    //
    // Get the current system time
    //

    if(SUCCEEDED(hr))
    {
        dwStartTime = GetTickCount();
    }

    //
    // Enter the main loop
    // 

    while(SUCCEEDED(hr) && !fBreakTest)
    {
        //
        // Get the current system time
        //

        while(dwStartTime == (dwCurrentTime = GetTickCount()));

        if(INFINITE != dwTime)
        {
            if(dwCurrentTime >= dwStartTime + dwTime)
            {
                break;
            }
        }

        //
        // Calculate the distance the sound should travel
        //

        flTimeDelta = (FLOAT)(dwCurrentTime - dwStartTime) / 1000.0f;
        flTheta += flAngularVelocity * flTimeDelta;

        //
        // Set the object's new position and velocity
        //

        RotateVectorAzimuth(flDistance, flTheta, &vrCurrentPosition);

        vrVelocity.x = (vrCurrentPosition.x - vrPreviousPosition.x) / flTimeDelta;
        vrVelocity.y = (vrCurrentPosition.y - vrPreviousPosition.y) / flTimeDelta;
        vrVelocity.z = (vrCurrentPosition.z - vrPreviousPosition.z) / flTimeDelta;

        hr = ValidateResult(pBuffer->SetVelocity(vrVelocity.x, vrVelocity.y, vrVelocity.z, DS3D_DEFERRED));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetPosition(vrCurrentPosition.x, vrCurrentPosition.y, vrCurrentPosition.z, DS3D_DEFERRED));
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(g_pDirectSound->CommitDeferredSettings());
        }

        if(SUCCEEDED(hr))
        {
            if(((INT)vrCurrentPosition.x != nLastX) || ((INT)vrCurrentPosition.y != nLastY) || ((INT)vrCurrentPosition.z != nLastZ))
            {
                nLastX = (INT)vrCurrentPosition.x;
                nLastY = (INT)vrCurrentPosition.y;
                nLastZ = (INT)vrCurrentPosition.z;

                DPF_TEST("%d %d %d (%d %d %d)", nLastX, nLastY, nLastZ, (int)vrVelocity.x, (int)vrVelocity.y, (int)vrVelocity.z);
            }
        }

        //
        // Save settings for the next time around
        //

        vrPreviousPosition = vrCurrentPosition;
        dwStartTime = dwCurrentTime;
    }

    //
    // Clean up
    //

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotBuffer
 *
 *  Description:
 *      Plays a single buffer to completion.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: buffer creation flags.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotBuffer"

HRESULT
PlayOneShotBuffer
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags     = 0,
    LPCDSMIXBINS            pMixBins    = NULL
)
{
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateBufferFromFile(pszFile, dwFlags, pMixBins, NULL, &pBuffer));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBufferToCompletion(pBuffer));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotBuffer
 *
 *  Description:
 *      Plays a single buffer to completion.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotBuffer"

HRESULT
PlayOneShotBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    LPCDSMIXBINS            pMixBins            = NULL
)
{
    WAVEFORMATEX            wfxFormat           = INIT_PCM_WAVEFORMAT(dwChannelCount, dwSamplesPerSec, dwBitsPerSample);
    LPCSTR                  pszFileName         = GetStdWaveFile(&wfxFormat);
    
    return PlayOneShotBuffer(pszFileName, dwFlags, pMixBins);
}


/****************************************************************************
 *
 *  TestSequentialBuffers
 *
 *  Description:
 *      Plays a list of secondary buffers sequentially.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSequentialBuffers"

HRESULT
TestSequentialBuffers
(
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]    = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]  = { 1, 2 };
    static const DWORD      adwBitResolutions[] = { 8, 16 };
    static const DWORD      dwBufferCount       = NUMELMS(adwSampleRates) * NUMELMS(adwChannelCounts) * NUMELMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    HRESULT                 hr                  = DS_OK;
    DWORD                   i;

    for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
    {
        hr = PlayOneShotBuffer(0, dwFormatTag, adwSampleRates[i % NUMELMS(adwSampleRates)], adwBitResolutions[i % NUMELMS(adwBitResolutions)], adwChannelCounts[i % NUMELMS(adwChannelCounts)]);
    }

    return hr;
}


/****************************************************************************
 *
 *  TestMultipleBuffers
 *
 *  Description:
 *      Plays multiple buffers of varying formats.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultipleBuffers"

HRESULT
TestMultipleBuffers
(
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]            = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]          = { 1, 2 };
    static const DWORD      adwBitResolutions[]         = { 8, 16 };
    static const DWORD      dwBufferCount               = NUMELMS(adwSampleRates) * NUMELMS(adwChannelCounts) * NUMELMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     apBuffers[dwBufferCount]    = { NULL };
    DWORD                   dwSampleRateIndex           = 0;
    DWORD                   dwChannelCountIndex         = 0;
    DWORD                   dwBitResolutionIndex        = 0;
    DWORD                   dwActiveBuffers             = 0;
    HRESULT                 hr                          = DS_OK;
    DWORD                   dwFreeSGEs;
    DWORD                   dwMaxBufferSize;
    DWORD                   dwBufferSize;
    LPCWAVEFORMATEX         pwfx;
    DWORD                   dwStatus;
    DWORD                   i;

    //
    // Get the count of free SGEs
    //

    hr = GetFreeSGEs(&dwFreeSGEs);

    //
    // Calculate the maximum buffer size
    //

    if(SUCCEEDED(hr))
    {
        dwMaxBufferSize = PAGE_SIZE;
    }

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveBuffers < dwBufferCount))
    {
        //
        // Create the buffer
        //
        
        pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);
        dwBufferSize = dwMaxBufferSize;
        
        hr = CreateStdBuffer(0, pwfx, 0, NULL, &apBuffers[dwActiveBuffers], &dwBufferSize);

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[dwActiveBuffers]);
        }

        if(SUCCEEDED(hr))
        {
            dwSampleRateIndex = (dwSampleRateIndex + 1) % NUMELMS(adwSampleRates);
            dwChannelCountIndex = (dwChannelCountIndex + 1) % NUMELMS(adwChannelCounts);
            dwBitResolutionIndex = (dwBitResolutionIndex + 1) % NUMELMS(adwBitResolutions);

            dwActiveBuffers++;
        }
    }

    //
    // Wait for all buffers to finish playing
    //

    while(SUCCEEDED(hr) && dwActiveBuffers)
    {
        DirectSoundDoWork();
        
        for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
        {
            if(apBuffers[i])
            {
                hr = ValidateResult(apBuffers[i]->GetStatus(&dwStatus));

                if(SUCCEEDED(hr) && !(dwStatus & DSBSTATUS_PLAYING))
                {
                    RELEASE(apBuffers[i]);

                    dwActiveBuffers--;
                }
            }
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  TestMultipleStreams
 *
 *  Description:
 *      Plays multiple streams of varying formats.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultipleStreams"

HRESULT
TestMultipleStreams
(
    DWORD                   dwFormatTag,
    DWORD                   dwPacketSize
)
{
    static const DWORD      adwSampleRates[]                    = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]                  = { 1, 2 };
    static const DWORD      adwBitResolutions[]                 = { 8, 16 };
    static const DWORD      dwStreamCount                       = NUMELMS(adwSampleRates) * NUMELMS(adwChannelCounts) * NUMELMS(adwBitResolutions);
    LPDIRECTSOUNDSTREAM     apStreams[dwStreamCount]            = { NULL };
    LPVOID                  apvStreamData[dwStreamCount]        = { NULL };
    HANDLE                  ahCompletionEvents[dwStreamCount]   = { NULL };
    DWORD                   dwSampleRateIndex                   = 0;
    DWORD                   dwChannelCountIndex                 = 0;
    DWORD                   dwBitResolutionIndex                = 0;
    DWORD                   dwActiveStreams                     = 0;
    HRESULT                 hr                                  = DS_OK;
    LPCWAVEFORMATEX         pwfx;
    DWORD                   i;

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveStreams < dwStreamCount))
    {
        hr = ValidatePtr(ahCompletionEvents[dwActiveStreams] = CreateEvent(NULL, FALSE, FALSE, NULL));

        if(SUCCEEDED(hr))
        {
            pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);

            dwPacketSize /= pwfx->nBlockAlign;
            dwPacketSize *= pwfx->nBlockAlign;
            
            hr = CreateStdQueuedStream(0, pwfx, 0, &dwPacketSize, ahCompletionEvents[dwActiveStreams], NULL, &apStreams[dwActiveStreams], &apvStreamData[dwActiveStreams]);
        }

        if(SUCCEEDED(hr))
        {
            hr = PauseStream(apStreams[dwActiveStreams], FALSE);
        }

        if(SUCCEEDED(hr))
        {
            dwSampleRateIndex = (dwSampleRateIndex + 1) % NUMELMS(adwSampleRates);
            dwChannelCountIndex = (dwChannelCountIndex + 1) % NUMELMS(adwChannelCounts);
            dwBitResolutionIndex = (dwBitResolutionIndex + 1) % NUMELMS(adwBitResolutions);

            dwActiveStreams++;
        }
    }

    //
    // Wait for each stream to complete
    //

    while(SUCCEEDED(hr) && dwActiveStreams)
    {
        DirectSoundDoWork();
        
        if((i = WaitForMultipleObjects(dwStreamCount, ahCompletionEvents, FALSE, 0)) < dwStreamCount)
        {
            RELEASE(apStreams[i]);
            FREE(apvStreamData[i]);

            dwActiveStreams--;
        }
    }

    //
    // Clean up
    //

    for(i = 0; i < dwStreamCount; i++)
    {
        CLOSE_HANDLE(ahCompletionEvents[i]);
    }

    return hr;
}


/****************************************************************************
 *
 *  TestNotifies
 *
 *  Description:
 *      Tests notifications.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestNotifies"

HRESULT
TestNotifies
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwNotifyCount,
    BOOL                    fLoop
)
{
    LPCWAVEFORMATEX         pwfxFormat      = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPXFILEMEDIAOBJECT      pWaveFile       = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DWORD                   dwVolumeIndex   = 0;
    DWORD                   dwDuration      = 0;
    DWORD                   dwPeriod;
    LPHANDLE                pahEvents;
    LPDSBPOSITIONNOTIFY     padsbpn;
    DSENVELOPEDESC          dseg;
    HRESULT                 hr;
    DWORD                   i;

    //
    // Create the buffer
    //

    hr = CreateStdBuffer(DSBCAPS_CTRLPOSITIONNOTIFY, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    //
    // Calculate the notification period
    //
    
    if(SUCCEEDED(hr))
    {
        dwPeriod = dwDuration / (dwNotifyCount - 1) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign;
    }

    //
    // Create notification events
    //
    
    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pahEvents, HANDLE, dwNotifyCount);
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwNotifyCount; i++)
        {
            if(FAILED(hr = ValidatePtr(pahEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL))))
            {
                break;
            }
        }
    }

    //
    // Set notifications
    //

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padsbpn, DSBPOSITIONNOTIFY, dwNotifyCount);
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwNotifyCount - 2; i++)
        {
            padsbpn[i].dwOffset = i * dwPeriod;
            padsbpn[i].hEventNotify = pahEvents[i];
        }

        padsbpn[i].dwOffset = dwDuration - pwfxFormat->nBlockAlign;
        padsbpn[i].hEventNotify = pahEvents[i];

        i++;
        
        padsbpn[i].dwOffset = DSBPN_OFFSETSTOP;
        padsbpn[i].hEventNotify = pahEvents[i];

        hr = ValidateResult(pBuffer->SetNotificationPositions(dwNotifyCount, padsbpn));
    }

    //
    // Start playback
    //

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, fLoop ? DSBPLAY_LOOPING : 0);
    }

    //
    // Wait for playback to complete
    //

    if(SUCCEEDED(hr))
    {
        while(!fBreakTest)
        {
            DirectSoundDoWork();
            
            if((i = WaitForMultipleObjects(dwNotifyCount, pahEvents, FALSE, 100)) < dwNotifyCount)
            {
                DPF_TEST("Event %lu signaled", i);

                if(WAIT_OBJECT_0 + dwNotifyCount - 1 == i)
                {
                    break;
                }
            }
        }
    }

    //
    // Clean up
    //

    if(pahEvents)
    {
        for(i = 0; i < dwNotifyCount; i++)
        {
            CLOSE_HANDLE(pahEvents[i]);
        }
    }

    FREE(pahEvents);
    FREE(padsbpn);

    RELEASE(pBuffer);
    RELEASE(pWaveFile);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotStream
 *
 *  Description:
 *      Tests streaming.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: packet size, in bytes.
 *      DWORD [in]: mixbin mask.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotStream"

HRESULT
PlayOneShotStream
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags,
    DWORD                   dwPacketSize,
    LPCDSMIXBINS            pMixBins            = NULL 
)
{
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvDataBuffer        = NULL;
    HANDLE                  hCompletionEvent;
    HRESULT                 hr;
    
    //
    // Create the completion event
    //
    
    hr = ValidatePtr(hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL));

    //
    // Create the stream 
    //

    if(SUCCEEDED(hr))
    {
        hr = CreateQueuedStreamFromFile(pszFile, dwFlags, pMixBins, &dwPacketSize, hCompletionEvent, NULL, &pStream, &pvDataBuffer);
    }

    //
    // Start playback
    //

    if(SUCCEEDED(hr))
    {
        hr = PauseStream(pStream, FALSE);
    }

    //
    // Wait for the completion event to be signaled
    //

    if(SUCCEEDED(hr))
    {
        while(TRUE)
        {
            DirectSoundDoWork();

            if(WAIT_TIMEOUT != WaitForSingleObject(hCompletionEvent, 0))
            {
                break;
            }
        }
    }

    //
    // Clean up
    //

    RELEASE(pStream);
    FREE(pvDataBuffer);
    CLOSE_HANDLE(hCompletionEvent);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotStream
 *
 *  Description:
 *      Tests streaming.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotStream"

HRESULT
PlayOneShotStream
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize,
    LPCDSMIXBINS            pMixBins        = NULL
)
{
    LPCWAVEFORMATEX         pwfxFormat      = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPCSTR                  pszFileName     = GetStdWaveFile(pwfxFormat);
    
    return PlayOneShotStream(pszFileName, dwFlags, dwPacketSize, pMixBins);
}


/****************************************************************************
 *
 *  TestBufferOffsets
 *
 *  Description:
 *      Tests buffer play region.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      FLOAT [in]: play start position (0 to 1).
 *      FLOAT [in]: play end position (0 to 1).
 *      FLOAT [in]: loop start position (0 to 1).
 *      FLOAT [in]: loop end position (0 to 1).
 *      BOOL [in]: TRUE to play looping.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestBufferOffsets"

HRESULT
TestBufferOffsets
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    FLOAT                   flPlayStart,
    FLOAT                   flPlayEnd,
    FLOAT                   flLoopStart,
    FLOAT                   flLoopEnd,
    BOOL                    fLoop
)
{
    LPCWAVEFORMATEX         pwfxFormat  = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    DWORD                   dwDuration  = 0;
    DWORD                   dwPlayStart;
    DWORD                   dwPlayLength;
    DWORD                   dwLoopStart;
    DWORD                   dwLoopLength;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    if(SUCCEEDED(hr))
    {
        dwPlayStart = (DWORD)((FLOAT)dwDuration * flPlayStart) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign;
        dwPlayLength = ((DWORD)((FLOAT)dwDuration * flPlayEnd) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign) - dwPlayStart;
        
        dwLoopStart = (DWORD)((FLOAT)dwDuration * flLoopStart) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign - dwPlayStart;
        dwLoopLength = ((DWORD)((FLOAT)dwDuration * flLoopEnd) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign) - dwLoopStart - dwPlayStart;

        DPF_TEST("Setting buffer play region to %lu, %lu and loop region to %lu, %lu (duration %lu)", dwPlayStart, dwPlayLength, dwLoopStart, dwLoopLength, dwDuration);
        
        hr = ValidateResult(pBuffer->SetPlayRegion(dwPlayStart, dwPlayLength));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetLoopRegion(dwLoopStart, dwLoopLength));
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, fLoop ? DSBPLAY_LOOPING : 0);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(30000);

        hr = PlayBuffer(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestSubMix
 *
 *  Description:
 *      Tests basic submixing.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to test MIXIN.  FALSE to test FXIN.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestSubMix"

HRESULT
TestSubMix
(
    BOOL                    fMixIn,
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]            = { /*22050, 32000, */44100, 48000};
    static const DWORD      adwChannelCounts[]          = { 1 };
    static const DWORD      adwBitResolutions[]         = { 16 };
    static const DWORD      dwBufferCount               = NUMELMS(adwSampleRates) * NUMELMS(adwChannelCounts) * NUMELMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     apBuffers[dwBufferCount]    = { NULL };
    LPDIRECTSOUNDBUFFER     apOutputBuffers[2]          = { NULL };
    DWORD                   dwActiveBuffers             = 0;
    DWORD                   dwSampleRateIndex           = 0;
    DWORD                   dwChannelCountIndex         = 0;
    DWORD                   dwBitResolutionIndex        = 0;
    HRESULT                 hr                          = DS_OK;
    DSBUFFERDESC            dsbd;
    DWORD                   dwFreeSGEs;
    DWORD                   dwMaxBufferSize;
    DWORD                   dwBufferSize;
    DWORD                   dwStatus;
    LPCWAVEFORMATEX         pwfx;
    DSMIXBINS               MixBins;
    DWORD                   i, z;

    //
    // Create output buffers
    //

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = fMixIn ? DSBCAPS_MIXIN : DSBCAPS_FXIN;

    for(i = 0; (i < NUMELMS(apOutputBuffers)) && SUCCEEDED(hr); i++)
    {
        if(!fMixIn)
        {
            dsbd.dwInputMixBin = DSMIXBIN_FXSEND_10 + i;
        }
        
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apOutputBuffers[i]));
    }

    //
    // Get the count of free SGEs
    //

    if(SUCCEEDED(hr))
    {
        hr = GetFreeSGEs(&dwFreeSGEs);
    }

    //
    // Calculate the maximum buffer size
    //

    if(SUCCEEDED(hr))
    {
        dwMaxBufferSize = ((dwFreeSGEs - dwBufferCount) * PAGE_SIZE) / dwBufferCount / 4 * 4;
    }

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveBuffers < dwBufferCount))
    {
        //
        // Create the buffer
        //
        
        pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);
        dwBufferSize = dwMaxBufferSize;

        MixBins.dwMixBinCount = 0;
        
        hr = CreateStdBuffer(0, pwfx, &MixBins, apOutputBuffers[dwActiveBuffers % NUMELMS(apOutputBuffers)], &apBuffers[dwActiveBuffers], &dwBufferSize);

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[dwActiveBuffers]);
        }

        if(SUCCEEDED(hr))
        {
            dwSampleRateIndex = (dwSampleRateIndex + 1) % NUMELMS(adwSampleRates);
            dwChannelCountIndex = (dwChannelCountIndex + 1) % NUMELMS(adwChannelCounts);
            dwBitResolutionIndex = (dwBitResolutionIndex + 1) % NUMELMS(adwBitResolutions);

            dwActiveBuffers++;
        }
    }

    //
    // Wait for all buffers to finish playing
    //

    while(SUCCEEDED(hr) && dwActiveBuffers)
    {
        for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
        {
            if(apBuffers[i])
            {
                hr = ValidateResult(apBuffers[i]->GetStatus(&dwStatus));

                if(SUCCEEDED(hr) && !(dwStatus & DSBSTATUS_PLAYING))
                {
                    RELEASE(apBuffers[i]);

                    dwActiveBuffers--;
                }
            }
        }
    }

    //
    // Release output buffers
    //

    for(i = 0; i < NUMELMS(apOutputBuffers); i++)
    {
        RELEASE(apOutputBuffers[i]);
    }

    return hr;
}


/****************************************************************************
 *
 *  TestDLS
 *
 *  Description:
 *      Tests basic DLS functionality.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDLS"

HRESULT
TestDLS
(
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    static const DWORD      dwSegmentLength = 200;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DSENVELOPEDESC          env;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        env.dwEG = DSEG_AMPLITUDE;
        env.dwMode = DSEG_MODE_DELAY;
        env.dwDelay = dwSegmentLength;
        env.dwAttack = dwSegmentLength;
        env.dwHold = dwSegmentLength;
        env.dwDecay = dwSegmentLength;
        env.dwRelease = dwSegmentLength;
        env.dwSustain = 0xFF;
        env.lPitchScale = 0;
        env.lFilterCutOff = 0;

        hr = ValidateResult(pBuffer->SetEG(&env));
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 10000, FALSE, TRUE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestStreamStop
 *
 *  Description:
 *      Tests stream release envelopes.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestStreamStop"

HRESULT
TestStreamStop
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize
)
{
    static const DWORD      dwSegmentLength     = 200;
    static const DWORD      dwDelay             = 5000;
    const LPCWAVEFORMATEX   pwfxFormat          = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvAudioData         = NULL;
    DSENVELOPEDESC          env;
    HRESULT                 hr;

    hr = CreateStdQueuedStream(0, pwfxFormat, NULL, &dwPacketSize, NULL, NULL, &pStream, &pvAudioData);

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&env, sizeof(env));
        
        env.dwEG = DSEG_AMPLITUDE;
        env.dwMode = DSEG_MODE_HOLD;
        env.dwRelease = dwSegmentLength;
        env.dwSustain = 0xFF;

        hr = ValidateResult(pStream->SetEG(&env));
    }

    if(SUCCEEDED(hr))
    {
        hr = PauseStream(pStream, FALSE);
    }

    if(SUCCEEDED(hr))
    {
        hr = FlushStream(pStream, dwFlags, (dwFlags & DSSTREAMFLUSHEX_ASYNC) ? dwDelay : 0, TRUE);
    }

    RELEASE(pStream);

    FREE(pvAudioData);

    return hr;
}


/****************************************************************************
 *
 *  TestSurroundEncoder
 *
 *  Description:
 *      Tests surround-sound encoding.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "TestSurroundEncoder"

HRESULT
TestSurroundEncoder
(
    DWORD                       dwFormatTag,
    DWORD                       dwSamplesPerSec,
    DWORD                       dwBitsPerSample
)
{
    typedef struct
    {
        LPCSTR                  pszDescription;
        DWORD                   pMixBins;
    } TESTMIXBINS;

    static const TESTMIXBINS    aMixBins[] =
    {

#if 0

        { "All speakers",       DSMIXBIN_SPEAKER_MASK },
        { "Front left",         DSMIXBIN_FRONT_LEFT },
        { "Front right",        DSMIXBIN_FRONT_RIGHT },
        { "Front center",       DSMIXBIN_FRONT_CENTER },
        { "Back left",          DSMIXBIN_BACK_LEFT },
        { "Back right",         DSMIXBIN_BACK_RIGHT },
        { "LFE",                DSMIXBIN_LOW_FREQUENCY },

#else

        { "Front",              DSMIXBIN_FRONT_LEFT },
        { "Back",               DSMIXBIN_BACK_LEFT },

#endif

    };
    
    static const DWORD          dwDuration  = 5000;
    LPDIRECTSOUNDBUFFER         pBuffer     = NULL;
    HRESULT                     hr;
    DWORD                       i;

    hr = CreateStdBuffer(0, CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, 1), 0, NULL, &pBuffer);

    for(i = 0; (i < NUMELMS(aMixBins)) && SUCCEEDED(hr); i++)
    {
        DPF_TEST(aMixBins[i].pszDescription);

        hr = ValidateResult(pBuffer->SetMixBins(aMixBins[i].pMixBins));

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
        }

        if(SUCCEEDED(hr))
        {
            Sleep(dwDuration);
        }
    }

    RELEASE(pBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  TestSgeSharing
 *
 *  Description:
 *      Tests whether buffer SGE sharing works by creating two very large
 *      buffers and pointing them to the same memory.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSgeSharing"

HRESULT
TestSgeSharing
(
    void
)
{
    LPVOID                      pvBufferData    = NULL;
    LPDIRECTSOUNDBUFFER         apBuffers[2]    = { NULL };
    DWORD                       dwBufferSize;
    DSBUFFERDESC                dsbd;
    WAVEFORMATEX                wfx;
    HRESULT                     hr;
    DWORD                       i;

    XAudioCreatePcmFormat(2, 48000, 16, &wfx);

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.lpwfxFormat = &wfx;

    dwBufferSize = -1;
    
    hr = ClampBufferSize(&dwBufferSize);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvBufferData, BYTE, dwBufferSize);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone16(pvBufferData, dwBufferSize, wfx.nSamplesPerSec, wfx.nChannels, 500);
    }

    for(i = 0; (i < NUMELMS(apBuffers)) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[i]));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(apBuffers[i]->SetBufferData(pvBufferData, dwBufferSize));
        }

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[i], DSBPLAY_LOOPING);
        }

        if(SUCCEEDED(hr))
        {
            hr = StopBuffer(apBuffers[i], 0, (5000 * i) + 10000);
        }
    }

    for(i = 0; (i < NUMELMS(apBuffers)) && SUCCEEDED(hr); i++)
    {
        if(apBuffers[i])
        {
            hr = WaitBuffer(apBuffers[i], FALSE);

            RELEASE(apBuffers[i]);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  TestSgeHeap
 *
 *  Description:
 *      Allocates all available SGEs, then frees them all in a random order
 *      to verify that they were coalesced properly.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSgeHeap"

HRESULT
TestSgeHeap
(
    void
)
{
    LPDIRECTSOUNDBUFFER     apBuffers[256]  = { NULL };
    LPVOID                  pvBufferData    = NULL;
    DWORD                   dwBufferCount;
    DWORD                   dwBufferSize;
    DWORD                   dwRemaining;
    DWORD                   dwFree;
    DSBUFFERDESC            dsbd;
    DSCAPS                  dsc;
    HRESULT                 hr;
    DWORD                   i;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.lpwfxFormat = (LPWAVEFORMATEX)CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);

    hr = GetDirectSoundCaps(&dsc);

    if(SUCCEEDED(hr))
    {
        dwBufferCount = dsc.dwFree2DBuffers + dsc.dwFree3DBuffers;
        dwBufferSize = dsc.dwFreeBufferSGEs / dwBufferCount;
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidatePtr(pvBufferData = MmAllocateContiguousMemoryEx(dsc.dwFreeBufferSGEs * PAGE_SIZE, 0, 0xFFFFFFFF, PAGE_SIZE, PAGE_READWRITE));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("Creating %lu buffers", dwBufferCount);
        
        for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
        {
            hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[i]));

            if(SUCCEEDED(hr))
            {
                if(dwBufferCount - 1 == i)
                {
                    dwBufferSize = dsc.dwFreeBufferSGEs - dwBufferSize;
                }
                
                hr = ValidateResult(apBuffers[i]->SetBufferData(pvBufferData, dwBufferSize * PAGE_SIZE));
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = GetFreeSGEs(&dwFree);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(!dwFree);
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("Releasing all buffers");

        for(dwRemaining = dwBufferCount; dwRemaining; dwRemaining--)
        {
            dwFree = rand() % dwRemaining;

            for(i = 0; i < dwBufferCount; i++)
            {
                if(apBuffers[i])
                {
                    if(!dwFree)
                    {
                        RELEASE(apBuffers[i]);
                        break;
                    }

                    dwFree--;
                }
            }

            ASSERT(!dwFree);
        }

        for(i = 0; i < dwBufferCount; i++)
        {
            ASSERT(!apBuffers[i]);
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("Creating big buffer");

        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[0]));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(apBuffers[0]->SetBufferData(pvBufferData, dsc.dwFreeBufferSGEs * PAGE_SIZE));
    }

    RELEASE(apBuffers[0]);

    if(pvBufferData)
    {
        MmFreeContiguousMemory(pvBufferData);
    }

    return hr;
}


/****************************************************************************
 *
 *  Test256Voices
 *
 *  Description:
 *      Creates 256 voices.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Test256Voices"

HRESULT
Test256Voices
(
    void
)
{
    static const DWORD          dwBufferSize    = PAGE_SIZE;
    LPVOID                      pvBufferData    = NULL;
    LPDIRECTSOUNDBUFFER         apBuffers[256]  = { NULL };
    DSCAPS                      dsc;
    DSBUFFERDESC                dsbd;
    WAVEFORMATEX                wfx;
    HRESULT                     hr;
    DWORD                       i;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.lpwfxFormat = &wfx;

    XAudioCreatePcmFormat(1, dwBufferSize / 2, 16, &wfx);

    hr = MALLOC(pvBufferData, BYTE, dwBufferSize);

    if(SUCCEEDED(hr))
    {
        GenerateTone16(pvBufferData, dwBufferSize, wfx.nSamplesPerSec, wfx.nChannels, 500);
    }

    if(SUCCEEDED(hr))
    {
        hr = GetDirectSoundCaps(&dsc);
    }

    for(i = 0; (i < dsc.dwFree2DBuffers) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[i]));
    }

    if(SUCCEEDED(hr))
    {
        dsbd.dwFlags |= DSBCAPS_CTRL3D;
    }
    
    for(i = 0; (i < dsc.dwFree3DBuffers) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[dsc.dwFree2DBuffers + i]));
    }

    for(i = 0; (i < dsc.dwFree2DBuffers + dsc.dwFree3DBuffers) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(apBuffers[i]->SetBufferData(pvBufferData, dwBufferSize));

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[i], DSBPLAY_LOOPING);
        }
    }

    if(SUCCEEDED(hr))
    {
        Sleep(5000);
    }

    for(i = 0; i < NUMELMS(apBuffers); i++)
    {
        if(apBuffers[i])
        {
            StopBuffer(apBuffers[i], 0, 0, FALSE, TRUE);
        }
        
        RELEASE(apBuffers[i]);
    }

    FREE(pvBufferData);

    return hr;
}


/****************************************************************************
 *
 *  TestStop
 *
 *  Description:
 *      Tests stopping and restarting a buffer.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestStop"

HRESULT
TestStop
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    LPCWAVEFORMATEX         pwfxFormat  = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    DWORD                   dwDuration  = 0;
    DWORD                   dwPlay;
    DWORD                   dwWrite;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(!dwPlay);
        ASSERT(!dwWrite);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("initial play:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(2000);

        hr = ValidateResult(pBuffer->SetCurrentPosition(dwDuration / 2 / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign));
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("manual setposition:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, 0, 10000, FALSE, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(2500);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("forced stop:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("play from current position:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("natural stop:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(2000);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("play after natural stop (2000 ms delayed):  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_FROMSTART);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("play from start:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestFrequency
 *
 *  Description:
 *      Tests changing the frequency.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestFrequency"

HRESULT
TestFrequency
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwDelay
)
{
    static const DWORD      adwFrequencies[]    = { 0, 8000, 11025, 16000, 22050, 32000, 44100, 48000, 64000, 96000 };
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    DWORD                   dwFrequency;
    HRESULT                 hr;

    hr = CreateStdBuffer(dwFlags, CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        for(dwFrequency = 0; (dwFrequency < NUMELMS(adwFrequencies)) && SUCCEEDED(hr); dwFrequency++)
        {
            DPF_TEST("Frequency %lu", adwFrequencies[dwFrequency]);

            hr = ValidateResult(pBuffer->SetFrequency(adwFrequencies[dwFrequency]));

            if(SUCCEEDED(hr))
            {
                Sleep(dwDelay);
            }
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestDiscontinuity
 *
 *  Description:
 *      Tests allowing the stream to starve by calling Discontinuity.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDiscontinuity"

HRESULT
TestDiscontinuity
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize,
    BOOL                    fStarve
)
{
    LPCWAVEFORMATEX         pwfxFormat          = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvDataBuffer        = NULL;
    DWORD                   dwPacketsThisTime   = 0;
    DWORD                   dwDuration;
    DWORD                   dwPacketCount;
    XMEDIAPACKET            xmb;
    HRESULT                 hr;
    DWORD                   i, z;

    //
    // Create the stream

    hr = CreateStdStream(dwFlags, pwfxFormat, 0, &dwPacketSize, NULL, NULL, NULL, &pStream, &pvDataBuffer, &dwDuration, &dwPacketCount);

    //
    // Enter the stream loop
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmb, sizeof(xmb));
        
        xmb.pvBuffer = pvDataBuffer;
        xmb.dwMaxSize = dwPacketSize;

        while(dwPacketCount)
        {
            dwPacketsThisTime = ((dwPacketsThisTime + 1) % 2) + 1;

            for(z = 0; (z < dwPacketsThisTime) && dwPacketCount && SUCCEEDED(hr); z++)
            {
                DirectSoundDoWork();
            
                if(!--dwPacketCount)
                {
                    xmb.dwMaxSize = dwDuration;
                }                
            
                hr = ValidateResult(pStream->Process(&xmb, NULL));

                xmb.pvBuffer = (LPBYTE)xmb.pvBuffer + xmb.dwMaxSize;
            
                dwDuration -= xmb.dwMaxSize;
            }

            if(SUCCEEDED(hr) && !fStarve)
            {
                hr = ValidateResult(pStream->Discontinuity());
            }

            if(SUCCEEDED(hr))
            {
                Sleep((dwPacketSize * dwPacketsThisTime * 2) / (pwfxFormat->nAvgBytesPerSec / 1000));
            }
        }
    }

    //
    // Clean up
    //

    RELEASE(pStream);
    FREE(pvDataBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestDeferredCommandRelease
 *
 *  Description:
 *      Tests whether deferred commands automatically get released when the
 *      buffer is.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDeferredCommandRelease"

HRESULT
TestDeferredCommandRelease
(
    void
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, CreateFormat(WAVE_FORMAT_PCM, 32000, 16, 2), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 10000);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestHeadroom
 *
 *  Description:
 *      Tests headroom.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "TestHeadroom"

HRESULT
TestHeadroom
(
    void
)
{
    static const DWORD      dwSleep         = 2000;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    HRESULT                 hr;
    int                     i;

    hr = CreateToneBuffer(0, 8000, 16, 1, 500, 0, 0, &pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    for(i = DSBHEADROOM_MAX; SUCCEEDED(hr) && (i >= DSBHEADROOM_MIN); i -= 1000)
    {
        DPF_TEST("%lu voice headroom", i);

        hr = ValidateResult(pBuffer->SetHeadroom(i));

        if(SUCCEEDED(hr))
        {
            Sleep(dwSleep);
        }
    }

    for(i = DSHEADROOM_MIN; SUCCEEDED(hr) && (i <= DSHEADROOM_MAX); i++)
    {
        DPF_TEST("%lu mixbin headroom", i);

        hr = ValidateResult(g_pDirectSound->SetMixBinHeadroom(DSMIXBIN_VALID, i));

        if(SUCCEEDED(hr))
        {
            Sleep(dwSleep);
        }
    }

    RELEASE(pBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  TestI3DL2Listener
 *
 *  Description:
 *      Tests I3DL2 listener.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "TestI3DL2Listener"

HRESULT
TestI3DL2Listener
(
    void
)
{
    static const struct
    {
        LPCSTR                      pszName;
        DSI3DL2LISTENER             Properties;
    } Environments[] =
    {
        { "Default",         { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT } },
        { "Generic",         { DSI3DL2_ENVIRONMENT_PRESET_GENERIC } },
        { "PaddedCell",      { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL } },
        { "Room",            { DSI3DL2_ENVIRONMENT_PRESET_ROOM } },
        { "Bathroom",        { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM } },
        { "LivingRoom",      { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM } },
        { "StoneRoom",       { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM } },
        { "Auditorium",      { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM } },
        { "ConcertHall",     { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL } },
        { "Cave",            { DSI3DL2_ENVIRONMENT_PRESET_CAVE } },
        { "Arena",           { DSI3DL2_ENVIRONMENT_PRESET_ARENA } },
        { "Hangar",          { DSI3DL2_ENVIRONMENT_PRESET_HANGAR } },
        { "CarpetedHallway", { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY } },
        { "Hallway",         { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY } },
        { "StoneCorridor",   { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR } },
        { "Alley",           { DSI3DL2_ENVIRONMENT_PRESET_ALLEY } },
        { "Forest",          { DSI3DL2_ENVIRONMENT_PRESET_FOREST } },
        { "City",            { DSI3DL2_ENVIRONMENT_PRESET_CITY } },
        { "Mountains",       { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS } },
        { "Quarry",          { DSI3DL2_ENVIRONMENT_PRESET_QUARRY } },
        { "Plain",           { DSI3DL2_ENVIRONMENT_PRESET_PLAIN } },
        { "ParkingLot",      { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT } },
        { "SewerPipe",       { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE } },
        { "UnderWater",      { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER } },
    };

    static const DWORD              pMixBins    = DSMIXBIN_SPEAKER_MASK | DSMIXBIN_I3DL2;
    static const DWORD              dwDelay         = 10000;
    LPDIRECTSOUNDBUFFER             pBuffer         = NULL;
    HRESULT                         hr;
    DWORD                           i;

    hr = CreateBufferFromFile("t:\\media\\audio\\pcm\\CleanGuitarArpeggios.wav", 0, pMixBins, NULL, &pBuffer);

    for(i = 0; SUCCEEDED(hr) && (i < NUMELMS(Environments)); i++)
    {
        DPF_TEST(Environments[i].pszName);

        hr = ValidateResult(g_pDirectSound->SetI3DL2Listener(&Environments[i].Properties, DS3D_IMMEDIATE));

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
        }

        if(SUCCEEDED(hr))
        {
            Sleep(dwDelay);
        }
    }

    RELEASE(pBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  TestMultiChannel
 *
 *  Description:
 *      Tests multichannel content.
 *
 *  Arguments:
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultiChannel"

HRESULT
TestMultiChannel
(
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    LPCWAVEFORMATEX         pwfxSrc             = CreateFormat(WAVE_FORMAT_PCM, dwSampleRate, dwBitsPerSample, dwChannelCount);
    XFileMediaObject *      pWaveFile           = NULL;
    LPVOID                  pvSrcData           = NULL;
    LPVOID                  pvDstData           = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    WAVEFORMATEX            wfxDst;
    DWORD                   dwSrcDataSize;
    DWORD                   dwDstDataSize;
    DSBUFFERDESC            dsbd;
    HRESULT                 hr;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = 0;
    dsbd.lpwfxFormat = &wfxDst;
    
    //
    // Load the source wave file
    //

    hr = LoadStdWaveFile(pwfxSrc, &pvSrcData, &dwSrcDataSize, &pWaveFile);

    //
    // Enter the multichannel test loop
    //

    if(SUCCEEDED(hr))
    {
        for(wfxDst.nChannels = pwfxSrc->nChannels + 1; wfxDst.nChannels <= 6; wfxDst.nChannels++)
        {
            if(wfxDst.nChannels % pwfxSrc->nChannels)
            {
                continue;
            }

            if(wfxDst.nChannels % 2)
            {
                continue;
            }

            //
            // Convert to multichannel
            //

            DPF_TEST("Converting from %lu channel to %lu channel", pwfxSrc->nChannels, wfxDst.nChannels);
            
            hr = MakeMultiChannel(pwfxSrc, &wfxDst, pvSrcData, dwSrcDataSize, &pvDstData, &dwDstDataSize);

            //
            // Create the buffer, making sure to keep it to 2047 SGEs
            //
            
            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
            }

            if(SUCCEEDED(hr))
            {
                hr = ClampBufferSize(&dwDstDataSize);
            }

            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(pBuffer->SetBufferData(pvDstData, dwDstDataSize));
            }

            //
            // Start playback
            //

            if(SUCCEEDED(hr))
            {
                hr = PlayBufferToCompletion(pBuffer);
            }

            //
            // Clean up
            //

            FREE(pvDstData);
            RELEASE(pBuffer);
        }
    }

    //
    // Clean up
    //

    RELEASE(pWaveFile);
    FREE(pvSrcData);

    return hr;
}


/****************************************************************************
 *
 *  TestMultiChannel2
 *
 *  Description:
 *      Tests multichannel content.
 *
 *  Arguments:
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultiChannel2"

HRESULT
TestMultiChannel2
(
    DWORD                   dwChannelCount
)
{
    static const DWORD      dwSegmentLength = 2;
    LPVOID                  pvMonoData      = NULL;
    LPVOID                  pvMultiData     = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    WAVEFORMATEX            wfxMono;
    WAVEFORMATEX            wfxMulti;
    short *                 pnMonoData;
    short *                 pnMultiData;
    DSBUFFERDESC            dsbd;
    HRESULT                 hr;
    DWORD                   a, b, c;

    XAudioCreatePcmFormat(1, 48000, 16, &wfxMono);
    XAudioCreatePcmFormat(6, wfxMono.nSamplesPerSec, wfxMono.wBitsPerSample, &wfxMulti);

    hr = MALLOC(pvMonoData, BYTE, wfxMono.nAvgBytesPerSec * dwSegmentLength);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvMultiData, BYTE, wfxMulti.nAvgBytesPerSec * wfxMulti.nChannels * dwSegmentLength);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvMonoData, wfxMono.nAvgBytesPerSec * dwSegmentLength, wfxMono.nSamplesPerSec, wfxMono.wBitsPerSample, wfxMono.nChannels, 500);
    }

    if(SUCCEEDED(hr))
    {
        pnMultiData = (short *)pvMultiData;
        
        for(a = 0; a < wfxMulti.nChannels; a++)
        {
            pnMonoData = (short *)pvMonoData;
            
            for(b = 0; b < wfxMulti.nSamplesPerSec * dwSegmentLength; b++)
            {
                for(c = 0; c < a; c++)
                {
                    *pnMultiData++ = 0;
                }

                *pnMultiData++ = *pnMonoData++;

                for(c = a + 1; c < wfxMulti.nChannels; c++)
                {
                    *pnMultiData++ = 0;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = &wfxMulti;

        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetBufferData(pvMultiData, wfxMulti.nAvgBytesPerSec * wfxMulti.nChannels * dwSegmentLength));
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    RELEASE(pBuffer);

    FREE(pvMultiData);
    FREE(pvMonoData);

    return hr;
}


/****************************************************************************
 *
 *  TestMultiChannel3
 *
 *  Description:
 *      Tests multichannel content.
 *
 *  Arguments:
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultiChannel3"

HRESULT
TestMultiChannel3
(
    DWORD                   dwChannelCount
)
{
    static const DWORD      dwSegmentLength = 2;
    LPVOID                  pvMonoData      = NULL;
    LPVOID                  pvMultiData     = NULL;
    LPDIRECTSOUNDSTREAM     pStream         = NULL;
    WAVEFORMATEX            wfxMono;
    WAVEFORMATEX            wfxMulti;
    short *                 pnMonoData;
    short *                 pnMultiData;
    DSSTREAMDESC            dssd;
    XMEDIAPACKET            xmp;
    DWORD                   dwStatus;
    HRESULT                 hr;
    DWORD                   a, b, c;

    XAudioCreatePcmFormat(1, 48000, 16, &wfxMono);
    XAudioCreatePcmFormat(6, wfxMono.nSamplesPerSec, wfxMono.wBitsPerSample, &wfxMulti);

    hr = MALLOC(pvMonoData, BYTE, wfxMono.nAvgBytesPerSec * dwSegmentLength);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvMultiData, BYTE, wfxMulti.nAvgBytesPerSec * wfxMulti.nChannels * dwSegmentLength);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvMonoData, wfxMono.nAvgBytesPerSec * dwSegmentLength, wfxMono.nSamplesPerSec, wfxMono.wBitsPerSample, wfxMono.nChannels, 500);
    }

    if(SUCCEEDED(hr))
    {
        pnMultiData = (short *)pvMultiData;
        
        for(a = 0; a < wfxMulti.nChannels; a++)
        {
            pnMonoData = (short *)pvMonoData;
            
            for(b = 0; b < wfxMulti.nSamplesPerSec * dwSegmentLength; b++)
            {
                for(c = 0; c < a; c++)
                {
                    *pnMultiData++ = 0;
                }

                *pnMultiData++ = *pnMonoData++;

                for(c = a + 1; c < wfxMulti.nChannels; c++)
                {
                    *pnMultiData++ = 0;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dssd, sizeof(dssd));

        dssd.lpwfxFormat = &wfxMulti;
        dssd.dwMaxAttachedPackets = 1;

        hr = ValidateResult(DirectSoundCreateStream(&dssd, &pStream));
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvMultiData;
        xmp.dwMaxSize = wfxMulti.nAvgBytesPerSec * wfxMulti.nChannels * dwSegmentLength;
        xmp.pdwStatus = &dwStatus;

        hr = ValidateResult(pStream->Process(&xmp, NULL));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pStream->Discontinuity());
    }

    if(SUCCEEDED(hr))
    {
        while(XMEDIAPACKET_STATUS_PENDING == *((volatile DWORD *)&dwStatus))
        {
            DirectSoundDoWork();
        }
    }

    RELEASE(pStream);

    FREE(pvMultiData);
    FREE(pvMonoData);

    return hr;
}


/****************************************************************************
 *
 *  TestReleaseEnvelope
 *
 *  Description:
 *      Tests the hardware release envelope.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestReleaseEnvelope"

HRESULT
TestReleaseEnvelope
(
    void
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    DSENVELOPEDESC          dsed;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(0, 8000, 16, 1, 500, 0, 0, &pBuffer));

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsed, sizeof(dsed));

        dsed.dwEG = DSEG_MULTI;
        dsed.dwMode = DSEG_MODE_DISABLE;
        dsed.dwRelease = 1000;
        
        hr = ValidateResult(pBuffer->SetEG(&dsed));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 0, FALSE, TRUE));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  CompareVolume
 *
 *  Description:
 *      Compares comparable 2D and 3D buffer volume.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#if 0

#undef DPF_FNAME
#define DPF_FNAME "CompareVolume"

HRESULT
CompareVolume
(
    FLOAT                   flDistance
)
{
    static const LONG       lExtra  = -600;
    const LONG              lVolume = (LONG)(-2000.0f * log10f(flDistance)) + lExtra;
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    BOOL                    f3d     = FALSE;
    HRESULT                 hr      = DS_OK;

    while(SUCCEEDED(hr) && !fBreakTest)
    {
        DPF_TEST(f3d ? "3D" : "2D");
        
        hr = ValidateResult(CreateToneBuffer(f3d ? DSBCAPS_CTRL3D : 0, 8000, 16, 1, 500, 0, f3d ? 0 : DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_LEFT, &pBuffer));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetHeadroom(0));
        }

        if(SUCCEEDED(hr))
        {
            if(f3d)
            {
                hr = ValidateResult(pBuffer->SetPosition(0, 0, flDistance, DS3D_IMMEDIATE));
            }
            else
            {
                hr = ValidateResult(pBuffer->SetVolume(lVolume));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(StopBuffer(pBuffer, 0, 2000, FALSE, TRUE));
        }

        RELEASE(pBuffer);

        f3d = !f3d;
    }

    RELEASE(pBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  PlayToneBuffer
 *
 *  Description:
 *      Plays a simple sine-wave buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *      DWORD [in]: length of time to play the buffer, in ms.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayToneBuffer"

HRESULT
PlayToneBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels,
    DWORD                   dwToneFrequency,
    DWORD                   dwTime
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(dwFlags, dwSamplesPerSec, dwBitsPerSample, dwChannels, dwToneFrequency, 0, 0, &pBuffer));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
    }

    if(SUCCEEDED(hr) && (INFINITE != dwTime))
    {
        hr = ValidateResult(StopBuffer(pBuffer, 0, dwTime));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(WaitBuffer(pBuffer, FALSE));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestNaturalStop
 *
 *  Description:
 *      Tests playing a buffer to completion.
 *
 *  Arguments:
 *      DWORD [in]: iterations.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestNaturalStop"

HRESULT
TestNaturalStop
(
    DWORD                   dwIterations
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(0, 8000, 16, 1, 400, 400, 0, &pBuffer));

    while(SUCCEEDED(hr))
    {
        if(INFINITE != dwIterations)
        {
            if(!dwIterations--)
            {
                break;
            }
        }
    
        hr = ValidateResult(PlayBuffer(pBuffer));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(WaitBuffer(pBuffer, FALSE));
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestFlush
 *
 *  Description:
 *      Tests flushing a stream.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestFlush"

HRESULT
TestFlush
(
    void
)
{
    const LPCWAVEFORMATEX   pwfxFormat          = CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    DWORD                   dwPacketSize        = 0x1000;
    LPVOID                  pvAudioData         = NULL;
    DWORD                   dwAudioDataSize     = NULL;
    DWORD                   dwPacketCount       = 0;
    LPDWORD                 padwStatus          = NULL;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    DWORD                   i;

    hr = ValidateResult(CreateStdStream(0, pwfxFormat, 0, &dwPacketSize, NULL, NULL, NULL, &pStream, &pvAudioData, &dwAudioDataSize, &dwPacketCount));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padwStatus, DWORD, dwPacketCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvAudioData;
        xmp.dwMaxSize = dwPacketSize;
        xmp.pdwStatus = padwStatus;
        
        for(i = 0; SUCCEEDED(hr) && (i < dwPacketCount); i++)
        {
            if(i + 1 == dwPacketCount)
            {
                xmp.dwMaxSize = dwAudioDataSize - (dwPacketSize * (dwPacketCount - 1));
            }
            
            hr = ValidateResult(pStream->Process(&xmp, NULL));

            if(SUCCEEDED(hr))
            {
                xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
                xmp.pdwStatus++;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        Sleep(5000);

        hr = ValidateResult(pStream->Flush());
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            if((XMEDIAPACKET_STATUS_SUCCESS != padwStatus[i]) && (XMEDIAPACKET_STATUS_FLUSHED != padwStatus[i]))
            {
                DPF_TEST("Packet %lu status %x", i, padwStatus[i]);
                hr = E_FAIL;
            }
        }
    }

    RELEASE(pStream);
    FREE(padwStatus);
    FREE(pvAudioData);

    return hr;
}


/****************************************************************************
 *
 *  TestPitch
 *
 *  Description:
 *      Tests pitch.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestPitch"

HRESULT
TestPitch
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels
)
{
    static const LONG       alPitch[]   = { DSBPITCH_MIN, 0, DSBPITCH_MAX };
    const LPCWAVEFORMATEX   pwfxFormat  = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannels);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    HRESULT                 hr;
    DWORD                   i;

    hr = ValidateResult(CreateStdBuffer(dwFlags, pwfxFormat, 0, NULL, &pBuffer, NULL));

    if(SUCCEEDED(hr))
    {
        for(i = 0; (i < NUMELMS(alPitch)) && SUCCEEDED(hr); i++)
        {
            DPF_TEST("Pitch %d", alPitch[i]);
            
            hr = ValidateResult(pBuffer->SetPitch(alPitch[i]));

            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
            }

            if(SUCCEEDED(hr))
            {
                Sleep(2000);
            }
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  StressPlayStop
 *
 *  Description:
 *      Stresses calling Play and Stop.
 *
 *  Arguments:
 *      DWORD [in]: time to test, in ms.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "StressPlayStop"

HRESULT
StressPlayStop
(
    DWORD                       dwFlags,
    DWORD                       dwSourceCount,
    DWORD                       dwNoteOffMin,
    DWORD                       dwNoteOffMax,
    DWORD                       dwTestLength,
    DWORD                       dwStreamCount,
    DWORD                       dwStreamFrequency
)
{
    static const DWORD          DSBSTATUS_PENDINGSTOP   = 0x80000000;
    static const WORD           awSilence[32]           = { 0 };
    const WAVEFORMATEX          wfxSilence              = INIT_PCM_WAVEFORMAT(1, dwStreamFrequency, 16);
    LPDIRECTSOUNDBUFFER         apSourceBuffers[256]    = { NULL };
    DWORD                       adwStatus[256]          = { 0 };
    LPDIRECTSOUNDSTREAM         apStreams[256]          = { NULL };
    LPDIRECTSOUNDBUFFER         pDestBuffer             = NULL;
    DWORD                       dwPlayCount             = 0;
    DWORD                       dwStopCount             = 0;
    DWORD                       dwNoteOffCount          = 0;
    DWORD                       dwNaturalStopCount      = 0;
    DWORD                       dwSubmixCount           = 0;
    DWORD                       dwLoopCount             = 0;
    HRESULT                     hr                      = S_OK;
    DWORD                       dwStartTime;
    DWORD                       dwCurrentTime;
    DWORD                       dwStatus;
    DSCAPS                      dsc;
    DSBUFFERDESC                dsbd;
    DSSTREAMDESC                dssd;
    DSENVELOPEDESC              dseg;
    XMEDIAPACKET                xmp;
    DWORD                       i, z;

    //
    // Set up the envelope description for NoteOff
    //
    
    dseg.dwEG = DSEG_AMPLITUDE;
    dseg.dwMode = DSEG_MODE_HOLD;
    dseg.dwDelay = DSEG_DELAY_DEFAULT;
    dseg.dwAttack = DSEG_ATTACK_DEFAULT;
    dseg.dwHold = DSEG_HOLD_DEFAULT;
    dseg.dwDecay = DSEG_DECAY_DEFAULT;
    dseg.dwRelease = DSEG_RELEASE_DEFAULT;
    dseg.dwSustain = DSEG_SUSTAIN_DEFAULT;
    dseg.lPitchScale = DSEG_PITCHSCALE_DEFAULT;
    dseg.lFilterCutOff = DSEG_FILTERCUTOFF_DEFAULT;

    //
    // Create the submix buffer
    //

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_MIXIN;

    hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pDestBuffer));

    //
    // Create interference streams
    //

    if(SUCCEEDED(hr) && dwStreamCount)
    {
        DPF_TEST("Creating %lu interference streams", dwStreamCount);

        ZeroMemory(&dssd, sizeof(dssd));

        dssd.lpwfxFormat = (LPWAVEFORMATEX)&wfxSilence;
        dssd.dwMaxAttachedPackets = 2;
        dssd.lpfnCallback = ResubmitPacketCallback;
        
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = (LPVOID)awSilence;
        xmp.dwMaxSize = sizeof(awSilence);
        xmp.pContext = &xmp;

        for(i = 0; (i < dwStreamCount) && SUCCEEDED(hr); i++)
        {
            dssd.lpvContext = &apStreams[i];

            hr = ValidateResult(DirectSoundCreateStream(&dssd, &apStreams[i]));

            if(SUCCEEDED(hr))
            {
                hr = PauseStream(apStreams[i], TRUE);
            }

            for(z = 0; (z < dssd.dwMaxAttachedPackets) && SUCCEEDED(hr); z++)
            {
                hr = ValidateResult(apStreams[i]->Process(&xmp, NULL));
            }

            if(SUCCEEDED(hr))
            {
                hr = PauseStream(apStreams[i], FALSE);
            }
        }
    }

    //
    // Create source buffers
    //
    
    if(SUCCEEDED(hr))
    {
        hr = GetDirectSoundCaps(&dsc);
    }

    if(SUCCEEDED(hr))
    {
        dwSourceCount = min(dwSourceCount, dsc.dwFree2DBuffers + dsc.dwFree3DBuffers);

        DPF_TEST("Creating %lu buffers", dwSourceCount);

        for(i = 0; (i < dwSourceCount) && SUCCEEDED(hr); i++)
        {
            hr = ValidateResult(CreateToneBuffer(dwFlags, 32000, 16, 1, 500, 0, 0, &apSourceBuffers[i]));
        }
    }

    //
    // Save the current time
    //

    if(SUCCEEDED(hr))
    {
        dwStartTime = GetTickCount();
    }

    //
    // Enter the main loop
    //

    while(SUCCEEDED(hr))
    {
        DirectSoundDoWork();

        //
        // Check the current time
        //
        
        if(!((dwCurrentTime = GetTickCount()) % 2000))
        {
            DPF_TEST("%lu plays (%lu submixing, %lu looping), %lu natural stops, %lu forced, %lu note-off", dwPlayCount, dwSubmixCount, dwLoopCount, dwNaturalStopCount, dwStopCount, dwNoteOffCount);

            dwPlayCount = 0;
            dwStopCount = 0;
            dwNoteOffCount = 0;
            dwNaturalStopCount = 0;
            dwSubmixCount = 0;
            dwLoopCount = 0;

            if(INFINITE != dwTestLength)
            {
                if(dwCurrentTime >= dwStartTime + dwTestLength)
                {
                    break;
                }
            }
        }

        //
        // Pick a random buffer and get it's status
        //

        i = rand() % dwSourceCount;

        hr = ValidateResult(apSourceBuffers[i]->GetStatus(&dwStatus));

        if(SUCCEEDED(hr))
        {
            if(adwStatus[i] & DSBSTATUS_PENDINGSTOP)
            {
                if(!(dwStatus & DSBSTATUS_PLAYING))
                {
                    adwStatus[i] = 0;
                }
            }
            else
            {
                adwStatus[i] = dwStatus;
            }
        }

        //
        // Should we play or stop?
        //

        if(SUCCEEDED(hr) && !(adwStatus[i] & DSBSTATUS_PENDINGSTOP))
        {
            if(rand() % 2)
            {
                dwPlayCount++;
            
                //
                // Submix or not?
                //
            
                if(!(adwStatus[i] & DSBSTATUS_PLAYING))
                {
                    if(rand() % 2)
                    {
                        dwSubmixCount++;
                
                        hr = ValidateResult(apSourceBuffers[i]->SetOutputBuffer(pDestBuffer));
                    }
                    else
                    {
                        hr = ValidateResult(apSourceBuffers[i]->SetOutputBuffer(NULL));
                    }
                }

                //
                // Loop or not?
                //

                if(SUCCEEDED(hr)) 
                {
                    if(rand() % 2)
                    {
                        dwLoopCount++;
                
                        hr = ValidateResult(apSourceBuffers[i]->Play(0, 0, DSBPLAY_LOOPING));
                    }
                    else
                    {
                        hr = ValidateResult(apSourceBuffers[i]->Play(0, 0, 0));
                    }
                }
            }
            else
            {
                //
                // Still playing?
                //
            
                if(adwStatus[i] & DSBSTATUS_PLAYING)
                {
                    //
                    // Envelope or not?
                    //

                    if(rand() % 2)
                    {
                        dwNoteOffCount++;
                        
                        dseg.dwRelease = dwNoteOffMin + (rand() % (dwNoteOffMax + 1 - dwNoteOffMin));

                        hr = ValidateResult(apSourceBuffers[i]->SetEG(&dseg));

                        if(SUCCEEDED(hr))
                        {
                            hr = ValidateResult(apSourceBuffers[i]->StopEx(0, DSBSTOPEX_ENVELOPE));
                        }
                    }
                    else
                    {
                        dwStopCount++;

                        hr = ValidateResult(apSourceBuffers[i]->Stop());
                    }

                    if(SUCCEEDED(hr))
                    {
                        adwStatus[i] |= DSBSTATUS_PENDINGSTOP;
                    }
                }
                else
                {
                    dwNaturalStopCount++;
                }
            }
        }
    }

    for(i = 0; i < dwSourceCount; i++)
    {
        RELEASE(apSourceBuffers[i]);
    }

    for(i = 0; i < dwStreamCount; i++)
    {
        RELEASE(apStreams[i]);
    }

    RELEASE(pDestBuffer);

    return hr;
}    


/****************************************************************************
 *
 *  FindFrequencyRange
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FindFrequencyRange"

HRESULT
FindFrequencyRange
(
    void
)
{
    LONG                    lPitch;
    DWORD                   i;
    
    for(i = 48000; i > 0; i--)
    {
        if((lPitch = XAudioCalculatePitch(i)) < DSBPITCH_MIN)
        {
            DPF_TEST("Lower %lu (pitch %ld)", i + 1, lPitch);
            break;
        }
    }

    for(i = 48000; ; i++)
    {
        if((lPitch = XAudioCalculatePitch(i)) > DSBPITCH_MAX)
        {
            DPF_TEST("Upper %lu (pitch %ld)", i - 1, lPitch);
            break;
        }
    }

    return DS_OK;
}


/****************************************************************************
 *
 *  TestDeltaPanic
 *
 *  Description:
 *      Main test function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "TestDeltaPanic"

HRESULT
TestDeltaPanic
(
    void
)
{
    LPDIRECTSOUNDBUFFER     pToneBuffer     = NULL;
    HRESULT                 hr;

    hr = CreateToneBuffer(0, 8000, 8, 1, 500, 0, 0, &pToneBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pToneBuffer->SetVolume(-2400);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pToneBuffer, DSBPLAY_LOOPING);
    }
    
    while(SUCCEEDED(hr))
    {

#ifdef DEBUG

        g_fDirectSoundSimulateDeltaPanic = TRUE;

#endif // DEBUG

        hr = PlayOneShotBuffer(0, WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 1, DSMIXBIN_FXSEND_0);
    }

    RELEASE(pToneBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  TestTimeStampedPackets
 *
 *  Description:
 *      Tests stream packets with a timestamp.
 *
 *  Arguments:
 *      DWORD [in]: delay between packets, in milliseconds.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestTimeStampedPackets"

HRESULT
TestTimeStampedPackets
(
    DWORD                   dwDelay
)
{
    static const DWORD      dwPacketCount                   = 2;
    const LPCWAVEFORMATEX   pwfxFormat                      = CreateFormat(WAVE_FORMAT_PCM, 8000, 16, 1);
    const DWORD             dwBufferSize                    = pwfxFormat->nAvgBytesPerSec * 4;
    LPVOID                  pvPacketData                    = NULL;
    LPDIRECTSOUNDSTREAM     pStream                         = NULL;
    DWORD                   adwStatus[dwPacketCount];
    REFERENCE_TIME          rtPacketLength;
    REFERENCE_TIME          artTimeStamps[dwPacketCount];
    DSSTREAMDESC            dssd;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    DWORD                   i;

    ZeroMemory(&dssd, sizeof(dssd));

    dssd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
    dssd.dwMaxAttachedPackets = dwPacketCount;

    hr = ValidateResult(DirectSoundCreateStream(&dssd, &pStream));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvPacketData, BYTE, dwBufferSize);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvPacketData, dwBufferSize, pwfxFormat->nSamplesPerSec, pwfxFormat->wBitsPerSample, pwfxFormat->nChannels, 500);

        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvPacketData;
        xmp.dwMaxSize = dwBufferSize;

        rtPacketLength = ((REFERENCE_TIME)dwBufferSize * 10000000i64) / (REFERENCE_TIME)pwfxFormat->nAvgBytesPerSec;
        rtPacketLength += (REFERENCE_TIME)dwDelay * 10000i64;
        
        for(i = 0; (i < dwPacketCount) && SUCCEEDED(hr); i++)
        {
            artTimeStamps[i] = -(rtPacketLength * i);

            xmp.pdwStatus = &adwStatus[i];
            xmp.prtTimestamp = &artTimeStamps[i];

            hr = ValidateResult(pStream->Process(&xmp, NULL));
        }
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            while(XMEDIAPACKET_STATUS_PENDING == adwStatus[i])
            {
                DirectSoundDoWork();
            }
        }
    }

    RELEASE(pStream);
    FREE(pvPacketData);

    return hr;
}


/****************************************************************************
 *
 *  TestSetFormat
 *
 *  Description:
 *      Sets format on a buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestSetFormat"

HRESULT
TestSetFormat
(
    void
)
{
    static const WAVEFORMATEX           wfxFormat1      = INIT_PCM_WAVEFORMAT(2, 44100, 16);
    static const XBOXADPCMWAVEFORMAT    wfxFormat2      = INIT_XBOX_ADPCM_WAVEFORMAT(1, 22050);
    static const DWORD                  dwDelay         = 2500;
    XFileMediaObject *                  pSrcXmo2        = NULL;
    LPVOID                              pvDataBuffer2   = NULL;
    IDirectSoundBuffer *                pBuffer         = NULL;
    DWORD                               dwLength2;
    HRESULT                             hr;
    
    hr = CreateStdBuffer(0, &wfxFormat1, NULL, NULL, &pBuffer);
    
    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, 0, dwDelay, TRUE, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetBufferData(NULL, 0));
    }
    
    if(SUCCEEDED(hr))
    {
        hr = LoadStdWaveFile(&wfxFormat2.wfx, &pvDataBuffer2, &dwLength2, &pSrcXmo2);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetFormat(&wfxFormat2.wfx));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetBufferData(pvDataBuffer2, dwLength2));
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, 0, dwDelay, TRUE, TRUE);
    }

    RELEASE(pBuffer);        
    RELEASE(pSrcXmo2);
    FREE(pvDataBuffer2);

    return hr;
}


/****************************************************************************
 *
 *  TestStarvation
 *
 *  Description:
 *      Tests starving a stream.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      DWORD [in]: packet size, in bytes.
 *      DWORD [in]: 1-in-N chance the stream will starve between packets.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestStarvation"

HRESULT
TestStarvation
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize,
    DWORD                   dwStarvationChance
)
{
    const LPCWAVEFORMATEX   pwfxFormat      = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDSTREAM     pStream         = NULL;
    LPVOID                  pvAudioData     = NULL;
    DWORD                   dwAudioDataSize = 0;
    DWORD                   dwPacketCount   = 0;
    LPDWORD                 padwStatus      = NULL;
    BOOL                    fStarve;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    hr = CreateStdStream(dwFlags, pwfxFormat, NULL, &dwPacketSize, NULL, NULL, NULL, &pStream, &pvAudioData, &dwAudioDataSize, &dwPacketCount);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padwStatus, DWORD, dwPacketCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvAudioData;
        xmp.dwMaxSize = dwPacketSize;
        xmp.pdwStatus = padwStatus;
    }

    while(SUCCEEDED(hr) && dwPacketCount--)
    {
        if(!dwPacketCount)
        {
            xmp.dwMaxSize = dwAudioDataSize;
        }

        DPF_TEST("Feeding the stream");

        hr = ValidateResult(pStream->Process(&xmp, NULL));

        if(SUCCEEDED(hr))
        {
            fStarve = !(rand() % dwStarvationChance);
            
            if(!dwPacketCount || fStarve)
            {
                if(fStarve)
                {
                    DPF_TEST("Starving the stream");
                }

                while(XMEDIAPACKET_STATUS_PENDING == *xmp.pdwStatus)
                {
                    DirectSoundDoWork();
                }
            }
        }

        xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
        
        xmp.pdwStatus++;

        dwAudioDataSize -= xmp.dwMaxSize;
    }

    RELEASE(pStream);

    FREE(pvAudioData);
    FREE(padwStatus);

    return hr;
}


/****************************************************************************
 *
 *  TestWaveBundler
 *
 *  Description:
 *      Test the Wave Bundler tool.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestWaveBundler"

HRESULT
TestWaveBundler
(
    LPCSTR                  pszBank,
    DWORD                   dwEntryCount
)
{
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    CWaveBankReader         WaveBank;
    DSBUFFERDESC            dsbd;
    WAVEBANKSECTIONDATA     SectionData;
    WAVEBANKUNIWAVEFORMAT   wfx;
    WAVEBANKENTRYREGION     PlayRegion;
    WAVEBANKENTRYREGION     LoopRegion;
    DWORD                   dwSize;
    BOOL                    fMapped;
    HRESULT                 hr;
    DWORD                   i;

    DPF_ENTER();

    DPF_TEST("Opening wave bank %s", pszBank);
    
    hr = ValidateResult(WaveBank.Open(pszBank));

    if(SUCCEEDED(hr))
    {
        WaveBank.GetSectionData(&SectionData);
    }

    if(SUCCEEDED(hr))
    {  
        ASSERT(dwEntryCount == SectionData.pHeader->dwEntryCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = (LPWAVEFORMATEX)CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);

        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    if(SUCCEEDED(hr))
    {
        dwSize = SectionData.dwDataSize;

        hr = ClampBufferSize(&dwSize);
    }

    if(SUCCEEDED(hr))
    {
        if(fMapped = (dwSize == SectionData.dwDataSize))
        {
            hr = ValidateResult(pBuffer->SetBufferData(SectionData.pvData, SectionData.dwDataSize));

            if(SUCCEEDED(hr))
            {
                DPF_TEST("Entire bank mapped.  Using SetPlayRegion");
            }
        }
        else
        {
            DPF_TEST("Bank too big to map.  Using SetBufferData for each element");
        }
    }

    for(i = 0; (i < dwEntryCount) && SUCCEEDED(hr); i++)
    {
        WaveBankExpandFormat(&SectionData.paMetaData[i].Format, &wfx);
        
        PlayRegion = SectionData.paMetaData[i].PlayRegion;
        LoopRegion = SectionData.paMetaData[i].LoopRegion;
        
        DPF_TEST("Loading entry %lu (%s, %lu.%3.3lu kHz, %lu-bit, %lu-channel, offset %lu, length %lu)", i, (WAVE_FORMAT_XBOX_ADPCM == wfx.WaveFormatEx.wFormatTag) ? "ADPCM" : "PCM", wfx.WaveFormatEx.nSamplesPerSec / 1000, wfx.WaveFormatEx.nSamplesPerSec % 1000, wfx.WaveFormatEx.wBitsPerSample, wfx.WaveFormatEx.nChannels, PlayRegion.dwStart, PlayRegion.dwLength);
        
        hr = ValidateResult(pBuffer->SetFormat(&wfx.WaveFormatEx));

        if(SUCCEEDED(hr))
        {
            if(fMapped)
            {
                hr = ValidateResult(pBuffer->SetPlayRegion(PlayRegion.dwStart, PlayRegion.dwLength));
            }
            else
            {
                ClampBufferSize(&PlayRegion.dwLength);
            
                hr = ValidateResult(pBuffer->SetBufferData((LPBYTE)SectionData.pvData + PlayRegion.dwStart, PlayRegion.dwLength));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetLoopRegion(LoopRegion.dwStart, LoopRegion.dwLength));
        }

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(pBuffer, LoopRegion.dwLength ? DSBPLAY_LOOPING : 0);
        }

        if(SUCCEEDED(hr) && LoopRegion.dwLength)
        {
            Sleep(PlayRegion.dwLength * 2 * 1000 / wfx.WaveFormatEx.nAvgBytesPerSec);

            hr = PlayBuffer(pBuffer);
        }

        if(SUCCEEDED(hr))
        {
            hr = WaitBuffer(pBuffer, FALSE);
        }
    }

    RELEASE(pBuffer);

    DPF_LEAVE_HRESULT(hr);
    
    return hr;
}


/****************************************************************************
 *
 *  TestReleasePausedStream
 *
 *  Description:
 *      Tests releasing a paused stream.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestReleasePausedStream"

HRESULT
TestReleasePausedStream
(
    void
)
{
    LPDIRECTSOUNDSTREAM     pStream = NULL;
    DSSTREAMDESC            dssd;
    HRESULT                 hr;
    
    DPF_ENTER();

    ZeroMemory(&dssd, sizeof(dssd));

    dssd.lpwfxFormat = (LPWAVEFORMATEX)CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);
    dssd.dwMaxAttachedPackets = 1;

    hr = DirectSoundCreateStream(&dssd, &pStream);

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pStream->Pause(DSSTREAMPAUSE_PAUSE));
    }

    RELEASE(pStream);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  TestTimedStreamResume
 *
 *  Description:
 *      Tests resuming a paused stream using a timestamp.
 *
 *  Arguments:
 *      DWORD [in]: delay, in ms.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestTimedStreamResume"

HRESULT
TestTimedStreamResume
(
    DWORD                   dwDelay
)
{
    const LPCWAVEFORMATEX   pwfxFormat          = CreateFormat(WAVE_FORMAT_PCM, 48000, 16, 2);
    const REFERENCE_TIME    rtTimestamp         = (REFERENCE_TIME)dwDelay * -10000i64;
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvAudioData         = NULL;
    DWORD                   dwPacketSize        = 0x4000;
    HRESULT                 hr;

    hr = CreateStdQueuedStream(0, pwfxFormat, NULL, &dwPacketSize, NULL, NULL, &pStream, &pvAudioData);

    if(SUCCEEDED(hr))
    {
        DPF_TEST("Setting Pause command for %lu ms in the future", dwDelay);
        
        hr = ValidateResult(pStream->PauseEx(rtTimestamp, DSSTREAMPAUSE_RESUME));
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitStream(pStream, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitStream(pStream, FALSE);
    }

    RELEASE(pStream);
    FREE(pvAudioData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  TestDirectSound
 *
 *  Description:
 *      Main test function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDirectSound"

HRESULT
TestDirectSound
(
    void
)
{
    HRESULT                 hr  = DS_OK;

    /*DirectSoundUsePan3D();*/	// Volt this API is not present in public API

    //
    // Create the DirectSound object
    //

    hr = ValidateResult(DirectSoundCreate(NULL, &g_pDirectSound, NULL));

    //
    // Load the default effects image
    //

    if(SUCCEEDED(hr))
    {
        hr = LoadEffectsImage("dsstdfx", XAUDIO_DOWNLOADFX_XBESECTION);
    }
    
    //
    // Test away...
    //

    // BEGIN_TEST(PlayOneShotBuffer)(0, WAVE_FORMAT_PCM, 48000, 16, 1);
    // BEGIN_TEST(PlayOneShotBuffer)("t:\\media\\audio\\pcm\\48k16bs.aif");
    // BEGIN_TEST(PlayOneShotStream)(0, WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 1, 0x4000);
    // BEGIN_TEST(PlayToneBuffer)(0, 8000, 8, 1, 400, INFINITE);
    // BEGIN_TEST(Test3d)(0.0f, 0.0f, 0.0f, 5.0f, -72.0f, INFINITE);
    // BEGIN_TEST(TestMultipleBuffers)(WAVE_FORMAT_PCM);
    // BEGIN_TEST(TestMultipleStreams)(WAVE_FORMAT_PCM, 0x4000);
    // BEGIN_TEST(TestSequentialBuffers)(WAVE_FORMAT_PCM);
    // BEGIN_TEST(TestNotifies)(WAVE_FORMAT_PCM, 22050, 16, 1, 20, FALSE);
    // BEGIN_TEST(TestBufferOffsets)(WAVE_FORMAT_PCM, 48000, 16, 2, 0.0f, 1.0f, 0.5f, 1.0f, TRUE);
    // BEGIN_TEST(TestSubMix)(TRUE, WAVE_FORMAT_PCM);
    // BEGIN_TEST(TestDLS)(WAVE_FORMAT_PCM, 44100, 16, 1);
    // BEGIN_TEST(TestSurroundEncoder)(WAVE_FORMAT_PCM, 44100, 16);
    // BEGIN_TEST(TestSgeSharing)();
    // BEGIN_TEST(TestSgeHeap)();
    // BEGIN_TEST(Test256Voices)();
    // BEGIN_TEST(TestStop)(WAVE_FORMAT_PCM, 44100, 16, 1);
    // BEGIN_TEST(TestFrequency)(DSBCAPS_CTRL3D, WAVE_FORMAT_PCM, 22050, 16, 1, 5000);
    // BEGIN_TEST(TestDiscontinuity)(0, WAVE_FORMAT_PCM, 22050, 16, 1, 0x4000, TRUE);
    // BEGIN_TEST(TestDeferredCommandRelease)();
    // BEGIN_TEST(TestHeadroom)();
    // BEGIN_TEST(TestI3DL2Listener)();
    // BEGIN_TEST(TestMultiChannel)(44100, 8, 1);
    // BEGIN_TEST(TestMultiChannel2)(6);
    // BEGIN_TEST(TestMultiChannel3)(6);
    // BEGIN_TEST(TestReverb)();
    // BEGIN_TEST(StressPlayStop)(0, -1, 1, 50, INFINITE, 0, 8000);
    // BEGIN_TEST(TestReleaseEnvelope)();
    // BEGIN_TEST(TestNaturalStop)(1);
    // BEGIN_TEST(TestFlush)();
    // BEGIN_TEST(TestPitch)(0, WAVE_FORMAT_PCM, 44100, 16, 1);
    // BEGIN_TEST(FindFrequencyRange)();
    // BEGIN_TEST(TestTimeStampedPackets)(5000);
    // BEGIN_TEST(TestDeltaPanic)();
    // BEGIN_TEST(TestSetFormat)();
    // BEGIN_TEST(TestStarvation)(0, WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 1, 0x4000, 3);
    // BEGIN_TEST(TestStreamStop)(DSSTREAMFLUSHEX_IMMEDIATE, WAVE_FORMAT_PCM, 44100, 16, 2, 0x4000);
    // BEGIN_TEST(TestStreamStop)(DSSTREAMFLUSHEX_ASYNC, WAVE_FORMAT_PCM, 44100, 16, 2, 0x4000);
    // BEGIN_TEST(TestStreamStop)(DSSTREAMFLUSHEX_ASYNC | DSSTREAMFLUSHEX_ENVELOPE, WAVE_FORMAT_PCM, 44100, 16, 2, 0x4000);
    // BEGIN_TEST(TestReleasePausedStream)();
    BEGIN_TEST(TestTimedStreamResume)(10000);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\pcm.xwb", WAVEBANK_PCM_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\pcmaiff.xwb", WAVEBANK_PCMAIFF_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\adpcm.xwb", WAVEBANK_ADPCM_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\compress.xwb", WAVEBANK_COMPRESS_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\8bit.xwb", WAVEBANK_8BIT_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\loop.xwb", WAVEBANK_LOOP_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\mixed.xwb", WAVEBANK_MIXED_ENTRY_COUNT);

    //
    // Release the DirectSound object
    //

    RELEASE(g_pDirectSound);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\sdk\inc\guiddef.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001. All rights reserved.
//
//  File:       guiddef.h
//
//  Contents:   GUID definition
//
//----------------------------------------------------------------------------

#ifndef GUID_DEFINED
#define GUID_DEFINED
#ifdef __midl
typedef struct {
#else
typedef struct _GUID {
#endif
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#endif

#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif
#endif

#ifdef DEFINE_GUID
#undef DEFINE_GUID
#endif

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#endif // INITGUID

#define DEFINE_OLEGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifndef _GUIDDEF_H_
#define _GUIDDEF_H_

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef GUID IID;
typedef IID *LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
typedef GUID CLSID;
typedef CLSID *LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)
typedef GUID FMTID;
typedef FMTID *LPFMTID;
#define FMTID_NULL          GUID_NULL
#define IsEqualFMTID(rfmtid1, rfmtid2) IsEqualGUID(rfmtid1, rfmtid2)

#ifdef __midl_proxy
#define __MIDL_CONST
#else
#define __MIDL_CONST const
#endif

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#ifdef __cplusplus
#define REFGUID const GUID &
#else
#define REFGUID const GUID * __MIDL_CONST
#endif
#endif

#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#ifdef __cplusplus
#define REFIID const IID &
#else
#define REFIID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#ifdef __cplusplus
#define REFCLSID const IID &
#else
#define REFCLSID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFFMTID_DEFINED
#define _REFFMTID_DEFINED
#ifdef __cplusplus
#define REFFMTID const IID &
#else
#define REFFMTID const IID * __MIDL_CONST
#endif
#endif

#endif // !__IID_DEFINED__

#if !defined (__midl)
#if !defined (_SYS_GUID_OPERATORS_)
#define _SYS_GUID_OPERATORS_
#include <string.h>

// Faster (but makes code fatter) inline version...use sparingly
#ifdef __cplusplus
__inline int InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}

#else   // ! __cplusplus

#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((unsigned long *) rguid1)[0] == ((unsigned long *) rguid2)[0] &&   \
        ((unsigned long *) rguid1)[1] == ((unsigned long *) rguid2)[1] &&    \
        ((unsigned long *) rguid1)[2] == ((unsigned long *) rguid2)[2] &&    \
        ((unsigned long *) rguid1)[3] == ((unsigned long *) rguid2)[3])

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

#endif  // __cplusplus

#ifdef __INLINE_ISEQUAL_GUID
#undef IsEqualGUID
#define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
#endif

// Same type, different name

#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if !defined _SYS_GUID_OPERATOR_EQ_ && !defined _NO_SYS_GUID_OPERATOR_EQ_
#define _SYS_GUID_OPERATOR_EQ_
// A couple of C++ helpers

#ifdef __cplusplus
__inline int operator==(REFGUID guidOne, REFGUID guidOther)
{
    return IsEqualGUID(guidOne,guidOther);
}

__inline int operator!=(REFGUID guidOne, REFGUID guidOther)
{
    return !(guidOne == guidOther);
}
#endif
#endif  // _SYS_GUID_OPERATOR_EQ_
#endif  // _SYS_GUID_OPERATORS_
#endif  // __midl
#endif  // _GUIDDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\BaseTsd.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    basetsd.h

Abstract:

    Type definitions for the basic sized types.

Author:

    Jeff Havens (jhavens)   23-Oct-1997

Revision History:

--*/

#ifndef _BASETSD_H_
#define _BASETSD_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// The following types are guaranteed to be signed and 32 bits wide.
//

typedef int LONG32, *PLONG32;
typedef int INT32, *PINT32;

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
typedef unsigned int UINT32, *PUINT32;

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
#if ( 501 < __midl )

    typedef [public] __int3264 INT_PTR, *PINT_PTR;
    typedef [public] unsigned __int3264 UINT_PTR, *PUINT_PTR;

    typedef [public] __int3264 LONG_PTR, *PLONG_PTR;
    typedef [public] unsigned __int3264 ULONG_PTR, *PULONG_PTR;

#else  // midl64
// old midl and C++ compiler

#if defined(_WIN64)
    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int64

#else
    typedef _W64 int INT_PTR, *PINT_PTR;
    typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

    typedef _W64 long LONG_PTR, *PLONG_PTR;
    typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int32

#endif
#endif // midl64

//
// HALF_PTR is half the size of a pointer it intended for use with
// within strcuture which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//

#ifdef _WIN64

#define ADDRESS_TAG_BIT 0x40000000000UI64

typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;

#pragma warning(disable:4311)   // type cast truncation
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4305)   // type cast truncation

#if !defined(__midl)
__inline
unsigned long
HandleToUlong(
    const void *h
    )
{
    return((unsigned long) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) h );
}

__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void  *p
    )
{
    return((unsigned long) p );
}

__inline
unsigned int
PtrToUint(
    const void  *p
    )
{
    return((unsigned int) p );
}

__inline
unsigned short
PtrToUshort(
    const void  *p
    )
{
    return((unsigned short) p );
}

__inline
long
PtrToLong(
    const void  *p
    )
{
    return((long) p );
}

__inline
int
PtrToInt(
    const void  *p
    )
{
    return((int) p );
}

__inline
short
PtrToShort(
    const void  *p
    )
{
    return((short) p );
}

__inline
void *
IntToPtr(
    const int i
    )
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}

#endif // !_midl
#if _MSC_VER >= 1200
#pragma warning(pop)      // restore 4305
#endif
#pragma warning(3:4311)   // bump 4311 to a level 3

#else  // !_WIN64

#define ADDRESS_TAG_BIT 0x80000000UL

typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef _W64 unsigned long HANDLE_PTR;

#define HandleToUlong( h ) ((ULONG)(ULONG_PTR)(h) )
#define HandleToLong( h ) ((LONG)(LONG_PTR) (h) )
#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
#define PtrToLong( p ) ((LONG)(LONG_PTR) (p) )
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
#define PtrToInt( p ) ((INT)(INT_PTR) (p) )
#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
#define PtrToShort( p ) ((short)(LONG_PTR)(p) )
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
#define ULongToPtr( ul )  ((VOID *)(ULONG_PTR)((unsigned long)ul))

#endif // !_WIN64

#define UlongToPtr(ul) ULongToPtr(ul)
#define UintToPtr(ui) UIntToPtr(ui)

#define MAXUINT_PTR  (~((UINT_PTR)0))
#define MAXINT_PTR   ((INT_PTR)(MAXUINT_PTR >> 1))
#define MININT_PTR   (~MAXINT_PTR)

#define MAXULONG_PTR (~((ULONG_PTR)0))
#define MAXLONG_PTR  ((LONG_PTR)(MAXULONG_PTR >> 1))
#define MINLONG_PTR  (~MAXLONG_PTR)

#define MAXUHALF_PTR ((UHALF_PTR)~0)
#define MAXHALF_PTR  ((HALF_PTR)(MAXUHALF_PTR >> 1))
#define MINHALF_PTR  (~MAXHALF_PTR)

//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;

//
// Add Windows flavor DWORD_PTR types
//

typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

//
// The following types are guaranteed to be signed and 64 bits wide.
//

typedef __int64 LONG64, *PLONG64;
typedef __int64 INT64,  *PINT64;


//
// The following types are guaranteed to be unsigned and 64 bits wide.
//

typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;
typedef unsigned __int64 UINT64,  *PUINT64;

#ifdef __cplusplus
}
#endif

#endif // _BASETSD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\ConIo.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif  //_WCONIO_DEFINED

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\CType.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */




/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (_pctype[a] & (b))
#endif



#ifndef _MT
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */


#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( _pctype[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */



/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3D8Caps.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8caps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8CAPS_H
#define _D3D8CAPS_H

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

#pragma pack(4)

typedef struct _D3DCAPS8
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT    AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture8's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture8's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture8's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture8's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture8's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth, MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   MaxPixelShaderValue;        // max value of pixel shader arithmetic component

} D3DCAPS8;

//
// BIT DEFINES FOR D3DCAPS8 DWORD MEMBERS
//

//
// Caps
//
#define D3DCAPS_READ_SCANLINE           0x00020000L

//
// Caps2
//
#define D3DCAPS2_NO2DDURING3DSCENE      0x00000002L
#define D3DCAPS2_FULLSCREENGAMMA        0x00020000L
#define D3DCAPS2_CANRENDERWINDOWED      0x00080000L
#define D3DCAPS2_CANCALIBRATEGAMMA      0x00100000L
#define D3DCAPS2_RESERVED               0x02000000L

//
// Caps3
//
#define D3DCAPS3_RESERVED               0x8000001fL

//
// PresentationIntervals
//
#define D3DPRESENT_INTERVAL_DEFAULT             0x00000000L
#define D3DPRESENT_INTERVAL_ONE                 0x00000001L
#define D3DPRESENT_INTERVAL_TWO                 0x00000002L
#define D3DPRESENT_INTERVAL_THREE               0x00000004L
#define D3DPRESENT_INTERVAL_FOUR                0x00000008L
#define D3DPRESENT_INTERVAL_IMMEDIATE           0x80000000L
#define D3DPRESENT_INTERVAL_ONE_OR_IMMEDIATE    0x80000001L
#define D3DPRESENT_INTERVAL_TWO_OR_IMMEDIATE    0x80000002L

//
// CursorCaps
//
// Driver supports HW color cursor in at least hi-res modes(height >=400)
#define D3DCURSORCAPS_COLOR             0x00000001L
// Driver supports HW cursor also in low-res modes(height < 400)
#define D3DCURSORCAPS_LOWRES            0x00000002L

//
// DevCaps
//
#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#define D3DDEVCAPS_DRAWPRIMITIVES2      0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX    0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT  0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL  0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION      0x00080000L /* Device has HW acceleration for rasterization */
#define D3DDEVCAPS_PUREDEVICE           0x00100000L /* Device supports D3DCREATE_PUREDEVICE */
#define D3DDEVCAPS_QUINTICRTPATCHES     0x00200000L /* Device supports quintic Beziers and BSplines */
#define D3DDEVCAPS_RTPATCHES            0x00400000L /* Device supports Rect and Tri patches */
#define D3DDEVCAPS_RTPATCHHANDLEZERO    0x00800000L /* Indicates that RT Patches may be drawn efficiently using handle 0 */
#define D3DDEVCAPS_NPATCHES             0x01000000L /* Device supports N-Patches */

//
// PrimitiveMiscCaps
//
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L
#define D3DPMISCCAPS_COLORWRITEENABLE   0x00000080L
#define D3DPMISCCAPS_CLIPPLANESCALEDPOINTS 0x00000100L /* Device correctly clips scaled points to clip planes */
#define D3DPMISCCAPS_CLIPTLVERTS        0x00000200L /* device will clip post-transformed vertex primitives */
#define D3DPMISCCAPS_TSSARGTEMP         0x00000400L /* device supports D3DTA_TEMP for temporary register */
#define D3DPMISCCAPS_BLENDOP            0x00000800L /* device supports D3DRS_BLENDOP */

//
// LineCaps
//
#define D3DLINECAPS_TEXTURE             0x00000001L
#define D3DLINECAPS_ZTEST               0x00000002L
#define D3DLINECAPS_BLEND               0x00000004L
#define D3DLINECAPS_ALPHACMP            0x00000008L
#define D3DLINECAPS_FOG                 0x00000010L

//
// RasterCaps
//
#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_ROP2             0x00000002L
#define D3DPRASTERCAPS_XOR              0x00000004L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_ANTIALIASEDGES   0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS    0x00002000L
#define D3DPRASTERCAPS_ZBIAS            0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR   0x00008000L
#define D3DPRASTERCAPS_FOGRANGE         0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY       0x00020000L
#define D3DPRASTERCAPS_WBUFFER          0x00040000L
#define D3DPRASTERCAPS_WFOG             0x00100000L
#define D3DPRASTERCAPS_ZFOG             0x00200000L
#define D3DPRASTERCAPS_COLORPERSPECTIVE 0x00400000L /* Device iterates colors perspective correct */
#define D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  0x00800000L

//
// ZCmpCaps, AlphaCmpCaps
//
#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

//
// SourceBlendCaps, DestBlendCaps
//
#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

//
// ShadeCaps
//
#define D3DPSHADECAPS_COLORGOURAUDRGB       0x00000008L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB    0x00000200L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND     0x00004000L
#define D3DPSHADECAPS_FOGGOURAUD            0x00080000L

//
// TextureCaps
//
#define D3DPTEXTURECAPS_PERSPECTIVE         0x00000001L /* Perspective-correct texturing is supported */
#define D3DPTEXTURECAPS_POW2                0x00000002L /* Power-of-2 texture dimensions are required - applies to non-Cube/Volume textures only. */
#define D3DPTEXTURECAPS_ALPHA               0x00000004L /* Alpha in texture pixels is supported */
#define D3DPTEXTURECAPS_SQUAREONLY          0x00000020L /* Only square textures are supported */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L /* Texture indices are not scaled by the texture size prior to interpolation */
#define D3DPTEXTURECAPS_ALPHAPALETTE        0x00000080L /* Device can draw alpha from texture palettes */
// Device can use non-POW2 textures if:
//  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
//  2) D3DRS_WRAP(N) is zero for this texture's coordinates
//  3) mip mapping is not enabled (use magnification filter only)
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L
#define D3DPTEXTURECAPS_PROJECTED           0x00000400L /* Device can do D3DTTFF_PROJECTED */
#define D3DPTEXTURECAPS_CUBEMAP             0x00000800L /* Device can do cubemap textures */
#define D3DPTEXTURECAPS_VOLUMEMAP           0x00002000L /* Device can do volume textures */
#define D3DPTEXTURECAPS_MIPMAP              0x00004000L /* Device can do mipmapped textures */
#define D3DPTEXTURECAPS_MIPVOLUMEMAP        0x00008000L /* Device can do mipmapped volume textures */
#define D3DPTEXTURECAPS_MIPCUBEMAP          0x00010000L /* Device can do mipmapped cube maps */
#define D3DPTEXTURECAPS_CUBEMAP_POW2        0x00020000L /* Device requires that cubemaps be power-of-2 dimension */
#define D3DPTEXTURECAPS_VOLUMEMAP_POW2      0x00040000L /* Device requires that volume maps be power-of-2 dimension */

//
// TextureFilterCaps
//
#define D3DPTFILTERCAPS_MINFPOINT           0x00000100L /* Min Filter */
#define D3DPTFILTERCAPS_MINFLINEAR          0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC     0x00000400L
#define D3DPTFILTERCAPS_MIPFPOINT           0x00010000L /* Mip Filter */
#define D3DPTFILTERCAPS_MIPFLINEAR          0x00020000L
#define D3DPTFILTERCAPS_MAGFPOINT           0x01000000L /* Mag Filter */
#define D3DPTFILTERCAPS_MAGFLINEAR          0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC     0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC      0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC   0x10000000L

//
// TextureAddressCaps
//
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#define D3DPTADDRESSCAPS_MIRRORONCE     0x00000020L

//
// StencilCaps
//
#define D3DSTENCILCAPS_KEEP             0x00000001L
#define D3DSTENCILCAPS_ZERO             0x00000002L
#define D3DSTENCILCAPS_REPLACE          0x00000004L
#define D3DSTENCILCAPS_INCRSAT          0x00000008L
#define D3DSTENCILCAPS_DECRSAT          0x00000010L
#define D3DSTENCILCAPS_INVERT           0x00000020L
#define D3DSTENCILCAPS_INCR             0x00000040L
#define D3DSTENCILCAPS_DECR             0x00000080L

//
// TextureOpCaps
//
#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L
#define D3DTEXOPCAPS_MULTIPLYADD                0x01000000L
#define D3DTEXOPCAPS_LERP                       0x02000000L

//
// FVFCaps
//
#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */
#define D3DFVFCAPS_PSIZE                0x00100000L /* Device can receive point size */

//
// VertexProcessingCaps
//
#define D3DVTXPCAPS_TEXGEN              0x00000001L /* device can do texgen */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L /* device can do DX7-level colormaterialsource ops */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L /* device can do directional lights */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L /* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L /* device can do local viewer */
#define D3DVTXPCAPS_TWEENING            0x00000040L /* device can do vertex tweening */
#define D3DVTXPCAPS_NO_VSDT_UBYTE4      0x00000080L /* device does not support D3DVSDT_UBYTE4 */

#pragma pack()

#endif /* _D3D8CAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3DX8.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8_H__
#define __D3DX8_H__

#include <d3d8.h>
#include <limits.h>

#include <xobjbase.h>

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#define D3DX_DEFAULT ULONG_MAX
#define D3DX_DEFAULT_FLOAT FLT_MAX

#include "d3dx8math.h"
#include "d3dx8core.h"
#include "d3dx8tex.h"
#include "d3dx8mesh.h"
#include "d3dx8shape.h"
#include "d3dx8effect.h"


#endif //__D3DX8_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\CrtDbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
void * __cdecl operator new[](size_t);

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#if     _MSC_VER >= 1200


void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
void * __cdecl operator new[](size_t);

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200
void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\CGuid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       cguid.h
//
//--------------------------------------------------------------------------

#ifndef __CGUID_H__
#define __CGUID_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern const IID GUID_NULL;
extern const IID IID_IRpcChannel;
extern const IID IID_IRpcStub;
extern const IID IID_IStubManager;
extern const IID IID_IRpcProxy;
extern const IID IID_IProxyManager;
extern const IID IID_IPSFactory;
extern const IID IID_IInternalMoniker;
extern const IID IID_IDfReserved1;
extern const IID IID_IDfReserved2;
extern const IID IID_IDfReserved3;
extern const CLSID CLSID_StdMarshal;
extern const CLSID CLSID_AggStdMarshal;
extern const CLSID CLSID_StdAsyncActManager;
extern const IID IID_IStub;
extern const IID IID_IProxy;
extern const IID IID_IEnumGeneric;
extern const IID IID_IEnumHolder;
extern const IID IID_IEnumCallback;
extern const IID IID_IOleManager;
extern const IID IID_IOlePresObj;
extern const IID IID_IDebug;
extern const IID IID_IDebugStream;
extern const CLSID CLSID_PSGenObject;
extern const CLSID CLSID_PSClientSite;
extern const CLSID CLSID_PSClassObject;
extern const CLSID CLSID_PSInPlaceActive;
extern const CLSID CLSID_PSInPlaceFrame;
extern const CLSID CLSID_PSDragDrop;
extern const CLSID CLSID_PSBindCtx;
extern const CLSID CLSID_PSEnumerators;
extern const CLSID CLSID_StaticMetafile;
extern const CLSID CLSID_StaticDib;
extern const CLSID CID_CDfsVolume;
extern const CLSID CLSID_DCOMAccessControl;
extern const CLSID CLSID_StdGlobalInterfaceTable;
extern const CLSID CLSID_ComBinding;
extern const CLSID CLSID_StdEvent;
extern const CLSID CLSID_ManualResetEvent;
extern const CLSID CLSID_SynchronizeContainer;

//********************************************
//
// CD Forms CLSIDs
//
//********************************************

//
// Form Kernel objects
//
extern const CLSID CLSID_CCDFormKrnl;
extern const CLSID CLSID_CCDPropertyPage;
extern const CLSID CLSID_CCDFormDialog;

//
// Control objects
//
extern const CLSID CLSID_CCDCommandButton;
extern const CLSID CLSID_CCDComboBox;
extern const CLSID CLSID_CCDTextBox;
extern const CLSID CLSID_CCDCheckBox;
extern const CLSID CLSID_CCDLabel;
extern const CLSID CLSID_CCDOptionButton;
extern const CLSID CLSID_CCDListBox;
extern const CLSID CLSID_CCDScrollBar;
extern const CLSID CLSID_CCDGroupBox;

//
// Property Pages
//
extern const CLSID CLSID_CCDGeneralPropertyPage;
extern const CLSID CLSID_CCDGenericPropertyPage;
extern const CLSID CLSID_CCDFontPropertyPage;
extern const CLSID CLSID_CCDColorPropertyPage;
extern const CLSID CLSID_CCDLabelPropertyPage;
extern const CLSID CLSID_CCDCheckBoxPropertyPage;
extern const CLSID CLSID_CCDTextBoxPropertyPage;
extern const CLSID CLSID_CCDOptionButtonPropertyPage;
extern const CLSID CLSID_CCDListBoxPropertyPage;
extern const CLSID CLSID_CCDCommandButtonPropertyPage;
extern const CLSID CLSID_CCDComboBoxPropertyPage;
extern const CLSID CLSID_CCDScrollBarPropertyPage;
extern const CLSID CLSID_CCDGroupBoxPropertyPage;
extern const CLSID CLSID_CCDXObjectPropertyPage;

extern const CLSID CLSID_CStdPropertyFrame;

extern const CLSID CLSID_CFormPropertyPage;
extern const CLSID CLSID_CGridPropertyPage;

extern const CLSID CLSID_CWSJArticlePage;
extern const CLSID CLSID_CSystemPage;

extern const CLSID CLSID_IdentityUnmarshal;
extern const CLSID CLSID_InProcFreeMarshaler;

extern const CLSID CLSID_Picture_Metafile;
extern const CLSID CLSID_Picture_EnhMetafile;
extern const CLSID CLSID_Picture_Dib;

//
// Enumerations
//
extern const GUID GUID_TRISTATE;

#ifdef __cplusplus
}
#endif


#endif // __CGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3D8Types.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8types.h
 *  Content:    Xbox Direct3D types include file
 *
 ***************************************************************************/

#ifndef _D3D8TYPES_H_
#define _D3D8TYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#include <float.h>

#pragma warning(disable:4201) // anonymous unions warning
#pragma pack(4)

// D3DCOLOR is equivalent to D3DFMT_A8R8G8B8
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

// maps unsigned 8 bits/channel to D3DCOLOR
#define D3DCOLOR_ARGB(a,r,g,b) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)
#define D3DCOLOR_XRGB(r,g,b)   D3DCOLOR_ARGB(0xff,r,g,b)

// maps floating point channels (0.f to 1.f range) to D3DCOLOR
#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif
typedef struct _D3DVECTOR *LPD3DVECTOR;

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;
#define D3DRECT_DEFINED
#endif

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif

typedef struct _D3DVIEWPORT8 {
    DWORD       X;
    DWORD       Y;            /* Viewport Top left */
    DWORD       Width;
    DWORD       Height;       /* Viewport Dimensions */
    float       MinZ;         /* Min/max of clip Volume */
    float       MaxZ;
} D3DVIEWPORT8;

typedef struct _D3DMATERIAL8 {
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    float           Power;          /* Sharpness if specular highlight */
} D3DMATERIAL8;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

typedef struct _D3DLIGHT8 {
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    float           Range;            /* Cutoff range */
    float           Falloff;          /* Falloff */
    float           Attenuation0;     /* Constant attenuation */
    float           Attenuation1;     /* Linear attenuation */
    float           Attenuation2;     /* Quadratic attenuation */
    float           Theta;            /* Inner angle of spotlight cone */
    float           Phi;              /* Outer angle of spotlight cone */
} D3DLIGHT8;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x000000f0l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000001l  /* Clear target z buffer */
#define D3DCLEAR_STENCIL           0x00000002l  /* Clear stencil planes */

// The following are Xbox extensions
#define D3DCLEAR_TARGET_R          0x00000010l  /* Clear target surface R component */
#define D3DCLEAR_TARGET_G          0x00000020l  /* Clear target surface G component */
#define D3DCLEAR_TARGET_B          0x00000040l  /* Clear target surface B component */
#define D3DCLEAR_TARGET_A          0x00000080l  /* Clear target surface A component */

// The driver uses these values as the maximum value for Z in the z-buffer.

#define D3DZ_MAX_D16         65535.0
#define D3DZ_MAX_D24S8       16777215.0
#define D3DZ_MAX_F16         511.9375   

// We can't use the whole available range for the 24-bit floating point z
// because the maximum value is very, very close to the IEEE single 
// precision maximum.  Any calculation using the value will cause an overflow.
//
// Back off a bit from the max (3.4028e38),
//
#define D3DZ_MAX_F24S8       1.0e30

/*
 * The following defines the rendering states
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT               = 0x1d00,
    D3DSHADE_GOURAUD            = 0x1d01,
    D3DSHADE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;


typedef enum _D3DFILLMODE {
    D3DFILL_POINT               = 0x1b00,
    D3DFILL_WIREFRAME           = 0x1b01,
    D3DFILL_SOLID               = 0x1b02,
    D3DFILL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO               = 0,
    D3DBLEND_ONE                = 1,
    D3DBLEND_SRCCOLOR           = 0x300,
    D3DBLEND_INVSRCCOLOR        = 0x301,
    D3DBLEND_SRCALPHA           = 0x302,
    D3DBLEND_INVSRCALPHA        = 0x303,
    D3DBLEND_DESTALPHA          = 0x304,
    D3DBLEND_INVDESTALPHA       = 0x305,
    D3DBLEND_DESTCOLOR          = 0x306,
    D3DBLEND_INVDESTCOLOR       = 0x307,
    D3DBLEND_SRCALPHASAT        = 0x308,
    D3DBLEND_CONSTANTCOLOR      = 0x8001,
    D3DBLEND_INVCONSTANTCOLOR   = 0x8002,
    D3DBLEND_CONSTANTALPHA      = 0x8003,
    D3DBLEND_INVCONSTANTALPHA   = 0x8004,

    // D3DBLEND_BOTHSRCALPHA not supported on Xbox
    // D3DBLEND_BOTHINVSRCALPHA not supported on Xbox

    D3DBLEND_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum _D3DBLENDOP {
    D3DBLENDOP_ADD              = 0x8006,
    D3DBLENDOP_SUBTRACT         = 0x800a,
    D3DBLENDOP_REVSUBTRACT      = 0x800b,
    D3DBLENDOP_MIN              = 0x8007,
    D3DBLENDOP_MAX              = 0x8008,
    D3DBLENDOP_ADDSIGNED        = 0xf006,       // Xbox extension
    D3DBLENDOP_REVSUBTRACTSIGNED= 0xf005,       // Xbox extension
    D3DBLENDOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DBLENDOP;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP            = 1,
    D3DTADDRESS_MIRROR          = 2,
    D3DTADDRESS_CLAMP           = 3,
    D3DTADDRESS_BORDER          = 4,
    D3DTADDRESS_CLAMPTOEDGE     = 5, // Xbox extension

    // D3DTADDRESS_MIRRORONCE not supported on Xbox

    D3DTADDRESS_MAX             = 6,
    D3DTADDRESS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum _D3DTEXTURECOLORKEYOP {            // Xbox extension
    D3DTCOLORKEYOP_DISABLE      = 0,
    D3DTCOLORKEYOP_ALPHA        = 1,
    D3DTCOLORKEYOP_RGBA         = 2,
    D3DTCOLORKEYOP_KILL         = 3,

    D3DTCOLORKEYOP_MAX          = 4,
    D3DTCOLORKEYOP_FORCE_DWORD  = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURECOLORKEYOP;

typedef enum _D3DTEXTUREALPHAKILL {             // Xbox extension
    D3DTALPHAKILL_DISABLE       = 0,
    D3DTALPHAKILL_ENABLE        = 4,

    D3DTALPHAKILL_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREALPHAKILL;

typedef enum _D3DCULL {
    D3DCULL_NONE                = 0,
    D3DCULL_CW                  = 0x900,
    D3DCULL_CCW                 = 0x901,
    D3DCULL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum _D3DFRONT {                        // Xbox extension
    D3DFRONT_CW                 = 0x900,
    D3DFRONT_CCW                = 0x901,
    D3DFRONT_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DFRONT;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER                = 0x200,
    D3DCMP_LESS                 = 0x201,
    D3DCMP_EQUAL                = 0x202,
    D3DCMP_LESSEQUAL            = 0x203,
    D3DCMP_GREATER              = 0x204,
    D3DCMP_NOTEQUAL             = 0x205,
    D3DCMP_GREATEREQUAL         = 0x206,
    D3DCMP_ALWAYS               = 0x207,
    D3DCMP_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 0x1e00,
    D3DSTENCILOP_ZERO           = 0,
    D3DSTENCILOP_REPLACE        = 0x1e01,
    D3DSTENCILOP_INCRSAT        = 0x1e02,
    D3DSTENCILOP_DECRSAT        = 0x1e03,
    D3DSTENCILOP_INVERT         = 0x150a,
    D3DSTENCILOP_INCR           = 0x8507,
    D3DSTENCILOP_DECR           = 0x8508,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                 = 0,
    D3DFOG_EXP                  = 1,
    D3DFOG_EXP2                 = 2,
    D3DFOG_LINEAR               = 3,
    D3DFOG_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum _D3DSWATHWIDTH {                   // Xbox extension
    D3DSWATH_8                  = 0,
    D3DSWATH_16                 = 1,
    D3DSWATH_32                 = 2,
    D3DSWATH_64                 = 3,
    D3DSWATH_128                = 4,
    D3DSWATH_OFF                = 0xf,
    D3DSWATH_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSWATHWIDTH;

typedef enum _D3DPALETTESIZE {                  // Xbox extension
    D3DPALETTE_256              = 0,
    D3DPALETTE_128              = 1,
    D3DPALETTE_64               = 2,
    D3DPALETTE_32               = 3,

    D3DPALETTE_MAX              = 4,
    D3DPALETTE_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DPALETTESIZE;

typedef DWORD D3DSHADERCONSTANTMODE;            // Xbox extension

#define D3DSCM_96CONSTANTS                  0
#define D3DSCM_192CONSTANTS                 1
#define D3DSCM_192CONSTANTSANDFIXEDPIPELINE 2
#define D3DSCM_NORESERVEDCONSTANTS          0x10    // Flag

typedef enum _D3DLOGICOP {                      // Xbox extension
    D3DLOGICOP_NONE             = 0,
    D3DLOGICOP_CLEAR            = 0x1500,
    D3DLOGICOP_AND              = 0x1501,
    D3DLOGICOP_AND_REVERSE      = 0x1502,
    D3DLOGICOP_COPY             = 0x1503,
    D3DLOGICOP_AND_INVERTED     = 0x1504,
    D3DLOGICOP_NOOP             = 0x1505,
    D3DLOGICOP_XOR              = 0x1506,
    D3DLOGICOP_OR               = 0x1507,
    D3DLOGICOP_NOR              = 0x1508,
    D3DLOGICOP_EQUIV            = 0x1509,
    D3DLOGICOP_INVERT           = 0x150a,
    D3DLOGICOP_OR_REVERSE       = 0x150b,
    D3DLOGICOP_COPY_INVERTED    = 0x150c,
    D3DLOGICOP_OR_INVERTED      = 0x150d,
    D3DLOGICOP_NAND             = 0x150e,
    D3DLOGICOP_SET              = 0x150f,
    D3DLOGICOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DLOGICOP;

typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINELOOP              = 3,  // Xbox extension
    D3DPT_LINESTRIP             = 4,
    D3DPT_TRIANGLELIST          = 5,
    D3DPT_TRIANGLESTRIP         = 6,
    D3DPT_TRIANGLEFAN           = 7,
    D3DPT_QUADLIST              = 8,  // Xbox extension
    D3DPT_QUADSTRIP             = 9,  // Xbox extension
    D3DPT_POLYGON               = 10, // Xbox extension

    D3DPT_MAX                   = 11,
    D3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW          = 0,
    D3DTS_PROJECTION    = 1,
    D3DTS_TEXTURE0      = 2,
    D3DTS_TEXTURE1      = 3,
    D3DTS_TEXTURE2      = 4,
    D3DTS_TEXTURE3      = 5,
    D3DTS_WORLD         = 6,
    D3DTS_WORLD1        = 7,
    D3DTS_WORLD2        = 8,
    D3DTS_WORLD3        = 9,

    D3DTS_MAX           = 10,
    D3DTS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

#define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + D3DTS_WORLD)

typedef enum _D3DRENDERSTATETYPE {

    // Simple render states that are processed by D3D immediately:

    D3DRS_PS_MIN                        = 0,

    // The following pixel-shader renderstates are all Xbox extensions:

    D3DRS_PSALPHAINPUTS0                = 0,   // Pixel shader, Stage 0 alpha inputs                         
    D3DRS_PSALPHAINPUTS1                = 1,   // Pixel shader, Stage 1 alpha inputs                         
    D3DRS_PSALPHAINPUTS2                = 2,   // Pixel shader, Stage 2 alpha inputs                         
    D3DRS_PSALPHAINPUTS3                = 3,   // Pixel shader, Stage 3 alpha inputs                         
    D3DRS_PSALPHAINPUTS4                = 4,   // Pixel shader, Stage 4 alpha inputs                         
    D3DRS_PSALPHAINPUTS5                = 5,   // Pixel shader, Stage 5 alpha inputs                         
    D3DRS_PSALPHAINPUTS6                = 6,   // Pixel shader, Stage 6 alpha inputs                         
    D3DRS_PSALPHAINPUTS7                = 7,   // Pixel shader, Stage 7 alpha inputs                         
    D3DRS_PSFINALCOMBINERINPUTSABCD     = 8,   // Pixel shader, Final combiner inputs ABCD
    D3DRS_PSFINALCOMBINERINPUTSEFG      = 9,   // Pixel shader, Final combiner inputs EFG
    D3DRS_PSCONSTANT0_0                 = 10,  // Pixel shader, C0 in stage 0
    D3DRS_PSCONSTANT0_1                 = 11,  // Pixel shader, C0 in stage 1
    D3DRS_PSCONSTANT0_2                 = 12,  // Pixel shader, C0 in stage 2
    D3DRS_PSCONSTANT0_3                 = 13,  // Pixel shader, C0 in stage 3
    D3DRS_PSCONSTANT0_4                 = 14,  // Pixel shader, C0 in stage 4
    D3DRS_PSCONSTANT0_5                 = 15,  // Pixel shader, C0 in stage 5
    D3DRS_PSCONSTANT0_6                 = 16,  // Pixel shader, C0 in stage 6
    D3DRS_PSCONSTANT0_7                 = 17,  // Pixel shader, C0 in stage 7
    D3DRS_PSCONSTANT1_0                 = 18,  // Pixel shader, C1 in stage 0
    D3DRS_PSCONSTANT1_1                 = 19,  // Pixel shader, C1 in stage 1
    D3DRS_PSCONSTANT1_2                 = 20,  // Pixel shader, C1 in stage 2
    D3DRS_PSCONSTANT1_3                 = 21,  // Pixel shader, C1 in stage 3
    D3DRS_PSCONSTANT1_4                 = 22,  // Pixel shader, C1 in stage 4
    D3DRS_PSCONSTANT1_5                 = 23,  // Pixel shader, C1 in stage 5
    D3DRS_PSCONSTANT1_6                 = 24,  // Pixel shader, C1 in stage 6
    D3DRS_PSCONSTANT1_7                 = 25,  // Pixel shader, C1 in stage 7
    D3DRS_PSALPHAOUTPUTS0               = 26,  // Pixel shader, Stage 0 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS1               = 27,  // Pixel shader, Stage 1 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS2               = 28,  // Pixel shader, Stage 2 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS3               = 29,  // Pixel shader, Stage 3 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS4               = 30,  // Pixel shader, Stage 4 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS5               = 31,  // Pixel shader, Stage 5 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS6               = 32,  // Pixel shader, Stage 6 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS7               = 33,  // Pixel shader, Stage 7 alpha outputs                        
    D3DRS_PSRGBINPUTS0                  = 34,  // Pixel shader, Stage 0 RGB inputs                           
    D3DRS_PSRGBINPUTS1                  = 35,  // Pixel shader, Stage 1 RGB inputs                           
    D3DRS_PSRGBINPUTS2                  = 36,  // Pixel shader, Stage 2 RGB inputs                           
    D3DRS_PSRGBINPUTS3                  = 37,  // Pixel shader, Stage 3 RGB inputs                           
    D3DRS_PSRGBINPUTS4                  = 38,  // Pixel shader, Stage 4 RGB inputs                           
    D3DRS_PSRGBINPUTS5                  = 39,  // Pixel shader, Stage 5 RGB inputs                           
    D3DRS_PSRGBINPUTS6                  = 40,  // Pixel shader, Stage 6 RGB inputs                           
    D3DRS_PSRGBINPUTS7                  = 41,  // Pixel shader, Stage 7 RGB inputs                           
    D3DRS_PSCOMPAREMODE                 = 42,  // Pixel shader, Compare modes for clipplane texture mode     
    D3DRS_PSFINALCOMBINERCONSTANT0      = 43,  // Pixel shader, C0 in final combiner
    D3DRS_PSFINALCOMBINERCONSTANT1      = 44,  // Pixel shader, C1 in final combiner
    D3DRS_PSRGBOUTPUTS0                 = 45,  // Pixel shader, Stage 0 RGB outputs                          
    D3DRS_PSRGBOUTPUTS1                 = 46,  // Pixel shader, Stage 1 RGB outputs                          
    D3DRS_PSRGBOUTPUTS2                 = 47,  // Pixel shader, Stage 2 RGB outputs                          
    D3DRS_PSRGBOUTPUTS3                 = 48,  // Pixel shader, Stage 3 RGB outputs                          
    D3DRS_PSRGBOUTPUTS4                 = 49,  // Pixel shader, Stage 4 RGB outputs                          
    D3DRS_PSRGBOUTPUTS5                 = 50,  // Pixel shader, Stage 5 RGB outputs                          
    D3DRS_PSRGBOUTPUTS6                 = 51,  // Pixel shader, Stage 6 RGB outputs                          
    D3DRS_PSRGBOUTPUTS7                 = 52,  // Pixel shader, Stage 7 RGB outputs                          
    D3DRS_PSCOMBINERCOUNT               = 53,  // Pixel shader, Active combiner count (Stages 0-7)           
                                               // Pixel shader, Reserved
    D3DRS_PSDOTMAPPING                  = 55,  // Pixel shader, Input mapping for dot product modes          
    D3DRS_PSINPUTTEXTURE                = 56,  // Pixel shader, Texture source for some texture modes        
                                        
    D3DRS_PS_MAX                        = 57,  
                                        
    D3DRS_ZFUNC                         = 57,  // D3DCMPFUNC 
    D3DRS_ALPHAFUNC                     = 58,  // D3DCMPFUNC 
    D3DRS_ALPHABLENDENABLE              = 59,  // TRUE to enable alpha blending 
    D3DRS_ALPHATESTENABLE               = 60,  // TRUE to enable alpha tests 
    D3DRS_ALPHAREF                      = 61,  // BYTE
    D3DRS_SRCBLEND                      = 62,  // D3DBLEND 
    D3DRS_DESTBLEND                     = 63,  // D3DBLEND 
    D3DRS_ZWRITEENABLE                  = 64,  // TRUE to enable Z writes 
    D3DRS_DITHERENABLE                  = 65,  // TRUE to enable dithering 
    D3DRS_SHADEMODE                     = 66,  // D3DSHADEMODE 
    D3DRS_COLORWRITEENABLE              = 67,  // D3DCOLORWRITEENABLE_ALPHA, etc. per-channel write enable
    D3DRS_STENCILZFAIL                  = 68,  // D3DSTENCILOP to do if stencil test passes and Z test fails 
    D3DRS_STENCILPASS                   = 69,  // D3DSTENCILOP to do if both stencil and Z tests pass 
    D3DRS_STENCILFUNC                   = 70,  // D3DCMPFUNC
    D3DRS_STENCILREF                    = 71,  // BYTE reference value used in stencil test 
    D3DRS_STENCILMASK                   = 72,  // BYTE mask value used in stencil test 
    D3DRS_STENCILWRITEMASK              = 73,  // BYTE write mask applied to values written to stencil buffer 
    D3DRS_BLENDOP                       = 74,  // D3DBLENDOP setting
    D3DRS_BLENDCOLOR                    = 75,  // D3DCOLOR for D3DBLEND_CONSTANT, etc. (Xbox extension)
    D3DRS_SWATHWIDTH                    = 76,  // D3DSWATHWIDTH (Xbox extension)
    D3DRS_POLYGONOFFSETZSLOPESCALE      = 77,  // float Z factor for shadow maps (Xbox extension)
    D3DRS_POLYGONOFFSETZOFFSET          = 78,  // float bias for polygon offset (Xbox extension)
    D3DRS_POINTOFFSETENABLE             = 79,  // TRUE to enable polygon offset for points (Xbox extension)
    D3DRS_WIREFRAMEOFFSETENABLE         = 80,  // TRUE to enable polygon offset for lines (Xbox extension)
    D3DRS_SOLIDOFFSETENABLE             = 81,  // TRUE to enable polygon offset for fills (Xbox extension)
                                        
    D3DRS_SIMPLE_MAX                    = 82,

    // State whose handling is deferred until the next Draw[Indexed]Vertices
    // call because of interdependencies on other states:

    D3DRS_FOGENABLE                     = 82,  // TRUE to enable fog blending 
    D3DRS_FOGTABLEMODE                  = 83,  // D3DFOGMODE 
    D3DRS_FOGSTART                      = 84,  // float fog start (for both vertex and pixel fog) 
    D3DRS_FOGEND                        = 85,  // float fog end      
    D3DRS_FOGDENSITY                    = 86,  // float fog density  
    D3DRS_RANGEFOGENABLE                = 87,  // TRUE to enable range-based fog 
    D3DRS_WRAP0                         = 88,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 1st texture coord.
    D3DRS_WRAP1                         = 89,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 2nd texture coord. 
    D3DRS_WRAP2                         = 90,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 3rd texture coord. 
    D3DRS_WRAP3                         = 91,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 4th texture coord. 
    D3DRS_LIGHTING                      = 92,  // TRUE to enable lighting
    D3DRS_SPECULARENABLE                = 93,  // TRUE to enable specular 
    D3DRS_LOCALVIEWER                   = 94,  // TRUE to enable camera-relative specular highlights
    D3DRS_COLORVERTEX                   = 95,  // TRUE to enable per-vertex color
    D3DRS_BACKSPECULARMATERIALSOURCE    = 96,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKDIFFUSEMATERIALSOURCE     = 97,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKAMBIENTMATERIALSOURCE     = 98,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKEMISSIVEMATERIALSOURCE    = 99,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_SPECULARMATERIALSOURCE        = 100, // D3DMATERIALCOLORSOURCE 
    D3DRS_DIFFUSEMATERIALSOURCE         = 101, // D3DMATERIALCOLORSOURCE 
    D3DRS_AMBIENTMATERIALSOURCE         = 102, // D3DMATERIALCOLORSOURCE 
    D3DRS_EMISSIVEMATERIALSOURCE        = 103, // D3DMATERIALCOLORSOURCE 
    D3DRS_BACKAMBIENT                   = 104, // D3DCOLOR (Xbox extension)
    D3DRS_AMBIENT                       = 105, // D3DCOLOR 
    D3DRS_POINTSIZE                     = 106, // float point size 
    D3DRS_POINTSIZE_MIN                 = 107, // float point size min threshold 
    D3DRS_POINTSPRITEENABLE             = 108, // TRUE to enable point sprites
    D3DRS_POINTSCALEENABLE              = 109, // TRUE to enable point size scaling
    D3DRS_POINTSCALE_A                  = 110, // float point attenuation A value 
    D3DRS_POINTSCALE_B                  = 111, // float point attenuation B value 
    D3DRS_POINTSCALE_C                  = 112, // float point attenuation C value 
    D3DRS_POINTSIZE_MAX                 = 113, // float point size max threshold 
    D3DRS_PATCHEDGESTYLE                = 114, // D3DPATCHEDGESTYLE
    D3DRS_PATCHSEGMENTS                 = 115, // DWORD number of segments per edge when drawing patches
    D3DRS_SWAPFILTER                    = 116, // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for Swap (Xbox extension)
                                        
    D3DRS_DEFERRED_MAX                  = 117,

    // Complex state that has immediate processing:

    D3DRS_PSTEXTUREMODES                = 117, // Pixel shader, Texture addressing modes (Xbox extension)
    D3DRS_VERTEXBLEND                   = 118, // D3DVERTEXBLENDFLAGS
    D3DRS_FOGCOLOR                      = 119, // D3DCOLOR 
    D3DRS_FILLMODE                      = 120, // D3DFILLMODE        
    D3DRS_BACKFILLMODE                  = 121, // D3DFILLMODE (Xbox extension)
    D3DRS_TWOSIDEDLIGHTING              = 122, // TRUE to enable two-sided lighting (Xbox extension)
    D3DRS_NORMALIZENORMALS              = 123, // TRUE to enable automatic normalization
    D3DRS_ZENABLE                       = 124, // D3DZBUFFERTYPE (or TRUE/FALSE for legacy) 
    D3DRS_STENCILENABLE                 = 125, // TRUE to enable stenciling
    D3DRS_STENCILFAIL                   = 126, // D3DSTENCILOP to do if stencil test fails 
    D3DRS_FRONTFACE                     = 127, // D3DFRONT (Xbox extension)
    D3DRS_CULLMODE                      = 128, // D3DCULL 
    D3DRS_TEXTUREFACTOR                 = 129, // D3DCOLOR used for multi-texture blend 
    D3DRS_ZBIAS                         = 130, // LONG Z bias 
    D3DRS_LOGICOP                       = 131, // D3DLOGICOP (Xbox extension)
    D3DRS_EDGEANTIALIAS                 = 132, // TRUE to enable edge antialiasing (Xbox extension)
    D3DRS_MULTISAMPLEANTIALIAS          = 133, // TRUE to enable multisample antialiasing
    D3DRS_MULTISAMPLEMASK               = 134, // DWORD per-pixel and per-sample enable/disable
    D3DRS_MULTISAMPLEMODE               = 135, // D3DMULTISAMPLEMODE for the backbuffer (Xbox extension)
    D3DRS_MULTISAMPLERENDERTARGETMODE   = 136, // D3DMULTISAMPLEMODE for non-backbuffer render targets (Xbox extension)
    D3DRS_SHADOWFUNC                    = 137, // D3DCMPFUNC (Xbox extension)
    D3DRS_LINEWIDTH                     = 138, // float (Xbox extension)
    D3DRS_DXT1NOISEENABLE               = 139, // TRUE to enable DXT1 decompression noise (Xbox extension)
    D3DRS_YUVENABLE                     = 140, // TRUE to enable use of D3DFMT_YUY2 and D3DFMT_UYVY texture formats
    D3DRS_OCCLUSIONCULLENABLE           = 141, // TRUE to enable Z occlusion culling
    D3DRS_STENCILCULLENABLE             = 142, // TRUE to enable stencil culling
    D3DRS_ROPZCMPALWAYSREAD             = 143, // TRUE to always read target packet when Z enabled
    D3DRS_ROPZREAD                      = 144, // TRUE to always read Z
    D3DRS_DONOTCULLUNCOMPRESSED         = 145, // TRUE to never attempt occlusion culling (stencil or Z) on uncompressed packets
                                        
    D3DRS_MAX                           = 146, // Total number of renderstates 

    // Render states that are not supported on Xbox:
    //
    // D3DRS_LINEPATTERN
    // D3DRS_LASTPIXEL
    // D3DRS_CLIPPING
    // D3DRS_FOGVERTEXMODE
    // D3DRS_CLIPPLANEENABLE
    // D3DRS_SOFTWAREVERTEXPROCESSING
    // D3DRS_DEBUGMONITORTOKEN
    // D3DRS_INDEXEDVERTEXBLENDENABLE
    // D3DRS_TWEENFACTOR

    D3DRS_FORCE_DWORD                   = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// Values for material source
typedef enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL         = 0,            // Color from material is used
    D3DMCS_COLOR1           = 1,            // Diffuse vertex color is used
    D3DMCS_COLOR2           = 2,            // Specular vertex color is used
    D3DMCS_FORCE_DWORD      = 0x7fffffff,   // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;

// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 D3DRS_WRAP0

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000010L
#define D3DWRAP_V   0x00001000L
#define D3DWRAP_W   0x00100000L

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
#define D3DWRAPCOORD_0   0x00000010L    // same as D3DWRAP_U
#define D3DWRAPCOORD_1   0x00001000L    // same as D3DWRAP_V
#define D3DWRAPCOORD_2   0x00100000L    // same as D3DWRAP_W
#define D3DWRAPCOORD_3   0x01000000L

/* Flags to construct D3DRS_COLORWRITEENABLE */
#define D3DCOLORWRITEENABLE_RED     (1L<<16)
#define D3DCOLORWRITEENABLE_GREEN   (1L<<8)
#define D3DCOLORWRITEENABLE_BLUE    (1L<<0)
#define D3DCOLORWRITEENABLE_ALPHA   (1L<<24)
#define D3DCOLORWRITEENABLE_ALL     0x01010101 // Xbox extension

/*
 * State enumerants for per-stage texture processing.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    // State whose handling is deferred until the next Draw[Indexed]Vertices
    // call because of interdependencies on other states:

    D3DTSS_ADDRESSU              =  0,  // D3DTEXTUREADDRESS for U coordinate 
    D3DTSS_ADDRESSV              =  1,  // D3DTEXTUREADDRESS for V coordinate 
    D3DTSS_ADDRESSW              =  2,  // D3DTEXTUREADDRESS for W coordinate 
    D3DTSS_MAGFILTER             =  3,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for magnification 
    D3DTSS_MINFILTER             =  4,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for minification 
    D3DTSS_MIPFILTER             =  5,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use between mipmaps during minification 
    D3DTSS_MIPMAPLODBIAS         =  6,  // float mipmap LOD bias 
    D3DTSS_MAXMIPLEVEL           =  7,  // DWORD 0..(n-1) LOD index of largest map to use (0 == largest) 
    D3DTSS_MAXANISOTROPY         =  8,  // DWORD maximum anisotropy 
    D3DTSS_COLORKEYOP            =  9,  // D3DTEXTURECOLORKEYOP (Xbox extension)
    D3DTSS_COLORSIGN             = 10,  // D3DTSIGN_* (D3DTSIGN_ASIGNED etc.) for color channels (xbox extension)
    D3DTSS_ALPHAKILL             = 11,  // D3DTEXTUREALPHAKILL (Xbox extension)

    D3DTSS_DEFERRED_TEXTURE_STATE_MAX = 12,

    D3DTSS_COLOROP               = 12,  // D3DTEXTUREOP - per-stage blending controls for color channels 
    D3DTSS_COLORARG0             = 13,  // D3DTA_* (D3DTA_TEXTURE etc.) third arg for triadic ops 
    D3DTSS_COLORARG1             = 14,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg
    D3DTSS_COLORARG2             = 15,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg 
    D3DTSS_ALPHAOP               = 16,  // D3DTEXTUREOP - per-stage blending controls for alpha channel 
    D3DTSS_ALPHAARG0             = 17,  // D3DTA_* (D3DTA_TEXTURE etc.) third arg for triadic ops 
    D3DTSS_ALPHAARG1             = 18,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg
    D3DTSS_ALPHAARG2             = 19,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg) 
    D3DTSS_RESULTARG             = 20,  // D3DTA_CURRENT or D3DTA_TEMP - arg for result 
    D3DTSS_TEXTURETRANSFORMFLAGS = 21,  // D3DTEXTURETRANSFORMFLAGS controls texture transform 

    D3DTSS_DEFERRED_MAX          = 22,

    // State that has immediate processing:

    D3DTSS_BUMPENVMAT00          = 22,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT01          = 23,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT11          = 24,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT10          = 25,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVLSCALE         = 26,  // float scale for bump map luminance 
    D3DTSS_BUMPENVLOFFSET        = 27,  // float offset for bump map luminance 
    D3DTSS_TEXCOORDINDEX         = 28,  // DWORD identifies which set of texture coordinates index this texture 
    D3DTSS_BORDERCOLOR           = 29,  // D3DCOLOR 
    D3DTSS_COLORKEYCOLOR         = 30,  // D3DCOLOR value for color key (Xbox extension)
                                 
    D3DTSS_MAX                   = 32,  // Total number of texture stage states (bumped to a power of 2)

    D3DTSS_FORCE_DWORD           = 0x7fffffff, // force 32-bit size enum 
} D3DTEXTURESTAGESTATETYPE;

/*
 * The maximum number of texture stages supported on Xbox
 */

#define D3DTSS_MAXSTAGES 4

/*
 * The maximum index value possible for EndVisibilityTest
 */

#define D3DVISIBILITY_TEST_MAX 4096

// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
#define D3DTSS_TCI_PASSTHRU                             0x00000000
#define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
#define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000
#define D3DTSS_TCI_OBJECT                               0x00040000
#define D3DTSS_TCI_SPHERE                               0x00050000

#define D3DTSS_TCI_TEXCOORDINDEX_MAX                    8
#define D3DTSS_TCI_TEXGEN_MAX                           0x00060000

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum _D3DTEXTUREOP
{
    // Control
    D3DTOP_DISABLE              = 1,      // disables stage
    D3DTOP_SELECTARG1           = 2,      // the default
    D3DTOP_SELECTARG2           = 3,

    // Modulate
    D3DTOP_MODULATE             = 4,      // multiply args together
    D3DTOP_MODULATE2X           = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X           = 6,      // multiply and  2 bits

    // Add
    D3DTOP_ADD                  =  7,   // add arguments together
    D3DTOP_ADDSIGNED            =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X          =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT             = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH            = 11,   // add 2 args, subtract product
                                        // Arg1 + Arg2 - Arg1*Arg2
                                        // = Arg1 + (1-Arg1)*Arg2

    // Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 14, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 15, // alpha from D3DRENDERSTATE_TEXTUREFACTOR

    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 16, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 13, // by alpha of current color

    // Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 22,

    // Triadic ops
    D3DTOP_MULTIPLYADD          = 23, // Arg0 + Arg1*Arg2
    D3DTOP_LERP                 = 24, // (Arg0)*Arg1 + (1-Arg0)*Arg2

    // Bump mapping
    D3DTOP_BUMPENVMAP           = 25, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 26, // with luminance channel

    D3DTOP_MAX                  = 27,
    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
 * operations set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
#define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
#define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
#define D3DTA_TFACTOR           0x00000003  // select RENDERSTATE_TEXTUREFACTOR (read only)
#define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
#define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)

#define D3DTA_SELECTMAX         0x00000006
#define D3DTA_MODIFIERMAX       0x00000040

/*
 * Flags for D3DTSS_COLORSIGN (Xbox extension)
 */
#define D3DTSIGN_ASIGNED           0x10000000
#define D3DTSIGN_AUNSIGNED         0
#define D3DTSIGN_RSIGNED           0x20000000
#define D3DTSIGN_RUNSIGNED         0
#define D3DTSIGN_GSIGNED           0x40000000
#define D3DTSIGN_GUNSIGNED         0
#define D3DTSIGN_BSIGNED           0x80000000
#define D3DTSIGN_BUNSIGNED         0

//
// Values for D3DTSS_***FILTER texture stage states
//
typedef enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
    D3DTEXF_POINT           = 1,    // nearest
    D3DTEXF_LINEAR          = 2,    // linear interpolation
    D3DTEXF_ANISOTROPIC     = 3,    // anisotropic
    D3DTEXF_QUINCUNX        = 4,    // quincunx kernel (Xbox extension)
    D3DTEXF_GAUSSIANCUBIC   = 5,    // different cubic kernel

    D3DTEXF_MAX             = 6,
    D3DTEXF_FORCE_DWORD     = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREFILTERTYPE;

/* The maximum number of vertices user can pass to any d3d
   drawing function or to create vertex buffer with
*/
#define D3DMAXNUMVERTICES    ((1<<16) - 1)
/* The maximum number of primitives user can pass to any d3d
   drawing function.
*/
#define D3DMAXNUMPRIMITIVES  ((1<<16) - 1)

//-------------------------------------------------------------------
// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x00E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#define D3DFVF_XYZB1            0x006
#define D3DFVF_XYZB2            0x008
#define D3DFVF_XYZB3            0x00a
#define D3DFVF_XYZB4            0x00c

#define D3DFVF_NORMAL           0x010
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400

#define D3DFVF_RESERVED2        0xE000  // 4 reserved bits

// D3DFVF_PSIZE is not supported on Xbox with the fixed function pipeline 
// (a programmable vertex shader can be written to support per-vertex point
// sizes)

//---------------------------------------------------------------------
// Vertex Shaders
//

/*

Vertex Shader Declaration

The declaration portion of a vertex shader defines the static external
interface of the shader.  The information in the declaration includes:

- Assignments of vertex shader input registers to data streams.  These
assignments bind a specific vertex register to a single component within a
vertex stream.  A vertex stream element is identified by a byte offset
within the stream and a type.  The type specifies the arithmetic data type
plus the dimensionality (1, 2, 3, or 4 values).  Stream data which is
less than 4 values are always expanded out to 4 values with zero or more
0.F values and one 1.F value.

- Assignment of vertex shader input registers to implicit data from the
primitive tessellator.  This controls the loading of vertex data which is
not loaded from a stream, but rather is generated during primitive
tessellation prior to the vertex shader.

- Loading data into the constant memory at the time a shader is set as the
current shader.  Each token specifies values for one or more contiguous 4
DWORD constant registers.  This allows the shader to update an arbitrary
subset of the constant memory, overwriting the device state (which
contains the current values of the constant memory).  Note that these
values can be subsequently overwritten (between DrawPrimitive calls)
during the time a shader is bound to a device via the
SetVertexShaderConstant method.


Declaration arrays are single-dimensional arrays of DWORDs composed of
multiple tokens each of which is one or more DWORDs.  The single-DWORD
token value 0xFFFFFFFF is a special token used to indicate the end of the
declaration array.  The single DWORD token value 0x00000000 is a NOP token
with is ignored during the declaration parsing.  Note that 0x00000000 is a
valid value for DWORDs following the first DWORD for multiple word tokens.

[31:29] TokenType
    0x0 - NOP (requires all DWORD bits to be zero)
    0x1 - stream selector
    0x2 - stream data definition (map to vertex input memory)
    0x3 - vertex input memory from tessellator
    0x4 - constant memory from shader
    0x5 - extension
    0x6 - reserved
    0x7 - end-of-array (requires all DWORD bits to be 1)

NOP Token (single DWORD token)
    [31:29] 0x0
    [28:00] 0x0

Stream Selector (single DWORD token)
    [31:29] 0x1
    [28]    indicates whether this is a tessellator stream
    [27:04] 0x0
    [03:00] stream selector (0..15)

Stream Data Definition (single DWORD token)
    Vertex Input Register Load
      [31:29] 0x2
      [28]    0x0
      [27:24] 0x0
      [23:16] type (dimensionality and data type)
      [15:04] 0x0
      [03:00] vertex register address (0..15)
    DWORD Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27]    0x0
      [26:20] 0x0
      [19:16] count of DWORDS to skip over (0..15)
      [15:00] 0x0
    BYTE Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27]    0x1
      [26:20] 0x0
      [19:16] count of BYTES to skip over (0..15)
      [15:00] 0x0
  
Vertex Input Memory from Tessellator Data (single DWORD token)
    [31:29] 0x3
    [28]    indicates whether data is normals or u/v
    [27:24] 0x0
    [23:20] vertex register address (0..15)
    [19:04] 0x0
    [03:00] vertex register address (0..15)

Constant Memory from Shader (multiple DWORD token)
    [31:29] 0x4
    [28:25] count of 4*DWORD constants to load (0..15)
    [24:08] 0x0
    [07:00] constant memory address (0..191 - biased by 96)

Extension Token (single or multiple DWORD token)
    [31:29] 0x5
    [28:24] count of additional DWORDs in token (0..31)
    [23:00] extension-specific information

End-of-array token (single DWORD token)
    [31:29] 0x7
    [28:00] 0x1fffffff

The stream selector token must be immediately followed by a contiguous set 
of stream data definition tokens.  This token sequence fully defines that 
stream, including the set of elements within the stream, the order in 
which the elements appear, the type of each element, and the vertex 
register into which to load an element.

Streams are allowed to include data which is not loaded into a vertex 
register, thus allowing data which is not used for this shader to exist 
in the vertex stream.  This skipped data is defined only by a count of 
DWORDs to skip over, since the type i nformation is irrelevant.

The token sequence:
Stream Select: stream=0
Stream Data Definition (Load): type=FLOAT3; register=3
Stream Data Definition (Load): type=FLOAT3; register=4
Stream Data Definition (Skip): count=2
Stream Data Definition (Load): type=FLOAT2; register=7

defines stream zero to consist of 4 elements, 3 of which are loaded into 
registers and the fourth skipped over.  Register 3 is loaded with the 
first three DWORDs in each vertex interpreted as FLOAT data.  Register 4 
is loaded with the 4th, 5th, and 6th DWORDs interpreted as FLOAT data.  
The next two DWORDs (7th and 8th) are skipped over and not loaded into 
any vertex input register.   Register 7 is loaded with the 9th and 10th 
DWORDS interpreted as FLOAT data.  Placing of tokens other than NOPs 
between the Stream Selector and Stream Data Definition tokens is disallowed.

*/

// Vertex Shader 1.0 register limits. D3D device must provide at least
// specified number of registers
//

#define D3DVS_STREAMS_MAX_V1_0          16
#define D3DVS_INPUTREG_MAX_V1_0         16
#define D3DVS_TEMPREG_MAX_V1_0          12
// This max required number. Device could have more registers. Check caps.
#define D3DVS_CONSTREG_COUNT_XBOX       192
#define D3DVS_TCRDOUTREG_MAX_V1_0       8
#define D3DVS_ADDRREG_MAX_V1_0          1
#define D3DVS_ATTROUTREG_MAX_V1_0       2
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_0  128

// The following two vertex shader constant addresses are reserved on Xbox
// when the SetShaderConstantMode does not have the D3DSCM_NORESERVEDCONSTANTS 
// bit set (that is, these are reserved unless all of your vertex shaders use
// #pragma screenspace):
//
#define D3DVS_XBOX_RESERVEDCONSTANT1    -38
#define D3DVS_XBOX_RESERVEDCONSTANT2    -37

// Calling SetVertexShader with FVF_XYZRHW invalidates the first 11 or 12
// vertex shader program slots as loaded via LoadVertexShader. Max is 12...
//
#define D3DVS_XBOX_RESERVEDXYZRHWSLOTS  12

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define D3DPS_INPUTREG_MAX_DX8         8
#define D3DPS_TEMPREG_MAX_DX8          8
#define D3DPS_CONSTREG_MAX_DX8         16
#define D3DPS_TEXTUREREG_MAX_DX8       8


typedef enum _D3DVSD_TOKENTYPE
{
    D3DVSD_TOKEN_NOP        = 0,    // NOP or extension
    D3DVSD_TOKEN_STREAM,            // stream selector
    D3DVSD_TOKEN_STREAMDATA,        // stream data definition (map to vertex input memory)
    D3DVSD_TOKEN_TESSELLATOR,       // vertex input memory from tessellator
    D3DVSD_TOKEN_CONSTMEM,          // constant memory from shader
    D3DVSD_TOKEN_EXT,               // extension
    D3DVSD_TOKEN_END = 7,           // end-of-array (requires all DWORD bits to be 1)
    D3DVSD_FORCE_DWORD = 0x7fffffff,// force 32-bit size enum
} D3DVSD_TOKENTYPE;

#define D3DVSD_TOKENTYPESHIFT   29
#define D3DVSD_TOKENTYPEMASK    (7 << D3DVSD_TOKENTYPESHIFT)

#define D3DVSD_STREAMNUMBERSHIFT 0
#define D3DVSD_STREAMNUMBERMASK (0xF << D3DVSD_STREAMNUMBERSHIFT)

#define D3DVSD_DATALOADTYPESHIFT 28
#define D3DVSD_DATALOADTYPEMASK (0x1 << D3DVSD_DATALOADTYPESHIFT)

#define D3DVSD_DATATYPESHIFT 16
#define D3DVSD_DATATYPEMASK (0xFF << D3DVSD_DATATYPESHIFT)

#define D3DVSD_SKIPCOUNTSHIFT 16
#define D3DVSD_SKIPCOUNTMASK (0xF << D3DVSD_SKIPCOUNTSHIFT)

#define D3DVSD_VERTEXREGSHIFT 0
#define D3DVSD_VERTEXREGMASK (0x1F << D3DVSD_VERTEXREGSHIFT)

#define D3DVSD_VERTEXREGINSHIFT 20
#define D3DVSD_VERTEXREGINMASK (0xF << D3DVSD_VERTEXREGINSHIFT)

#define D3DVSD_CONSTCOUNTSHIFT 25
#define D3DVSD_CONSTCOUNTMASK (0xF << D3DVSD_CONSTCOUNTSHIFT)

#define D3DVSD_CONSTADDRESSSHIFT 0
#define D3DVSD_CONSTADDRESSMASK (0xFF << D3DVSD_CONSTADDRESSSHIFT)

#define D3DVSD_CONSTRSSHIFT 16
#define D3DVSD_CONSTRSMASK (0x1FFF << D3DVSD_CONSTRSSHIFT)

#define D3DVSD_EXTCOUNTSHIFT 24
#define D3DVSD_EXTCOUNTMASK (0x1F << D3DVSD_EXTCOUNTSHIFT)

#define D3DVSD_EXTINFOSHIFT 0
#define D3DVSD_EXTINFOMASK (0xFFFFFF << D3DVSD_EXTINFOSHIFT)

#define D3DVSD_MAKETOKENTYPE(tokenType) ((tokenType << D3DVSD_TOKENTYPESHIFT) & D3DVSD_TOKENTYPEMASK)

// macros for generation of CreateVertexShader Declaration token array

// Set current stream
// _StreamNumber [0..(MaxStreams-1)] stream to get data from
//
#define D3DVSD_STREAM( _StreamNumber ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (_StreamNumber))

// Set tessellator stream
//
#define D3DVSD_STREAMTESSSHIFT 28
#define D3DVSD_STREAMTESSMASK (1 << D3DVSD_STREAMTESSSHIFT)
#define D3DVSD_STREAM_TESS( ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (D3DVSD_STREAMTESSMASK))

// bind single vertex register to vertex element from vertex stream
//
// _VertexRegister [0..26] address of the vertex register
// _Type [D3DVSDT_*] dimensionality and arithmetic data type

#define D3DVSD_REG( _VertexRegister, _Type ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) |            \
     ((_Type) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Skip _DWORDCount DWORDs in vertex
//
#define D3DVSD_SKIP( _DWORDCount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x10000000 | \
     ((_DWORDCount) << D3DVSD_SKIPCOUNTSHIFT))

// Skip _BYTECount BYTEs in vertex (Xbox extension)
//
#define D3DVSD_SKIPBYTES( _BYTECount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x18000000 | \
     ((_BYTECount) << D3DVSD_SKIPCOUNTSHIFT))

// load data into vertex shader constant memory
//
// _ConstantAddress [-96..95] - address of constant array to begin filling data
// _Count [0..15] - number of constant vectors to load (4 DWORDs each)
// followed by 4*_Count DWORDS of data
//
#define D3DVSD_CONST( _ConstantAddress, _Count ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM) | \
     ((_Count) << D3DVSD_CONSTCOUNTSHIFT) | ((_ConstantAddress) + 96))

// enable tessellator generated normals
//
// _VertexRegisterIn  [0..15] address of vertex register whose input stream
//                            will be used in normal computation
// _VertexRegisterOut [0..15] address of vertex register to output the normal to
//
#define D3DVSD_TESSNORMAL( _VertexRegisterIn, _VertexRegisterOut ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | \
     ((_VertexRegisterIn) << D3DVSD_VERTEXREGINSHIFT) | \
     (_VertexRegisterOut))

// enable tessellator generated surface parameters
//
// _VertexRegister [0..15] address of vertex register to output parameters
//
#define D3DVSD_TESSUV( _VertexRegister ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | 0x10000000 | \
     (_VertexRegister))

// Generates END token
//
#define D3DVSD_END() 0xFFFFFFFF

// Generates NOP token
#define D3DVSD_NOP() 0x00000000

// bit declarations for _Type fields
#define D3DVSDT_FLOAT1      0x12    // 1D float expanded to (value, 0., 0., 1.)
#define D3DVSDT_FLOAT2      0x22    // 2D float expanded to (value, value, 0., 1.)
#define D3DVSDT_FLOAT3      0x32    // 3D float expanded to (value, value, value, 1.)
#define D3DVSDT_FLOAT4      0x42    // 4D float
#define D3DVSDT_D3DCOLOR    0x40    // 4D packed unsigned bytes mapped to 0. to 1. range
                                    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
#define D3DVSDT_SHORT2      0x25    // 2D signed short expanded to (value, value, 0., 1.)
#define D3DVSDT_SHORT4      0x45    // 4D signed short

// The following are Xbox extensions
#define D3DVSDT_NORMSHORT1  0x11    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
                                    // (signed, normalized short maps from -1.0 to 1.0)
#define D3DVSDT_NORMSHORT2  0x21    // 2D signed, normalized short expanded to (value, value, 0., 1.)
#define D3DVSDT_NORMSHORT3  0x31    // 3D signed, normalized short expanded to (value, value, value, 1.)  
#define D3DVSDT_NORMSHORT4  0x41    // 4D signed, normalized short expanded to (value, value, value, value)  
#define D3DVSDT_NORMPACKED3 0x16    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
                                    // Each component ranges from -1.0 to 1.0.  
                                    // Expanded to (value, value, value, 1.)
#define D3DVSDT_SHORT1      0x15    // 1D signed short expanded to (value, 0., 0., 1.)  
                                    // Signed shorts map to the range [-32768, 32767]
#define D3DVSDT_SHORT3      0x35    // 3D signed short expanded to (value, value, value, 1.)
#define D3DVSDT_PBYTE1      0x14    // 1D packed byte expanded to (value, 0., 0., 1.)  
                                    // Packed bytes map to the range [0, 1]
#define D3DVSDT_PBYTE2      0x24    // 2D packed byte expanded to (value, value, 0., 1.)
#define D3DVSDT_PBYTE3      0x34    // 3D packed byte expanded to (value, value, value, 1.)
#define D3DVSDT_PBYTE4      0x44    // 4D packed byte expanded to (value, value, value, value) 
#define D3DVSDT_FLOAT2H     0x72    // 2D homogeneous float expanded to (value, value,0., value.)
                                    // Useful for projective texture coordinates.
#define D3DVSDT_NONE        0x02    // No stream data

// D3DVSDT_UBYTE4 not supported on Xbox (hardware can't do it)

// assignments of vertex input registers for fixed function vertex shader
//
#define D3DVSDE_VERTEX          -1  // Xbox extension, used only in Begin/End bracket
#define D3DVSDE_POSITION        0
#define D3DVSDE_BLENDWEIGHT     1
#define D3DVSDE_NORMAL          2
#define D3DVSDE_DIFFUSE         3
#define D3DVSDE_SPECULAR        4
#define D3DVSDE_FOG             5   // Xbox extension
#define D3DVSDE_BACKDIFFUSE     7   // Xbox extension
#define D3DVSDE_BACKSPECULAR    8   // Xbox extension
#define D3DVSDE_TEXCOORD0       9
#define D3DVSDE_TEXCOORD1       10
#define D3DVSDE_TEXCOORD2       11
#define D3DVSDE_TEXCOORD3       12

// D3DVSDE_PSIZE is not supported on Xbox with the fixed function pipeline 
// (a programmable vertex shader can be written to support per-vertex point
// sizes)

// Maximum supported number of texture coordinate sets
#define D3DDP_MAXTEXCOORD   4

// Some Vertex Shader APIs take allow the vertex format to be specified with 
// a structure rather than a handle to a vertex shader object.  The following 
// structure defines how vertex attributes are read from one or more streams.

typedef struct _D3DVERTEXSHADERINPUT
{
    DWORD StreamIndex;      // which stream 
    DWORD Offset;           // Byte offset from the start of the stream.
    DWORD Format;           // format of this attribute (D3DVSDT_*)
    BYTE  TessType;         // 0=none, 1=normal, 2=autotex
    BYTE  TessSource;       // source register for normal/uv autocalc
} D3DVERTEXSHADERINPUT;

// Up to 16 different inputs are supported by the vertex shader hardware.
// Each of the 16 entries in the following structure defines which 
// stream that value comes from, what byte offset corresponds to an 
// attribute, and the format of the attribute.

typedef struct _D3DVERTEXATTRIBUTEFORMAT
{
    D3DVERTEXSHADERINPUT Input[16];
} D3DVERTEXATTRIBUTEFORMAT;


//
// Instruction Token Bit Definitions
//
#define D3DSI_OPCODE_MASK       0x0000FFFF

typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
{
    D3DSIO_NOP          = 0,    // PS/VS
    D3DSIO_MOV          ,       // PS/VS
    D3DSIO_ADD          ,       // PS/VS
    D3DSIO_SUB          ,       // PS
    D3DSIO_MAD          ,       // PS/VS
    D3DSIO_MUL          ,       // PS/VS
    D3DSIO_RCP          ,       // VS
    D3DSIO_RSQ          ,       // VS
    D3DSIO_DP3          ,       // PS/VS
    D3DSIO_DP4          ,       // VS
    D3DSIO_MIN          ,       // VS
    D3DSIO_MAX          ,       // VS
    D3DSIO_SLT          ,       // VS
    D3DSIO_SGE          ,       // VS
    D3DSIO_EXP          ,       // VS
    D3DSIO_LOG          ,       // VS
    D3DSIO_LIT          ,       // VS
    D3DSIO_DST          ,       // VS
    D3DSIO_LRP          ,       // PS
    D3DSIO_FRC          ,       // VS
    D3DSIO_M4x4         ,       // VS
    D3DSIO_M4x3         ,       // VS
    D3DSIO_M3x4         ,       // VS
    D3DSIO_M3x3         ,       // VS
    D3DSIO_M3x2         ,       // VS

    D3DSIO_TEXCOORD     = 64,   // PS
    D3DSIO_TEXKILL      ,       // PS
    D3DSIO_TEX          ,       // PS
    D3DSIO_TEXBEM       ,       // PS
    D3DSIO_TEXBEML      ,       // PS
    D3DSIO_TEXREG2AR    ,       // PS
    D3DSIO_TEXREG2GB    ,       // PS
    D3DSIO_TEXM3x2PAD   ,       // PS
    D3DSIO_TEXM3x2TEX   ,       // PS
    D3DSIO_TEXM3x3PAD   ,       // PS
    D3DSIO_TEXM3x3TEX   ,       // PS
    D3DSIO_TEXM3x3DIFF  ,       // PS
    D3DSIO_TEXM3x3SPEC  ,       // PS
    D3DSIO_TEXM3x3VSPEC ,       // PS
    D3DSIO_EXPP         ,       // VS
    D3DSIO_LOGP         ,       // VS
    D3DSIO_CND          ,       // PS
    D3DSIO_DEF          ,       // PS
    
    // Xbox Extensions
    D3DSIO_DPH          =256,   // VS
    D3DSIO_RCC          ,       // VS
    D3DSIO_XMMA         ,       // PS
    D3DSIO_XMMC         ,       // PS
    D3DSIO_XDM          ,       // PS
    D3DSIO_XDD          ,       // PS
    D3DSIO_XFC          ,       // PS
    D3DSIO_TEXM3x2DEPTH ,       // PS
    D3DSIO_TEXBRDF      ,       // PS

    D3DSIO_COMMENT      = 0xFFFE,
    D3DSIO_END          = 0xFFFF,

    D3DSIO_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;

//
// Co-Issue Instruction Modifier - if set then this instruction is to be
// issued in parallel with the previous instruction(s) for which this bit
// is not set.
//
#define D3DSI_COISSUE           0x40000000

//
// Parameter Token Bit Definitions
//
#define D3DSP_REGNUM_MASK       0x00000FFF

// destination parameter write mask
#define D3DSP_WRITEMASK_0       0x00010000  // Component 0 (X;Red)
#define D3DSP_WRITEMASK_1       0x00020000  // Component 1 (Y;Green)
#define D3DSP_WRITEMASK_2       0x00040000  // Component 2 (Z;Blue)
#define D3DSP_WRITEMASK_3       0x00080000  // Component 3 (W;Alpha)
#define D3DSP_WRITEMASK_ALL     0x000F0000  // All Components

// destination parameter modifiers
#define D3DSP_DSTMOD_SHIFT      20
#define D3DSP_DSTMOD_MASK       0x00F00000

#define D3DSP_DSTSRC_SHIFT      15          // indicates src or dst
#define D3DSP_DSTSRC_MASK       0x00008000

typedef enum _D3DSHADER_PARAM_DSTMOD_TYPE
{
    D3DSPDM_NONE    = 0<<D3DSP_DSTMOD_SHIFT, // nop
    D3DSPDM_BIAS    = 1<<D3DSP_DSTMOD_SHIFT, // subtract 0.5
    D3DSPDM_FORCE_DWORD  = 0x7fffffff,      // force 32-bit size enum
} D3DSHADER_PARAM_DSTMOD_TYPE;

// destination parameter 
#define D3DSP_DSTSHIFT_SHIFT    24
#define D3DSP_DSTSHIFT_MASK     0x0F000000

// destination/source parameter register type
#define D3DSP_REGTYPE_SHIFT     28
#define D3DSP_REGTYPE_MASK      0x70000000

typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
{
    D3DSPR_TEMP     = 0<<D3DSP_REGTYPE_SHIFT, // Temporary Register File
    D3DSPR_INPUT    = 1<<D3DSP_REGTYPE_SHIFT, // Input Register File
    D3DSPR_CONST    = 2<<D3DSP_REGTYPE_SHIFT, // Constant Register File
    D3DSPR_ADDR     = 3<<D3DSP_REGTYPE_SHIFT, // Address Register (VS)
    D3DSPR_TEXTURE  = 3<<D3DSP_REGTYPE_SHIFT, // Texture Register File (PS)
    D3DSPR_RASTOUT  = 4<<D3DSP_REGTYPE_SHIFT, // Rasterizer Register File
    D3DSPR_ATTROUT  = 5<<D3DSP_REGTYPE_SHIFT, // Attribute Output Register File
    D3DSPR_TEXCRDOUT= 6<<D3DSP_REGTYPE_SHIFT, // Texture Coordinate Output Register File
    D3DSPR_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DSHADER_PARAM_REGISTER_TYPE;

// Register offsets in the Rasterizer Register File
//
typedef enum _D3DVS_RASTOUT_OFFSETS
{
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DVS_RASTOUT_OFFSETS;

// Source operand addressing modes

#define D3DVS_ADDRESSMODE_SHIFT 13
#define D3DVS_ADDRESSMODE_MASK  (3 << D3DVS_ADDRESSMODE_SHIFT)

enum D3DVS_ADRRESSMODE
{
    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),   // Relative to register A0
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
};

// Source operand swizzle definitions
//
#define D3DVS_SWIZZLE_SHIFT     16
#define D3DVS_SWIZZLE_MASK      0x00FF0000

// The following bits define where to take component X:

#define D3DVS_X_X       (0 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Y       (1 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Z       (2 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_W       (3 << D3DVS_SWIZZLE_SHIFT)

// The following bits define where to take component Y:

#define D3DVS_Y_X       (0 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_W       (3 << (D3DVS_SWIZZLE_SHIFT + 2))

// The following bits define where to take component Z:

#define D3DVS_Z_X       (0 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_W       (3 << (D3DVS_SWIZZLE_SHIFT + 4))

// The following bits define where to take component W:

#define D3DVS_W_X       (0 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_W       (3 << (D3DVS_SWIZZLE_SHIFT + 6))

// Value when there is no swizzle (X is taken from X, Y is taken from Y,
// Z is taken from Z, W is taken from W
//
#define D3DVS_NOSWIZZLE (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)

// source parameter swizzle
#define D3DSP_SWIZZLE_SHIFT     16
#define D3DSP_SWIZZLE_MASK      0x00FF0000

#define D3DSP_NOSWIZZLE \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// pixel-shader swizzle ops
#define D3DSP_REPLICATEALPHA \
    ( (3 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// source parameter modifiers
#define D3DSP_SRCMOD_SHIFT      24
#define D3DSP_SRCMOD_MASK       0x0F000000

typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
{
    D3DSPSM_NONE    = 0<<D3DSP_SRCMOD_SHIFT, // nop
    D3DSPSM_NEG     = 1<<D3DSP_SRCMOD_SHIFT, // negate
    D3DSPSM_BIAS    = 2<<D3DSP_SRCMOD_SHIFT, // bias
    D3DSPSM_BIASNEG = 3<<D3DSP_SRCMOD_SHIFT, // bias and negate
    D3DSPSM_SIGN    = 4<<D3DSP_SRCMOD_SHIFT, // sign
    D3DSPSM_SIGNNEG = 5<<D3DSP_SRCMOD_SHIFT, // sign and negate
    D3DSPSM_COMP    = 6<<D3DSP_SRCMOD_SHIFT, // complement
    D3DSPSM_SAT     = 7<<D3DSP_SRCMOD_SHIFT, // saturate

    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
} D3DSHADER_PARAM_SRCMOD_TYPE;

// pixel shader version token
#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))

// vertex shader version token
#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))

// extract major/minor from version cap
#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)

// destination/source parameter register type
#define D3DSI_COMMENTSIZE_SHIFT     16
#define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
#define D3DSHADER_COMMENT(_DWordSize) \
    ((((_DWordSize)<<D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|D3DSIO_COMMENT)

// pixel/vertex shader end token
#define D3DPS_END()  0x0000FFFF
#define D3DVS_END()  0x0000FFFF

//-------------------------------------------------------------------------
// D3D Vertex Shader Microcode Type values:
// --------------
//
// D3DSMT_VERTEXSHADER
//   An ordinary vertex shader.
//
// D3DSMT_READWRITE_VERTEXSHADER
//   A vertex shader that can write to the constant registers.
//
// D3DSMT_VERTEXSTATESHADER
//   A vertex state shader.
//
//-------------------------------------------------------------------------

#define D3DSMT_VERTEXSHADER              1
#define D3DSMT_READWRITE_VERTEXSHADER    2
#define D3DSMT_VERTEXSTATESHADER         3

//---------------------------------------------------------------------

// High order surfaces
//
typedef enum _D3DBASISTYPE
{
   D3DBASIS_BEZIER      = 0,
   D3DBASIS_BSPLINE     = 1,
   D3DBASIS_INTERPOLATE = 2,
   D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;

typedef enum _D3DORDERTYPE
{
   D3DORDER_LINEAR      = 1,
   D3DORDER_CUBIC       = 3,
   D3DORDER_QUINTIC     = 5,
   D3DORDER_FORCE_DWORD = 0x7fffffff,
} D3DORDERTYPE;

typedef enum _D3DPATCHEDGESTYLE
{
   D3DPATCHEDGE_DISCRETE    = 0,
   D3DPATCHEDGE_CONTINUOUS  = 1,
   D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0x7fffffff,
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBF_DISABLE           = 0,     // Disable vertex blending
    D3DVBF_1WEIGHTS          = 1,     // 2 matrix blending
    D3DVBF_2WEIGHTS          = 3,     // 3 matrix blending
    D3DVBF_3WEIGHTS          = 5,     // 4 matrix blending
    D3DVBF_2WEIGHTS2MATRICES = 2,     // Xbox extension
    D3DVBF_3WEIGHTS3MATRICES = 4,     // Xbox extension
    D3DVBF_4WEIGHTS4MATRICES = 6,     // Xbox extension

    D3DVBF_MAX               = 7,
    D3DVBF_FORCE_DWORD       = 0x7fffffff, // force 32-bit size enum
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS 
{
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


//---------------------------------------------------------------------

/* Direct3D8 Device types */
typedef enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL         = 1,
    D3DDEVTYPE_REF         = 2,
    D3DDEVTYPE_SW          = 3,

    D3DDEVTYPE_FORCE_DWORD  = 0x7fffffff
} D3DDEVTYPE;

/* AntiAliasing buffer types */

typedef DWORD D3DMULTISAMPLE_TYPE;

#define D3DMULTISAMPLE_NONE                                      0x0011

// Number of samples, sample type, and filter (Xbox extensions):
//
#define D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR              0x1021
#define D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX            0x1121
#define D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR   0x2021
#define D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR     0x2012
                                                              
#define D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR              0x1022
#define D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN            0x1222
#define D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR              0x2022
#define D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN            0x2222
                                                              
#define D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN            0x1233
#define D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN            0x2233
                                                                  
// Format of the pre-filter (big) color buffer (Xbox extensions):
//                                                          
#define D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT                  0x00000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5                 0x10000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5                   0x20000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8                 0x30000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8                 0x40000 

// Defaults:
//
#define D3DMULTISAMPLE_2_SAMPLES D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMULTISAMPLE_4_SAMPLES D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMULTISAMPLE_9_SAMPLES D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN

/* Types for D3DRS_MULTISAMPLEMODE and D3DRS_MULTISAMPLERENDERTARGETMODE */
typedef enum _D3DMULTISAMPLEMODE
{
    D3DMULTISAMPLEMODE_1X                                   = 0,
    D3DMULTISAMPLEMODE_2X                                   = 1,
    D3DMULTISAMPLEMODE_4X                                   = 2,

    D3DMULTISAMPLEMODE_FORCE_DWORD                          = 0x7fffffff
} D3DMULTISAMPLETYPE;


/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D16 indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */

// DOC: The numerical values for these formats have changed from D3D8
//    : to make the mapping to the NV internal format value easier.
//    : Most noteably is that D3DFMT_UNKNOWN is no longer zero.
//
typedef enum _D3DFORMAT
{
    D3DFMT_UNKNOWN              = 0xFFFFFFFF,

    /* Swizzled formats */

    D3DFMT_A8R8G8B8             = 0x00000006,
    D3DFMT_X8R8G8B8             = 0x00000007,
    D3DFMT_R5G6B5               = 0x00000005,
    D3DFMT_R6G5B5               = 0x00000027,
    D3DFMT_X1R5G5B5             = 0x00000003,
    D3DFMT_A1R5G5B5             = 0x00000002,
    D3DFMT_A4R4G4B4             = 0x00000004,
    D3DFMT_A8                   = 0x00000019,
    D3DFMT_A8B8G8R8             = 0x0000003A,   
    D3DFMT_B8G8R8A8             = 0x0000003B,   
    D3DFMT_R4G4B4A4             = 0x00000039,   
    D3DFMT_R5G5B5A1             = 0x00000038,   
    D3DFMT_R8G8B8A8             = 0x0000003C,   
    D3DFMT_R8B8                 = 0x00000029,   
    D3DFMT_G8B8                 = 0x00000028,   

    D3DFMT_P8                   = 0x0000000B,

    D3DFMT_L8                   = 0x00000000,
    D3DFMT_A8L8                 = 0x0000001A,
    D3DFMT_AL8                  = 0x00000001,   
    D3DFMT_L16                  = 0x00000032,   

    D3DFMT_V8U8                 = 0x00000028,
    D3DFMT_L6V5U5               = 0x00000027,
    D3DFMT_X8L8V8U8             = 0x00000007,
    D3DFMT_Q8W8V8U8             = 0x0000003A,
    D3DFMT_V16U16               = 0x00000033,

    D3DFMT_D16_LOCKABLE         = 0x0000002C,
    D3DFMT_D16                  = 0x0000002C,
    D3DFMT_D24S8                = 0x0000002A,
    D3DFMT_F16                  = 0x0000002D,   
    D3DFMT_F24S8                = 0x0000002B,

    /* YUV formats */

    D3DFMT_YUY2                 = 0x00000024,
    D3DFMT_UYVY                 = 0x00000025,

    /* Compressed formats */

    D3DFMT_DXT1                 = 0x0000000C,
    D3DFMT_DXT2                 = 0x0000000E,
    D3DFMT_DXT3                 = 0x0000000E,
    D3DFMT_DXT4                 = 0x0000000F,
    D3DFMT_DXT5                 = 0x0000000F,

    /* Linear formats */

    D3DFMT_LIN_A1R5G5B5         = 0x00000010,   
    D3DFMT_LIN_A4R4G4B4         = 0x0000001D,   
    D3DFMT_LIN_A8               = 0x0000001F,   
    D3DFMT_LIN_A8B8G8R8         = 0x0000003F,   
    D3DFMT_LIN_A8R8G8B8         = 0x00000012,   
    D3DFMT_LIN_B8G8R8A8         = 0x00000040,   
    D3DFMT_LIN_G8B8             = 0x00000017,   
    D3DFMT_LIN_R4G4B4A4         = 0x0000003E,   
    D3DFMT_LIN_R5G5B5A1         = 0x0000003D,   
    D3DFMT_LIN_R5G6B5           = 0x00000011,   
    D3DFMT_LIN_R6G5B5           = 0x00000037,   
    D3DFMT_LIN_R8B8             = 0x00000016,   
    D3DFMT_LIN_R8G8B8A8         = 0x00000041,   
    D3DFMT_LIN_X1R5G5B5         = 0x0000001C,   
    D3DFMT_LIN_X8R8G8B8         = 0x0000001E,   

    D3DFMT_LIN_A8L8             = 0x00000020,   
    D3DFMT_LIN_AL8              = 0x0000001B,   
    D3DFMT_LIN_L16              = 0x00000035,   
    D3DFMT_LIN_L8               = 0x00000013,   

    D3DFMT_LIN_V16U16           = 0x00000036,
    D3DFMT_LIN_V8U8             = 0x00000017,
    D3DFMT_LIN_L6V5U5           = 0x00000037,
    D3DFMT_LIN_X8L8V8U8         = 0x0000001E,
    D3DFMT_LIN_Q8W8V8U8         = 0x00000012,

    D3DFMT_LIN_D24S8            = 0x0000002E,   
    D3DFMT_LIN_F24S8            = 0x0000002F,   
    D3DFMT_LIN_D16              = 0x00000030,   
    D3DFMT_LIN_F16              = 0x00000031,   

    D3DFMT_VERTEXDATA           = 100,
    D3DFMT_INDEX16              = 101,

    D3DFMT_FORCE_DWORD          =0x7fffffff
} D3DFORMAT;

/* Display mode flags */

#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER      0x00000001
#define D3DPRESENTFLAG_WIDESCREEN               0x00000010
#define D3DPRESENTFLAG_INTERLACED               0x00000020
#define D3DPRESENTFLAG_PROGRESSIVE              0x00000040
#define D3DPRESENTFLAG_FIELD                    0x00000080
#define D3DPRESENTFLAG_10X11PIXELASPECTRATIO    0x00000100

/* Display Modes */
typedef struct _D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    DWORD           Flags;
    D3DFORMAT       Format;
} D3DDISPLAYMODE;

/* Creation Parameters */
typedef struct _D3DDEVICE_CREATION_PARAMETERS
{
    UINT            AdapterOrdinal;
    D3DDEVTYPE      DeviceType;
    HWND            hFocusWindow;
    DWORD           BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;


/* SwapEffects */
typedef enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD           = 1,
    D3DSWAPEFFECT_FLIP              = 2,
    D3DSWAPEFFECT_COPY              = 3,
    D3DSWAPEFFECT_COPY_VSYNC        = 4,

    D3DSWAPEFFECT_FORCE_DWORD       = 0x7fffffff
} D3DSWAPEFFECT;

/* Swap flags (Xbox extension) */
#define D3DSWAP_COPY                0x00000001L
#define D3DSWAP_BYPASSCOPY          0x00000002L
#define D3DSWAP_FINISH              0x00000004L

#define D3DSWAP_DEFAULT             0x00000000L

/* Insert Callback (Xbox extension) */
typedef enum _D3DCALLBACKTYPE
{
    D3DCALLBACK_READ                = 0,
    D3DCALLBACK_WRITE               = 1,

    D3DCALLBACKTYPE_FORCE_DWORD     = 0x7fffffff
} D3DCALLBACKTYPE;

/* VBlank data (Xbox extension) */
#define D3DVBLANK_SWAPDONE          0x00000001L
#define D3DVBLANK_SWAPMISSED        0x00000002L

typedef struct _D3DVBLANKDATA
{
    DWORD           VBlank;
    DWORD           Swap;
    DWORD           Flags;
} D3DVBLANKDATA;

/* Swap data (Xbox extension) */
typedef struct _D3DSWAPDATA
{
    DWORD           Swap;
    DWORD           SwapVBlank;
    DWORD           MissedVBlanks;
    DWORD           TimeUntilSwapVBlank;
    DWORD           TimeBetweenSwapVBlanks;
} D3DSWAPDATA;

/* Pool types */

// DOC: All parameters typed as D3DPOOL will be ignored.  Change the type from an enum
//  : to a DWORD so developers can cheat and just pass '0' for this value.

typedef DWORD D3DPOOL;

#define D3DPOOL_DEFAULT             0
#define D3DPOOL_MANAGED             1
#define D3DPOOL_SYSTEMMEM           2

/* RefreshRate pre-defines */
#define D3DPRESENT_RATE_DEFAULT         0x00000000
#define D3DPRESENT_RATE_UNLIMITED       0x00000000


/* Reset and CreateDevice Parameters */
typedef struct _D3DPRESENT_PARAMETERS_
{
    UINT                BackBufferWidth;
    UINT                BackBufferHeight;
    D3DFORMAT           BackBufferFormat;
    UINT                BackBufferCount;
    D3DMULTISAMPLE_TYPE MultiSampleType;
    D3DSWAPEFFECT       SwapEffect;
    HWND                hDeviceWindow;
    BOOL                Windowed;
    BOOL                EnableAutoDepthStencil;
    D3DFORMAT           AutoDepthStencilFormat;
    DWORD               Flags;
    UINT                FullScreen_RefreshRateInHz; 
    UINT                FullScreen_PresentationInterval;
    D3DSurface         *BufferSurfaces[3];
    D3DSurface         *DepthStencilSurface;

} D3DPRESENT_PARAMETERS;

/* Gamma Ramp: Xbox changes WORD values to BYTE */

typedef struct _D3DGAMMARAMP
{
    BYTE                red  [256];
    BYTE                green[256];
    BYTE                blue [256];
} D3DGAMMARAMP;

/* Back buffer types */
typedef DWORD D3DBACKBUFFER_TYPE;

#define D3DBACKBUFFER_TYPE_MONO   0


/* Types */
typedef enum _D3DRESOURCETYPE 
{
    D3DRTYPE_NONE                   =  0,
    D3DRTYPE_SURFACE                =  1,
    D3DRTYPE_VOLUME                 =  2,
    D3DRTYPE_TEXTURE                =  3,
    D3DRTYPE_VOLUMETEXTURE          =  4,
    D3DRTYPE_CUBETEXTURE            =  5,
    D3DRTYPE_VERTEXBUFFER           =  6,
    D3DRTYPE_INDEXBUFFER            =  7,
    D3DRTYPE_PUSHBUFFER             =  8,
    D3DRTYPE_PALETTE                =  9,
    D3DRTYPE_FIXUP                  =  10,

    D3DRTYPE_FORCE_DWORD            = 0x7fffffff
} D3DRESOURCETYPE;

/* Locations */

// Enumeration used for memory movement (Xbox extension)
//
typedef enum _D3DMEMORY 
{
    D3DMEM_AGP                      = 0,
    D3DMEM_VIDEO                    = 1
} D3DMEMORY;

/* Usages */
#define D3DUSAGE_RENDERTARGET           (0x00000001L)
#define D3DUSAGE_DEPTHSTENCIL           (0x00000002L)

/* Usages for Vertex/Index buffers */
#define D3DUSAGE_WRITEONLY              (0x00000008L)
#define D3DUSAGE_POINTS                 (0x00000040L)
#define D3DUSAGE_RTPATCHES              (0x00000080L)
#define D3DUSAGE_DYNAMIC                (0x00000200L)

/* Usages for CreateVertexShader */
#define D3DUSAGE_PERSISTENTDIFFUSE      (0x00000400L)   // Xbox extension
#define D3DUSAGE_PERSISTENTSPECULAR     (0x00000800L)   // Xbox extension
#define D3DUSAGE_PERSISTENTBACKDIFFUSE  (0x00001000L)   // Xbox extension
#define D3DUSAGE_PERSISTENTBACKSPECULAR (0x00002000L)   // Xbox extension

/* Usages for CreateTexture/CreateImageSurface */
#define D3DUSAGE_BORDERSOURCE_COLOR     (0x00000000L)   // Xbox extension
#define D3DUSAGE_BORDERSOURCE_TEXTURE   (0x00010000L)   // Xbox extension


/* CubeMap Face identifiers */
typedef enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X     = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X     = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y     = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y     = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z     = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z     = 5,

    D3DCUBEMAP_FACE_FORCE_DWORD    = 0x7fffffff
} D3DCUBEMAP_FACES;


/* Lock flags */

#define D3DLOCK_NOFLUSH             0x00000010L // Xbox extension
#define D3DLOCK_NOOVERWRITE         0x00000020L 
#define D3DLOCK_TILED               0x00000040L // Xbox extension
#define D3DLOCK_READONLY            0x00000080L

// D3DLOCK_NOSYSLOCK not supported on Xbox
// D3DLOCK_NO_DIRTY_UPDATE not supported on Xbox
// D3DLOCK_DISCARD not supported on Xbox 
//
//     (NOTE: The lack of D3DLOCK_DISCARD support can cause significant 
//      performance degradation for the unwary.  See the documentation
//      for notes on using IsBusy or fences in order to manage your own
//      pool of temporary vertex buffers when generating vertex data
//      dynamically.)

/* Vertex Buffer Description */
typedef struct _D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;

} D3DVERTEXBUFFER_DESC;

/* Index Buffer Description */
typedef struct _D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
} D3DINDEXBUFFER_DESC;


/* Surface Description */
typedef struct _D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC;

typedef struct _D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC;

/* Structure for LockRect */
typedef struct _D3DLOCKED_RECT
{
    INT                 Pitch;
    void*               pBits;
} D3DLOCKED_RECT;

/* Structures for LockBox */
typedef struct _D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX;

typedef struct _D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    void*               pBits;
} D3DLOCKED_BOX;

/* Structures for high order primitives */
typedef struct _D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DRECTPATCH_INFO;

typedef struct _D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DTRIPATCH_INFO;

/* Adapter Identifier */
#define MAX_DEVICE_IDENTIFIER_STRING        512
typedef struct _D3DADAPTER_IDENTIFIER8
{
    char            Driver[MAX_DEVICE_IDENTIFIER_STRING];
    char            Description[MAX_DEVICE_IDENTIFIER_STRING];

#ifdef _WIN32
    LARGE_INTEGER   DriverVersion;            /* Defined for 32 bit components */
#else
    DWORD           DriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD           DriverVersionHighPart;
#endif

    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;

    GUID            DeviceIdentifier;

    DWORD           WHQLLevel;

} D3DADAPTER_IDENTIFIER8;


/* Raster Status structure returned by GetRasterStatus */
typedef struct _D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS;


/* Field Type enum defines possible values for a display field */
typedef enum _D3DFIELDTYPE                      // Xbox extension
{                    
    D3DFIELD_ODD            = 1,
    D3DFIELD_EVEN           = 2,
    D3DFIELD_PROGRESSIVE    = 3,
    D3DFIELD_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DFIELDTYPE;


/* Field Status structure is returned by GetDisplayFieldStatus */
typedef struct _D3DFIELD_STATUS                 // Xbox extension
{
    D3DFIELDTYPE   Field;
    UINT           VBlankCount;
} D3DFIELD_STATUS;


/* SetVertexInput struct */
typedef struct _D3DSTREAM_INPUT                 // Xbox extension
{
    D3DVertexBuffer    *VertexBuffer;
    UINT                Stride;
    UINT                Offset;
} D3DSTREAM_INPUT;


/* Maximum number of scissors rectangles */     
#define D3DSCISSORS_MAX             8

/* D3DTILE constants */
#define D3DTILE_MAXTILES            8
#define D3DTILE_MAXTAGS             76800
#define D3DTILE_TAGSIZE             64
#define D3DTILE_ALIGNMENT           0x4000

/* D3DTILE macro for calculating the end tag for a Z-compressed tile */
#define D3DTILE_ZENDTAG(pTile) ((((pTile)->ZStartTag + ((pTile)->Size / D3DTILE_TAGSIZE)) + 255) & ~255)

/* D3DTILE Flags */
#define D3DTILE_FLAGS_ZBUFFER       0x00000001
#define D3DTILE_FLAGS_ZCOMPRESS     0x80000000
#define D3DTILE_FLAGS_Z32BITS       0x04000000
#define D3DTILE_FLAGS_Z16BITS       0x00000000

/* D3DTILE Pitch values */
#define D3DTILE_PITCH_0200          0x0200
#define D3DTILE_PITCH_0300          0x0300
#define D3DTILE_PITCH_0400          0x0400
#define D3DTILE_PITCH_0500          0x0500
#define D3DTILE_PITCH_0600          0x0600
#define D3DTILE_PITCH_0700          0x0700
#define D3DTILE_PITCH_0800          0x0800
#define D3DTILE_PITCH_0A00          0x0A00
#define D3DTILE_PITCH_0C00          0x0C00
#define D3DTILE_PITCH_0E00          0x0E00
#define D3DTILE_PITCH_1000          0x1000
#define D3DTILE_PITCH_1400          0x1400
#define D3DTILE_PITCH_1800          0x1800
#define D3DTILE_PITCH_1C00          0x1C00
#define D3DTILE_PITCH_2000          0x2000
#define D3DTILE_PITCH_2800          0x2800
#define D3DTILE_PITCH_3000          0x3000
#define D3DTILE_PITCH_3800          0x3800
#define D3DTILE_PITCH_4000          0x4000
#define D3DTILE_PITCH_5000          0x5000
#define D3DTILE_PITCH_6000          0x6000
#define D3DTILE_PITCH_7000          0x7000
#define D3DTILE_PITCH_8000          0x8000
#define D3DTILE_PITCH_A000          0xA000
#define D3DTILE_PITCH_C000          0xC000
#define D3DTILE_PITCH_E000          0xE000

/* SetTile struct */
typedef struct _D3DTILE                         // Xbox extension
{                   
    DWORD   Flags;
    void*   pMemory;
    DWORD   Size;
    DWORD   Pitch;
    DWORD   ZStartTag; 
    DWORD   ZOffset;
} D3DTILE;

/* CopyRectsState Operation values */
typedef enum _D3DCOPYRECTOPERATION
{
    D3DCOPYRECT_SRCCOPY_AND         = 0,
    D3DCOPYRECT_ROP_AND             = 1,
    D3DCOPYRECT_BLEND_AND           = 2,
    D3DCOPYRECT_SRCCOPY             = 3,
    D3DCOPYRECT_SRCCOPY_PREMULT     = 4,
    D3DCOPYRECT_BLEND_PREMULT       = 5,
    D3DCOPYRECT_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCOPYRECTOPERATION;

/* CopyRectsState Color Format values */
typedef enum _D3DCOPYRECTCOLORFORMAT
{
    D3DCOPYRECT_COLOR_FORMAT_DEFAULT                 = 0,
    D3DCOPYRECT_COLOR_FORMAT_Y8                      = 1,
    D3DCOPYRECT_COLOR_FORMAT_X1R5G5B5_Z1R5G5B5       = 2,
    D3DCOPYRECT_COLOR_FORMAT_X1R5G5B5_O1R5G5B5       = 3,
    D3DCOPYRECT_COLOR_FORMAT_R5G6B5                  = 4,
    D3DCOPYRECT_COLOR_FORMAT_Y16                     = 5,
    D3DCOPYRECT_COLOR_FORMAT_X8R8G8B8_Z8R8G8B8       = 6,
    D3DCOPYRECT_COLOR_FORMAT_X8R8G8B8_O8R8G8B8       = 7,
    D3DCOPYRECT_COLOR_FORMAT_X1A7R8G8B8_Z1A7R8G8B8   = 8,
    D3DCOPYRECT_COLOR_FORMAT_X1A7R8G8B8_O1A7R8G8B8   = 9,
    D3DCOPYRECT_COLOR_FORMAT_A8R8G8B8                = 10,
    D3DCOPYRECT_COLOR_FORMAT_Y32                     = 11,
    D3DCOPYRECT_COLOR_FORMAT_FORCE_DWORD             = 0x7fffffff, /* force 32-bit size enum */
} D3DCOPYRECTCOLORFORMAT;

/* CopyRectsState struct */
typedef struct _D3DCOPYRECTSTATE                // Xbox extension
{
    D3DCOPYRECTCOLORFORMAT ColorFormat;
    D3DCOPYRECTOPERATION Operation;

    BOOL ColorKeyEnable;
    DWORD ColorKeyValue;

    // D3DCOPYRECT_BLEND_AND alpha value 
    // The VALUE_FRACTION bits (30:21) contain the 10 bit unsigned fraction of the alpha value.
    // The VALUE bits (31:31) contain the 1 bit signed integer of the alpha value.
    DWORD BlendAlpha;

    // D3DCOPYRECT_*_PREMULT alpha value
    // Contains an alpha value for all four channels.
    DWORD PremultAlpha;

    // Clipping Rect
    DWORD ClippingPoint;    // y_x S16_S16
    DWORD ClippingSize;     // height_width U16_U16

} D3DCOPYRECTSTATE;

/* CopyRectRopState struct */
typedef struct _D3DCOPYRECTROPSTATE             // Xbox extension
{
    DWORD Rop;              // Ternary raster operation.
                            //   DSTINVERT:0x55, SRCCOPY:0xCC,
                            //   SRCPAINT:0xEE, SRCINVERT:0x66,
                            //   ...

    DWORD Shape;            // 0:8X_8Y, 1:64X_1Y, 2:1X_64Y
    DWORD PatternSelect;    // 1:monochrome, 2:color

    DWORD MonoColor0;       // Color to use when bit is "0"
    DWORD MonoColor1;       // Color to use when bit is "1" 

    DWORD MonoPattern0;     // 8x8 = 64 bit pattern
    DWORD MonoPattern1;     //

    CONST DWORD *ColorPattern;  // Color Pattern used if PatternSelect == color
                                // 32-bit: Array of 64 DWORDS
                                // 16-bit: Array of 32 DWORDS

} D3DCOPYRECTROPSTATE;

/*----------------------------------------------
/* Pixel Shader Binary Format
/*----------------------------------------------

/*---------------------------------------------------*/
/*  This structure holds all of the state necessary  */
/*  to define an Xbox Pixel Shader.  It is the       */
/*  structure generated when a pixel shader is       */
/*  assembled.  Each member of this structure        */
/*  corresponds to a D3D Renderstate that can be     */
/*  set at any time using the SetRenderState()       */
/*  method.                                          */
/*  The members of this structure have been ordered  */
/*  to enable the most efficient hardware load       */
/*  possible.                                        */
/*---------------------------------------------------*/

typedef struct _D3DPixelShaderDef
{
   DWORD    PSAlphaInputs[8];          // Alpha inputs for each stage
   DWORD    PSFinalCombinerInputsABCD; // Final combiner inputs
   DWORD    PSFinalCombinerInputsEFG;  // Final combiner inputs (continued)
   DWORD    PSConstant0[8];            // C0 for each stage
   DWORD    PSConstant1[8];            // C1 for each stage
   DWORD    PSAlphaOutputs[8];         // Alpha output for each stage
   DWORD    PSRGBInputs[8];            // RGB inputs for each stage
   DWORD    PSCompareMode;             // Compare modes for clipplane texture mode
   DWORD    PSFinalCombinerConstant0;  // C0 in final combiner
   DWORD    PSFinalCombinerConstant1;  // C1 in final combiner
   DWORD    PSRGBOutputs[8];           // Stage 0 RGB outputs
   DWORD    PSCombinerCount;           // Active combiner count (Stages 0-7)
   DWORD    PSTextureModes;            // Texture addressing modes
   DWORD    PSDotMapping;              // Input mapping for dot product modes
   DWORD    PSInputTexture;            // Texture source for some texture modes
   DWORD    PSC0Mapping;               // Mapping of c0 regs to D3D constants
   DWORD    PSC1Mapping;               // Mapping of c1 regs to D3D constants
   DWORD    PSFinalCombinerConstants;  // Final combiner constant mapping
} D3DPIXELSHADERDEF;

/*---------------------------------------------------------------------------*/
/*  Texture configuration - The following members of the D3DPixelShaderDef   */
/*  structure define the addressing modes of each of the four texture stages:*/
/*      PSTextureModes                                                       */
/*      PSDotMapping                                                         */
/*      PSInputTexture                                                       */
/*      PSCompareMode                                                        */
/*---------------------------------------------------------------------------*/

// =========================================================================================================
// PSTextureModes
// --------.--------.--------.---xxxxx stage0
// --------.--------.------xx.xxx----- stage1
// --------.--------.-xxxxx--.-------- stage2
// --------.----xxxx.x-------.-------- stage3

#define PS_TEXTUREMODES(t0,t1,t2,t3) (((t3)<<15)|((t2)<<10)|((t1)<<5)|(t0))

/*
Texture modes:
NONE           :stage inactive
PROJECT2D      :argb = texture(s/q, t/q)
PROJECT3D      :argb = texture(s/q, t/q, r/q)
CUBEMAP        :argb = cubemap(s,t,r)
PASSTHRU       :argb = s,t,r,q
CLIPPLANE      :pixel not drawn if s,t,r, or q < 0.  PSCompareMode affects comparison
BUMPENVMAP     :argb=texture(s+mat00*src.r+mat01*src.g,
                             t+mat10*src.r+mat11*src.g)
                mat00 set via D3DTSS_BUMPENVMAT00, etc.
BUMPENVMAP_LUM :argb=texture(s+mat00*src.r+mat01*src.g, 
                             t+mat10*src.r+mat11*src.g) * (lum_scale*src.b + lum_bias)
                lum_scale set by D3DTSS_BUMPENVLSCALE
                lum_bias set by D3DTSS_BUMPENVLOFFSET
                mat00 set via D3DTSS_BUMPENVMAT00, etc.
BRDF           :argb = texture(eyeSigma, lightSigma, dPhi)
                       eyeSigma = Sigma of eye vector in spherical coordinates
                       lightSigma = Sigma of light vector in spherical coordinates
                       dPhi = Phi of eye - Phi of light
DOT_ST         :argb = texture(<DotResult of stage-1>, (s,t,r).(src.r,src.g,src.b))
DOT_ZW         :frag depth = (<DotResult of stage-1>/((s,t,r).(src.r,src.g,src.b))
DOT_RFLCT_DIFF :n = (<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b),<DotResult of stage+1>)
                argb = cubemap(n)
DOT_RFLCT_SPEC :n = (<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b))
                r = 2*n*(n.e)/(n.n) - e where e is eye vector built from q coord of each stage
                argb = cubemap(r)
DOT_STR_3D     :argb=texture((<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b)))
DOT_STR_CUBE   :argb=cubemap((<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b)))
DEPENDENT_AR   :argb = texture(src.a, src.r) 
DEPENDENT_GB   :argb = texture(src.g, src.b)
DOTPRODUCT     :argb = (s,t,r).(src.r,src.g,src.b)
DOT_RFLCT_SPEC_CONST :n = (<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b))
                r = 2*n*(n.e)/(n.n) - e where e is eye vector set via SetEyeVector()
                argb = cubemap(r)
*/

enum PS_TEXTUREMODES
{                                 // valid in stage 0 1 2 3
    PS_TEXTUREMODES_NONE=                 0x00L, // * * * *
    PS_TEXTUREMODES_PROJECT2D=            0x01L, // * * * *
    PS_TEXTUREMODES_PROJECT3D=            0x02L, // * * * *
    PS_TEXTUREMODES_CUBEMAP=              0x03L, // * * * *
    PS_TEXTUREMODES_PASSTHRU=             0x04L, // * * * *
    PS_TEXTUREMODES_CLIPPLANE=            0x05L, // * * * *
    PS_TEXTUREMODES_BUMPENVMAP=           0x06L, // - * * *
    PS_TEXTUREMODES_BUMPENVMAP_LUM=       0x07L, // - * * *
    PS_TEXTUREMODES_BRDF=                 0x08L, // - - * *
    PS_TEXTUREMODES_DOT_ST=               0x09L, // - - * *
    PS_TEXTUREMODES_DOT_ZW=               0x0aL, // - - * *
    PS_TEXTUREMODES_DOT_RFLCT_DIFF=       0x0bL, // - - * -
    PS_TEXTUREMODES_DOT_RFLCT_SPEC=       0x0cL, // - - - *
    PS_TEXTUREMODES_DOT_STR_3D=           0x0dL, // - - - *
    PS_TEXTUREMODES_DOT_STR_CUBE=         0x0eL, // - - - *
    PS_TEXTUREMODES_DPNDNT_AR=            0x0fL, // - * * *
    PS_TEXTUREMODES_DPNDNT_GB=            0x10L, // - * * *
    PS_TEXTUREMODES_DOTPRODUCT=           0x11L, // - * * -
    PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST= 0x12L, // - - - *
    // 0x13-0x1f reserved
};


// =========================================================================================================
// PSDotMapping
// --------.--------.--------.-----xxx // stage1
// --------.--------.--------.-xxx---- // stage2
// --------.--------.-----xxx.-------- // stage3

#define PS_DOTMAPPING(t0,t1,t2,t3) (((t3)<<8)|((t2)<<4)|(t1))

// Mappings:
// ZERO_TO_ONE         :rgb->(r,g,b): 0x0=>0.0, 0xff=>1.0
// MINUS1_TO_1_D3D     :rgb->(r,g,b): 0x0=>-128/127, 0x01=>-1.0, 0x80=>0.0, 0xff=>1.0
// MINUS1_TO_1_GL      :rgb->(r,g,b): 0x80=>-1.0, 0x7f=>1.0
// MINUS1_TO_1         :rgb->(r,g,b): 0x80=>-128/127, 0x81=>-1.0, 0x0=>0.0, 0x7f=>1.0
// HILO_1              :HL->(H,L,1.0): 0x0000=>0.0, 0xffff=>1.0
// HILO_HEMISPHERE_D3D :HL->(H,L,sqrt(1-H*H-L*L)): 0x8000=>-1.0, 0x0=>0.0, 0x7fff=32767/32768
// HILO_HEMISPHERE_GL  :HL->(H,L,sqrt(1-H*H-L*L)): 0x8000=>-1.0, 0x7fff=>1.0
// HILO_HEMISPHERE     :HL->(H,L,sqrt(1-H*H-L*L)): 0x8001=>-1.0, 0x0=>0.0, 0x7fff=>1.0, 0x8000=>-32768/32767

enum PS_DOTMAPPING
{                              // valid in stage 0 1 2 3
    PS_DOTMAPPING_ZERO_TO_ONE=         0x00L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1_D3D=     0x01L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1_GL=      0x02L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1=         0x03L, // - * * *
    PS_DOTMAPPING_HILO_1=              0x04L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE_D3D= 0x05L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE_GL=  0x06L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE=     0x07L, // - * * *
};

// =========================================================================================================
// PSCompareMode
// --------.--------.--------.----xxxx // stage0
// --------.--------.--------.xxxx---- // stage1
// --------.--------.----xxxx.-------- // stage2
// --------.--------.xxxx----.-------- // stage3

#define PS_COMPAREMODE(t0,t1,t2,t3) (((t3)<<12)|((t2)<<8)|((t1)<<4)|(t0))

enum PS_COMPAREMODE
{
    PS_COMPAREMODE_S_LT= 0x00L,
    PS_COMPAREMODE_S_GE= 0x01L,
    
    PS_COMPAREMODE_T_LT= 0x00L,
    PS_COMPAREMODE_T_GE= 0x02L,
    
    PS_COMPAREMODE_R_LT= 0x00L,
    PS_COMPAREMODE_R_GE= 0x04L,
    
    PS_COMPAREMODE_Q_LT= 0x00L,
    PS_COMPAREMODE_Q_GE= 0x08L,
};

// =========================================================================================================
// PSInputTexture
// --------.-------x.--------.-------- // stage2
// --------.--xx----.--------.-------- // stage3
//
// Selects the other texture to use as an input in the following texture modes:
// DOT_ST, DOT_STR_3D, DOT_STR_CUBE, DOT_ZW, DOT_RFLCT_SPEC, 
// DOT_RFLCT_DIFF, DPNDNT_AR, DPNDNT_GB, BUMPENVMAP,
// BUMPENVMAP_LUM, DOT_PRODUCT

#define PS_INPUTTEXTURE(t0,t1,t2,t3) (((t3)<<20)|((t2)<<16))


/*---------------------------------------------------------------------------------*/
/*  Color combiners - The following members of the D3DPixelShaderDef structure     */
/*  define the state for the eight stages of color combiners:                      */
/*      PSCombinerCount - Number of stages                                         */
/*      PSAlphaInputs[8] - Inputs for alpha portion of each stage                  */
/*      PSRGBInputs[8] - Inputs for RGB portion of each stage                      */
/*      PSConstant0[8] - Constant 0 for each stage                                 */
/*      PSConstant1[8] - Constant 1 for each stage                                 */
/*      PSFinalCombinerConstant0 - Constant 0 for final combiner                   */
/*      PSFinalCombinerConstant1 - Constant 1 for final combiner                   */
/*      PSAlphaOutputs[8] - Outputs for alpha portion of each stage                */
/*      PSRGBOutputs[8] - Outputs for RGB portion of each stage                    */
/*---------------------------------------------------------------------------------*/


// =========================================================================================================
// PSCombinerCount
// --------.--------.--------.----xxxx // number of combiners (1-8)
// --------.--------.-------x.-------- // mux bit (0= LSB, 1= MSB)
// --------.--------.---x----.-------- // separate C0
// --------.-------x.--------.-------- // separate C1

#define PS_COMBINERCOUNT(count, flags) (((flags)<<8)|(count))
// count is 1-8, flags contains one or more values from PS_COMBINERCOUNTFLAGS

enum PS_COMBINERCOUNTFLAGS
{
    PS_COMBINERCOUNT_MUX_LSB=     0x0000L, // mux on r0.a lsb
    PS_COMBINERCOUNT_MUX_MSB=     0x0001L, // mux on r0.a msb
    
    PS_COMBINERCOUNT_SAME_C0=     0x0000L, // c0 same in each stage
    PS_COMBINERCOUNT_UNIQUE_C0=   0x0010L, // c0 unique in each stage
    
    PS_COMBINERCOUNT_SAME_C1=     0x0000L, // c1 same in each stage
    PS_COMBINERCOUNT_UNIQUE_C1=   0x0100L  // c1 unique in each stage
};


// =========================================================================================================
// PSRGBInputs[0-7]
// PSAlphaInputs[0-7]
// PSFinalCombinerInputsABCD
// PSFinalCombinerInputsEFG
// --------.--------.--------.----xxxx // D register
// --------.--------.--------.---x---- // D channel (0= RGB/BLUE, 1= ALPHA)
// --------.--------.--------.xxx----- // D input mapping
// --------.--------.----xxxx.-------- // C register
// --------.--------.---x----.-------- // C channel (0= RGB/BLUE, 1= ALPHA)
// --------.--------.xxx-----.-------- // C input mapping
// --------.----xxxx.--------.-------- // B register
// --------.---x----.--------.-------- // B channel (0= RGB/BLUE, 1= ALPHA)
// --------.xxx-----.--------.-------- // B input mapping
// ----xxxx.--------.--------.-------- // A register
// ---x----.--------.--------.-------- // A channel (0= RGB/BLUE, 1= ALPHA)
// xxx-----.--------.--------.-------- // A input mapping

// examples:
// 
// shader.PSRGBInputs[3]= PS_COMBINERINPUTS(
//     PS_REGISTER_T0 | PS_INPUTMAPPING_EXPAND_NORMAL     | PS_CHANNEL_RGB,
//     PS_REGISTER_C0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
//     PS_REGISTER_ZERO,
//     PS_REGISTER_ZERO);
// 
// shader.PSFinalCombinerInputsABCD= PS_COMBINERINPUTS(
//     PS_REGISTER_T0     | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
//     PS_REGISTER_ZERO   | PS_INPUTMAPPING_EXPAND_NORMAL     | PS_CHANNEL_RGB,
//     PS_REGISTER_EFPROD | PS_INPUTMAPPING_UNSIGNED_INVERT   | PS_CHANNEL_RGB,
//     PS_REGISTER_ZERO);
//
// PS_FINALCOMBINERSETTING is set in 4th field of PSFinalCombinerInputsEFG with PS_COMBINERINPUTS
// example:
// 
// shader.PSFinalCombinerInputsEFG= PS_COMBINERINPUTS(
//     PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
//     PS_REGISTER_R1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
//     PS_REGISTER_R1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_BLUE,
//    PS_FINALCOMBINERSETTING_CLAMP_SUM | PS_FINALCOMBINERSETTING_COMPLEMENT_R0);

#define PS_COMBINERINPUTS(a,b,c,d) (((a)<<24)|((b)<<16)|((c)<<8)|(d))
// For PSFinalCombinerInputsEFG,
//     a,b,c contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING for input E,F, and G
//     d contains values from PS_FINALCOMBINERSETTING
// For all other inputs,
//     a,b,c,d each contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING

enum PS_INPUTMAPPING
{
    PS_INPUTMAPPING_UNSIGNED_IDENTITY= 0x00L, // max(0,x)         OK for final combiner
    PS_INPUTMAPPING_UNSIGNED_INVERT=   0x20L, // 1 - max(0,x)     OK for final combiner
    PS_INPUTMAPPING_EXPAND_NORMAL=     0x40L, // 2*max(0,x) - 1   invalid for final combiner
    PS_INPUTMAPPING_EXPAND_NEGATE=     0x60L, // 1 - 2*max(0,x)   invalid for final combiner
    PS_INPUTMAPPING_HALFBIAS_NORMAL=   0x80L, // max(0,x) - 1/2   invalid for final combiner
    PS_INPUTMAPPING_HALFBIAS_NEGATE=   0xa0L, // 1/2 - max(0,x)   invalid for final combiner
    PS_INPUTMAPPING_SIGNED_IDENTITY=   0xc0L, // x                invalid for final combiner
    PS_INPUTMAPPING_SIGNED_NEGATE=     0xe0L, // -x               invalid for final combiner
};

enum PS_REGISTER
{
    PS_REGISTER_ZERO=              0x00L, // r    
    PS_REGISTER_DISCARD=           0x00L, // w
    PS_REGISTER_C0=                0x01L, // r
    PS_REGISTER_C1=                0x02L, // r
    PS_REGISTER_FOG=               0x03L, // r
    PS_REGISTER_V0=                0x04L, // r/w  
    PS_REGISTER_V1=                0x05L, // r/w
    PS_REGISTER_T0=                0x08L, // r/w
    PS_REGISTER_T1=                0x09L, // r/w
    PS_REGISTER_T2=                0x0aL, // r/w
    PS_REGISTER_T3=                0x0bL, // r/w
    PS_REGISTER_R0=                0x0cL, // r/w
    PS_REGISTER_R1=                0x0dL, // r/w
    PS_REGISTER_V1R0_SUM=          0x0eL, // r
    PS_REGISTER_EF_PROD=           0x0fL, // r
    
    PS_REGISTER_ONE=               PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT, // OK for final combiner
    PS_REGISTER_NEGATIVE_ONE=      PS_REGISTER_ZERO | PS_INPUTMAPPING_EXPAND_NORMAL,   // invalid for final combiner
    PS_REGISTER_ONE_HALF=          PS_REGISTER_ZERO | PS_INPUTMAPPING_HALFBIAS_NEGATE, // invalid for final combiner
    PS_REGISTER_NEGATIVE_ONE_HALF= PS_REGISTER_ZERO | PS_INPUTMAPPING_HALFBIAS_NORMAL, // invalid for final combiner
};

// FOG ALPHA is only available in final combiner
// V1R0_SUM and EF_PROD are only available in final combiner (A,B,C,D inputs only)
// V1R0_SUM_ALPHA and EF_PROD_ALPHA are not available
// R0_ALPHA is initialized to T0_ALPHA in stage0

enum PS_CHANNEL
{
    PS_CHANNEL_RGB=   0x00, // used as RGB source
    PS_CHANNEL_BLUE=  0x00, // used as ALPHA source
    PS_CHANNEL_ALPHA= 0x10, // used as RGB or ALPHA source
};


enum PS_FINALCOMBINERSETTING
{
    PS_FINALCOMBINERSETTING_CLAMP_SUM=     0x80, // V1+R0 sum clamped to [0,1]
    
    PS_FINALCOMBINERSETTING_COMPLEMENT_V1= 0x40, // unsigned invert mapping
    
    PS_FINALCOMBINERSETTING_COMPLEMENT_R0= 0x20, // unsigned invert mapping
};

// =========================================================================================================
// PSRGBOutputs[0-7]
// PSAlphaOutputs[0-7]
// --------.--------.--------.----xxxx // CD register
// --------.--------.--------.xxxx---- // AB register
// --------.--------.----xxxx.-------- // SUM register
// --------.--------.---x----.-------- // CD output (0= multiply, 1= dot product)
// --------.--------.--x-----.-------- // AB output (0= multiply, 1= dot product)
// --------.--------.-x------.-------- // AB_CD mux/sum select (0= sum, 1= mux)
// --------.------xx.x-------.-------- // Output mapping
// --------.-----x--.--------.-------- // CD blue to alpha
// --------.----x---.--------.-------- // AB blue to alpha

#define PS_COMBINEROUTPUTS(ab,cd,mux_sum,flags) (((flags)<<12)|((mux_sum)<<8)|((ab)<<4)|(cd))
// ab,cd,mux_sum contain a value from PS_REGISTER
// flags contains values from PS_COMBINEROUTPUT

enum PS_COMBINEROUTPUT
{
    PS_COMBINEROUTPUT_IDENTITY=            0x00L, // y = x        
    PS_COMBINEROUTPUT_BIAS=                0x08L, // y = x - 0.5  
    PS_COMBINEROUTPUT_SHIFTLEFT_1=         0x10L, // y = x*2      
    PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS=    0x18L, // y = (x - 0.5)*2
    PS_COMBINEROUTPUT_SHIFTLEFT_2=         0x20L, // y = x*4      
    PS_COMBINEROUTPUT_SHIFTRIGHT_1=        0x30L, // y = x/2      
    
    PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA=    0x80L, // RGB only
    
    PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA=    0x40L, // RGB only
    
    PS_COMBINEROUTPUT_AB_MULTIPLY=         0x00L,
    PS_COMBINEROUTPUT_AB_DOT_PRODUCT=      0x02L, // RGB only
    
    PS_COMBINEROUTPUT_CD_MULTIPLY=         0x00L,
    PS_COMBINEROUTPUT_CD_DOT_PRODUCT=      0x01L, // RGB only
    
    PS_COMBINEROUTPUT_AB_CD_SUM=           0x00L, // 3rd output is AB+CD
    PS_COMBINEROUTPUT_AB_CD_MUX=           0x04L, // 3rd output is MUX(AB,CD) based on R0.a
};

// AB_CD register output must be DISCARD if either AB_DOT_PRODUCT or CD_DOT_PRODUCT are set

// =========================================================================================================
// PSC0Mapping
// PSC1Mapping
// --------.--------.--------.----xxxx // offset of D3D constant for stage 0
// --------.--------.--------.xxxx---- // offset of D3D constant for stage 1
// --------.--------.----xxxx.-------- // offset of D3D constant for stage 2
// --------.--------.xxxx----.-------- // offset of D3D constant for stage 3
// --------.----xxxx.--------.-------- // offset of D3D constant for stage 4
// --------.xxxx----.--------.-------- // offset of D3D constant for stage 5
// ----xxxx.--------.--------.-------- // offset of D3D constant for stage 6
// xxxx----.--------.--------.-------- // offset of D3D constant for stage 7

#define PS_CONSTANTMAPPING(s0,s1,s2,s3,s4,s5,s6,s7) \
     (((DWORD)(s0)&0xf)<< 0) | (((DWORD)(s1)&0xf)<< 4) | \
     (((DWORD)(s2)&0xf)<< 8) | (((DWORD)(s3)&0xf)<<12) | \
     (((DWORD)(s4)&0xf)<<16) | (((DWORD)(s5)&0xf)<<20) | \
     (((DWORD)(s6)&0xf)<<24) | (((DWORD)(s7)&0xf)<<28) 
// s0-s7 contain the offset of the D3D constant that corresponds to the 
// c0 or c1 constant in stages 0 through 7.  These mappings are only used in 
// SetPixelShaderConstant().
   
// =========================================================================================================
// PSFinalCombinerConstants
// --------.--------.--------.----xxxx // offset of D3D constant for C0
// --------.--------.--------.xxxx---- // offset of D3D constant for C1
// --------.--------.-------x.-------- // Adjust texture flag

#define PS_FINALCOMBINERCONSTANTS(c0,c1,flags) (((DWORD)(flags) << 8) | ((DWORD)(c0)&0xf)<< 0) | (((DWORD)(c1)&0xf)<< 4)
// c0 and c1 contain the offset of the D3D constant that corresponds to the
// constants in the final combiner.  These mappings are only used in 
// SetPixelShaderConstant().  Flags contains values from PS_GLOBALFLAGS

enum PS_GLOBALFLAGS
{
    // if this flag is set, the texture mode for each texture stage is adjusted as follows:
    //     if set texture is a cubemap, 
    //         change PS_TEXTUREMODES_PROJECT2D to PS_TEXTUREMODES_CUBEMAP
    //         change PS_TEXTUREMODES_PROJECT3D to PS_TEXTUREMODES_CUBEMAP
    //         change PS_TEXTUREMODES_DOT_STR_3D to PS_TEXTUREMODES_DOT_STR_CUBE
    //     if set texture is a volume texture, 
    //         change PS_TEXTUREMODES_PROJECT2D to PS_TEXTUREMODES_PROJECT3D
    //         change PS_TEXTUREMODES_CUBEMAP to PS_TEXTUREMODES_PROJECT3D
    //         change PS_TEXTUREMODES_DOT_STR_CUBE to PS_TEXTUREMODES_DOT_STR_3D
    //     if set texture is neither cubemap or volume texture, 
    //         change PS_TEXTUREMODES_PROJECT3D to PS_TEXTUREMODES_PROJECT2D
    //         change PS_TEXTUREMODES_CUBEMAP to PS_TEXTUREMODES_PROJECT2D

    PS_GLOBALFLAGS_NO_TEXMODE_ADJUST=     0x0000L, // don't adjust texture modes
    PS_GLOBALFLAGS_TEXMODE_ADJUST=        0x0001L, // adjust texture modes according to set texture
};

   
typedef struct _D3DPixelShaderDefFile
{
    DWORD               FileID;         // Uniquely identifies the file as pixel shader binary
    D3DPIXELSHADERDEF   Psd;            // The pixel shader def structure
} D3DPIXELSHADERDEF_FILE;

#define D3DPIXELSHADERDEF_FILE_ID   0x30425350  // "PSB0"

/*----------------------- End of Pixel Shader Defines -----------------------*/

/*----------------------------------------------
/* Push-Buffer Binary Format
/*----------------------------------------------

/*---------------------------------------------------*/
/*  These defines describe the binary format of the  */
/*  push-buffer.  They may be used in conjunction    */
/*  with BeginPush/EndPush and RunPushBuffer.        */
/*---------------------------------------------------*/

/* Encoding support */

#define D3DPUSH_ENCODE(Method, Count)   (((Count) << 18) + (Method))
#define D3DPUSH_NOINCREMENT_FLAG        0x40000000

/* Methods */

#define D3DPUSH_SET_BEGIN_END           0x000017fc      // D3DPRIMITIVETYPE or 0 to end
#define D3DPUSH_INLINE_ARRAY            0x00001818


/*----------------------- End of Push-Buffer Defines -----------------------*/


#pragma pack()
#pragma warning(default:4201)

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8TYPES(P)_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3D8Perf.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8perf.h
 *  Content:    Xbox Direct3D debug library API
 *
 ****************************************************************************/


#ifndef _D3D8PERF_H_
#define _D3D8PERF_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * This file exposes the extra functionality implemented in the
 * performance-instrumented and debug version of the Direct3D library 
 * (d3d8i.lib and d3d8d.lib).
 */

// Enumeration of all of the non-api events that the driver counts.
typedef enum _D3DPERF_PerformanceCounters
{
    PERF_VERTICES,

    PERF_SETTRANSFORM_WORLD,
    PERF_SETTRANSFORM_VIEW,
    PERF_SETTRANSFORM_PROJECTION,
    PERF_SETTRANSFORM_TEXTURE,

    PERF_PUSHBUFFER_SEGMENTS,
    PERF_PUSHBUFFER_WAITS,
    PERF_OBJECTLOCK_WAITS,
    PERF_PRESENT_WAITS,
    PERF_D3DDEVICE_BLOCKUNTILIDLE_WAITS,
    PERF_D3DDEVICE_BLOCKUNTILVERTICALBLANK_WAITS,
    PERF_D3DDEVICE_BLOCKONFENCE_WAITS,
    PERF_CPUSPINDURINGWAIT_TIME,
    PERF_UNSWIZZLING_TEXTURE_LOCKS,
    PERF_PUSHBUFFER_JUMPTOBEGINNING,
    PERF_RUNPUSHBUFFER_BYTES,

    PERF_REDUNDANT_SETRENDERSTATE,
    PERF_REDUNDANT_SETTEXTURESTATE,
    PERF_REDUNDANT_SETVERTEXSHADER,
    PERF_REDUNDANT_SETTRANSFORM,
    PERF_REDUNDANT_SETTEXTURE,
    PERF_REDUNDANT_SETPALETTE,
    PERF_REDUNDANT_SETSTREAMSOURCE,

    PERF_SETSTATE_POINTPARAMS,
    PERF_SETSTATE_COMBINERS,
    PERF_SETSTATE_TEXTURESTATE,
    PERF_SETSTATE_SPECFOGCOMBINER,
    PERF_SETSTATE_TEXTRANSFORM,
    PERF_SETSTATE_LIGHTS,
    PERF_SETSTATE_TRANSFORM,

    D3DPERF_MAX,
    D3DPERF_FORCE_LONG  =   0xFFFFFFFF

} D3DPERF_PerformanceCounters;

// Counts of the number of times each API is called.
typedef enum _D3DPERF_APICounters
{

    /* Direct3D APIs */

    API_DIRECT3D_CHECKDEPTHSTENCILMATCH,
    API_DIRECT3D_CHECKDEVICEFORMAT,
    API_DIRECT3D_CHECKDEVICEMULTISAMPLETYPE,
    API_DIRECT3D_CHECKDEVICETYPE,
    API_DIRECT3D_CREATEDEVICE,
    API_DIRECT3D_ENUMADAPTERMODES,
    API_DIRECT3D_GETADAPTERDISPLAYMODE,
    API_DIRECT3D_GETADAPTERIDENTIFIER,
    API_DIRECT3D_GETADAPTERMODECOUNT,
    API_DIRECT3D_GETDEVICECAPS,
    API_DIRECT3D_SETPUSHBUFFERSIZE,

    /* D3DDevice APIs */

    API_D3DDEVICE_APPLYSTATEBLOCK,
    API_D3DDEVICE_BEGIN,
    API_D3DDEVICE_BEGINPUSH,
    API_D3DDEVICE_BEGINPUSHBUFFER,
    API_D3DDEVICE_BEGINSTATEBLOCK,
    API_D3DDEVICE_BEGINVISIBILITYTEST,
    API_D3DDEVICE_BLOCKONFENCE,
    API_D3DDEVICE_BLOCKUNTILIDLE,
    API_D3DDEVICE_BLOCKUNTILVERTICALBLANK,
    API_D3DDEVICE_CAPTURESTATEBLOCK,
    API_D3DDEVICE_CLEAR,
    API_D3DDEVICE_COPYRECTS,
    API_D3DDEVICE_CREATECUBETEXTURE,
    API_D3DDEVICE_CREATEDEPTHSTENCILSURFACE,
    API_D3DDEVICE_CREATEFIXUP,
    API_D3DDEVICE_CREATEIMAGESURFACE,
    API_D3DDEVICE_CREATEINDEXBUFFER,
    API_D3DDEVICE_CREATEPALETTE,
    API_D3DDEVICE_CREATEPIXELSHADER,
    API_D3DDEVICE_CREATEPUSHBUFFER,
    API_D3DDEVICE_CREATERENDERTARGET,
    API_D3DDEVICE_CREATESTATEBLOCK,
    API_D3DDEVICE_CREATETEXTURE,
    API_D3DDEVICE_CREATEVERTEXBUFFER,
    API_D3DDEVICE_CREATEVERTEXSHADER,
    API_D3DDEVICE_CREATEVOLUMETEXTURE,
    API_D3DDEVICE_DELETEPATCH,
    API_D3DDEVICE_DELETEPIXELSHADER,
    API_D3DDEVICE_DELETESTATEBLOCK,
    API_D3DDEVICE_DELETEVERTEXSHADER,
    API_D3DDEVICE_DRAWINDEXEDVERTICES,
    API_D3DDEVICE_DRAWINDEXEDVERTICESUP,
    API_D3DDEVICE_DRAWRECTPATCH,
    API_D3DDEVICE_DRAWTRIPATCH,
    API_D3DDEVICE_DRAWVERTICES,
    API_D3DDEVICE_DRAWVERTICESUP,
    API_D3DDEVICE_ENABLECC,
    API_D3DDEVICE_ENABLEOVERLAY,
    API_D3DDEVICE_END,
    API_D3DDEVICE_ENDPUSH,
    API_D3DDEVICE_ENDPUSHBUFFER,
    API_D3DDEVICE_ENDSTATEBLOCK,
    API_D3DDEVICE_ENDVISIBILITYTEST,
    API_D3DDEVICE_FLUSHVERTEXCACHE,
    API_D3DDEVICE_GETBACKBUFFER,
    API_D3DDEVICE_GETBACKBUFFERSCALE,
    API_D3DDEVICE_GETBACKMATERIAL,
    API_D3DDEVICE_GETCCSTATUS,
    API_D3DDEVICE_GETCREATIONPARAMETERS,
    API_D3DDEVICE_GETDEPTHSTENCILSURFACE,
    API_D3DDEVICE_GETDEVICECAPS,
    API_D3DDEVICE_GETDIRECT3D,
    API_D3DDEVICE_GETDISPLAYFIELDSTATUS,
    API_D3DDEVICE_GETDISPLAYMODE,
    API_D3DDEVICE_GETGAMMARAMP,
    API_D3DDEVICE_GETINDICES,
    API_D3DDEVICE_GETLIGHT,
    API_D3DDEVICE_GETLIGHTENABLE,
    API_D3DDEVICE_GETMATERIAL,
    API_D3DDEVICE_GETMODELVIEW,
    API_D3DDEVICE_GETOVERLAYUPDATESTATUS,
    API_D3DDEVICE_GETPALETTE,
    API_D3DDEVICE_GETPIXELSHADER,
    API_D3DDEVICE_GETPIXELSHADERCONSTANT,
    API_D3DDEVICE_GETPIXELSHADERFUNCTION,
    API_D3DDEVICE_GETPROJECTIONVIEWPORTMATRIX,
    API_D3DDEVICE_GETPUSHBUFFEROFFSET,
    API_D3DDEVICE_GETRASTERSTATUS,
    API_D3DDEVICE_GETRENDERSTATE,
    API_D3DDEVICE_GETRENDERTARGET,
    API_D3DDEVICE_GETSCISSORS,
    API_D3DDEVICE_GETSCREENSPACEOFFSET,
    API_D3DDEVICE_GETSHADERCONSTANTMODE,
    API_D3DDEVICE_GETSTREAMSOURCE,
    API_D3DDEVICE_GETTEXTURE,
    API_D3DDEVICE_GETTEXTURESTAGESTATE,
    API_D3DDEVICE_GETTILE,
    API_D3DDEVICE_GETTILECOMPRESSIONTAGS,
    API_D3DDEVICE_GETTRANSFORM,
    API_D3DDEVICE_GETVERTEXBLENDMODELVIEW,
    API_D3DDEVICE_GETVERTEXSHADER,
    API_D3DDEVICE_GETVERTEXSHADERCONSTANT,
    API_D3DDEVICE_GETVERTEXSHADERDECLARATION,
    API_D3DDEVICE_GETVERTEXSHADERFUNCTION,
    API_D3DDEVICE_GETVERTEXSHADERINPUT,
    API_D3DDEVICE_GETVERTEXSHADERSIZE,
    API_D3DDEVICE_GETVERTEXSHADERTYPE,
    API_D3DDEVICE_GETVIEWPORT,
    API_D3DDEVICE_GETVISIBILITYTESTRESULT,
    API_D3DDEVICE_INSERTCALLBACK,
    API_D3DDEVICE_INSERTFENCE,
    API_D3DDEVICE_ISBUSY,
    API_D3DDEVICE_ISFENCEPENDING,
    API_D3DDEVICE_KICKPUSHBUFFER,
    API_D3DDEVICE_LIGHTENABLE,
    API_D3DDEVICE_LOADVERTEXSHADER,
    API_D3DDEVICE_LOADVERTEXSHADERPROGRAM,
    API_D3DDEVICE_MULTIPLYTRANSFORM,
    API_D3DDEVICE_NOP,
    API_D3DDEVICE_PERSISTDISPLAY,
    API_D3DDEVICE_PRESENT,
    API_D3DDEVICE_PRIMEVERTEXCACHE,
    API_D3DDEVICE_READVERTEXSHADERCONSTANT,
    API_D3DDEVICE_RESET,
    API_D3DDEVICE_RESUME,
    API_D3DDEVICE_RUNPUSHBUFFER,
    API_D3DDEVICE_RUNVERTEXSTATESHADER,
    API_D3DDEVICE_SELECTVERTEXSHADER,
    API_D3DDEVICE_SENDCC,
    API_D3DDEVICE_SETBACKBUFFERSCALE,
    API_D3DDEVICE_SETBACKMATERIAL,
    API_D3DDEVICE_SETGAMMARAMP,
    API_D3DDEVICE_SETINDICES,
    API_D3DDEVICE_SETLIGHT,
    API_D3DDEVICE_SETMATERIAL,
    API_D3DDEVICE_SETMODELVIEW,
    API_D3DDEVICE_SETPALETTE,
    API_D3DDEVICE_SETPIXELSHADER,
    API_D3DDEVICE_SETPIXELSHADERCONSTANT,
    API_D3DDEVICE_SETPIXELSHADERPROGRAM,
    API_D3DDEVICE_SETRENDERSTATE_BACKFILLMODE,
    API_D3DDEVICE_SETRENDERSTATE_CULLMODE,
    API_D3DDEVICE_SETRENDERSTATE_DONOTCULLUNCOMPRESSED,
    API_D3DDEVICE_SETRENDERSTATE_DXT1NOISEENABLE,
    API_D3DDEVICE_SETRENDERSTATE_EDGEANTIALIAS,
    API_D3DDEVICE_SETRENDERSTATE_FILLMODE,
    API_D3DDEVICE_SETRENDERSTATE_FOGCOLOR,
    API_D3DDEVICE_SETRENDERSTATE_FRONTFACE,
    API_D3DDEVICE_SETRENDERSTATE_LINEWIDTH,
    API_D3DDEVICE_SETRENDERSTATE_LOGICOP,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEANTIALIAS,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMASK,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMODE,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLERENDERTARGETMODE,
    API_D3DDEVICE_SETRENDERSTATE_NORMALIZENORMALS,
    API_D3DDEVICE_SETRENDERSTATE_OCCLUSIONCULLENABLE,
    API_D3DDEVICE_SETRENDERSTATE_PARAMETERCHECK,
    API_D3DDEVICE_SETRENDERSTATE_PSTEXTUREMODES,
    API_D3DDEVICE_SETRENDERSTATE_ROPZCMPALWAYSREAD,
    API_D3DDEVICE_SETRENDERSTATE_ROPZREAD,
    API_D3DDEVICE_SETRENDERSTATE_SHADOWFUNC,
    API_D3DDEVICE_SETRENDERSTATE_SIMPLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILCULLENABLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILENABLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILFAIL,
    API_D3DDEVICE_SETRENDERSTATE_TEXTUREFACTOR,
    API_D3DDEVICE_SETRENDERSTATE_TWOSIDEDLIGHTING,
    API_D3DDEVICE_SETRENDERSTATE_VERTEXBLEND,
    API_D3DDEVICE_SETRENDERSTATE_YUVENABLE,
    API_D3DDEVICE_SETRENDERSTATE_ZBIAS,
    API_D3DDEVICE_SETRENDERSTATE_ZENABLE,
    API_D3DDEVICE_SETRENDERSTATENOTINLINE,
    API_D3DDEVICE_SETRENDERTARGET,
    API_D3DDEVICE_SETSCISSORS,
    API_D3DDEVICE_SETSCREENSPACEOFFSET,
    API_D3DDEVICE_SETSHADERCONSTANTMODE,
    API_D3DDEVICE_SETSTREAMSOURCE,
    API_D3DDEVICE_SETSWAPCALLBACK,
    API_D3DDEVICE_SETTEXTURE,
    API_D3DDEVICE_SETTEXTURESTAGESTATENOTINLINE,
    API_D3DDEVICE_SETTEXTURESTATE_BORDERCOLOR,
    API_D3DDEVICE_SETTEXTURESTATE_BUMPENV,
    API_D3DDEVICE_SETTEXTURESTATE_COLORKEYCOLOR,
    API_D3DDEVICE_SETTEXTURESTATE_PARAMETERCHECK,
    API_D3DDEVICE_SETTEXTURESTATE_TEXCOORDINDEX,
    API_D3DDEVICE_SETTILE,
    API_D3DDEVICE_SETTRANSFORM,
    API_D3DDEVICE_SETVERTEXBLENDMODELVIEW,
    API_D3DDEVICE_SETVERTEXDATA2F,
    API_D3DDEVICE_SETVERTEXDATA2S,
    API_D3DDEVICE_SETVERTEXDATA4F,
    API_D3DDEVICE_SETVERTEXDATA4S,
    API_D3DDEVICE_SETVERTEXDATA4UB,
    API_D3DDEVICE_SETVERTEXDATACOLOR,
    API_D3DDEVICE_SETVERTEXSHADER,
    API_D3DDEVICE_SETVERTEXSHADERCONSTANT,
    API_D3DDEVICE_SETVERTEXSHADERINPUT,
    API_D3DDEVICE_SETVERTICALBLANKCALLBACK,
    API_D3DDEVICE_SETVIEWPORT,
    API_D3DDEVICE_SUSPEND,
    API_D3DDEVICE_SWITCHTEXTURE,
    API_D3DDEVICE_UPDATEOVERLAY,

    /* D3DResource APIs */

    API_D3DRESOURCE_ADDREF,
    API_D3DRESOURCE_BLOCKUNTILNOTBUSY,
    API_D3DRESOURCE_FREEPRIVATEDATA,
    API_D3DRESOURCE_GETDEVICE,
    API_D3DRESOURCE_GETPRIVATEDATA,
    API_D3DRESOURCE_GETTYPE,
    API_D3DRESOURCE_ISBUSY,
    API_D3DRESOURCE_REGISTER,
    API_D3DRESOURCE_RELEASE,
    API_D3DRESOURCE_SETPRIVATEDATA,

    /* D3DBaseTexture APIs */

    API_D3DBASETEXTURE_GETLEVELCOUNT,

    /* D3DTexture APIs */

    API_D3DTEXTURE_GETLEVELDESC,
    API_D3DTEXTURE_GETSURFACELEVEL,
    API_D3DTEXTURE_LOCKRECT,

    /* D3DCubeTexture APIs */

    API_D3DCUBETEXTURE_GETCUBEMAPSURFACE,
    API_D3DCUBETEXTURE_GETLEVELDESC,
    API_D3DCUBETEXTURE_LOCKRECT,

    /* D3DVolumeTexture APIs */

    API_D3DVOLUMETEXURE_GETLEVELDESC,
    API_D3DVOLUMETEXURE_GETVOLUMELEVEL,
    API_D3DVOLUMETEXURE_LOCKBOX,

    /* D3DVertexBuffer APIs */

    API_D3DVERTEXBUFFER_GETDESC,
    API_D3DVERTEXBUFFER_LOCK,

    /* D3DIndexBuffer APIs */

    API_D3DINDEXBUFFER_GETDESC,

    /* D3DVolume APIs */

    API_D3DVOLUME_GETCONTAINER,
    API_D3DVOLUME_GETDESC,
    API_D3DVOLUME_LOCKBOX,

    /* D3DSurface APIs */

    API_D3DSURFACE_GETCONTAINER,
    API_D3DSURFACE_GETDESC,
    API_D3DSURFACE_LOCKRECT,

    /* D3DPalette APIs */

    API_D3DPALETTE_GETSIZE,
    API_D3DPALETTE_LOCK,

    /* D3DPushBuffer APIs */

    API_D3DPUSHBUFFER_BEGINFIXUP,
    API_D3DPUSHBUFFER_ENDFIXUP,
    API_D3DPUSHBUFFER_ENDVISIBILITYTEST,
    API_D3DPUSHBUFFER_JUMP,
    API_D3DPUSHBUFFER_RUNPUSHBUFFER,
    API_D3DPUSHBUFFER_SETMODELVIEW,
    API_D3DPUSHBUFFER_SETPALETTE,
    API_D3DPUSHBUFFER_SETRENDERTARGET,
    API_D3DPUSHBUFFER_SETTEXTURE,
    API_D3DPUSHBUFFER_SETVERTEXBLENDMODELVIEW,
    API_D3DPUSHBUFFER_SETVERTEXSHADERCONSTANT,
    API_D3DPUSHBUFFER_SETVERTEXSHADERINPUT,
    API_D3DPUSHBUFFER_VERIFY,

    /* D3DFixup APIs */

    API_D3DFIXUP_GETSIZE,
    API_D3DFIXUP_GETSPACE,
    API_D3DFIXUP_RESET,

    D3DAPI_MAX,
    D3DAPI_FORCE_LONG  =   0xFFFFFFFF

} D3DPERF_APICounters;

// A structure that contains performance information gathered by
// the driver.
//
typedef struct _D3DWAITINFO
{
    DWORD Count;
    ULONGLONG Cycles;

} D3DWAITINFO;

// function callback declaration for cycle time threshold callback
//
typedef void (WINAPI *PFNCycleThresholdHandler)(D3DPERF_PerformanceCounters perfctr,
    ULONGLONG Cycles);

// function callback declaration for spewing framerate information
//
typedef void (WINAPI *PFNDumpFrameRateInfoHandler)(void);

// m_dwDumpFPSInfoMask flags which specify what data to display during default
// m_pfnDumpFrameRateInfoHandler callback. By default everything is enabled
// except D3DPERF_DUMP_FPS_PERFPROFILE which has a much higher overhead.
//
// To use set m_FrameRateIntervalTime to 10000 (10ms) or similar.
//
#define D3DPERF_DUMP_FPS_INTINFO        0x00000001  // interrupts & context switches
#define D3DPERF_DUMP_FPS_MEMORY         0x00000002  // memory info
#define D3DPERF_DUMP_FPS_PUSHBUFFER     0x00000004  // pushbuffer info
#define D3DPERF_DUMP_FPS_WAITINFO       0x00000008  // *_WAITS timings
#define D3DPERF_DUMP_FPS_PERFPROFILE    0x00000010  // 100ns timer which pings GPU to
                                                    // determine %busy/idle time.
#define D3DPERF_DUMP_FPS_VERTEXINFO     0x00000020  // vertex processing info
#define D3DPERF_DUMP_FPS_PERFEVENTS     0x00000040  // performance events info

// Structure which allows SetRenderState calls to be overriden. For example,
// set m_RenderStateOverrides[D3DRS_FILLMODE] = { TRUE, D3DFILL_WIREFRAME }
// to turn on wireframe mode.
//
typedef struct _D3DOVERRIDERENDERSTATE
{
    BOOL Override;
    DWORD Value;
} D3DOVERRIDERENDERSTATE;

// D3D profile busy/idle samples
//
typedef enum _D3DPERFPROF
{
    D3DPERF_PROF_GPU,
    D3DPERF_PROF_FE,
    D3DPERF_PROF_BE,
    D3DPERF_PROF_MAX
} D3DPERFPROF;

// D3D performance event types.
//
typedef enum _D3DPERFEventsType
{
    D3DPERFEvent_Header                 = 0,
    D3DPERFEvent_DrawVerticesUP         = 1,
    D3DPERFEvent_DrawIndexedVerticesUP  = 2,
    D3DPERFEvent_DrawVertices           = 3,
    D3DPERFEvent_DrawIndexedVertices    = 4,
    D3DPERFEvent_BeginEnd               = 5,
    D3DPERFEvent_RunPushBuffer          = 6,

    D3DPERFEvent_VBlank                 = 7,
    D3DPERFEvent_Kickoff                = 8,
    D3DPERFEvent_Present                = 9,

    D3DPERFEvent_BlockUntilIdle         = 10,
    D3DPERFEvent_BlockOnFence           = 11,
    D3DPERFEvent_PushBufferWait         = 12,
    D3DPERFEvent_ObjectLockWait         = 13,

    D3DPERFEvent_User0                  = 21,
    D3DPERFEvent_User1                  = 22,
    D3DPERFEvent_User2                  = 23,
    D3DPERFEvent_User3                  = 24,
    D3DPERFEvent_User4                  = 25,
    D3DPERFEvent_User5                  = 26,
    D3DPERFEvent_User6                  = 27,
    D3DPERFEvent_User7                  = 28,
    D3DPERFEvent_User8                  = 29,
    D3DPERFEvent_User9                  = 30,
    D3DPERFEvent_User10                 = 31,

    D3DPERFEvent_Max                    = 32,
} D3DPERFEventsType;

// D3D performance event structure.
// 
typedef struct _D3DPERFEvent
{
    WORD Type;                          // Event type. D3DPERFEventsType or
                                        // user defined event.
    union
    {
        char HeaderText[30];            // D3DPERFEvent_Header

        struct
        {
            WORD GpuPct;                // Pct fe/be gpu was busy since last sample.
                                        // 0xffff means there weren't enough samples.
            DWORD CpuPutPtr;            // cpu put ptr location at CycleCpuStart

            ULONGLONG CycleCpuStart;    // rdtsc for start of timing
            DWORD CycleCpuLength;       // cpu cycle length of timing block

            DWORD CycleGpuStartDelta;   // gpu start cycle delta from CycleCpuStart
            DWORD CycleGpuLength;       // total gpu processing time

            DWORD Data;                 // Event Data. Space event took in pushbuffer
                                        // or for RunPushBuffer size of pushbuffer.
        };
    };
} D3DPERFEvent;

// Structure that contains all of the performance information gathered by
// the driver.
//
typedef struct _D3DPERF
{
    // Time Stamp Counter value of last D3DPERF_Reset() call.
    ULONGLONG m_TSCLastResetVal;

    // Time Stamp Counter value of last Present() call
    ULONGLONG m_TSCLastPresentVal;

    // Max and Min Frame number (.Count) with cycle counts (.Cycles)
    D3DWAITINFO m_FrameTimeMin;
    D3DWAITINFO m_FrameTimeMax;

    // Issues debug break when perfctr and break number line up.
    DWORD m_BreakCount;
    D3DPERF_PerformanceCounters m_Breakperfctr;

    // Pushbuffer location at D3DPERF_Reset call
    DWORD *m_pPutLocationAtReset;

    // Count of dwords skipped jumping back to pushbuffer start
    ULONGLONG m_PushBufferEndDwordsSkipped;

    // Interval time to dump framerate information in milliseconds
    DWORD m_FrameRateIntervalTime;
    // Mask which controls what information D3DPERF_DumpFrameRateInfo
    // (default m_pfnDumpFrameRateInfoHandler handler) spits out.
    DWORD m_dwDumpFPSInfoMask;
    PFNDumpFrameRateInfoHandler m_pfnDumpFrameRateInfoHandler;

    // Holds threshold cycle count for spewing wait times
    DWORD m_DumpWaitCycleTimesThreshold;
    // Handler function to call when threshold cycle count hit. This
    // function defaults to D3DPERF_DumpCounterCycleInfo which simply
    // dumps PERF_OBJECTLOCK_WAITS count and wait times.
    PFNCycleThresholdHandler m_pfnCycleThresholdHandler;

    // If true, the next D3DPERF_Reset call will go through
    // m_RenderStateOverrides and set any renderstates which have
    // the Override member set to true.
    BOOL m_SetRenderStateOverridesOnReset;

    // Profile data gathered when profile is started via D3DPERF_StartPerfProfile
    //  (also via m_dwDumpFPSInfoMask/m_DumpWaitCycleTimesThreshold)

    // Total number of profile samples read
    DWORD m_ProfileSamples;

    // Time profiler was started. Initialized in D3DPERF_StartPerfProfile.
    ULONGLONG m_TSCProfileStartTime;

    // Perf state bitmask history over last 10ms where it then wraps.
    // 0x2 means gpu (1 << D3DPERF_PROF_GPU) and (1 << D3DPERF_PROF_FE) were busy.
    // Cleared in D3DPERF_StartPerfProfile and D3DPERF_Reset calls.
    WORD m_ProfileData[105000];

    // Total busy counts for each unit read while profiler was enabled
    DWORD m_ProfileBusyCounts[D3DPERF_PROF_MAX];


    // Performance monitoring members.

    // Mask of performance events to record.
    // D3DPERF_PerfEventStart(WORD Type, ...) does the following:
    //   if((1 << Type) && !(g_PerfCounters.RecordD3DPerfEvents & (1 << Type)))
    //       return NULL;
    DWORD RecordD3DPerfEvents;

    // if SpewFrameCount != 0, D3DPERF_DumpPerfEvents will spew
    // Count frame(s) starting at present #D3DPerfEventSpewFrameStart
    // in pD3DPerfEvents.
    DWORD D3DPerfEventSpewFrameStart;
    DWORD D3DPerfEventSpewFrameCount;

    // Holds threshold cycle count for spewing perf times
    DWORD m_DumpPerfCycleTimesThresholdCpu;
    DWORD m_DumpPerfCycleTimesThresholdGpu;

    // The current open event in pD3DPerfEvents.
    DWORD CurrentD3DPerfEvent;
    // Count of elements in pD3DPerfEvents
    DWORD CountD3DPerfEvents;
    // Pointer to array of pD3DPerfEvents
    D3DPERFEvent *pD3DPerfEvents;


    // Values used to override any calls to SetRenderState.
    //
    D3DOVERRIDERENDERSTATE m_RenderStateOverrides[D3DRS_MAX];

    // The count of the number of times certain performance-related events
    // happen.  Use D3DPERF_PerformanceCounters to index into this array.
    //
    D3DWAITINFO m_PerformanceCounters[D3DPERF_MAX];

    // The count of the number of times each API is called.  Use
    // D3DPERF_APICounters to index into this array.
    //
    DWORD m_APICounters[D3DAPI_MAX];

    // The count of the number of times each render state is set.  Use
    // D3DRENDERSTATE to index into this array.
    //
    DWORD m_RenderStateCounters[D3DRS_MAX];

    // The count of the number of times each texture state is set.
    DWORD m_TextureStateCounters[D3DTSS_MAX];

} D3DPERF;

// Holds the name of an individual renderstate or texturestate.  You need
// to search through the array of these things to find the name for the
// state.
//
typedef struct _D3DSTATENAME
{
    DWORD m_State;
    char *m_Name;

} D3DSTATENAME;

// Holds the names for the different performance things gathered
// by the driver.
//
typedef struct _D3DPERFNAMES
{
    // Array of string of human-readable names for the above counters.
    char *m_PerformanceCounterNames[D3DPERF_MAX];

    // An array of human-readable names for the above counters.
    char *m_APICounterNames[D3DAPI_MAX];

    // Human-readable names for the renderstate counters.
    D3DSTATENAME m_RenderStateNames[D3DRS_MAX];

    // Human-readable names for the texture states.
    D3DSTATENAME m_TextureStateNames[D3DTSS_MAX];

} D3DPERFNAMES;

// Holds information on the pushbuffer and guesstimate on count of bytes
// written since last D3DPERF_Reset.
//
typedef struct _D3DPUSHBUFFERINFO
{
    DWORD PushBufferSize;
    DWORD PushSegmentSize;
    DWORD PushSegmentCount;

    DWORD *pPushBase;
    DWORD *pPushLimit;

    ULONGLONG PushBufferBytesWritten;

} D3DPUSHBUFFERINFO;


// Returns the performance structure which is statically allocated and should
// never be freed.
//
D3DPERF * WINAPI D3DPERF_GetStatistics();

// Returns an array of names which is statically allocated.
//
D3DPERFNAMES * WINAPI D3DPERF_GetNames();

// Returns information on the pushbuffer
//
void WINAPI D3DPERF_GetPushBufferInfo(D3DPUSHBUFFERINFO *pPushBufferInfo);

// Dumps current frame rate information.
//
void WINAPI D3DPERF_DumpFrameRateInfo();

// Reset all of the perf counters to zero.
//
void WINAPI D3DPERF_Reset();

// Trivial dumper of all statistics to the debug output.
//
void WINAPI D3DPERF_Dump();


// D3D Perf states
//
typedef enum _D3DPERFSTATETYPE
{
    D3DPERFSTATE_VTX_CACHE,     // 4KB pre-t&l cache
    D3DPERFSTATE_VTX_FILE,      // 24 entry post t&l cache
    D3DPERFSTATE_VTX_ALL,       // enable/disable all vtx states
} D3DPERFSTATETYPE;

// Set state routine which allows you to enable/disable
// the vertex cache and/or file. This can be useful to determine
// how well you're currently, or not, using vertex caching.
//
HRESULT WINAPI D3DPERF_SetState(D3DPERFSTATETYPE State, DWORD Value);

// GPU Profile control routines. Enabling the PerfProfiler starts
// profiler interrupt run every 100ns which checks the current busy/idle
// status of the gpu.
//
BOOL WINAPI D3DPERF_StartPerfProfile();
void WINAPI D3DPERF_StopPerfProfile();
void WINAPI D3DPERF_DumpPerfProfCounts();

// Routine to spew current list of performance monitoring events.
// Setting D3DPERF_DUMP_FPS_PERFEVENTS will cause D3DPERF_DumpFrameRateInfo to
// dump this information also. Looks something like:
//
//   Event                  CpuStart   CpuTime  GpuStart  GpuTime  CpuPut  Data Gpu%
//   Kickoff                       0      1683         0        0  113320      0
//      *** FrameMove ***
//   user0                    12705    106084   1900673   109887  113376   6176
//    DrawIndexedVertices     108691      6869   1947551    54773  115132   3924  90
//    DrawIndexedVertices     123267    278445   2216913  1471443  120420  86052
//
// FrameMove: is a user inserted header via D3DPERF_InsertPerfEventHeader
// user0: user event inserted via
//      D3DPERFEvent *pD3DPerfEvent = D3DPERF_PerfEventStart(D3DPERFEvent_User0, TRUE);
//      ...
//      D3DPERF_PerfEventEnd(pD3DPerfEvent, TRUE);
// CpuStart: cycle time of when event was start
// CpuTime: count of cycles cpu took for event
// GpuStart: cycle time of when gpu started working on event
// GpuTime: count of cycles gpu took for event
// CpuPut: where the CpuPut pushbuffer pointer was at start of event
// Gpu%: Gpu busy percentage since last event with more than 15 samples
//
void WINAPI D3DPERF_DumpPerfEvents();

/*
 * Helper routines to set up various d3dperf members to dump
 *  framerate information.
 */

// Sets a breakpoint on a specified performance counter number
//
__inline void WINAPI D3DPERF_SetBreakPerfCount(D3DPERF_PerformanceCounters perfctr,
    DWORD BreakCount)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_Breakperfctr = perfctr;
    pPerf->m_BreakCount = BreakCount;
}

// Sets frame rate interval (in ms) to call D3DPERF_DumpFrameRateInfo()
//
__inline void WINAPI D3DPERF_SetShowFrameRateInterval(DWORD FrameRateIntervalTime)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_FrameRateIntervalTime = FrameRateIntervalTime;
}

// Default handler for DumpWaitCycleTimesThreshold which just spews
// PERF_OBJECTLOCK_WAITS count and time
void WINAPI D3DPERF_DumpCounterCycleInfo(D3DPERF_PerformanceCounters perfctr,
    ULONGLONG Cycles);

// Sets threshold Cycle count and handler function for hitting wait time thresholds
__inline void WINAPI D3DPERF_SetWaitCycleTimeThreshold(
    PFNCycleThresholdHandler pfnCycleThresholdHandler,
    DWORD DumpWaitCycleTimesThreshold)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_DumpWaitCycleTimesThreshold = DumpWaitCycleTimesThreshold;
    pPerf->m_pfnCycleThresholdHandler = pfnCycleThresholdHandler;
}

// D3DPERF_StartCountingPerfEvent
//
// This should only be done when the chip is idle as
// any outstanding requests to the gpu will try to write
// back to pPerf->pD3DPerfEvents.
//
__inline BOOL WINAPI D3DPERF_StartCountingPerfEvent(
    DWORD EventCount
    )
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();

    // if we've got a count of events and it's not the same as last time
    if(EventCount && pPerf->CountD3DPerfEvents != EventCount)
    {
        // free old block, alloc new block
        free(pPerf->pD3DPerfEvents);

        pPerf->pD3DPerfEvents = (D3DPERFEvent *)malloc(sizeof(D3DPERFEvent) * EventCount);
        if(pPerf->pD3DPerfEvents)
            memset(pPerf->pD3DPerfEvents, 0, sizeof(D3DPERFEvent) * EventCount);
        else
            EventCount = 0;
    }

    pPerf->CurrentD3DPerfEvent = 0;                 // current entry in pD3DPerfEvents
    pPerf->CountD3DPerfEvents = EventCount;         // count of items in pD3DPerfEvents

    if(!pPerf->D3DPerfEventSpewFrameCount)
    {
        pPerf->D3DPerfEventSpewFrameStart = 2;      // by default just spew one frame
        pPerf->D3DPerfEventSpewFrameCount = 1;      // starting at the second present
    }

    // record mask (-1 is all)
    if(!pPerf->RecordD3DPerfEvents)
    {
        pPerf->RecordD3DPerfEvents =
            (1 << D3DPERFEvent_Header) |
            (1 << D3DPERFEvent_Present) |
            (1 << D3DPERFEvent_BlockUntilIdle) |
            (1 << D3DPERFEvent_BlockOnFence) |
            (1 << D3DPERFEvent_PushBufferWait) |
            (1 << D3DPERFEvent_ObjectLockWait) |
            (1 << D3DPERFEvent_User0) | (1 << D3DPERFEvent_User1) |
            (1 << D3DPERFEvent_User2) | (1 << D3DPERFEvent_User3) |
            (1 << D3DPERFEvent_User4) | (1 << D3DPERFEvent_User5) |
            (1 << D3DPERFEvent_User6) | (1 << D3DPERFEvent_User7) |
            (1 << D3DPERFEvent_User8) | (1 << D3DPERFEvent_User9) |
            (1 << D3DPERFEvent_User10);
    }

    return pPerf->RecordD3DPerfEvents;
}

// Insert a performance event header
//
__inline void WINAPI D3DPERF_InsertPerfEventHeader(
    char *szHeader
    )
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();

    if(pPerf->CountD3DPerfEvents)
    {
        DWORD CurrentEvent =
            (InterlockedIncrement((PLONG)&pPerf->CurrentD3DPerfEvent) - 1) %
            pPerf->CountD3DPerfEvents;
        D3DPERFEvent *pD3DPerfEvent = &pPerf->pD3DPerfEvents[CurrentEvent];

        pD3DPerfEvent->Type = D3DPERFEvent_Header;

        strncpy(pD3DPerfEvent->HeaderText, szHeader, sizeof(pD3DPerfEvent->HeaderText));
        pD3DPerfEvent->HeaderText[sizeof(pD3DPerfEvent->HeaderText) - 1] = 0;
    }
}

// D3DPERF_PerfEventStart/End.
//
//  Insert a performance Event. Type should be from D3DPERFEvent_User0 to User10.
//  RecordGpuTime states whether you want to insert fences for counting gpu times.
//
//      D3DPERFEvent *pD3DPerfEvent = D3DPERF_PerfEventStart(D3DPERFEvent_User0, TRUE);
//      ...
//      D3DPERF_PerfEventEnd(pD3DPerfEvent, TRUE);
//
D3DPERFEvent * WINAPI D3DPERF_PerfEventStart(
    WORD Type, BOOL RecordGpuTime);

void WINAPI D3DPERF_PerfEventEnd(
    D3DPERFEvent *pD3DPerfEvent, BOOL RecordGpuTime);

// D3DPERF_BlockTimer / PERFEVENT_BLOCKTIMER
// 
// Convenient struct+macro for inserting user-defined perf events.
// Will time the period spanning the life of the object.
//
// Example usage:
//
//     void RenderScene()
//     {
//         PERFEVENT_BLOCKTIMER("RenderScene", TRUE); // do record GPU time
//
//         // BLOCK OF CODE TO BE TIMED
//     }
// -or-
//     void UpdateLogic()
//     {
//         PERFEVENT_BLOCKTIMER("UpdateLogic", FALSE); // don't record GPU time
//
//         // BLOCK OF CODE TO BE TIMED
//     }
//
#ifdef __cplusplus
struct D3DPERF_BlockTimer
{
    D3DPERFEvent *m_pD3DPerfEvent;
    BOOL          m_bRecordGpuTime;

    __forceinline D3DPERF_BlockTimer(char *pszHeaderString,
                                     BOOL  bRecordGpuTime,
                                     WORD  EventType = D3DPERFEvent_User0)
    {
        if(pszHeaderString) { D3DPERF_InsertPerfEventHeader(pszHeaderString); }
        m_bRecordGpuTime = bRecordGpuTime;
        m_pD3DPerfEvent = D3DPERF_PerfEventStart(EventType, m_bRecordGpuTime);
    }

    __forceinline ~D3DPERF_BlockTimer()
    {
        D3DPERF_PerfEventEnd(m_pD3DPerfEvent, m_bRecordGpuTime);
    }
};

#define PERFEVENT_BLOCKTIMER(x,y)    D3DPERF_BlockTimer _PerfEventTimer(x,y)
#endif __cplusplus

#ifdef __cplusplus
}
#endif

#endif _D3D8PERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3D8.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8.h
 *  Content:    Xbox Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D8_H_
#define _D3D8_H_

#pragma warning( push )
#pragma warning( disable : 4100 ) // unreferenced formal parameter

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

#ifndef D3DINLINE
#define D3DINLINE static __forceinline
#endif

#ifndef D3DMINLINE
#define D3DMINLINE __forceinline
#endif

#define D3DFASTCALL __fastcall

#define D3D_SDK_VERSION 0

#include <stdlib.h>

typedef struct Direct3D                  Direct3D;
typedef struct D3DDevice                 D3DDevice;
typedef struct D3DResource               D3DResource;
typedef struct D3DBaseTexture            D3DBaseTexture;
typedef struct D3DTexture                D3DTexture;
typedef struct D3DVolumeTexture          D3DVolumeTexture;
typedef struct D3DCubeTexture            D3DCubeTexture;
typedef struct D3DVertexBuffer           D3DVertexBuffer;
typedef struct D3DIndexBuffer            D3DIndexBuffer;
typedef struct D3DPalette                D3DPalette;
typedef struct D3DSurface                D3DSurface;
typedef struct D3DVolume                 D3DVolume;
typedef struct D3DPushBuffer             D3DPushBuffer;
typedef struct D3DFixup                  D3DFixup;

// Compatibility typedefs.

#define IDirect3D8                       Direct3D
#define IDirect3DDevice8                 D3DDevice
#define IDirect3DResource8               D3DResource
#define IDirect3DBaseTexture8            D3DBaseTexture
#define IDirect3DTexture8                D3DTexture
#define IDirect3DVolumeTexture8          D3DVolumeTexture
#define IDirect3DCubeTexture8            D3DCubeTexture
#define IDirect3DVertexBuffer8           D3DVertexBuffer
#define IDirect3DIndexBuffer8            D3DIndexBuffer
#define IDirect3DPalette8                D3DPalette
#define IDirect3DSurface8                D3DSurface
#define IDirect3DVolume8                 D3DVolume
#define IDirect3DPushBuffer8             D3DPushBuffer
#define IDirect3DFixup8                  D3DFixup

// Pointer typedefs.

typedef struct Direct3D                  *LPDIRECT3D8,              *PDIRECT3D8;
typedef struct D3DDevice                 *LPDIRECT3DDEVICE8,        *PDIRECT3DDEVICE8;
typedef struct D3DResource               *LPDIRECT3DRESOURCE8,      *PDIRECT3DRESOURCE8;
typedef struct D3DBaseTexture            *LPDIRECT3DBASETEXTURE8,   *PDIRECT3DBASETEXTURE8;
typedef struct D3DTexture                *LPDIRECT3DTEXTURE8,       *PDIRECT3DTEXTURE8;
typedef struct D3DVolumeTexture          *LPDIRECT3DVOLUMETEXTURE8, *PDIRECT3DVOLUMETEXTURE8;
typedef struct D3DCubeTexture            *LPDIRECT3DCUBETEXTURE8,   *PDIRECT3DCUBETEXTURE8;
typedef struct D3DVertexBuffer           *LPDIRECT3DVERTEXBUFFER8,  *PDIRECT3DVERTEXBUFFER8;
typedef struct D3DIndexBuffer            *LPDIRECT3DINDEXBUFFER8,   *PDIRECT3DINDEXBUFFER8;
typedef struct D3DPalette                *LPDIRECT3DPALETTE8,       *PDIRECT3DPALETTE8;
typedef struct D3DSurface                *LPDIRECT3DSURFACE8,       *PDIRECT3DSURFACE8;
typedef struct D3DVolume                 *LPDIRECT3DVOLUME8,        *PDIRECT3DVOLUME8;
typedef struct D3DPushBuffer             *LPDIRECT3DPUSHBUFFER8,    *PDIRECT3DPUSHBUFFER8;
typedef struct D3DFixup                  *LPDIRECT3DFIXUP8,         *PDIRECT3DFIXUP8;

#include "d3d8types.h"
#include "d3d8caps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * The XBOX implementation of Direct3DCreate8 exists only for backwards
 * compatibility.
 *
 * There is no need to store the result of this function call.  You can
 * pass 'NULL' for the Direct3D 'this' pointer as it is completely
 * ignored.
 */

Direct3D * WINAPI Direct3DCreate8(UINT SDKVersion);

/****************************************************************************
 *
 * Parameter for Direct3D Enum and GetCaps8 functions to get the info for
 * the current mode only.
 *
 ****************************************************************************/

#define D3DCURRENT_DISPLAY_MODE                 0x00EFFFFFL

/****************************************************************************
 *
 * Flags for Direct3D::CreateDevice's BehaviorFlags
 *
 ****************************************************************************/

#define D3DCREATE_PUREDEVICE                    0x00000010L
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING     0x00000020L
#define D3DCREATE_HARDWARE_VERTEXPROCESSING     0x00000040L
#define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L

// D3DCREATE_FPU_PRESERVE is not supported on Xbox
// D3DCREATE_MULTITHREADED is not supported on Xbox

/****************************************************************************
 *
 * Parameter for Direct3D::CreateDevice's Adapter
 *
 ****************************************************************************/

#define D3DADAPTER_DEFAULT                     0

/****************************************************************************
 *
 * Flags for Direct3D::EnumAdapters
 *
 ****************************************************************************/

#define D3DENUM_NO_WHQL_LEVEL                   0x00000002L

/****************************************************************************
 *
 * Maximum number of back-buffers supported in DX8
 *
 ****************************************************************************/

#define D3DPRESENT_BACK_BUFFERS_MAX             2L

/****************************************************************************
 *
 * Flags for D3DDevice::SetGammaRamp
 *
 ****************************************************************************/

#define D3DSGR_NO_CALIBRATION                  0x00000000L
#define D3DSGR_CALIBRATE                       0x00000001L
#define D3DSGR_IMMEDIATE                       0x00000002L

/****************************************************************************
 * Flags for SetPrivateData method on all D3D8 interfaces
 *
 * The passed pointer is an IUnknown ptr. The SizeOfData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). Direct3D will call AddRef through this
 * pointer and Release when the private data is destroyed. The data will be
 * destroyed when another SetPrivateData with the same GUID is set, when
 * FreePrivateData is called, or when the D3D8 object is freed.
 ****************************************************************************/

#define D3DSPD_IUNKNOWN                         0x00000001L

/*
 *  DirectDraw error codes
 */

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

/*
 * Direct3D Errors
 */

#define D3D_OK                              S_OK

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)
#define D3DERR_TESTINCOMPLETE                   MAKE_D3DHRESULT(2088) // Xbox extension
#define D3DERR_BUFFERTOOSMALL                   MAKE_D3DHRESULT(2089) // Xbox extension

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)

/****************************************************************************
 *
 * BeginStateBlock/EndStateBlock semantics require that D3D have the ability
 * to record all API state-changing calls in a state block.  Rather than add 
 * a time-consuming are-we-recording-a-state-block check to every SetRenderState 
 * and SetTextureStageState call that would slow callers even if they never 
 * used BeginStateBlock/EndStateBlock, we've placed that logic inline so that 
 * it can be eliminated if not needed by the title.
 *
 * To enable BeginStateBlock/EndStateBlock, define the following before
 * including xtl.h.  This needs to be done for all modules that can change
 * state that should be recorded by BeginStateBlock.
 *
 *      #define D3DCOMPILE_BEGINSTATEBLOCK 1
 *
 ****************************************************************************/

typedef enum _D3DSTATEBLOCKDIRTYINDEX
{
    D3DSBD_TEXTURES              = 0, 
    D3DSBD_PIXELSHADER           = D3DSBD_TEXTURES + D3DTSS_MAXSTAGES,
    D3DSBD_VERTEXSHADER          = D3DSBD_PIXELSHADER + 1,
    D3DSBD_INDICES               = D3DSBD_VERTEXSHADER + 1,
    D3DSBD_STREAMS               = D3DSBD_INDICES + 1,
    D3DSBD_PIXELSHADERCONSTANTS  = D3DSBD_STREAMS + D3DVS_STREAMS_MAX_V1_0,
    D3DSBD_VERTEXSHADERCONSTANTS = D3DSBD_PIXELSHADERCONSTANTS + D3DPS_CONSTREG_MAX_DX8,
    D3DSBD_RENDERSTATES          = D3DSBD_VERTEXSHADERCONSTANTS + D3DVS_CONSTREG_COUNT_XBOX,
    D3DSBD_TEXTURESTATES         = D3DSBD_RENDERSTATES + D3DRS_MAX,
    D3DSBD_TRANSFORMS            = D3DSBD_TEXTURESTATES + (D3DTSS_MAXSTAGES * D3DTSS_MAX),
    D3DSBD_VIEWPORT              = D3DSBD_TRANSFORMS + D3DTS_MAX,
    D3DSBD_MATERIAL              = D3DSBD_VIEWPORT + 1,
    D3DSBD_BACKMATERIAL          = D3DSBD_MATERIAL + 1,
    D3DSBD_MAX                   = D3DSBD_BACKMATERIAL + 1,
    D3DSBD_FORCE_DWORD           = 0x7fffffff, // force 32-bit size enum
} D3DSTATEBLOCKDIRTYINDEX;

#ifdef D3DCOMPILE_BEGINSTATEBLOCK
        
    #define D3DDIRTY_TEXTURE(stage)                                         \
        { D3D__StateBlockDirty[D3DSBD_TEXTURES + (stage)] = TRUE; }
        
    #define D3DDIRTY_PIXELSHADER()                                          \
        { D3D__StateBlockDirty[D3DSBD_PIXELSHADER] = TRUE; }
        
    #define D3DDIRTY_VERTEXSHADER()                                         \
        { D3D__StateBlockDirty[D3DSBD_VERTEXSHADER] = TRUE; }
        
    #define D3DDIRTY_INDICES()                                              \
        { D3D__StateBlockDirty[D3DSBD_INDICES] = TRUE; }
        
    #define D3DDIRTY_STREAM(stream)                                         \
        { D3D__StateBlockDirty[D3DSBD_STREAMS + (stream)] = TRUE; }
        
    #define D3DDIRTY_PIXELSHADERCONSTANT(index, count)                      \
        { memset(&D3D__StateBlockDirty[D3DSBD_PIXELSHADERCONSTANTS + (index)], TRUE, (count)); }
        
    #define D3DDIRTY_VERTEXSHADERCONSTANT(index, count)                     \
        { memset(&D3D__StateBlockDirty[D3DSBD_VERTEXSHADERCONSTANTS + (index) + 96], TRUE, (count)); }
                          
    #define D3DDIRTY_RENDERSTATE(state)                                     \
        { D3D__StateBlockDirty[D3DSBD_RENDERSTATES + (state)] = TRUE; }
    
    #define D3DDIRTY_TEXTURESTATE(stage, state)                             \
        { D3D__StateBlockDirty[D3DSBD_TEXTURESTATES +                       \
                          ((state) * D3DTSS_MAXSTAGES) + (stage)] = TRUE; } 
        
    #define D3DDIRTY_TRANSFORM(transform)                                   \
        { D3D__StateBlockDirty[D3DSBD_TRANSFORMS + (transform)] = TRUE; }
        
    #define D3DDIRTY_VIEWPORT()                                             \
        { D3D__StateBlockDirty[D3DSBD_VIEWPORT] = TRUE; }
        
    #define D3DDIRTY_MATERIAL()                                             \
        { D3D__StateBlockDirty[D3DSBD_MATERIAL] = TRUE; }
        
    #define D3DDIRTY_BACKMATERIAL()                                         \
        { D3D__StateBlockDirty[D3DSBD_BACKMATERIAL] = TRUE; }
    
#else
        
    #define D3DDIRTY_TEXTURE(stage)
    #define D3DDIRTY_PIXELSHADER()                                         
    #define D3DDIRTY_VERTEXSHADER()                                        
    #define D3DDIRTY_INDICES()                                             
    #define D3DDIRTY_STREAM(stream)                                         
    #define D3DDIRTY_PIXELSHADERCONSTANT(index, count)                         
    #define D3DDIRTY_VERTEXSHADERCONSTANT(index, count)                        
    #define D3DDIRTY_RENDERSTATE(state)                                    
    #define D3DDIRTY_TEXTURESTATE(stage, state)                            
    #define D3DDIRTY_TRANSFORM(transform)                                  
    #define D3DDIRTY_VIEWPORT()
    #define D3DDIRTY_MATERIAL()                                            
    #define D3DDIRTY_BACKMATERIAL()                                            

#endif

/****************************************************************************
 *
 * __declspec(selectany) has the lovely attribute that it allows the linker
 * to remove duplicate instantiations of global declarations, and to remove
 * the instantiation entirely if unreferenced.
 *
 ****************************************************************************/

#define D3DCONST extern CONST DECLSPEC_SELECTANY

/****************************************************************************
 *
 * Private internal data - Please don't access these directly, as they're
 *                         subject to change.
 *
 ****************************************************************************/

D3DCONST UINT D3DPRIMITIVETOVERTEXCOUNT[11][2] =
{
    {0, 0},         // Illegal
    {1, 0},         // D3DPT_POINTLIST     = 1,
    {2, 0},         // D3DPT_LINELIST      = 2,
    {1, 1},         // D3DPT_LINELOOP      = 3,
    {1, 1},         // D3DPT_LINESTRIP     = 4,
    {3, 0},         // D3DPT_TRIANGLELIST  = 5,
    {1, 2},         // D3DPT_TRIANGLESTRIP = 6,
    {1, 2},         // D3DPT_TRIANGLEFAN   = 7,
    {4, 0},         // D3DPT_QUADLIST      = 8,
    {2, 2},         // D3DPT_QUADSTRIP     = 9,
    {0, 0},         // Illegal (D3DPT_POLYGON)
};

D3DCONST DWORD D3DSIMPLERENDERSTATEENCODE[] =
{                                          
    0x040260,    0x040264,    0x040268,    0x04026c,    // 0
    0x040270,    0x040274,    0x040278,    0x04027c,    // 4
    0x040288,    0x04028c,    0x040a60,    0x040a64,    // 8
    0x040a68,    0x040a6c,    0x040a70,    0x040a74,    // 12
    0x040a78,    0x040a7c,    0x040a80,    0x040a84,    // 16
    0x040a88,    0x040a8c,    0x040a90,    0x040a94,    // 20
    0x040a98,    0x040a9c,    0x040aa0,    0x040aa4,    // 24
    0x040aa8,    0x040aac,    0x040ab0,    0x040ab4,    // 28
    0x040ab8,    0x040abc,    0x040ac0,    0x040ac4,    // 32
    0x040ac8,    0x040acc,    0x040ad0,    0x040ad4,    // 36
    0x040ad8,    0x040adc,    0x0417f8,    0x041e20,    // 40
    0x041e24,    0x041e40,    0x041e44,    0x041e48,    // 44
    0x041e4c,    0x041e50,    0x041e54,    0x041e58,    // 48
    0x041e5c,    0x041e60,    0x041d90,    0x041e74,    // 52
    0x041e78,    0x040354,    0x04033c,    0x040304,    // 56
    0x040300,    0x040340,    0x040344,    0x040348,    // 60
    0x04035c,    0x040310,    0x04037c,    0x040358,    // 64
    0x040374,    0x040378,    0x040364,    0x040368,    // 68
    0x04036c,    0x040360,    0x040350,    0x04034c,    // 72
    0x0409f8,    0x040384,    0x040388,    0x040330,    // 76
    0x040334,    0x040338,    
};

D3DCONST DWORD D3DTEXTUREDIRECTENCODE[] =
{ 
    0x081b00,    0x081b40,    0x081b80,    0x081bc0,
};
     
#define D3DDIRTYFLAG_TEXTURE_STATE                0x0000000f
#define D3DDIRTYFLAG_TEXTURE_STATE_0              0x00000001
#define D3DDIRTYFLAG_TEXTURE_STATE_1              0x00000002
#define D3DDIRTYFLAG_TEXTURE_STATE_2              0x00000004
#define D3DDIRTYFLAG_TEXTURE_STATE_3              0x00000008
#define D3DDIRTYFLAG_VERTEXFORMAT                 0x00000070
#define D3DDIRTYFLAG_VERTEXFORMAT_VB              0x00000010
#define D3DDIRTYFLAG_VERTEXFORMAT_UP              0x00000020
#define D3DDIRTYFLAG_VERTEXFORMAT_OFFSETS         0x00000040
#define D3DDIRTYFLAG_POINTPARAMS                  0x00000100
#define D3DDIRTYFLAG_TRANSFORM                    0x00000200
#define D3DDIRTYFLAG_TEXTURE_TRANSFORM            0x00000400
#define D3DDIRTYFLAG_COMBINERS                    0x00000800
#define D3DDIRTYFLAG_LIGHTS                       0x00001000
#define D3DDIRTYFLAG_SPECFOG_COMBINER             0x00002000
#define D3DDIRTYFLAG_SHADER_STAGE_PROGRAM         0x00004000

D3DCONST DWORD D3DDIRTYFROMRENDERSTATE[] =
{
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGENABLE                 
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGTABLEMODE              
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGSTART                  
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGEND                    
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGDENSITY                
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_RANGEFOGENABLE            
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP0                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP1                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP2                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP3                     
    // D3DRS_LIGHTING dirties the transform because of the inverse-model-
    // view optimization:
    (D3DDIRTYFLAG_LIGHTS | D3DDIRTYFLAG_TRANSFORM),     // D3DRS_LIGHTING                   
    (D3DDIRTYFLAG_LIGHTS | D3DDIRTYFLAG_SPECFOG_COMBINER),// D3DRS_SPECULARENABLE             
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_LOCALVIEWER                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_COLORVERTEX                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKSPECULARMATERIALSOURCE 
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKDIFFUSEMATERIALSOURCE  
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKAMBIENTMATERIALSOURCE  
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKEMISSIVEMATERIALSOURCE 
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_SPECULARMATERIALSOURCE     
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_DIFFUSEMATERIALSOURCE      
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_AMBIENTMATERIALSOURCE      
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_EMISSIVEMATERIALSOURCE     
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKAMBIENT                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_AMBIENT                    
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE                 
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE_MIN             
    (D3DDIRTYFLAG_POINTPARAMS | D3DDIRTYFLAG_COMBINERS),// D3DRS_POINTSPRITEENABLE         
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALEENABLE          
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_A              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_B              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_C              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE_MAX             
    0,                                                  // D3DRS_PATCHEDGESTYLE            
    0,                                                  // D3DRS_PATCHSEGMENTS             
    0,                                                  // D3DRS_MULTISAMPLEFILTER
};

D3DCONST DWORD D3DDIRTYFROMTEXTURESTATE[] =
{
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSU
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSV
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSW
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAGFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MINFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MIPFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MIPMAPLODBIAS
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAXMIPLEVEL
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAXANISOTROPY
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_COLORKEYOP
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_COLORSIGN
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ALPHAKILL
    (D3DDIRTYFLAG_COMBINERS | D3DDIRTYFLAG_SHADER_STAGE_PROGRAM | D3DDIRTYFLAG_TEXTURE_STATE),
                                                        // D3DTSS_COLOROP (special cased)
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG0           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG1           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG2           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAOP             
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG0           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG1           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG2           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_RESULTARG           
    D3DDIRTYFLAG_TEXTURE_TRANSFORM,                     // D3DTSS_TEXTURETRANSFORMFLAGS
};

// Macro for converting from primitive count to number of vertices.
//
#define D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount) \
    ((PrimitiveCount) * D3DPRIMITIVETOVERTEXCOUNT[PrimitiveType][0] + \
     + D3DPRIMITIVETOVERTEXCOUNT[PrimitiveType][1])

/****************************************************************************
 *
 * Publicly accessible globals - Feel free to modify the values.
 *
 ****************************************************************************/

// 'Extern' declaration that is both C and C++ friendly.
//
#ifdef __cplusplus
    #define D3DEXTERN extern "C"
#else
    #define D3DEXTERN extern
#endif

// Set D3D__NullHardware to TRUE to enable infinitely fast hardware (so fast 
// you can't even see the results).  This is useful for determining how CPU-
// bound your program is.
//
D3DEXTERN BOOL D3D__NullHardware; 

// Set D3D__SingleStepPusher to TRUE to cause D3D to do an implicit 
// BlockUntilIdle after every D3D API call.  This is useful for tracking
// weird hardware crashes and hangs down to the problem API call.
// 
D3DEXTERN BOOL D3D__SingleStepPusher;

/****************************************************************************
 *
 * Private D3D globals - Please don't use these directly, as they're subject
 *                       subject to change.
 *
 ****************************************************************************/

// This array marks what APIs have been called when recording state blocks:
//
D3DEXTERN BYTE D3D__StateBlockDirty[];

// This array shadows the current render states:
//
D3DEXTERN DWORD D3D__RenderState[D3DRS_MAX];

// This array shadows the current texture stage states:
//
D3DEXTERN DWORD D3D__TextureState[D3DTSS_MAXSTAGES][D3DTSS_MAX];

// This array contains the dirty flags for deferred render and texture states:
//
D3DEXTERN DWORD D3D__DirtyFlags;

// This points to the data of the currently selected index buffer.  This is
// used for converting Draw[Indexed]Primitive calls to Draw[Indexed]Vertices
// calls inline.
//
D3DEXTERN WORD* D3D__IndexData;

/****************************************************************************
 *
 * Miscellaneous public defines
 *
 ****************************************************************************/

// The required alignment for any memory that is going to be
// rendered to from the hardware.
//
#define D3D_RENDER_MEMORY_ALIGNMENT           64

// The required alignment for any memory that is tiled, including the
// default frame buffers and depth buffer.
//
#define D3D_TILED_SURFACE_ALIGNMENT           0x4000

// Types of our DPC-level callback functions.
//
typedef void (__cdecl * D3DCALLBACK)(DWORD Context);
typedef void (__cdecl * D3DVBLANKCALLBACK)(D3DVBLANKDATA *pData);
typedef void (__cdecl * D3DSWAPCALLBACK)(D3DSWAPDATA *pData);

/*
 * NOTE: The C version of the methods for all of these interfaces
 *       are named "<interfacename>_<method name>" and have an 
 *       explicit pointer to the interface as the first parameter.
 *       The actual definition of these methods is at the end
 *       of this file.
 */

/*
 * Direct3D, IDirect3D8 interface
 *
 */

#ifdef __cplusplus

struct Direct3D
{
    static ULONG WINAPI AddRef();
    static ULONG WINAPI Release();

    static UINT WINAPI GetAdapterCount();

    static HRESULT WINAPI GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier);
    static UINT    WINAPI GetAdapterModeCount(UINT Adapter);
    static HRESULT WINAPI EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
    static HRESULT WINAPI CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
    static HRESULT WINAPI CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
    static HRESULT WINAPI CheckDepthStencilMatch(UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat);
    static HRESULT WINAPI GetDeviceCaps(UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps);
    static HRESULT WINAPI CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface);
    static HRESULT WINAPI SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize); // Xbox extension
};

#endif __cplusplus

/*
 * D3DDevice, IDirect3DDevice8 interface
 */

#ifdef __cplusplus

struct D3DDevice
{
    // Standard D3D APIs:

    static ULONG WINAPI AddRef();
    static ULONG WINAPI Release();
    static HRESULT WINAPI GetDirect3D(Direct3D **ppD3D8);
    static HRESULT WINAPI GetDeviceCaps(D3DCAPS8 *pCaps);
    static HRESULT WINAPI GetDisplayMode(D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters);
    static HRESULT WINAPI Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
    static HRESULT WINAPI Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2);
    static HRESULT WINAPI GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer);
    static HRESULT WINAPI GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);
    static void    WINAPI SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp);
    static void    WINAPI GetGammaRamp(D3DGAMMARAMP *pRamp);
    static HRESULT WINAPI CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture);
    static HRESULT WINAPI CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture);
    static HRESULT WINAPI CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture);
    static HRESULT WINAPI CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer);
    static HRESULT WINAPI CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer);
    static HRESULT WINAPI CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface);
    static HRESULT WINAPI CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface);
    static HRESULT WINAPI CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface);
    static HRESULT WINAPI CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray);
    static HRESULT WINAPI SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil);
    static HRESULT WINAPI GetRenderTarget(D3DSurface **ppRenderTarget);
    static HRESULT WINAPI GetDepthStencilSurface(D3DSurface **ppZStencilSurface);
    static HRESULT WINAPI BeginScene();
    static HRESULT WINAPI EndScene();
    static HRESULT WINAPI Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
    static HRESULT WINAPI SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    static HRESULT WINAPI GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
    static HRESULT WINAPI MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    static HRESULT WINAPI SetViewport(CONST D3DVIEWPORT8 *pViewport);
    static HRESULT WINAPI GetViewport(D3DVIEWPORT8 *pViewport);
    static HRESULT WINAPI SetMaterial(CONST D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI GetMaterial(D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
    static HRESULT WINAPI GetLight(DWORD Index, D3DLIGHT8 *pLight);
    static HRESULT WINAPI LightEnable(DWORD Index, BOOL Enable);
    static HRESULT WINAPI GetLightEnable(DWORD Index, BOOL *pEnable);
    static HRESULT WINAPI SetRenderState(D3DRENDERSTATETYPE State, DWORD Value);
    static HRESULT WINAPI GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue);
#if D3DCOMPILE_BEGINSTATEBLOCK
    static HRESULT WINAPI BeginStateBlock();
    static HRESULT WINAPI EndStateBlock(DWORD *pToken);
#endif
    static HRESULT WINAPI ApplyStateBlock(DWORD Token);
    static HRESULT WINAPI CaptureStateBlock(DWORD Token);
    static HRESULT WINAPI DeleteStateBlock(DWORD Token);
    static HRESULT WINAPI CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);
    static HRESULT WINAPI GetTexture(DWORD Stage, D3DBaseTexture **ppTexture);
    static HRESULT WINAPI SetTexture(DWORD Stage, D3DBaseTexture *pTexture);
    static HRESULT WINAPI GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue);
    static HRESULT WINAPI SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
    static HRESULT WINAPI DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount);
    static HRESULT WINAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount);
    static HRESULT WINAPI DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
    static HRESULT WINAPI SetVertexShader(DWORD Handle);
    static HRESULT WINAPI GetVertexShader(DWORD *pHandle);
    static HRESULT WINAPI DeleteVertexShader(DWORD Handle);
    static HRESULT WINAPI SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
    static HRESULT WINAPI GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
    static HRESULT WINAPI SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride);
    static HRESULT WINAPI GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride);
    static HRESULT WINAPI SetIndices(D3DIndexBuffer *pIndexData, UINT BaseVertexIndex);
    static HRESULT WINAPI GetIndices(D3DIndexBuffer **ppIndexData, UINT *pBaseVertexIndex);
    static HRESULT WINAPI CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle);
    static HRESULT WINAPI SetPixelShader(DWORD Handle);
    static HRESULT WINAPI SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef);
    static HRESULT WINAPI GetPixelShader(DWORD *pHandle);
    static HRESULT WINAPI DeletePixelShader(DWORD Handle);
    static HRESULT WINAPI SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData);
    static HRESULT WINAPI DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
    static HRESULT WINAPI DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
    static HRESULT WINAPI DeletePatch(UINT Handle);

    // The following APIs are all Xbox extensions:

    static HRESULT WINAPI SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode);
    static HRESULT WINAPI GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode);
    static HRESULT WINAPI LoadVertexShader(DWORD Handle, DWORD Address);
    static HRESULT WINAPI LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address);
    static HRESULT WINAPI SelectVertexShader(DWORD Handle, DWORD Address);
    static HRESULT WINAPI SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address);
    static HRESULT WINAPI RunVertexStateShader(DWORD Address, CONST float *pData);
    static HRESULT WINAPI GetVertexShaderSize(DWORD Handle, UINT *pSize);
    static HRESULT WINAPI GetVertexShaderType(DWORD Handle, DWORD *pType);
    static HRESULT WINAPI DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount);
    static HRESULT WINAPI DrawIndexedVertices(D3DPRIMITIVETYPE, UINT VertexCount, CONST WORD *pIndexData);
    static HRESULT WINAPI DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData);
    static HRESULT WINAPI CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette);
    static HRESULT WINAPI GetPalette(DWORD Stage, D3DPalette **ppPalette);
    static HRESULT WINAPI SetPalette(DWORD Stage, D3DPalette *pPalette);
    static HRESULT WINAPI SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
    static HRESULT WINAPI SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value);
    static HRESULT WINAPI SetBackMaterial(CONST D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI GetBackMaterial(D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey);
    static HRESULT WINAPI EnableOverlay(BOOL Enable);
    static HRESULT WINAPI BeginVisibilityTest();
    static HRESULT WINAPI EndVisibilityTest(DWORD Index);
    static HRESULT WINAPI GetVisibilityTestResult(DWORD Index, UINT* pResult, ULONGLONG* pTimeStamp);
    static BOOL    WINAPI GetOverlayUpdateStatus();
    static HRESULT WINAPI GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus);
    static HRESULT WINAPI SetVertexData2f(INT Register, float a, float b);
    static HRESULT WINAPI SetVertexData4f(INT Register, float a, float b, float c, float d);
    static HRESULT WINAPI SetVertexData2s(INT Register, SHORT a, SHORT b);
    static HRESULT WINAPI SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d);
    static HRESULT WINAPI SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d);
    static HRESULT WINAPI SetVertexDataColor(INT Register, D3DCOLOR Color);
    static HRESULT WINAPI Begin(D3DPRIMITIVETYPE PrimitiveType);
    static HRESULT WINAPI End();
    static HRESULT WINAPI CreateFixup(UINT Size, D3DFixup **ppFixup);
    static HRESULT WINAPI CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer);
    static HRESULT WINAPI BeginPushBuffer(D3DPushBuffer *pPushBuffer);
    static HRESULT WINAPI EndPushBuffer();
    static HRESULT WINAPI RunPushBuffer(D3DPushBuffer* pPushBuffer, D3DFixup *pFixup);
    static HRESULT WINAPI GetPushBufferOffset(DWORD* pOffset);
    static HRESULT WINAPI Nop();
    static HRESULT WINAPI GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
    static HRESULT WINAPI GetModelView(D3DMATRIX* pModelView);
    static HRESULT WINAPI SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI SwitchTexture(DWORD Stage, D3DBaseTexture *pTexture);
    static HRESULT WINAPI Suspend();
    static HRESULT WINAPI Resume(BOOL Reset);
    static HRESULT WINAPI SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects);
    static HRESULT WINAPI GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects);
    static HRESULT WINAPI SetTile(DWORD Index, CONST D3DTILE* pTile);
    static HRESULT WINAPI GetTile(DWORD Index, D3DTILE* pTile);
    static DWORD   WINAPI GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag);
    static void    WINAPI SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count);
    static void    WINAPI GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
    static HRESULT WINAPI BeginPush(DWORD Count, DWORD **ppPush);
    static HRESULT WINAPI EndPush(DWORD *pPush);
    static BOOL    WINAPI IsBusy();
    static void    WINAPI BlockUntilIdle();
    static void    WINAPI KickPushBuffer();
    static void    WINAPI SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback);
    static void    WINAPI SetSwapCallback(D3DSWAPCALLBACK pCallback);
    static void    WINAPI BlockUntilVerticalBlank();
    static DWORD   WINAPI InsertFence();
    static BOOL    WINAPI IsFencePending(DWORD Fence);
    static VOID    WINAPI BlockOnFence(DWORD Fence);
    static VOID    WINAPI InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context);
    static VOID    WINAPI FlushVertexCache();
    static void    WINAPI SetFlickerFilter(DWORD Filter);
    static void    WINAPI SetSoftDisplayFilter(BOOL Enable);
    static HRESULT WINAPI SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState);
    static HRESULT WINAPI GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState);
    static HRESULT WINAPI PersistDisplay();
    static HRESULT WINAPI GetPersistedSurface(IDirect3DSurface8 **ppSurface);
    static DWORD   WINAPI Swap(DWORD Flags);
    static HRESULT WINAPI SetBackBufferScale(float x, float y);
    static HRESULT WINAPI GetBackBufferScale(float *pX, float *pY);
    static HRESULT WINAPI SetScreenSpaceOffset(float x, float Y);
    static HRESULT WINAPI GetScreenSpaceOffset(float *pX, float *pY);
    static void    WINAPI SetOverscanColor(D3DCOLOR Color);
    static D3DCOLOR WINAPI GetOverscanColor();
    static DWORD   WINAPI SetDebugMarker(DWORD Marker);
    static DWORD   WINAPI GetDebugMarker();
};

#endif __cplusplus

/*
 * D3DResource, IDirect3DResource8 interface
 *
 * The root structure of all D3D 'resources' such as textures and vertex buffers.
 */

#define D3DCOMMON_REFCOUNT_MASK      0x0000FFFF

#define D3DCOMMON_TYPE_MASK          0x00070000
#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PUSHBUFFER    0x00020000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_TYPE_FIXUP         0x00060000

#define D3DCOMMON_INTREFCOUNT_MASK   0x00780000
#define D3DCOMMON_INTREFCOUNT_SHIFT  19

// This flag was used for UMA emulation on pre-Beta development kit
// machines, and is deprecated on the final hardware.
//
#define D3DCOMMON_VIDEOMEMORY        0

// Internal flag to indicate that this resource was created by Direct3D 
//
#define D3DCOMMON_D3DCREATED         0x01000000

// The rest of the bits may be used by derived classes.
#define D3DCOMMON_UNUSED_MASK        0xFE000000
#define D3DCOMMON_UNUSED_SHIFT       25

#ifdef __cplusplus

struct D3DResource
{
    ULONG WINAPI AddRef();

    // DOC:  If the GPU is currently using this object when the last call 
    //   to release is made then this call will block until the GPU is done 
    //   with this object.  The caller will have to manually check this if 
    //   they do not want this call to block.
    //
    ULONG WINAPI Release();

    HRESULT WINAPI GetDevice(D3DDevice **ppDevice);
    D3DRESOURCETYPE WINAPI GetType();

    HRESULT WINAPI SetPrivateData(REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags);
    HRESULT WINAPI GetPrivateData(REFGUID refguid, void *pData, DWORD *pSizeOfData);
    HRESULT WINAPI FreePrivateData(REFGUID refguid);

    // DOC: This additional method returns TRUE if the data for this
    //  : resource is currently being used by the GPU.  This can be used
    //  : to avoid blocking in Release and Lock.  This will always return
    //  : TRUE if the resource is currently set on the device.
    //
    BOOL WINAPI IsBusy();

    // DOC: A blocking form of 'IsBusy' that ensure that this resource is
    //  : no longer used by the GPU.  This will wait for the GPU to go
    //  : idle if this resource is set on the device.
    //
    void    WINAPI BlockUntilNotBusy();

    // DOC: On pre-beta development kits, this API set whether the we should 
    //  ; use video or AGP memory for the data of this resource.  
    //  ;
    //  ; This API has been deprecated on the final hardware.
    //
    void    WINAPI MoveResourceMemory(D3DMEMORY where);

    // DOC: Performs some debug checks and maps the resource's 
    //  : data field from a contiguous memory address to the physical memory
    //  : address.  It should be called for any resource that is not created
    //  : through an D3DDevice "Create" routine.
    //  :
    //  : This API does not modify any state in the resource besides the
    //  : Data field nor does the library keep track of what resources
    //  : have been registered.  
    //  :
    //  : This method takes a contiguous memory address, adds the current
    //  : contents of the Data field to it, converts it to a physical
    //  : address and sets that as the Data field of the resource.
    //
    void    WINAPI Register(void *pBase);

    // All resources need these fields.  Inherit them in C++.

    DWORD Common;           // Refcount and flags common to all resources
    DWORD Data;             // Offset to the data held by this resource
    DWORD Lock;             // Lock information, initialize to zero
};

#endif __cplusplus

/*
 * D3DPixelContainer interface
 *
 * A base structure that describes the shared layout between textures
 * and surfaces.
 */

// The layout of the Format field.

#define D3DFORMAT_RESERVED1_MASK        0x00000003      // Must be zero
                                        
#define D3DFORMAT_DMACHANNEL_MASK       0x00000003
#define D3DFORMAT_DMACHANNEL_A          0x00000001      // DMA channel A - the default for all system memory
#define D3DFORMAT_DMACHANNEL_B          0x00000002      // DMA channel B - unused
#define D3DFORMAT_CUBEMAP               0x00000004      // Set if the texture if a cube map
#define D3DFORMAT_BORDERSOURCE_COLOR    0x00000008
#define D3DFORMAT_DIMENSION_MASK        0x000000F0      // # of dimensions
#define D3DFORMAT_DIMENSION_SHIFT       4
#define D3DFORMAT_FORMAT_MASK           0x0000FF00
#define D3DFORMAT_FORMAT_SHIFT          8
#define D3DFORMAT_MIPMAP_MASK           0x000F0000 
#define D3DFORMAT_MIPMAP_SHIFT          16
#define D3DFORMAT_USIZE_MASK            0x00F00000      // Log 2 of the U size of the base texture
#define D3DFORMAT_USIZE_SHIFT           20
#define D3DFORMAT_VSIZE_MASK            0x0F000000      // Log 2 of the V size of the base texture
#define D3DFORMAT_VSIZE_SHIFT           24
#define D3DFORMAT_PSIZE_MASK            0xF0000000      // Log 2 of the P size of the base texture
#define D3DFORMAT_PSIZE_SHIFT           28

// The layout of the size field, used for non swizzled or compressed textures.
// 
// The Size field of a container will be zero if the texture is swizzled or compressed.
// It is guarenteed to be non-zero otherwise because either the height/width will be 
// greater than one or the pitch adjust will be nonzero because the minimum texture
// pitch is 8 bytes.

#define D3DSIZE_WIDTH_MASK              0x00000FFF   // Width of the texture - 1, in texels
#define D3DSIZE_HEIGHT_MASK             0x00FFF000   // Height of the texture - 1, in texels
#define D3DSIZE_HEIGHT_SHIFT            12
#define D3DSIZE_PITCH_MASK              0xFF000000   // Pitch / 64 - 1
#define D3DSIZE_PITCH_SHIFT             24

#define D3DTEXTURE_ALIGNMENT            128
#define D3DTEXTURE_CUBEFACE_ALIGNMENT   128

#define D3DTEXTURE_PITCH_ALIGNMENT 64
#define D3DTEXTURE_PITCH_MIN       64

#ifdef __cplusplus

struct D3DPixelContainer : public D3DResource
{
    DWORD Format;   // Format information about the texture.
    DWORD Size;     // Size of a non power-of-2 texture, must be zero otherwise
};

#endif __cplusplus

/*
 * D3DBaseTexture interface
 *
 * The root structure of all D3D textures.  Inherits all of the methods
 * from D3DResource.
 *
 * The data memory pointed to by the Data field must be aligned on a
 * D3DTEXTURE_ALIGNMENT byte multiple.
 */

struct D3DBaseTexture
    #ifdef __cplusplus
        : public D3DPixelContainer
    #endif
{

#ifdef __cplusplus
    DWORD WINAPI GetLevelCount();
#endif

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

    DWORD Format;   // Format information about the texture.
    DWORD Size;     // Size of a non power-of-2 texture, must be zero otherwise
#endif

};


/*
 * D3DTexture, IDirect3DTexture8 interface
 *
 * A normal texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI GetSurfaceLevel(UINT Level, D3DSurface **ppSurfaceLevel);
    HRESULT WINAPI LockRect(UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect(UINT Level);
};

#endif __cplusplus


/*
 * D3DVolumeTexture, IDirect3DVolumeTexture8 interface
 *
 * A volume texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DVolumeTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DVOLUME_DESC *pDesc);
    HRESULT WINAPI GetVolumeLevel(UINT Level, D3DVolume **ppVolumeLevel);
    HRESULT WINAPI LockBox(UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
    HRESULT WINAPI UnlockBox(UINT Level);
};

#endif __cplusplus


/*
 * D3DCubeTexture, IDirect3DCubeTexture8 interface
 *
 * A cube texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DCubeTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface);
    HRESULT WINAPI LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level);
};

#endif __cplusplus


/*
 * D3DVertexBuffer, IDirect3DVertexBuffer8 interface
 *
 * A vertex buffer.
 *
 * The data for the vertex buffer must be aligned on a 
 * D3DVERTEXBUFFER_ALIGNMENT byte multiple.
 */

#define D3DVERTEXBUFFER_ALIGNMENT     4    

struct D3DVertexBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
    HRESULT WINAPI Unlock();
    HRESULT WINAPI GetDesc(D3DVERTEXBUFFER_DESC *pDesc);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DIndexBuffer, IDirect3DIndexBuffer8 interface
 *
 * An index buffer.
 *
 * The data for the index buffer must be aligned on a D3DINDEXBUFFER_ALIGNMENT
 * byte multiple.
 */

#define D3DINDEXBUFFER_ALIGNMENT        4      

struct D3DIndexBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
    HRESULT WINAPI Unlock();
    HRESULT WINAPI GetDesc(D3DINDEXBUFFER_DESC *pDesc);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;                    
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DPalette, IDirect3DPalette8 interface
 *
 * A palette.
 */

#define D3DPALETTE_ALIGNMENT 64

#define D3DPALETTE_COMMON_VIDEOMEMORY            0
#define D3DPALETTE_COMMON_UNUSED                 0x20000000
#define D3DPALETTE_COMMON_PALETTESIZE_MASK       0xC0000000
#define D3DPALETTE_COMMON_PALETTESIZE_SHIFT      30

#define D3DPALETTE_COMMON_PALETTESET_SHIFT       28
#define D3DPALETTE_COMMON_PALETTESET_MASK        0xF

struct D3DPalette
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(D3DCOLOR **ppColors, DWORD Flags);
    HRESULT WINAPI Unlock();
    D3DPALETTESIZE WINAPI GetSize();

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DSurface, IDirect3DSurface8 interface
 *
 * Abstracts a chunk of data that can be drawn to.  The Common and Format
 * fields use the D3DCOMMON and D3DFORMAT constants defined for
 * textures.
 */

#define D3DSURFACE_ALIGNMENT    D3D_RENDER_MEMORY_ALIGNMENT
#define D3DSURFACE_OWNSMEMORY   0x80000000

struct D3DSurface
    #if defined(__cplusplus)
        : public D3DPixelContainer
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI GetContainer(D3DBaseTexture **ppBaseTexture);
    HRESULT WINAPI GetDesc(D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI LockRect(D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect();

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DPixelContainer
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format;
    DWORD Size;

#endif

    D3DBaseTexture *Parent; 
};


/*
 * D3DVolume, IDirect3DVolume8 interface
 */

#define D3DVOLUME_ALIGNMENT    D3D_RENDER_MEMORY_ALIGNMENT
#define D3DVOLUME_OWNSMEMORY   0x800000000

struct D3DVolume
    #if defined(__cplusplus)
        : public D3DPixelContainer
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI GetContainer(D3DBaseTexture **ppBaseTexture);
    HRESULT WINAPI GetDesc(D3DVOLUME_DESC *pDesc);
    HRESULT WINAPI LockBox(D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
    HRESULT WINAPI UnlockBox();

#endif

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format; 
    DWORD Size;

#endif

    D3DBaseTexture *Parent; 
};


/*
 * D3DPushBuffer, IDirect3DPushBuffer8 interface
 *
 * A push-buffer resource.
 */

#define D3DPUSHBUFFER_ALIGNMENT 4

// The following flag, when set in the Common field, dictates that when 
// RunPushBuffer is called, the push-buffer is copied using the CPU instead 
// of executed in-place by the GPU.  This should be used for small push-
// buffers to avoid the high latency cost of the GPU JUMP command.  In this
// case, the memory should be cacheable (not write-combined), and need not
// be physically contiguous.
#define D3DPUSHBUFFER_RUN_USING_CPU_COPY  0x80000000

struct D3DPushBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Verify(BOOL StampResources);
    HRESULT WINAPI BeginFixup(D3DFixup* pFixup, BOOL NoWait);
    HRESULT WINAPI EndFixup();
    HRESULT WINAPI RunPushBuffer(DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup);
    HRESULT WINAPI SetModelView(DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
    HRESULT WINAPI SetVertexBlendModelView(DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
    HRESULT WINAPI SetVertexShaderInput(DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
    HRESULT WINAPI SetVertexShaderInputDirect(DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
    HRESULT WINAPI SetRenderTarget(DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer);
    HRESULT WINAPI SetTexture(DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture);
    HRESULT WINAPI SetPalette(DWORD Offset, DWORD Stage,D3DPalette *pPalette);
    HRESULT WINAPI EndVisibilityTest(DWORD Offset, DWORD Index);
    HRESULT WINAPI SetVertexShaderConstant(DWORD Offset, INT Register, CONST VOID* pConstantData, DWORD ConstantCount);
    HRESULT WINAPI Jump(DWORD Offset, UINT DestinationOffset);
    HRESULT WINAPI GetSize(DWORD* pSize);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource.  
    //
    // Note (in an exception to all other resources) that 'Data' is a virtual 
    // address for the D3DPUSHBUFFER_RUN_USING_CPU_COPY case.
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

    // Size, in bytes, of the push-buffer program.
    DWORD Size;

    // Size, in bytes, of the allocation of the buffer pointed to by 'Data'.
    DWORD AllocationSize;
};


/*
 * D3DFixup, IFixup8 interface
 *
 * A fix-up resource for push-buffers.
 */

#define D3DFIXUP_ALIGNMENT 4

struct D3DFixup
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Reset(); 
    HRESULT WINAPI GetSize(DWORD* pSize);
    HRESULT WINAPI GetSpace(DWORD* pSpace);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource.  
    //
    // Note that 'Data' is always a virtual address.
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

    // Offset to the last completed fix-up.  RunPushBuffer uses this and 'Data'.
    DWORD Run;

    // Offset to where we'll append the next fix-up.
    DWORD Next;

    // Size of the whole allocation.
    DWORD Size;
};


/*
 * Helper methods.
 */

//----------------------------------------------------------------------------
// Allocate a block of contiguous memory and return a write-combined
// pointer to it.  This memory is suitable to be used as the data
// for any of the D3D structures.
//
// Returns NULL if the memory could not be allocated.
//
void* WINAPI D3D_AllocContiguousMemory(
    DWORD Size,         // The size of the allocation in bytes
    DWORD Alignment     // The alignment of the allocation
    );

//----------------------------------------------------------------------------
// Frees memory allocated by the above method.
//
    
void WINAPI D3D_FreeContiguousMemory(
    void *pMemory       // The block of memory to free
    );


//----------------------------------------------------------------------------
// D3D_CopyContiguousMemory has been deprecated on the final hardware.
// Use CopyRects instead.  
//
// With the API as speced, this function was hideously expensive because 
// it had to flush the GPU's entire push-buffer, and then spin the CPU until 
// the copy was done.  CopyRects lets everything be nicely asynchronous,
// just as it is with all other GPU APIs.  
// 
// To get equivalent behavior with CopyRects, use XGSetSurfaceHeader to create
// wrapper surfaces around the memory (the pitches should equal the widths 
// times the pixel size and not be more than 8128).  Then surface.IsBusy(),
// LockRect(), and the other standard synchronization APIs may be used to
// determine when the copy is done.
//
// void WINAPI D3D_CopyContiguousMemory(
//     void *pSource,
//     void *pDest,
//     DWORD Size
//     ); 

//----------------------------------------------------------------------------
// On pre-beta development kits, this function was used to copy data
// from AGP memory to video memory.
//
// This function is deprecated on the final hardware.
//
D3DINLINE void WINAPI D3D_CopyContiguousMemoryToVideo(
    void *pMemory          // Contiguous memory block to move.
    )
{
}


/*
 * C exported method definitions for the class methods defined above and the C++
 * thunks that defer to them.
 */

/* Direct3D */

D3DINLINE ULONG   WINAPI Direct3D_AddRef() { return 1; }
D3DINLINE ULONG   WINAPI Direct3D_Release() { return 1; }
D3DINLINE UINT    WINAPI Direct3D_GetAdapterCount() { return 1; }
HRESULT WINAPI Direct3D_GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier);
UINT    WINAPI Direct3D_GetAdapterModeCount(UINT Adapter);
HRESULT WINAPI Direct3D_EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode);
HRESULT WINAPI Direct3D_GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode);
HRESULT WINAPI Direct3D_CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
HRESULT WINAPI Direct3D_CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
HRESULT WINAPI Direct3D_CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
HRESULT WINAPI Direct3D_CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat);
HRESULT WINAPI Direct3D_GetDeviceCaps(UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps);
HRESULT WINAPI Direct3D_CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface);
void    WINAPI Direct3D_SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize);

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3D8_AddRef(Direct3D *pThis) { return Direct3D_AddRef(); }
D3DINLINE ULONG   WINAPI IDirect3D8_Release(Direct3D *pThis) { return Direct3D_Release(); }
D3DINLINE UINT    WINAPI IDirect3D8_GetAdapterCount(Direct3D *pThis) { return Direct3D_GetAdapterCount(); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetAdapterIdentifier(Direct3D *pThis, UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier) { return Direct3D_GetAdapterIdentifier(Adapter, Flags, pIdentifier); }
D3DINLINE UINT    WINAPI IDirect3D8_GetAdapterModeCount(Direct3D *pThis, UINT Adapter) { return Direct3D_GetAdapterModeCount(Adapter); }
D3DINLINE HRESULT WINAPI IDirect3D8_EnumAdapterModes(Direct3D *pThis, UINT Adapter, UINT iMode, D3DDISPLAYMODE *pMode) { return Direct3D_EnumAdapterModes(Adapter, iMode, pMode); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetAdapterDisplayMode(Direct3D *pThis, UINT Adapter, D3DDISPLAYMODE *pMode) { return Direct3D_GetAdapterDisplayMode(Adapter, pMode); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceType(Direct3D *pThis, UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed) { return Direct3D_CheckDeviceType(Adapter, CheckType, DisplayFormat, BackBufferFormat, Windowed); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceFormat(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) { return Direct3D_CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceMultiSampleType(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType) { return Direct3D_CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDepthStencilMatch(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) { return Direct3D_CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetDeviceCaps(Direct3D *pThis, UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps) { return Direct3D_GetDeviceCaps(Adapter, DeviceType, pCaps); }
D3DINLINE HRESULT WINAPI IDirect3D8_CreateDevice(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface) { return Direct3D_CreateDevice(Adapter, DeviceType, pUnused, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface); }
D3DINLINE HRESULT WINAPI IDirect3D8_SetPushBufferSize(Direct3D *pThis, DWORD PushBufferSize, DWORD KickOffSize) { Direct3D_SetPushBufferSize(PushBufferSize, KickOffSize); return S_OK; }

#ifdef __cplusplus

D3DMINLINE ULONG   WINAPI Direct3D::AddRef() { return Direct3D_AddRef(); }
D3DMINLINE ULONG   WINAPI Direct3D::Release() { return Direct3D_Release(); }
D3DMINLINE UINT    WINAPI Direct3D::GetAdapterCount() { return Direct3D_GetAdapterCount(); }
D3DMINLINE HRESULT WINAPI Direct3D::GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier) { return Direct3D_GetAdapterIdentifier(Adapter, Flags, pIdentifier); }
D3DMINLINE UINT    WINAPI Direct3D::GetAdapterModeCount(UINT Adapter) { return Direct3D_GetAdapterModeCount(Adapter); }
D3DMINLINE HRESULT WINAPI Direct3D::EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode) { return Direct3D_EnumAdapterModes(Adapter, Mode, pMode); }
D3DMINLINE HRESULT WINAPI Direct3D::GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode) { return Direct3D_GetAdapterDisplayMode(Adapter, pMode); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed) { return Direct3D_CheckDeviceType(Adapter, CheckType, DisplayFormat, BackBufferFormat, Windowed); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) { return Direct3D_CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType) { return Direct3D_CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) { return Direct3D_CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat); }
D3DMINLINE HRESULT WINAPI Direct3D::GetDeviceCaps(UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS8 *pCaps) { return Direct3D_GetDeviceCaps(Adapter, DeviceType, pCaps); }
D3DMINLINE HRESULT WINAPI Direct3D::CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface) { return Direct3D_CreateDevice(Adapter, DeviceType, pUnused, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface); }
D3DMINLINE HRESULT WINAPI Direct3D::SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize) { Direct3D_SetPushBufferSize(PushBufferSize, KickOffSize); return S_OK; }

#endif __cplusplus

/* D3DDevice */

ULONG   WINAPI D3DDevice_AddRef();
ULONG   WINAPI D3DDevice_Release();
void    WINAPI D3DDevice_GetDirect3D(Direct3D **ppD3D8);
void    WINAPI D3DDevice_GetDeviceCaps(D3DCAPS8 *pCaps);
void    WINAPI D3DDevice_GetDisplayMode(D3DDISPLAYMODE *pMode);
void    WINAPI D3DDevice_GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters);
HRESULT WINAPI D3DDevice_Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
void    WINAPI D3DDevice_GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer);
void    WINAPI D3DDevice_GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);
void    WINAPI D3DDevice_SetFlickerFilter(DWORD Filter);
void    WINAPI D3DDevice_SetSoftDisplayFilter(BOOL Enable);
void    WINAPI D3DDevice_SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp);
void    WINAPI D3DDevice_GetGammaRamp(D3DGAMMARAMP *pRamp);
HRESULT WINAPI D3DDevice_CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture);
HRESULT WINAPI D3DDevice_CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture);
HRESULT WINAPI D3DDevice_CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture);
HRESULT WINAPI D3DDevice_CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer);
HRESULT WINAPI D3DDevice_CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer);
HRESULT WINAPI D3DDevice_CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette);
HRESULT WINAPI D3DDevice_CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface);
HRESULT WINAPI D3DDevice_CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface);
HRESULT WINAPI D3DDevice_CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface);
void    WINAPI D3DDevice_CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray);
void    WINAPI D3DDevice_SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState);
void    WINAPI D3DDevice_GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState);
void    WINAPI D3DDevice_SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil);
void    WINAPI D3DDevice_GetRenderTarget(D3DSurface **ppRenderTarget);
HRESULT WINAPI D3DDevice_GetDepthStencilSurface(D3DSurface **ppZStencilSurface);
D3DINLINE void    WINAPI D3DDevice_BeginScene() { }
D3DINLINE void    WINAPI D3DDevice_EndScene() { }
void    WINAPI D3DDevice_Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
void    WINAPI D3DDevice_SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_SetViewport(CONST D3DVIEWPORT8 *pViewport);
void    WINAPI D3DDevice_GetViewport(D3DVIEWPORT8 *pViewport);
void    WINAPI D3DDevice_SetMaterial(CONST D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_GetMaterial(D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_SetBackMaterial(CONST D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_GetBackMaterial(D3DMATERIAL8 *pMaterial);
HRESULT WINAPI D3DDevice_SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
void    WINAPI D3DDevice_GetLight(DWORD Index, D3DLIGHT8 *pLight);
HRESULT WINAPI D3DDevice_LightEnable(DWORD Index, BOOL Enable);
void    WINAPI D3DDevice_GetLightEnable(DWORD Index, BOOL *pEnable);
void    WINAPI D3DDevice_SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value);
HRESULT WINAPI D3DDevice_SetRenderState_ParameterCheck(D3DRENDERSTATETYPE State, DWORD Value);
void    D3DFASTCALL D3DDevice_SetRenderState_Simple(DWORD Method, DWORD Value);
void    WINAPI D3DDevice_SetRenderState_PSTextureModes(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_VertexBlend(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FogColor(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FillMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_BackFillMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_TwoSidedLighting(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_NormalizeNormals(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ZEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilFail(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_CullMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FrontFace(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_TextureFactor(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ZBias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_LogicOp(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_EdgeAntiAlias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleAntiAlias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleMask(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleRenderTargetMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ShadowFunc(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_LineWidth(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_Dxt1NoiseEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_YuvEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_OcclusionCullEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilCullEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_RopZCmpAlwaysRead(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_RopZRead(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_DoNotCullUncompressed(DWORD Value);
void    WINAPI D3DDevice_SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
HRESULT WINAPI D3DDevice_SetTextureState_ParameterCheck(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_BumpEnv(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_TexCoordIndex(DWORD Stage, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_BorderColor(DWORD Stage, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_ColorKeyColor(DWORD Stage, DWORD Value);
#if D3DCOMPILE_BEGINSTATEBLOCK
void    WINAPI D3DDevice_BeginStateBlock();
HRESULT WINAPI D3DDevice_EndStateBlock(DWORD *pToken);
#endif
void    WINAPI D3DDevice_ApplyStateBlock(DWORD Token);
void    WINAPI D3DDevice_CaptureStateBlock(DWORD Token);
void    WINAPI D3DDevice_DeleteStateBlock(DWORD Token);
HRESULT WINAPI D3DDevice_CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);
void    WINAPI D3DDevice_GetTexture(DWORD Stage, D3DBaseTexture **ppTexture);
void    WINAPI D3DDevice_SetTexture(DWORD Stage, D3DBaseTexture *pTexture);
void    WINAPI D3DDevice_GetPalette(DWORD Stage, D3DPalette **ppPalette);
void    WINAPI D3DDevice_SetPalette(DWORD Stage, D3DPalette *pPalette);
void    WINAPI D3DDevice_DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount);
void    WINAPI D3DDevice_DrawIndexedVertices(D3DPRIMITIVETYPE, UINT VertexCount, CONST WORD *pIndexData);
void    WINAPI D3DDevice_DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
void    WINAPI D3DDevice_DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
void    WINAPI D3DDevice_PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData);
HRESULT WINAPI D3DDevice_CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
void    WINAPI D3DDevice_SetVertexShader(DWORD Handle);
void    WINAPI D3DDevice_GetVertexShader(DWORD *pHandle);
void    WINAPI D3DDevice_DeleteVertexShader(DWORD Handle);
void    WINAPI D3DDevice_SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode);
void    WINAPI D3DDevice_GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode);
void    WINAPI D3DDevice_LoadVertexShader(DWORD Handle, DWORD Address);
void    WINAPI D3DDevice_LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address);
void    WINAPI D3DDevice_SelectVertexShader(DWORD Handle, DWORD Address);
void    WINAPI D3DDevice_SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address);
void    WINAPI D3DDevice_RunVertexStateShader(DWORD Address, CONST float *pData);
void    WINAPI D3DDevice_GetVertexShaderSize(DWORD Handle, UINT* pSize);
void    WINAPI D3DDevice_GetVertexShaderType(DWORD Handle, DWORD* pType);
HRESULT WINAPI D3DDevice_GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
HRESULT WINAPI D3DDevice_GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
void    WINAPI D3DDevice_SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride);
void    WINAPI D3DDevice_GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride);
void    WINAPI D3DDevice_SetIndices(D3DIndexBuffer* pIndexData, UINT BaseVertexIndex);
void    WINAPI D3DDevice_GetIndices(D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex);
void    WINAPI D3DDevice_CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle);
void    WINAPI D3DDevice_SetPixelShader(DWORD Handle);
void    WINAPI D3DDevice_SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef);
void    WINAPI D3DDevice_GetPixelShader(DWORD *pHandle);
void    WINAPI D3DDevice_DeletePixelShader(DWORD Handle);
void    WINAPI D3DDevice_SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData);
HRESULT WINAPI D3DDevice_DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
HRESULT WINAPI D3DDevice_DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
void    WINAPI D3DDevice_DeletePatch(UINT Handle);
void    WINAPI D3DDevice_UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey);
void    WINAPI D3DDevice_EnableOverlay(BOOL Enable);
void    WINAPI D3DDevice_BeginVisibilityTest();
HRESULT WINAPI D3DDevice_EndVisibilityTest(DWORD Index);
HRESULT WINAPI D3DDevice_GetVisibilityTestResult(DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp);
BOOL    WINAPI D3DDevice_IsBusy();
void    WINAPI D3DDevice_BlockUntilIdle();
void    WINAPI D3DDevice_KickPushBuffer();
void    WINAPI D3DDevice_SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback);
void    WINAPI D3DDevice_SetSwapCallback(D3DSWAPCALLBACK pCallback);
void    WINAPI D3DDevice_BlockUntilVerticalBlank();
DWORD   WINAPI D3DDevice_InsertFence();
BOOL    WINAPI D3DDevice_IsFencePending(DWORD Fence);
VOID    WINAPI D3DDevice_BlockOnFence(DWORD Fence);
void    WINAPI D3DDevice_InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context);
void    WINAPI D3DDevice_FlushVertexCache();
HRESULT WINAPI D3DDevice_PersistDisplay();
HRESULT WINAPI D3DDevice_GetPersistedSurface(IDirect3DSurface8 **ppSurface);
BOOL    WINAPI D3DDevice_GetOverlayUpdateStatus();
void    WINAPI D3DDevice_GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus);
void    WINAPI D3DDevice_SetVertexData2f(INT Register, float a, float b);
void    WINAPI D3DDevice_SetVertexData4f(INT Register, float a, float b, float c, float d);
void    WINAPI D3DDevice_SetVertexData2s(INT Register, SHORT a, SHORT b);
void    WINAPI D3DDevice_SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d);
void    WINAPI D3DDevice_SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d);
void    WINAPI D3DDevice_SetVertexDataColor(INT Register, D3DCOLOR Color);
void    WINAPI D3DDevice_Begin(D3DPRIMITIVETYPE PrimitiveType);
void    WINAPI D3DDevice_End();
HRESULT WINAPI D3DDevice_CreateFixup(UINT Size, D3DFixup **ppFixup);
HRESULT WINAPI D3DDevice_CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer);
void    WINAPI D3DDevice_BeginPushBuffer(D3DPushBuffer *pPushBuffer);
HRESULT WINAPI D3DDevice_EndPushBuffer();
void    WINAPI D3DDevice_RunPushBuffer(D3DPushBuffer *pPushBuffer, D3DFixup *pFixup);
void    WINAPI D3DDevice_GetPushBufferOffset(DWORD* pOffset);
void    WINAPI D3DDevice_Nop();
void    WINAPI D3DDevice_GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport);
void    WINAPI D3DDevice_SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
HRESULT WINAPI D3DDevice_GetModelView(D3DMATRIX* pModelView);
void    WINAPI D3DDevice_SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
HRESULT WINAPI D3DDevice_GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport);
void    WINAPI D3DDevice_SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
void    WINAPI D3DDevice_SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
HRESULT WINAPI D3DDevice_GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs);
void    D3DFASTCALL D3DDevice_SwitchTexture(DWORD Method, DWORD Data, DWORD Format);
void    WINAPI D3DDevice_Suspend();
void    WINAPI D3DDevice_Resume(BOOL Reset);
void    WINAPI D3DDevice_SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects);
void    WINAPI D3DDevice_GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects);
void    WINAPI D3DDevice_SetTile(DWORD Index, CONST D3DTILE* pTile);
void    WINAPI D3DDevice_GetTile(DWORD Index, D3DTILE* pTile);
DWORD   WINAPI D3DDevice_GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag);
void    WINAPI D3DDevice_SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count);
void    WINAPI D3DDevice_GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
void    WINAPI D3DDevice_BeginPush(DWORD Count, DWORD **ppPush);
void    WINAPI D3DDevice_EndPush(DWORD *pPush);
DWORD   WINAPI D3DDevice_Swap(DWORD Flags);
void    WINAPI D3DDevice_SetBackBufferScale(float x, float y);
void    WINAPI D3DDevice_GetBackBufferScale(float *pX, float *pY);
void    WINAPI D3DDevice_SetScreenSpaceOffset(float x, float y);
void    WINAPI D3DDevice_GetScreenSpaceOffset(float *pX, float *pY);
void    WINAPI D3DDevice_SetOverscanColor(D3DCOLOR Color);
D3DCOLOR WINAPI D3DDevice_GetOverscanColor();

#ifdef _DEBUG
DWORD   WINAPI D3DDevice_SetDebugMarker(DWORD Marker);
DWORD   WINAPI D3DDevice_GetDebugMarker();
#else
D3DINLINE DWORD   WINAPI D3DDevice_SetDebugMarker(DWORD Marker) { return 0; }
D3DINLINE DWORD   WINAPI D3DDevice_GetDebugMarker() { return 0; }
#endif

D3DINLINE void D3DDevice_GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue)
{
    *pValue = D3D__RenderState[State];
}
D3DINLINE void D3DDevice_GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue)
{
    *pValue = D3D__TextureState[Stage][Type];
}

#if D3DCOMPILE_NOTINLINE
    
    D3DINLINE void D3DDevice_SetRenderState(D3DRENDERSTATETYPE State, DWORD Value)
    {
        D3DDevice_SetRenderStateNotInline(State, Value);
    }
    D3DINLINE void D3DDevice_SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
    {
        D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value);
    }

#else
    
    // This D3DINLINE version of SetRenderState has the nice advantage that it
    // essentially moves to compile-time the big 'switch' statement for
    // handling all the render state types.  When given a constant value for 
    // 'State', all of these 'if's get nicely compiled away.  We can't use a 
    // static call-table because the compiler cannot remove the indirect.
    //
    // If you're calling SetRenderState with a non-constant value for 'State',
    // it's better to call SetRenderStateNotInline (it will reduce code bloat
    // and be a bit faster because the non-D3DINLINE version uses a call-table).
    //
    D3DINLINE void D3DDevice_SetRenderState(D3DRENDERSTATETYPE State, DWORD Value)
    {
        #ifdef _DEBUG
        if (D3DDevice_SetRenderState_ParameterCheck(State, Value) != S_OK)
            return;
        #endif

        if (State < D3DRS_SIMPLE_MAX)
        {
            D3DDevice_SetRenderState_Simple(D3DSIMPLERENDERSTATEENCODE[State], Value);
            #if !D3DCOMPILE_PUREDEVICE
            D3D__RenderState[State] = Value;
            #endif
        }
        else if (State < D3DRS_DEFERRED_MAX)
        {
            D3D__DirtyFlags |= D3DDIRTYFROMRENDERSTATE[State - D3DRS_SIMPLE_MAX];
            D3D__RenderState[State] = Value;
        }
        else if (State == D3DRS_PSTEXTUREMODES)
        {
            D3DDevice_SetRenderState_PSTextureModes(Value);
        }
        else if (State == D3DRS_VERTEXBLEND)
        {
            D3DDevice_SetRenderState_VertexBlend(Value);
        }
        else if (State == D3DRS_FOGCOLOR)
        {
            D3DDevice_SetRenderState_FogColor(Value);
        }
        else if (State == D3DRS_FILLMODE)
        {
            D3DDevice_SetRenderState_FillMode(Value);
        }
        else if (State == D3DRS_BACKFILLMODE)
        {
            D3DDevice_SetRenderState_BackFillMode(Value);
        }
        else if (State == D3DRS_TWOSIDEDLIGHTING)
        {
            D3DDevice_SetRenderState_TwoSidedLighting(Value);
        }
        else if (State == D3DRS_NORMALIZENORMALS)
        {
            D3DDevice_SetRenderState_NormalizeNormals(Value);
        }
        else if (State == D3DRS_ZENABLE)
        {
            D3DDevice_SetRenderState_ZEnable(Value);
        }
        else if (State == D3DRS_STENCILENABLE)
        {
            D3DDevice_SetRenderState_StencilEnable(Value);
        }
        else if (State == D3DRS_STENCILFAIL)
        {
            D3DDevice_SetRenderState_StencilFail(Value);
        }
        else if (State == D3DRS_CULLMODE)
        {
            D3DDevice_SetRenderState_CullMode(Value);
        }
        else if (State == D3DRS_FRONTFACE)
        {
            D3DDevice_SetRenderState_FrontFace(Value);
        }
        else if (State == D3DRS_TEXTUREFACTOR)
        {
            D3DDevice_SetRenderState_TextureFactor(Value);
        }
        else if (State == D3DRS_ZBIAS)
        {
            D3DDevice_SetRenderState_ZBias(Value);
        }
        else if (State == D3DRS_LOGICOP)
        {
            D3DDevice_SetRenderState_LogicOp(Value);
        }
        else if (State == D3DRS_EDGEANTIALIAS)
        {
            D3DDevice_SetRenderState_EdgeAntiAlias(Value);
        }
        else if (State == D3DRS_MULTISAMPLEANTIALIAS)
        {
            D3DDevice_SetRenderState_MultiSampleAntiAlias(Value);
        }
        else if (State == D3DRS_MULTISAMPLEMASK)
        {
            D3DDevice_SetRenderState_MultiSampleMask(Value);
        }
        else if (State == D3DRS_MULTISAMPLEMODE)
        {
            D3DDevice_SetRenderState_MultiSampleMode(Value);
        }
        else if (State == D3DRS_MULTISAMPLERENDERTARGETMODE)
        {
            D3DDevice_SetRenderState_MultiSampleRenderTargetMode(Value);
        }
        else if (State == D3DRS_SHADOWFUNC)
        {
            D3DDevice_SetRenderState_ShadowFunc(Value);
        }
        else if (State == D3DRS_LINEWIDTH)
        {
            D3DDevice_SetRenderState_LineWidth(Value);
        }
        else if (State == D3DRS_DXT1NOISEENABLE)
        {
            D3DDevice_SetRenderState_Dxt1NoiseEnable(Value);
        }
        else if (State == D3DRS_YUVENABLE)
        {
            D3DDevice_SetRenderState_YuvEnable(Value);
        }
        else if (State == D3DRS_OCCLUSIONCULLENABLE)
        {
            D3DDevice_SetRenderState_OcclusionCullEnable(Value);
        }
        else if (State == D3DRS_STENCILCULLENABLE)
        {
            D3DDevice_SetRenderState_StencilCullEnable(Value);
        }
        else if (State == D3DRS_ROPZCMPALWAYSREAD)
        {
            D3DDevice_SetRenderState_RopZCmpAlwaysRead(Value);
        }
        else if (State == D3DRS_ROPZREAD)
        {
            D3DDevice_SetRenderState_RopZRead(Value);
        }
        else if (State == D3DRS_DONOTCULLUNCOMPRESSED)
        {
            D3DDevice_SetRenderState_DoNotCullUncompressed(Value);
        }
    }

    // As above, but for SetTextureStageState:

    D3DINLINE void D3DDevice_SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
    {
        #ifdef _DEBUG
        if (D3DDevice_SetTextureState_ParameterCheck(Stage, Type, Value) != S_OK)
            return;
        #endif
        
        if (Type < D3DTSS_DEFERRED_TEXTURE_STATE_MAX)
        {
            D3D__DirtyFlags |= (D3DDIRTYFLAG_TEXTURE_STATE_0 << Stage);
            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type == D3DTSS_COLOROP)
        {
            // Only D3DTOP_BUMPENVMAP and D3DTOP_BUMPENVMAPLUMINANCE require the
            // sign flags and shader program to be recomputed:

            D3D__DirtyFlags |= (Value < D3DTOP_BUMPENVMAP)
                             ? (D3DDIRTYFLAG_COMBINERS)
                             : (D3DDIRTYFLAG_COMBINERS | 
                                D3DDIRTYFLAG_SHADER_STAGE_PROGRAM | 
                                D3DDIRTYFLAG_TEXTURE_STATE);

            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type < D3DTSS_DEFERRED_MAX)
        {
            D3D__DirtyFlags |= D3DDIRTYFROMTEXTURESTATE[Type];
            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type == D3DTSS_TEXCOORDINDEX)
        {
            D3DDevice_SetTextureState_TexCoordIndex(Stage, Value);
        }
        else if (Type == D3DTSS_BORDERCOLOR)
        {
            D3DDevice_SetTextureState_BorderColor(Stage, Value);
        }
        else if (Type == D3DTSS_COLORKEYCOLOR)
        {
            D3DDevice_SetTextureState_ColorKeyColor(Stage, Value);
        }
        else if ((Type >= D3DTSS_BUMPENVMAT00) && (Type <= D3DTSS_BUMPENVLOFFSET))
        {
            D3DDevice_SetTextureState_BumpEnv(Stage, Type, Value);
        }
    }

#endif

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DDevice8_AddRef(D3DDevice *pThis) { return D3DDevice_AddRef(); }
D3DINLINE ULONG   WINAPI IDirect3DDevice8_Release(D3DDevice *pThis) { return D3DDevice_Release(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDirect3D(D3DDevice *pThis, Direct3D **ppD3D8) { D3DDevice_GetDirect3D(ppD3D8); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDeviceCaps(D3DDevice *pThis, D3DCAPS8 *pCaps) { D3DDevice_GetDeviceCaps(pCaps); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDisplayMode(D3DDevice *pThis, D3DDISPLAYMODE *pMode) { D3DDevice_GetDisplayMode(pMode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetCreationParameters(D3DDevice *pThis, D3DDEVICE_CREATION_PARAMETERS *pParameters) { D3DDevice_GetCreationParameters(pParameters); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Reset(D3DDevice *pThis, D3DPRESENT_PARAMETERS *pPresentationParameters) { return D3DDevice_Reset(pPresentationParameters); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Present(D3DDevice *pThis, CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2) { D3DDevice_Swap(0); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackBuffer(D3DDevice *pThis, INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer) { D3DDevice_GetBackBuffer(BackBuffer, Type, ppBackBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRasterStatus(D3DDevice *pThis, D3DRASTER_STATUS *pRasterStatus) { D3DDevice_GetRasterStatus(pRasterStatus); return S_OK; }
D3DINLINE void    WINAPI IDirect3DDevice8_SetFlickerFilter(D3DDevice *pThis, DWORD Filter) { D3DDevice_SetFlickerFilter(Filter); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetSoftDisplayFilter(D3DDevice *pThis, BOOL Enable) { D3DDevice_SetSoftDisplayFilter(Enable); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetGammaRamp(D3DDevice *pThis, DWORD Flags, CONST D3DGAMMARAMP *pRamp) { D3DDevice_SetGammaRamp(Flags, pRamp); }
D3DINLINE void    WINAPI IDirect3DDevice8_GetGammaRamp(D3DDevice *pThis, D3DGAMMARAMP *pRamp) { D3DDevice_GetGammaRamp(pRamp); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateTexture(D3DDevice *pThis, UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture) { return D3DDevice_CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVolumeTexture(D3DDevice *pThis, UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture) { return D3DDevice_CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateCubeTexture(D3DDevice *pThis, UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture) { return D3DDevice_CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVertexBuffer(D3DDevice *pThis, UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer) { return D3DDevice_CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateIndexBuffer(D3DDevice *pThis, UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer) { return D3DDevice_CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePalette(D3DDevice *pThis, D3DPALETTESIZE Size, D3DPalette **ppPalette) { return D3DDevice_CreatePalette(Size, ppPalette); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateRenderTarget(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface) { return D3DDevice_CreateRenderTarget(Width, Height, Format, MultiSample, Lockable, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateDepthStencilSurface(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface) { return D3DDevice_CreateDepthStencilSurface(Width, Height, Format, MultiSample, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateImageSurface(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface) { return D3DDevice_CreateImageSurface(Width, Height, Format, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CopyRects(D3DDevice *pThis, D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray) { D3DDevice_CopyRects(pSourceSurface, pSourceRectsArray, cRects, pDestinationSurface, pDestPointsArray); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_SetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_GetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderTarget(D3DDevice *pThis, D3DSurface *pRenderTarget, D3DSurface *pNewZStencil) { D3DDevice_SetRenderTarget(pRenderTarget, pNewZStencil); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRenderTarget(D3DDevice *pThis, D3DSurface **ppRenderTarget) { D3DDevice_GetRenderTarget(ppRenderTarget); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDepthStencilSurface(D3DDevice *pThis, D3DSurface **ppZStencilSurface) { return D3DDevice_GetDepthStencilSurface(ppZStencilSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginScene(D3DDevice *pThis) { D3DDevice_BeginScene(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndScene(D3DDevice *pThis) { D3DDevice_EndScene(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Clear(D3DDevice *pThis, DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) { D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDIRTY_TRANSFORM(State); D3DDevice_SetTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix) { D3DDevice_GetTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_MultiplyTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDevice_MultiplyTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetViewport(D3DDevice *pThis, CONST D3DVIEWPORT8 *pViewport) { D3DDIRTY_VIEWPORT(); D3DDevice_SetViewport(pViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetViewport(D3DDevice *pThis, D3DVIEWPORT8 *pViewport) { D3DDevice_GetViewport(pViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetMaterial(D3DDevice *pThis, CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_MATERIAL(); D3DDevice_SetMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetMaterial(D3DDevice *pThis, D3DMATERIAL8 *pMaterial) { D3DDevice_GetMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetBackMaterial(D3DDevice *pThis, CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_BACKMATERIAL(); D3DDevice_SetBackMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackMaterial(D3DDevice *pThis, D3DMATERIAL8 *pMaterial) { D3DDevice_GetBackMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetLight(D3DDevice *pThis, DWORD Index, CONST D3DLIGHT8 *pLight) { return D3DDevice_SetLight(Index, pLight); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetLight(D3DDevice *pThis, DWORD Index, D3DLIGHT8 *pLight) { D3DDevice_GetLight(Index, pLight); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LightEnable(D3DDevice *pThis, DWORD Index, BOOL Enable) { return D3DDevice_LightEnable(Index, Enable); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetLightEnable(D3DDevice *pThis, DWORD Index, BOOL *pEnable) { D3DDevice_GetLightEnable(Index, pEnable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderState(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderState(State, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderStateNotInline(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderStateNotInline(State, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRenderState(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD *pValue) { D3DDevice_GetRenderState(State, pValue); return S_OK; }
#if D3DCOMPILE_BEGINSTATEBLOCK
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginStateBlock(D3DDevice *pThis) { D3DDevice_BeginStateBlock(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndStateBlock(D3DDevice *pThis, DWORD *pToken) { return D3DDevice_EndStateBlock(pToken); }
#endif
D3DINLINE HRESULT WINAPI IDirect3DDevice8_ApplyStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_ApplyStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CaptureStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_CaptureStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeleteStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_DeleteStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateStateBlock(D3DDevice *pThis, D3DSTATEBLOCKTYPE Type,DWORD *pToken) { return D3DDevice_CreateStateBlock(Type, pToken); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture **ppTexture) { D3DDevice_GetTexture(Stage, ppTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture *pTexture) { D3DDIRTY_TEXTURE(Stage); D3DDevice_SetTexture(Stage, pTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPalette(D3DDevice *pThis, DWORD Stage, D3DPalette **ppPalette) { D3DDevice_GetPalette(Stage, ppPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPalette(D3DDevice *pThis, DWORD Stage, D3DPalette *pPalette) { D3DDevice_SetPalette(Stage, pPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTextureStageState(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue) { D3DDevice_GetTextureStageState(Stage, Type, pValue); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTextureStageState(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageState(Stage, Type, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTextureStageStateNotInline(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawPrimitive(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount)); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedPrimitive(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount) { D3DDevice_DrawIndexedVertices(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), D3D__IndexData + StartIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawPrimitiveUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedPrimitiveUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawVertices(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, VertexCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedVertices(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, WORD *pIndexData) { D3DDevice_DrawIndexedVertices(PrimitiveType, VertexCount, pIndexData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawVerticesUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, VertexCount, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedVerticesUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, VertexCount, pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_PrimeVertexCache(D3DDevice *pThis, UINT VertexCount, CONST WORD *pIndexData) { D3DDevice_PrimeVertexCache(VertexCount, pIndexData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVertexShader(D3DDevice *pThis, CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage) { return D3DDevice_CreateVertexShader(pDeclaration, pFunction, pHandle, Usage); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShader(D3DDevice *pThis, DWORD Handle) { D3DDIRTY_VERTEXSHADER(); D3DDevice_SetVertexShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShader(D3DDevice *pThis, DWORD *pHandle) { D3DDevice_GetVertexShader(pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeleteVertexShader(D3DDevice *pThis, DWORD Handle) { D3DDevice_DeleteVertexShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderConstant(D3DDevice *pThis, INT Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_VERTEXSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderConstant(D3DDevice *pThis, INT Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetShaderConstantMode(D3DDevice *pThis, D3DSHADERCONSTANTMODE Mode) { D3DDevice_SetShaderConstantMode(Mode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetShaderConstantMode(D3DDevice *pThis, D3DSHADERCONSTANTMODE *pMode) { D3DDevice_GetShaderConstantMode(pMode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LoadVertexShader(D3DDevice *pThis, DWORD Handle, DWORD Address) { D3DDevice_LoadVertexShader(Handle, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LoadVertexShaderProgram(D3DDevice *pThis, CONST DWORD *pFunction, DWORD Address) { D3DDevice_LoadVertexShaderProgram(pFunction, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SelectVertexShader(D3DDevice *pThis, DWORD Handle, DWORD Address) { D3DDevice_SelectVertexShader(Handle, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SelectVertexShaderDirect(D3DDevice *pThis, D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address) { D3DDevice_SelectVertexShaderDirect(pVAF, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_RunVertexStateShader(D3DDevice *pThis, DWORD Address, CONST float *pData) { D3DDevice_RunVertexStateShader(Address, pData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderSize(D3DDevice *pThis, DWORD Handle, UINT* pSize) { D3DDevice_GetVertexShaderSize(Handle, pSize); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderType(D3DDevice *pThis, DWORD Handle, DWORD* pType) { D3DDevice_GetVertexShaderType(Handle, pType); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderDeclaration(D3DDevice *pThis, DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderDeclaration(Handle, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderFunction(D3DDevice *pThis, DWORD Handle,void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderFunction(Handle, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetStreamSource(D3DDevice *pThis, UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride) { D3DDIRTY_STREAM(StreamNumber); D3DDevice_SetStreamSource(StreamNumber, pStreamData, Stride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetStreamSource(D3DDevice *pThis, UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride) { D3DDevice_GetStreamSource(StreamNumber, ppStreamData, pStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetIndices(D3DDevice *pThis, D3DIndexBuffer* pIndexData, UINT BaseVertexIndex) { D3DDIRTY_INDICES(); D3DDevice_SetIndices(pIndexData, BaseVertexIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetIndices(D3DDevice *pThis, D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex) { D3DDevice_GetIndices(ppIndexData, pBaseVertexIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePixelShader(D3DDevice *pThis, CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle) { D3DDevice_CreatePixelShader(pPSDef, pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShader(D3DDevice *pThis, DWORD Handle) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShaderProgram(D3DDevice *pThis, CONST D3DPIXELSHADERDEF *pPSDef) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShaderProgram(pPSDef); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShader(D3DDevice *pThis, DWORD *pHandle) { D3DDevice_GetPixelShader(pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeletePixelShader(D3DDevice *pThis, DWORD Handle) { D3DDevice_DeletePixelShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShaderConstant(D3DDevice *pThis, DWORD Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_PIXELSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShaderConstant(D3DDevice *pThis, DWORD Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShaderFunction(D3DDevice *pThis, DWORD Handle, D3DPIXELSHADERDEF *pData) { D3DDevice_GetPixelShaderFunction(Handle, pData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawRectPatch(D3DDevice *pThis, UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo) { return D3DDevice_DrawRectPatch(Handle, pNumSegs, pRectPatchInfo); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawTriPatch(D3DDevice *pThis, UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo) { return D3DDevice_DrawTriPatch(Handle, pNumSegs, pTriPatchInfo); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeletePatch(D3DDevice *pThis, UINT Handle) { D3DDevice_DeletePatch(Handle); return S_OK; }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_IsBusy(D3DDevice *pThis) { return D3DDevice_IsBusy(); }
D3DINLINE void    WINAPI IDirect3DDevice8_BlockUntilIdle(D3DDevice *pThis) { D3DDevice_BlockUntilIdle(); }
D3DINLINE void    WINAPI IDirect3DDevice8_KickPushBuffer(D3DDevice *pThis) { D3DDevice_KickPushBuffer(); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetVerticalBlankCallback(D3DDevice *pThis, D3DVBLANKCALLBACK pCallback) { D3DDevice_SetVerticalBlankCallback(pCallback); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetSwapCallback(D3DDevice *pThis, D3DSWAPCALLBACK pCallback) { D3DDevice_SetSwapCallback(pCallback); }
D3DINLINE void    WINAPI IDirect3DDevice8_BlockUntilVerticalBlank(D3DDevice *pThis) { D3DDevice_BlockUntilVerticalBlank(); }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_InsertFence(D3DDevice *pThis) { return D3DDevice_InsertFence(); }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_IsFencePending(D3DDevice *pThis, DWORD Fence) { return D3DDevice_IsFencePending(Fence); }
D3DINLINE VOID    WINAPI IDirect3DDevice8_BlockOnFence(D3DDevice *pThis, DWORD Fence) { D3DDevice_BlockOnFence(Fence); }
D3DINLINE void    WINAPI IDirect3DDevice8_InsertCallback(D3DDevice *pThis, D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context) { D3DDevice_InsertCallback(Type, pCallback, Context); }
D3DINLINE void    WINAPI IDirect3DDevice8_FlushVertexCache(D3DDevice *pThis) { D3DDevice_FlushVertexCache(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_PersistDisplay(D3DDevice *pThis) { return D3DDevice_PersistDisplay(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPersistedSurface(D3DDevice *pThis, IDirect3DSurface8 **ppSurface) { D3DDevice_GetPersistedSurface(ppSurface); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_UpdateOverlay(D3DDevice *pThis, D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey) { D3DDevice_UpdateOverlay(pSurface, SrcRect, DstRect, EnableColorKey, ColorKey); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EnableOverlay(D3DDevice *pThis, BOOL Enable) { D3DDevice_EnableOverlay(Enable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginVisibilityTest(D3DDevice *pThis) { D3DDevice_BeginVisibilityTest(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndVisibilityTest(D3DDevice *pThis, DWORD Index) { return D3DDevice_EndVisibilityTest(Index); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVisibilityTestResult(D3DDevice *pThis, DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp) { return D3DDevice_GetVisibilityTestResult(Index, pResult, pTimeStamp); }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_GetOverlayUpdateStatus(D3DDevice *pThis) { return D3DDevice_GetOverlayUpdateStatus(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDisplayFieldStatus(D3DDevice *pThis, D3DFIELD_STATUS *pFieldStatus) { D3DDevice_GetDisplayFieldStatus(pFieldStatus); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData2f(D3DDevice *pThis, INT Register, float a, float b) { D3DDevice_SetVertexData2f(Register, a, b); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4f(D3DDevice *pThis, INT Register, float a, float b, float c, float d) { D3DDevice_SetVertexData4f(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData2s(D3DDevice *pThis, INT Register, SHORT a, SHORT b) { D3DDevice_SetVertexData2s(Register, a, b); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4s(D3DDevice *pThis, INT Register, SHORT a, SHORT b, SHORT c, SHORT d) { D3DDevice_SetVertexData4s(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4ub(D3DDevice *pThis, INT Register, BYTE a, BYTE b, BYTE c, BYTE d) { D3DDevice_SetVertexData4ub(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexDataColor(D3DDevice *pThis, INT Register, D3DCOLOR Color) { D3DDevice_SetVertexDataColor(Register, Color); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Begin(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType) { D3DDevice_Begin(PrimitiveType); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_End(D3DDevice *pThis) { D3DDevice_End(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateFixup(D3DDevice *pThis, UINT Size, D3DFixup **ppFixup) { return D3DDevice_CreateFixup(Size, ppFixup); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePushBuffer(D3DDevice *pThis, UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer** ppPushBuffer) { return D3DDevice_CreatePushBuffer(Size, RunUsingCpuCopy, ppPushBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginPushBuffer(D3DDevice *pThis, D3DPushBuffer *pPushBuffer) { D3DDevice_BeginPushBuffer(pPushBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndPushBuffer(D3DDevice *pThis) { return D3DDevice_EndPushBuffer(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_RunPushBuffer(D3DDevice *pThis, D3DPushBuffer* pPushBuffer, D3DFixup *pFixup) { D3DDevice_RunPushBuffer(pPushBuffer, pFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPushBufferOffset(D3DDevice *pThis, DWORD* pOffset) { D3DDevice_GetPushBufferOffset(pOffset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Nop(D3DDevice *pThis) { D3DDevice_Nop(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetProjectionViewportMatrix(D3DDevice *pThis, D3DMATRIX* pProjectionViewport) { D3DDevice_GetProjectionViewportMatrix(pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetModelView(D3DDevice *pThis, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DDevice_SetModelView(pModelView, pInverseModelView, pComposite); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetModelView(D3DDevice *pThis, D3DMATRIX* pModelView) { return D3DDevice_GetModelView(pModelView); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexBlendModelView(D3DDevice *pThis, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DDevice_SetVertexBlendModelView(Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexBlendModelView(D3DDevice *pThis, UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport) { return D3DDevice_GetVertexBlendModelView(Count, pModelViews, pProjectionViewport); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderInput(D3DDevice *pThis, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInput(Handle, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderInputDirect(D3DDevice *pThis, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInputDirect(pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderInput(D3DDevice *pThis, DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs) { return D3DDevice_GetVertexShaderInput(pHandle, pStreamCount, pStreamInputs); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SwitchTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture *pTexture) { D3DDevice_SwitchTexture(D3DTEXTUREDIRECTENCODE[Stage], (pTexture)->Data, (pTexture)->Format); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Suspend(D3DDevice *pThis) { D3DDevice_Suspend(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Resume(D3DDevice *pThis, BOOL Reset) { D3DDevice_Resume(Reset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetScissors(D3DDevice *pThis, DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects) { D3DDevice_SetScissors(Count, Exclusive, pRects); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetScissors(D3DDevice *pThis, DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects) { D3DDevice_GetScissors(pCount, pExclusive, pRects); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTile(D3DDevice *pThis, DWORD Index, CONST D3DTILE* pTile) { D3DDevice_SetTile(Index, pTile); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTile(D3DDevice *pThis, DWORD Index, D3DTILE* pTile) { D3DDevice_GetTile(Index, pTile); return S_OK; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetTileCompressionTags(D3DDevice *pThis, DWORD ZStartTag, DWORD ZEndTag) { return D3DDevice_GetTileCompressionTags(ZStartTag, ZEndTag); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetTileCompressionTagBits(D3DDevice *pThis, DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count) { D3DDevice_SetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DINLINE void    WINAPI IDirect3DDevice8_GetTileCompressionTagBits(D3DDevice *pThis, DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_GetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginPush(D3DDevice *pThis, DWORD Count, DWORD **ppPush) { D3DDevice_BeginPush(Count, ppPush); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndPush(D3DDevice *pThis, DWORD *pPush) { D3DDevice_EndPush(pPush); return S_OK; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_Swap(DWORD Flags) { return D3DDevice_Swap(Flags); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetBackBufferScale(float x, float y) { D3DDevice_SetBackBufferScale(x, y); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackBufferScale(float *pX, float *pY) { D3DDevice_GetBackBufferScale(pX, pY); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetScreenSpaceOffset(float x, float y) { D3DDevice_SetScreenSpaceOffset(x, y); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetScreenSpaceOffset(float *pX, float *pY) { D3DDevice_GetScreenSpaceOffset(pX, pY); return S_OK; }
D3DINLINE void    WINAPI IDirect3DDevice8_SetOverscanColor(D3DCOLOR Color) { D3DDevice_SetOverscanColor(Color); }
D3DINLINE D3DCOLOR WINAPI IDirect3DDevice8_GetOverscanColor() { return D3DDevice_GetOverscanColor(); }                                                                                                                                 
#ifdef _DEBUG
D3DINLINE DWORD   WINAPI IDirect3DDevice8_SetDebugMarker(DWORD Marker) { return D3DDevice_SetDebugMarker(Marker); }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetDebugMarker() { return D3DDevice_GetDebugMarker(); }
#else
D3DINLINE DWORD   WINAPI IDirect3DDevice8_SetDebugMarker(DWORD Marker) { return 0; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetDebugMarker() { return 0; }
#endif

#ifdef __cplusplus

D3DMINLINE ULONG   WINAPI D3DDevice::AddRef() { return D3DDevice_AddRef(); }
D3DMINLINE ULONG   WINAPI D3DDevice::Release() { return D3DDevice_Release(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDirect3D(Direct3D **ppD3D8) { D3DDevice_GetDirect3D(ppD3D8); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDeviceCaps(D3DCAPS8 *pCaps) { D3DDevice_GetDeviceCaps(pCaps); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDisplayMode(D3DDISPLAYMODE *pMode) { D3DDevice_GetDisplayMode(pMode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters) { D3DDevice_GetCreationParameters(pParameters); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Reset(D3DPRESENT_PARAMETERS *pPresentationParameters) { return D3DDevice_Reset(pPresentationParameters); }
D3DMINLINE HRESULT WINAPI D3DDevice::Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2) { D3DDevice_Swap(0); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer) { D3DDevice_GetBackBuffer(BackBuffer, Type, ppBackBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRasterStatus(D3DRASTER_STATUS *pRasterStatus) { D3DDevice_GetRasterStatus(pRasterStatus); return S_OK; }
D3DMINLINE void    WINAPI D3DDevice::SetFlickerFilter(DWORD Filter) { D3DDevice_SetFlickerFilter(Filter); }
D3DMINLINE void    WINAPI D3DDevice::SetSoftDisplayFilter(BOOL Enable) { D3DDevice_SetSoftDisplayFilter(Enable); }
D3DMINLINE void    WINAPI D3DDevice::SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp) { D3DDevice_SetGammaRamp(Flags, pRamp); }
D3DMINLINE void    WINAPI D3DDevice::GetGammaRamp(D3DGAMMARAMP *pRamp) { D3DDevice_GetGammaRamp(pRamp); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture) { return D3DDevice_CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture) { return D3DDevice_CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture) { return D3DDevice_CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer) { return D3DDevice_CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer) { return D3DDevice_CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette) { return D3DDevice_CreatePalette(Size, ppPalette); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface) { return D3DDevice_CreateRenderTarget(Width, Height, Format, MultiSample, Lockable, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface) { return D3DDevice_CreateDepthStencilSurface(Width, Height, Format, MultiSample, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface) { return D3DDevice_CreateImageSurface(Width, Height, Format, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray) { D3DDevice_CopyRects(pSourceSurface, pSourceRectsArray, cRects, pDestinationSurface, pDestPointsArray); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_SetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_GetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil) { D3DDevice_SetRenderTarget(pRenderTarget, pNewZStencil); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRenderTarget(D3DSurface **ppRenderTarget) { D3DDevice_GetRenderTarget(ppRenderTarget); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDepthStencilSurface(D3DSurface **ppZStencilSurface) { return D3DDevice_GetDepthStencilSurface(ppZStencilSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginScene() { D3DDevice_BeginScene(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndScene() { D3DDevice_EndScene(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) { D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDIRTY_TRANSFORM(State); D3DDevice_SetTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix) { D3DDevice_GetTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDevice_MultiplyTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetViewport(CONST D3DVIEWPORT8 *pViewport) { D3DDIRTY_VIEWPORT(); D3DDevice_SetViewport(pViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetViewport(D3DVIEWPORT8 *pViewport) { D3DDevice_GetViewport(pViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetMaterial(CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_MATERIAL(); D3DDevice_SetMaterial(pMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetMaterial(D3DMATERIAL8 *pMaterial) { D3DDevice_GetMaterial(pMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetBackMaterial(CONST D3DMATERIAL8 *pBackMaterial) { D3DDIRTY_BACKMATERIAL(); D3DDevice_SetBackMaterial(pBackMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackMaterial(D3DMATERIAL8 *pBackMaterial) { D3DDevice_GetBackMaterial(pBackMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetLight(DWORD Index, CONST D3DLIGHT8 *pLight) { return D3DDevice_SetLight(Index, pLight); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetLight(DWORD Index, D3DLIGHT8 *pLight) { D3DDevice_GetLight(Index, pLight); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LightEnable(DWORD Index, BOOL Enable) { return D3DDevice_LightEnable(Index, Enable); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetLightEnable(DWORD Index, BOOL *pEnable) { D3DDevice_GetLightEnable(Index, pEnable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderState(D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderState(State, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderStateNotInline(State, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue) { D3DDevice_GetRenderState(State, pValue); return S_OK; }
#if D3DCOMPILE_BEGINSTATEBLOCK
D3DMINLINE HRESULT WINAPI D3DDevice::BeginStateBlock() { D3DDevice_BeginStateBlock(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndStateBlock(DWORD *pToken) { return D3DDevice_EndStateBlock(pToken); }
#endif
D3DMINLINE HRESULT WINAPI D3DDevice::ApplyStateBlock(DWORD Token) { D3DDevice_ApplyStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CaptureStateBlock(DWORD Token) { D3DDevice_CaptureStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DeleteStateBlock(DWORD Token) { D3DDevice_DeleteStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken) { return D3DDevice_CreateStateBlock(Type, pToken); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTexture(DWORD Stage, D3DBaseTexture **ppTexture) { D3DDevice_GetTexture(Stage, ppTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTexture(DWORD Stage, D3DBaseTexture *pTexture) { D3DDIRTY_TEXTURE(Stage); D3DDevice_SetTexture(Stage, pTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPalette(DWORD Stage, D3DPalette **ppPalette) { D3DDevice_GetPalette(Stage, ppPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPalette(DWORD Stage, D3DPalette *pPalette) { D3DDevice_SetPalette(Stage, pPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue) { D3DDevice_GetTextureStageState(Stage, Type, pValue); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageState(Stage, Type, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount)); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount) { D3DDevice_DrawIndexedVertices(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), D3D__IndexData + StartIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, VertexCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedVertices(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST WORD* pIndexData) { D3DDevice_DrawIndexedVertices(PrimitiveType, VertexCount, pIndexData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, VertexCount, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, VertexCount, pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData) { D3DDevice_PrimeVertexCache(VertexCount, pIndexData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage) { return D3DDevice_CreateVertexShader(pDeclaration, pFunction, pHandle, Usage); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShader(DWORD Handle) { D3DDIRTY_VERTEXSHADER(); D3DDevice_SetVertexShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShader(DWORD *pHandle) { D3DDevice_GetVertexShader(pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode) { D3DDevice_SetShaderConstantMode(Mode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode) { D3DDevice_GetShaderConstantMode(pMode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LoadVertexShader(DWORD Handle, DWORD Address) { D3DDevice_LoadVertexShader(Handle, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address) { D3DDevice_LoadVertexShaderProgram(pFunction, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SelectVertexShader(DWORD Handle, DWORD Address) { D3DDevice_SelectVertexShader(Handle, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address) { D3DDevice_SelectVertexShaderDirect(pVAF, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::RunVertexStateShader(DWORD Address, CONST float *pData) { D3DDevice_RunVertexStateShader(Address, pData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderSize(DWORD Handle, UINT *pSize) { D3DDevice_GetVertexShaderSize(Handle, pSize); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderType(DWORD Handle, DWORD *pType) { D3DDevice_GetVertexShaderType(Handle, pType); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderDeclaration(Handle, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderFunction(DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderFunction(Handle, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DDevice::DeleteVertexShader(DWORD Handle) { D3DDevice_DeleteVertexShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_VERTEXSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride) { D3DDIRTY_STREAM(StreamNumber); D3DDevice_SetStreamSource(StreamNumber, pStreamData, Stride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride) { D3DDevice_GetStreamSource(StreamNumber, ppStreamData, pStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetIndices(D3DIndexBuffer* pIndexData, UINT BaseVertexIndex) { D3DDIRTY_INDICES(); D3DDevice_SetIndices(pIndexData, BaseVertexIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetIndices(D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex) { D3DDevice_GetIndices(ppIndexData, pBaseVertexIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle) { D3DDevice_CreatePixelShader(pPSDef, pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShader(DWORD Handle) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShaderProgram(pPSDef); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShader(DWORD *pHandle) { D3DDevice_GetPixelShader(pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DeletePixelShader(DWORD Handle) { D3DDevice_DeletePixelShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_PIXELSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData) { D3DDevice_GetPixelShaderFunction(Handle, pData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo) { return D3DDevice_DrawRectPatch(Handle, pNumSegs, pRectPatchInfo); }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo) { return D3DDevice_DrawTriPatch(Handle, pNumSegs, pTriPatchInfo); }
D3DMINLINE HRESULT WINAPI D3DDevice::DeletePatch(UINT Handle) { D3DDevice_DeletePatch(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey) { D3DDevice_UpdateOverlay(pSurface, SrcRect, DstRect, EnableColorKey, ColorKey); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EnableOverlay(BOOL Enable) { D3DDevice_EnableOverlay(Enable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginVisibilityTest() { D3DDevice_BeginVisibilityTest(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndVisibilityTest(DWORD Index) { return D3DDevice_EndVisibilityTest(Index); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVisibilityTestResult(DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp) { return D3DDevice_GetVisibilityTestResult(Index, pResult, pTimeStamp); }
D3DMINLINE BOOL    WINAPI D3DDevice::IsBusy() { return D3DDevice_IsBusy(); }
D3DMINLINE void    WINAPI D3DDevice::BlockUntilIdle() { D3DDevice_BlockUntilIdle(); }
D3DMINLINE void    WINAPI D3DDevice::KickPushBuffer() { D3DDevice_KickPushBuffer(); }
D3DMINLINE void    WINAPI D3DDevice::SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback) { D3DDevice_SetVerticalBlankCallback(pCallback); }
D3DMINLINE void    WINAPI D3DDevice::SetSwapCallback(D3DSWAPCALLBACK pCallback) { D3DDevice_SetSwapCallback(pCallback); }
D3DMINLINE void    WINAPI D3DDevice::BlockUntilVerticalBlank() { D3DDevice_BlockUntilVerticalBlank(); }
D3DMINLINE DWORD   WINAPI D3DDevice::InsertFence() { return D3DDevice_InsertFence(); }
D3DMINLINE BOOL    WINAPI D3DDevice::IsFencePending(DWORD Fence) { return D3DDevice_IsFencePending(Fence); }
D3DMINLINE void    WINAPI D3DDevice::BlockOnFence(DWORD Fence) { D3DDevice_BlockOnFence(Fence); }
D3DMINLINE void    WINAPI D3DDevice::InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context) { D3DDevice_InsertCallback(Type, pCallback, Context); }
D3DMINLINE void    WINAPI D3DDevice::FlushVertexCache() { D3DDevice_FlushVertexCache(); }
D3DMINLINE HRESULT WINAPI D3DDevice::PersistDisplay() { return D3DDevice_PersistDisplay(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPersistedSurface(IDirect3DSurface8 **ppSurface) { D3DDevice_GetPersistedSurface(ppSurface); return S_OK; }
D3DMINLINE BOOL    WINAPI D3DDevice::GetOverlayUpdateStatus() { return D3DDevice_GetOverlayUpdateStatus(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus) { D3DDevice_GetDisplayFieldStatus(pFieldStatus); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData2f(INT Register, float a, float b) { D3DDevice_SetVertexData2f(Register, a, b); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4f(INT Register, float a, float b, float c, float d) { D3DDevice_SetVertexData4f(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData2s(INT Register, SHORT a, SHORT b) { D3DDevice_SetVertexData2s(Register, a, b); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d) { D3DDevice_SetVertexData4s(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d) { D3DDevice_SetVertexData4ub(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexDataColor(INT Register, D3DCOLOR Color) { D3DDevice_SetVertexDataColor(Register, Color); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Begin(D3DPRIMITIVETYPE PrimitiveType) { D3DDevice_Begin(PrimitiveType); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::End() { D3DDevice_End(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateFixup(UINT Size, D3DFixup **ppFixup) { return D3DDevice_CreateFixup(Size, ppFixup); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer) { return D3DDevice_CreatePushBuffer(Size, RunUsingCpuCopy, ppPushBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginPushBuffer(D3DPushBuffer* pPushBuffer) { D3DDevice_BeginPushBuffer(pPushBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndPushBuffer() { return D3DDevice_EndPushBuffer(); }
D3DMINLINE HRESULT WINAPI D3DDevice::RunPushBuffer(D3DPushBuffer* pPushBuffer, D3DFixup *pFixup) { D3DDevice_RunPushBuffer(pPushBuffer, pFixup); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPushBufferOffset(DWORD* pOffset) { D3DDevice_GetPushBufferOffset(pOffset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Nop() { D3DDevice_Nop(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport) { D3DDevice_GetProjectionViewportMatrix(pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DDevice_SetModelView(pModelView, pInverseModelView, pComposite); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetModelView(D3DMATRIX* pModelView) { return D3DDevice_GetModelView(pModelView); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DDevice_SetVertexBlendModelView(Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport) { return D3DDevice_GetVertexBlendModelView(Count, pModelViews, pProjectionViewport); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInput(Handle, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInputDirect(pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs) { return D3DDevice_GetVertexShaderInput(pHandle, pStreamCount, pStreamInputs); }
D3DMINLINE HRESULT WINAPI D3DDevice::SwitchTexture(DWORD Stage, D3DBaseTexture *pTexture) { D3DDevice_SwitchTexture(D3DTEXTUREDIRECTENCODE[Stage], (pTexture)->Data, (pTexture)->Format); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Suspend() { D3DDevice_Suspend(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Resume(BOOL Reset) { D3DDevice_Resume(Reset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects) { D3DDevice_SetScissors(Count, Exclusive, pRects); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects) { D3DDevice_GetScissors(pCount, pExclusive, pRects); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTile(DWORD Index, CONST D3DTILE* pTile) { D3DDevice_SetTile(Index, pTile); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTile(DWORD Index, D3DTILE* pTile) { D3DDevice_GetTile(Index, pTile); return S_OK; }
D3DMINLINE DWORD   WINAPI D3DDevice::GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag) { return D3DDevice_GetTileCompressionTags(ZStartTag, ZEndTag); }
D3DMINLINE void    WINAPI D3DDevice::SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count) { D3DDevice_SetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DMINLINE void    WINAPI D3DDevice::GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_GetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginPush(DWORD Count, DWORD **ppPush) { D3DDevice_BeginPush(Count, ppPush); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndPush(DWORD *pPush) { D3DDevice_EndPush(pPush); return S_OK; }
D3DMINLINE DWORD   WINAPI D3DDevice::Swap(DWORD Flags) { return D3DDevice_Swap(Flags); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetBackBufferScale(float x, float y) { D3DDevice_SetBackBufferScale(x, y); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackBufferScale(float *pX, float *pY) { D3DDevice_GetBackBufferScale(pX, pY); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetScreenSpaceOffset(float x, float y) { D3DDevice_SetScreenSpaceOffset(x, y); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetScreenSpaceOffset(float *pX, float *pY) { D3DDevice_GetScreenSpaceOffset(pX, pY); return S_OK; }
D3DMINLINE void    WINAPI D3DDevice::SetOverscanColor(D3DCOLOR Color) { D3DDevice_SetOverscanColor(Color); }
D3DMINLINE D3DCOLOR WINAPI D3DDevice::GetOverscanColor() { return D3DDevice_GetOverscanColor(); }
#ifdef _DEBUG
D3DMINLINE DWORD   WINAPI D3DDevice::SetDebugMarker(DWORD Marker) { return D3DDevice_SetDebugMarker(Marker); }
D3DMINLINE DWORD   WINAPI D3DDevice::GetDebugMarker() { return D3DDevice_GetDebugMarker(); }
#else
D3DMINLINE DWORD   WINAPI D3DDevice::SetDebugMarker(DWORD Marker) { return 0; }
D3DMINLINE DWORD   WINAPI D3DDevice::GetDebugMarker() { return 0; }
#endif

#endif __cplusplus

/* D3DResource */

ULONG   WINAPI D3DResource_AddRef(D3DResource *pThis);
ULONG   WINAPI D3DResource_Release(D3DResource *pThis);
void    WINAPI D3DResource_GetDevice(D3DResource *pThis, D3DDevice **ppDevice);
HRESULT WINAPI D3DResource_SetPrivateData(D3DResource *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags);
HRESULT WINAPI D3DResource_GetPrivateData(D3DResource *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData);
void    WINAPI D3DResource_FreePrivateData(D3DResource *pThis, REFGUID refguid);
D3DRESOURCETYPE WINAPI D3DResource_GetType(D3DResource *pThis);
BOOL    WINAPI D3DResource_IsBusy(D3DResource *pThis);
void    WINAPI D3DResource_BlockUntilNotBusy(D3DResource *pThis);
void    WINAPI D3DResource_Register(D3DResource *pThis, void *pBase);
D3DINLINE void WINAPI D3DResource_MoveResourceMemory(D3DResource *pThis, D3DMEMORY where) { }

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DResource8_AddRef(D3DResource *pThis) { return D3DResource_AddRef(pThis); }
D3DINLINE ULONG   WINAPI IDirect3DResource8_Release(D3DResource *pThis) { return D3DResource_Release(pThis); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_GetDevice(D3DResource *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice(pThis, ppDevice); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DResource8_SetPrivateData(D3DResource *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData(pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_GetPrivateData(D3DResource *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData(pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_FreePrivateData(D3DResource *pThis, REFGUID refguid) { D3DResource_FreePrivateData(pThis, refguid); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DResource8_GetType(D3DResource *pThis) { return D3DResource_GetType(pThis); }
D3DINLINE BOOL    WINAPI IDirect3DResource8_IsBusy(D3DResource *pThis) { return D3DResource_IsBusy(pThis); }
D3DINLINE void    WINAPI IDirect3DResource8_BlockUntilNotBusy(D3DResource *pThis) { D3DResource_BlockUntilNotBusy(pThis); }
D3DINLINE void    WINAPI IDirect3DResource8_MoveResourceMemory(D3DResource *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory(pThis, where); }
D3DINLINE void    WINAPI IDirect3DResource8_Register(D3DResource *pThis, void *pBase) { D3DResource_Register(pThis, pBase); }

#ifdef __cplusplus

D3DMINLINE ULONG WINAPI D3DResource::AddRef() { return D3DResource_AddRef(this); }
D3DMINLINE ULONG WINAPI D3DResource::Release() { return D3DResource_Release(this); }
D3DMINLINE HRESULT WINAPI D3DResource::GetDevice(D3DDevice **ppDevice) { D3DResource_GetDevice(this, ppDevice); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DResource::SetPrivateData(REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData(this, refguid, pData, SizeOfData, Flags); }
D3DMINLINE HRESULT WINAPI D3DResource::GetPrivateData(REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData(this, refguid, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DResource::FreePrivateData(REFGUID refguid) { D3DResource_FreePrivateData(this, refguid); return S_OK; }
D3DMINLINE D3DRESOURCETYPE WINAPI D3DResource::GetType() { return D3DResource_GetType(this); }
D3DMINLINE BOOL    WINAPI D3DResource::IsBusy() { return D3DResource_IsBusy(this); }
D3DMINLINE void    WINAPI D3DResource::BlockUntilNotBusy() { D3DResource_BlockUntilNotBusy(this); }
D3DMINLINE void    WINAPI D3DResource::MoveResourceMemory(D3DMEMORY where) { D3DResource_MoveResourceMemory(this, where); }
D3DMINLINE void    WINAPI D3DResource::Register(void *pBase) { D3DResource_Register(this, pBase); }

#endif __cplusplus

/* D3DBaseTexture */

D3DINLINE ULONG   WINAPI D3DBaseTexture_AddRef(D3DBaseTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DBaseTexture_Release(D3DBaseTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_GetDevice(D3DBaseTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DBaseTexture_GetType(D3DBaseTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DBaseTexture_IsBusy(D3DBaseTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_BlockUntilNotBusy(D3DBaseTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_MoveResourceMemory(D3DBaseTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DBaseTexture_Register(D3DBaseTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DBaseTexture_SetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DBaseTexture_GetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DBaseTexture_FreePrivateData(D3DBaseTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

DWORD WINAPI D3DBaseTexture_GetLevelCount(D3DBaseTexture *pThis);

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DBaseTexture8_AddRef(D3DBaseTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DBaseTexture8_Release(D3DBaseTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_GetDevice(D3DBaseTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DBaseTexture8_GetType(D3DBaseTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DBaseTexture8_IsBusy(D3DBaseTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_BlockUntilNotBusy(D3DBaseTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_MoveResourceMemory(D3DBaseTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_Register(D3DBaseTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_SetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_GetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_FreePrivateData(D3DBaseTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE DWORD WINAPI IDirect3DBaseTexture8_GetLevelCount(D3DBaseTexture *pThis) { return D3DBaseTexture_GetLevelCount(pThis); }

#ifdef __cplusplus

D3DMINLINE DWORD WINAPI D3DBaseTexture::GetLevelCount() { return D3DBaseTexture_GetLevelCount(this); }

#endif __cplusplus

/* D3DTexture */

D3DINLINE ULONG   WINAPI D3DTexture_AddRef(D3DTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DTexture_Release(D3DTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_GetDevice(D3DTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DTexture_GetType(D3DTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DTexture_IsBusy(D3DTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_BlockUntilNotBusy(D3DTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_MoveResourceMemory(D3DTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DTexture_Register(D3DTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DTexture_GetLevelCount(D3DTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DTexture_SetPrivateData(D3DTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DTexture_GetPrivateData(D3DTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DTexture_FreePrivateData(D3DTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DTexture_GetLevelDesc(D3DTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
HRESULT WINAPI D3DTexture_GetSurfaceLevel(D3DTexture *pThis, UINT Level, D3DSurface **ppSurfaceLevel);
void    WINAPI D3DTexture_LockRect(D3DTexture *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DTexture_UnlockRect(D3DTexture *pThis, UINT Level) { }

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DTexture8_AddRef(D3DTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DTexture8_Release(D3DTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetDevice(D3DTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DTexture8_GetType(D3DTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DTexture8_IsBusy(D3DTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DTexture8_BlockUntilNotBusy(D3DTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DTexture8_MoveResourceMemory(D3DTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DTexture8_Register(D3DTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DTexture8_GetLevelCount(D3DTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_SetPrivateData(D3DTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetPrivateData(D3DTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_FreePrivateData(D3DTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetLevelDesc(D3DTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc) { D3DTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetSurfaceLevel(D3DTexture *pThis, UINT Level, D3DSurface **ppSurfaceLevel) { return D3DTexture_GetSurfaceLevel(pThis, Level, ppSurfaceLevel); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_LockRect(D3DTexture *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DTexture_LockRect(pThis, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_UnlockRect(D3DTexture *pThis, UINT Level) { D3DTexture_UnlockRect(pThis, Level); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DTexture::GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc) { D3DTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DTexture::GetSurfaceLevel(UINT Level, D3DSurface **ppSurfaceLevel) { return D3DTexture_GetSurfaceLevel(this, Level, ppSurfaceLevel); }
D3DMINLINE HRESULT WINAPI D3DTexture::LockRect(UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DTexture_LockRect(this, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DTexture::UnlockRect(UINT Level) { D3DTexture_UnlockRect(this, Level); return S_OK; }

#endif __cplusplus

/* D3DVolumeTexture */

D3DINLINE ULONG   WINAPI D3DVolumeTexture_AddRef(D3DVolumeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVolumeTexture_Release(D3DVolumeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_GetDevice(D3DVolumeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVolumeTexture_GetType(D3DVolumeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVolumeTexture_IsBusy(D3DVolumeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_BlockUntilNotBusy(D3DVolumeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_MoveResourceMemory(D3DVolumeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVolumeTexture_Register(D3DVolumeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DVolumeTexture_GetLevelCount(D3DVolumeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DVolumeTexture_SetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVolumeTexture_GetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVolumeTexture_FreePrivateData(D3DVolumeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVolumeTexture_GetLevelDesc(D3DVolumeTexture *pThis, UINT Level, D3DVOLUME_DESC *pDesc);
HRESULT WINAPI D3DVolumeTexture_GetVolumeLevel(D3DVolumeTexture *pThis, UINT Level, D3DVolume **ppVolumeLevel);
void    WINAPI D3DVolumeTexture_LockBox(D3DVolumeTexture *pThis, UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
D3DINLINE void WINAPI D3DVolumeTexture_UnlockBox(D3DVolumeTexture *pThis, UINT Level) { }

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DVolumeTexture8_AddRef(D3DVolumeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVolumeTexture8_Release(D3DVolumeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetDevice(D3DVolumeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVolumeTexture8_GetType(D3DVolumeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVolumeTexture8_IsBusy(D3DVolumeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_BlockUntilNotBusy(D3DVolumeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_MoveResourceMemory(D3DVolumeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_Register(D3DVolumeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DVolumeTexture8_GetLevelCount(D3DVolumeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_SetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_FreePrivateData(D3DVolumeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetLevelDesc(D3DVolumeTexture *pThis, UINT Level, D3DVOLUME_DESC *pDesc) { D3DVolumeTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetVolumeLevel(D3DVolumeTexture *pThis, UINT Level, D3DVolume **ppVolumeLevel) { return D3DVolumeTexture_GetVolumeLevel(pThis, Level, ppVolumeLevel); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_LockBox(D3DVolumeTexture *pThis, UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolumeTexture_LockBox(pThis, Level, pLockedVolume, pBox, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_UnlockBox(D3DVolumeTexture *pThis, UINT Level) { D3DVolumeTexture_UnlockBox(pThis, Level); return S_OK; }


#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVolumeTexture::GetLevelDesc(UINT Level, D3DVOLUME_DESC *pDesc) { D3DVolumeTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::GetVolumeLevel(UINT Level, D3DVolume **ppVolumeLevel) { return D3DVolumeTexture_GetVolumeLevel(this, Level, ppVolumeLevel); }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::LockBox(UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolumeTexture_LockBox(this, Level, pLockedVolume, pBox, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::UnlockBox(UINT Level) { D3DVolumeTexture_UnlockBox(this, Level); return S_OK; }

#endif __cplusplus

/* D3DCubeTexture */

D3DINLINE ULONG   WINAPI D3DCubeTexture_AddRef(D3DCubeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DCubeTexture_Release(D3DCubeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_GetDevice(D3DCubeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DCubeTexture_GetType(D3DCubeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DCubeTexture_IsBusy(D3DCubeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_BlockUntilNotBusy(D3DCubeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_MoveResourceMemory(D3DCubeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DCubeTexture_Register(D3DCubeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DCubeTexture_GetLevelCount(D3DCubeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DCubeTexture_SetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DCubeTexture_GetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DCubeTexture_FreePrivateData(D3DCubeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DCubeTexture_GetLevelDesc(D3DCubeTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
HRESULT WINAPI D3DCubeTexture_GetCubeMapSurface(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface);
void    WINAPI D3DCubeTexture_LockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DCubeTexture_UnlockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level) { }

D3DINLINE ULONG   WINAPI IDirect3DCubeTexture8_AddRef(D3DCubeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DCubeTexture8_Release(D3DCubeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetDevice(D3DCubeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DCubeTexture8_GetType(D3DCubeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DCubeTexture8_IsBusy(D3DCubeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_BlockUntilNotBusy(D3DCubeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_MoveResourceMemory(D3DCubeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_Register(D3DCubeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DCubeTexture8_GetLevelCount(D3DCubeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_SetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_FreePrivateData(D3DCubeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetLevelDesc(D3DCubeTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc) { D3DCubeTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetCubeMapSurface(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface) { return D3DCubeTexture_GetCubeMapSurface(pThis, FaceType, Level, ppCubeMapSurface); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_LockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DCubeTexture_LockRect(pThis, FaceType, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_UnlockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level) { D3DCubeTexture_UnlockRect(pThis, FaceType, Level); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DCubeTexture::GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc) { D3DCubeTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface) { return D3DCubeTexture_GetCubeMapSurface(this, FaceType, Level, ppCubeMapSurface); }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DCubeTexture_LockRect(this, FaceType, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level) { D3DCubeTexture_UnlockRect(this, FaceType, Level); return S_OK; }

#endif __cplusplus

/* D3DVertexBuffer */

D3DINLINE ULONG   WINAPI D3DVertexBuffer_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVertexBuffer_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVertexBuffer_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVertexBuffer_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_BlockUntilNotBusy(D3DVertexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVertexBuffer_Register(D3DVertexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DVertexBuffer_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVertexBuffer_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVertexBuffer_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVertexBuffer_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
void    WINAPI D3DVertexBuffer_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc);
D3DINLINE void WINAPI D3DVertexBuffer_Unlock(D3DVertexBuffer *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DVertexBuffer8_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVertexBuffer8_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVertexBuffer8_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVertexBuffer8_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_BlockUntilNotBusy(D3DVertexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_Register(D3DVertexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DVertexBuffer_Lock(pThis, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_Unlock(D3DVertexBuffer *pThis) { D3DVertexBuffer_Unlock(pThis); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc) { D3DVertexBuffer_GetDesc(pThis, pDesc); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVertexBuffer::Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DVertexBuffer_Lock(this, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVertexBuffer::Unlock() { D3DVertexBuffer_Unlock(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVertexBuffer::GetDesc(D3DVERTEXBUFFER_DESC *pDesc) { D3DVertexBuffer_GetDesc(this, pDesc); return S_OK; }

#endif __cplusplus

/* D3DIndexBuffer */

D3DINLINE ULONG   WINAPI D3DIndexBuffer_AddRef(D3DIndexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DIndexBuffer_Release(D3DIndexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_GetDevice(D3DIndexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DIndexBuffer_GetType(D3DIndexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DIndexBuffer_IsBusy(D3DIndexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_BlockUntilNotBusy(D3DIndexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_MoveResourceMemory(D3DIndexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DIndexBuffer_Register(D3DIndexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DIndexBuffer_SetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DIndexBuffer_GetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DIndexBuffer_FreePrivateData(D3DIndexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

D3DINLINE void    WINAPI D3DIndexBuffer_Lock(D3DIndexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { *(ppbData) = (BYTE*) (pThis)->Data + (OffsetToLock); }
D3DINLINE void    WINAPI D3DIndexBuffer_Unlock(D3DIndexBuffer *pThis) { }
void    WINAPI D3DIndexBuffer_GetDesc(D3DIndexBuffer *pThis, D3DINDEXBUFFER_DESC *pDesc);

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DIndexBuffer8_AddRef(D3DIndexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DIndexBuffer8_Release(D3DIndexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetDevice(D3DIndexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DIndexBuffer8_GetType(D3DIndexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DIndexBuffer8_IsBusy(D3DIndexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_BlockUntilNotBusy(D3DIndexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_MoveResourceMemory(D3DIndexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_Register(D3DIndexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_SetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_FreePrivateData(D3DIndexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_Lock(D3DIndexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DIndexBuffer_Lock(pThis, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_Unlock(D3DIndexBuffer *pThis) { D3DIndexBuffer_Unlock(pThis); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetDesc(D3DIndexBuffer *pThis, D3DINDEXBUFFER_DESC *pDesc) { D3DIndexBuffer_GetDesc(pThis, pDesc); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DIndexBuffer::Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DIndexBuffer_Lock(this, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DIndexBuffer::Unlock() { D3DIndexBuffer_Unlock(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DIndexBuffer::GetDesc(D3DINDEXBUFFER_DESC *pDesc) { D3DIndexBuffer_GetDesc(this, pDesc); return S_OK; }

#endif __cplusplus

/* D3DPalette */

D3DINLINE ULONG   WINAPI D3DPalette_AddRef(D3DPalette *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DPalette_Release(D3DPalette *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_GetDevice(D3DPalette *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DPalette_GetType(D3DPalette *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DPalette_IsBusy(D3DPalette *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_BlockUntilNotBusy(D3DPalette *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_MoveResourceMemory(D3DPalette *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DPalette_Register(D3DPalette *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DPalette_SetPrivateData(D3DPalette *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DPalette_GetPrivateData(D3DPalette *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DPalette_FreePrivateData(D3DPalette *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DPalette_Lock(D3DPalette *pThis, D3DCOLOR **ppColor, DWORD Flags);
D3DPALETTESIZE WINAPI D3DPalette_GetSize(D3DPalette *pThis);
D3DINLINE void WINAPI D3DPalette_Unlock(D3DPalette *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DPalette8_AddRef(D3DPalette *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DPalette8_Release(D3DPalette *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_GetDevice(D3DPalette *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DPalette8_GetType(D3DPalette *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DPalette8_IsBusy(D3DPalette *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPalette8_BlockUntilNotBusy(D3DPalette *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPalette8_MoveResourceMemory(D3DPalette *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DPalette8_Register(D3DPalette *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_SetPrivateData(D3DPalette *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_GetPrivateData(D3DPalette *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_FreePrivateData(D3DPalette *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DPalette8_Lock(D3DPalette *pThis, D3DCOLOR **ppColor, DWORD Flags) { D3DPalette_Lock(pThis, ppColor, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_Unlock(D3DPalette *pThis) { D3DPalette_Unlock(pThis); return S_OK; }
D3DINLINE D3DPALETTESIZE WINAPI IDirect3DPalette8_GetSize(D3DPalette *pThis) { return D3DPalette_GetSize(pThis); }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DPalette::Lock(D3DCOLOR **ppColors, DWORD Flags) { D3DPalette_Lock(this, ppColors, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPalette::Unlock() { D3DPalette_Unlock(this); return S_OK; }
D3DMINLINE D3DPALETTESIZE WINAPI D3DPalette::GetSize() { return D3DPalette_GetSize(this); }

#endif __cplusplus

/* D3DPushBuffer */

D3DINLINE ULONG   WINAPI D3DPushBuffer_AddRef(D3DPushBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DPushBuffer_Release(D3DPushBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_GetDevice(D3DPushBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DPushBuffer_GetType(D3DPushBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DPushBuffer_IsBusy(D3DPushBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_BlockUntilNotBusy(D3DPushBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_MoveResourceMemory(D3DPushBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DPushBuffer_Register(D3DPushBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DPushBuffer_SetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DPushBuffer_GetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DPushBuffer_FreePrivateData(D3DPushBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DPushBuffer_Verify(D3DPushBuffer* pPushBuffer, BOOL StampResources);
void    WINAPI D3DPushBuffer_BeginFixup(D3DPushBuffer* pPushBuffer, D3DFixup* pFixup, BOOL NoWait);
HRESULT WINAPI D3DPushBuffer_EndFixup(D3DPushBuffer* pPushBuffer);
void    WINAPI D3DPushBuffer_RunPushBuffer(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup);
void    WINAPI D3DPushBuffer_SetModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
void    WINAPI D3DPushBuffer_SetVertexBlendModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
void    WINAPI D3DPushBuffer_SetVertexShaderInput(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
void    WINAPI D3DPushBuffer_SetVertexShaderInputDirect(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
void    WINAPI D3DPushBuffer_SetRenderTarget(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer);
void    WINAPI D3DPushBuffer_SetTexture(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture);
void    WINAPI D3DPushBuffer_SetPalette(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage,D3DPalette *pPalette);
HRESULT WINAPI D3DPushBuffer_EndVisibilityTest(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Index);
void    WINAPI D3DPushBuffer_SetVertexShaderConstant(D3DPushBuffer* pPushBuffer, DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount);
void    WINAPI D3DPushBuffer_Jump(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT DestinationOffset);

D3DINLINE ULONG   WINAPI IDirect3DPushBuffer8_AddRef(D3DPushBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DPushBuffer8_Release(D3DPushBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetDevice(D3DPushBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DPushBuffer8_GetType(D3DPushBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DPushBuffer8_IsBusy(D3DPushBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_BlockUntilNotBusy(D3DPushBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_MoveResourceMemory(D3DPushBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_Register(D3DPushBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_FreePrivateData(D3DPushBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_Verify(D3DPushBuffer* pPushBuffer, BOOL StampResources) { D3DPushBuffer_Verify(pPushBuffer, StampResources); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_BeginFixup(D3DPushBuffer* pPushBuffer, D3DFixup* pFixup, BOOL NoWait) { D3DPushBuffer_BeginFixup(pPushBuffer, pFixup, NoWait); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_EndFixup(D3DPushBuffer* pPushBuffer) { return D3DPushBuffer_EndFixup(pPushBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_RunPushBuffer(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup) { D3DPushBuffer_RunPushBuffer(pPushBuffer, Offset, pDestinationPushBuffer, pDestinationFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DPushBuffer_SetModelView(pPushBuffer, Offset, pModelView, pInverseModelView, pComposite); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexBlendModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DPushBuffer_SetVertexBlendModelView(pPushBuffer, Offset, Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderInput(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInput(pPushBuffer, Offset, Handle, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderInputDirect(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInputDirect(pPushBuffer, Offset, pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetRenderTarget(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer) { D3DPushBuffer_SetRenderTarget(pPushBuffer, Offset, pRenderTarget, pZBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetTexture(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture) { D3DPushBuffer_SetTexture(pPushBuffer, Offset, Stage, pTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetPalette(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage,D3DPalette *pPalette) { D3DPushBuffer_SetPalette(pPushBuffer, Offset, Stage, pPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_EndVisibilityTest(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Index) { return D3DPushBuffer_EndVisibilityTest(pPushBuffer, Offset, Index); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderConstant(D3DPushBuffer* pPushBuffer, DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount) { D3DPushBuffer_SetVertexShaderConstant(pPushBuffer, Offset, Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_Jump(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT DestinationOffset) { D3DPushBuffer_Jump(pPushBuffer, Offset, DestinationOffset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetSize(D3DPushBuffer* pPushBuffer, DWORD* pSize) { *pSize = pPushBuffer->Size; return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DPushBuffer::Verify(BOOL StampResources) { D3DPushBuffer_Verify(this, StampResources); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::BeginFixup(D3DFixup* pFixup, BOOL NoWait) { D3DPushBuffer_BeginFixup(this, pFixup, NoWait); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::EndFixup() { return D3DPushBuffer_EndFixup(this); }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::RunPushBuffer(DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup) { D3DPushBuffer_RunPushBuffer(this, Offset, pDestinationPushBuffer, pDestinationFixup); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetModelView(DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DPushBuffer_SetModelView(this, Offset, pModelView, pInverseModelView, pComposite); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexBlendModelView(DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DPushBuffer_SetVertexBlendModelView(this, Offset, Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderInput(DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInput(this, Offset, Handle, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderInputDirect(DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInputDirect(this, Offset, pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetRenderTarget(DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer) { D3DPushBuffer_SetRenderTarget(this, Offset, pRenderTarget, pZBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetTexture(DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture) { D3DPushBuffer_SetTexture(this, Offset, Stage, pTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetPalette(DWORD Offset, DWORD Stage,D3DPalette *pPalette) { D3DPushBuffer_SetPalette(this, Offset, Stage, pPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::EndVisibilityTest(DWORD Offset, DWORD Index) { return D3DPushBuffer_EndVisibilityTest(this, Offset, Index); }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderConstant(DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount) { D3DPushBuffer_SetVertexShaderConstant(this, Offset, Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::Jump(DWORD Offset, UINT DestinationOffset) { D3DPushBuffer_Jump(this, Offset, DestinationOffset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::GetSize(DWORD* pSize) { *pSize = Size; return S_OK; }

#endif __cplusplus

/* D3DFixup */

D3DINLINE ULONG   WINAPI D3DFixup_AddRef(D3DFixup *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DFixup_Release(D3DFixup *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_GetDevice(D3DFixup *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DFixup_GetType(D3DFixup *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DFixup_IsBusy(D3DFixup *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_BlockUntilNotBusy(D3DFixup *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_MoveResourceMemory(D3DFixup *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DFixup_Register(D3DFixup *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DFixup_SetPrivateData(D3DFixup *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DFixup_GetPrivateData(D3DFixup *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DFixup_FreePrivateData(D3DFixup *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DFixup_Reset(D3DFixup* pFixup);
void    WINAPI D3DFixup_GetSize(D3DFixup* pFixup, DWORD* pSize);
void    WINAPI D3DFixup_GetSpace(D3DFixup* pFixup, DWORD* pSpace);

D3DINLINE ULONG   WINAPI IDirect3DFixup8_AddRef(D3DFixup *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DFixup8_Release(D3DFixup *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetDevice(D3DFixup *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DFixup8_GetType(D3DFixup *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DFixup8_IsBusy(D3DFixup *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DFixup8_BlockUntilNotBusy(D3DFixup *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DFixup8_MoveResourceMemory(D3DFixup *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DFixup8_Register(D3DFixup *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_SetPrivateData(D3DFixup *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetPrivateData(D3DFixup *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_FreePrivateData(D3DFixup *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DFixup8_Reset(D3DFixup* pFixup) { D3DFixup_Reset(pFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetSize(D3DFixup* pFixup, DWORD* pSize) { D3DFixup_GetSize(pFixup, pSize); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetSpace(D3DFixup* pFixup, DWORD* pSpace) { D3DFixup_GetSpace(pFixup, pSpace); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DFixup::Reset() { D3DFixup_Reset(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DFixup::GetSize(DWORD* pSize) { D3DFixup_GetSize(this, pSize); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DFixup::GetSpace(DWORD* pSpace) { D3DFixup_GetSpace(this, pSpace); return S_OK; }

#endif __cplusplus

/* D3DSurface */

D3DINLINE ULONG   WINAPI D3DSurface_AddRef(D3DSurface *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DSurface_Release(D3DSurface *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_GetDevice(D3DSurface *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DSurface_GetType(D3DSurface *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DSurface_IsBusy(D3DSurface *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_BlockUntilNotBusy(D3DSurface *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_MoveResourceMemory(D3DSurface *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DSurface_Register(D3DSurface *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DSurface_SetPrivateData(D3DSurface *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DSurface_GetPrivateData(D3DSurface *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DSurface_FreePrivateData(D3DSurface *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

HRESULT WINAPI D3DSurface_GetContainer(D3DSurface *pThis, D3DBaseTexture **ppBaseTexture);
void    WINAPI D3DSurface_GetDesc(D3DSurface *pThis, D3DSURFACE_DESC *pDesc);
void    WINAPI D3DSurface_LockRect(D3DSurface *pThis, D3DLOCKED_RECT *pLockedRect,CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DSurface_UnlockRect(D3DSurface *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DSurface8_AddRef(D3DSurface *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DSurface8_Release(D3DSurface *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetDevice(D3DSurface *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DSurface8_GetType(D3DSurface *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DSurface8_IsBusy(D3DSurface *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DSurface8_BlockUntilNotBusy(D3DSurface *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DSurface8_MoveResourceMemory(D3DSurface *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DSurface8_Register(D3DSurface *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_SetPrivateData(D3DSurface *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetPrivateData(D3DSurface *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_FreePrivateData(D3DSurface *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetContainer(D3DSurface *pThis, D3DBaseTexture **ppBaseTexture) { return D3DSurface_GetContainer(pThis, ppBaseTexture); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetDesc(D3DSurface *pThis, D3DSURFACE_DESC *pDesc) { D3DSurface_GetDesc(pThis, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_LockRect(D3DSurface *pThis, D3DLOCKED_RECT *pLockedRect,CONST RECT *pRect, DWORD Flags) { D3DSurface_LockRect(pThis, pLockedRect,pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_UnlockRect(D3DSurface *pThis) { D3DSurface_UnlockRect(pThis); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DSurface::GetContainer(D3DBaseTexture **ppBaseTexture) { return D3DSurface_GetContainer(this, ppBaseTexture); }
D3DMINLINE HRESULT WINAPI D3DSurface::GetDesc(D3DSURFACE_DESC *pDesc) { D3DSurface_GetDesc(this, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DSurface::LockRect(D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DSurface_LockRect(this, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DSurface::UnlockRect() { D3DSurface_UnlockRect(this); return S_OK; }

#endif __cplusplus

/* D3DVolume */

D3DINLINE ULONG   WINAPI D3DVolume_AddRef(D3DVolume *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVolume_Release(D3DVolume *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_GetDevice(D3DVolume *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVolume_GetType(D3DVolume *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVolume_IsBusy(D3DVolume *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_BlockUntilNotBusy(D3DVolume *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_MoveResourceMemory(D3DVolume *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVolume_Register(D3DVolume *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DVolume_SetPrivateData(D3DVolume *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVolume_GetPrivateData(D3DVolume *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVolume_FreePrivateData(D3DVolume *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVolume_GetContainer(D3DVolume *pThis, D3DBaseTexture **ppBaseTexture);
void    WINAPI D3DVolume_GetDesc(D3DVolume *pThis, D3DVOLUME_DESC *pDesc);
void    WINAPI D3DVolume_LockBox(D3DVolume *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
D3DINLINE void WINAPI D3DVolume_UnlockBox(D3DVolume *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DVolume8_AddRef(D3DVolume *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVolume8_Release(D3DVolume *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetDevice(D3DVolume *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVolume8_GetType(D3DVolume *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVolume8_IsBusy(D3DVolume *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolume8_BlockUntilNotBusy(D3DVolume *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolume8_MoveResourceMemory(D3DVolume *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVolume8_Register(D3DVolume *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_SetPrivateData(D3DVolume *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetPrivateData(D3DVolume *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_FreePrivateData(D3DVolume *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetContainer(D3DVolume *pThis, D3DBaseTexture **ppBaseTexture) { D3DVolume_GetContainer(pThis, ppBaseTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetDesc(D3DVolume *pThis, D3DVOLUME_DESC *pDesc) { D3DVolume_GetDesc(pThis, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_LockBox(D3DVolume *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolume_LockBox(pThis, pLockedVolume, pBox, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_UnlockBox(D3DVolume *pThis) { D3DVolume_UnlockBox(pThis); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVolume::GetContainer(D3DBaseTexture **ppBaseTexture) { D3DVolume_GetContainer(this, ppBaseTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::GetDesc(D3DVOLUME_DESC *pDesc) { D3DVolume_GetDesc(this, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::LockBox(D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolume_LockBox(this, pLockedVolume, pBox, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::UnlockBox() { D3DVolume_UnlockBox(this); return S_OK; }

#endif __cplusplus

#ifdef __cplusplus
};
#endif

#pragma warning( pop )

#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3DX8Effect.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8effect.h
//  Content:    D3DX effect types and functions
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8EFFECT_H__
#define __D3DX8EFFECT_H__


typedef enum _D3DXPARAMETERTYPE
{
    D3DXPT_DWORD        = 0,
    D3DXPT_FLOAT        = 1,
    D3DXPT_VECTOR       = 2,
    D3DXPT_MATRIX       = 3,
    D3DXPT_TEXTURE      = 4,
    D3DXPT_VERTEXSHADER = 5,
    D3DXPT_PIXELSHADER  = 6,
    D3DXPT_CONSTANT     = 7,
    D3DXPT_FORCE_DWORD  = 0x7fffffff /* force 32-bit size enum */

} D3DXPARAMETERTYPE;


typedef struct _D3DXEFFECT_DESC
{
    UINT Parameters;
    UINT Techniques;
    DWORD Usage;

} D3DXEFFECT_DESC;


typedef struct _D3DXPARAMETER_DESC
{
    DWORD Name;
    D3DXPARAMETERTYPE Type;

} D3DXPARAMETER_DESC;


typedef struct _D3DXTECHNIQUE_DESC
{
    DWORD Name;
    UINT Passes;

} D3DXTECHNIQUE_DESC;


typedef struct _D3DXPASS_DESC
{
    DWORD Name;

} D3DXPASS_DESC;


typedef struct ID3DXEffect *LPD3DXEFFECT;
typedef struct ID3DXTechnique *LPD3DXTECHNIQUE;




//////////////////////////////////////////////////////////////////////////////
// ID3DXTechnique ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// {A00F378D-AF79-4917-907E-4D635EE63844}
DEFINE_GUID( IID_ID3DXTechnique,
0xa00f378d, 0xaf79, 0x4917, 0x90, 0x7e, 0x4d, 0x63, 0x5e, 0xe6, 0x38, 0x44);


DECLARE_INTERFACE_(ID3DXTechnique, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXTechnique
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXTECHNIQUE_DESC* pDesc) PURE;
    STDMETHOD(GetPassDesc)(THIS_ UINT Index, D3DXPASS_DESC* pDesc) PURE;

    STDMETHOD_(BOOL, IsParameterUsed)(THIS_ DWORD dwName) PURE;

    STDMETHOD(Validate)(THIS) PURE;
    STDMETHOD(Begin)(THIS_ UINT *pPasses) PURE;
    STDMETHOD(Pass)(THIS_ UINT Index) PURE;
    STDMETHOD(End)(THIS) PURE;
};


//////////////////////////////////////////////////////////////////////////////
// ID3DXEffect ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


// {281BBDD4-AEDF-4907-8650-E79CDFD45165}
DEFINE_GUID( IID_ID3DXEffect,
0x281bbdd4, 0xaedf, 0x4907, 0x86, 0x50, 0xe7, 0x9c, 0xdf, 0xd4, 0x51, 0x65);


DECLARE_INTERFACE_(ID3DXEffect, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXEffect
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXEFFECT_DESC* pDesc) PURE;

    STDMETHOD(GetParameterDesc)(THIS_ UINT Index, D3DXPARAMETER_DESC* pDesc) PURE;
    STDMETHOD(GetTechniqueDesc)(THIS_ UINT Index, D3DXTECHNIQUE_DESC* pDesc) PURE;

    STDMETHOD(SetDword)(THIS_ DWORD Name, DWORD dw) PURE;
    STDMETHOD(GetDword)(THIS_ DWORD Name, DWORD* pdw) PURE;
    STDMETHOD(SetFloat)(THIS_ DWORD Name, FLOAT f) PURE;
    STDMETHOD(GetFloat)(THIS_ DWORD Name, FLOAT* pf) PURE;
    STDMETHOD(SetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector) PURE;
    STDMETHOD(GetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector) PURE;
    STDMETHOD(SetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix) PURE;
    STDMETHOD(GetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 pTexture) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 *ppTexture) PURE;
    STDMETHOD(SetVertexShader)(THIS_ DWORD Name, DWORD Handle) PURE;
    STDMETHOD(GetVertexShader)(THIS_ DWORD Name, DWORD* pHandle) PURE;
    STDMETHOD(SetPixelShader)(THIS_ DWORD Name, DWORD Handle) PURE;
    STDMETHOD(GetPixelShader)(THIS_ DWORD Name, DWORD* pHandle) PURE;

    STDMETHOD(GetTechnique)(THIS_ UINT Index, LPD3DXTECHNIQUE* ppTechnique) PURE;
    STDMETHOD(CloneEffect)(THIS_ LPDIRECT3DDEVICE8 pDevice, DWORD Usage, LPD3DXEFFECT* ppEffect) PURE;
};



//////////////////////////////////////////////////////////////////////////////
// APIs //////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//----------------------------------------------------------------------------
// D3DXCompileEffect:
// ------------------
// Compiles an ascii effect description into a binary form usable by
// D3DXCreateEffect.
//
// Parameters:
//  pSrcFile
//      Name of the file containing the ascii effect description
//  pSrcData
//      Pointer to ascii effect description
//  SrcDataSize
//      Size of the effect description in bytes
//  ppCompiledEffect
//      Returns a buffer containing compiled effect.
//  ppCompilationErrors
//      Returns a buffer containing any error messages which occurred during
//      compile.  Or NULL if you do not care about the error messages.
//
//----------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCompileEffectFromFileA(
        LPCSTR            pSrcFile,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);

#define D3DXCompileEffectFromFile D3DXCompileEffectFromFileA


HRESULT WINAPI
    D3DXCompileEffect(
        LPCVOID           pSrcData,
        UINT              SrcDataSize,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);



//----------------------------------------------------------------------------
// D3DXCreateEffect:
// -----------------
// Creates an effect object, given compiled binary effect data
//
// Parameters:
//  pDevice
//      Pointer to the device to be used.
//  pCompiledEffect
//      Pointer to compiled effect data
//  CompiledEffectSize
//      Size of compiled effect data in bytes
//  Usage
//      Allows the specification of D3DUSAGE_SOFTWAREPROCESSING
//  ppEffect
//      Returns the created effect object
//----------------------------------------------------------------------------


HRESULT WINAPI
    D3DXCreateEffect(
        LPDIRECT3DDEVICE8 pDevice,
        LPCVOID           pCompiledEffect,
        UINT              CompiledEffectSize,
        DWORD             Usage,
        LPD3DXEFFECT*     ppEffect);



#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3DX8Core.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8core.h
//  Content:    D3DX core types and functions
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8CORE_H__
#define __D3DX8CORE_H__

#undef INTERFACE
#define INTERFACE VOID

///////////////////////////////////////////////////////////////////////////
// ID3DXBuffer:
// ------------
// The buffer object is used to return arbitrary lenght data.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXBuffer ID3DXBuffer;
typedef interface ID3DXBuffer *LPD3DXBUFFER;

// {932E6A7E-C68E-45dd-A7BF-53D19C86DB1F}
DEFINE_GUID(IID_ID3DXBuffer,
0x932e6a7e, 0xc68e, 0x45dd, 0xa7, 0xbf, 0x53, 0xd1, 0x9c, 0x86, 0xdb, 0x1f);

DECLARE_INTERFACE_(ID3DXBuffer, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBuffer
    STDMETHOD_(LPVOID, GetBufferPointer)(THIS) PURE;
    STDMETHOD_(DWORD, GetBufferSize)(THIS) PURE;
};






///////////////////////////////////////////////////////////////////////////
// ID3DXSprite:
// ------------
// This object intends to provide an easy way to drawing sprites using D3D.
//
// Begin -
//    Prepares device for drawing sprites
//
// Draw, DrawAffine, DrawTransform
//    Draws a sprite in screen-space.  Before transformation, the sprite is
//    the size of SrcRect, with its top-left corner at the origin (0,0).
//    The color and alpha channels are modulated by Color.
//
// End -
//     Restores device state to how it was when Begin was called.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXSprite ID3DXSprite;
typedef interface ID3DXSprite *LPD3DXSPRITE;


// {E8691849-87B8-4929-9050-1B0542D5538C}
DEFINE_GUID( IID_ID3DXSprite,
0xe8691849, 0x87b8, 0x4929, 0x90, 0x50, 0x1b, 0x5, 0x42, 0xd5, 0x53, 0x8c);


DECLARE_INTERFACE_(ID3DXSprite, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSprite
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;

    STDMETHOD(Begin)(THIS) PURE;

    STDMETHOD(Draw)(THIS_ LPDIRECT3DTEXTURE8  pSrcTexture,
        CONST RECT* pSrcRect, CONST D3DXVECTOR2* pScaling,
        CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation,
        CONST D3DXVECTOR2* pTranslation, D3DCOLOR Color) PURE;

    STDMETHOD(DrawTransform)(THIS_ LPDIRECT3DTEXTURE8 pSrcTexture,
        CONST RECT* pSrcRect, CONST D3DXMATRIX* pTransform,
        D3DCOLOR Color) PURE;

    STDMETHOD(End)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


HRESULT WINAPI
    D3DXCreateSprite(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXSPRITE*       ppSprite);

#ifdef __cplusplus
}
#endif //__cplusplus





///////////////////////////////////////////////////////////////////////////
// ID3DXRenderToSurface:
// ---------------------
// This object abstracts rendering to surfaces.  These surfaces do not
// necessarily need to be render targets.  If they are not, a compatible
// render target is used, and the result copied into surface at end scene.
///////////////////////////////////////////////////////////////////////////

typedef struct _D3DXRTS_DESC
{
    UINT                Width;
    UINT                Height;
    D3DFORMAT           Format;
    BOOL                DepthStencil;
    D3DFORMAT           DepthStencilFormat;

} D3DXRTS_DESC;


typedef interface ID3DXRenderToSurface ID3DXRenderToSurface;
typedef interface ID3DXRenderToSurface *LPD3DXRENDERTOSURFACE;


// {69CC587C-E40C-458d-B5D3-B029E18EB60A}
DEFINE_GUID( IID_ID3DXRenderToSurface,
0x69cc587c, 0xe40c, 0x458d, 0xb5, 0xd3, 0xb0, 0x29, 0xe1, 0x8e, 0xb6, 0xa);


DECLARE_INTERFACE_(ID3DXRenderToSurface, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXRenderToSurface
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXRTS_DESC* pDesc) PURE;

    STDMETHOD(BeginScene)(THIS_ LPDIRECT3DSURFACE8 pSurface, CONST D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateRenderToSurface(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Width,
        UINT                    Height,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRENDERTOSURFACE*  ppRenderToSurface);

#ifdef __cplusplus
}
#endif //__cplusplus



///////////////////////////////////////////////////////////////////////////
// ID3DXRenderToEnvMap:
// --------------------
///////////////////////////////////////////////////////////////////////////

typedef struct _D3DXRTE_DESC
{
    UINT        Size;
    D3DFORMAT   Format;
    BOOL        DepthStencil;
    D3DFORMAT   DepthStencilFormat;
} D3DXRTE_DESC;


typedef interface ID3DXRenderToEnvMap ID3DXRenderToEnvMap;
typedef interface ID3DXRenderToEnvMap *LPD3DXRenderToEnvMap;

// {9F6779E5-60A9-4d8b-AEE4-32770F405DBA}
DEFINE_GUID( IID_ID3DXRenderToEnvMap,
0x9f6779e5, 0x60a9, 0x4d8b, 0xae, 0xe4, 0x32, 0x77, 0xf, 0x40, 0x5d, 0xba);


DECLARE_INTERFACE_(ID3DXRenderToEnvMap, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXRenderToEnvMap
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXRTE_DESC* pDesc) PURE;

    STDMETHOD(BeginCube)(THIS_
        LPDIRECT3DCUBETEXTURE8 pCubeTex) PURE;

    STDMETHOD(BeginSphere)(THIS_
        LPDIRECT3DTEXTURE8 pTex) PURE;

    STDMETHOD(BeginHemisphere)(THIS_
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg) PURE;

    STDMETHOD(BeginParabolic)(THIS_
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg) PURE;

    STDMETHOD(Face)(THIS_ D3DCUBEMAP_FACES Face) PURE;
    STDMETHOD(End)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateRenderToEnvMap(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Size,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRenderToEnvMap*   ppRenderToEnvMap);

#ifdef __cplusplus
}
#endif //__cplusplus

///////////////////////////////////////////////////////////////////////////
// Misc APIs:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXGetFVFVertexSize:
// ---------------------
// Returns the size (in bytes) of a vertex for a given FVF.
//-------------------------------------------------------------------------

UINT WINAPI
    D3DXGetFVFVertexSize(DWORD FVF);


//-------------------------------------------------------------------------
// D3DXGetErrorString:
// ------------------
// Returns the error string for given an hresult.  Interprets all D3DX and
// D3D hresults.
//
// Parameters:
//  hr
//      The error code to be deciphered.
//  pBuffer
//      Pointer to the buffer to be filled in.
//  BufferLen
//      Count of characters in buffer.  Any error message longer than this
//      length will be truncated to fit.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXGetErrorStringA(
        HRESULT             hr,
        LPSTR               pBuffer,
        UINT                BufferLen);

HRESULT WINAPI
    D3DXGetErrorStringW(
        HRESULT             hr,
        LPWSTR              pBuffer,
        UINT                BufferLen);

#ifdef UNICODE
#define D3DXGetErrorString D3DXGetErrorStringW
#else
#define D3DXGetErrorString D3DXGetErrorStringA
#endif



#ifdef __cplusplus
}
#endif //__cplusplus


#endif //__D3DX8CORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3DX8Shape.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8shapes.h
//  Content:    D3DX simple shapes
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8SHAPES_H__
#define __D3DX8SHAPES_H__

///////////////////////////////////////////////////////////////////////////
// Functions:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXCreatePolygon:
// ------------------
// Creates a mesh containing an n-sided polygon.  The polygon is centered
// at the origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Length      Length of each side.
//  Sides       Number of sides the polygon has.  (Must be >= 3)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreatePolygon(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Length,
        UINT                Sides,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateBox:
// --------------
// Creates a mesh containing an axis-aligned box.  The box is centered at
// the origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Width       Width of box (along X-axis)
//  Height      Height of box (along Y-axis)
//  Depth       Depth of box (along Z-axis)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateBox(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Width,
        FLOAT               Height,
        FLOAT               Depth,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateCylinder:
// -------------------
// Creates a mesh containing a cylinder.  The generated cylinder is
// centered at the origin, and its axis is aligned with the Z-axis.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Radius1     Radius at -Z end (should be >= 0.0f)
//  Radius2     Radius at +Z end (should be >= 0.0f)
//  Length      Length of cylinder (along Z-axis)
//  Slices      Number of slices about the main axis
//  Stacks      Number of stacks along the main axis
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCylinder(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Radius1,
        FLOAT               Radius2,
        FLOAT               Length,
        UINT                Slices,
        UINT                Stacks,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateSphere:
// -----------------
// Creates a mesh containing a sphere.  The sphere is centered at the
// origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Radius      Radius of the sphere (should be >= 0.0f)
//  Slices      Number of slices about the main axis
//  Stacks      Number of stacks along the main axis
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateSphere(
        LPDIRECT3DDEVICE8  pDevice,
        FLOAT              Radius,
        UINT               Slices,
        UINT               Stacks,
        LPD3DXMESH*        ppMesh,
        LPD3DXBUFFER*      ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateTorus:
// ----------------
// Creates a mesh containing a torus.  The generated torus is centered at
// the origin, and its axis is aligned with the Z-axis.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  InnerRadius Inner radius of the torus (should be >= 0.0f)
//  OuterRadius Outer radius of the torue (should be >= 0.0f)
//  Sides       Number of sides in a cross-section (must be >= 3)
//  Rings       Number of rings making up the torus (must be >= 3)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTorus(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               InnerRadius,
        FLOAT               OuterRadius,
        UINT                Sides,
        UINT                Rings,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateTeapot:
// -----------------
// Creates a mesh containing a teapot.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTeapot(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8SHAPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3DX8Mesh.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8mesh.h
//  Content:    D3DX mesh types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8MESH_H__
#define __D3DX8MESH_H__

#include "dxfile.h"     // defines LPDIRECTXFILEDATA

// {A69BA991-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXBaseMesh,
0xa69ba991, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {9D84AC46-6B90-49a9-A721-085C7A3E3DAE}
DEFINE_GUID(IID_ID3DXMesh,
0x9d84ac46, 0x6b90, 0x49a9, 0xa7, 0x21, 0x8, 0x5c, 0x7a, 0x3e, 0x3d, 0xae);

// {15981AA8-1A05-48e3-BBE7-FF5D49654E3F}
DEFINE_GUID(IID_ID3DXPMesh,
0x15981aa8, 0x1a05, 0x48e3, 0xbb, 0xe7, 0xff, 0x5d, 0x49, 0x65, 0x4e, 0x3f);

// {BC3BBDE2-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXSPMesh,
0xbc3bbde2, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {82A53844-F322-409e-A2E9-992E1104069D}
DEFINE_GUID(IID_ID3DXSkinMesh,
0x82a53844, 0xf322, 0x409e, 0xa2, 0xe9, 0x99, 0x2e, 0x11, 0x4, 0x6, 0x9d);


enum _D3DXMESH {
    D3DXMESH_32BIT                  = 0x001, // If set, then use 32 bit indices, if not set use 16 bit indices. 32BIT meshes currently not supported on ID3DXSkinMesh object
    D3DXMESH_DONOTCLIP              = 0x002, // Use D3DUSAGE_DONOTCLIP for VB & IB.
    D3DXMESH_POINTS                 = 0x004, // Use D3DUSAGE_POINTS for VB & IB.
    D3DXMESH_RTPATCHES              = 0x008, // Use D3DUSAGE_RTPATCHES for VB & IB.
    D3DXMESH_NPATCHES               = 0x4000,// Use D3DUSAGE_NPATCHES for VB & IB.
    D3DXMESH_VB_SYSTEMMEM           = 0x010, // Use D3DPOOL_SYSTEMMEM for VB. Overrides D3DXMESH_MANAGEDVERTEXBUFFER
    D3DXMESH_VB_MANAGED             = 0x020, // Use D3DPOOL_MANAGED for VB.
    D3DXMESH_VB_WRITEONLY           = 0x040, // Use D3DUSAGE_WRITEONLY for VB.
    D3DXMESH_VB_DYNAMIC             = 0x080, // Use D3DUSAGE_DYNAMIC for VB.
    D3DXMESH_IB_SYSTEMMEM           = 0x100, // Use D3DPOOL_SYSTEMMEM for IB. Overrides D3DXMESH_MANAGEDINDEXBUFFER
    D3DXMESH_IB_MANAGED             = 0x200, // Use D3DPOOL_MANAGED for IB.
    D3DXMESH_IB_WRITEONLY           = 0x400, // Use D3DUSAGE_WRITEONLY for IB.
    D3DXMESH_IB_DYNAMIC             = 0x800, // Use D3DUSAGE_DYNAMIC for IB.

    D3DXMESH_VB_SHARE               = 0x1000, // Valid for Clone* calls only, forces cloned mesh/pmesh to share vertex buffer

    D3DXMESH_USEHWONLY              = 0x2000, // Valid for ID3DXSkinMesh::ConvertToBlendedMesh

    // Helper options
    D3DXMESH_SYSTEMMEM              = 0x110, // D3DXMESH_VB_SYSTEMMEM | D3DXMESH_IB_SYSTEMMEM
    D3DXMESH_MANAGED                = 0x220, // D3DXMESH_VB_MANAGED | D3DXMESH_IB_MANAGED
    D3DXMESH_WRITEONLY              = 0x440, // D3DXMESH_VB_WRITEONLY | D3DXMESH_IB_WRITEONLY
    D3DXMESH_DYNAMIC                = 0x880, // D3DXMESH_VB_DYNAMIC | D3DXMESH_IB_DYNAMIC

};

// option field values for specifying min value in D3DXGeneratePMesh and D3DXSimplifyMesh
enum _D3DXMESHSIMP
{
    D3DXMESHSIMP_VERTEX   = 0x1,
    D3DXMESHSIMP_FACE     = 0x2,

};

enum _MAX_FVF_DECL_SIZE
{
    MAX_FVF_DECL_SIZE = 20
};

typedef struct ID3DXBaseMesh *LPD3DXBASEMESH;
typedef struct ID3DXMesh *LPD3DXMESH;
typedef struct ID3DXPMesh *LPD3DXPMESH;
typedef struct ID3DXSPMesh *LPD3DXSPMESH;
typedef struct ID3DXSkinMesh *LPD3DXSKINMESH;

typedef struct _D3DXATTRIBUTERANGE
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
} D3DXATTRIBUTERANGE;

typedef D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE;

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
struct D3DXMATERIAL
{
    D3DMATERIAL8  MatD3D;
    LPSTR         pTextureFilename;
};
typedef struct D3DXMATERIAL *LPD3DXMATERIAL;
#ifdef __cplusplus
}
#endif //__cplusplus

typedef struct _D3DXATTRIBUTEWEIGHTS
{
    FLOAT Position;
    FLOAT Boundary;
    FLOAT Normal;
    FLOAT Diffuse;
    FLOAT Specular;
    FLOAT Tex[8];
} D3DXATTRIBUTEWEIGHTS;

typedef D3DXATTRIBUTEWEIGHTS* LPD3DXATTRIBUTEWEIGHTS;

DECLARE_INTERFACE_(ID3DXBaseMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;
};

DECLARE_INTERFACE_(ID3DXMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXMesh
    STDMETHOD(LockAttributeBuffer)(THIS_ DWORD Flags, DWORD** ppData) PURE;
    STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;
    STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;
    STDMETHOD(GenerateAdjacency)(THIS_ FLOAT fEpsilon, DWORD* pAdjacency) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(OptimizeInplace)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap) PURE;
};

DECLARE_INTERFACE_(ID3DXPMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXPMesh
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(SetNumFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(SetNumVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinVertices)(THIS) PURE;
    STDMETHOD(Save)(THIS_ IStream *pStream, LPD3DXMATERIAL pMaterials, DWORD NumMaterials) PURE;

    STDMETHOD(Optimize)(THIS_ DWORD Flags, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(GetAdjacency)(THIS_ DWORD* pAdjacency) PURE;
};

DECLARE_INTERFACE_(ID3DXSPMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSPMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ReduceFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(ReduceVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
};

#define UNUSED16 (0xffff)
#define UNUSED32 (0xffffffff)

// ID3DXMesh::Optimize options
enum _D3DXMESHOPT {
    D3DXMESHOPT_COMPACT       = 0x001,
    D3DXMESHOPT_ATTRSORT      = 0x002,
    D3DXMESHOPT_VERTEXCACHE   = 0x004,
    D3DXMESHOPT_STRIPREORDER  = 0x008,
    D3DXMESHOPT_IGNOREVERTS   = 0x010,  // optimize faces only, don't touch vertices
    D3DXMESHOPT_SHAREVB       = 0x020,
};

// Subset of the mesh that has the same attribute and bone combination.
// This subset can be rendered in a single draw call
typedef struct _D3DXBONECOMBINATION
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
    DWORD* BoneId;
} D3DXBONECOMBINATION, *LPD3DXBONECOMBINATION;

DECLARE_INTERFACE_(ID3DXSkinMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(LockAttributeBuffer)(THIS_ DWORD flags, DWORD** ppData) PURE;
    STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    // ID3DXSkinMesh
    STDMETHOD_(DWORD, GetNumBones)(THIS) PURE;
    STDMETHOD(GetOriginalMesh)(THIS_ LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(SetBoneInfluence)(THIS_ DWORD bone, DWORD numInfluences, CONST DWORD* vertices, CONST FLOAT* weights) PURE;
    STDMETHOD_(DWORD, GetNumBoneInfluences)(THIS_ DWORD bone) PURE;
    STDMETHOD(GetBoneInfluence)(THIS_ DWORD bone, DWORD* vertices, FLOAT* weights) PURE;
    STDMETHOD(GetMaxVertexInfluences)(THIS_ DWORD* maxVertexInfluences) PURE;
    STDMETHOD(GetMaxFaceInfluences)(THIS_ DWORD* maxFaceInfluences) PURE;
    STDMETHOD(ConvertToBlendedMesh)(THIS_ DWORD options, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut,
                            DWORD* pNumBoneCombinations, LPD3DXBUFFER* ppBoneCombinationTable, LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(ConvertToIndexedBlendedMesh)(THIS_ DWORD options,
                                           CONST LPDWORD pAdjacencyIn,
                                           DWORD paletteSize,
                                           LPDWORD pAdjacencyOut,
                                           DWORD* pNumBoneCombinations,
                                           LPD3DXBUFFER* ppBoneCombinationTable,
                                           LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(GenerateSkinnedMesh)(THIS_ DWORD options, FLOAT minWeight, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut, LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(UpdateSkinnedMesh)(THIS_ CONST D3DXMATRIX* pBoneTransforms, LPD3DXMESH pMesh) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateMesh(
        DWORD NumFaces,
        DWORD NumVertices,
        DWORD Options,
        CONST DWORD *pDeclaration,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXCreateMeshFVF(
        DWORD NumFaces,
        DWORD NumVertices,
        DWORD Options,
        DWORD FVF,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXCreateSPMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        LPD3DXSPMESH* ppSMesh);

// clean a mesh up for simplification, try to make manifold
HRESULT WINAPI
    D3DXCleanMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency,
    LPD3DXMESH* ppMeshOut);

HRESULT WINAPI
    D3DXValidMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency);

HRESULT WINAPI
    D3DXGeneratePMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue,
        DWORD Options,
        LPD3DXPMESH* ppPMesh);

HRESULT WINAPI
    D3DXSimplifyMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue,
        DWORD Options,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXComputeBoundingSphere(
        PVOID pPointsFVF,
        DWORD NumVertices,
        DWORD FVF,
        D3DXVECTOR3 *pCenter,
        FLOAT *pRadius);

HRESULT WINAPI
    D3DXComputeBoundingBox(
        PVOID pPointsFVF,
        DWORD NumVertices,
        DWORD FVF,
        D3DXVECTOR3 *pMin,
        D3DXVECTOR3 *pMax);

HRESULT WINAPI
    D3DXComputeNormals(
        LPD3DXBASEMESH pMesh);

HRESULT WINAPI
    D3DXCreateBuffer(
        DWORD NumBytes,
        LPD3DXBUFFER *ppBuffer);


HRESULT WINAPI
    D3DXLoadMeshFromX(
        LPSTR pFilename,
        DWORD Options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials,
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXSaveMeshToX(
        LPSTR pFilename,
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXMATERIAL pMaterials,
        DWORD NumMaterials,
        DWORD Format
        );

HRESULT WINAPI
    D3DXCreatePMeshFromStream(
        IStream *pStream,
    DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice,
        LPD3DXBUFFER *ppMaterials,
        DWORD* pNumMaterials,
        LPD3DXPMESH *ppPMesh);

HRESULT WINAPI
    D3DXCreateSkinMesh(
        DWORD numFaces,
        DWORD numVertices,
        DWORD numBones,
        DWORD options,
        CONST DWORD *pDeclaration,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFVF(
        DWORD numFaces,
        DWORD numVertices,
        DWORD numBones,
        DWORD options,
        DWORD fvf,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFromMesh(
        LPD3DXMESH pMesh,
        DWORD numBones,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXLoadMeshFromXof(
        LPDIRECTXFILEDATA pXofObjMesh,
        DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice,
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials,
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXLoadSkinMeshFromXof(
        LPDIRECTXFILEDATA pxofobjMesh,
        DWORD options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER* ppAdjacency,
        LPD3DXBUFFER* ppMaterials,
        PDWORD pMatOut,
        LPD3DXBUFFER* ppBoneNames,
        LPD3DXBUFFER* ppBoneTransforms,
        LPD3DXSKINMESH* ppMesh);

HRESULT WINAPI
    D3DXTesselateMesh(
        LPD3DXMESH pMeshIn,
        CONST DWORD* pAdjacency,
        FLOAT NumSegs,
        BOOL  QuadraticInterpNormals,     // if false use linear intrep for normals, if true use quadratic
        LPD3DXMESH *ppMeshOut);

HRESULT WINAPI
    D3DXDeclaratorFromFVF(
        DWORD FVF,
        DWORD Declaration[MAX_FVF_DECL_SIZE]);

HRESULT WINAPI
    D3DXFVFFromDeclarator(
        CONST DWORD *pDeclarator,
        DWORD *pFVF);

HRESULT WINAPI
    D3DXWeldVertices(
        CONST LPD3DXMESH pMesh,
        float fEpsilon,
        CONST DWORD *rgdwAdjacencyIn,
        DWORD *rgdwAdjacencyOut,
        DWORD* pFaceRemap,
        LPD3DXBUFFER *ppbufVertexRemap);

HRESULT WINAPI
    D3DXIntersect(
        LPD3DXBASEMESH pMesh,
        CONST D3DXVECTOR3 *pRayPos,
        CONST D3DXVECTOR3 *pRayDir,
        BOOL    *pHit,
        DWORD   *pFaceIndex,
        FLOAT   *pU,
        FLOAT   *pV,
        FLOAT   *pDist);

BOOL WINAPI
    D3DXSphereBoundProbe(
        CONST D3DXVECTOR3 *pvCenter,
        FLOAT fRadius,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

BOOL WINAPI
    D3DXBoxBoundProbe(
        CONST D3DXVECTOR3 *pvMin,
        CONST D3DXVECTOR3 *pvMax,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

enum _D3DXERR {
    D3DXERR_CANNOTMODIFYINDEXBUFFER     = MAKE_DDHRESULT(2900),
    D3DXERR_INVALIDMESH                 = MAKE_DDHRESULT(2901),
    D3DXERR_CANNOTATTRSORT              = MAKE_DDHRESULT(2902),
    D3DXERR_SKINNINGNOTSUPPORTED        = MAKE_DDHRESULT(2903),
    D3DXERR_TOOMANYINFLUENCES           = MAKE_DDHRESULT(2904),
    D3DXERR_INVALIDDATA                 = MAKE_DDHRESULT(2905),
};

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8MESH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3DX8Math.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8math.h
//  Content:    D3DX math types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __XGMATH_H__

#ifndef __D3DX8MATH_H__
#define __D3DX8MATH_H__

#ifdef __cplusplus
extern "C++" {
#endif // __cplusplus

#include <math.h>

#pragma warning(disable:4201) // anonymous unions warning



typedef struct ID3DXMatrixStack *LPD3DXMATRIXSTACK;

// {E3357330-CC5E-11d2-A434-00A0C90629A8}
DEFINE_GUID( IID_ID3DXMatrixStack,
0xe3357330, 0xcc5e, 0x11d2, 0xa4, 0x34, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);


//===========================================================================
//
// General purpose utilities
//
//===========================================================================
#define D3DX_PI    ((FLOAT)  3.141592654f)
#define D3DX_1BYPI ((FLOAT)  0.318309886f)

#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))



//===========================================================================
//
// Vectors
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------
typedef struct D3DXVECTOR2
{
#ifdef __cplusplus
public:
    D3DXVECTOR2() {};
    D3DXVECTOR2( CONST FLOAT * );
    D3DXVECTOR2( FLOAT x, FLOAT y );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR2& operator += ( CONST D3DXVECTOR2& );
    D3DXVECTOR2& operator -= ( CONST D3DXVECTOR2& );
    D3DXVECTOR2& operator *= ( FLOAT );
    D3DXVECTOR2& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR2 operator + () const;
    D3DXVECTOR2 operator - () const;

    // binary operators
    D3DXVECTOR2 operator + ( CONST D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator - ( CONST D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator * ( FLOAT ) const;
    D3DXVECTOR2 operator / ( FLOAT ) const;

    friend D3DXVECTOR2 operator * ( FLOAT, CONST D3DXVECTOR2& );

    BOOL operator == ( CONST D3DXVECTOR2& ) const;
    BOOL operator != ( CONST D3DXVECTOR2& ) const;


public:
#endif //__cplusplus
    FLOAT x, y;
} D3DXVECTOR2, *LPD3DXVECTOR2;


//--------------------------
// 3D Vector
//--------------------------
#ifdef __cplusplus
typedef struct D3DXVECTOR3 : public D3DVECTOR
{
public:
    D3DXVECTOR3() {};
    D3DXVECTOR3( CONST FLOAT * );
    D3DXVECTOR3( CONST D3DVECTOR& );
    D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR3& operator += ( CONST D3DXVECTOR3& );
    D3DXVECTOR3& operator -= ( CONST D3DXVECTOR3& );
    D3DXVECTOR3& operator *= ( FLOAT );
    D3DXVECTOR3& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR3 operator + () const;
    D3DXVECTOR3 operator - () const;

    // binary operators
    D3DXVECTOR3 operator + ( CONST D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator - ( CONST D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator * ( FLOAT ) const;
    D3DXVECTOR3 operator / ( FLOAT ) const;

    friend D3DXVECTOR3 operator * ( FLOAT, CONST struct D3DXVECTOR3& );

    BOOL operator == ( CONST D3DXVECTOR3& ) const;
    BOOL operator != ( CONST D3DXVECTOR3& ) const;

} D3DXVECTOR3, *LPD3DXVECTOR3;

#else //!__cplusplus
typedef struct _D3DVECTOR D3DXVECTOR3, *LPD3DXVECTOR3;
#endif //!__cplusplus


//--------------------------
// 4D Vector
//--------------------------
typedef struct D3DXVECTOR4
{
#ifdef __cplusplus
public:
    D3DXVECTOR4() {};
    D3DXVECTOR4( CONST FLOAT* );
    D3DXVECTOR4( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR4& operator += ( CONST D3DXVECTOR4& );
    D3DXVECTOR4& operator -= ( CONST D3DXVECTOR4& );
    D3DXVECTOR4& operator *= ( FLOAT );
    D3DXVECTOR4& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR4 operator + () const;
    D3DXVECTOR4 operator - () const;

    // binary operators
    D3DXVECTOR4 operator + ( CONST D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator - ( CONST D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator * ( FLOAT ) const;
    D3DXVECTOR4 operator / ( FLOAT ) const;

    friend D3DXVECTOR4 operator * ( FLOAT, CONST D3DXVECTOR4& );

    BOOL operator == ( CONST D3DXVECTOR4& ) const;
    BOOL operator != ( CONST D3DXVECTOR4& ) const;

public:
#endif //__cplusplus
    FLOAT x, y, z, w;
} D3DXVECTOR4, *LPD3DXVECTOR4;


//===========================================================================
//
// Matrices
//
//===========================================================================
#ifdef __cplusplus
typedef struct D3DXMATRIX : public D3DMATRIX
{
public:
    D3DXMATRIX() {};
    D3DXMATRIX( CONST FLOAT * );
    D3DXMATRIX( CONST D3DMATRIX& );
    D3DXMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
                FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
                FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
                FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );


    // access grants
    FLOAT& operator () ( UINT Row, UINT Col );
    FLOAT  operator () ( UINT Row, UINT Col ) const;

    // casting operators
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXMATRIX& operator *= ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator += ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator -= ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator *= ( FLOAT );
    D3DXMATRIX& operator /= ( FLOAT );

    // unary operators
    D3DXMATRIX operator + () const;
    D3DXMATRIX operator - () const;

    // binary operators
    D3DXMATRIX operator * ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator + ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator - ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator * ( FLOAT ) const;
    D3DXMATRIX operator / ( FLOAT ) const;

    friend D3DXMATRIX operator * ( FLOAT, CONST D3DXMATRIX& );

    BOOL operator == ( CONST D3DXMATRIX& ) const;
    BOOL operator != ( CONST D3DXMATRIX& ) const;

} D3DXMATRIX, *LPD3DXMATRIX;

#else //!__cplusplus
typedef struct _D3DMATRIX D3DXMATRIX, *LPD3DXMATRIX;
#endif //!__cplusplus


//===========================================================================
//
//    Quaternions
//
//===========================================================================
typedef struct D3DXQUATERNION
{
#ifdef __cplusplus
public:
    D3DXQUATERNION() {}
    D3DXQUATERNION( CONST FLOAT * );
    D3DXQUATERNION( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXQUATERNION& operator += ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator -= ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( FLOAT );
    D3DXQUATERNION& operator /= ( FLOAT );

    // unary operators
    D3DXQUATERNION  operator + () const;
    D3DXQUATERNION  operator - () const;

    // binary operators
    D3DXQUATERNION operator + ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator - ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( FLOAT ) const;
    D3DXQUATERNION operator / ( FLOAT ) const;

    friend D3DXQUATERNION operator * (FLOAT, CONST D3DXQUATERNION& );

    BOOL operator == ( CONST D3DXQUATERNION& ) const;
    BOOL operator != ( CONST D3DXQUATERNION& ) const;

#endif //__cplusplus
    FLOAT x, y, z, w;
} D3DXQUATERNION, *LPD3DXQUATERNION;


//===========================================================================
//
// Planes
//
//===========================================================================
typedef struct D3DXPLANE
{
#ifdef __cplusplus
public:
    D3DXPLANE() {}
    D3DXPLANE( CONST FLOAT* );
    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // unary operators
    D3DXPLANE operator + () const;
    D3DXPLANE operator - () const;

    // binary operators
    BOOL operator == ( CONST D3DXPLANE& ) const;
    BOOL operator != ( CONST D3DXPLANE& ) const;

#endif //__cplusplus
    FLOAT a, b, c, d;
} D3DXPLANE, *LPD3DXPLANE;


//===========================================================================
//
// Colors
//
//===========================================================================

typedef struct D3DXCOLOR
{
#ifdef __cplusplus
public:
    D3DXCOLOR() {}
    D3DXCOLOR( DWORD argb );
    D3DXCOLOR( CONST FLOAT * );
    D3DXCOLOR( CONST D3DCOLORVALUE& );
    D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );

    // casting
    operator DWORD () const;

    operator FLOAT* ();
    operator CONST FLOAT* () const;

    operator D3DCOLORVALUE* ();
    operator CONST D3DCOLORVALUE* () const;

    operator D3DCOLORVALUE& ();
    operator CONST D3DCOLORVALUE& () const;

    // assignment operators
    D3DXCOLOR& operator += ( CONST D3DXCOLOR& );
    D3DXCOLOR& operator -= ( CONST D3DXCOLOR& );
    D3DXCOLOR& operator *= ( FLOAT );
    D3DXCOLOR& operator /= ( FLOAT );

    // unary operators
    D3DXCOLOR operator + () const;
    D3DXCOLOR operator - () const;

    // binary operators
    D3DXCOLOR operator + ( CONST D3DXCOLOR& ) const;
    D3DXCOLOR operator - ( CONST D3DXCOLOR& ) const;
    D3DXCOLOR operator * ( FLOAT ) const;
    D3DXCOLOR operator / ( FLOAT ) const;

    friend D3DXCOLOR operator * (FLOAT, CONST D3DXCOLOR& );

    BOOL operator == ( CONST D3DXCOLOR& ) const;
    BOOL operator != ( CONST D3DXCOLOR& ) const;

#endif //__cplusplus
    FLOAT r, g, b, a;
} D3DXCOLOR, *LPD3DXCOLOR;



//===========================================================================
//
// D3DX math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

FLOAT D3DXVec2Length
    ( CONST D3DXVECTOR2 *pV );

FLOAT D3DXVec2LengthSq
    ( CONST D3DXVECTOR2 *pV );

FLOAT D3DXVec2Dot
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
FLOAT D3DXVec2CCW
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s );

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR2* WINAPI D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR2* WINAPI D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pT1,
      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR2* WINAPI D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV0, CONST D3DXVECTOR2 *pV1,
      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, 0, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

FLOAT D3DXVec3Length
    ( CONST D3DXVECTOR3 *pV );

FLOAT D3DXVec3LengthSq
    ( CONST D3DXVECTOR3 *pV );

FLOAT D3DXVec3Dot
    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR3* WINAPI D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR3* WINAPI D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pT1,
      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR3* WINAPI D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV0, CONST D3DXVECTOR3 *pV1,
      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      CONST D3DXVECTOR3 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, z, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a
// non-affine matrix, the matrix you pass to this function should be the
// transpose of the inverse of the matrix you would use to transform a coord.
D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Project vector from object space into screen space
D3DXVECTOR3* WINAPI D3DXVec3Project
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);

// Project vector from screen space into object space
D3DXVECTOR3* WINAPI D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

FLOAT D3DXVec4Length
    ( CONST D3DXVECTOR4 *pV );

FLOAT D3DXVec4LengthSq
    ( CONST D3DXVECTOR4 *pV );

FLOAT D3DXVec4Dot
    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 );

D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
D3DXVECTOR4* WINAPI D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      CONST D3DXVECTOR4 *pV3);

D3DXVECTOR4* WINAPI D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR4* WINAPI D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pT1,
      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR4* WINAPI D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV0, CONST D3DXVECTOR4 *pV1,
      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      CONST D3DXVECTOR4 *pV3, FLOAT f, FLOAT g);

// Transform vector by matrix.
D3DXVECTOR4* WINAPI D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut );

BOOL D3DXMatrixIsIdentity
    ( CONST D3DXMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

FLOAT WINAPI D3DXMatrixfDeterminant
    ( CONST D3DXMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2
// followed by the transformation M1.  (Out = M1 * M2)
D3DXMATRIX* WINAPI D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );

D3DXMATRIX* WINAPI D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
D3DXMATRIX* WINAPI D3DXMatrixInverse
    ( D3DXMATRIX *pOut, FLOAT *pDeterminant, CONST D3DXMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
D3DXMATRIX* WINAPI D3DXMatrixScaling
    ( D3DXMATRIX *pOut, FLOAT sx, FLOAT sy, FLOAT sz );

// Build a matrix which translates by (x, y, z)
D3DXMATRIX* WINAPI D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, FLOAT x, FLOAT y, FLOAT z );

// Build a matrix which rotates around the X axis
D3DXMATRIX* WINAPI D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Y axis
D3DXMATRIX* WINAPI D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Z axis
D3DXMATRIX* WINAPI D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around an arbitrary axis
D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );

// Build a matrix from a quaternion
D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, CONST D3DXQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );


// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pScalingCenter,
      CONST D3DXQUATERNION *pScalingRotation, CONST D3DXVECTOR3 *pScaling,
      CONST D3DXVECTOR3 *pRotationCenter, CONST D3DXQUATERNION *pRotation,
      CONST D3DXVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR3 *pRotationCenter,
      CONST D3DXQUATERNION *pRotation, CONST D3DXVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
      CONST D3DXVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
      CONST D3DXVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
D3DXMATRIX* WINAPI D3DXMatrixShadow
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR4 *pLight,
      CONST D3DXPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
D3DXMATRIX* WINAPI D3DXMatrixReflect
    ( D3DXMATRIX *pOut, CONST D3DXPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

FLOAT D3DXQuaternionLength
    ( CONST D3DXQUATERNION *pQ );

// Length squared, or "norm"
FLOAT D3DXQuaternionLengthSq
    ( CONST D3DXQUATERNION *pQ );

FLOAT D3DXQuaternionDot
    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 );

// (0, 0, 0, 1)
D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut );

BOOL D3DXQuaternionIsIdentity
    ( CONST D3DXQUATERNION *pQ );

// (-x, -y, -z, w)
D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI D3DXQuaternionToAxisAngle
    ( CONST D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, FLOAT *pAngle );

// Build a quaternion from a rotation matrix.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, CONST D3DXMATRIX *pM);

// Rotation about arbitrary axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );

// Quaternion multiplication.  The result represents the rotation Q2
// followed by the rotation Q1.  (Out = Q2 * Q1)
D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2 );

D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Conjugate and re-norm
D3DXQUATERNION* WINAPI D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
D3DXQUATERNION* WINAPI D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
D3DXQUATERNION* WINAPI D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, FLOAT t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
D3DXQUATERNION* WINAPI D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
      CONST D3DXQUATERNION *pQ4, FLOAT t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
      FLOAT f, FLOAT g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
FLOAT D3DXPlaneDot
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV);

// ax + by + cz + d
FLOAT D3DXPlaneDotCoord
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);

// ax + by + cz
FLOAT D3DXPlaneDotNormal
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
D3DXPLANE* WINAPI D3DXPlaneNormalize
    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV1,
      CONST D3DXVECTOR3 *pV2);

// Construct a plane from a point and a normal
D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pPoint, CONST D3DXVECTOR3 *pNormal);

// Construct a plane from 3 points
D3DXPLANE* WINAPI D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      CONST D3DXVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
D3DXPLANE* WINAPI D3DXPlaneTransform
    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC);

D3DXCOLOR* D3DXColorAdd
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorSubtract
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorScale
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
D3DXCOLOR* D3DXColorModulate
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
D3DXCOLOR* D3DXColorLerp
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
D3DXCOLOR* WINAPI D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT c);

#ifdef __cplusplus
}
#endif






//===========================================================================
//
//    Matrix Stack
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   ID3DXMatrixStack

DECLARE_INTERFACE_(ID3DXMatrixStack, IUnknown)
{
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // ID3DXMatrixStack methods
    //

    // Pops the top of the stack, returns the current top
    // *after* popping the top.
    STDMETHOD(Pop)(THIS) PURE;

    // Pushes the stack by one, duplicating the current matrix.
    STDMETHOD(Push)(THIS) PURE;

    // Loads identity in the current matrix.
    STDMETHOD(LoadIdentity)(THIS) PURE;

    // Loads the given matrix into the current matrix
    STDMETHOD(LoadMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Right-Multiplies the given matrix to the current matrix.
    // (transformation is about the current world origin)
    STDMETHOD(MultMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Left-Multiplies the given matrix to the current matrix
    // (transformation is about the local origin of the object)
    STDMETHOD(MultMatrixLocal)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the current world origin)
    STDMETHOD(RotateAxis)
        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the local origin of the object)
    STDMETHOD(RotateAxisLocal)
        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // current world origin)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRoll)
        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // local origin of the object)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRollLocal)
        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;

    // Right multiply the current matrix with the computed scale
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Scale)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Left multiply the current matrix with the computed scale
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(ScaleLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Right multiply the current matrix with the computed translation
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Translate)(THIS_ FLOAT x, FLOAT y, FLOAT z ) PURE;

    // Left multiply the current matrix with the computed translation
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(TranslateLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Obtain the current matrix at the top of the stack
    STDMETHOD_(D3DXMATRIX*, GetTop)(THIS) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI D3DXCreateMatrixStack( DWORD Flags, LPD3DXMATRIXSTACK *ppStack );

#ifdef __cplusplus
}
#endif

#include "d3dx8math.inl"

#pragma warning(default:4201)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __D3DX8MATH_H__

#endif // __XGMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\CPXXUPD\public\xdk\inc-mar02\D3DX8Tex.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8tex.h
//  Content:    D3DX texturing APIs
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8TEX_H__
#define __D3DX8TEX_H__

//-------------------------------------------------------------------------
// D3DXSetDXT3DXT5
// ---------------
//
// Set premultiplied alpha format for DXT surface and texture processing.
// When set to true, DXT surfaces will be processed with nonpremultiplied
// alpha i.e. DXT3 / DXT5 format. When set to false, surfaces will be
// processed with premultiplied alpha, i.e. DXT2 / DXT4 format. The default
// is nonpremultiplied alpha - DXT3 / DXT5.
//
//-------------------------------------------------------------------------

void WINAPI D3DXSetDXT3DXT5(BOOL Set);

//-------------------------------------------------------------------------
// D3DXGetDXT3DXT5
// ---------------
//
// Get whether D3DX is currently using nonpremultiplied alpha format -
// DXT3 / DXT5 or premultiplied alpha format - DXT2 / DXT4 for DXT surface
// and texture processing.
//
//-------------------------------------------------------------------------

BOOL WINAPI D3DXGetDXT3DXT5(void);

//-------------------------------------------------------------------------
// D3DX_FILTER flags:
// ------------------
//
// A valid filter must contain one of these values:
//
//  D3DX_FILTER_NONE
//      No scaling or filtering will take place.  Pixels outside the bounds
//      of the source image are assumed to be transparent black.
//  D3DX_FILTER_POINT
//      Each destination pixel is computed by sampling the nearest pixel
//      from the source image.
//  D3DX_FILTER_LINEAR
//      Each destination pixel is computed by linearly interpolating between
//      the nearest pixels in the source image.  This filter works best
//      when the scale on each axis is less than 2.
//  D3DX_FILTER_TRIANGLE
//      Every pixel in the source image contributes equally to the
//      destination image.  This is the slowest of all the filters.
//  D3DX_FILTER_BOX
//      Each pixel is computed by averaging a 2x2(x2) box pixels from
//      the source image. Only works when the dimensions of the
//      destination are half those of the source. (as with mip maps)
//
//
// And can be OR'd with any of these optional flags:
//
//  D3DX_FILTER_MIRROR_U
//      Indicates that pixels off the edge of the texture on the U-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR_V
//      Indicates that pixels off the edge of the texture on the V-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR_W
//      Indicates that pixels off the edge of the texture on the W-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR
//      Same as specifying D3DX_FILTER_MIRROR_U, D3DX_FILTER_MIRROR_V,
//      and D3DX_FILTER_MIRROR_V
//  D3DX_FILTER_DITHER
//      Dithers the resulting image.
//
//-------------------------------------------------------------------------

#define D3DX_FILTER_NONE      (1 << 0)
#define D3DX_FILTER_POINT     (2 << 0)
#define D3DX_FILTER_LINEAR    (3 << 0)
#define D3DX_FILTER_TRIANGLE  (4 << 0)
#define D3DX_FILTER_BOX       (5 << 0)

#define D3DX_FILTER_MIRROR_U  (1 << 16)
#define D3DX_FILTER_MIRROR_V  (2 << 16)
#define D3DX_FILTER_MIRROR_W  (4 << 16)
#define D3DX_FILTER_MIRROR    (7 << 16)
#define D3DX_FILTER_DITHER    (8 << 16)


//-------------------------------------------------------------------------
// D3DXIMAGE_INFO:
// ---------------
// This structure is used to return a rough description of what the
// the original contents of an image file looked like.
//
//  Width
//      Width of original image in pixels
//  Height
//      Height of original image in pixels
//  Depth
//      Depth of original image in pixels
//  MipLevels
//      Number of mip levels in original image
//  Format
//      D3D format which most closely describes the data in original image
//
//-------------------------------------------------------------------------


typedef struct _D3DXIMAGE_INFO
{
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT MipLevels;
    D3DFORMAT Format;

} D3DXIMAGE_INFO;

#ifndef _PALETTEENTRY_DEFINED
#define _PALETTEENTRY_DEFINED

typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY, FAR *LPPALETTEENTRY;

#endif


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromFile/Resource:
// ---------------------------------
// Load surface from a file or resource
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcFile
//      File name of the source image.
//  pSrcModule
//      Module where resource is located, or NULL for module associated
//      with image the os used to create the current process.
//  pSrcResource
//      Resource name
//  pSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  pSrcRect
//      Source rectangle, or NULL for entire image
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the
//      description of the data in the source image file, or NULL.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromFileA(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCSTR                pSrcFile,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);

#define D3DXLoadSurfaceFromFile D3DXLoadSurfaceFromFileA


HRESULT WINAPI
    D3DXLoadSurfaceFromFileInMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);



//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromSurface:
// --------------------------
// Load surface from another surface (with color conversion)
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcSurface
//      Source surface
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcRect
//      Source rectangle, or NULL for entire surface
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromSurface(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPDIRECT3DSURFACE8    pSrcSurface,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromMemory:
// ------------------------
// Load surface from memory.
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcMemory
//      Pointer to the top-left corner of the source image in memory
//  SrcFormat
//      Pixel format of the source image.
//  SrcPitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the width of one row of cells, in bytes.
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcRect
//      Source rectangle.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  SrcPitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//-------------------------------------------------------------------------
// D3DXLoadVolumeFromVolume:
// --------------------------
// Load volume from another volume (with color conversion)
//
// Parameters:
//  pDestVolume
//      Destination volume, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestBox
//      Destination box, or NULL for entire volume
//  pSrcVolume
//      Source volume
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcBox
//      Source box, or NULL for entire volume
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadVolumeFromVolume(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPDIRECT3DVOLUME8     pSrcVolume,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


//-------------------------------------------------------------------------
// D3DXLoadVolumeFromMemory:
// ------------------------
// Load volume from memory.
//
// Parameters:
//  pDestVolume
//      Destination volume, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestBox
//      Destination box, or NULL for entire volume
//  pSrcMemory
//      Pointer to the top-left corner of the source volume in memory
//  SrcFormat
//      Pixel format of the source volume.
//  SrcRowPitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the size of one row of cells, in bytes.
//  SrcSlicePitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the size of one slice of cells, in bytes.
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcBox
//      Source box.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadVolumeFromMemory(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  SrcRowPitch,
        UINT                  SrcSlicePitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




//-------------------------------------------------------------------------
// D3DXCheckTextureRequirements:
// -----------------------------
//
// Checks texture creation parameters.  If parameters are invalid, this
// function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pWidth
//      Desired width in pixels, or NULL.  Returns corrected width.
//  pHeight
//      Desired height in pixels, or NULL.  Returns corrected height.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  Usage
//      Texture usage flags
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//  Pool
//      Memory pool to be used to create texture
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateTexture:
// ------------------
// Create an empty texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Width
//      width in pixels; must be non-zero
//  Height
//      height in pixels; must be non-zero
//  MipLevels
//      nu