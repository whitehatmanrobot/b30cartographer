(size=0; size<256; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("FILE_FLAG_SEQUENTIAL_SCAN")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)~size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("FILE_FLAG_RANDOM_ACCESS")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("FILE_FLAG_WRITE_THROUGH")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)~size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 7 meg")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<MEGABYTE*7; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Read from a write only file")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == FALSE)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        // Note, the next test ("Write to a read only file") depends on this test's file.
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); });
    TESTCASE("Write to a read only file")
        {
        // This test depends on the prevous test's ("Read from a write only file") file.
        hFile = CreateFile(lpFile1, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == FALSE)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write to closed handle")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n");
        CloseHandle(hFile);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == FALSE)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == FALSE)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    delete[] wbuffer;
    delete[] rbuffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\replacefile.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ReplaceFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the ReplaceFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::ReplaceFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReplaceFile(
      LPCTSTR lpReplacedFileName,    // file name
      LPCTSTR lpReplacementFileName, // replacement file 
      LPCTSTR lpBackupFileName,      // optional backup file
      DWORD dwReplaceFlags,          // replace options
      LPVOID lpExclude,              // reserved
      LPVOID lpReserved              // reserved
    );
    */
    xSetFunctionName(hLog, "ReplaceFile");

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\ReplaceFile_file1_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\ReplaceFile_file2_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws:\\ReplaceFile_file3_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%ws:\\ReplaceFile_bigfile_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%ws:\\ReplaceFile_thisFileDoesNotExist_%d.bla", BASE_DRIVE, ThreadID);
    unsigned i;

    // initialize system state
    CreateFilledFile(lpFile1, KILOBYTE*16);
    CreateFilledFile(lpFile2, KILOBYTE*16);
    CreateFilledFile(lpBigFile, MEGABYTE*2);
    DeleteFile(lpFakeFile);
    DeleteFile(lpFile3);


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("valid valid nul")
        {
        if(ReplaceFile(lpFile1, lpFile2, lpNull, 0, NULL, NULL) == TRUE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(!FileExists(lpFile2))
            TESTPASS(hLog, "Original file removed (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file removed (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpFile2, FALSE); });
    TESTCASE("large valid valid nul")
        {
        if(ReplaceFile(lpFile1, lpBigFile, lpNull, 0, NULL, NULL) == TRUE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(!FileExists(lpBigFile))
            TESTPASS(hLog, "Original file removed (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file removed (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpBigFile, FALSE); });
    TESTCASE("valid valid backup")
        {
        if(ReplaceFile(lpFile1, lpFile2, lpFile3, 0, NULL, NULL) == TRUE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(!FileExists(lpFile2))
            TESTPASS(hLog, "Original file removed (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file removed (ec: %ld)", GetLastError());

        if(FileExists(lpFile3))
            TESTPASS(hLog, "Backup created (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Backup created (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpFile2, FALSE); DeleteFile(lpFile3); });
    TESTCASE("large valid valid backup")
        {
        if(ReplaceFile(lpFile1, lpBigFile, lpFile3, 0, NULL, NULL) == TRUE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(!FileExists(lpBigFile))
            TESTPASS(hLog, "Original file removed (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file removed (ec: %ld)", GetLastError());

        if(FileExists(lpFile3))
            TESTPASS(hLog, "Backup created (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Backup created (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpBigFile, FALSE); DeleteFile(lpFile3); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("invalid valid nul")
        {
        if(ReplaceFile(lpFakeFile, lpFile2, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(FileExists(lpFile2))
            TESTPASS(hLog, "Original file remains (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file remains (ec: %ld)", GetLastError());

        if(!FileExists(lpFakeFile))
            TESTPASS(hLog, "Invalid file created (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Invalid file created (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFakeFile); });
    TESTCASE("valid invalid nul")
        {
        if(ReplaceFile(lpFile1, lpFakeFile, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(FileExists(lpFile1))
            TESTPASS(hLog, "Original file remains (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file remains (ec: %ld)", GetLastError());

        if(!FileExists(lpFakeFile))
            TESTPASS(hLog, "Invalid file created (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Invalid file created (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFakeFile); });
    TESTCASE("newfile valid null w/ extra params")
        {
        if(ReplaceFile(lpFile1, lpFile2, lpNull, 0, hBogus, hBogus) == FALSE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpFile2, FALSE); });



    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    xSetFunctionName(hLog, "DeleteFile");
    TESTCASE("Removing lpFile1")
        {
        if(DeleteFile(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing lpFile2")
        {
        if(DeleteFile(lpFile2) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing lpBigFile")
        {
        if(DeleteFile(lpBigFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\setendoffile.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SetEndOfFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the SetEndOfFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::SetEndOfFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL SetEndOfFile(
      HANDLE hFile   // handle to file
    );
    */
    xSetFunctionName(hLog, "SetEndOfFile");

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FEO01_%d.txt", BASE_DRIVE, ThreadID);
    HANDLE hFile;
    DWORD size;
    DWORD highSize;

    DWORD time = GetTickCount();



    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Empty File")
        {
        size = 0;
        CreateFilledFile(lpFile1, 0);
        hFile = FileOpenRW(lpFile1);

        if(SetEndOfFile(hFile) == TRUE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("filesize 1, End 1")
        {
        size = 1;
        CreateFilledFile(lpFile1, 1);
        hFile = FileOpenRW(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        if(SetEndOfFile(hFile) == TRUE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("filesize 1, End 0")
        {
        size = 0;
        CreateFilledFile(lpFile1, 1);
        hFile = FileOpenRW(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        if(SetEndOfFile(hFile) == TRUE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("filesize 6meg, End 3meg")
        {
        size = MEGABYTE*3;
        CreateFilledFile(lpFile1, MEGABYTE*6);
        hFile = FileOpenRW(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        if(SetEndOfFile(hFile) == TRUE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Read Only file")
        {
        size = 512;
        CreateFilledFile(lpFile1, KILOBYTE);
        hFile = FileOpen(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        if(SetEndOfFile(hFile) == FALSE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) != size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Closed Handle")
        {
        size = 512;
        CreateFilledFile(lpFile1, KILOBYTE);
        hFile = FileOpenRW(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        CloseHandle(hFile);

        if(SetEndOfFile(hFile) == FALSE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        hFile = FileOpenRW(lpFile1);

        if((highSize=GetFileSize(hFile, &highSize)) != size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\removedirectory.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    RemoveDirectory.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the RemoveDirectory API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    
*/
DWORD MUTests::RemoveDirectory_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL RemoveDirectory(
      LPCTSTR lpPathName   // directory name
    );
    */
    xSetFunctionName(hLog, "RemoveDirectory");

    char lpFile1[256];
    char lpFile2[256];
    unsigned i;


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Removing \\RemoveDirectory")
        {
        sprintf(lpFile1, "%ws:\\FRD01_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        if(RemoveDirectory(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing SubRemoveDirectory")
        {
        sprintf(lpFile1, "%ws:\\FRD02_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }

        sprintf(lpFile1, "%ws:\\FRD02_%d\\FRD03_%d", BASE_DRIVE, ThreadID, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }

        if(RemoveDirectory(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        sprintf(lpFile1, "%ws:\\FRD02_%d", BASE_DRIVE, ThreadID);
        if(RemoveDirectory(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    /*
    TESTCASE("Removing \\ RemoveDirectory2")
        {
        sprintf(lpFile1, "%ws:\\ RemoveDirectory2_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        if(RemoveDirectory(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
*/

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\readwritefileex.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ReadWriteFileEx.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"


struct CompletionState
    {
    long state;         // current state 0=write 1=read 0xff=timeout
    DWORD errorCode;    // expected error code
    DWORD size;         // size of the data to read/write
    char *variation;    // name of this test variation
    HANDLE hFile;       // handle to the file
    char* filename;     // filename
    char *rbuffer;      // read buffer
    char *wbuffer;      // write buffer
    HANDLE hLog;        // handle to the logging object
    };

static void CALLBACK CompletionFunct(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);
static void SerializeTest(HANDLE hLog, char *variation, char* filename, DWORD size, char *rbuffer, char *wbuffer);

/*

Routine Description:

    Tests the ReadFileEx / WriteFileEx APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::ReadWriteFileEx_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReadFileEx(
      HANDLE hFile,                                       // handle to file
      LPVOID lpBuffer,                                    // data buffer
      DWORD nNumberOfBytesToRead,                         // number of bytes to read
      LPOVERLAPPED lpOverlapped,                          // offset
      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine // completion routine
    );

    BOOL WriteFileEx(
      HANDLE hFile,                                       // handle to output file
      LPCVOID lpBuffer,                                   // data buffer
      DWORD nNumberOfBytesToWrite,                        // number of bytes to write
      LPOVERLAPPED lpOverlapped,                          // overlapped buffer
      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine // completion routine
    );
    */
    xSetFunctionName(hLog, "ReadFileEx / WriteFileEx");

    char *wbuffer = new char[MEGABYTE*16];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    char *rbuffer = new char[MEGABYTE*16];
    if(!rbuffer)
        {
        delete[] wbuffer;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FRWX01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\FRWX02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws:\\FRWX03_%d.txt", BASE_DRIVE, ThreadID);

    HANDLE hFile = NULL;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;

    DWORD size;

    // initialize state
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    size = sprintf(wbuffer, "");
    SerializeTest(hLog, "Read/Write 0 bytes", lpFile1, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "1");
    SerializeTest(hLog, "Read/Write 1 byte", lpFile2, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, " ");
    SerializeTest(hLog, "Read/Write 1 space", lpFile3, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "69");
    SerializeTest(hLog, "Read/Write 2 bytes", lpFile1, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "xboxboxboxboxbox");
    SerializeTest(hLog, "Read/Write 16 bytes", lpFile2, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFileEx() / WriteFileEx() API Test!\r\n");
    SerializeTest(hLog, "Read/Write short text", lpFile3, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFileEx() / WriteFileEx() API Test!\r\n\r\n"
            "The quick brown fox jumps over the lazy dog\r\n"
            "1234567890\t-=`~!@#$%^&*()_+[]}{\\|';:\"/.,<>?\r\n\r\n"
            "This is a story about Ranet Jeno, the wicked witch from a swamp called DC.\r\n\r\n"
            "(All persons, places, and events are fictitious and bear no resemblance to any living or deceased (past, present, or future) persons, places or events.)\r\n\r\n");
    SerializeTest(hLog, "Read/Write long text", lpFile1, size, rbuffer, wbuffer);

    for(int i=0; i<8192; i++)
        {
        size += sprintf(wbuffer+size, "Hello World.\r\n\r\nThis is a ReadFileEx() / WriteFileEx() API Test!\r\n\r\n");
        }
    SerializeTest(hLog, "Read/Write really long text (0.5meg)", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<256; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write short binary (256b)", lpFile3, size, rbuffer, wbuffer);

    for(size=0; size<512; size++)
        {
        wbuffer[size] = (char)(~size);
        }
    SerializeTest(hLog, "Read/Write short binary (512b)", lpFile1, size, rbuffer, wbuffer);

    for(size=0; size<KILOBYTE*3; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write 3k", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<KILOBYTE*4; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write 4k", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<KILOBYTE*5; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write 5k", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<KILOBYTE*7; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write 7k", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<KILOBYTE*8; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write 8k", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<KILOBYTE*9; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write 9k", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<MEGABYTE*6; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write 6 meg", lpFile2, size, rbuffer, wbuffer);


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    delete[] wbuffer;
    delete[] rbuffer;

    // cleanup
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);

    return 0;
    }



static VOID CALLBACK CompletionFunct(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
    {
    // Bad pointer
    if(!lpOverlapped)
        {
        DebugPrint("OVERLAPPED struct is null (ec: %ld)", dwErrorCode);
        return;
        }

    CompletionState *testinfo = (CompletionState*)lpOverlapped->hEvent;

    // Bad pointer
    if(!testinfo)
        {
        memset(lpOverlapped, 0, sizeof(OVERLAPPED));
        delete lpOverlapped;
        DebugPrint("OVERLAPPED struct contained invalid pointer to state information (ec: %ld)", dwErrorCode);
        return;
        }

    long stateVal = InterlockedIncrement(&testinfo->state) - 1;

    // Write Callback
    if(stateVal == 0)
        {
        if(dwNumberOfBytesTransfered == testinfo->size && dwErrorCode == testinfo->errorCode)
            TESTPASS(testinfo->hLog, "WriteFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);
        else
            TESTFAIL(testinfo->hLog, "WriteFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);


        if(ReadFileEx(testinfo->hFile, testinfo->rbuffer, testinfo->size, lpOverlapped, CompletionFunct) == TRUE)
            TESTPASS(testinfo->hLog, "ReadFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(testinfo->hLog, "ReadFileEx (ec: %ld)", GetLastError());
        }

    // Read Callback
    else if(stateVal == 1)
        {
        if(dwNumberOfBytesTransfered == testinfo->size && dwErrorCode == testinfo->errorCode)
            TESTPASS(testinfo->hLog, "ReadFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);
        else
            TESTFAIL(testinfo->hLog, "ReadFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);

        if(memcmp(testinfo->rbuffer, testinfo->wbuffer, testinfo->size) == 0)
            TESTPASS(testinfo->hLog, "Write Buffer[%d] == Read Buffer[%d]", testinfo->size, dwNumberOfBytesTransfered);
        else
            TESTFAIL(testinfo->hLog, "Write Buffer[%d] != Read Buffer[%d]", testinfo->size, dwNumberOfBytesTransfered);

        CloseHandle(testinfo->hFile);
        DeleteFile(testinfo->filename);
        memset(testinfo, 0, sizeof(CompletionState));
        memset(lpOverlapped, 0, sizeof(OVERLAPPED));
        delete testinfo;
        delete lpOverlapped;
        }

    // We hit timeout before the callback - things are messed, so cleanup and bail
    else if(stateVal == 0xFF)
        {
        CloseHandle(testinfo->hFile);
        DeleteFile(testinfo->filename);
        memset(testinfo, 0, sizeof(CompletionState));
        memset(lpOverlapped, 0, sizeof(OVERLAPPED));
        delete testinfo;
        delete lpOverlapped;
        }

    // unknown state
    else
        {
        memset(lpOverlapped, 0, sizeof(OVERLAPPED));
        delete lpOverlapped;
        TESTFAIL(testinfo->hLog, "State information contained invalid state (ec: %ld)", dwErrorCode);
        return;
        }
    }



static void SerializeTest(HANDLE hLog, char *variation, char* filename, DWORD size, char *rbuffer, char *wbuffer)
    {
    CompletionState *state = new CompletionState; // gets deleted in CompletionFunct
    if(!state) return;

    OVERLAPPED *overlap = new OVERLAPPED; // gets deleted in CompletionFunct
    if(!overlap)
        {
        delete state;
        return;
        }

    // hEvent is ignored by ReadFileEx & WriteFileEx and so they allow us to pass information via this pointer
    overlap->hEvent = (HANDLE)state;
    overlap->Internal = 0;
    overlap->InternalHigh = 0;
    overlap->Offset = 0;
    overlap->OffsetHigh = 0;

    state->rbuffer = rbuffer;
    state->wbuffer = wbuffer;
    state->errorCode = 0;
    state->filename = filename;
    state->size = size;
    state->variation = variation;
    state->state = 0;
    state->hLog = hLog;

    long stateVal=0;

    TESTCASE(variation)
        {
        state->hFile = CreateFile(state->filename, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL);
        if(state->hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        DWORD dwBytesWritten;

        if(WriteFile(state->hFile, state->wbuffer, state->size, &dwBytesWritten, overlap) == TRUE)
            TESTPASS(hLog, "WriteFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "WriteFileEx (ec: %ld)", GetLastError());

        // wait for the IO Callbacks
        do
            {
            if(SleepEx(15000, true) != WAIT_IO_COMPLETION)
                {
                stateVal = InterlockedExchange(&state->state, 0xFF);
                if(stateVal < 2)
                    {
                    TESTFAIL(hLog, "Hit timeout before IO Completed (memory may leak as a result) state=%d", stateVal);
                    SleepEx(15000, true); // wait for a bit longer just to be sure
                    }
                break;
                }

            // get the current value 
            stateVal = InterlockedCompareExchange(&state->state, 0xFF, 0xFF);
            } while(stateVal < 2);
        } ENDTESTCASE;
    
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\setfilepointerex.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SetFilePointerEx.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

    If you make changes to the test cases, be sure to make similiar changes
    to the cases in SetFilePointer.cpp

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the SetFilePointerEx API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::SetFilePointerEx_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL SetFilePointerEx(
      HANDLE hFile,                    // handle to file
      LARGE_INTEGER liDistanceToMove,  // bytes to move pointer
      PLARGE_INTEGER lpNewFilePointer, // new file pointer
      DWORD dwMoveMethod               // starting point
    );
    */
    xSetFunctionName(hLog, "SetFilePointerEx");

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FFPX01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\FFPX02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws:\\FFPX03_%d.txt", BASE_DRIVE, ThreadID);

    char *stdStr = "DWORD SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);";
    DWORD size;
    DWORD wSize, rSize;
    LARGE_INTEGER i64;
    HANDLE hFile = NULL;
    DWORD seek = 0;

    char *wbuffer = new char[MEGABYTE*10];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    char *rbuffer = new char[MEGABYTE*10];
    if(!rbuffer)
        {
        delete[] wbuffer;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }

    hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Seek(0 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(0), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 0)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(0), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 0)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(1 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(1), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 1)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(1), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 1)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(10 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(10), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 10)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(10), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 10)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(300 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(300), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 300)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(300), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 300)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(-200 FILE_END) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-200), &i64, FILE_END) == TRUE && i64.QuadPart == 100+strlen(stdStr))
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-200), &i64, FILE_END) == TRUE && i64.QuadPart == 100+strlen(stdStr))
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    CloseHandle(hFile);
    DeleteFile(lpFile1);

    delete[] wbuffer;
    delete[] rbuffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\remotduke\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\remotduke\dp.h ===
#ifndef __dp_h_
#define __dp_h_


#include "dukeprod.h"

BOXSTATUS  LeftTriggerTest(BOXSTATUS newstatus);
BOXSTATUS RightTriggerTest(BOXSTATUS newstatus);
BOXSTATUS LeftThumbStick1Test(BOXSTATUS newstatus);
BOXSTATUS RightThumbStick1Test(BOXSTATUS newstatus);
BOXSTATUS DPadTest(BOXSTATUS newstatus);
BOXSTATUS StartSelectTest(BOXSTATUS newstatus);
BOXSTATUS ButtonTest(BOXSTATUS newstatus);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "stdafx.h"
#include <xbox.h>
#include <xlog.h>

#include "usbmanager.h"
#include "commontest.h"

namespace MUTests {

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
    };


USBManager::USBManager()
    {
    hotplugs = true;
    DWORD insertions, insertions2;
    unsigned i, j;
    unsigned port, slot;

    pollingParameters.fAutoPoll = 1;
    pollingParameters.fInterruptOut = 0;
    pollingParameters.ReservedMBZ1 = 0;
    pollingParameters.bInputInterval = 8;  
    pollingParameters.bOutputInterval = 8;
    pollingParameters.ReservedMBZ2 = 0;

    // make sure the usb schema has not changed on us
    ASSERT(ARRAYSIZE(XIDMasks) == XGetPortCount());

    // initialize
    for(i=0; i<XGetPortCount(); i++)
        {
        for(j=0; j<SLOT_MAX; j++)
            {
            devices[i][j] = NULL;
            packetNum[i][j] = 1234;
            }
        }

    // look for game pads
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    //DebugPrint("USBMGR: XID: - %X\n", insertions);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XID %d\n", i);
            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
            }
        }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    //DebugPrint("USBMGR: XMU: - %X\n", insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XMU %d (ec: %lu)\n", port, err);
            devices[i][slot] = new DeviceMU(port, slot);
            }
        }

    
    // check for hawks
    insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if(insertions == insertions2)
        {
        //DebugPrint("USBMGR: OK!\n");
        }
    else
        {
        //DebugPrint("USBMGR: CRAP!\n");
        }
    //DebugPrint("USBMGR: XHAWK: %X %X\n", removals, insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[port][slot] = new DeviceHawk(port, slot);
            }
        }
    }


USBManager::~USBManager()
    {
    unsigned i, j;

    for(i=0; i<XGetPortCount(); i++)
        {
        for(j=0; j<SLOT_MAX; j++)
            {
            if(devices[i][j] != NULL)
                {
                if(XDEVICE_TYPE_GAMEPAD == devices[i][j]->type) delete (DeviceDuke*)devices[i][j];
                else if(XDEVICE_TYPE_MEMORY_UNIT == devices[i][j]->type) delete (DeviceMU*)devices[i][j];
                else if(XDEVICE_TYPE_VOICE_MICROPHONE == devices[i][j]->type) delete (DeviceHawk*)devices[i][j];
                devices[i][j] = NULL;
                }
            }
        }
    }


void USBManager::CheckForHotplugs(void)
    {
    DWORD addDuke, removeDuke;
    DWORD addMU, removeMU;
    DWORD addHawk, removeHawk, addHawk2, removeHawk2;
    unsigned slot, port;
    unsigned i, j;

    if(!hotplugs) return;

    // check for mu removals
    XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addMU, &removeMU);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(removeMU & XMUMasks[i])
            {
            //DebugPrint("***USBMGR: Removed XMU [%d][%d]\n", port, slot);
            delete (DeviceMU*)devices[i][slot];
            devices[i][slot] = NULL;
            }
        }

    // check for xhawk removals
    XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &addHawk, &removeHawk);
    XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &addHawk2, &removeHawk2);
    if(removeHawk == removeHawk && addHawk == addHawk2)
        {
        //DebugPrint("USBMGR: OK!\n");
        }
    else
        {
        //DebugPrint("USBMGR: CRAP!\n");
        }
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(removeHawk & XMUMasks[i])
            {
            //DebugPrint("***USBMGR: Removed HAWK [%d][%d]\n", port, slot);
            delete (DeviceHawk*)devices[port][slot];
            devices[port][slot] = NULL;
            }
        }


    // check for game controllers (insert & removal)
    XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke);
    //DebugPrint("USBMGR: XID: %X %X\n", removals, insertions);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(removeDuke & XIDMasks[i])
            {
            //DebugPrint("USBMGR: Removed XID [%d][0]\n", i);
            delete (DeviceDuke*)devices[i][0];
            devices[i][0] = NULL;
            /*
            // close any devices in slots
            if(devices[i][1] != INVALID_HANDLE_VALUE)
                {
                XUnmountMU(XMUPortFromDriveLetter((WCHAR)devices[i][1]), XMUSlotFromDriveLetter((WCHAR)devices[i][1]));
                devices[i][1] = INVALID_HANDLE_VALUE;
                }
            if(devices[i][2] != INVALID_HANDLE_VALUE)
                {
                XUnmountMU(XMUPortFromDriveLetter((WCHAR)devices[i][2]), XMUSlotFromDriveLetter((WCHAR)devices[i][2]));
                devices[i][2] = INVALID_HANDLE_VALUE;
                }
                */
            }
        if(addDuke & XIDMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XID [%d][0]\n", i);
            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
            }
        }

    // check for mu insertions
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(addMU & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XMU [%d][%d] = %wc:\\\n", port, slot, drive);
            devices[i][slot] = new DeviceMU(port, slot); 
            }
        }

    // check for xhawk insertions
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(addHawk & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[i][slot] = new DeviceHawk(port, slot); 
            }
        }
    }


void USBManager::ProcessInput(void)
    {
    CheckForHotplugs();
    for(unsigned i=0; i<XGetPortCount(); i++)
        {
        DumpControllerState(INVALID_SOCKET, i, 0);
        }
    }


void USBManager::ProcessInput(SOCKET sock)
    {
    CheckForHotplugs();
    for(unsigned i=0; i<XGetPortCount(); i++)
        {
        DumpControllerState(sock, i, 0);
        }
    }


void USBManager::DumpControllerState(SOCKET sock, unsigned port, unsigned slot)
    {
    }

} // namespace MUTests
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\remotduke\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, 0) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\utils.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif

namespace MUTests {

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    char* - pointer to Unicode string

Note:

    Because a bunch of Unicode functions expect a char string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
char* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((ULONG_PTR)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (char*)str;
    }


/*****************************************************************************

Routine Description:

    Unicode2AnsiHack

    In-place Pseudo Unicode to Ansi (wide char to char) conversion.

Arguments:

    IN unsigned short* str - wide char string to convert to char string

Return Value:

    char* - pointer to ANSI string

*****************************************************************************/
char* Unicode2AnsiHack(unsigned short *str)
    {
    if(!str) return NULL;
    char *str2 = (char*)str;

    size_t len = wcslen(str)+1;
    for(size_t i=0; i<len; i++)
        {
        str2[i] = str2[i*2];
        }

    return (char*)str;
    }

/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    char *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
bool FileExists(const char *filename)
    {
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    bool retval = false;

    hFind = FindFirstFile(filename, &FindFileData);

    if(hFind != INVALID_HANDLE_VALUE)
        {
        retval = true;
        }
    FindClose(hFind);

    return retval;
    }


/*

Routine Description:

    Creates a new file and fills it with x bytes of garbage

Arguments:

    char *filename - the name of the file to create
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD CreateFilledFile(const char *filename, DWORD size /*=16384*/)
    {
    HANDLE file = CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    size = FillFile(file, size);

    CloseHandle(file);

    return size;
    return size;
    }




/*

Routine Description:

    Fills an opened file with x bytes of garbage

Arguments:

    HANDLE hFile - handle to opened file
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD FillFile(HANDLE hFile, DWORD size)
    {
    char *error = NULL;
    char w = 'X';
    DWORD wsize = sizeof(w);
    DWORD errCode = 0;

    do
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            error = "unable to create/open file";
            errCode = GetLastError();
            break;
            }

        if(size == 0) break;

        if(SetFilePointer(hFile, size-1, NULL, FILE_BEGIN) != size-1)
            {
            error = "unable to size file";
            errCode = GetLastError();
            break;
            }

        if(WriteFile(hFile, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = "unable to write last byte";
            errCode = GetLastError();
            break;
            }
        } while(0);

    FlushFileBuffers(hFile);

    if(error)
        {
        DebugPrint("MUTESTS: FillFile(%ld) - %ws (ec: %d)\n", size, error, errCode);
        size = 0;
        }

    return size;
    }

/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpen(const char *filename)
    {
    return CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }




/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpenRW(const char *filename)
    {
    return CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }




/*

Routine Description:

    Generates a FILETIME structure from the date components by calling 
    SystemTimeToFileTime

Arguments:

    LPFILETIME fileTime - pointer to the FILETIME struct to populate with the date
    WORD year
    WORD month
    WORD day
    WORD hour
    WORD min
    WORD sec
    WORD msec

Return Value:

    BOOL - returns the result from SystemTimeToFileTime

*/
BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec)
    {
    SYSTEMTIME sysTime;

    sysTime.wYear = year;
    sysTime.wMonth = month;
    sysTime.wDay = day;
    sysTime.wHour = hour;
    sysTime.wMinute = min;
    sysTime.wSecond = sec;
    sysTime.wMilliseconds = msec;

    return SystemTimeToFileTime(&sysTime, fileTime);
    }

/*

Routine Description:


Arguments:

    drive - Drive to fill up, it should be in the form 
        C:\
        D:\
        etc.
    lpFile - This function will populate buffer with the name of the file created

Return Value:

    DWORD return code from GetLastError in the event of a problem

*/
DWORD FillHDPartition(const char *drive, char *lpFile)
    {
    if(!drive || !lpFile) return ERROR_INVALID_PARAMETER;

    DWORD error = 0;
    char w = 'X';
    DWORD wsize = sizeof(w);
    LARGE_INTEGER distance;
    LARGE_INTEGER size;
    ULARGE_INTEGER available;
    ULARGE_INTEGER total;
    ULARGE_INTEGER free;

    DebugPrint("MUTESTS: Filling HD Partition: %s...\n", drive);

    sprintf(lpFile, "%sFHD.dmp", drive, GetCurrentThreadId());

    HANDLE file = CreateFile(lpFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
    if(file == INVALID_HANDLE_VALUE)
        {
        return GetLastError();
        }

    // Get the disk space free
    GetDiskFreeSpaceEx(drive, &available, &total, &free);
    distance.QuadPart = (__int64)available.QuadPart - 256;
    size.QuadPart = 0;

    // Do a test write
    if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
        {
        error = GetLastError();
        CloseHandle(file);
        return error;
        }

    // write as big as a file as possible
    do
        {
        distance.QuadPart -= 256;
        if(distance.QuadPart < 0) break;

        if(SetFilePointerEx(file, distance, &size, FILE_BEGIN) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("SetFilePointerEx (ec: %lu)\n", error);
            }
        else if(size.QuadPart != distance.QuadPart)
            {
            error = 99;
            //DebugPrint("SetFilePointerEx size != dist\n");
            }
        else if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("WriteFile (ec: %lu)\n", error);
            }
        else
            {
            error = 0;
            }

        } while(error);

    // clean up
    if(FlushFileBuffers(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("FlushFileBuffers (ec: %lu)\n", error);
        }
    if(CloseHandle(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("CloseHandle (ec: %lu)\n", error);
        }

    DebugPrint("MUTESTS: Filled  HD Partition. %ws(%I64d)\n", lpFile, size.QuadPart);

    return error;
    }

/*

Routine Description:

    Writes system resource usage information to the specified log file 
    and/or to the debugger.

    Be sure to include extern "C" { "ntos.h" } to use MmQueryStatistics

    MM_STATISTICS:
        ULONG TotalPhysicalPages;
        ULONG AvailablePages;
        ULONG VirtualMemoryBytesCommitted;
        ULONG VirtualMemoryBytesReserved;
        ULONG CachePagesCommitted;
        ULONG PoolPagesCommitted;
        ULONG StackPagesCommitted;
        ULONG ImagePagesCommitted;

Arguments:

    HANDLE hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    bool debugger - true sends memory data to the debugger

Return Value:

    None

*/
void FlushDiskCache(void);

void LogResourceStatus(HANDLE hLog, bool debugger)
    {
    const DWORD pageSize = 4096;
    MM_STATISTICS mmStats;
    PS_STATISTICS psStats;

    // initialize the stat info
    memset(&mmStats, 0, sizeof(MM_STATISTICS));
    mmStats.Length = sizeof(MM_STATISTICS);
    memset(&psStats, 0, sizeof(PS_STATISTICS));
    psStats.Length = sizeof(PS_STATISTICS);

    FlushDiskCache();

    // gather all the data
    MmQueryStatistics(&mmStats);
    PsQueryStatistics(&psStats);

    // display/write the data
    if(hLog)
        {
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        xLog(hLog, XLL_INFO, "   Total:     %lu", mmStats.TotalPhysicalPages*pageSize);
        xLog(hLog, XLL_INFO, "   Available: %lu", mmStats.AvailablePages*pageSize);
        xLog(hLog, XLL_INFO, "   Cache:     %lu", mmStats.CachePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Pool:      %lu", mmStats.PoolPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Stack:     %lu", mmStats.StackPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Image:     %lu", mmStats.ImagePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Handles:   %lu", psStats.HandleCount);
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        }
    if(debugger)
        {
        DebugPrint("MEM: Available=%lu, Cache=%lu, Pool=%lu, Stack=%lu, Image=%lu, Handles=%lu\n", mmStats.AvailablePages*pageSize, mmStats.CachePagesCommitted*pageSize, mmStats.PoolPagesCommitted*pageSize, mmStats.StackPagesCommitted*pageSize, mmStats.ImagePagesCommitted*pageSize, psStats.HandleCount);
        }
    }

void FlushVolume(char *volume)
    {
    HANDLE hFile = CreateFile(volume, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        DebugPrint("MEM: FlushError: %lu, 0x%x\n", GetLastError(), GetLastError());
    FlushFileBuffers(hFile);
    CloseHandle(hFile);
    }

/*

Routine Description:

    This routine will flush the disk cache

Arguments:

    None

Return Value:

    No return value

*/
void FlushDiskCache(void)
    {
    ULONG Volume, Disk;
    HANDLE Handle;
    NTSTATUS Status;
    char VolumeBuffer[MAX_PATH];
    OBJECT_STRING VolumeString;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;

    for(Disk=0; Disk<2; Disk++)
        {
        for(Volume=1; Volume<4; Volume++)
            {
            sprintf(VolumeBuffer, "\\Device\\Harddisk%d\\Partition%d", Disk, Volume);

            RtlInitObjectString(&VolumeString, VolumeBuffer);

            InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

            Status = NtCreateFile(&Handle, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);

            if(!NT_SUCCESS(Status)) continue;

            Status = NtFlushBuffersFile(Handle, &IoStatusBlock);
            NtClose(Handle);
            }
        }
    }

} // namespace MUTests
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_

#include "stdafx.h"
#include <xbox.h>

namespace MUTests {


enum {
    SLOT_CONTROLLER,
    SLOT_TOP,
    SLOT_BOTTOM,
    SLOT_MAX
    };


class USBDevice
    {
    public:
        PXPP_DEVICE_TYPE type; // XDEVICE type

    public:
        USBDevice() { type = NULL; }
        ~USBDevice() { type = NULL; }

    public:
        virtual void Insert(unsigned port, unsigned slot) = 0;
        virtual void Remove(void) = 0;
    };

class DeviceDuke : public USBDevice
    {
    public:
        HANDLE duke;
        XINPUT_POLLING_PARAMETERS *pollingParameters;

    public:
        DeviceDuke() { type = XDEVICE_TYPE_GAMEPAD; pollingParameters = NULL; duke = NULL; }
        DeviceDuke(unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p) { type = XDEVICE_TYPE_GAMEPAD; pollingParameters = p; duke = NULL; Insert(port, slot); }
        ~DeviceDuke() { if(duke) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert duke\n");*/ duke = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters); }
        void Remove(void) { /*DebugPrint("USBDevice: Remove duke\n");*/ XInputClose(duke); duke = 0; }
    };

class DeviceMU : public USBDevice
    {
    public:
        char drive;

    public:
        DeviceMU() { type = XDEVICE_TYPE_MEMORY_UNIT; drive = 0; }
        DeviceMU(unsigned port, unsigned slot) { type = XDEVICE_TYPE_MEMORY_UNIT; drive = 0; Insert(port, slot); }
        ~DeviceMU() { if(drive) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert MU\n");*/ XMountMU(port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, &drive); }
        void Remove(void) { /*DebugPrint("USBDevice: Remove MU\n");*/ XUnmountMU(XMUPortFromDriveLetter(drive), XMUSlotFromDriveLetter(drive)); drive = 0; }
    };

class DeviceHawk : public USBDevice
    {
    public:
        XMediaObject *microphone;
        XMediaObject *headphone;

    public:
        DeviceHawk() { type = XDEVICE_TYPE_VOICE_MICROPHONE; microphone = headphone = NULL; }
        DeviceHawk(unsigned port, unsigned slot) { type = XDEVICE_TYPE_VOICE_MICROPHONE; microphone = headphone = NULL; Insert(port, slot); }
        ~DeviceHawk() { if(microphone || headphone) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert HAWK\n"); XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &microphone); XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &headphone); */}
        void Remove(void) { 
            /*DebugPrint("USBDevice: Remove HAWK\n");*/
            if(microphone) { DebugPrint("microphone->Release()..."); microphone->Release(); DebugPrint("...microphone->Release()\n"); } 
            if(headphone)  { DebugPrint("headphone->Release()...");  headphone->Release();  DebugPrint("...headphone->Release()\n"); } 
            microphone = headphone = NULL; 
            /*DebugPrint("USBDevice: Remove HAWK\n");*/ }
    };

class USBManager
    {
    public:
        bool hotplugs;
        USBDevice *devices[XGetPortCount()][SLOT_MAX];
        DWORD packetNum[XGetPortCount()][SLOT_MAX];
        XINPUT_POLLING_PARAMETERS pollingParameters;

    public:
        USBManager();
        ~USBManager();

    public:
        void DumpControllerState(SOCKET sock, unsigned port, unsigned slot);
        void ProcessInput(void);
        void ProcessInput(SOCKET sock);
        void CheckForHotplugs(void);

    };

} // namespace MUTests

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\utils.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

namespace MUTests
    {
    extern bool FileExists(const char *filename);
    extern DWORD FillFile(HANDLE hFile, DWORD size);
    extern DWORD CreateFilledFile(const char *filename, DWORD size=16384);
    extern HANDLE FileOpen(const char *filename);
    extern HANDLE FileOpenRW(const char *filename);
    extern BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec);
    extern DWORD FillHDPartition(const char *drive, char *lpFile);
    extern void LogResourceStatus(HANDLE hLog, bool debugger);

    class iLARGE_INTEGER
        {
        public: 
            __int64 value;

        public:
            iLARGE_INTEGER() { value = 0; }
            iLARGE_INTEGER(int i) { value = i; }
            iLARGE_INTEGER(DWORD i) { value = i; }
            iLARGE_INTEGER(__int64 i) { value = i; }
            iLARGE_INTEGER(const LARGE_INTEGER &i) { value = i.QuadPart; }

            operator int() {  return (int)value; }
            operator DWORD() {  return (DWORD)value; }
            operator __int64() {  return value; }
            operator LARGE_INTEGER() {  LARGE_INTEGER a; a.QuadPart=value; return a; }
        };
    } // namespace MUTests

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\remotduke\dp.cpp ===
//#define __HAMMERHEAD__
//define __TWOPASS__

#include "xtl.h"
#include "Draw.h"
//#include "Device.h"
#include "dukeprod.h"
#include "dp.h"

#define countof(_x_) (sizeof(_x_) / sizeof(_x_[0]))

#define nc 8192
typedef struct {
	float x1;
	float y1;
	float x2;
	float y2;
	BOXSTATUS stat;
} BOXSTRUCT;

typedef struct {
	signed short minx;
	signed short miny;
	signed short maxx;
	signed short maxy;
	BOOL button;
	int index;
} TPTESTSTRUCT;


#pragma warning(disable : 4035)
__int64 __inline rdtsc() {_asm {rdtsc}}
int __inline rdtsci(){_asm{rdtsc}}
BYTE  __inline rolb( BYTE narf, int r){_asm{mov  al, narf}_asm{mov ecx,r}_asm{rol  al,cl}}
WORD  __inline rolw( WORD narf, int r){_asm{mov  ax, narf}_asm{mov ecx,r}_asm{rol  ax,cl}}
DWORD __inline rold(DWORD narf, int r){_asm{mov eax, narf}_asm{mov ecx,r}_asm{rol eax,cl}}
BYTE  __inline rorb( BYTE narf, int r){_asm{mov  al, narf}_asm{mov ecx,r}_asm{ror  al,cl}}
WORD  __inline rorw( WORD narf, int r){_asm{mov  ax, narf}_asm{mov ecx,r}_asm{ror  ax,cl}}
DWORD __inline rord(DWORD narf, int r){_asm{mov eax, narf}_asm{mov ecx,r}_asm{ror eax,cl}}
#pragma warning(default : 4035)

void drawbox(BOXSTRUCT* b)
{
	DWORD col; 

	switch(b->stat)
	{
	case notyet:
		col = 0xff0000ff;
		break;
	case testme:
		col = (rdtsci()&0x8000000) ? 0xffffffff : 0xff707070;	//blink grey, .4 second intravals
		break;
	case pending:
		col = 0xffffff00;
		break;
	case failed:
		col = 0xffff0000;
		break;
	case passed:
		col = 0xff00ff00;
		break;
	}

	drBox(b->x1, b->y1, b->x2, b->y2, col);
	
}

#define DRAWALL() { for(int __i_ = 0; __i_ < numtocheck; __i_++) drawbox(&bs[__i_]); }


/*
//template: to create a new test:
	copy this, 
	name it appropriately, 
	add a reference to dukeprod.cpp
	change the locations in the bs[] array
	add test code where the // is.


BOXSTATUS TEMPLATE(BOXSTATUS newstatus)
{
	static BOXSTRUCT bs[] = {
		{10,10,11,20,notyet},
		{12,10,15,20,notyet},
		{16,10,19,20,notyet},
		{20,10,23,20,notyet},
		{24,10,25,20,notyet}
	};
	static const int numtocheck = countof(bs);

	int i;
	BOOL doh = FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		//add test-checking code here

		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}
*/

BOXSTATUS LeftTriggerTest(BOXSTATUS newstatus)
{
	static BYTE roller = 0;
	static BOXSTRUCT bs[] = {
		{20,70,23,90,notyet},
		{24,70,31,90,notyet},
		{32,70,39,90,notyet},
		{40,70,47,90,notyet},
		{48,70,51,90,notyet},
		{24,62,28,66,notyet}
	};

	static const int numtocheck = countof(bs);

	BYTE data = gData->bAnalogButtons[GPL];
	int i;
	BOOL doh = FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		roller = 0;
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data == 0)	
			bs[0].stat = passed;
		bs[1].stat = passed;
		bs[2].stat = passed;
		bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		if(bs[4].stat == passed) {
			if(data == 0 || bs[5].stat == passed) {		//retract!
				bs[5].stat = passed;
			} else {
				bs[5].stat = pending;
			}
		}
#else 
		if(data == 0)	
			bs[0].stat = passed;
		if(data > 0x00 && data <= 0x55)		
			bs[1].stat = passed;
		if(data > 0x55 && data <= 0xAA)		
			bs[2].stat = passed;
		if(data > 0xAA && data <  0xff)
			bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		roller |= (rolb(data, 1) ^ data);
		if(roller == 0xff) {
			if(bs[4].stat == passed) {
				if(data == 0 || bs[5].stat == passed) {	//retract!
					bs[5].stat = passed;
				} else {
					bs[5].stat = pending;
				}
			}
		}
#endif

		DRAWALL();
		drPrintf(0,0,L"Left Trigger: %02hx", data);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS RightTriggerTest(BOXSTATUS newstatus)
{
	static BYTE roller = 0;
	static BOXSTRUCT bs[] = {
		{520,70,523,90,notyet},
		{524,70,531,90,notyet},
		{532,70,539,90,notyet},
		{540,70,547,90,notyet},
		{548,70,551,90,notyet},
		{524,62,528,66,notyet}
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	BYTE data = gData->bAnalogButtons[GPR];
	int i;
	BOOL doh = FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		roller = 0;
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data == 0)	
			bs[0].stat = passed;
		bs[1].stat = passed;
		bs[2].stat = passed;
		bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		if(bs[4].stat == passed) {
			if(data == 0 || bs[5].stat == passed) {		//retract!
				bs[5].stat = passed;
			} else {
				bs[5].stat = pending;
			}
		}
#else 
		if(data == 0)	
			bs[0].stat = passed;
		if(data > 0x00 && data <= 0x55)		
			bs[1].stat = passed;
		if(data > 0x55 && data <= 0xAA)		
			bs[2].stat = passed;
		if(data > 0xAA && data <  0xff)
			bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		roller |= (rolb(data, 1) ^ data);
		if(roller == 0xff) {
			if(bs[4].stat == passed) {
				if(data == 0 || bs[5].stat == passed) {	//retract!
					bs[5].stat = passed;
				} else {								
					bs[5].stat = pending;
				}
			}
		}
#endif
		DRAWALL();
		drPrintf(0,0,L"Right Trigger: %02hx", data);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}



BOXSTATUS LeftThumbStick1Test(BOXSTATUS newstatus)
{
	static TPTESTSTRUCT tp[] = {				//in-order checkoff
		{   -nc,   -nc,    nc,    nc,0, 9},
		{-16000,-16000, 16000, 16000,0, 4},

		{-16000, 16001, 16000, 32767,0, 1},
		{-32768, 16001,-16001, 32767,0, 0},
		{-32768,-16000,-16001, 16000,0, 3},
		{-32768,-32768,-16001,-16001,0, 6},
		{-16000,-32768, 16000,-16001,0, 7},
		{ 16001,-32768, 32767,-16001,0, 8},
		{ 16001,-16000, 32767, 16000,0, 5},
		{ 16001, 16001, 32767, 32767,0, 2},

#ifdef __TWOPASS__
		{-16000, 16001, 16000, 32767,1, 1},
		{-32768, 16001,-16001, 32767,1, 0},
		{-32768,-16000,-16001, 16000,1, 3},
		{-32768,-32768,-16001,-16001,1, 6},
		{-16000,-32768, 16000,-16001,1, 7},
		{ 16001,-32768, 32767,-16001,1, 8},
		{ 16001,-16000, 32767, 16000,1, 5},
		{ 16001, 16001, 32767, 32767,1, 2},

		{-16000,-16000, 16000, 16000,1, 4},
#endif
		//{     0,     0,     0,     0,1, 9},
		{   -nc,   -nc,    nc,    nc, 1, 9},
		{   -nc,   -nc,    nc,    nc, 0, 9}
		//{     0,     0,     0,     0,0, 9}
	};

	/*
//#pragma warning (disable : 4309; disable : 4305)//either this, or (short)... ugh.
	static TPTESTSTRUCT tp2[] = {					//any-order checkoff
		{(short)0x8000,(short)0x8000,(short)0x8000,(short)0x7fff,0,10},
		{(short)0x8001,(short)0x8000,(short)0xa000,(short)0x7fff,0,11},
		{(short)0xa001,(short)0x8000,(short)0xc000,(short)0x7fff,0,12},
		{(short)0xc001,(short)0x8000,(short)0xe000,(short)0x7fff,0,13},
		{(short)0xe001,(short)0x8000,(short)0xffff,(short)0x7fff,0,14},
		{(short)0x0000,(short)0x8000,(short)0x0000,(short)0x7fff,0,15},
		{(short)0x0001,(short)0x8000,(short)0x2000,(short)0x7fff,0,16},
		{(short)0x2001,(short)0x8000,(short)0x4000,(short)0x7fff,0,17},
		{(short)0x4001,(short)0x8000,(short)0x6000,(short)0x7fff,0,18},
		{(short)0x6001,(short)0x8000,(short)0x7ffe,(short)0x7fff,0,19},
		{(short)0x7fff,(short)0x8000,(short)0x7fff,(short)0x7fff,0,20},

		{(short)0x8000,(short)0x8000,(short)0x7fff,(short)0x8000,0,21},
		{(short)0x8000,(short)0x8001,(short)0x7fff,(short)0xa000,0,22},
		{(short)0x8000,(short)0xa001,(short)0x7fff,(short)0xc000,0,23},
		{(short)0x8000,(short)0xc001,(short)0x7fff,(short)0xe000,0,24},
		{(short)0x8000,(short)0xe001,(short)0x7fff,(short)0xffff,0,25},
		{(short)0x8000,(short)0x0000,(short)0x7fff,(short)0x0000,0,26},
		{(short)0x8000,(short)0x0001,(short)0x7fff,(short)0x2000,0,27},
		{(short)0x8000,(short)0x2001,(short)0x7fff,(short)0x4000,0,28},
		{(short)0x8000,(short)0x4001,(short)0x7fff,(short)0x6000,0,29},
		{(short)0x8000,(short)0x6001,(short)0x7fff,(short)0x7ffe,0,30},
		{(short)0x8000,(short)0x700f,(short)0x7fff,(short)0x7fff,0,31}
	};
//#pragma warning(default : 4309; default : 4305)
*/

	static BOXSTRUCT bs[] = {
		{40,160,59,179,notyet},				//0
		{60,160,79,179,notyet},				//1
		{80,160,99,179,notyet},
		{40,180,59,199,notyet},				//3	
		{60,180,79,199,notyet},				//4
		{80,180,99,199,notyet},
		{40,200,59,219,notyet},				//6
		{60,200,79,219,notyet},
		{80,200,99,219,notyet},	

		{67,187,73,193,notyet},	//centered	//9
/*
		{42,150,46,154,notyet},	//   0x80	//10
		{47,150,51,154,notyet},	//to 0xa0
		{52,150,56,154,notyet},	//to 0xc0
		{57,150,61,154,notyet},	//to 0xe0
		{62,150,66,154,notyet},	//to 0xff
		{67,150,71,154,notyet},	//   0x00
		{72,150,76,154,notyet},	//to 0x20
		{77,150,81,154,notyet},	//to 0x40
		{82,150,86,154,notyet},	//to 0x60
		{87,150,91,154,notyet},	//to 0x7e
		{92,150,96,154,notyet},	//   0x7f	//20

		{105,212,109,216,notyet},	//   0x7f	//31
		{105,207,109,211,notyet},	//to 0x7e
		{105,202,109,206,notyet},	//to 0x60
		{105,197,109,201,notyet},	//to 0x40
		{105,192,109,196,notyet},	//to 0x20
		{105,187,109,191,notyet},	//   0x00
		{105,182,109,186,notyet},	//to 0xff
		{105,177,109,181,notyet},	//to 0xe0
		{105,172,109,176,notyet},	//to 0xc0
		{105,167,109,171,notyet},	//to 0xa0
		{105,162,109,166,notyet},	//   0x80	//21
*/
		{110,177,126,193,notyet}    //button	//32
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	BOOL doh = FALSE;
	static int c = 0;

	signed short x = gData->sThumbLX;
	signed short y = gData->sThumbLY;
	BOOL bp = (gData->wButtons & XINPUT_GAMEPAD_LEFT_THUMB) ? TRUE : FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		if(c >= sizeof(tp) / sizeof(tp[0])) {
			bs[sizeof(bs)/sizeof(bs[0])-1].stat = passed;
		} else {
			if(x > tp[c].maxx || x < tp[c].minx || 
				y > tp[c].maxy || y < tp[c].miny ||
				bp != tp[c].button || ((tp[c].maxx | tp[c].minx | tp[c].maxy | tp[c].miny) && (!(x | y))) )
			{
				bs[tp[c].index].stat = testme;
				if(c!=(numtocheck-2)) bs[sizeof(bs)/sizeof(bs[0])-1].stat = tp[c].button ? testme : pending;
				else bs[sizeof(bs)/sizeof(bs[0])-1].stat=pending;
			} else {
				for(i = c + 1; i < sizeof(tp) / sizeof(tp[0]); i++)
				{
					if(tp[i].index == tp[c].index) {
						bs[tp[c].index].stat = pending;
						goto notdone;
					}
				}
				bs[tp[c].index].stat = passed;
notdone:

//				bs[tp[c].index].stat = tp[c].button ? passed : pending;
				c++;
			}
		}

/*
		for(i = 0; i < sizeof(tp2) / sizeof(tp2[0]); i++)
		{
			if(x > tp2[i].maxx || x < tp2[i].minx ||
				y > tp2[i].maxy || y < tp2[i].miny)
			{
				if(bs[tp2[i].index].stat != passed) bs[tp2[i].index].stat = testme;
			} else {
				bs[tp2[i].index].stat = passed;
			}
		}
*/

		::drPrintf(0,0,L"Left Thumb-Stick: X: %6hd   Y: %6hd  B: %s", 
			x, y, bp ? L"TRUE" : L"FALSE");
		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS DPadTest(BOXSTATUS newstatus)
{
	static struct {
		BYTE d[4];
	} bd[] = {
		{1,0,0,0},
		{1,0,1,0},
		{0,0,1,0},
		{0,1,1,0},
		{0,1,0,0},
		{0,1,0,1},
		{0,0,0,1},
		{1,0,0,1},
		{0,0,0,0}
	};
	static BOXSTRUCT bs[] = {
		{115,335,205,425,notyet},	//all?
		{150,340,170,360,notyet},	//up
		{120,340,140,360,notyet},	//upleft
		{120,370,140,390,notyet},	//left
		{120,400,140,420,notyet},	//downleft
		{150,400,170,420,notyet},	//down
		{180,400,200,420,notyet},	//downright
		{180,370,200,390,notyet},	//right
		{180,340,200,360,notyet},	//upright
		{150,370,170,390,notyet} 	//centered
	};
	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	static int c = 0;
	BOOL doh = FALSE;
	BYTE data[] = {
		gData->wButtons & XINPUT_GAMEPAD_DPAD_UP    ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_DOWN  ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_LEFT  ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ? 1 : 0
	};


	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 1;
		return notyet;
	case testme:
		for(i = 1; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(doh) {
			goto doh;
		}

		if(bs[0].stat == failed) {
			return failed;
		}

		return passed;
doh:
		if((data[0] && data[1]) || (data[2] && data[3])) {
			bs[0].stat = failed;
		}

		for (i = 0; i < 4; i++)	{
			if(data[i] != bd[c-1].d[i]) {
				bs[c].stat = testme;
				goto doh2;
			}
		}
		bs[c].stat = passed;
		c++;

doh2:

		DRAWALL();
		drPrintf(0,0,L"Up: %d  Down: %d  Left: %d  Right: %d",data[0],data[1],data[2],data[3]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}


BOXSTATUS StartSelectTest(BOXSTATUS newstatus)
{
	static BOXSTRUCT bs[] = {
		{240,400,250,410,notyet},
		{280,400,290,410,notyet}
	};
	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);
	static int c = 0;
	int i;
	BOOL doh = TRUE;
	BYTE data[] = {
		gData->wButtons & XINPUT_GAMEPAD_BACK     ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_START    ? 1 : 0,
	};

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		switch (c) {
		case 0:
			if(data[0] == 0 || data[1] == 1) {
				bs[0].stat = testme;
			} else {
				bs[0].stat = pending;
				c++;
			}
			break;
		case 1:
			if(data[0] == 0) {
				bs[0].stat = passed;
				bs[1].stat = testme;
				c++;
			}
			break;
		case 2:
			if(data[0] == 1 || data[1] == 0) {
				bs[1].stat = testme;
			} else {
				bs[1].stat = pending;
				c++;
			}
			break;
		case 3:
			if(data[1] == 0) {
				bs[1].stat = passed;
				return passed;
			}
			break;
		}

		DRAWALL();
		drPrintf(0,0,L"Start: %d   Back: %d", data[0], data[1]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}


BOXSTATUS RightThumbStick1Test(BOXSTATUS newstatus)
{
	static TPTESTSTRUCT tp[] = {				//in-order checkoff
		{     -nc,     -nc,     nc,     nc,0, 9},
		{-16000, -16000,  16000,  16000,0, 4},

		{-16000, 16001, 16000, 32767,0, 1},
		{-32768, 16001,-16001, 32767,0, 0},
		{-32768,-16000,-16001, 16000,0, 3},
		{-32768,-32768,-16001,-16001,0, 6},
		{-16000,-32768, 16000,-16001,0, 7},
		{ 16001,-32768, 32767,-16001,0, 8},
		{ 16001,-16000, 32767, 16000,0, 5},
		{ 16001, 16001, 32767, 32767,0, 2},

#ifdef __TWOPASS__
		{-16000, 16001, 16000, 32767,1, 1},
		{-32768, 16001,-16001, 32767,1, 0},
		{-32768,-16000,-16001, 16000,1, 3},
		{-32768,-32768,-16001,-16001,1, 6},
		{-16000,-32768, 16000,-16001,1, 7},
		{ 16001,-32768, 32767,-16001,1, 8},
		{ 16001,-16000, 32767, 16000,1, 5},
		{ 16001, 16001, 32767, 32767,1, 2},

		{ -16000, -16000,  16000,  16000,1, 4},
#endif
		{   -nc,   -nc,    nc,    nc,1, 9},
		{   -nc,   -nc,    nc,    nc,0, 9}
		
		//{     0,     0,     0,     0,1, 9},
		//{     0,     0,     0,     0,0, 9}
	};

	/*
//#pragma warning (disable : 4309; disable : 4305)//either this, or (short)... ugh.
	static TPTESTSTRUCT tp2[] = {					//any-order checkoff
		{(short)0x8000,(short)0x8000,(short)0x8000,(short)0x7fff,0,10},
		{(short)0x8001,(short)0x8000,(short)0xa000,(short)0x7fff,0,11},
		{(short)0xa001,(short)0x8000,(short)0xc000,(short)0x7fff,0,12},
		{(short)0xc001,(short)0x8000,(short)0xe000,(short)0x7fff,0,13},
		{(short)0xe001,(short)0x8000,(short)0xffff,(short)0x7fff,0,14},
		{(short)0x0000,(short)0x8000,(short)0x0000,(short)0x7fff,0,15},
		{(short)0x0001,(short)0x8000,(short)0x2000,(short)0x7fff,0,16},
		{(short)0x2001,(short)0x8000,(short)0x4000,(short)0x7fff,0,17},
		{(short)0x4001,(short)0x8000,(short)0x6000,(short)0x7fff,0,18},
		{(short)0x6001,(short)0x8000,(short)0x7ffe,(short)0x7fff,0,19},
		{(short)0x7fff,(short)0x8000,(short)0x7fff,(short)0x7fff,0,20},

		{(short)0x8000,(short)0x8000,(short)0x7fff,(short)0x8000,0,21},
		{(short)0x8000,(short)0x8001,(short)0x7fff,(short)0xa000,0,22},
		{(short)0x8000,(short)0xa001,(short)0x7fff,(short)0xc000,0,23},
		{(short)0x8000,(short)0xc001,(short)0x7fff,(short)0xe000,0,24},
		{(short)0x8000,(short)0xe001,(short)0x7fff,(short)0xffff,0,25},
		{(short)0x8000,(short)0x0000,(short)0x7fff,(short)0x0000,0,26},
		{(short)0x8000,(short)0x0001,(short)0x7fff,(short)0x2000,0,27},
		{(short)0x8000,(short)0x2001,(short)0x7fff,(short)0x4000,0,28},
		{(short)0x8000,(short)0x4001,(short)0x7fff,(short)0x6000,0,29},
		{(short)0x8000,(short)0x6001,(short)0x7fff,(short)0x7ffe,0,30},
		{(short)0x8000,(short)0x700f,(short)0x7fff,(short)0x7fff,0,31}
	};
//#pragma warning(default : 4309; default : 4305)
*/

	static BOXSTRUCT bs[] = {
		{340,360,359,379,notyet},				//0
		{360,360,379,379,notyet},				//1
		{380,360,399,379,notyet},
		{340,380,359,399,notyet},				//3	
		{360,380,379,399,notyet},				//4
		{380,380,399,399,notyet},
		{340,400,359,419,notyet},				//6
		{360,400,379,419,notyet},
		{380,400,399,419,notyet},	
		{367,387,373,393,notyet},	//centered	//9
/*
		{342,350,346,354,notyet},	//   0x80	//10
		{347,350,351,354,notyet},	//to 0xa0
		{352,350,356,354,notyet},	//to 0xc0
		{357,350,361,354,notyet},	//to 0xe0
		{362,350,366,354,notyet},	//to 0xff
		{367,350,371,354,notyet},	//   0x00
		{372,350,376,354,notyet},	//to 0x20
		{377,350,381,354,notyet},	//to 0x40
		{382,350,386,354,notyet},	//to 0x60
		{387,350,391,354,notyet},	//to 0x7e
		{392,350,396,354,notyet},	//   0x7f	//20

		{405,412,409,416,notyet},	//   0x7f	//31
		{405,407,409,411,notyet},	//to 0x7e
		{405,402,409,406,notyet},	//to 0x60
		{405,397,409,401,notyet},	//to 0x40
		{405,392,409,396,notyet},	//to 0x20
		{405,387,409,391,notyet},	//   0x00
		{405,382,409,386,notyet},	//to 0xff
		{405,377,409,381,notyet},	//to 0xe0
		{405,372,409,376,notyet},	//to 0xc0
		{405,367,409,371,notyet},	//to 0xa0
		{405,362,409,366,notyet},	//   0x80	//21
		*/

		{410,377,426,393,notyet}    //button	//32
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	BOOL doh = FALSE;
	static int c = 0;

	signed short x = gData->sThumbRX;
	signed short y = gData->sThumbRY;
	BOOL bp = (gData->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB) ? TRUE : FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
//				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		if(c >= sizeof(tp) / sizeof(tp[0])) {
			bs[sizeof(bs)/sizeof(bs[0])-1].stat = passed;
		} else {
			if(x > tp[c].maxx || x < tp[c].minx || 
				y > tp[c].maxy || y < tp[c].miny ||
				bp != tp[c].button || ((tp[c].maxx | tp[c].minx | tp[c].maxy | tp[c].miny) && (!(x | y))) )
			{
				bs[tp[c].index].stat = testme;
				if(c!=(numtocheck-2)) bs[sizeof(bs)/sizeof(bs[0])-1].stat = tp[c].button ? testme : pending;
				else bs[sizeof(bs)/sizeof(bs[0])-1].stat=pending;
			} else {
				for(i = c + 1; i < sizeof(tp) / sizeof(tp[0]); i++)
				{
					if(tp[i].index == tp[c].index) {
						bs[tp[c].index].stat = pending;
						goto notdone;
					}
				}
				bs[tp[c].index].stat = passed;
notdone:

//				bs[tp[c].index].stat = tp[c].button ? passed : pending;
				c++;
			}
		}

/*
		for(i = 0; i < sizeof(tp2) / sizeof(tp2[0]); i++)
		{
			if(x > tp2[i].maxx || x < tp2[i].minx ||
				y > tp2[i].maxy || y < tp2[i].miny)
			{
				if(bs[tp2[i].index].stat != passed) bs[tp2[i].index].stat = testme;
			} else {
				bs[tp2[i].index].stat = passed;
			}
		}
*/

		::drPrintf(0,0,L"Right Thumb-Stick: X: %6hd   Y: %6hd  B: %s", 
			x, y, bp ? L"TRUE" : L"FALSE");
		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS ButtonTest(BOXSTATUS newstatus)
{
	static BOXSTRUCT bs[] = {
		{410,210,420,212,notyet},
		{410,212,420,216,notyet},
		{410,216,420,220,notyet},
		{410,220,420,224,notyet},
		{410,224,420,228,notyet},
		{424,210,428,228,notyet},

		{450,210,460,212,notyet},
		{450,212,460,216,notyet},
		{450,216,460,220,notyet},
		{450,220,460,224,notyet},
		{450,224,460,228,notyet},
		{464,210,468,228,notyet},

		{490,210,500,212,notyet},
		{490,212,500,216,notyet},
		{490,216,500,220,notyet},
		{490,220,500,224,notyet},
		{490,224,500,228,notyet},
		{504,210,508,228,notyet},

		{410,260,420,262,notyet},
		{410,262,420,266,notyet},
		{410,266,420,270,notyet},
		{410,270,420,274,notyet},
		{410,274,420,278,notyet},
		{424,260,428,278,notyet},

		{450,260,460,262,notyet},
		{450,262,460,266,notyet},
		{450,266,460,270,notyet},
		{450,270,460,274,notyet},
		{450,274,460,278,notyet},
		{464,260,468,278,notyet},

		{490,260,500,262,notyet},
		{490,262,500,266,notyet},
		{490,266,500,270,notyet},
		{490,270,500,274,notyet},
		{490,274,500,278,notyet},
		{504,260,508,278,notyet}
	};
	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	static int c = 0;
//	if(c >= 6) c = 0;

	int i;
	BOOL doh = FALSE;
	BOOL doh2 = FALSE;

	static BYTE otherdif[6] = {0,0,0,0,0,0};
	static BYTE roller = 0;

	BYTE data[] = {
		gData->bAnalogButtons[GPX],
		gData->bAnalogButtons[GPY],
		gData->bAnalogButtons[GPW],
		gData->bAnalogButtons[GPA],
		gData->bAnalogButtons[GPB],
		gData->bAnalogButtons[GPK]
	};

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}

		roller = 0;
		for(i = 1; i < 6; i++) {
			otherdif[i] = 0x00;
		}
		otherdif[0] = 0xff;
		c = 0;

		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(c < 6) {
			for(i = 0; i < 6; i++) {
				if(bs[c * 6 + i].stat != passed) {
					bs[c * 6 + i].stat = testme;
				}
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data[c] == 0) 
			bs[c * 6 + 4].stat = passed;
		bs[c * 6 + 3].stat = passed;
		bs[c * 6 + 2].stat = passed;
		bs[c * 6 + 1].stat = passed;
		if (data[c] == 0xff) 
			bs[c * 6 + 0].stat = passed;
#else
		if(data[c] == 0) 
			bs[c * 6 + 4].stat = passed;
		else if (data[c] < 0x55) 
			bs[c * 6 + 3].stat = passed;
		else if (data[c] < 0xaa) 
			bs[c * 6 + 2].stat = passed;
		else if (data[c] < 0xff) 
			bs[c * 6 + 1].stat = passed;
		if (data[c] == 0xff) 
			bs[c * 6 + 0].stat = passed;
#endif
		

		doh2 = FALSE;
		for(i = 0; i < 6; i++) {
			otherdif[i] |= data[c] ^ data[i];
			if(otherdif[i] != 0xff) {
				doh2 = TRUE;
			}
		}

		roller |= rolb(data[c], 1) ^ data[c];
		if(!doh2 
			#ifndef __HAMMERHEAD__
				&& roller == 0xff
			#endif
			) {		
			bs[c * 6 + 5].stat = pending;
		}

		for(i = 0; i < 6; i++) {
			if(bs[i * 6 + 5].stat == pending) {
				if(bs[i * 6 + 4].stat == passed && data[i] == 0)
					bs[i * 6 + 5].stat = passed;
				else
					bs[i * 6 + 5].stat = pending;
			}
		}

		for(i = 0; i < 5; i++) {
			if(bs[c * 6 + i].stat != passed) goto doh2;
		}
		if(bs[c * 6 + 5].stat != passed && bs[c * 6 + 5].stat != pending) {
			goto doh2;
		}

		c++;
		for(i = 0; i < 6; i++) {
			otherdif[i] = 0;		
		}
		roller = 0;
		otherdif[c] = 0xff;
doh2:
		DRAWALL();
		drPrintf(0,0,L"X:%02x  Y:%02x  K:%02x  W:%02x  A:%02x  B:%02x  c:%d  ro:%02x  od: %02x %02x %02x %02x %02x %02x",
			data[2], data[3], data[4], data[5], data[0], data[1], c, roller, 
			otherdif[0], otherdif[1], otherdif[2], otherdif[3], otherdif[4], otherdif[5]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\remotduke\irrem.h ===
#include <xtl.h>
#include <stdio.h>
//#include <dsound.h>
#include "draw.h"

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...

/*extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}*/


/*
#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\remotduke\dukeprod.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cpx.h

Abstract:

    function declarations, type definitions, includes, etc, for Control Panel X

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __cpx_h_
#define __cpx_h_

//#include <windef.h>
//#include "ccl.h"
//#include "modes.h"

#ifndef UNICODE
#define UNICODE
#endif


#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif


#define MAX_SLOTS XGetPortCount()
//typedef enum {none, tested} padstatus;
typedef enum {notyet, testme, pending, failed, passed} BOXSTATUS;
typedef BOXSTATUS (*BOXFUNC)(BOXSTATUS newstatus);
extern BOXSTATUS gPadStatus[MAX_SLOTS];

#include "dp.h"
#include "device.h"

extern BOXFUNC gBoxFuncs[];
extern gpGAMEPAD * gData;


#endif //!defined (__cpx_h_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\USBdesc\inc\i_slixdriver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    i_slixdriver.h

Abstract:

    internal header for the SliXbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/
#ifndef __i_slixdriver_h_
#define __i_slixdriver_h_

#include <xid.h>

//*****************************************************************************
//**  Defines  ****************************************************************
//*****************************************************************************



#define SLIX_DRIVER_EXTENSION_ID 0
#define MAX_PORTS 8					    //max num of ports on the xbox (currently 5)
#define MAX_SLOTS 4						//max num of slots on a duke, plus 1 (currently 3)
#define MAX_INTERFACES 4				// max num of interfaces (currently 2 on Hawk)
#define BACK_PORT 0xf					//the number corresponding to the back-port of the xbox 
#define MAX_ENDPOINTS 32                                                                                        //changed by Bing
#define SLIX_MAX_BULK_PACKET_SIZE    0x40	//max bytes that can be transfered in a packet


// PDEVICE_EXTENSION->DeviceFlags state flags
//
//#define DF_MRB_IN_PROGRESS          0x00000002
//#define DF_PERSISTENT_ERROR         0x00000004
//#define DF_RESET_IN_PROGRESS        0x00000008
//#define DF_DEVICE_DISCONNECTED      0x00000010
#define DF_CONNECTED   0x0001
#define DF_INITIALIZED 0x0002


#define INCREMENT_PENDING_IO_COUNT(deviceExtension) \
    InterlockedIncrement((PLONG)&((deviceExtension)->PendingIoCount))

#define DECREMENT_PENDING_IO_COUNT(deviceExtension) \
    InterlockedDecrement((PLONG)&((deviceExtension)->PendingIoCount))

typedef unsigned char BYTE;	
typedef unsigned long DWORD;

#define		HID_DESCRIPTOR_TYPE		0x21
typedef struct _USB_HID_DESCRIPTOR
{
	UCHAR							Length;
	UCHAR							DescriptorType;
	USHORT							HIDVersion;
	UCHAR							CountryCode;
	UCHAR							NumClassDescriptors;
	UCHAR							ReportDescriptor;
	UCHAR							ReportDescriptorLength;
	UCHAR							ReportDescriptorSubtype;
	UCHAR							ReportDescriptorSubtypeLength;
} USB_HID_DESCRIPTOR, *PUSB_HID_DESCRIPTOR;


typedef struct _DEVICE_EXTENSION
{
    // device class interface to USB core stack
    IUsbDevice                      *Device;
	VOID*							Endpoints[MAX_ENDPOINTS];                                                                 //changed by Bing
	UCHAR							EndpointType[MAX_ENDPOINTS];                                                              //changed by Bing

	DWORD flags;
	USB_INTERFACE_DESCRIPTOR		InterfaceDescriptor; // storage for interface descriptor
	USB_DEVICE_DESCRIPTOR			DeviceDescriptor;
	USB_CONFIGURATION_DESCRIPTOR	ConfigurationDescriptor;
	USB_HID_DESCRIPTOR				HidDescriptor;
	USB_ENDPOINT_DESCRIPTOR			Endpoint1;
	USB_ENDPOINT_DESCRIPTOR			Endpoint2;
	XID_DESCRIPTOR					XidDescriptor;
	URB								Urb;  // used by enumeration for descriptor queries
	BYTE							bConfigData[200];
	BYTE							bNoOpt;
	XINPUT_CAPABILITIES				InputCaps;
	BYTE							bCapsOutBuff[50];
	BYTE							bCapsInBuff[50];
	BOOL							fAvail;
	BOOL							fGotCaps;
	BYTE							bPort;
	BYTE							bSlot;
	BYTE							bInterfaceNumber;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct SLIX_DRIVER_EXTENSION {				//driver extension, holds all relevant data
    DEVICE_EXTENSION Nodes[MAX_PORTS][MAX_SLOTS][MAX_INTERFACES]; //[port][slot][Inteface]		//pointers to the deviceObjects of each possible device
	ULONG	ulDeviceInserted;
	ULONG	ulDeviceRemoved;
}  SLIX_DRIVER_EXTENSION, *PSLIX_DRIVER_EXTENSION;

extern SLIX_DRIVER_EXTENSION * gpDriverExtension;	//pointer to the driver extension is global...
extern DEVICE_EXTENSION *	gInsertedDevices[];
extern USHORT				gInsertedCount;


#if DBG || DEBUG_LOG

extern ULONG               DebugFlags;     // DBGF_* Flags
extern ULONG               DebugLevel;     // Level of debug output

#define DBGPRINT(level, _x_) \
    if (level <= DebugLevel) { \
        KdPrint(("SlixD: ")); \
        KdPrint( _x_ ); \
    }


#else

#define DBGPRINT(level, _x_)

#endif



/*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************


NTSTATUS SLIX_Create (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS SLIX_Close (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);


NTSTATUS SLIX_DeviceControl (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

VOID SLIX_StartIo (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

//VOID SLIX_TimeoutDpc (IN PKDPC Dpc, IN PVOID Context, IN PVOID SysArg1, IN PVOID SysArg2);



typedef struct _REQUEST {
	BYTE* pData;
	int MaxData;
	
} REQUEST, *PREQUEST;
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\remotduke\remotduke.cpp ===
/* ++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    remotduke.cpp

Abstract:

    initializes all global variables, contains main loop, init. The module is using remote controller to control duke's motor.
	there is a file called buttoncontrol.ini to specify all codes. it can be changed to satisfy different requirement. This 
	application supports two dukes right now, it can be modified to support more than two dukes easily.

Author:

     Bing Li (a-bingli) 2001 May

-- */



#include "irrem.h"    //all stuff for IR controller
 
#include <xboxp.h>
#include <time.h>
 
#include "dukeprod.h"  // all stuff for dukeprod
#include "ccl.h"
#include "device.h"     // library for device operation
 
#include "mmu.h"
#include "Tsc.h"




#define NO_XDCS_INSTANCE    ((DWORD)(-1))
//size can be changed whenever need to remember or to output screen more than one ir code
#define IR_CODE_BUFFER_SIZE 2  // can be enlarged to store more IR_CODE
#define MAXCOUNT 5              //useless now

#define LIFT 0
#define RIGHT 1

#define XDCS_STATUS_NO_DONGLE           0
#define XDCS_STATUS_DOWNLOADING         1
#define XDCS_STATUS_DOWNLOAD_SUCCEEDED  2
#define XDCS_STATUS_DOWNLOAD_FAILED     3
#define XDCS_STATUS_FILE_WRITE_FAILED   4


struct REMOTE_CODE_TABLE
{
    LPWSTR Name;                   //the name of the button on the remote controller
    WORD Code;                     //the code of the button
	WORD Controler;                 //the control code of the button to specify which motor will be controlled
};

//table size 28, 27 buttons in total
#define RemoteCodeSize 28          //there are 27 buttons for the current remote controller, it may be changed later on
DWORD  MAXTIME=120;                //the default time to finish the test

//Global Variable
DWORD TestStatus;

HANDLE target;                      //file handle to handle the download file
HANDLE source;                      //file handle to handle the source file which is used to compare with the download file

int Dongle=0, Rom=0, File=1, screen=0, timer=0;  // all these variables are used to control flow

//CDraw draw;
WCHAR FormatBuffer[256];
DWORD dwDownloadStatus = XDCS_STATUS_NO_DONGLE;   //default as NO DONGLE

//These are all status in this application now.
LPWSTR StatusText[] = 
    {
        L"No Dongle",
        L"Downloading",
        L"Success",
        L"Failure",
        L"Writing to File Failed",

    };


REMOTE_CODE_TABLE RemoteCodeTable[RemoteCodeSize];
/* = {                       
      Button Name  Code    control( supports 2*2*2*2 = 16 motor)

    {L"POWER",    0xAD5   0x0000},
    {L"REVERSE",  0xAE2   0x0000},
    {L"PLAY",     0xAEA   0x0000},
    {L"FORWARD",  0xAE3   0x0000},
    {L"SKIP -",   0xADD   0x0000},
    {L"STOP",     0xAE0   0x0000},
    {L"PAUSE",    0xAE6   0x0000},
    {L"SKIP +",   0xADF   0x0000},
    {L"GUIDE",    0xAE5   0x0000},
    {L"INFO",     0xAC3   0x0000},
    {L"MENU",     0xAF7   0x0000},
    {L"REPLAY",   0xAD8   0x0000},
    {L"UP",       0xAA6   0x0000},
    {L"LEFT",     0xAA9   0x0000},
    {L"OK",       0xA0B   0x0000},
    {L"RIGHT",    0xAA8   0x0000},
    {L"DOWN",     0xAA7   0x0000},
    {L"DIGIT 0",  0xACF   0x0000},
    {L"DIGIT 1",  0xACE   0x0000},
    {L"DIGIT 2",  0xACD   0x0000},
    {L"DIGIT 3",  0xACC   0x0000},
    {L"DIGIT 4",  0xACB   0x0000},
    {L"DIGIT 5",  0xACA   0x0000},
    {L"DIGIT 6",  0xAC9   0x0000},
    {L"DIGIT 7",  0xAC8   0x0000},
    {L"DIGIT 8",  0xAC7   0x0000},
    {L"DIGIT 9",  0xAC6   0x0000},
    {NULL, 0}
};

 this is the basic code table, now it is read from the file
*/

BOXSTATUS gPadStatus[MAX_SLOTS];

gpGAMEPAD * gData;  // defined in dukeprod.h

/*********************************************************************
*Function: TurnMotor() is used to turn on/off the motor              *
*Parameter:button code index, on==1 is on, otherwise turn off        *
*Return:   void                                                      *
*Notes:    Now it support two dukes at the same time, you can easily *
*          modify to support more than two dukes                     * 
**********************************************************************/

void TurnMotor(int button, /*int slot,*/ int on)
{
	gpPoll();
	Sleep(16);

	BYTE slot=0;
	DWORD r=0;

	WORD flag=0;

 //controler ==0 means the controler code is empty
	if(RemoteCodeTable[button].Controler==0) return;

 
  while(1) //loop until we're supposed to quit...
	{
	  
	   

	   if(slot == MAX_SLOTS ) return;
	    flag=0;
	   
    gpUpdateDeviceStateInfo();				//update the button state info...
		//muGetDeviceMessages();


        gpPoll();
		gData = ::gpGetState(slot);


		for(slot = 0; slot < MAX_SLOTS; slot++)	//go through all slots...
		{
		   
          //DebugPrint("slot=%d\n", slot);

		  if(gpDeviceExists(slot)) {
			  
			  //DebugPrint("slot=%d\n", slot);
			  //DebugPrint("controler=%d\n",RemoteCodeTable[button].Controler); 

			if( ( (!(slot&1)) && ( 4352 & RemoteCodeTable[button].Controler) ) ||
				( (slot&1) && ( 17 & RemoteCodeTable[button].Controler) )  )   {

			BYTE data;
			XINPUT_FEEDBACK feedback;
			memset(&feedback, 0, sizeof(XINPUT_FEEDBACK));
		 	 
			data=(on? 252:0);

			switch(RemoteCodeTable[button].Controler) {
			     case 4096: feedback.Rumble.wLeftMotorSpeed= (data<<8) +data; break;     //controler == 0x1000
				 case 16:   feedback.Rumble.wLeftMotorSpeed= (data<<8) +data; break;     //controler == 0x0010
			     case 256:  feedback.Rumble.wRightMotorSpeed= (data<<8) +data; break;    //controler == 0x0100
				 case 1:    feedback.Rumble.wRightMotorSpeed= (data<<8) +data; break;    //controler == 0x0001
				 case 4352: feedback.Rumble.wRightMotorSpeed= (data<<8) +data;           //controler == 0x1100
					        feedback.Rumble.wLeftMotorSpeed= (data<<8) +data;
							DebugPrint("both speed = %d \n", feedback.Rumble.wLeftMotorSpeed);
					        break;
				 case 17:   feedback.Rumble.wRightMotorSpeed= (data<<8) +data;            //controler == 0x0011
					        feedback.Rumble.wLeftMotorSpeed= (data<<8) +data;
                            DebugPrint("both speed = %d \n", feedback.Rumble.wLeftMotorSpeed);
					        break;
				 case 0: return;
				 default: DebugPrint("Unknow RemoteCodeTable[].Controler code \n");

			}

            r = gpInputSetState(slot, &feedback);

			while(feedback.Header.dwStatus == ERROR_IO_PENDING) 	; //asynchronous
			
			if(feedback.Header.dwStatus != ERROR_SUCCESS)
					DebugPrint("Error: %d\n", feedback.Header.dwStatus);
		 

			 if(ERROR_IO_PENDING!=r)
			        DebugPrint("gpInputSetState returned error %d\n", r);
			 else flag++;

			  //DebugPrint("flag=%d slot=%d\n", flag, slot);

			}

		  }
		  else ::gPadStatus[slot]=notyet;


		  if(flag) return;  //if the motor has been turned on, return

		}

		if(slot == MAX_SLOTS) return; //if there is no device at all,  return

	}


}




void InitRemotCodeTable()
{
   int i=0;

   for(i=0; i<RemoteCodeSize;i++) {

       //RemoteCodeTable[i]= new REMOTE_CODE_TABLE;
	   RemoteCodeTable[i].Name = new WCHAR;
	   RemoteCodeTable[i].Code = 0;
	   RemoteCodeTable[i].Controler=0;
   }

}

int hextode(CHAR hex[])
{

  int retn=0,i=0, k=0;
  int len=strlen(hex), pw=(int)pow(16,len-3);

  //hex begin 0x, so we count from the (0,1,)2, from the third one
  for(i=2;i<len; ++i) {
	  if((hex[i]>= '0') && (hex[i] <= '9'))   k=  hex[i] - '0'; //numbers from 0 - 9
      else {
		  
		  switch(hex[i]) {
		  case 'A' : k=10; break;
          case 'a' : k=10; break;
		  case 'B' : k=11; break;
		  case 'b' : k=11; break;
		  case 'C' : k=12; break;
          case 'c' : k=12; break;
		  case 'D' : k=13; break;
          case 'd' : k=13; break;
		  case 'E' : k=14; break;
		  case 'e' : k=14; break;
		  case 'F' : k=15; break;
          case 'f' : k=15; break;
		  default: DebugPrint("Button.ini has invalid hex charactor %c \n", hex[i]); return -1;
		  }

	  }

	  retn += k*pw;
	  pw /=16;
  }
  
  return retn;

}


  
// read remote_code_table from the file
void Readrct(char file[], int fsize)
{

  int size=RemoteCodeSize,i=0;
  CHAR *tempf = new CHAR [fsize];
  
  if(tempf==0) {
	  DebugPrint("Out of memory space \n");
	  return;
  }

  CHAR  *temp;
  
  strcpy(tempf,file);

  //ignore the first line of the comments
  if((temp=strtok(tempf, "\r\n")) == NULL) {
		  
		  DebugPrint("Empty file \n");
		  return;
	  }
   

  //this is the second line to read time limit as decimal in seconds unit

  temp=strtok(NULL, " \n");

  int t=atoi(temp);
  if(t!=0)  MAXTIME=t;  

  //parse the file to assign to the RemoteCodeTable[]
  for(i=0; i<size;i++) {

	  if((temp=strtok(NULL, " \r\n")) == NULL) {
		  
		  DebugPrint("Out of button.ini range, size is not correct \n");
		  return;
	  }  

	  swprintf(RemoteCodeTable[i].Name,L"%S", temp);

	  //DebugPrint("RemoteCodeTable[%d].Name=%s \n",i, temp);

	  if( (temp=strtok(NULL, " \r\n")) == NULL ) {
		  
		  DebugPrint("Out of button.ini range, size is not correct \n");
		  return;
	  }  

	  RemoteCodeTable[i].Code = (WORD)hextode(temp);
	  //DebugPrint("RemoteCodeTable[%d].Code=%s\n",i, temp);

      if( (temp=strtok(NULL, " \r\n")) == NULL ) {
		  
		  DebugPrint("Out of button.ini range, size is not correct \n");
		  return;
	  }  

	  RemoteCodeTable[i].Controler = (WORD)hextode(temp);
	  //DebugPrint("RemoteCodeTable[%d].Controler=%s\n",i, temp);

  }
}


    
/**************************************************************************************
*Function: ReadButton() is used to read RemoteCodeTable[] from the file, which include*
*          the name of the button, the IR code of the button, the controller which is *
*          used to control the duke motor.                                            *
*Parameters: the array of string to store the file path and name, actually it defined *
*Notes:    This function copied the whole file to array then deal with the array      *
***************************************************************************************/

void ReadButton(char buttonfilename[])
{
  //char buttonfilename[]="C:\\public\button.ini";

  HANDLE buttonfile;

  buttonfile = CreateFile(buttonfilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); 

  if(buttonfile==INVALID_HANDLE_VALUE) {
	  DebugPrint("CreateFile failed, Error %d \n", GetLastError());
	  return;
  }

  DWORD fsize=0;
	
  CHAR *sm;
   
  DWORD temp;

	
	if(-1==(fsize=GetFileSize(buttonfile,NULL))) {
		 DebugPrint("GetFileSize(buttonfile,NULL) failed, Error: %d\n", GetLastError());
		return;
	}

	sm = new char[fsize];
	if(sm == NULL) {
		DebugPrint("new failed line %d FILE :%s!\n", __LINE__, __FILE__);
		delete[] sm;
		return;
	}
	
	if(FALSE == ReadFile(buttonfile, sm, fsize, &temp, 0)) {
		DebugPrint("ReadFile(buttonfile, .., %d, .., 0) failed! Error %d \n", fsize, GetLastError());
		delete[] sm;
		return;
	}

   Readrct(sm, fsize);


}



/*************************************************************************************************
*Function: WorkScreen() is used to show the user which button need to be pressed when IR receiver*
*           is pluged in, and every thing works well.                                            *
*Parameters: the button index of RemoteCodeTable[]                                               *
**************************************************************************************************/

void WorkScreen(int button)
{
	float wX=40, wY=50;
	screen=1;
	drCls();
	
	drPrintf(wX,wY,L"Xbox Tongle Test Version 1.00        Runing ...");


	drPrintf(wX,70.0,L"Time Limit Is %d Seconds",MAXTIME);

    wY+=100; 

    // set the  color for the screen, and then reset back again, set the size does not work for the original application
	drSetSize(40.0, 42.0, 0xff00ffff,0xff000000);

	if((button>=0)&&(button<28)) drPrintf(wX,wY,L"Press %s",RemoteCodeTable[button].Name);
	else drPrintf(wX, wY, L"Unknow Button");

	drSetSize(8.0, 15.0, 0xff00ff00, 0xff000000); //default color

    drShowScreen();
}




void ShowFinalResult()
{
    

    float x1=0,x2=0,x3=0,x4=0,y1=0,y2=0,y3=0,y4=0;
    float m1=0,m2=0,m3=0,m4=0,n1=0,n2=0,n3=0,n4=0;

    drCls();
 
    if((TestStatus==1)&&(File == 1)) {
		DebugPrint("Test passed.\n");

        drPrintf(20, 40,L"Test Passed");

		drQuad(250, 350, 0xff00ff00, 550,  50, 0xff00ff00, 600, 100, 0xff00ff00, 300, 400, 0xff00ff00);
		drQuad(250, 450, 0xff00ff00, 300, 400, 0xff00ff00, 150, 250, 0xff00ff00, 100, 300, 0xff00ff00);
	 

	} else {

		DebugPrint("Test failed.\n");

		if(File!=1) {
			drPrintf(20.0, 40.0, L"File Compare Failed");
			DebugPrint("File Compare Failed\n");
		}
		else if(timer) { 
			drPrintf(20.0, 40.0, L"Time Off");
			DebugPrint("Time Off\n");
		}
		else if(TestStatus == -1) {
			drPrintf(20, 40, L"Download Failed");
			DebugPrint("Download Failed \n");
		}
		else {
			drPrintf(20, 40, L"Button Test Failed");
			DebugPrint("Button test failed \n");
		}


		drQuad(200, 400, 0xffff0000, 550,  50, 0xffff0000, 600, 100, 0xffff0000, 250, 450, 0xffff0000);
		drQuad(600, 400, 0xffff0000, 250,  50, 0xffff0000, 200, 100, 0xffff0000, 550, 450, 0xffff0000);

	}
     
	drShowScreen();

}


int DiffFile(/*HANDLE &target, HANDLE &source*/)
{
	  
	
	int diff=0; //initiliaze as false, it will changed as true whenever bad thing happened
	
	DWORD tfsize=0, sfsize=0;
	
	char *tm, *sm;
	DWORD temp;


	
	if(-1==(sfsize=GetFileSize(source,NULL))) {
		 DebugPrint("GetFileSize(source,NULL) failed, Error: %d\n", GetLastError());
		return 1;
	}
	
	if(-1==(tfsize=GetFileSize(target,NULL))) {
		DebugPrint("GetFileSize(target,NULL) failed, Error: %d\n", GetLastError());
		return 1;
	}

	if(tfsize!=sfsize) {
		DebugPrint("Size are different\nSource file size is %d but ", sfsize);
        DebugPrint("Target file size is %d\n", tfsize);
		return 1;
	} else DebugPrint("Equal file size, target is %d, source is %d \n", tfsize, sfsize);
	
	tm = new char[tfsize];
	if(tm == NULL) {
		DebugPrint("new failed line %d FILE :%s!\n", __LINE__, __FILE__);
		delete [] tm;
		return 1;
	}
	
	sm = new char[sfsize];
	if(sm == NULL) {
		DebugPrint("new failed line %d FILE :%s!\n", __LINE__, __FILE__);
		delete[] sm;
		return 1;
	}
	
	if(FALSE == ReadFile(target, tm, tfsize, &temp, 0)) {
		DebugPrint("ReadFile(h1, .., %d, .., 0) failed! Error %d \n", tfsize, GetLastError());
		 
		delete[] sm;
		delete[] tm;
		return 1;
	}
	
	if(FALSE == ReadFile(source, sm, sfsize, &temp, 0)) {
		DebugPrint("ReadFile(h2, .., %d, .., 0) failed! Error %d \n", sfsize, GetLastError());
		delete[] sm;
		delete[] tm;
		return 1;
	}
	
	if(memcmp(tm, sm, sfsize)) {
		DebugPrint("NOT the same file\n");
		return 1;
	}
	
    DebugPrint("The same file, Success File Compare\n");
	return diff;

}

void ShowScreen()
{

    drCls();
	 
	drPrintf(10,20,L"Xbox Tongle Test Version 1.00 ");

	drPrintf(10,50,L"No IR Remote Receiver");

//default as failed 
	drQuad(200, 400, 0xffff0000, 550,  50, 0xffff0000, 600, 100, 0xffff0000, 250, 450, 0xffff0000);
	drQuad(600, 400, 0xffff0000, 250,  50, 0xffff0000, 200, 100, 0xffff0000, 550, 450, 0xffff0000);


	drShowScreen();


}



LPCWSTR GetCodeName(WORD wCode)
{
    REMOTE_CODE_TABLE *pRemoteEntry = RemoteCodeTable;
    while(pRemoteEntry->Code)
    {
        if(pRemoteEntry->Code == wCode)
        {
            return pRemoteEntry->Name;
        }
        pRemoteEntry++;
    }
    if(wCode)
    {
        return L"UNKNOWN";
    } else
    {
        return NULL;
    }
}


//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------
void __cdecl main()
{
    XDCS_DVD_CODE_INFORMATION XdcsInfo;
    DWORD dwXdcsInstance=NO_XDCS_INSTANCE;
//    DWORD dwDownloadStatus = XDCS_STATUS_NO_DONGLE;
    DWORD dwConnectedDevices = 0;
    DWORD dwPortInUse = 0;
    XDCS_ASYNC_DOWNLOAD_REQUEST downloadRequest;
    DWORD dwPercentComplete = 0;
    DWORD dwDownloadStartTick, dwCurrentTick;
	DWORD mystarttime=0,mycurrenttime=0;

    double fDownloadTime = 0;
    PVOID pvBuffer;
    DWORD dwInserstions, dwRemovals;
    CHAR  szFileName[]="t:\\dvdcode.lib";
	CHAR sourceFileName[]="t:\\dvdsource.lib";
	CHAR button[]="t:\\buttoncontrol.ini";

	

	if((source = CreateFile(sourceFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))==INVALID_HANDLE_VALUE)
	{ DebugPrint("Can not Create Source File \n");
	  File =0;
	  goto Final;
	}
    
    //HANDLE hFile;
	LPCWSTR pwszCodeName=0, oldCodeName=0;
 

    HANDLE hRemote = NULL;
    DWORD  dwRemotePort=0;
    XINPUT_STATE_INTERNAL IrCodeBuffer[IR_CODE_BUFFER_SIZE] = {0};

    DWORD dwIrCodeBufferPos=0;
    DWORD dwPacketNumber=0;

	 
	DWORD dwDisplayYPos;

	float myX=10, myY=20,y=0;
	int remotecode=0, press =0, count=0,pressOk=0, dc=0;
    int xinput=0;
 
	TestStatus =1; //initiliaze as success, any bad thing happend, it will fail

     
    //Initialize core peripheral port support
    XInitDevices(0,NULL);
	
	drInit();

	InitRemotCodeTable();

	ReadButton(button);
	

 
        
    //Loop Forever
	Rom=0;
	Dongle=1;
	Rom=1; File=-1;

	struct tm *ptr;
	time_t lt;
 
	ShowScreen();


	WORD right=0, motor=0;

    while(1) {

           if( (mycurrenttime - mystarttime) > MAXTIME) { 
			   DebugPrint("Time off \n");
			   timer=1;
			   TestStatus = 0;
			   TurnMotor(remotecode,0);
			   motor=0;
			   goto Final;
		   }


		   if(remotecode==0) {
			   lt=time('\0');
			   ptr=localtime(&lt);
                
			   mystarttime = (ptr->tm_hour) * 360 + (ptr->tm_min)*60 + ptr->tm_sec;
			   mycurrenttime=mystarttime;
		 
		   }


		   if((RemoteCodeTable[remotecode].Code!=0)&&(RemoteCodeTable[remotecode].Controler==0)) {

			   TurnMotor(remotecode-1,0);
			   goto Final;
		   }



		   oldCodeName = RemoteCodeTable[remotecode].Name;

		   

        if(XDCS_STATUS_DOWNLOADING == dwDownloadStatus)
        {
            //Update download time
            dwCurrentTick = GetTickCount();
            fDownloadTime = ((LONG)dwCurrentTick - (LONG)dwDownloadStartTick)/1000.0;
            //Update percent complete
            dwPercentComplete = (downloadRequest.ulBytesRead * 100) / downloadRequest.ulLength; 
            // Check status
            if(ERROR_SUCCESS == downloadRequest.ulStatus)
            {
                target = CreateFile(szFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); 
                if(INVALID_HANDLE_VALUE != target)
                {
                    DWORD dwBytesWritten;
                    if(WriteFile(target, downloadRequest.pvBuffer, downloadRequest.ulBytesRead, &dwBytesWritten, NULL))
                    {
                        dwDownloadStatus = XDCS_STATUS_DOWNLOAD_SUCCEEDED;
				
                    } else
                    {
                        dwDownloadStatus = XDCS_STATUS_FILE_WRITE_FAILED;
						DebugPrint("WriteFile() failed %d", GetLastError());
                    }
 //                   CloseHandle(target);
                } else
                {
                    dwDownloadStatus = XDCS_STATUS_FILE_WRITE_FAILED;
					DebugPrint("CreateFile() failed %d\n", GetLastError());
                }
                free(downloadRequest.pvBuffer);
            } else if(ERROR_IO_PENDING != downloadRequest.ulStatus)
            {
                dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                free(downloadRequest.pvBuffer);
            }
        }

        //
        //  Look for the insertion or removal of devices
        //
        if(XGetDeviceChanges(XDEVICE_TYPE_DVD_CODE_SERVER, &dwInserstions, &dwRemovals))
        {

			if (((remotecode > 0)&& (remotecode < (RemoteCodeSize -1))) || (dwDownloadStatus == XDCS_STATUS_DOWNLOADING)
				||(dwDownloadStatus == XDCS_STATUS_DOWNLOAD_SUCCEEDED))
			{
			
				TestStatus =0;
				TurnMotor(remotecode, 0);
				motor=0;
				goto Final;
			}

			Rom = 0;
            if((1<<dwPortInUse)&dwRemovals)
            {   
                dwDownloadStatus = XDCS_STATUS_NO_DONGLE;
            }
            dwConnectedDevices &= dwRemovals;       //Handle removals
            dwConnectedDevices |= dwInserstions;    //Then additions

            //If there currently is no dongle, start using the first device.
            if(XDCS_STATUS_NO_DONGLE == dwDownloadStatus)
            {
                if(dwInserstions)
                {
                    DWORD dwError;
                    dwPortInUse = 0;
                    while(!(dwConnectedDevices&(1<<dwPortInUse))) dwPortInUse++;
                    dwError = XDCSGetInformation(dwPortInUse, &dwXdcsInstance, &XdcsInfo);
                    if(dwError)
                    {
                        dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                    } else
                    {
                        dwDownloadStatus = XDCS_STATUS_DOWNLOADING;
                        downloadRequest.dwDeviceInstance = dwXdcsInstance;
                        downloadRequest.pvBuffer = malloc(XdcsInfo.dwCodeLength);
                        downloadRequest.ulOffset = 0;
                        downloadRequest.ulLength = XdcsInfo.dwCodeLength;
                        downloadRequest.ulBytesRead = 0;
                        downloadRequest.hCompleteEvent = NULL;
                        dwDownloadStartTick = GetTickCount();
                        if(!downloadRequest.pvBuffer)
                        {
                            dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
							DebugPrint("Memory Allocation Failed \n");

                        } else if(ERROR_IO_PENDING!=XDCSDownloadCodeAsync(&downloadRequest))
                        {
                            dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                        }
                    }
                }
            }
        }    
		
	
        if(Rom==1) continue;
         
        //DebugPrint("DownloadStatus %S \n",StatusText[dwDownloadStatus]); 

// Compare the downloaded file in t:\dvdcode.lib with t:\dvdsource.lib byte by byte using DiffFile(), 
// DiffFile return 1 if two files are different, 0 otherwise.

		if((dwDownloadStatus == XDCS_STATUS_DOWNLOAD_SUCCEEDED)&&(File==-1)) {
			
    		SetFilePointer(target,NULL,NULL,FILE_BEGIN);
            SetFilePointer(source,NULL,NULL,FILE_BEGIN);

	    	if(!DiffFile()) {
			//			drPrintf(10,myY,L"File Compare is SUCCESSFUL");
		    	DebugPrint("File Compare is Successful\n");
				File=1;
				TestStatus=1;
				if(!CloseHandle(target)) DebugPrint("CloseHandle(target) faile: %d\n", GetLastError());
 
			} else {
			    TestStatus =0; 
			    File=0;
			    DebugPrint("Compare File Failed\n");
                if(!CloseHandle(target)) DebugPrint("CloseHandle(target) faile: %d\n", GetLastError());
				
				TurnMotor(remotecode, 0);
				motor=0;
			    goto Final;

			}   

		} else if((dwDownloadStatus==XDCS_STATUS_DOWNLOAD_FAILED) ||(dwDownloadStatus==XDCS_STATUS_FILE_WRITE_FAILED)) {
			TestStatus=-1;
			DebugPrint("DownLoad Filed \n");
            if(!CloseHandle(target)) DebugPrint("CloseHandle(target) faile: %d\n", GetLastError());
			TurnMotor(remotecode, 0);
			goto Final;
		}


        /**
        *** Poll the XID Remote part.
        *** Just because we don't have lot's of creative ways to
        *** abuse the XInput API, we will be clever here, and use the API in a valid,
        *** but less than optimal ways.  It had better work too!
        **/
		static int bing=0;
        if(!hRemote) {
            DWORD dwDevices= (XGetDevices(XDEVICE_TYPE_IR_REMOTE)&0x0F); 
            if(dwDevices)
            {
                //Find the first bit set and open it.
                dwRemotePort = 0;
                while(!(dwDevices&(1<<dwRemotePort))) dwRemotePort++;
                hRemote = XInputOpen(XDEVICE_TYPE_IR_REMOTE, dwRemotePort, XDEVICE_NO_SLOT, NULL);
                dwPacketNumber = 0;
            }
        }

		//compare file first, otherwise do not need to test others
		if(File == -1) {
			
			drCls();
			drPrintf(10, 40, L" %s", StatusText[dwDownloadStatus]);
			drShowScreen();			
			continue;

		}

        if(hRemote)
        {
            
			WorkScreen(remotecode);

			if(motor==0) { 
				TurnMotor(remotecode,1);
				motor++;
			}


            if(ERROR_SUCCESS == XInputGetState(hRemote, (PXINPUT_STATE)(IrCodeBuffer+dwIrCodeBufferPos)))
            {
                //Don't move for duplicates
                if(dwPacketNumber != IrCodeBuffer[dwIrCodeBufferPos].dwPacketNumber)
                {
                    dwPacketNumber = IrCodeBuffer[dwIrCodeBufferPos].dwPacketNumber;
                    dwIrCodeBufferPos = (dwIrCodeBufferPos+1)%IR_CODE_BUFFER_SIZE;
                    
					if(dwPacketNumber) {
						DWORD dwCodeBufferDisplayPos = (dwIrCodeBufferPos+1)%IR_CODE_BUFFER_SIZE;
                        DWORD dwDisplayYPos = 265 + (IR_CODE_BUFFER_SIZE*15);
                        LPCWSTR pwszCodeName;
                   
						for(int i=1; i < IR_CODE_BUFFER_SIZE; i++) { 
							pwszCodeName = GetCodeName(IrCodeBuffer[dwCodeBufferDisplayPos].IrRemote.wKeyCode);
                           if(pwszCodeName)
						   {
                            
 
							if(oldCodeName==pwszCodeName) {
								TurnMotor(remotecode, 0);
								DebugPrint("remotecode = %d turn off\n", remotecode);
								remotecode++;
								motor=0;
								break;
							}
							//else goto Code;
						   }
                           dwDisplayYPos -= 15;
                           dwCodeBufferDisplayPos = (dwCodeBufferDisplayPos+1)%IR_CODE_BUFFER_SIZE;
						}
					}
				}
			
			} else {   
                XInputClose(hRemote);
                hRemote = NULL;
                memset(IrCodeBuffer, 0, sizeof(IrCodeBuffer));
				//screen=0;
                 
            }
        } else
        {
             
			screen=0;
			DebugPrint("hhandle = NULL \n");
        }

        //Preset
        if(screen==0) {
			ShowScreen();
            TurnMotor(remotecode,0);
			motor=0;
		}

		lt=time('\0');
		ptr=localtime(&lt);

		mycurrenttime = (ptr->tm_hour) * 360 + (ptr->tm_min)*60 + ptr->tm_sec;


//		currenttick=GetTickCount();
         
	 

		if((mycurrenttime - mystarttime) > MAXTIME) {
			TestStatus = 0;
			timer=1;
		}

//		DebugPrint("currenttime=%d \n starttime=%d\n", mycurrenttime,mystarttime);
		
		if( (remotecode == RemoteCodeSize-1) || ( (mycurrenttime-mystarttime) > MAXTIME ) ) {
Final:	ShowFinalResult();
		//initiliaze all variable
		    dwDownloadStatus = XDCS_STATUS_NO_DONGLE;
			Rom =1;
			timer=0;
			remotecode =0;
			motor=0;
			File=-1;
			mycurrenttime =0;
			mystarttime=0;
			screen=1;
		}
    }
	

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\USBdesc\inc\slixdriver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    i_slixdriver.h

Abstract:

    header of exposed routines from the SliXbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/
#ifndef __slixdriver_h__
#define __slixdriver_h__

#define _IN
#define _OUT
#define _OPT

/* unused, since we aren't going through CreateFile
#define IOCTL_SLIX_IN		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
#define IOCTL_SLIX_OUT		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
#define IOCTL_SLIX_SETUP	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
#define IOCTL_SLIX_DATA0	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
#define IOCTL_SLIX_DATA1	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
*/

typedef long USBD_STATUS;
typedef unsigned char       BYTE;
typedef unsigned long		DWORD;



void KeepCode();

#ifdef __cplusplus
extern "C" { //to prevent name mangling... 
#endif

/*************************************************************************************
Function:   SlixdIn
Purpose:	create & send an IN packet, receive the data, return any errors
Params:     in Address --- the topology of the device to receive from (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to receive from 
			out data --- pointer to the buffer to receive data
			in out len --- pointer to max length of data buffer, receives size of data received
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdIn(_IN BYTE Address, _IN BYTE Endpoint, _OUT char * data, _IN _OUT DWORD * len, _IN BYTE USBInterface);


/*************************************************************************************
Function:   SlixdOut
Purpose:	create & send an OUT packet, send the data, return any errors
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdOut(_IN BYTE Address, _IN BYTE Endpoint, _IN char * data, _IN DWORD len, _IN BYTE USBInterface);


/*************************************************************************************
Function:   SlixdSetup
Purpose:	create & send a SETUP packet, send the data, return any errors
note: more stuff may be needed to receive or send additional data...
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
			data2 --- pointer to buffer to receive or send data. OPT if data[6]==0
			len2 --- p to length of data2 if sending, p to max length if receiving, & 
				will receive length of data received.  OPT if data[6] == 0
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdSetup(_IN BYTE Address, _IN BYTE Endpoint, _IN char * data, _IN DWORD len, 
					   _OPT _IN _OUT char * data2, _OPT _IN _OUT USHORT *len2, _IN BYTE USBInterface);



USBD_STATUS SlixdReset();



#ifdef __cplusplus
} //extern "C"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\remotduke\dukeprod.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dukeprod.cpp

Abstract:

    initializes all global variables, contains main loop, init, and stuff for duke production test

Author:

    Jason Gould (jgould) Aug 2000

Modified: 
	Jeff Keely		december 2000  -added mu code
	Jason Gould		january 2001   -added comments, renamed variables


--*/

#include "xtl.h"
#include <stdio.h>
#include "dukeprod.h"
#include "ccl.h"
#include "device.h"
#include "draw.h"
#include "mmu.h"
#include "Tsc.h"

#define countof(_x_) (sizeof(_x_) / sizeof(_x_[0]))

BOXSTATUS gPadStatus[MAX_SLOTS];

/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void init()
{
	int i;

	DWORD dwRet;

    DebugPrint("Welcome to Duke Production Test: Built on %s at %s\n", __DATE__,__TIME__);

    //Initialize core peripheral port support
    XInitDevices(0,NULL);
    

	gpInit(0);
	drInit();
	muInit();

	for(i = 0; i < MAX_SLOTS; i++) {
		gPadStatus[i] = notyet;
	}
	
	TscInit(0);

	DebugPrint("Done with initialization!\n");
}



/*************************************************************************************
Function:	deinit
Purpose:	de-initialize all cpx stuff (NONE, since we never should quit!)
Params:		none
Out:		un-registers the callbacks for controlpads and MUs, tells all cpx modes to quit
Notes:		We shouldn't ever go here, since xbox only has one process, & this is it...
*************************************************************************************/
void deinit()
{
	DebugPrint("Quitting???? ...");

//	gModeFunctions[gMode](STATUS_LEAVE, 0);
//	for(int i = 0; i < MAX_MODES; i++) {
//		gModeFunctions[i](STATUS_QUIT, 0);
//	}

	gpDeinit();
	drDeinit();
	muDeinit();

	DebugPrint("Deinit is finished.\n");
	
}


/*************************************************************************************
Function:	wWinMain (...)
Purpose:	the entry-point of cpx. Calls init, does the main loop, then de-inits
Params:		irrelevant
Notes:		until d3d is ported, it can't display the console...
*************************************************************************************/
//DWORD WINAPI TestMain()

gpGAMEPAD * gData;

typedef struct {
	BOXFUNC BoxFunc;
	float secs;
	BOXSTATUS stat;
} TESTSTRUCT;

TESTSTRUCT tests[] = {
	{LeftTriggerTest     ,20, notyet},
	{RightTriggerTest    ,20, notyet},
	{LeftThumbStick1Test ,20, notyet},
	{DPadTest            ,20, notyet},
	{StartSelectTest     ,20, notyet},
	{RightThumbStick1Test,20, notyet},
	{ButtonTest          ,20, notyet}
};


bool muTop, muBottom;

BOXSTATUS test(int slot)
{
	int i, j;
	__int64 tim;
	BOXSTATUS overall = passed;
	muTop = true;
	muBottom = true;

	gData = ::gpGetState(slot);
	for(i = 0; i < countof(tests); i++) {
		tests[i].stat = notyet;
		tests[i].BoxFunc(tests[i].stat);
	}


	/*
	Please pardon the odd code here. 
	It was originally designed to run simultaneously with other tests that also used d3d.
	Since d3d isn't multithreaded, all drawing routine calls had to occur in the same thread,
	yet had to occur nearly simultaneously with other test code - Hence the repeated calling 
	& returning from functions...
  	*/ 
	
	for(i = 0; i < countof(tests); i++) {
		tim = TscBegin();
		tests[i].stat = testme;
		while(1) {
			drCls();

			gpUpdateDeviceStateInfo();				//update the button state info...
			if(!::gpDeviceExists(slot))	{
				return failed;
			}
			muGetDeviceMessages();

			gpPoll();
			gData = ::gpGetState(slot);

			for(j = 0; j < countof(tests); j++) {
				tests[j].stat = tests[j].BoxFunc(tests[j].stat);
			}

            /*
			int d1 = muGetDriveFromPortSlot(slot, XDEVICE_TOP_SLOT);
			if(d1 != 0) muTop = true;
			int d2 = muGetDriveFromPortSlot(slot, XDEVICE_BOTTOM_SLOT);
			if(d2 != 0) muBottom = true;
            */

			drBox(230,20,330,50, muTop ? 0xff00ff00 : 0xfff0f0f0);
			drBox(230,60,330,90, muBottom ? 0xff00ff00 : 0xfff0f0f0);

			DWORD r;
			BYTE data;
			XINPUT_FEEDBACK feedback;
			memset(&feedback, 0, sizeof(XINPUT_FEEDBACK));
			if(tests[0].stat == testme)	// if LeftTriggerTest is going, rumble left
			{
				data = gData->bAnalogButtons[GPL];

				DebugPrint("data=%d \n", data);

				feedback.Rumble.wLeftMotorSpeed= (data<<8) +data;
				r = gpInputSetState(slot, &feedback);
				if(r != ERROR_IO_PENDING)
					DebugPrint("gpInputSetState returned error %d\n", r);
				while(feedback.Header.dwStatus == ERROR_IO_PENDING)
					;
				if(feedback.Header.dwStatus != ERROR_SUCCESS)
					DebugPrint("Error: %d\n", feedback.Header.dwStatus);
			}
			if(tests[1].stat == testme)	// if RightTriggerTest is going, rumble right
			{
				data = gData->bAnalogButtons[GPR];
				feedback.Rumble.wRightMotorSpeed= (data<<8) +data;
				r = gpInputSetState(slot, &feedback);
				if(r != ERROR_IO_PENDING)
					DebugPrint("gpInputSetState returned error %d\n", r);
				while(feedback.Header.dwStatus == ERROR_IO_PENDING)
					;
				if(feedback.Header.dwStatus != ERROR_SUCCESS)
					DebugPrint("Error: %d\n", feedback.Header.dwStatus);
			}

		//	_asm int 3;
			drShowScreen();							

			if (TscTicksToFSeconds(TscCurrentTime(tim)) > tests[i].secs) {
				tests[i].stat = failed;
			} else {
				if(tests[i].stat == passed) {
					break;
				}
			}

			if(tests[i].stat == failed) {
				overall = failed;
				break;
			}
		}
	}
	return overall;
}

//int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow)
int __cdecl main()
{
//	_asm int 3;

	int i;
	init();

	gpPoll();
	Sleep(16);

	drCls();
	drShowScreen();

	while(1) //loop until we're supposed to quit...
	{
		gpUpdateDeviceStateInfo();				//update the button state info...
		muGetDeviceMessages();

		for(i = 0; i < MAX_SLOTS; i++) {
			if(!gpDeviceExists(i)) {
				::gPadStatus[i] = notyet;
			} else if (gPadStatus[i] == notyet) {
				gPadStatus[i] = test(i);

				drCls();
				if(gPadStatus[i] == passed && muTop && muBottom) {
					//passed
					drQuad(250, 350, 0xff00ff00, 550,  50, 0xff00ff00, 600, 100, 0xff00ff00, 300, 400, 0xff00ff00);
					drQuad(250, 450, 0xff00ff00, 300, 400, 0xff00ff00, 150, 250, 0xff00ff00, 100, 300, 0xff00ff00);
				} else {
					//failed
					drQuad(200, 400, 0xffff0000, 550,  50, 0xffff0000, 600, 100, 0xffff0000, 250, 450, 0xffff0000);
					drQuad(600, 400, 0xffff0000, 250,  50, 0xffff0000, 200, 100, 0xffff0000, 550, 450, 0xffff0000);
				}
				drShowScreen();
			}
		}
	}
//		gpPoll();
//		gGlobalCommands.CheckControls();		//see if any commands are being presseed
//		gModeFunctions[gMode](STATUS_NORMAL, 0);	//go to the appropriate mode
//		drShowScreen();							//and draw the screen
	

	//we should theoretically never get here on xbox......

	deinit();


	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\USBdesc\slixd\islixd.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    islixd.cpp

Abstract:

    interface to the slixbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/


extern "C" {
#include <nt.h>
#include <ntos.h>
}

#include <xtl.h>

#include <stdio.h>
#include <usb.h>
#include "..\inc\slixdriver.h"
#include "..\inc\i_slixdriver.h"

//#include "slixdriver.cpp"
//extern void SLIX_RemoveDevice (IN IUsbDevice *Device);


///////////////////////#define _WAIT (733000 * 1000 * 30)  //50 milliseconds
#define _TICKS_PER_MILLISECOND 733000I64
const __int64 _WAIT = (_TICKS_PER_MILLISECOND * 1000 * 40);

#define PORT_FROM_ADDRESS(a) ((a) & 0x0f)
#define SLOT_FROM_ADDRESS(a) (((a) >> 4) & 0x7)

#define ENDPOINT_TYPE(e) ((e >> 4) & 3)
#define ENDPOINT_DIRECTION(e) (e & 0x80)

#define ENDPOINT_NUM(e) (ENDPOINT_DIRECTION(e)?(e & 15):((e & 15)+16))                                                  //changed by Bing from 15 to 31

#define ENDPOINT_NUM_DIRECTION(e) (e & 0x8f)


typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

volatile int gYouMayPass = 0;

#pragma warning(disable:4035) 
//disable "no return". rdtsc changes edx:eax, which is where __int64 is returned.
//this incriments roughly 733000000 times/second.
//733000 = 1 millisecond, etc.
__int64 __inline gettsc() {_asm {rdtsc} }	
#pragma warning(default:4035)




VOID CompleteProc (PURB urb, PVOID con)
{
 	gYouMayPass = ~urb->Header.Status;	//encoding it for the moment...
}

VOID IsochCompleteProc (USBD_ISOCH_TRANSFER_STATUS* puits, PVOID con)
{
 	gYouMayPass = ~puits->Status;	//encoding it for the moment...
}


//#define USB_ENDPOINT_TYPE_CONTROL                 0x00
//#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01
//#define USB_ENDPOINT_TYPE_BULK                    0x02
//#define USB_ENDPOINT_TYPE_INTERRUPT               0x03
HANDLE GetEndpoint(IUsbDevice * pud, BYTE endpoint)
{
	URB urb;
	int temp;
	void** Endpoints = ((PDEVICE_EXTENSION)pud->GetExtension())->Endpoints;

	if((0 == ENDPOINT_NUM(endpoint)) || (16==ENDPOINT_NUM(endpoint)) ) {	//default (control) endpoint
		if(Endpoints[0] != (void*)-1) {	//if it's been opened already
			return Endpoints[0];		//return it...
		}

		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_OPEN_DEFAULT_ENDPOINT((&urb.OpenEndpoint));
		pud->SubmitRequest(&urb);
		Endpoints[endpoint] = NULL;		//NULL is always returned for the default endpoint handle
		return NULL;

	} else {	//normal endpoint

		if(ENDPOINT_TYPE(endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { //isoch

			//if it's not already opened...
			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
				DBGPRINT(3, ("Attempting to open isoch endpoint: "));
				((DEVICE_EXTENSION*)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] 
					= USB_ENDPOINT_TYPE_ISOCHRONOUS; //so we can close it properly

				RtlZeroMemory(&urb,sizeof(URB));
                USB_BUILD_ISOCH_OPEN_ENDPOINT((&urb.IsochOpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), 256, 0);
				temp = pud->SubmitRequest(&urb);
				DBGPRINT(3, ("returned 0x%8x\n", temp));
				Endpoints[ENDPOINT_NUM(endpoint)] = urb.IsochOpenEndpoint.EndpointHandle;

				URB urb2;
				RtlZeroMemory(&urb2,sizeof(URB));
				USB_BUILD_ISOCH_START_TRANSFER((&urb2.IsochStartTransfer), Endpoints[ENDPOINT_NUM(endpoint)], 
					0, URB_FLAG_ISOCH_START_ASAP);
				temp = pud->SubmitRequest(&urb2);
				DBGPRINT(3, ("StartTransfer returned 0x%8x\n", temp));

			}

			return Endpoints[ENDPOINT_NUM(endpoint)];

		} else { //not isoch
			if(Endpoints[ENDPOINT_NUM(endpoint)] != (void*) -1 && Endpoints[ENDPOINT_NUM(endpoint)] != NULL) {
				return Endpoints[ENDPOINT_NUM(endpoint)];
			}

			RtlZeroMemory(&urb,sizeof(URB));

			USB_BUILD_OPEN_ENDPOINT((&urb.OpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), ENDPOINT_TYPE(endpoint), SLIX_MAX_BULK_PACKET_SIZE, 1);
			pud->SubmitRequest(&urb);
			Endpoints[ENDPOINT_NUM(endpoint)] = urb.OpenEndpoint.EndpointHandle;
			return urb.OpenEndpoint.EndpointHandle;
		}

	}
}



 

 


//callback for endpoint closes (below) to allow them to be asynchronous
//but I don't think this is a callback function, it just a stub, may useless called by IUsbDevice class.
//VOID arf (PURB urb, PVOID context)
//{ }

 

void CloseEndpoint(IUsbDevice * pud, BYTE endpoint, HANDLE eh)
{
//	URB urb;
//	int temp;
//	void** Endpoints = ((PDEVICE_EXTENSION)pud->GetExtension())->Endpoints;

//
//	if(0 == ENDPOINT_NUM(endpoint)) {	//default (control) endpoint
//		if(Endpoints[0] == (void*)-1) {	//if it's been closed already
//			return; //Endpoints[0];		//return it...
//		} else {

		//RtlZeroMemory(&urb,sizeof(URB));
//		USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&urb.CloseEndpoint, arf,0);

		//USB_BUILD_OPEN_DEFAULT_ENDPOINT((&urb.OpenEndpoint));
//		pud->SubmitRequest(&urb);
		//Endpoints[endpoint] = NULL;		//NULL is always returned for the default endpoint handle
//		return;// NULL;
//		}

//	} else {//normal endpoint
//		if(ENDPOINT_TYPE(endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { //isoch

			//if it's not already opened...

			/* we will consider this later on
			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
				DBGPRINT(3, ("Attempting to open isoch endpoint: "));
				((DEVICE_EXTENSION*)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] 
					= USB_ENDPOINT_TYPE_ISOCHRONOUS; //so we can close it properly

				RtlZeroMemory(&urb,sizeof(URB));
                USB_BUILD_ISOCH_OPEN_ENDPOINT((&urb.IsochOpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), 256, 0);
				temp = pud->SubmitRequest(&urb);
				DBGPRINT(3, ("returned 0x%8x\n", temp));
				Endpoints[ENDPOINT_NUM(endpoint)] = urb.IsochOpenEndpoint.EndpointHandle;

				URB urb2;
				RtlZeroMemory(&urb2,sizeof(URB));
				USB_BUILD_ISOCH_START_TRANSFER((&urb2.IsochStartTransfer), Endpoints[ENDPOINT_NUM(endpoint)], 
					0, URB_FLAG_ISOCH_START_ASAP);
				temp = pud->SubmitRequest(&urb2);
				DBGPRINT(3, ("StartTransfer returned 0x%8x\n", temp));
            
			}
			*/

//			return; //Endpoints[ENDPOINT_NUM(endpoint)];

//		} else { //not isoch
//			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
				//already closed
//				return; //Endpoints[ENDPOINT_NUM(endpoint)];
//			} else {
			//RtlZeroMemory(&urb,sizeof(URB));

			//USB_BUILD_OPEN_ENDPOINT((&urb.OpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), ENDPOINT_TYPE(endpoint), SLIX_MAX_BULK_PACKET_SIZE, 1);
			
			
//            USB_BUILD_CLOSE_ENDPOINT(&urb.CloseEndpoint,Endpoints[ENDPOINT_NUM(endpoint)] , arf,0);
//			pud->SubmitRequest(&urb);
			//Endpoints[ENDPOINT_NUM(endpoint)] = urb.OpenEndpoint.EndpointHandle;
//			return; // urb.OpenEndpoint.EndpointHandle;
//			}
//		}

//	}

	//intiliaze it again
  // Endpoints[ENDPOINT_NUM(endpoint)]=(void *) -1;
  //((PDEVICE_EXTENSION)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] = 0;



}


/*************************************************************************************
Function:   SlixdIn
Purpose:	create & send an IN packet, receive the data, return any errors
Params:     in Address --- the topology of the device to receive from (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to receive from 
			out data --- pointer to the buffer to receive data
			in out len --- pointer to max length of data buffer, receives size of data received
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdIn(_IN BYTE Address, _IN BYTE Endpoint, _OUT char * data, _IN _OUT DWORD * len, _IN BYTE USBInterface)
{	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG templen = 8;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	BYTE closeendpoint = Endpoint;
	int port, slot;
	__int64 maxwaittime;

	port = PORT_FROM_ADDRESS(Address);
	slot = SLOT_FROM_ADDRESS(Address);

	de = &gpDriverExtension->Nodes[port][slot][USBInterface];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		DBGPRINT(2,("SlixdIn: Port %d, Slot %d, pud==NULL\n", port, slot));
		*len = 0;
		return USBD_STATUS_ERROR;
	}

	if(!(de->flags & DF_CONNECTED)){
		DBGPRINT(2,("SlixdIn: de->DeviceFlags & DF_CONNECTED"));
		*len = 0;
		return USBD_STATUS_ERROR;
	}
	
	if(data == NULL) {
		if(len != NULL) *len = 0;
		return USBD_STATUS_ERROR;
	}

	if(Endpoint == 0) {
		DBGPRINT(3, ("ERROR! Can't send additional INs to endpoint 0\n"));
		*len = 0;
		return USBD_STATUS_ERROR;
	}

	Endpoint |= 0x80;

	ourendpoint = GetEndpoint(pud, Endpoint);

	if(ourendpoint == NULL && (ENDPOINT_NUM(Endpoint) != 0)) {
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		DBGPRINT(3, ("ourendpoint == NULL && Endpoint != 0\n"));
		if(len) *len = 0;
		return USBD_STATUS_ERROR;
	} 

	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) {		//isoch
		USBD_ISOCH_BUFFER_DESCRIPTOR bufd;

		bufd.Context = (void*)pud;
		bufd.FrameCount = 1;
		bufd.Pattern[0] = (USHORT)*len;
		bufd.Pattern[1] = 0;
		bufd.TransferBuffer = data;
		bufd.TransferComplete = IsochCompleteProc; 
		RtlZeroMemory(&urb, sizeof(URB));
		USB_BUILD_ISOCH_ATTACH_BUFFER((&urb.IsochAttachBuffer), ourendpoint, USBD_DELAY_INTERRUPT_0_MS, &bufd);
		maxwaittime = _WAIT;	//3.1 milliseconds

	} else {	//non-isoch
		*len = (*len + 63) & ~63;	//round up to the nearest 64 bytes so we don't get buffer overflows
	
		if(!*len) {	//len == 0
			DBGPRINT(3, ("*len == 0!!!\n"));
			*len = 64;
		}
	
		templen = *len;
	
		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(&urb.BulkOrInterruptTransfer,
			ourendpoint, data, templen, USB_TRANSFER_DIRECTION_IN, 
			CompleteProc, (void*)pud, TRUE);
		maxwaittime = _WAIT;	//roughly 3 milliseconds
		//(if a 64-byte packet comes back, ohci requests another one until our buffer is full)
	}
	gYouMayPass = 0;

	__int64 tim = gettsc();
	retcode = pud->SubmitRequest(&urb);

	while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }	//wait to time out, or for request to come back

	if((gettsc() - tim) > maxwaittime) {	//if we timed out
		pud->CancelRequest(&urb);			//cancel request
		while(!gYouMayPass) { }				//and wait for the thing to cancel
	}

	//we got a response!
	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n"
				"returned data size: %d, first 8 bytes = %016I64x\n", 
				retcode, urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}

	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { 
		//*len = *len //hope that we really got that much data back
	} else {
		*len = (USHORT)urb.BulkOrInterruptTransfer.TransferBufferLength;
	}

	//CloseEndpoint(pud, Endpoint, ourendpoint);
	CloseEndpoint(pud, closeendpoint, ourendpoint);

	return retcode;
}

/*************************************************************************************
Function:   SlixdOut
Purpose:	create & send an OUT packet, send the data, return any errors
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdOut(_IN BYTE Address, _IN BYTE Endpoint, _IN char * data, _IN DWORD len, _IN BYTE USBInterface)
{
	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG temp;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	int port, slot;
	__int64 maxwaittime;

	port = PORT_FROM_ADDRESS(Address);
	slot = SLOT_FROM_ADDRESS(Address);

	de = &gpDriverExtension->Nodes[port][slot][USBInterface];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		return USBD_STATUS_ERROR;
	}

	if(Endpoint == 0) {
		DBGPRINT(3,("ERROR! Can't send additional OUTs to endpoint 0\n"));
//		*len = 0;
		return USBD_STATUS_ERROR;
	}

	ourendpoint = GetEndpoint(pud, Endpoint);
	
	if(data == NULL) {
		if(len != 0) {
			return USBD_STATUS_ERROR;	//trying to send data that doesn't exist??
		}
	}

	//if(ourendpoint == NULL && Endpoint != 0) {
	if(ourendpoint == NULL && (ENDPOINT_NUM(Endpoint) != 0)) {                                           //changed by Bing from above line to this, this should be the same as SlixDIN().
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		return USBD_STATUS_ERROR;
	}


	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) {		//isoch
		USBD_ISOCH_BUFFER_DESCRIPTOR bufd;

		bufd.Context = (void*)pud;
		bufd.FrameCount = 1;
		bufd.Pattern[0] = (USHORT)len;
		bufd.Pattern[1] = 0;
		bufd.TransferBuffer = data;
		bufd.TransferComplete = IsochCompleteProc; 
		RtlZeroMemory(&urb, sizeof(URB));
		USB_BUILD_ISOCH_ATTACH_BUFFER((&urb.IsochAttachBuffer), ourendpoint, USBD_DELAY_INTERRUPT_0_MS, &bufd);
		maxwaittime = _WAIT;	//3.1 milliseconds

	} else {	//non-isoch

		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(&urb.BulkOrInterruptTransfer,
			ourendpoint, data, len, USB_TRANSFER_DIRECTION_OUT, 
			CompleteProc, (void*)pud, TRUE);
		maxwaittime = _WAIT;		//wait 3 milliseconds

	}
	gYouMayPass = 0;



	__int64 tim = gettsc();
	retcode = pud->SubmitRequest(&urb);

	while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }	//wait to time out, or for response

	if((gettsc() - tim) > maxwaittime) {
		pud->CancelRequest(&urb);
		while(!gYouMayPass) { }
	}

	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n", retcode));
			DBGPRINT(3, ("returned data size: %d, first 8 bytes = %016I64x\n", 
				urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}

	CloseEndpoint(pud, Endpoint, ourendpoint);

	return retcode;
}

/*************************************************************************************
Function:   SlixdSetup
Purpose:	create & send a SETUP packet, send the data, return any errors
note: more stuff may be needed to receive or send additional data...
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
			data2 --- pointer to buffer to receive or send data. OPT if data[6]==0
			len2 --- p to length of data2 if sending, p to max length if receiving, & 
				will receive length of data received. Not optional.
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdSetup(_IN BYTE Address, _IN BYTE Endpoint, _IN char * data, _IN DWORD len, 
					   _OPT _IN _OUT char * data2, _IN _OUT USHORT *len2, _IN BYTE USBInterface)
{
	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG temp;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	USHORT extlen;
	BYTE direction;
	int port, slot;
	__int64 maxwaittime;

	port = PORT_FROM_ADDRESS(Address);
	slot = SLOT_FROM_ADDRESS(Address);

	de = &gpDriverExtension->Nodes[port][slot][USBInterface];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		return USBD_STATUS_ERROR;
	}

	if(data == NULL) {
		DBGPRINT(1, ("data == NULL"));
		return USBD_STATUS_ERROR;
	} else if(len != 8) {
		DBGPRINT(1, ("Setup packets should be 8 bytes! len = %d, data = %016I64x, len2 = %d", len, *(INT64*)data, *len2));
		return USBD_STATUS_ERROR;
	} 

	extlen = (*(USHORT*)&data[6]); //get the length of the data to send/recv
	if(!len2) {
		DBGPRINT(1, ("Setup: len2 is NOT optional!"));
		return USBD_STATUS_ERROR;
	} else if(*len2 < extlen) {
		DBGPRINT(1, ("sending data without enough buffer length?? len2: %d, extlen: %d", *len2, extlen));
		return USBD_STATUS_ERROR;
	}

	if(*len2 > 2048) *len2 = 2048;	//can't send or expect too much data, due to ohci requrements

	if(*len2 > 0) {
		if(data2 == NULL) {
			DBGPRINT(1, ("data2 == NULL"));
			return USBD_STATUS_ERROR;
		}

		direction = (data[0] & 128) ? USB_TRANSFER_DIRECTION_IN : USB_TRANSFER_DIRECTION_OUT;
	} else {
		direction = 0;
	}

	ourendpoint = GetEndpoint(pud, Endpoint);

	if(ourendpoint == NULL && Endpoint != 0) {
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		return USBD_STATUS_ERROR;
	}
	
	RtlZeroMemory(&urb,sizeof(URB));
	USB_BUILD_CONTROL_TRANSFER(&urb.ControlTransfer,
		ourendpoint, data2, *len2, direction,		////////////////////data2
		CompleteProc, (void*)pud, TRUE,
		data[0], data[1], (*(USHORT*)&data[2]), (*(USHORT*)&data[4]), (*(USHORT*)&data[6]) );


	gYouMayPass = 0;
	__int64 tim = gettsc();
	retcode = pud->SubmitRequest(&urb);

    maxwaittime = _WAIT;        //wait 3 milliseconds
	
    while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }               //wait for 3 milliseconds, or for the response.

	if((gettsc() - tim) > maxwaittime) {
		pud->CancelRequest(&urb);
		while(!gYouMayPass) { }
	}

	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n", retcode));
			DBGPRINT(3, ("returned data size: %d, first 8 bytes = %016I64x\n", 
				urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}


	*len2 = (USHORT)urb.ControlTransfer.TransferBufferLength;

	CloseEndpoint(pud, Endpoint, ourendpoint);
	return retcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\USBdesc\slixd\slixdriver.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    islixd.cpp

Abstract:

    interface to the slixbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/

extern "C" {
#include <nt.h>
#include <ntos.h>
}


#include <scsi.h>
//#include <ntdddisk.h>

#include <xtl.h>

#include <usb.h>
#include <stdio.h>

#include "..\inc\i_slixdriver.h"
#include "..\inc\slixdriver.h"

ULONG               DebugFlags;     // DBGF_* Flags
ULONG               DebugLevel=5;     // Level of debug output
SLIX_DRIVER_EXTENSION gde = {0};	
SLIX_DRIVER_EXTENSION *	gpDriverExtension;
DEVICE_EXTENSION *	gInsertedDevices[20];
USHORT				gInsertedCount;


//the following mess allows slix to grab & talk to all devices
#define SLIX1_Init DriverInit
#define SLIX2_Init DriverInit
#define SLIX3_Init DriverInit
#define SLIX4_Init DriverInit
#define SLIX5_Init DriverInit
#define SLIX6_Init DriverInit
#define SLIX7_Init DriverInit
#define SLIX8_Init DriverInit
#define SLIX9_Init DriverInit
#define SLIX10_Init DriverInit



#define SLIX1_AddDevice SLIX_AddDevice
#define SLIX2_AddDevice SLIX_AddDevice
#define SLIX3_AddDevice SLIX_AddDevice
#define SLIX4_AddDevice SLIX_AddDevice
#define SLIX5_AddDevice SLIX_AddDevice
#define SLIX6_AddDevice SLIX_AddDevice
#define SLIX7_AddDevice SLIX_AddDevice
#define SLIX8_AddDevice SLIX_AddDevice
#define SLIX9_AddDevice SLIX_AddDevice
#define SLIX10_AddDevice SLIX_AddDevice

#define SLIX1_RemoveDevice SLIX_RemoveDevice
#define SLIX2_RemoveDevice SLIX_RemoveDevice
#define SLIX3_RemoveDevice SLIX_RemoveDevice
#define SLIX4_RemoveDevice SLIX_RemoveDevice
#define SLIX5_RemoveDevice SLIX_RemoveDevice
#define SLIX6_RemoveDevice SLIX_RemoveDevice
#define SLIX7_RemoveDevice SLIX_RemoveDevice
#define SLIX8_RemoveDevice SLIX_RemoveDevice
#define SLIX9_RemoveDevice SLIX_RemoveDevice
#define SLIX10_RemoveDevice SLIX_RemoveDevice


#define SLIXDEVICEPORT  (&SLIXDEVICEPORT_TABLE)
#define SLIXDEVICESLOT  (&SLIXDEVICESLOT_TABLE)
DECLARE_XPP_TYPE(SLIXDEVICEPORT)
DECLARE_XPP_TYPE(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX1_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX2_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX3_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX4_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX5_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX6_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX7_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX8_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX9_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX10_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
#define XBOX_DEVICE_CLASS_INPUT_DEVICE 0x58
#define XBOX_DEVICE_CLASS_XHAWK_DEVICE 0x78
USB_CLASS_DRIVER_DECLARATION(SLIX1_, USB_DEVICE_CLASS_AUDIO, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(SLIX1_, 1, XBOX_DEVICE_CLASS_XHAWK_DEVICE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX2_, USB_DEVICE_CLASS_COMMUNICATIONS, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX3_, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(SLIX3_, 1, XBOX_DEVICE_CLASS_INPUT_DEVICE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX4_, USB_DEVICE_CLASS_MONITOR, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX5_, USB_DEVICE_CLASS_PHYSICAL_INTERFACE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX6_, USB_DEVICE_CLASS_POWER, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX7_, USB_DEVICE_CLASS_PRINTER, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX8_, USB_DEVICE_CLASS_STORAGE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX9_, USB_DEVICE_CLASS_RESERVED, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX10_, USB_DEVICE_CLASS_VENDOR_SPECIFIC, 0xFF, 0xFF)
#pragma data_seg(".XPP$ClassAAASLIX") //ohci should load this before anything else
USB_CLASS_DECLARATION_POINTER(SLIX1_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(SLIX1_, 1)
USB_CLASS_DECLARATION_POINTER(SLIX2_)
USB_CLASS_DECLARATION_POINTER(SLIX3_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(SLIX3_, 1)
USB_CLASS_DECLARATION_POINTER(SLIX4_)
USB_CLASS_DECLARATION_POINTER(SLIX5_)
USB_CLASS_DECLARATION_POINTER(SLIX6_)
USB_CLASS_DECLARATION_POINTER(SLIX7_)
USB_CLASS_DECLARATION_POINTER(SLIX8_)
USB_CLASS_DECLARATION_POINTER(SLIX9_)
USB_CLASS_DECLARATION_POINTER(SLIX10_)
#pragma data_seg()


//apis we are replacing by over-writing xid.sys... xapi is still looking for these!
/*
extern "C" void XInputClose(int){}
extern "C" void XInputGetCapabilities(int,int){}
extern "C" void XInputGetState(int,int){}
extern "C" void XInputOpen(int,int,int,int){}
extern "C" void XInputPoll(int){}
extern "C" void XInputSetState(int,int){}
*/

URB CloseUrb[MAX_ENDPOINTS];                                                                                              //changed by Bing from 16 to 32
URB StopUrb[MAX_ENDPOINTS];

void KeepCode()
{
	return;
}

/*************************************************************************************
Function:   DriverInit
Purpose:	the actually useful entrypoint of the slixbox driver. Sets up lots of stuff
Params:     DriverObject --- the object slixboxdriver will use...
			RegistryPath --- irrelevant
Return:     STATUS_SUCCESS, or some error code
*************************************************************************************/
void
DriverInit (IUsbInit *pUsbInit)
{
    DBGPRINT(2, ("enter:  DriverInit\n"));    
    ULONG port, slot,USBInterface;
    UCHAR realMaxPorts = (UCHAR)XGetPortCount();

	gpDriverExtension = &gde;

	for (port = 0;port < MAX_PORTS; port++) 
	{
		for (slot = 0; slot < MAX_SLOTS; slot++) 
		{
			for (USBInterface = 0; USBInterface < MAX_INTERFACES; USBInterface++)
			{
				gpDriverExtension->Nodes[port][slot][USBInterface].Device = NULL;
			}
		}
    }
    


    //
    //  Allocate a whole bunch of resources, we don't
    //  care that much how much memory we take, and
    //  we don't want to run out.
    //
    USB_RESOURCE_REQUIREMENTS resourceRequirements;
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_DIRECT;
    resourceRequirements.MaxDevices = realMaxPorts;
    resourceRequirements.MaxCompositeInterfaces = 3;
    resourceRequirements.MaxControlEndpoints = 2;
    resourceRequirements.MaxBulkEndpoints = 2;
    resourceRequirements.MaxInterruptEndpoints = 2;    
    resourceRequirements.MaxControlTDperTransfer = 40;
    resourceRequirements.MaxBulkTDperTransfer = 40;
    resourceRequirements.MaxIsochEndpoints = 2;
    resourceRequirements.MaxIsochMaxBuffers = 5;
    pUsbInit->RegisterResources(&resourceRequirements);
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_HIGH_POWER;
    pUsbInit->RegisterResources(&resourceRequirements);
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_LOW_POWER;
    resourceRequirements.MaxDevices = realMaxPorts*2;
    pUsbInit->RegisterResources(&resourceRequirements);

    DBGPRINT(2, ("exit:  DriverInit\n"));    

    return;// status;
}

//callback for endpoint closes (below) to allow them to be asynchronous
VOID Arf (PURB urb, PVOID context)
{ }

/*************************************************************************************
Function:   SLIX_RemoveDevice
Purpose:	called by pnp when a device is unplugged. Removes that interface from our array
Params:     Device = the interface to talk to usbd
Return:     none
*************************************************************************************/

VOID SLIX_RemoveDevice (IN IUsbDevice *Device)
{
	HANDLE ourendpoints[MAX_ENDPOINTS];
	int i;

    DBGPRINT(2, ("enter: SLIX_RemoveDevice\n"));
	if(Device == NULL) {
		DBGPRINT(1, ("SLIX_RemoveDevice called with NULL Device!\n"));
		return;
	}

    PDEVICE_EXTENSION   pDevExt = (PDEVICE_EXTENSION) Device->GetExtension();

	if(pDevExt == NULL) {
		DBGPRINT(1, ("SLIX_RemoveDevice called for device that has already been removed!!\n"
			"IUsbDevice passed: %p. Port: %x\n", Device, Device->GetPort()))
	}

	pDevExt->fAvail = FALSE;

	pDevExt->flags = 0;

	pDevExt->Device = 0;


	if(pDevExt->Endpoints[0] == NULL) {	//-1 == closed, other == open
		RtlZeroMemory(&CloseUrb[0],sizeof(URB));
		USB_BUILD_CLOSE_DEFAULT_ENDPOINT((&CloseUrb[0].CloseEndpoint), Arf, 0);
		Device->SubmitRequest(&CloseUrb[0]);
	}
	for(i = 1; i < MAX_ENDPOINTS; i++)	{                                                                            //changed by Bing from 16 to 32
		if(pDevExt->Endpoints[i] != (void*)-1 && pDevExt->Endpoints[i] != (void*)NULL) {
			RtlZeroMemory(&CloseUrb[i],sizeof(URB));
			if(pDevExt->EndpointType[i] == 1) {
				RtlZeroMemory(&StopUrb[i],sizeof(URB));
				USB_BUILD_ISOCH_STOP_TRANSFER((&StopUrb[i].IsochStopTransfer), pDevExt->Endpoints[i]);
				Device->SubmitRequest(&StopUrb[i]);
				USB_BUILD_ISOCH_CLOSE_ENDPOINT((&CloseUrb[i].IsochCloseEndpoint), pDevExt->Endpoints[i], Arf, 0);
			} else {
				USB_BUILD_CLOSE_ENDPOINT((&CloseUrb[i].CloseEndpoint), pDevExt->Endpoints[i], Arf, 0);
			}
			Device->SubmitRequest(&CloseUrb[i]);
		}
	}

	for(i = 0; i < MAX_ENDPOINTS; i++) {
		pDevExt->Endpoints[i] = (void*)-1;
		pDevExt->EndpointType[i] = 0;
	}

	Device->SetExtension(NULL);
	Device->RemoveComplete();


	DBGPRINT(2, ("exit:  SLIX_RemoveDevice\n"));
}


void AddCompletionRoutine(PURB pUrb, PDEVICE_EXTENSION pDevExt)
{
	// wrap up after URB completes

	KIRQL	OldIrqLevel;
	ULONG	ulDevices;
	BYTE *	pTemp = (BYTE *) &pDevExt->XidDescriptor;
	BYTE bByte = * pTemp;
	BYTE bByte2 = * (pTemp +1);

	IUsbDevice * pDevice = pDevExt->Device;
	
	pDevice->AddComplete(USBD_STATUS_SUCCESS);
	pDevExt->bNoOpt = bByte | bByte2;
	pDevExt->fGotCaps = FALSE;
	pDevExt->fAvail = TRUE;

	OldIrqLevel = KeRaiseIrqlToDpcLevel();
	gInsertedDevices[gInsertedCount++] = pDevExt;
	KeLowerIrql(OldIrqLevel);

	DBGPRINT(1,("Submit Request Status = %x\n",pUrb->Header.Status));

}

/*************************************************************************************
Function:   SLIX_AddDevice
Purpose:	the actually useful entrypoint of the slixbox driver. Sets up lots of stuff
Params:     DriverObject --- the object slixboxdriver will use...
			RegistryPath --- irrelevant
Return:     STATUS_SUCCESS, or some error code
*************************************************************************************/
VOID SLIX_AddDevice (IN IUsbDevice *Device)
{
    PSLIX_DRIVER_EXTENSION driverExtension;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION fdoDeviceExtension;
	ULONG ulPort;
    BYTE bSlot,bUSBInterface;
	URB urb;
	int i;
	UCHAR ucEndpointType;
	
    const USB_INTERFACE_DESCRIPTOR  *pInterfaceDescriptor;
	const USB_DEVICE_DESCRIPTOR8 *	pDeviceDescriptor;
	const USB_CONFIGURATION_DESCRIPTOR * pConfigurationDescriptor;
	driverExtension = gpDriverExtension;

	DBGPRINT(2, ("enter: SLIX_AddDevice\n"));
	ASSERT(Device != NULL /* SLIX_RemoveDevice */);

	// get topology so we know where we are plugged in
	ulPort = Device->GetPort();
    bSlot = 0;
    if(ulPort >= 16)
    {
        bSlot = 1;
        ulPort -= 16;
    }

	
	pInterfaceDescriptor = Device->GetInterfaceDescriptor();
	bUSBInterface = pInterfaceDescriptor->bInterfaceNumber;

	DBGPRINT(3, ("interface Class: %d, interface Subclass: %d , interface number: %d\n", 
		pInterfaceDescriptor->bInterfaceClass,
		pInterfaceDescriptor->bInterfaceSubClass,
		bUSBInterface));

	//if it's an MU or hawk, move it to the next port...
	//(if we didn't do this, it would be impossible ot distinguish top-slot from control pad)
	if((pInterfaceDescriptor->bInterfaceClass != USB_DEVICE_CLASS_HUMAN_INTERFACE) 
		&& (pInterfaceDescriptor->bInterfaceClass != USB_DEVICE_CLASS_PHYSICAL_INTERFACE)
		&& (pInterfaceDescriptor->bInterfaceClass != XBOX_DEVICE_CLASS_INPUT_DEVICE)) {
		bSlot++;
	}	

	fdoDeviceExtension = &driverExtension->Nodes[ulPort][bSlot][bUSBInterface];

	fdoDeviceExtension->bPort = (BYTE) ulPort;
	fdoDeviceExtension->bSlot = bSlot;
	fdoDeviceExtension->bInterfaceNumber = bUSBInterface;
	DBGPRINT(3, ("Topology:  port: %d, slot %d, interface %d\n", ulPort, bSlot, bUSBInterface));
	fdoDeviceExtension = &driverExtension->Nodes[ulPort][bSlot][bUSBInterface];
	fdoDeviceExtension->fAvail = FALSE;
	// save interface, configuration and device descriptors
	memcpy(&fdoDeviceExtension->InterfaceDescriptor,pInterfaceDescriptor,sizeof(USB_INTERFACE_DESCRIPTOR));
	pConfigurationDescriptor = Device->GetConfigurationDescriptor();
	memcpy(&fdoDeviceExtension->ConfigurationDescriptor,pConfigurationDescriptor,sizeof(USB_CONFIGURATION_DESCRIPTOR));
	memcpy(&fdoDeviceExtension->bConfigData,pConfigurationDescriptor,pConfigurationDescriptor->wTotalLength);
	

//	pDeviceDescriptor = Device->GetDeviceDescriptor();
//	memcpy(&fdoDeviceExtension->DeviceDescriptor, pDeviceDescriptor,sizeof(USB_DEVICE_DESCRIPTOR));
	// Set our DeviceExtension in our CUSB class data
	DBGPRINT(3, ("Device->SetExtension\n"));
	Device->SetExtension(fdoDeviceExtension);


	for(i = 0; i < MAX_ENDPOINTS; i++) {
		fdoDeviceExtension->Endpoints[i] = (void*)-1;
		fdoDeviceExtension->EndpointType[i] = 0;
	}

	// save our device class pointer
	fdoDeviceExtension->Device = Device;
	fdoDeviceExtension->flags |= DF_CONNECTED;

	Device->SetClassSpecificType(1);


	USBD_STATUS UsbdStatus = USBD_STATUS_SUCCESS;
		
    //
    //  Get XID Descriptor
    //
    USB_BUILD_CONTROL_TRANSFER(
        (PURB_CONTROL_TRANSFER)&fdoDeviceExtension->Urb,
        NULL, //Default endpoint
        (PVOID)&fdoDeviceExtension->XidDescriptor,
        sizeof(XID_DESCRIPTOR),
        USB_TRANSFER_DIRECTION_IN,
        (PURB_COMPLETE_PROC) AddCompletionRoutine,		
        fdoDeviceExtension,
        TRUE,
        (USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE),
        USB_REQUEST_GET_DESCRIPTOR,
        XID_DESCRIPTOR_TYPE,
        pInterfaceDescriptor->bInterfaceNumber,
        sizeof(XID_DESCRIPTOR)
        );

	UsbdStatus = Device->SubmitRequest(&fdoDeviceExtension->Urb);
	DBGPRINT(2, ("exit:  SLIX_AddDevice\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\USBdesc\USBDescApp\USBDescApp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    USBDesc.h

Abstract:

    Definitions for USB Descriptor application

Author:

    Dennis Krueger (a-denkru) November 2001

Revision History:

--*/
#ifndef __USBDESC_H_
#define __USBDESC_H_



#include <ntos.h>


#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include <XBApp.h>
#include <XBInput.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBSound.h>
#include <XBStopWatch.h>
#include <xboxp.h>
#include <xconfig.h>
#include <usb.h>

#ifndef UNICODE
#define UNICODE
#endif

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

#define MAX_LINES 100

#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }



class CTextScreenLine
{
public:
	
	 FLOAT m_sx;
	 FLOAT m_sy;
	 DWORD m_dwColor;
	 WCHAR* m_strText;
	 DWORD m_dwFlags;


	 CTextScreenLine();
	 CTextScreenLine(float sx, float sy, DWORD Color, WCHAR * TextStr, DWORD dwFlags=0);

	 ~CTextScreenLine() {;};  // do nothing destructor
};


class CTextScreenArray
{
public:
	CTextScreenArray();
	~CTextScreenArray();
	int Add(CTextScreenLine *);
	int Replace(CTextScreenLine *,int Index);
	CTextScreenLine * GetLine(int Index);	
	int GetLineCount();
		

private:
	
	CTextScreenLine * m_TextLines[MAX_LINES]; // rather than make this array dynamic
								      // I'm just making it a static "reasonable" size
	int m_LineCount;

};


#endif //!defined (__SCREENTEST_H_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\commontest.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         L"Z"
#define TITLE_DRIVE         L"T"
#define USER_DRIVE          L"U"
#define BASE_DRIVE          CACHE_DRIVE

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    xStartVariation(hLog, variant);
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    xStartVariation(hLog, aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

#define ALLCHARS L"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f" \
    L"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

// common numbers
static DWORD dwBogus = 0xF000BAAA;
static ULARGE_INTEGER ulBogus = { 0xF000BAAA, 0xF000BAAA };

// common HANDLE parameters
static HANDLE hNull = NULL;
static HANDLE hBogus = (void*)0xF000BAAA;

// common string parameters
static LPCTSTR lpNull = NULL;
static LPCTSTR lpEmpty = L"";
static LPCTSTR lpSpace = L" ";
static LPCTSTR lpBogus = (const unsigned short*)0xF000BAAA;
static LPCTSTR lpCurrentDir = L".";
static LPCTSTR lpParentDir = L"..";
static LPCTSTR lpUnderMaxPathDir = BASE_DRIVE L":\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory";
static LPCTSTR lpOverMaxPathDir = BASE_DRIVE L":\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory";

// device names
static WCHAR *deviceNames[] = {
    BASE_DRIVE L":\\prn",
    BASE_DRIVE L":\\aux",
    BASE_DRIVE L":\\con",
    BASE_DRIVE L":\\lpt1",
    L"\\\\?\\prn",
    L"\\\\?\\aux",
    L"\\\\?\\con",
    L"\\\\?\\lpt1",
    L"\\\\lpt1",
    L"CONOUT$",
    L"CONIN$",
    };

// invalid file names
static WCHAR *invalidFileNames[] = {
    BASE_DRIVE L":\\abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd",
    BASE_DRIVE L":\\)#+l+RI+Td<\x12>",
    BASE_DRIVE L":\\~`!@#$%^&*()-=_+[]{}\\|';:\",./?><",
    BASE_DRIVE L":\\*",
    BASE_DRIVE L":\\?",
    BASE_DRIVE L":\\" ALLCHARS,
    BASE_DRIVE L":\\abc?",
    BASE_DRIVE L":\\abc>def",
    BASE_DRIVE L":\\abc<def",
    BASE_DRIVE L":\\abc|def",
    BASE_DRIVE L":\\abc:def",
    BASE_DRIVE L":\\abc\"def",
    BASE_DRIVE L":\\>",
    BASE_DRIVE L":\\<",
    BASE_DRIVE L":\\:",
    BASE_DRIVE L":\\|",
    BASE_DRIVE L":\\\"",
    BASE_DRIVE L":\\..\\abcdef",
    BASE_DRIVE L":\\.\\..\\abcdef",
    BASE_DRIVE L":\\..\\..\\..\\..\\..\\..\\..\\..\\..\\abcdef",
    BASE_DRIVE L":\\abc" BASE_DRIVE L":\\def",
    BASE_DRIVE L":\\new\nline",
    BASE_DRIVE L":\\newline\n",
    BASE_DRIVE L":\\Carriage\rreturn",
    BASE_DRIVE L":\\Carriagereturn\r",
    BASE_DRIVE L":\\\ttab",
    BASE_DRIVE L":\\tab\t",
    BASE_DRIVE L":\\\abell",
    BASE_DRIVE L":\\bell\a",
    BASE_DRIVE BASE_DRIVE L":\\abc",
    BASE_DRIVE L"::\\abc",
    BASE_DRIVE L"abc",
    BASE_DRIVE L".",
    BASE_DRIVE L"..",
    BASE_DRIVE L" ",
    L"\\\\?\\" BASE_DRIVE L":\\)#+l+RI+Td<\x12>",
    L"\\\\?\\" BASE_DRIVE L":\\~`!@#$%^&*()-=_+[]{}\\|';:\",./?><",
    L"\\\\?\\" BASE_DRIVE L":\\*",
    L"\\\\?\\" BASE_DRIVE L":\\?",
    L"\\\\?\\" BASE_DRIVE L":\\" ALLCHARS,
    L"\\\\?\\" BASE_DRIVE L":\\..\\abcdef",
    L"\\\\?\\" BASE_DRIVE L":\\.\\..\\abcdef",
    L"\\\\?\\" BASE_DRIVE L":\\new\nline",
    L"\\\\?\\" BASE_DRIVE L":\\Carriage\rreturn",
    L"\\\\?\\" BASE_DRIVE L":\\\ttab",
    L"\\\\?\\" BASE_DRIVE BASE_DRIVE L":\\abc",
    L"\\\\?\\" BASE_DRIVE L"::\\abc",
    L"\\\\?\\" BASE_DRIVE L":\\\\abc",
    L"\\\\?\\" BASE_DRIVE L"abc",
    L"\\\\?\\abc",
    L"\\\\?\\ ",
    L"\\\\?\\/",
    L"\\\\?\\\\",
    L"\\\\?\\.",
    L"\\\\?\\..",
    L" ",
    L"/",
    L"\\",
    L".",
    L".."
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\USBdesc\USBDescApp\USBDescApp.cpp ===
//-----------------------------------------------------------------------------
// File: USBDesc.cpp
//
// Desc: General purpose reporting tool for USB peripherals 
//
// Hist: November 2001 - Created
//
//
// Author:  Dennis Krueger <a-denkru>
//
// 
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <process.h>
#include "USBDescApp.h"
#include "draw.h"
#include <stdlib.h>
#include <usb.h>
#include "..\inc\i_slixdriver.h"	// shared header with slixd
#include "..\inc\slixdriver.h"		// shared header with slixd


#define WHITECOLOR 0xffffffff
#define CRIMSONCOLOR 0xffDC143C
//#define TITLECOLOR	0xffffd700
#define TITLECOLOR	0xff87CEFA


// Classes for saving and text screens 
// support methods for TextScreenLine and TextScreenArray 
CTextScreenLine::CTextScreenLine()
{
	m_sx = 0;
	m_sy = 0;
	m_dwColor = 0;
	m_strText = NULL;
	m_dwFlags = 0;
}

CTextScreenLine::CTextScreenLine(float sx, float sy, DWORD Color, WCHAR * pTextStr, DWORD dwFlags)
{
	m_sx = sx;
	m_sy = sy;
	m_dwColor = Color;
	m_strText = pTextStr;
	m_dwFlags = dwFlags;
};



CTextScreenArray::CTextScreenArray()
{
	m_LineCount = 0;
}


CTextScreenArray::~CTextScreenArray()
{
	;
}



int CTextScreenArray::Add(CTextScreenLine * pThisLine)
{
	if(m_LineCount >= MAX_LINES) return -1;
	m_TextLines[m_LineCount] = pThisLine;
	m_LineCount++;
	return m_LineCount-1;  // return index
}

int CTextScreenArray::Replace(CTextScreenLine * pThisLine, int Index)
{
	if(Index >= MAX_LINES) return -1;
	m_TextLines[Index] = pThisLine;
	return Index;  // return index
}

int CTextScreenArray::GetLineCount()
{
	return m_LineCount;
}

CTextScreenLine *
CTextScreenArray::GetLine(int Index)
{
	if(Index >= m_LineCount) return NULL; // out of range
	return m_TextLines[Index];
}


//-----------------------------------------------------------------------------
// Name: class CInputTestApp
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CUtilityApp 
{
public:
    CUtilityApp();
	~CUtilityApp();

    virtual HRESULT Initialize();
	virtual void Run();

	CTextScreenArray	m_ThisScreen;

	BOOL	m_fStopRender;
	BOOL	m_fStopRefresh;
	HANDLE  m_hSynchRender;
	HANDLE  m_hSynchRefresh;
	BOOL	m_LivePorts[4];

};


DWORD WINAPI Render(void * pParam);
DWORD WINAPI Refresh(void * pParam);

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    KeepCode(); // do nothing function to force linker not to throw away as
				// ... uncalled the functions in the Slix Driver

	XInitDevices(0,NULL); // initialize the devices

	drInit();
	// find all attached controllers
	Sleep(2000);  // delay a couple seconds to allow emumeration to complete

	while(1) // run until rebooted
	{

		CUtilityApp * xbApp = new CUtilityApp();
		if( FAILED( xbApp->Initialize() ) )
			return;
		drCls();
		drShowScreen();
		xbApp->Run();
		delete xbApp; // end of test for this controller

	}
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CInputTestApp class
//-----------------------------------------------------------------------------
CUtilityApp::CUtilityApp() 
{
;
}

CUtilityApp::~CUtilityApp()
{
}

void CompleteRequest(PURB pUrb, KEVENT * pEvent)
{

    KeSetEvent(pEvent, IO_NO_INCREMENT, FALSE);
	KdPrint(("URB Completion Status: 0x%x\n",pUrb->Header.Status));


	
}

BOOL
GetXidCapabilitiesOut(PDEVICE_EXTENSION pDevExt)
{
	IUsbDevice * pDevice = pDevExt->Device;
    KEVENT		event;
	URB_CONTROL_TRANSFER	urb;
    //
    //  Build the URB
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    USB_BUILD_CONTROL_TRANSFER(
            &urb,
            NULL,
            (PVOID)pDevExt->bCapsOutBuff/*(&pDevExt->InputCaps.Out-2) */,
            sizeof(XINPUT_RUMBLE)+2,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)CompleteRequest,
            &event,
            TRUE,
            USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
            XID_COMMAND_GET_CAPABILITIES,
            0x0200,
            pDevExt->InterfaceDescriptor.bInterfaceNumber,
            sizeof(XINPUT_RUMBLE)+2
            );

		pDevice->SubmitRequest((PURB) &urb);

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
		return TRUE;


}

BOOL
GetXidCapabilitiesIn(PDEVICE_EXTENSION pDevExt)
{
	IUsbDevice * pDevice = pDevExt->Device;
	URB_CONTROL_TRANSFER urb;
	KEVENT event;

   //
    //  Build the URB
    //
    USB_BUILD_CONTROL_TRANSFER(
            &urb,
            NULL,
            (PVOID)(pDevExt->bCapsInBuff /* &pDevExt->InputCaps.In -2*/),
            sizeof(XINPUT_GAMEPAD)+2,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)CompleteRequest,
            &event,
            TRUE,
            USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
            XID_COMMAND_GET_CAPABILITIES,
            0x0100,
             pDevExt->InterfaceDescriptor.bInterfaceNumber,
            sizeof(XINPUT_GAMEPAD)+2
            );
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    pDevice->SubmitRequest((PURB)&urb);

    //
    //  Wait for transfer to complete
    //
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
	return TRUE;

}

BOOL
GetDeviceDescriptor(PDEVICE_EXTENSION pDevExt)
{
	IUsbDevice * pDevice = pDevExt->Device;
    KEVENT		event;
	URB_CONTROL_TRANSFER	urb;
    //
    //  Build the URB
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    USB_BUILD_CONTROL_TRANSFER(
            &urb,
            NULL,
            (PVOID)&pDevExt->DeviceDescriptor/*(&pDevExt->InputCaps.Out-2) */,
            sizeof(USB_DEVICE_DESCRIPTOR),
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)CompleteRequest,
            &event,
            TRUE,
            USB_DEVICE_TO_HOST ,
            USB_REQUEST_GET_DESCRIPTOR,
            0x0100,
            pDevExt->InterfaceDescriptor.bInterfaceNumber,
            sizeof(USB_DEVICE_DESCRIPTOR)
            );

	pDevice->SubmitRequest((PURB) &urb);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
	if(urb.Hdr.Status != 0)
	{
		
		pDevExt->DeviceDescriptor.bLength = 0xff; // signal failure to output routine
		*(LONG *) &pDevExt->DeviceDescriptor.bcdUSB = urb.Hdr.Status;
	}
	return TRUE;


}


void
CUtilityApp::Run()
{
	HANDLE	hResult;
	DEVICE_EXTENSION * pDevExt;
	DEVICE_EXTENSION * dePorts[2] = {0,0};
	BOOL	fResult;
	URB		Urb;
	BYTE	bPort,bSlot,bInterfaceNumber;

// spawn a refresh thread so we don't need to maintain that either
	m_fStopRefresh = FALSE;

	hResult = CreateThread(NULL,0,Refresh,this,0,NULL);
	if(NULL == hResult)
	{
		DWORD dwResult = GetLastError();
		return;
	}
	Sleep(0); // allow refresh thread to run

// spawn the render thread so we don't need to maintain it
	m_fStopRender = FALSE;
	hResult = CreateThread(NULL,0,Render,this,0,NULL);
	if(NULL == hResult)
	{
		DWORD dwResult = GetLastError();
		return;
	}
	while(1)
	{
		// check for new device arrival
		if(gpDriverExtension)
		{
			if( 0 != gInsertedCount)
			{
				// got a new device
				
				// get device extension
				KIRQL OldIrql = KeRaiseIrqlToDpcLevel();
				pDevExt = gInsertedDevices[--gInsertedCount];
				KeLowerIrql(OldIrql);

				bPort = pDevExt->bPort;
				bSlot = pDevExt->bSlot;
				bInterfaceNumber = pDevExt->bInterfaceNumber;
				IUsbDevice * pDevice = pDevExt->Device;
				if(FALSE == pDevExt->fGotCaps && TRUE == pDevExt->fAvail)
				{

					// we're going to fill in capabilities and descriptor, open control pipe
					USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)&Urb);
					USBD_STATUS status = pDevice->SubmitRequest(&Urb);
				}

				if(0 == bSlot)
				{
					// got a port, check if already handling
					if(dePorts[bPort] == NULL)
					{
						// got a new port (controller)							
						dePorts[bPort] = pDevExt;
					}
					// check if add device is completed
					// have we gotten our capabilities info?
					if(FALSE == pDevExt->fGotCaps && TRUE == pDevExt->fAvail)
					{
						// get capabilities, must be done in the order, first in then out
						// ... the bottom of the out buffer is overwritten by the in call

						fResult = GetXidCapabilitiesIn(pDevExt);
						if(FALSE == fResult)
						{
							// report failure of get In capabilities
						}
						fResult = GetXidCapabilitiesOut(pDevExt);
						if(FALSE == fResult)
						{
							// report failure of get Out Capabilities
						}
					} //  if deGotCaps
				} // if 0 == slot
				// Have we filled in the device descriptor for this device?
				if(FALSE == pDevExt->fGotCaps && TRUE == pDevExt->fAvail)
				{
					fResult = GetDeviceDescriptor(pDevExt);
					if(FALSE == fResult)
					{
						// report failure of get Descriptor
					}
					// finally close control pipe
					// we're going to fill in capabilities and descriptor, open control pipe
					USB_BUILD_CLOSE_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)&Urb.CloseEndpoint,NULL,NULL);
					USBD_STATUS status = pDevice->SubmitRequest(&Urb);
				}
				pDevExt->fGotCaps = TRUE;
			} //  if device						
		} // gpDriverExtension
	} // while(1)

	m_fStopRefresh = TRUE; // turn off refresh
	m_fStopRender = TRUE; // stop rendering

	// wait for refresh and render to quit
	WaitForSingleObject(m_hSynchRefresh,INFINITE);
	WaitForSingleObject(m_hSynchRender,INFINITE);
	
	return;



}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CUtilityApp::Initialize()
{

	m_fStopRender = FALSE; // init flags
	m_fStopRefresh = FALSE;
    // init drawing from cpxlib
    // locate the controller to initialize
	m_hSynchRefresh = CreateEvent(NULL,FALSE,FALSE,NULL);
	if(NULL == m_hSynchRefresh) return E_FAIL;
	m_hSynchRender = CreateEvent(NULL,FALSE,FALSE,NULL);
	if(NULL == m_hSynchRender) return E_FAIL;
	for(int i = 0; i < 4; i++)
	{
		m_LivePorts[i] = FALSE;
	}


    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
DWORD
WINAPI Refresh(void * pThis)
{
	
	CUtilityApp * pApp = (CUtilityApp *) pThis;
	// make mask for mu test
	while(FALSE == pApp->m_fStopRefresh)
	{
		// do periodic activity
		Sleep(0); // release quantum
	}
	SetEvent(pApp->m_hSynchRefresh); // inform main loop we're done

	return S_OK;
}


USHORT MakeChars(BYTE bByte)
{
	USHORT usResult;
	BYTE bLNibble,bHNibble;

	bLNibble = bByte & 0x0f;
	bHNibble = bByte >> 4;
	if(bHNibble < 10)
	{
		usResult = bHNibble + 0x30;
	} else
	{
		usResult = bHNibble + 0x41 - 0x0a;
	}
	usResult <<= 8;
	if(bLNibble < 10)
	{
		usResult += bLNibble + 0x30;
	} else
	{
		usResult += bLNibble + 0x41 - 0x0a;
	}
	return usResult;
}

BOOL MakeWStringOfBytes(BYTE * pInBuff,int iInLen, WCHAR * pOutBuff, int iOutLen)
{
	USHORT	usByteChars;
	USHORT * pTemp = (USHORT *) pOutBuff; // going to move two chars at a time
	if(iOutLen < (iInLen * 4) + 2) return FALSE;
	for(int i = 0; i < iInLen; i++)
	{
		// get byte
		usByteChars = MakeChars(pInBuff[i]);

		*pTemp++ =(WCHAR) (usByteChars >> 8); // upper character
		*pTemp++ = (WCHAR) (usByteChars & 0xff); // lower character

	}
	pTemp[i] = 0x00; // terminate string
	return TRUE;
}


void Spacify(WCHAR * pBuffer)
{
	WCHAR	WorkBuff[1000] = {0};
	WCHAR	wcTemp[3];
	WCHAR	*pTemp;
	int		iLen,iValue;
	pTemp = pBuffer;
	WCHAR	*pWork = WorkBuff;
	wcTemp[2] = 0x00; // null terminator

	while(1)
	{
		wcTemp[0] = pTemp[0]; // get first char of length byte; example 0x0030 0x0039 = len 0x09
		wcTemp[1] = pTemp[1]; // get second char of length byte
		if(0 == wcTemp[0]) break; // done if hit string terminator
		iLen = _wtoi(wcTemp); // length of this descriptor
		memcpy(pWork,pTemp,iLen*4);
		pWork += iLen*2;
		pTemp += iLen*2;
		*pWork++ = L' ';
	}
	// finished spacing all descriptor, copy back over top of original
	// get new length
	wcscpy(pBuffer,WorkBuff);
	return;
}


//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
DWORD WINAPI Render(void * pThis)
{
	BYTE * pTemp;
	CUtilityApp * pApp = (CUtilityApp *) pThis;
// setup frame rate
	WCHAR wcBuffer[500];
	DEVICE_EXTENSION * pDevExt;
	USB_DEVICE_DESCRIPTOR * pDevDesc;
	USB_CONFIGURATION_DESCRIPTOR * pCfgDesc;
	USB_INTERFACE_DESCRIPTOR * pIDesc;
	float BaseY;

	while(FALSE == pApp->m_fStopRender)
	{
		Sleep(100); // refresh 10 times a second
		drCls();
		drSetSize(50, 100, WHITECOLOR, 0xff000000); //set the color
		drPrintf(200,50,L"USB Peripheral Descriptors");
		drSetSize(50, 100, TITLECOLOR, 0xff000000); //set the color
		if(gpDriverExtension)
		{
			BOOL fSlotOnly = FALSE;
			int	 iDeviceCount = 0;
			// first check for any device other than controllers to control page display
			for(int port = 0; port < 2; port++) // only handling first two ports
			{
				for(int slot = 0; slot < 3; slot++) // only handling first two slots
				{
					for(int InterfaceNumber = 0; InterfaceNumber < 2; InterfaceNumber++)
					{
						if(gpDriverExtension->Nodes[port][slot][InterfaceNumber].Device && slot)
						{
							fSlotOnly = TRUE;
						}
					}
				}
			}

			for(int port = 0; port < 2; port++) // only handling first two ports
			{
				for(int slot = 0; slot < 3; slot++) // only handling first two slots
				{
					for(int InterfaceNumber = 0; InterfaceNumber < 2; InterfaceNumber++)
					{
						if(gpDriverExtension->Nodes[port][slot][InterfaceNumber].Device && iDeviceCount < 2)
						{

							pDevExt = &gpDriverExtension->Nodes[port][slot][InterfaceNumber];
							pDevDesc = &pDevExt->DeviceDescriptor;
							// is this a controller or an MU?

							memset(wcBuffer,0x00,sizeof(wcBuffer));
							if(0 == slot && FALSE == fSlotOnly) // got a controller and no slot-based device
							{
								BaseY = (float) 60 + (170 * iDeviceCount);
								swprintf(wcBuffer,L"Port %d",port);
								drPrintf(50, BaseY,wcBuffer);
								iDeviceCount++;
								// display device descriptor
								memset(wcBuffer,0x00,sizeof(wcBuffer));
								if(pDevDesc->bLength == 0xff) // failure signal
								{
									swprintf(wcBuffer,L"Device Desc:  Failure! Status = %x",*(ULONG *)&pDevDesc->bcdUSB);
								} else
								{
									swprintf(wcBuffer,
										L"Device Desc: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
										pDevDesc->bLength,
										pDevDesc->bDescriptorType,
										*(PBYTE)(&pDevDesc->bcdUSB),
										*((PBYTE)(&pDevDesc->bcdUSB)+1),
										pDevDesc->bDeviceClass,
										pDevDesc->bDeviceSubClass,
										pDevDesc->bDeviceProtocol,
										pDevDesc->bMaxPacketSize0,
										*(PBYTE)(&pDevDesc->idVendor),
										*((PBYTE)(&pDevDesc->idVendor)+1),
										*(PBYTE)(&pDevDesc->idProduct),
										*((PBYTE)(&pDevDesc->idProduct)+1),
										*(PBYTE)(&pDevDesc->bcdDevice),
										*((PBYTE)(&pDevDesc->bcdDevice)+1),
										pDevDesc->iManufacturer,
										pDevDesc->iProduct,
										pDevDesc->iSerialNumber,
										pDevDesc->bNumConfigurations
										);
								}

								drPrintf(50,BaseY + 20,wcBuffer);


								// display configuration descriptors
								// get a pointer to the descriptor data
								pCfgDesc = &pDevExt->ConfigurationDescriptor; 
								int iCfgLen = pCfgDesc->wTotalLength; // get the total length
								// new logic starts here
								memset(wcBuffer,0x00,sizeof(wcBuffer));
								MakeWStringOfBytes((BYTE *) pDevExt->bConfigData,iCfgLen,wcBuffer,sizeof(wcBuffer));
								Spacify(wcBuffer);  // add spaces between descriptors
								// now display bytes in WcBuffer 32 chars at a time
								int iChars = wcslen(wcBuffer);
								int iNumLines = iChars / 32;
								int LineInc = 40;
								drPrintf(50,BaseY+LineInc,L"Config Data:",0);
								WCHAR wcLineBuffer[50];
								WCHAR * pCurPtr = wcBuffer;
								for(int i = 0; i < iNumLines; i++)
								{
									memset(wcLineBuffer,0x00,sizeof(wcLineBuffer));
									memcpy(wcLineBuffer,pCurPtr,64);
									pCurPtr +=32;
									drPrintf(180,BaseY+LineInc,wcLineBuffer,0);
									LineInc += 20;
								}
								// do partial last line
								int iRem = iChars % 32;
								if(iRem)
								{
									memset(wcLineBuffer,0x00,sizeof(wcLineBuffer));
									memcpy(wcLineBuffer,pCurPtr,iRem*2);
									drPrintf(180,BaseY+LineInc,wcLineBuffer,0);
								}
								
								
								// print XID data
								memset(wcBuffer,0x00,sizeof(wcBuffer));
								pTemp = (BYTE *) &pDevExt->XidDescriptor;
								MakeWStringOfBytes(pTemp,sizeof(XID_DESCRIPTOR),wcBuffer,sizeof(wcBuffer));
								LineInc += 20;
								drPrintf(50,BaseY+LineInc,L"XID Desc:");
								drPrintf(180,BaseY+LineInc,wcBuffer,0);

								// print Capabilities
								memset(wcBuffer,0x00,sizeof(wcBuffer));
								pTemp = (BYTE *) pDevExt->bCapsInBuff /*&pDevExt->InputCaps.In*/;
								MakeWStringOfBytes(pTemp,sizeof(XINPUT_GAMEPAD)+2,wcBuffer,sizeof(wcBuffer));
								LineInc += 20;
								drPrintf(50,BaseY+LineInc,L"Input Caps:");
								drPrintf(180,BaseY+LineInc,wcBuffer);

								memset(wcBuffer,0x00,sizeof(wcBuffer));
								pTemp = (BYTE *) pDevExt->bCapsOutBuff /*&pDevExt->InputCaps.Out */;
								MakeWStringOfBytes(pTemp,sizeof(XINPUT_RUMBLE)+2,wcBuffer,sizeof(wcBuffer));
								LineInc += 20;
								drPrintf(50,BaseY+LineInc,L"Output Caps:");
								drPrintf(180,BaseY+LineInc,wcBuffer);

							} else if(slot)
							{
								// got other than controller
								swprintf(wcBuffer,L"Port %d - Slot %d",port,slot);
								BaseY = (float) 100 + (150 * iDeviceCount);
								drPrintf(50,BaseY,wcBuffer);
								iDeviceCount++;
							
								memset(wcBuffer,0x00,sizeof(wcBuffer));
								if(pDevDesc->bLength == 0xff) // failure signal
								{
									swprintf(wcBuffer,L"Device Desc:  Failure! Status = %x",*(ULONG *)&pDevDesc->bcdUSB);
								} else
								{
									swprintf(wcBuffer,
										L"Device Desc: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
										pDevDesc->bLength,
										pDevDesc->bDescriptorType,
										*(PBYTE)(&pDevDesc->bcdUSB),
										*((PBYTE)(&pDevDesc->bcdUSB)+1),
										pDevDesc->bDeviceClass,
										pDevDesc->bDeviceSubClass,
										pDevDesc->bDeviceProtocol,
										pDevDesc->bMaxPacketSize0,
										*(PBYTE)(&pDevDesc->idVendor),
										*((PBYTE)(&pDevDesc->idVendor)+1),
										*(PBYTE)(&pDevDesc->idProduct),
										*((PBYTE)(&pDevDesc->idProduct)+1),
										*(PBYTE)(&pDevDesc->bcdDevice),
										*((PBYTE)(&pDevDesc->bcdDevice)+1),
										pDevDesc->iManufacturer,
										pDevDesc->iProduct,
										pDevDesc->iSerialNumber,
										pDevDesc->bNumConfigurations
										);
								}


								drPrintf(50,BaseY + 20,wcBuffer);

								// display configuration descriptors
								// get a pointer to the descriptor data
								pCfgDesc = &pDevExt->ConfigurationDescriptor; 
								int iCfgLen = pCfgDesc->wTotalLength; // get the total length
								// new logic starts here
								memset(wcBuffer,0x00,sizeof(wcBuffer));
								MakeWStringOfBytes((BYTE *) pDevExt->bConfigData,iCfgLen,wcBuffer,sizeof(wcBuffer));
								Spacify(wcBuffer);  // add spaces between descriptors
								// now display bytes in WcBuffer 32 chars at a time
								int iChars = wcslen(wcBuffer);
								int iNumLines = iChars / 32;
								int LineInc = 40;
								drPrintf(50,BaseY+LineInc,L"Config Data:",0);
								WCHAR wcLineBuffer[50];
								WCHAR * pCurPtr = wcBuffer;
								for(int i = 0; i < iNumLines; i++)
								{
									memset(wcLineBuffer,0x00,sizeof(wcLineBuffer));
									memcpy(wcLineBuffer,pCurPtr,64);
									pCurPtr +=32;
									drPrintf(180,BaseY+LineInc,wcLineBuffer,0);
									LineInc += 20;
								}
								// do partial last line
								int iRem = iChars % 32;
								if(iRem)
								{
									memset(wcLineBuffer,0x00,sizeof(wcLineBuffer));
									memcpy(wcLineBuffer,pCurPtr,iRem*2);
									drPrintf(180,BaseY+LineInc,wcLineBuffer,0);
								}
													
							} // if slot
						} // if nodes
					}  // for interface
				} // for slot
			} // for port
		} // if driverextension
		drShowScreen();
		Sleep(100);
	} // while
	SetEvent(pApp->m_hSynchRender); // inform main loop we're done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\usbinput.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    usbInput.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

*/

typedef DWORD (*APITEST_FUNC)(HANDLE hLog, DWORD ThreadID);

namespace USBInput
    {
    //
    //  USB XInput Tests
    //
    extern DWORD DumpDevice_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD XInputOpenClose_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD XInputGetState_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD XInputGetCapabilities_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD XInputSetState_Test(HANDLE hLog, DWORD ThreadID);
    } // namespace USBInput
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\utils.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif

namespace USBInput {


/*

Routine Description:

    Writes system resource usage information to the specified log file 
    and/or to the debugger.

    Be sure to include extern "C" { "ntos.h" } to use MmQueryStatistics

    MM_STATISTICS:
        ULONG TotalPhysicalPages;
        ULONG AvailablePages;
        ULONG VirtualMemoryBytesCommitted;
        ULONG VirtualMemoryBytesReserved;
        ULONG CachePagesCommitted;
        ULONG PoolPagesCommitted;
        ULONG StackPagesCommitted;
        ULONG ImagePagesCommitted;

Arguments:

    HANDLE hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    bool debugger - true sends memory data to the debugger

Return Value:

    None

*/
void FlushDiskCache(void);

void LogResourceStatus(HANDLE hLog, bool debugger)
    {
    const DWORD pageSize = 4096;
    MM_STATISTICS mmStats;
    PS_STATISTICS psStats;

    // initialize the stat info
    memset(&mmStats, 0, sizeof(MM_STATISTICS));
    mmStats.Length = sizeof(MM_STATISTICS);
    memset(&psStats, 0, sizeof(PS_STATISTICS));
    psStats.Length = sizeof(PS_STATISTICS);

    FlushDiskCache();

    // gather all the data
    MmQueryStatistics(&mmStats);
    PsQueryStatistics(&psStats);

    // display/write the data
    if(hLog)
        {
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        xLog(hLog, XLL_INFO, "   Total:     %lu", mmStats.TotalPhysicalPages*pageSize);
        xLog(hLog, XLL_INFO, "   Available: %lu", mmStats.AvailablePages*pageSize);
        xLog(hLog, XLL_INFO, "   Cache:     %lu", mmStats.CachePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Pool:      %lu", mmStats.PoolPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Stack:     %lu", mmStats.StackPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Image:     %lu", mmStats.ImagePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Handles:   %lu", psStats.HandleCount);
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        }
    if(debugger)
        {
        DebugPrint("MEM: Available=%lu, Cache=%lu, Pool=%lu, Handles=%lu\n", mmStats.AvailablePages*pageSize, mmStats.CachePagesCommitted*pageSize, mmStats.PoolPagesCommitted*pageSize, psStats.HandleCount);
        }
    }

void FlushVolume(OCHAR *volume)
    {
    HANDLE hFile = CreateFile(volume, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        DebugPrint("MEM: FlushError: %lu, 0x%x\n", GetLastError(), GetLastError());
    FlushFileBuffers(hFile);
    CloseHandle(hFile);
    }

/*

Routine Description:

    This routine will flush the disk cache

Arguments:

    None

Return Value:

    No return value

*/
void FlushDiskCache(void)
    {
    ULONG Volume, Disk;
    HANDLE Handle;
    NTSTATUS Status;
    OCHAR VolumeBuffer[MAX_PATH];
    OBJECT_STRING VolumeString;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;

    for(Disk=0; Disk<2; Disk++)
        {
        for(Volume=1; Volume<4; Volume++)
            {
            soprintf(VolumeBuffer, OTEXT("\\Device\\Harddisk%d\\Partition%d"), Disk, Volume);

            RtlInitObjectString(&VolumeString, VolumeBuffer);

            InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

            Status = NtCreateFile(&Handle, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);

            if(!NT_SUCCESS(Status)) continue;

            Status = NtFlushBuffersFile(Handle, &IoStatusBlock);
            NtClose(Handle);
            }
        }
    }
} // namespace USBInput
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\utils.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

namespace USBInput
    {
    extern void LogResourceStatus(HANDLE hLog, bool debugger);
    } // namespace USBInput

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif



#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>


#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
{
ULONG DebugPrint(PCHAR Format, ...);
}


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\usbinput.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usbInput.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xbox.h>
#include <xtestlib.h>
#include <xlog.h>
#include "commontest.h"

#include "usbInput.h"

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

ULONG UsbInputThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE UsbInputHeapHandle;


BOOL WINAPI UsbInputDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        UsbInputHeapHandle = HeapCreate(0, 0, 0);

        if(!UsbInputHeapHandle)
            {
            OutputDebugString(L"USBTEST: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(UsbInputHeapHandle)
            {
            HeapDestroy(UsbInputHeapHandle);
            }
        }

    return TRUE;
    }

static bool wcistrstr(WCHAR *string, WCHAR *substr, size_t len=0)
    {
    if(!string || ! substr) return false;
    if(!*string) return false;
    if(!len) len = wcslen(substr);
    if(_wcsnicmp(string, substr, len) == 0) return true;

    return wcistrstr(string+1, substr, len);
    }

/*

Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    DWORD threadNumber - sequential number of the thread
    DWORD loops - # of times to run test
    WCHAR* testname - specific name of a test to run

Return Value:

    DWORD

*/
namespace USBInput {
static DWORD RunAll(HANDLE hLog, DWORD threadNumber, DWORD loops, WCHAR *testname)
    {
    Sleep(threadNumber*200); // stagger the thread's execution a bit

    struct APIFUNCT
        {
        APITEST_FUNC f;
        WCHAR *name;
        };
    #define BUILTAPISTRUCT(n) { n , L#n }

    // Define all the API tests
    APIFUNCT testlist[] =
        {
        /*
        */
        BUILTAPISTRUCT(USBInput::XInputOpenClose_Test),
        BUILTAPISTRUCT(USBInput::XInputGetState_Test),
        BUILTAPISTRUCT(USBInput::XInputGetCapabilities_Test),
        BUILTAPISTRUCT(USBInput::XInputSetState_Test),
        };

    bool runAll = _wcsicmp(testname, L"(all)") == 0 ? true : false;

    // Run the suite of tests
    for(DWORD i=0; i<loops; i++)
        {
        // run each test
        for(unsigned j=0; j<ARRAYSIZE(testlist); j++)
            {
            if(runAll || wcistrstr(testlist[j].name, testname))
                {
                xLog(hLog, XLL_INFO, "%ws() ******************************************", testlist[j].name);
                LogResourceStatus(hLog, false);
                DebugPrint("USBINPUT(%d): Entering %ws()\n", threadNumber, testlist[j].name);
                testlist[j].f(hLog, threadNumber);
                }
            }
        }
    LogResourceStatus(hLog, true);

    return 0;
    }
} // namespace USBInput



/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI UsbInputStartTest(HANDLE hLog)
    {
    ULONG ID;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, UsbInputThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &UsbInputThreadID);

    // test settings
    const int buffLen = 1024;
    WCHAR *testname = new WCHAR[buffLen];
    DWORD loops;


    // Pull out internal INI file settings
    GetProfileString(L"usbInput", L"testname", L"(all)", testname, buffLen);
    loops = GetProfileInt(L"usbInput", L"loops", 1);


    xSetOwnerAlias(hLog, "jpoley");
    xSetComponent(hLog, "USB Driver", "XInput");
    DebugPrint("USBINPUT(%d): **************************************************************\n", ID);
    DebugPrint("USBINPUT(%d): Entering StartTest()\n", ID);
    DebugPrint("USBINPUT(%d): Internal INI Settings:\n", ID);
    DebugPrint("  loops=%lu\n", loops);
    DebugPrint("  testname=%ws\n", testname);
    DebugPrint("\nUSBINPUT(%d): !!!      A USB Controller must be plugged into port 0      !!!\n", UsbInputThreadID);
    DebugPrint("             !!!               for these tests to pass                  !!!\n\n");

    switch(ID)
        {
        case 0:
        case 1:
        default:
            USBInput::RunAll(hLog, ID, loops, testname);
            break;
        }


    DebugPrint("USBINPUT(%d): Leaving StartTest()\n", ID);
    DebugPrint("USBINPUT(%d): **************************************************************\n", ID);
    USBInput::LogResourceStatus(NULL, true);
    xSetOwnerAlias(hLog, NULL);

    delete[] testname;
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI UsbInputEndTest(void)
    {
    UsbInputThreadID = 0;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( usbinput )
#pragma data_seg()

BEGIN_EXPORT_TABLE( usbinput )
    EXPORT_TABLE_ENTRY( "StartTest", UsbInputStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", UsbInputEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", UsbInputDllMain )
END_EXPORT_TABLE( usbinput )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\reenum\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\xinputgetcapabilities.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XInputGetCapabilities.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    08-17-2000  Created

Notes:

*/

#include "stdafx.h"
#include <xbox.h>
#include <xlog.h>
#include "commontest.h"
#include "usbInput.h"


/*

Routine Description:

    

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:


Notes:
    "winerror.h"

*/
DWORD USBInput::XInputGetCapabilities_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD
    XInputGetCapabilities(
        IN HANDLE hDevice,
        OUT PXINPUT_CAPABILITIES pCapabilities
        );
    */
    xSetFunctionName(hLog, "XInputGetCapabilities");

    HANDLE device;
    DWORD err;
    XINPUT_CAPABILITIES state;
    XINPUT_POLLING_PARAMETERS pollingValid;
    pollingValid.fAutoPoll = 1;
    pollingValid.fInterruptOut = 0;
    pollingValid.ReservedMBZ1 = 0;
    pollingValid.bInputInterval = 8;  
    pollingValid.bOutputInterval = 8;
    pollingValid.ReservedMBZ2 = 0;


    DWORD time = GetTickCount();

    device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingValid);
    if(device == NULL)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to open device in port 0 is one plugged in? All tests skipped! (ec: %lu)", GetLastError());
        xEndVariation(hLog);
        return -1;
        }


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("0 NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputGetCapabilities(0, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetCapabilities (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetCapabilities (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputGetCapabilities(INVALID_HANDLE_VALUE, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetCapabilities (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetCapabilities (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("valid NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputGetCapabilities(device, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetCapabilities (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetCapabilities (ec: %ld)", err);
        } ENDTESTCASE;
        */


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("GAMEPAD port0")
        {
        err = XInputGetCapabilities(device, &state);
        if(err == ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetCapabilities (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetCapabilities (ec: %ld)", err);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("INVALID_HANDLE_VALUE")
        {
        err = XInputGetCapabilities(INVALID_HANDLE_VALUE, &state);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetCapabilities (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetCapabilities (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("0x7777")
        {
        err = XInputGetCapabilities((HANDLE)0x7777, &state);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetCapabilities (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetCapabilities (ec: %ld)", err);
        } ENDTESTCASE;
        */


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("USBINPUT(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 100000;
        unsigned failures = 0;
        for(unsigned i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }
            err = XInputGetCapabilities(device, &state);
            if(err != ERROR_SUCCESS) ++failures;
            }
        if(failures)
            TESTFAIL(hLog, "XInputGetCapabilities mini stress failures: %u", failures);
        } ENDTESTCASE_CLEAN({ /*DebugPrint("   (%d) 100%%\n", ThreadID);*/ });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    XInputClose(device);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\xinputgetstate.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XInputGetState.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    08-17-2000  Created

Notes:

*/

#include "stdafx.h"
#include <xbox.h>
#include <xlog.h>
#include "commontest.h"
#include "usbInput.h"


/*

Routine Description:

    

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:


Notes:
    "winerror.h"

*/
DWORD USBInput::XInputGetState_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD
    XInputGetState(
        IN HANDLE hDevice,
        OUT PXINPUT_STATE  pState
        );
    */
    xSetFunctionName(hLog, "XInputGetState");

    HANDLE device;
    DWORD err;
    XINPUT_STATE state;
    XINPUT_POLLING_PARAMETERS pollingValid;
    pollingValid.fAutoPoll = 1;
    pollingValid.fInterruptOut = 0;
    pollingValid.ReservedMBZ1 = 0;
    pollingValid.bInputInterval = 8;  
    pollingValid.bOutputInterval = 8;
    pollingValid.ReservedMBZ2 = 0;

    DWORD time = GetTickCount();

    device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingValid);
    if(device == NULL)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to open device in port 0 is one plugged in? All tests skipped! (ec: %lu)", GetLastError());
        xEndVariation(hLog);
        return -1;
        }


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("0 NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputGetState(0, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetState (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputGetState(INVALID_HANDLE_VALUE, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetState (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("valid NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputGetState(device, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetState (ec: %ld)", err);
        } ENDTESTCASE;
        */


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("GAMEPAD port0")
        {
        err = XInputGetState(device, &state);
        if(err == ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetState (ec: %ld)", err);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("INVALID_HANDLE_VALUE")
        {
        err = XInputGetState(INVALID_HANDLE_VALUE, &state);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetState (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("0x7777")
        {
        err = XInputGetState((HANDLE)0x7777, &state);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputGetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputGetState (ec: %ld)", err);
        } ENDTESTCASE;
        */


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        //DebugPrint("USBINPUT(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 100000;
        unsigned failures = 0;
        for(unsigned i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                //DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }
            err = XInputGetState(device, &state);
            if(err != ERROR_SUCCESS) ++failures;
            }
        if(failures)
            TESTFAIL(hLog, "XInputGetState mini stress failures: %u", failures);
        } ENDTESTCASE_CLEAN({ /*DebugPrint("   (%d) 100%%\n", ThreadID);*/ });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    XInputClose(device);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\brainbox\main.cpp ===
#include "usbtst.h"
#include <brainbox.h>

#define FAILURE_RED          0xff9f0000
#define PENDING_YELLOW       0xffffff00
#define UNKNOWN_ORANGE       0xffff7f00
#define SUCCESS_GREEN        0xff009f00
#define WAITING_WHITE        0xffffffff

class CBrainBox
{
  public:
    CBrainBox() : m_dwConnectedDevices(0),
               m_dwCurrentDevice(0xFFFFFFFF),
               m_hBrainBox(NULL),
               m_fOutstandingOutput(FALSE)
    {
        memset(&m_BrainBoxData, 0, sizeof(m_BrainBoxData));
        memset(m_LastKnownLEDs, 0, sizeof(m_LastKnownLEDs));
        memset(m_DesiredLEDs, 0, sizeof(m_DesiredLEDs));
    }
    void Init();
    void Run();

  private:

// Render Loop
    void CheckForHotplug();
    void PollData();
    void UpdateLEDs();
    void Render();

// Graphics Helpers
    CDraw   m_draw;
    CXBFont *m_pFont;

// Data
    DWORD                   m_dwConnectedDevices;
    DWORD                   m_dwCurrentDevice;
    HANDLE                  m_hBrainBox;
    XINPUT_BRAINBOX         m_BrainBoxData;
    WORD                    m_LastKnownLEDs[3];
    WORD                    m_DesiredLEDs[3];
    XINPUT_BRAINBOX_LEDS    m_BrainBoxLEDPacket;
    BOOL                    m_fOutstandingOutput;
};

//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------
void __cdecl main()
{
    CBrainBox brainBox;
    brainBox.Init();
    brainBox.Run();
}

void CBrainBox::Init()
{
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    m_pFont = m_draw.CreateFont("d:\\media\\font16.xpr");
}

void CBrainBox::Run()
{
    while(1)
    {
        CheckForHotplug();
        PollData();
        UpdateLEDs();
        Render();
    }
}


void CBrainBox::CheckForHotplug()
{
    DWORD dwInsertions, dwRemovals;
    if(XGetDeviceChanges(XDEVICE_TYPE_BRAINBOX, &dwInsertions, &dwRemovals))
    {
        //If the current device was removed, stop using it.
        if(m_hBrainBox && (1 << m_dwCurrentDevice)&dwRemovals)
        {   
            XInputClose(m_hBrainBox);
            m_hBrainBox=NULL;
            memset(&m_BrainBoxData, 0, sizeof(m_BrainBoxData));
            memset(m_LastKnownLEDs, 0, sizeof(m_LastKnownLEDs));
            memset(m_DesiredLEDs, 0, sizeof(m_DesiredLEDs));
            m_fOutstandingOutput = FALSE;
        }
        m_dwConnectedDevices &= ~dwRemovals;
        m_dwConnectedDevices |= dwInsertions;
        if(!m_hBrainBox && m_dwConnectedDevices)
        {
            DWORD dwMask=1;
            //Find first device
            m_dwCurrentDevice = 0;
            while(m_dwCurrentDevice<4)
            {
                if(dwMask&m_dwConnectedDevices)
                {
                    XINPUT_POLLING_PARAMETERS pollingParameters;
                    pollingParameters.fAutoPoll = TRUE;
                    pollingParameters.bInputInterval = 8;
                    pollingParameters.bOutputInterval = 8;
                    pollingParameters.fInterruptOut = TRUE;
                    pollingParameters.ReservedMBZ1 = 0;
                    pollingParameters.ReservedMBZ2 = 0;
                    m_hBrainBox = XInputOpen(XDEVICE_TYPE_BRAINBOX, m_dwCurrentDevice, 0, &pollingParameters);
                    if(m_hBrainBox)
                    {
                        return;
                    }
                }
                dwMask <<= 1;
                m_dwCurrentDevice++;
            }
        }
    }
}

void CBrainBox::PollData()
{
    if(m_hBrainBox)
    {
        XInputGetState(m_hBrainBox, (PXINPUT_STATE)&m_BrainBoxData);
        m_DesiredLEDs[0] = m_BrainBoxData.data.bmButtons[0];
        m_DesiredLEDs[1] = m_BrainBoxData.data.bmButtons[1];
        m_DesiredLEDs[2] = m_BrainBoxData.data.bmButtons[2]&0x00000;
    }
}


void CBrainBox::UpdateLEDs()
{
    if(m_hBrainBox)
    {
      //Check for completed I/O
      if(m_fOutstandingOutput && (ERROR_IO_PENDING!=m_BrainBoxLEDPacket.Header.dwStatus))
      {
         m_fOutstandingOutput = FALSE;
         if(ERROR_SUCCESS == m_BrainBoxLEDPacket.Header.dwStatus)
         { 
		    memcpy(m_LastKnownLEDs, m_BrainBoxLEDPacket.bmLEDs, sizeof(m_LastKnownLEDs));
         }	
      }

      //If there is no outstanding, update the LED state to be the same as the button state
      if(!m_fOutstandingOutput)
      {
          for(int i=0; i<3; i++)
          {
            if(m_LastKnownLEDs[i] != m_DesiredLEDs[i])
            {
		        memcpy(m_BrainBoxLEDPacket.bmLEDs, m_DesiredLEDs, sizeof(m_DesiredLEDs));
                m_BrainBoxLEDPacket.Header.dwStatus = ERROR_IO_PENDING;
                m_BrainBoxLEDPacket.Header.hEvent = 0;
                m_fOutstandingOutput = TRUE;
                XInputSetState(m_hBrainBox, (XINPUT_FEEDBACK *)&m_BrainBoxLEDPacket);
                return;
            }
          }
      }
    }
}


void CBrainBox::Render()
{
    WCHAR wszFormatBuffer[1024];
    m_draw.FillRect(0,0,640,480, PITCH_BLACK);
    if(!m_hBrainBox)
    {
        m_pFont->DrawText(70, 95, FAILURE_RED, L"Insert Device");
    } else
    {
        wsprintf(wszFormatBuffer, L"Device In Port %d", m_dwCurrentDevice);
        m_pFont->DrawText(70, 70, BRIGHT_BLUE, wszFormatBuffer);
    
        wsprintf(wszFormatBuffer, L"Buttons 0x%0.4x%0.4x%0.4x", 
          (DWORD)m_BrainBoxData.data.bmButtons[2],
          (DWORD)m_BrainBoxData.data.bmButtons[1],
          (DWORD)m_BrainBoxData.data.bmButtons[0]);
        m_pFont->DrawText(70, 95, BRIGHT_BLUE, wszFormatBuffer);

        wsprintf(wszFormatBuffer, L"Right Lever (0x%0.4x, 0x%0.4x)", (DWORD)m_BrainBoxData.data.wRightLeverX,(DWORD)m_BrainBoxData.data.wRightLeverY);
        m_pFont->DrawText(70, 120, BRIGHT_BLUE, wszFormatBuffer);
        
        wsprintf(wszFormatBuffer, L"Left Lever (0x%0.4x)", (DWORD)m_BrainBoxData.data.wLeftLeverX);
        m_pFont->DrawText(70, 145, BRIGHT_BLUE, wszFormatBuffer);

        wsprintf(wszFormatBuffer, L"Upper Left Lever (0x%0.4x, 0x%0.4x)", (DWORD)m_BrainBoxData.data.wUpperLeftLeverX, (DWORD)m_BrainBoxData.data.wUpperLeftLeverY);
        m_pFont->DrawText(70, 170, BRIGHT_BLUE, wszFormatBuffer);
        
        wsprintf(wszFormatBuffer, L"Pedals (0x%0.4x, 0x%0.4x, 0x%0.4x)",
            (DWORD)m_BrainBoxData.data.wFootPedal1,
            (DWORD)m_BrainBoxData.data.wFootPedal2,
            (DWORD)m_BrainBoxData.data.wFootPedal3);
        m_pFont->DrawText(70, 195, BRIGHT_BLUE, wszFormatBuffer);

        wsprintf(wszFormatBuffer, L"Tuner (0x%0.2x)", (DWORD)m_BrainBoxData.data.bTuner);
        m_pFont->DrawText(70, 220, BRIGHT_BLUE, wszFormatBuffer);

        wsprintf(wszFormatBuffer, L"Shift Lever (0x%0.2x)", (DWORD)m_BrainBoxData.data.bShiftLever);
        m_pFont->DrawText(70, 245, BRIGHT_BLUE, wszFormatBuffer);
    }
    m_draw.Present();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\reenum\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\xinputsetstate.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XInputSetState.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    08-17-2000  Created

Notes:

*/

#include "stdafx.h"
#include <xbox.h>
#include <xlog.h>
#include "commontest.h"
#include "usbInput.h"


/*

Routine Description:

    

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:


Notes:
    "winerror.h"

*/
DWORD USBInput::XInputSetState_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD
    XInputSetState(
        IN HANDLE hDevice,
        IN OUT PXINPUT_FEEDBACK pFeedback
        );
    */
    xSetFunctionName(hLog, "XInputSetState");

    HANDLE device;
    DWORD err;
    XINPUT_FEEDBACK state;
    XINPUT_FEEDBACK *states;
    XINPUT_POLLING_PARAMETERS pollingValid = {1, 0, 0, 8, 8, 0};

    DWORD time = GetTickCount();

    device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingValid);
    if(device == NULL)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to open device in port 0 is one plugged in? All tests skipped! (ec: %lu)", GetLastError());
        xEndVariation(hLog);
        return -1;
        }


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("0 NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputSetState(0, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputSetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputSetState (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputSetState(INVALID_HANDLE_VALUE, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputSetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputSetState (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("valid NULL")
        {
        BUGGED(0, "Crashes on NULL");
        err = XInputSetState(device, NULL);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputSetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputSetState (ec: %ld)", err);
        } ENDTESTCASE;
        */


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("GAMEPAD port0")
        {
        state.Header.hEvent = NULL;
        state.Rumble.wLeftMotorSpeed = 100;
        state.Rumble.wRightMotorSpeed = 100;
        err = XInputSetState(device, &state);
        if(err == ERROR_IO_PENDING)
            TESTPASS(hLog, "XInputSetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputSetState (ec: %ld)", err);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("INVALID_HANDLE_VALUE")
        {
        err = XInputSetState(INVALID_HANDLE_VALUE, &state);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputSetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputSetState (ec: %ld)", err);
        } ENDTESTCASE;
    TESTCASE("0x7777")
        {
        err = XInputSetState((HANDLE)0x7777, &state);
        if(err != ERROR_SUCCESS)
            TESTPASS(hLog, "XInputSetState (ec: %ld)", err);
        else
            TESTFAIL(hLog, "XInputSetState (ec: %ld)", err);
        } ENDTESTCASE;
        */


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("USBINPUT(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 100000;
        states = new XINPUT_FEEDBACK[maxStress];
        if(!states) 
            {
            BLOCKED(0, "Memory alloction failed");
            break;
            }

        unsigned failures = 0;
        for(unsigned i=0; i<maxStress; i++)
            {
            states[i].Header.hEvent = NULL;
            states[i].Rumble.wLeftMotorSpeed = (WORD)maxStress;
            states[i].Rumble.wRightMotorSpeed = (WORD)maxStress;
            if(i%(maxStress/10) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }
            err = XInputSetState(device, &states[i]);
            if(err != ERROR_IO_PENDING) ++failures;
            }
        if(failures)
            TESTFAIL(hLog, "XInputSetState mini stress failures: %u", failures);

        i = 0;
        while(states[maxStress-1].Header.dwStatus == ERROR_IO_PENDING)
            {
            SleepEx(1000, TRUE);
            if((++i%10) == 0)
                {
                DebugPrint("   (%d) Waiting for IO to complete...\n", ThreadID);
                }
            }
        } ENDTESTCASE_CLEAN({ delete[] states; /*DebugPrint("   (%d) 100%%\n", ThreadID);*/ });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    XInputClose(device);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\reenum\devices.cpp ===
#include "usbtest.h"
#include "draw.h"
#include "devices.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

CGameController::~CGameController()
{
    
}

void CGameController::Init(DWORD dwPort, INT iLeft, INT iTop)
{
    // Record this the basic stuff
    m_dwPort = dwPort;
    m_iLeft  = iLeft;
    m_iTop   = iTop;

    //
    //  Initialize test state details
    //
    m_iState        = DEVICE_STATE_NOT_INSERTED;
    m_iReenumCount  = 0;
    m_fDisconnectGamepadHub = FALSE;

    //
    //  Initialize the synchronization stuff.
    //
    InitializeCriticalSection(&m_CriticalSection);
    m_hSignalEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    //  Start the worker thread
    //
    HANDLE hThread = CreateThread(NULL, 65535, (LPTHREAD_START_ROUTINE)WorkerThreadEntry, (LPVOID)this, 0, NULL);
    CloseHandle(hThread);
}

void CGameController::Inserted()
{
    EnterCriticalSection(&m_CriticalSection);
    m_iState = DEVICE_STATE_INSERTED;
    LeaveCriticalSection(&m_CriticalSection);
    SetEvent(m_hSignalEvent);
}
void CGameController::Removed(){} //Does nothing for now

DWORD WINAPI CGameController::WorkerThreadEntry(CGameController *pGameController)
{
    pGameController->WorkerThread();
    return 0;
}
void CGameController::WorkerThread()
{
    HANDLE      hDevice;
    IUsbDevice  *pParentHub;;
    IUsbDevice  *pXidDevice;
    IUsbDevice  *pRootHub;
    UCHAR       ucHubPort;
    UCHAR       ucHubPortInRoot;
    KIRQL       oldIrql;
    DWORD       dwWaitReason;

    //
    //  Wait for device insertion (no timeout)
    //
    WaitForSingleObject(m_hSignalEvent, INFINITE);

    //
    //  Assume that the state DEVICE_STATE_INSERTED
    //
    ASSERT(DEVICE_STATE_INSERTED == m_iState);

    //
    //  Open the device and get the handle
    //
    while(1)
    {
        Sleep(200); 
        //
        //  Reinit all the IUsbDevice pointers
        //
        pXidDevice = NULL;
        pParentHub = NULL;
        pRootHub = NULL;
       
        //
        //  We need to:
        //      1) Open the device.
        //      2) Sleep for 200 ms, while it polls 25 times or so
        //      3) Close the device.
        //      4) Get IUsbDevice interface for a gamepad in our port
        //      5) Get its parent's IUsbDevice interface (the internal hub).
        //      6) Get its parent's parent's IUsbDevice interface (for the root hub, or the daughter
        //         card hub.
        //      5) Report the device has not responding.
        //  If we managed to get to stop 5) without a failure then we set the status to 
        //  DEVICE_STATE_REENUMERATING.  Otherwise, we drop through to the next section.
        //

        HANDLE hDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, m_dwPort, XDEVICE_NO_SLOT, NULL);
        if(hDevice)
        {
            Sleep(200);
            XInputClose(hDevice);
        }

        oldIrql = KeRaiseIrqlToDpcLevel();
        pXidDevice = GetXidDeviceInterface(XDEVICE_TYPE_GAMEPAD, m_dwPort, 0);
        if(pXidDevice)
        {
            ucHubPort = GetHubPort(pXidDevice);
            pParentHub = GetParentInterface(pXidDevice);
            if(pParentHub)
            {
                ucHubPortInRoot = GetHubPort(pParentHub);
                pRootHub = GetParentInterface(pParentHub);
                
                if(pRootHub)
                {
                    KeLowerIrql(oldIrql);
                    if(m_fDisconnectGamepadHub)
                    {
                        m_fDisconnectGamepadHub = FALSE;
                        DisableHubPortSync(pRootHub, ucHubPortInRoot);
                        oldIrql = KeRaiseIrqlToDpcLevel();
                    } else
                    {
                        //
                        //  For disconnecting at the gamepad case we have to
                        //  hit reset too.  Why?  The XID driver will only
                        //  detect a device that doesn't respond if the device
                        //  is open.  Since we don't open the device,
                        //  well it won't come back automagically.
                        //
                        m_fDisconnectGamepadHub = TRUE;
                        DisableHubPortSync(pParentHub, ucHubPort);
                        oldIrql = KeRaiseIrqlToDpcLevel();
                        ResetDevice(pXidDevice, 0);
                    }
                    m_iState = DEVICE_STATE_REENUMERATING;
                    m_iReenumCount++;
                }
            }
        }
        KeLowerIrql(oldIrql);

        //
        //  Wait for the device to come back.  This presumes that we got to step 5) above.
        //  If not we will certainly timeout.  If the device fails enumeration (5 times)
        //  we will also timeout.  We do not distinguish.
        //
        //  In either case we query the root hub to see if there is still a device in the
        //  port.  If there is then somehow the device (or our API) failed.  We mark it
        //  a failure.  Otherwise, we simply record that there is no device attached.
        //  
        dwWaitReason = WaitForSingleObject(m_hSignalEvent, 2000); //Up to two seconds
        if(WAIT_TIMEOUT==dwWaitReason)
        {
            EnterCriticalSection(&m_CriticalSection);
            if(pRootHub && IsDeviceAttached(pRootHub, ucHubPortInRoot))
            {
                m_iState = DEVICE_STATE_FAILED;
            } else
            {
                m_iState = DEVICE_STATE_NOT_INSERTED;
            }
            LeaveCriticalSection(&m_CriticalSection);
            WaitForSingleObject(m_hSignalEvent, INFINITE);  //Wait for next insertion
            m_iReenumCount=0;
        }
    }
}

void CGameController::Draw(CDraw& draw)
{
    //
    //  Sync with display info
    //
    INT iState, iReenumCount;

    EnterCriticalSection(&m_CriticalSection);
    iState = m_iState;
    iReenumCount = m_iReenumCount;
    LeaveCriticalSection(&m_CriticalSection);
    
    //
    //  Clear area
    //
    draw.FillRect(m_iLeft, m_iTop, 150, 400, BACKGROUND_BLUE);
    //
    //  Draw Stop Light background
    //
    draw.FillCircle(m_iLeft+75, m_iTop+75, 60, PITCH_BLACK);
    draw.FillCircle(m_iLeft+75, m_iTop+305, 60, PITCH_BLACK);
    draw.FillRect(m_iLeft+15, m_iTop+75, 120, 230, PITCH_BLACK);

    WCHAR FormatBuffer[80];
    INT redColor; 
    INT yellowColor;
    INT greenColor;
    INT textXPos;
    INT textYPos;

    //
    //  Draw Red Light
    //
    if(DEVICE_STATE_FAILED == iState)
    {
        redColor = BRIGHT_RED;
        wsprintf(FormatBuffer, L"Failed Try %d", iReenumCount);
        textXPos = m_iLeft+40;
        textYPos = m_iTop+75;
    } else
    {
        redColor = DARK_RED;
    }
    draw.FillCircle(m_iLeft+75, m_iTop+75, 50, redColor);

    //
    //  Draw Yellow Light
    //
    if(DEVICE_STATE_NOT_INSERTED == iState)
    {
        yellowColor = BRIGHT_YELLOW;
        wsprintf(FormatBuffer, L"Insert Device");
        textXPos = m_iLeft+40;
        textYPos = m_iTop+195;
    } else
    {
        yellowColor = DARK_YELLOW;
    }
    draw.FillCircle(m_iLeft+75, m_iTop+195, 50, yellowColor);

    //
    //  Draw Green Light
    //
    if( 
        (DEVICE_STATE_INSERTED == iState) ||
        (DEVICE_STATE_REENUMERATING == iState)
    )
    {
        greenColor = BRIGHT_GREEN;
        wsprintf(FormatBuffer, L"Succeeded Try %d ", iReenumCount);
        textXPos = m_iLeft+40;
        textYPos = m_iTop+305;
    } else
    {
        greenColor = DARK_GREEN;
    }
    draw.FillCircle(m_iLeft+75, m_iTop+305, 50, greenColor);
    
    //
    //  Draw Text
    //
    draw.DrawText(FormatBuffer, textXPos, textYPos, PITCH_BLACK);
}


CGameControllers::CGameControllers()
{
    int i;
    for(i=0; i < 4; i++)
    {
        m_pGameControllers[i] = new CGameController();
        if(!m_pGameControllers[i])
        {
            DebugPrint("Failed to allocate a game controller!");
        } else
        {
            m_pGameControllers[i]->Init(i, 40+i*150, 40);
        }
    }
    DWORD dwDevices;
    dwDevices = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    for(i=0; i < 4; i++)
    {
        if(dwDevices&(1 << i)) m_pGameControllers[i]->Inserted();
    }
}

CGameControllers::~CGameControllers()
{
    int i;
    for(i=0; i < 4; i++)
    {
        delete m_pGameControllers[i];
    }
}

void CGameControllers::CheckForHotplugs()
{
    DWORD dwInsertions, dwRemovals;
    if(XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
    {
        int i;
        for(i=0; i < 4; i++)
        {
            if(dwRemovals&(1 << i))
            {
                m_pGameControllers[i]->Removed();
            }
            if(dwInsertions&(1 << i))
            {
                m_pGameControllers[i]->Inserted();
            }
        }
    }
}
void CGameControllers::Draw(CDraw& draw)
{
    for(int i=0; i < 4; i++) m_pGameControllers[i]->Draw(draw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\reenum\devices.h ===
class CGameController
{
  public:
    CGameController(){}
    ~CGameController();
    void    Init(DWORD dwPort, INT iLeft, INT iTop);
    void    Inserted();
    void    Removed();
    void    Draw(CDraw& draw);
  private:
    // work is done in a separate thread
    static  DWORD WINAPI WorkerThreadEntry(CGameController *pGameController);
    void    WorkerThread();
    
    CRITICAL_SECTION m_CriticalSection;  //Protects the variables shared between the worker thread and the main thread.
    HANDLE           m_hSignalEvent;     //This event is used to signal the worker thread that there may be work to do.
    int              m_iState;           //State of the device
    int              m_iReenumCount;     //Count of successful retries
    DWORD            m_dwPort;

    //Draw Coordinates
    BOOL             m_fDisconnectGamepadHub;
    INT              m_iLeft;
    INT              m_iTop;
    
};

#define DEVICE_STATE_NOT_INSERTED   0   //Device is not inserted - initial value
#define DEVICE_STATE_INSERTED       1   //Device is inserted - set by Inserted()
#define DEVICE_STATE_REENUMERATING  2   //Device has been reset waiting for Inserted()
#define DEVICE_STATE_FAILED         3   //Device has failed reenumeration.  Wait for reenumertion has timed out
                                        //and hub confirms that device is still present.
class CGameControllers
{
    public:
        CGameControllers();
        ~CGameControllers();
        void CheckForHotplugs();
        void Draw(CDraw& draw);
    private:
        CGameController  *m_pGameControllers[4];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\usbinput\xinputopenclose.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XInputOpenClose.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    08-17-2000  Created

Notes:

*/

#include "stdafx.h"
#include <xbox.h>
#include <xlog.h>
#include "commontest.h"
#include "usbInput.h"


/*

Routine Description:

    

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:


Notes:
    "winerror.h"

*/
DWORD USBInput::XInputOpenClose_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HANDLE
    XInputOpen(
        IN DWORD dwType,
        IN DWORD dwPort,
        IN DWORD dwSlot,
        IN PXINPUT_POLLING_PARAMETERS pPollingParameters OPTIONAL
        );

    VOID
    XInputClose(
        IN HANDLE hDevice
        );
    */
    xSetFunctionName(hLog, "XInputOpen");

    HANDLE device;
    DWORD time = GetTickCount();

    XINPUT_POLLING_PARAMETERS pollingValid;
    pollingValid.fAutoPoll = 1;
    pollingValid.fInterruptOut = 0;
    pollingValid.ReservedMBZ1 = 0;
    pollingValid.bInputInterval = 8;  
    pollingValid.bOutputInterval = 8;
    pollingValid.ReservedMBZ2 = 0;

    XINPUT_POLLING_PARAMETERS pollingFast = { 1, 0, 0, 1, 1, 0 };
    XINPUT_POLLING_PARAMETERS pollingSlow = { 1, 0, 0, 255, 255, 0 };
    XINPUT_POLLING_PARAMETERS pollingMed  = { 1, 0, 0, 128, 128, 0 };
    XINPUT_POLLING_PARAMETERS pollingManual  = { 0, 0, 0, 4, 4, 0 };
    XINPUT_POLLING_PARAMETERS pollingInterrupt = { 0, 1, 0, 4, 4, 0 };


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("GAMEPAD port0 slot0 NULL")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, NULL);
        if(device != NULL)
            {
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
            XInputClose(device);
            }
        else
            TESTFAIL(hLog, "Unable to open device is one plugged in? (ec: %lu)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port0 slot0 valid polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingValid);
        if(device != NULL)
            {
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
            XInputClose(device);
            }
        else
            TESTFAIL(hLog, "Unable to open device (ec: %lu)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port0 slot0 slow polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingSlow);
        if(device != NULL)
            {
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
            XInputClose(device);
            }
        else
            TESTFAIL(hLog, "Unable to open device (ec: %lu)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port0 slot0 medium polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingMed);
        if(device != NULL)
            {
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
            XInputClose(device);
            }
        else
            TESTFAIL(hLog, "Unable to open device (ec: %lu)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port0 slot0 fast polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingFast);
        if(device != NULL)
            {
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
            XInputClose(device);
            }
        else
            TESTFAIL(hLog, "Unable to open device (ec: %lu)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port0 slot0 manual polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingManual);
        if(device != NULL)
            {
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
            XInputClose(device);
            }
        else
            TESTFAIL(hLog, "Unable to open device (ec: %lu)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port0 slot0 interrupt polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingInterrupt);
        if(device != NULL)
            {
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
            XInputClose(device);
            }
        else
            TESTFAIL(hLog, "Unable to open device (ec: %lu)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("invalid type port0 slot0 valid polling")
        {
        device = XInputOpen(~0, 0, 0, &pollingValid);
        if(device == NULL)
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
        else
            {
            TESTFAIL(hLog, "dev == 0x%X (ec: %lu)", device, GetLastError());
            XInputClose(device);
            }
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port0 slot1 valid polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 1, &pollingValid);
        if(device == NULL)
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
        else
            {
            TESTFAIL(hLog, "dev == 0x%X (ec: %lu)", device, GetLastError());
            XInputClose(device);
            }
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port99 slot0 valid polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 99, 0, &pollingValid);
        if(device == NULL)
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
        else
            {
            TESTFAIL(hLog, "dev == 0x%X (ec: %lu)", device, GetLastError());
            XInputClose(device);
            }
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port~0 slot0 valid polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, ~0, 0, &pollingValid);
        if(device == NULL)
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
        else
            {
            TESTFAIL(hLog, "dev == 0x%X (ec: %lu)", device, GetLastError());
            XInputClose(device);
            }
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port0 slot~0 valid polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, ~0, &pollingValid);
        if(device == NULL)
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
        else
            {
            TESTFAIL(hLog, "dev == 0x%X (ec: %lu)", device, GetLastError());
            XInputClose(device);
            }
        } ENDTESTCASE;
    TESTCASE("GAMEPAD port(XGetPortCount) slot0 valid polling")
        {
        device = XInputOpen(XDEVICE_TYPE_GAMEPAD, XGetPortCount(), 0, &pollingValid);
        if(device == NULL)
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
        else
            {
            TESTFAIL(hLog, "dev == 0x%X (ec: %lu)", device, GetLastError());
            XInputClose(device);
            }
        } ENDTESTCASE;
    TESTCASE("MU port1 slot0 valid polling")
        {
        device = XInputOpen(XDEVICE_TYPE_MEMORY_UNIT, 1, 0, &pollingValid);
        if(device == NULL)
            TESTPASS(hLog, "(ec: %lu)", GetLastError());
        else
            {
            TESTFAIL(hLog, "dev == 0x%X (ec: %lu)", device, GetLastError());
            XInputClose(device);
            }
        } ENDTESTCASE;
*/


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("USBINPUT(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 1000;
        unsigned failures = 0;
        for(unsigned i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }
            device = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, 0, &pollingValid);
            if(device == NULL) ++failures;
            else XInputClose(device);
            }
        if(failures)
            TESTFAIL(hLog, "XInputOpen mini stress failures: %u", failures);
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\reenum\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}


VOID CDraw::FillCircle(
        INT x,
        INT y,
        INT r,
        D3DCOLOR color)
{
    INT rPos;
    double alpha;
    double dR = r;
    INT halfWidth;
    D3DRECT rect;
    
    if (m_pDevice != NULL)
    {
        for(rPos = 0; rPos<=r; rPos++)
        {
            alpha = asin(rPos/dR);
            halfWidth = (INT)(r*cos(alpha));
            rect.x1 = x-halfWidth;
            rect.x2 = x+halfWidth;
            rect.y1 = y-rPos;
            rect.y2 = y+rPos;
            m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
        }
    }
}

VOID CDraw::FillRectNow(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    FillRect(x,y,width,height,color);
    Present();
    FillRect(x,y,width,height,color);
}
//------------------------------------------------------------------------------
// CDraw::DrawText

VOID CDraw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    D3DLOCKED_RECT LockedRect;
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

VOID CDraw::DrawTextNow(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
    Present();
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
}
//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\xidtest\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

VOID CDraw::FillRectNow(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    FillRect(x,y,width,height,color);
    Present();
    FillRect(x,y,width,height,color);
}
//------------------------------------------------------------------------------
// CDraw::DrawText

VOID CDraw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

VOID CDraw::DrawTextNow(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
    Present();
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
}
//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\xidtest\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

#define BACKDROP_BLUE        0x000080
#define LABEL_WHITE          0xffffff
#define DISCONNECTED_BLUE    0x000020
#define CONNECTED_YELLOW     0xffff00


class CDraw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

     VOID FillRectNow(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);


    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);
    
    VOID DrawTextNow(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\reenum\main.cpp ===
#include <xtl.h>
#include "draw.h"
#include "devices.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------

void __cdecl main()
{
    CDraw draw;

    //
    //  Initialize core peripheral port support
    //
    XDEVICE_PREALLOC_TYPE devices[]=
	{
		{XDEVICE_TYPE_GAMEPAD, 4}
	};
    XInitDevices(sizeof(devices)/sizeof(XDEVICE_PREALLOC_TYPE),devices);

    //
    //  Initialize Display
    //
    draw.FillRect(0, 0, 640, 480, BACKGROUND_BLUE); 
    draw.DrawText(L"TEST FOR BAD DAKOTA UNITS:", 300,  10, LABEL_WHITE);
    draw.Present();
    draw.FillRect(0, 0, 640, 480, BACKGROUND_BLUE); 
    draw.DrawText(L"TEST FOR BAD DAKOTA UNITS:", 300,  10, LABEL_WHITE);

    CGameControllers *pGameControllers = new CGameControllers;
    
    do
    {
        pGameControllers->CheckForHotplugs();
        pGameControllers->Draw(draw);
        draw.Present();
        Sleep(8);  //Update display every 20 milliseconds
        
    }while(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\xidtest\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\xidtest\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\xidtest\devices.h ===
class CGameController
{
  public:
    CGameController(DWORD dwPortNumber);
    ~CGameController();
    void    Open(XINPUT_POLLING_PARAMETERS *pPollingParameters);
    void    Close();
    void    PollDevice();
    void    UpdateState();
    void    Draw(CDraw& draw);
    LPCWSTR GetDPadDirectionText();
    LPCWSTR GetButtonStateText(DWORD dwButtonMask);
  private:
    DWORD           m_dwPortNumber;
    BOOL            m_fOpened;
    HANDLE          m_hDevice;
    XINPUT_STATE    m_gpState;
    DWORD           m_dwPacketNumber;
    int             m_iLeftEdge;
    int             m_iTopEdge;
    int             m_iLabelColorOpened;
    int             m_iLabelColorClosed;
    int             m_iStateColor;
    volatile XINPUT_FEEDBACK m_Feedback;
};

class CGameControllers
{
    public:
        CGameControllers(XINPUT_POLLING_PARAMETERS *pPollingParameters);
        ~CGameControllers();
        void CheckForHotplugs();
        void UpdateState();
        void Draw(CDraw& draw);
        void PollDevices();
    private:
        CGameController           *m_pGameControllers[4];
        XINPUT_POLLING_PARAMETERS  *m_pPollingParameters;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\reenum\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

#define BACKGROUND_BLUE      0x000080
#define PITCH_BLACK          0x000000
#define LABEL_WHITE          0xffffff
#define BRIGHT_RED           0xcf0000
#define DARK_RED             0x2f0000
#define BRIGHT_GREEN         0x00cf00
#define DARK_GREEN           0x003f00
#define BRIGHT_YELLOW        0xcfcf00
#define DARK_YELLOW          0x2f3f00


class CDraw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID FillCircle(
        INT x,
        INT y,
        INT r,
        D3DCOLOR color);

     VOID FillRectNow(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);


    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);
    
    VOID DrawTextNow(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\xidtest\devices.cpp ===
#include <xtl.h>
#include "draw.h"
#include "devices.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

int PressureColor(UCHAR Pressure)
/*++
    Wild ass guess on how to make it go from blue to red on more pressure.
--*/
{
    UCHAR blue = Pressure << 2;
    if(blue > Pressure) blue -= Pressure;
    else blue = 0;
    UCHAR green = Pressure << 1;;
    if(green  > Pressure) green -= Pressure;
    else green = 0;
    UCHAR red = Pressure;
    int Color = 0;
    Color = D3DCOLOR_XRGB(red, green, blue);
    return Color;
}

CGameController::CGameController(DWORD dwPortNumber) : 
    m_dwPortNumber(dwPortNumber),
    m_fOpened(FALSE),
    m_dwPacketNumber(0),
    m_hDevice(0),
    m_iLabelColorOpened(LABEL_WHITE),
    m_iLabelColorClosed(DISCONNECTED_BLUE),
    m_iStateColor(CONNECTED_YELLOW)
{
    switch(dwPortNumber)
    {
        case 0:
            m_iLeftEdge = 10;
            m_iTopEdge  = 10;
            break;
        case 1:
            m_iLeftEdge = 325;
            m_iTopEdge  = 10;
            break;
        case 2:
            m_iLeftEdge = 10;
            m_iTopEdge  = 255;
            break;
        case 3:
            m_iLeftEdge = 325;
            m_iTopEdge  = 255;
            break;
    }
    m_Feedback.Header.dwStatus = ERROR_SUCCESS;
    m_Feedback.Rumble.wLeftMotorSpeed = 0;
    m_Feedback.Rumble.wRightMotorSpeed = 0;
}

CGameController::~CGameController()
{
    Close();
}
void CGameController::Open(XINPUT_POLLING_PARAMETERS *pPollingParameters)
{
    DWORD dwError;
    if(!m_fOpened)
    {
        m_Feedback.Header.dwStatus = ERROR_SUCCESS;
        m_hDevice =  XInputOpen(XDEVICE_TYPE_GAMEPAD, m_dwPortNumber, XDEVICE_NO_SLOT, pPollingParameters);
        if(m_hDevice)
        {
            m_fOpened = TRUE;
        } else
        {   
            DebugPrint("Opened port %d Failed: %d\n", m_dwPortNumber, GetLastError());
        }
    }
}
void CGameController::Close()
{
    DWORD dwError;
    if(m_fOpened)
    {
        while(ERROR_IO_PENDING == m_Feedback.Header.dwStatus);
        XInputClose(m_hDevice);
        m_fOpened = FALSE;
        m_hDevice = NULL;
    }
}

void CGameController::PollDevice()
{
    if(!m_fOpened) return;
    XInputPoll(m_hDevice);
}

void CGameController::UpdateState()
{
    if(!m_fOpened) return;
    DWORD dwError = XInputGetState(m_hDevice, &m_gpState);
    
    if(ERROR_IO_PENDING != m_Feedback.Header.dwStatus)
    {
        if(
            ((m_gpState.Gamepad.bAnalogButtons[6] << 8) != m_Feedback.Rumble.wLeftMotorSpeed) ||
            ((m_gpState.Gamepad.bAnalogButtons[7] << 8) != m_Feedback.Rumble.wRightMotorSpeed)
        ){
            m_Feedback.Rumble.wLeftMotorSpeed = m_gpState.Gamepad.bAnalogButtons[6] << 8;
            m_Feedback.Rumble.wRightMotorSpeed = m_gpState.Gamepad.bAnalogButtons[7] << 8;
            XInputSetState(m_hDevice, (PXINPUT_FEEDBACK)&m_Feedback);
        }
    }
    
    if(ERROR_SUCCESS != dwError)
    {
        if(dwError == ERROR_DEVICE_NOT_CONNECTED)
        {
            //
            //  Don't worry about closing the handle, since we
            //  poll for device removals and we will close
            //  the handle very soon anyway.
            //
            return;
        }
        DebugPrint("XInputGetDeviceState return error: %d\n", dwError);
        DebugPrint("This error is not expected in normal operation\n");
        DebugBreak();
    }
}

void CGameController::Draw(CDraw& draw)
{
    int iLabelColor = m_fOpened ? m_iLabelColorOpened : m_iLabelColorClosed;
    WCHAR FormatBuffer[80];
    draw.FillRect(m_iLeftEdge, m_iTopEdge, 300, 200, BACKDROP_BLUE); 
    wsprintf(FormatBuffer, L"Port Number %d", m_dwPortNumber);
    draw.DrawText(FormatBuffer, m_iLeftEdge, m_iTopEdge, iLabelColor);
    draw.DrawText(L"Start:", m_iLeftEdge+10, m_iTopEdge+10, iLabelColor);
    draw.DrawText(L"Back:", m_iLeftEdge+10, m_iTopEdge+20, iLabelColor);
    draw.DrawText(L"Analog  Buttons:", m_iLeftEdge+10, m_iTopEdge+30, iLabelColor);
    draw.DrawText(L"Left Thumbstick:", m_iLeftEdge+10, m_iTopEdge+50, iLabelColor);
    draw.DrawText(L"Right Thumbstick:", m_iLeftEdge+10, m_iTopEdge+60, iLabelColor);
    draw.DrawText(L"Direction Pad:", m_iLeftEdge+10, m_iTopEdge+70, iLabelColor);
    draw.DrawText(L"Packet Number:", m_iLeftEdge+10, m_iTopEdge+80, iLabelColor);
    if(m_fOpened)
    {
        
        draw.DrawText(
            GetButtonStateText(XINPUT_GAMEPAD_START),
            m_iLeftEdge+160,
            m_iTopEdge+10,
            m_iStateColor
            );
        draw.DrawText(
            GetButtonStateText(XINPUT_GAMEPAD_BACK),
            m_iLeftEdge+160,
            m_iTopEdge+20,
            m_iStateColor
            );

        for(int i=0; i<8; i++)
        {
            wsprintf(FormatBuffer, L"%3.0d", m_gpState.Gamepad.bAnalogButtons[i]);
            if(i < 4)
            {
                draw.DrawText(
                        FormatBuffer,
                        m_iLeftEdge+160+i*30,
                        m_iTopEdge+30,
                        PressureColor(m_gpState.Gamepad.bAnalogButtons[i])
                        );
            } else
            {
                draw.DrawText(
                        FormatBuffer,
                        m_iLeftEdge+160+(i-4)*30,
                        m_iTopEdge+40,
                        PressureColor(m_gpState.Gamepad.bAnalogButtons[i])
                        );
            }
        }
        wsprintf(
            FormatBuffer,
            L"(%d,%d, %s)",
            (LONG)m_gpState.Gamepad.sThumbLX,
            (LONG)m_gpState.Gamepad.sThumbLY,
            GetButtonStateText(XINPUT_GAMEPAD_LEFT_THUMB)
            );
        draw.DrawText(FormatBuffer, m_iLeftEdge+160, m_iTopEdge+50, m_iStateColor);
        wsprintf(
            FormatBuffer,
            L"(%d,%d, %s)",
            (LONG)m_gpState.Gamepad.sThumbRX,
            (LONG)m_gpState.Gamepad.sThumbRY,
            GetButtonStateText(XINPUT_GAMEPAD_RIGHT_THUMB)
            );
        draw.DrawText(FormatBuffer, m_iLeftEdge+160, m_iTopEdge+60, m_iStateColor);
        
        wsprintf(
            FormatBuffer,
            L"(%d)",
            m_gpState.dwPacketNumber
            );
        draw.DrawText(GetDPadDirectionText(), m_iLeftEdge+160, m_iTopEdge+70, m_iStateColor);
        draw.DrawText(FormatBuffer, m_iLeftEdge+160, m_iTopEdge+80, m_iStateColor);
    }
}

LPCWSTR CGameController::GetButtonStateText(DWORD dwButtonMask)
{
    
    if(dwButtonMask&m_gpState.Gamepad.wButtons)
    {
        return L"Down";
    }
    return L"Up";
}

LPCWSTR CGameController::GetDPadDirectionText()
{
    if(m_gpState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
    {
       if(m_gpState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
       {
            return L"Northwest";
       }
       if(m_gpState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
       {
            return L"Northeast";
       }
       return L"North";
    } 
    if(m_gpState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
    {
       if(m_gpState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
       {
            return L"Southwest";
       }
       if(m_gpState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
       {
            return L"Southeast";
       }
       return L"South";
    }
    if(m_gpState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
    {
        return L"West";
    }
    if(m_gpState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
    {
        return L"East";
    }
    return L"Centered";
}

CGameControllers::CGameControllers(XINPUT_POLLING_PARAMETERS *pPollingParameters) :
    m_pPollingParameters(pPollingParameters)
{
    int i;
    for(i=0; i < 4; i++)
    {
        m_pGameControllers[i] = new CGameController(i);
        if(!m_pGameControllers[i]) DebugPrint("Failed to allocate a game controller!");
    }
    DWORD dwDevices;
    dwDevices = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    for(i=0; i < 4; i++)
    {
        if(dwDevices&(1 << i)) m_pGameControllers[i]->Open(m_pPollingParameters);
    }
}

CGameControllers::~CGameControllers()
{
    int i;
    for(i=0; i < 4; i++)
    {
        delete m_pGameControllers[i];
    }
}
void CGameControllers::CheckForHotplugs()
{
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals);
    int i;
    for(i=0; i < 4; i++)
    {
        if(dwRemovals&(1 << i)) m_pGameControllers[i]->Close();
        if(dwInsertions&(1 << i)) m_pGameControllers[i]->Open(m_pPollingParameters);
    }
}
void CGameControllers::UpdateState()
{
   for(int i=0; i < 4; i++) m_pGameControllers[i]->UpdateState();
}
void CGameControllers::Draw(CDraw& draw)
{
    for(int i=0; i < 4; i++) m_pGameControllers[i]->Draw(draw);
}

void CGameControllers::PollDevices()
{
    for(int i=0; i < 4; i++) m_pGameControllers[i]->PollDevice();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\xid\xidtest\main.cpp ===
#include <xtl.h>
#include "draw.h"
#include "devices.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}
XINPUT_POLLING_PARAMETERS g_PollingParameters = {0};
//
//  Useful Macro
//
#define DECLARE_DO_TWICE int doTwice;
#define DO_TWICE doTwice=2; while(doTwice--)

void DrawTestCaseMessage(CDraw& draw, LPWSTR pMessage);

//------------------------------------------------------------------------------
//  Forward Declations
//------------------------------------------------------------------------------
void DrawTestCaseMessage(CDraw& draw, LPWSTR pMessage);

//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------

void __cdecl main()
{
    DECLARE_DO_TWICE;
    int iFrameCount=0;
    int iState = 0;
    BOOL fUseUpdateAndRedraw = TRUE;
    BOOL fCallPollDevice;
    DebugPrint("XInput Test Application.\nBuilt on %s at %s\n", __DATE__, __TIME__);
    CDraw draw;
    
    //Initialize core peripheral port support
    XDEVICE_PREALLOC_TYPE devices[]=
	{
		{XDEVICE_TYPE_GAMEPAD, 4}
        //{XDEVICE_TYPE_VOICE_HEADPHONE, 0}
	};

    XInitDevices(sizeof(devices)/sizeof(XDEVICE_PREALLOC_TYPE),devices);

    //For the memory unit driver to load
    XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);

    DO_TWICE
    {
        draw.FillRect(0, 0, 640, 480, BACKDROP_BLUE); 
        draw.DrawText(L"XInput Test Application", 300,  0, LABEL_WHITE);
        draw.Present();
    }
    CGameControllers *pGameControllers = NULL;
    do
    {
        fCallPollDevice = FALSE; //most of the case use autopoll
        iState = (iState+1)%5;
        //
        //  Decide how to open the game controllers this time
        //
        switch(iState)
        {
            case 0:
                DrawTestCaseMessage(draw, L"Default Polling Parameters");
                pGameControllers = new CGameControllers(NULL);
                break;
            case 1:
                DrawTestCaseMessage(draw, L"AutoPoll, Control-OUT, Input Interval 16 ms, Calling PollDevice");
                g_PollingParameters.fAutoPoll = TRUE;
                g_PollingParameters.fInterruptOut = FALSE;
                g_PollingParameters.bInputInterval = 16;
                g_PollingParameters.ReservedMBZ1 = 0;
                g_PollingParameters.ReservedMBZ2 = 0;
                pGameControllers = new CGameControllers(&g_PollingParameters);
                fCallPollDevice = TRUE; //make sure PollDevices does no harm.
                break;
            case 2:
                DrawTestCaseMessage(draw, L"AutoPoll, Control-OUT, Input Interval 4 ms");
                g_PollingParameters.fAutoPoll = TRUE;
                g_PollingParameters.fInterruptOut = FALSE;
                g_PollingParameters.bInputInterval = 4;
                g_PollingParameters.ReservedMBZ1 = 0;
                g_PollingParameters.ReservedMBZ2 = 0;
                pGameControllers = new CGameControllers(&g_PollingParameters);
                break;
            case 3:
                DrawTestCaseMessage(draw, L"ManualPoll, Control-OUT, Input Interval 2 ms");
                g_PollingParameters.fAutoPoll = FALSE;
                g_PollingParameters.fInterruptOut = FALSE;
                g_PollingParameters.bInputInterval = 2;
                g_PollingParameters.ReservedMBZ1 = 0;
                g_PollingParameters.ReservedMBZ2 = 0;
                pGameControllers = new CGameControllers(&g_PollingParameters);
                fCallPollDevice = TRUE; //make sure PollDevices does no harm.
                break;
            case 4:
                DrawTestCaseMessage(draw, L"ManualPoll, Control-OUT, Input Interval 2 ms, NOT POLLING");
                g_PollingParameters.fAutoPoll = FALSE;
                g_PollingParameters.fInterruptOut = FALSE;
                g_PollingParameters.bInputInterval = 2;
                g_PollingParameters.ReservedMBZ1 = 0;
                g_PollingParameters.ReservedMBZ2 = 0;
                pGameControllers = new CGameControllers(&g_PollingParameters);
                break;
        }
        //Poll for three hundred frames
        iFrameCount = 0;        
        while(300 > iFrameCount++)
        {
           pGameControllers->CheckForHotplugs();
           pGameControllers->UpdateState();
           DO_TWICE{
               pGameControllers->Draw(draw);
               draw.Present();
           }
           //
           //   Sleep for a video frame
           //
           if(fCallPollDevice)
           {
             Sleep(8);
             pGameControllers->PollDevices();
             Sleep(8);
           } else
           {
             Sleep(16);
           }
        }
        delete pGameControllers;
    }while(1);
}

void DrawTestCaseMessage(CDraw& draw, LPWSTR pMessage)
{
    DECLARE_DO_TWICE;
    DebugPrint("%ws\n", pMessage);
    DO_TWICE
    {
        draw.FillRect(0, 465, 640, 14, BACKDROP_BLUE); 
        draw.DrawText(L"TEST CASE:", 0, 465, LABEL_WHITE);
        draw.DrawText(pMessage, 60, 465, CONNECTED_YELLOW);
        draw.Present();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\commontest.h ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         "Z"
#define TITLE_DRIVE         "T"
#define USER_DRIVE          "U"
#define BASE_DRIVE          CACHE_DRIVE

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    xStartVariation(hLog, variant);
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    xStartVariation(hLog, aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

#define ALLCHARS "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f" \
    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

// common numbers
static DWORD dwBogus = 0xF000BAAA;
static ULARGE_INTEGER ulBogus = { 0xF000BAAA, 0xF000BAAA };

// common HANDLE parameters
static HANDLE hNull = NULL;
static HANDLE hBogus = (void*)0xF000BAAA;

// common string parameters
static char* lpNull = NULL;
static char* lpEmpty = "";
static char* lpSpace = " ";
//static char* lpBogus = (const char*)0xF000BAAA;
static char* lpCurrentDir = ".";
static char* lpParentDir = "..";
static char* lpUnderMaxPathDir = BASE_DRIVE ":\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory";
static char* lpOverMaxPathDir = BASE_DRIVE ":\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory";

// security attributes
/*
static SECURITY_DESCRIPTOR sdEmpty = { 0, 0, 0, 0, 0, 0, 0 };
static SECURITY_DESCRIPTOR sdBogus = { 0x69, 0x69, 0xF000, (void*)0xF000BAAA, (void*)0xF000BAAA, (PACL)0xF000BAAA, (PACL)0xF000BAAA};
static SECURITY_ATTRIBUTES saEmpty = { 0, 0, 0 };
static SECURITY_ATTRIBUTES saBogus = { 0xF000BAAA, (PISECURITY_DESCRIPTOR)0xF000BAAA, 0xF000BAAA};
static SECURITY_ATTRIBUTES saEmptyWithSize = { sizeof(SECURITY_ATTRIBUTES), 0, 0 };
static SECURITY_ATTRIBUTES saWithEmptySD = { sizeof(SECURITY_ATTRIBUTES), &sdEmpty, 0 };
static SECURITY_ATTRIBUTES saWithBogusSD = { sizeof(SECURITY_ATTRIBUTES), &sdBogus, 0 };
*/
/*
// device names
static char *deviceNames[] = {
    BASE_DRIVE ":\\prn",
    BASE_DRIVE ":\\aux",
    BASE_DRIVE ":\\con",
    BASE_DRIVE ":\\lpt1",
    "\\\\?\\prn",
    "\\\\?\\aux",
    "\\\\?\\con",
    "\\\\?\\lpt1",
    "\\\\lpt1",
    "CONOUT$",
    "CONIN$",
    };
*/

// invalid file names
static char *invalidFileNames[] = {
    BASE_DRIVE ":\\abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd",
    BASE_DRIVE ":\\)#+l+RI+Td<\x12>",
    BASE_DRIVE ":\\~`!@#$%^&*()-=_+[]{}\\|';:\",./?><",
    BASE_DRIVE ":\\*",
    BASE_DRIVE ":\\?",
    BASE_DRIVE ":\\" ALLCHARS,
    BASE_DRIVE ":\\abc?",
    BASE_DRIVE ":\\abc>def",
    BASE_DRIVE ":\\abc<def",
    BASE_DRIVE ":\\abc|def",
    BASE_DRIVE ":\\abc:def",
    BASE_DRIVE ":\\abc\"def",
    BASE_DRIVE ":\\>",
    BASE_DRIVE ":\\<",
    BASE_DRIVE ":\\:",
    BASE_DRIVE ":\\|",
    BASE_DRIVE ":\\\"",
    BASE_DRIVE ":\\..\\abcdef",
    BASE_DRIVE ":\\.\\..\\abcdef",
    BASE_DRIVE ":\\..\\..\\..\\..\\..\\..\\..\\..\\..\\abcdef",
    BASE_DRIVE ":\\abc" BASE_DRIVE ":\\def",
    BASE_DRIVE ":\\new\nline",
    BASE_DRIVE ":\\newline\n",
    BASE_DRIVE ":\\Carriage\rreturn",
    BASE_DRIVE ":\\Carriagereturn\r",
    BASE_DRIVE ":\\\ttab",
    BASE_DRIVE ":\\tab\t",
    BASE_DRIVE ":\\\abel",
    BASE_DRIVE ":\\bell\a",
    BASE_DRIVE BASE_DRIVE ":\\abc",
    BASE_DRIVE "::\\abc",
    BASE_DRIVE "abc",
    BASE_DRIVE ".",
    BASE_DRIVE "..",
    BASE_DRIVE " ",
    "\\\\?\\" BASE_DRIVE ":\\)#+l+RI+Td<\x12>",
    "\\\\?\\" BASE_DRIVE ":\\~`!@#$%^&*()-=_+[]{}\\|';:\",./?><",
    "\\\\?\\" BASE_DRIVE ":\\*",
    "\\\\?\\" BASE_DRIVE ":\\?",
    "\\\\?\\" BASE_DRIVE ":\\" ALLCHARS,
    "\\\\?\\" BASE_DRIVE ":\\..\\abcdef",
    "\\\\?\\" BASE_DRIVE ":\\.\\..\\abcdef",
    "\\\\?\\" BASE_DRIVE ":\\new\nline",
    "\\\\?\\" BASE_DRIVE ":\\Carriage\rreturn",
    "\\\\?\\" BASE_DRIVE ":\\\ttab",
    "\\\\?\\" BASE_DRIVE BASE_DRIVE ":\\abc",
    "\\\\?\\" BASE_DRIVE "::\\abc",
    "\\\\?\\" BASE_DRIVE ":\\\\abc",
    "\\\\?\\" BASE_DRIVE "abc",
    "\\\\?\\abc",
    "\\\\?\\ ",
    "\\\\?\\/",
    "\\\\?\\\\",
    "\\\\?\\.",
    "\\\\?\\..",
    " ",
    "/",
    "\\",
    ".",
    ".."
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\copyfileex.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CopyFileEx.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

static BOOL cancel = FALSE;
static DWORD CALLBACK CopyFileProgressRoutine(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);
static DWORD CALLBACK CancelHalfway(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);
static DWORD CALLBACK CancelOnFirst(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);


struct CopyState
    {
    HANDLE hLog;
    __int64 totalBytesTransferred;
    int state;
    };

// states
#define TEST_CANCELRESUME   1
#define TEST_CANCELFLAG     2


/*

Routine Description:

    Tests the CopyFileEx API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::CopyFileEx_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL CopyFileEx(
      LPCTSTR lpExistingFileName,           // name of existing file
      LPCTSTR lpNewFileName,                // name of new file
      LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
      LPVOID lpData,                        // callback parameter
      LPBOOL pbCancel,                      // cancel status
      DWORD dwCopyFlags                     // copy options
    );
    */
    xSetFunctionName(hLog, "CopyFileEx");

    char lpSmallFile[80]; sprintf(lpSmallFile, "%s:\\FCPX01_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%s:\\FCPX02_%d.txt", BASE_DRIVE, ThreadID);
    char lpExtraBigFile[80]; sprintf(lpExtraBigFile, "%s:\\FCPX03_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%s:\\FCPX04_%d.bla", BASE_DRIVE, ThreadID);
    char lpFakeFile2[80]; sprintf(lpFakeFile2, "%s:\\FCPX05_%d.bla", BASE_DRIVE, ThreadID);
    char lpDevice[80]; sprintf(lpDevice, "%s:\\FCPX06_%d.txt", BASE_DRIVE, ThreadID);
    char lpDir1[80]; sprintf(lpDir1, "%s:\\CPFX_%d", BASE_DRIVE, ThreadID);
    char lpSubFile[80]; sprintf(lpSubFile, "%s:\\CPFX_%d\\CPFX07_%d.txt", BASE_DRIVE, ThreadID, ThreadID);
    char lpFile1[80];
    char lpFile2[80];
    unsigned i;

    // initialize system state
    CreateDirectory(lpDir1, NULL);
    CreateFilledFile(lpSmallFile, KILOBYTE*16);
    CreateFilledFile(lpBigFile, MEGABYTE*8);        // tests rely on this being 8meg
    CreateFilledFile(lpExtraBigFile, MEGABYTE*64);
    CreateFilledFile(lpSubFile, KILOBYTE*16);


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NUL")
        {
        if(CopyFileEx(lpNull, lpNull, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("NULL Empty")
        {
        if(CopyFileEx(lpNull, lpEmpty, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Empty NUL")
        {
        if(CopyFileEx(lpEmpty, lpNull, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Empty Empty")
        {
        if(CopyFileEx(lpEmpty, lpEmpty, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Exist NULL")
        {
        BUGGEDPASS(56, "ACCESS VIOLATION \"By Design\"");
        if(CopyFileEx(lpSmallFile, lpNull, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("small file")
        {
        sprintf(lpFile1, "%s:\\CPFX08_%d.txt", BASE_DRIVE, ThreadID);

        if(CopyFileEx(lpSmallFile, lpFile1, CopyFileProgressRoutine, hLog, &cancel, 0) == TRUE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("large file")
        {
        sprintf(lpFile1, "%s:\\CPFX08_%d.txt", BASE_DRIVE, ThreadID);

        if(CopyFileEx(lpBigFile, lpFile1, CopyFileProgressRoutine, hLog, &cancel, 0) == TRUE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("extra large file")
        {
        sprintf(lpFile1, "%s:\\CPFX08_%d.txt", BASE_DRIVE, ThreadID);

        if(CopyFileEx(lpBigFile, lpFile1, CopyFileProgressRoutine, hLog, &cancel, 0) == TRUE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("Exists & FAIL_IF_EXISTS")
        {
        if(CopyFileEx(lpBigFile, lpExtraBigFile, CopyFileProgressRoutine, hLog, &cancel, COPY_FILE_FAIL_IF_EXISTS) == FALSE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    /*
    TESTCASE("large file cancel+resume")
        {
        CopyState state = { hLog, 0, TEST_CANCELRESUME };
        sprintf(lpFile1, "%s:\\CPFX08_%d.txt", BASE_DRIVE, ThreadID);

        if(CopyFileEx(lpBigFile, lpFile1, CancelHalfway, &state, &cancel, COPY_FILE_RESTARTABLE) == FALSE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(CopyFileEx(lpBigFile, lpFile1, CancelOnFirst, &state, &cancel, COPY_FILE_RESTARTABLE) == FALSE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(state.totalBytesTransferred > 1*MEGABYTE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Copy didnt restart, copied bytes = %I64d (ec: %ld)", state.totalBytesTransferred, GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
        */
    TESTCASE("cancel flag")
        {
        CopyState state = { hLog, 0, TEST_CANCELFLAG };
        sprintf(lpFile1, "%s:\\CPFX08_%d.txt", USER_DRIVE, ThreadID);

        if(CopyFileEx(lpBigFile, lpFile1, CancelHalfway, &state, &cancel, 0) == FALSE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(state.totalBytesTransferred < 5*MEGABYTE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Copy didnt stop, copied bytes = %I64d (ec: %ld)", state.totalBytesTransferred, GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(nonexist, nonexist)")
        {
        if(CopyFileEx(lpFakeFile, lpFakeFile2, CopyFileProgressRoutine, hLog, &cancel, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        if(FileExists(lpFakeFile2) == TRUE)
            TESTFAIL(hLog, "File exists (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFakeFile2); });



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            if(CopyFileEx(lpSmallFile, invalidFileNames[i], CopyFileProgressRoutine, hLog, &cancel, 0) == FALSE)
                TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    DeleteFile(lpSubFile);
    RemoveDirectory(lpDir1);
    DeleteFile(lpBigFile);
    DeleteFile(lpSmallFile);
    DeleteFile(lpExtraBigFile);
    DeleteFile(lpDevice);

    return 0;
    }


/*

Routine Description:

    Callback function used with the CopyFileEx and MoveFileWithProgress functions
    See "CopyProgressRoutine" in MSDN

Arguments:

    LARGE_INTEGER TotalFileSize          - file size
    LARGE_INTEGER TotalBytesTransferred  - bytes transferred
    LARGE_INTEGER StreamSize             - bytes in stream
    LARGE_INTEGER StreamBytesTransferred - bytes transferred for stream
    DWORD dwStreamNumber                 - current stream
    DWORD dwCallbackReason               - callback reason
    HANDLE hSourceFile                   - handle to source file
    HANDLE hDestinationFile              - handle to destination file
    LPVOID lpData                        - user data, HANDLE to XLOG object

Return Value:

    PROGRESS_CONTINUE, PROGRESS_STOP, or PROGRESS_CANCEL

*/
static DWORD CALLBACK CopyFileProgressRoutine(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
    {
    if(!lpData) return PROGRESS_CONTINUE;

    HANDLE hLog = (HANDLE)lpData;

    //xLog(hLog, XLL_INFO, "1: %I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);

    if(TotalBytesTransferred.QuadPart > TotalFileSize.QuadPart)
        {
        xLog(hLog, XLL_FAIL, "Transfered more than filesize: %I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);
        }

    if(TotalBytesTransferred.QuadPart >= TotalFileSize.QuadPart)
        {
        }

    return PROGRESS_CONTINUE;
    }

/*

Routine Description:

    Callback function used with the CopyFileEx and MoveFileWithProgress functions
    See "CopyProgressRoutine" in MSDN

Arguments:

    LARGE_INTEGER TotalFileSize          - file size
    LARGE_INTEGER TotalBytesTransferred  - bytes transferred
    LARGE_INTEGER StreamSize             - bytes in stream
    LARGE_INTEGER StreamBytesTransferred - bytes transferred for stream
    DWORD dwStreamNumber                 - current stream
    DWORD dwCallbackReason               - callback reason
    HANDLE hSourceFile                   - handle to source file
    HANDLE hDestinationFile              - handle to destination file
    LPVOID lpData                        - user data, CopyState

Return Value:

    PROGRESS_CONTINUE, PROGRESS_STOP, or PROGRESS_CANCEL

*/
static DWORD CALLBACK CancelHalfway(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
    {
    if(!lpData) return PROGRESS_CONTINUE;

    CopyState *state = (CopyState*)lpData;
    HANDLE hLog = state->hLog;
    state->totalBytesTransferred = TotalBytesTransferred.QuadPart;

    //xLog(hLog, XLL_INFO, "2: %I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);

    if(TotalBytesTransferred.QuadPart >= 3*MEGABYTE)
        {
        if(state->state == TEST_CANCELRESUME)
            {
            //return PROGRESS_STOP;
            return PROGRESS_CONTINUE;
            }
        else if(state->state == TEST_CANCELFLAG)
            {
            cancel = TRUE;
            return PROGRESS_CANCEL;
            }
        else
            {
            return PROGRESS_CONTINUE;
            }
        }

    if(TotalBytesTransferred.QuadPart >= TotalFileSize.QuadPart)
        {
        }

    return PROGRESS_CONTINUE;
    }

/*

Routine Description:

    Callback function used with the CopyFileEx and MoveFileWithProgress functions
    See "CopyProgressRoutine" in MSDN

Arguments:

    LARGE_INTEGER TotalFileSize          - file size
    LARGE_INTEGER TotalBytesTransferred  - bytes transferred
    LARGE_INTEGER StreamSize             - bytes in stream
    LARGE_INTEGER StreamBytesTransferred - bytes transferred for stream
    DWORD dwStreamNumber                 - current stream
    DWORD dwCallbackReason               - callback reason
    HANDLE hSourceFile                   - handle to source file
    HANDLE hDestinationFile              - handle to destination file
    LPVOID lpData                        - user data, CopyState

Return Value:

    PROGRESS_CONTINUE, PROGRESS_STOP, or PROGRESS_CANCEL

*/
static DWORD CALLBACK CancelOnFirst(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
    {
    if(!lpData) return PROGRESS_CONTINUE;

    CopyState *state = (CopyState*)lpData;
    HANDLE hLog = state->hLog;
    state->totalBytesTransferred = TotalBytesTransferred.QuadPart;

    if(dwCallbackReason == CALLBACK_CHUNK_FINISHED) return PROGRESS_CANCEL;
    else return PROGRESS_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\deletefile.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    DeleteFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the DeleteFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::DeleteFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL DeleteFile(
      LPCTSTR lpFileName   // file name
    );
    */
    xSetFunctionName(hLog, "DeleteFile");

    char lpFile1[80];
    unsigned i;

    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("lpPathName == NU")
        {
        if(DeleteFile(lpNull) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("lpPathName == \"\"")
        {
        if(DeleteFile(lpNull) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Existing file \\DeleteFile.txt")
        {
        sprintf(lpFile1, "%s:\\FDF01_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Existing large file \\DeleteFile_bigfile.txt")
        {
        sprintf(lpFile1, "%s:\\FDF02_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1, MEGABYTE*5);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Existing file \\a")
        {
        sprintf(lpFile1, "%s:\\%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1, KILOBYTE);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("lpPathName == \" \"")
        {
        if(DeleteFile(lpSpace) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Missing file \\MissingDeleteFile.txt")
        {
        if(DeleteFile("C:\\MissingDeleteFile.txt") == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE(BASE_DRIVE ":\\")
        {
        if(DeleteFile(BASE_DRIVE ":\\") == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory \\DeleteFileDir")
        {
        sprintf(lpFile1, "%s:\\FDF03_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        if(DeleteFile(lpFile1) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        RemoveDirectory(lpFile1);
        } ENDTESTCASE;
    TESTCASE("Directory .")
        {
        if(DeleteFile(lpCurrentDir) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory ..")
        {
        if(DeleteFile(lpParentDir) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            if(DeleteFile(invalidFileNames[i]) == FALSE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    // TODO over max path and 32000

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\createdirectory.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CreateDirectory.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the CreateDirectory API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    
*/
DWORD FILEIO::CreateDirectory_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL CreateDirectory(
      LPCTSTR lpPathName,                         // directory name
      LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    );
    */
    xSetFunctionName(hLog, "CreateDirectory");

    unsigned i=0;
    char *buffer = new char[65536];
    if(!buffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }


    char lpFile1[80]; sprintf(lpFile1, BASE_DRIVE ":\\FCD01_%d", ThreadID);
    char lpFile1Sub1[80]; sprintf(lpFile1Sub1, BASE_DRIVE ":\\FCD01_%d\\FCD02_%d", ThreadID, ThreadID);
    char lpFile1Sub2[80]; sprintf(lpFile1Sub2, BASE_DRIVE ":\\FCD01_%d\\FCD03_%d", ThreadID, ThreadID);
    //char lpFile2[80]; sprintf(lpFile2, BASE_DRIVE ":\\FCD0_%d",  ThreadID);
    char lpFile3[80]; sprintf(lpFile3, BASE_DRIVE ":\\FCD04_%d", ThreadID);
    char lpTemp[80];

    // initialize system state
    RemoveDirectory(lpFile1Sub1);
    RemoveDirectory(lpFile1Sub1);
    RemoveDirectory(lpFile1);
    //RemoveDirectory(lpFile2);
    RemoveDirectory(lpFile3);


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("lpPathName == NU")
        {
        if(CreateDirectory(lpNull, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("lpPathName == \"\"")
        {
        if(CreateDirectory(lpEmpty, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Creating CreateDirectory")
        {
        if(CreateDirectory(lpFile1, NULL) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        // this directory is used below
        } ENDTESTCASE;
    TESTCASE("Creating CreateSubDirectory")
        {
        if(CreateDirectory(lpFile1Sub1, NULL) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        // this directory is used below
        } ENDTESTCASE;
    /*
    TESTCASE("Creating \"\\ CreateDirectory2\"")
        {
        if(CreateDirectory(lpFile2, NULL) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        // this directory is used below
        } ENDTESTCASE;
    TESTCASE("Creating \\CreateDirectory\\.\\..\\.\\CreateDirectory4")
        {
        // Note this test depends on a directory created above
        if(CreateDirectory(lpFile1Sub2, NULL) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        RemoveDirectory(lpFile1Sub2);
        } ENDTESTCASE;
*/

    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Creating \" \"")
        {
        if(CreateDirectory(" ", NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        RemoveDirectory(" ");
        } ENDTESTCASE;
    TESTCASE("Recreating CreateSubDirectory")
        {
        // Note this test depends on a directory created above
        if(CreateDirectory(lpFile1Sub1, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        RemoveDirectory(lpFile1Sub1);
        } ENDTESTCASE;
    TESTCASE("Recreating \\CreateDirectory")
        {
        // Note this test depends on a directory created above
        if(CreateDirectory(lpFile1, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        RemoveDirectory(lpFile1);
        } ENDTESTCASE;
    /*
    TESTCASE("Recreating \"\\ CreateDirectory2\"")
        {
        // Note this test depends on a directory created above
        if(CreateDirectory(lpFile2, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        RemoveDirectory(lpFile2);
        } ENDTESTCASE;
        */
    TESTCASE("Creating " BASE_DRIVE ":\\")
        {
        if(CreateDirectory(BASE_DRIVE ":\\", NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        RemoveDirectory(BASE_DRIVE ":\\");
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            if(CreateDirectory(invalidFileNames[i], NULL) == FALSE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    //////////////////////////////////////////////////////////////////////////
    // MAXPATH limit
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Creating directories up to maxpath")
        {
        sprintf(buffer, "%s:", BASE_DRIVE);
        sprintf(lpTemp, "\\dir%06d", ThreadID);
        for(i=0; i<25; i++)
            {
            strcat(buffer + i*10, lpTemp);
            if(CreateDirectory(buffer, NULL) != TRUE)
                {
                if(i != 24)
                    {
                    TESTFAIL(hLog, "dir #%d (ec: %ld)", i, GetLastError());
                    break;
                    }
                }
            }
        if(i == 25) TESTPASS(hLog, "(ec: %ld)", GetLastError());
        for(; i>0; i--)
            {
            buffer[i*10+2] = 0;
            RemoveDirectory(buffer);
            }
        } ENDTESTCASE;


    TESTCASE("Creating 512 directories")
        {
        DWORD dirnum;
        DWORD err;

        CreateDirectory(BASE_DRIVE ":\\many", NULL);
        const unsigned int maxStress = 777;

        DebugPrint("'CreateDirectory'ing...\n");
        for(unsigned i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
            sprintf(buffer, "%s:\\many\\dir%lu", BASE_DRIVE, i);
            if(CreateDirectory(buffer, NULL) == FALSE)
                {
                err = GetLastError();
                break;
                }
            err = 0;
            }

        DebugPrint("'RemoveDirectory'ing...\n");
        do  {
            --i;
            if(i%(maxStress/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
            sprintf(buffer, "%s:\\many\\dir%lu", BASE_DRIVE, i);
            if(RemoveDirectory(buffer) == FALSE)
                {
                err = GetLastError();
                break;
                }
            err = 0;
            } while(i != 0);

        RemoveDirectory(BASE_DRIVE ":\\many");
        } ENDTESTCASE;

    //////////////////////////////////////////////////////////////////////////
    // 32000 limit
    //////////////////////////////////////////////////////////////////////////
    // this test takes a very very long time


    //////////////////////////////////////////////////////////////////////////
    // multiple directories
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("Creating as many directories as possible")
        {
        // this test takes a very very long time and should not be 
        // apart of the bvt

        DWORD dirnum;
        DWORD err;

        CreateDirectory(BASE_DRIVE ":\\many", NULL);

        DebugPrint("'CreateDirectory'ing...\n");
        for(dirnum=0; dirnum<(((DWORD)~0)-1); dirnum++)
            {
            if(dirnum%1000==0) DebugPrint("   (%d) %lu\n", ThreadID, dirnum);
            sprintf(buffer, "%s:\\many\\dir%lu", BASE_DRIVE, dirnum);
            if(CreateDirectory(buffer, NULL) == FALSE)
                {
                err = GetLastError();
                break;
                }
            err = 0;
            }

        DebugPrint("   (%d) Got to %lu with error: %lu\n", ThreadID, dirnum, err);

        DebugPrint("'RemoveDirectory'ing...\n");
        do  {
            --dirnum;
            if(dirnum%1000==0) DebugPrint("   (%d) %lu\n", ThreadID, dirnum);
            sprintf(buffer, "%s:\\many\\dir%lu", BASE_DRIVE, dirnum);
            if(RemoveDirectory(buffer) == FALSE)
                {
                err = GetLastError();
                break;
                }
            err = 0;
            } while(dirnum != 0);

        DebugPrint("   (%d) Got to %lu with error: %lu\n", ThreadID, dirnum, err);
        RemoveDirectory(BASE_DRIVE ":\\many");

        } ENDTESTCASE;
        */

    //////////////////////////////////////////////////////////////////////////
    // LPSECURITY_ATTRIBUTES
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("SA = {0,0,0}")
        {
        if(CreateDirectory(lpFile1, &saEmpty) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });
    TESTCASE("SA = { 0xF000BAAA, (PISECURITY_DESCRIPTOR)0xF000BAAA, 0xF000BAAA};")
        {
        if(CreateDirectory(lpFile1, &saBogus) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });
    TESTCASE("SA = { size, 0, 0 }")
        {
        if(CreateDirectory(lpFile1, &saEmptyWithSize) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });
    TESTCASE("SA = { size, &sdEmpty, 0 }")
        {
        if(CreateDirectory(lpFile1, &saWithEmptySD) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });
    TESTCASE("SA = { size, &sdBogus, 0 }")
        {
        if(CreateDirectory(lpFile1, &saWithBogusSD) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });
        */

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    delete[] buffer;

    RemoveDirectory(lpFile1Sub1);
    RemoveDirectory(lpFile1Sub1);
    RemoveDirectory(lpFile1);
    //RemoveDirectory(lpFile2);
    RemoveDirectory(lpFile3);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\copyfile.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CopyFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the CopyFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    DWORD - 

*/
DWORD FILEIO::CopyFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL CopyFile(
      LPCTSTR lpExistingFileName, // name of an existing file
      LPCTSTR lpNewFileName,      // name of new file
      BOOL bFailIfExists          // operation if file exists
    );
    */
    xSetFunctionName(hLog, "CopyFile");

    char lpSmallFile[80]; sprintf(lpSmallFile, BASE_DRIVE ":\\FCP01_%d.txt", ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, BASE_DRIVE ":\\FCP02_%d.txt", ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, BASE_DRIVE ":\\FCP03_%d.bla", ThreadID);
    char lpFile1[80]; sprintf(lpFile1, BASE_DRIVE ":\\FCP04_%d.txt", ThreadID);
    char lpFile2[80]; sprintf(lpFile2, BASE_DRIVE ":\\FCP05_%d.txt", ThreadID);
    char lpFile3[80]; sprintf(lpFile3, BASE_DRIVE ":\\FCP06_%d.txt", ThreadID);
    char lpFileTemp1[80];
    unsigned i;

    // initialize system state
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);
    DeleteFile(lpFakeFile);
    DeleteFile(lpBigFile);
    DeleteFile(lpSmallFile);
    CreateFilledFile(lpSmallFile, KILOBYTE*16);
    CreateFilledFile(lpBigFile, MEGABYTE*75);

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(NULL, exists, true)")
        {
        if(CopyFile(lpNull, lpSmallFile, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, NULL, true)")
        {
        BUGGEDPASS(56, "ACCESS VIOLATION \"By Design\"");
        if(CopyFile(lpSmallFile, lpNull, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(NULL, exists, false)")
        {
        if(CopyFile(lpNull, lpSmallFile, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, NULL, false)")
        {
        BUGGEDPASS(56, "ACCESS VIOLATION \"By Design\"");
        if(CopyFile(lpSmallFile, lpNull, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(nonexists, NULL, false)")
        {
        if(CopyFile(lpFakeFile, lpNull, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(NULL, nonexists, false)")
        {
        if(CopyFile(lpNull, lpFakeFile, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(\"\", exists, true)")
        {
        if(CopyFile(lpEmpty, lpSmallFile, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, \"\", true)")
        {
        if(CopyFile(lpSmallFile, lpEmpty, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(\"\", exists, false)")
        {
        if(CopyFile(lpEmpty, lpSmallFile, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, \"\", false)")
        {
        if(CopyFile(lpSmallFile, lpEmpty, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(nonexists, \"\", false)")
        {
        if(CopyFile(lpFakeFile, lpEmpty, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(\"\", nonexists, false)")
        {
        if(CopyFile(lpEmpty, lpFakeFile, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(exists, nonexists, true)")
        {
        if(CopyFile(lpSmallFile, lpFile1, TRUE) == TRUE && FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, nonexists, false)")
        {
        if(CopyFile(lpSmallFile, lpFile2, FALSE) == TRUE && FileExists(lpFile2))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, exists, false)")
        {
        if(CopyFile(lpSmallFile, lpFile1, FALSE) == TRUE && FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(exists, exists, true)")
        {
        if(CopyFile(lpSmallFile, lpFile1, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(nonexists, nonexists, false)")
        {
        if(CopyFile(lpFakeFile, lpFile3, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, nonexist\\nonexists, false)")
        {
        sprintf(lpFileTemp1, "%s:\\FCP\\FCP07_%d.txt", BASE_DRIVE, ThreadID);
        if(CopyFile(lpFakeFile, lpFileTemp1, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            if(CopyFile(lpSmallFile, invalidFileNames[i], FALSE) == FALSE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    //////////////////////////////////////////////////////////////////////////
    // copy abc to abc
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(file1, file1, true)")
        {
        if(CopyFile(lpBigFile, lpBigFile, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(file1, file1, false)")
        {
        if(CopyFile(lpBigFile, lpBigFile, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        for(i=0; i<10; i++)
            {
            DebugPrint("   (%d) %02d%%\n", ThreadID, i*10);
            CopyFile(lpSmallFile, lpFile1, FALSE);
            CopyFile(lpBigFile, lpFile2, FALSE);
            }
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    xSetFunctionName(hLog, "DeleteFile");
    TESTCASE("Removing CopyFile_file1.txt")
        {
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing CopyFile_file2.txt")
        {
        if(DeleteFile(lpFile2) == TRUE && !FileExists(lpFile2))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing CopyFile_file3.txt")
        {
        if(DeleteFile(lpFile3) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing non existant file")
        {
        if(DeleteFile(lpFakeFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing large file")
        {
        if(DeleteFile(lpBigFile) != FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing small file")
        {
        if(DeleteFile(lpSmallFile) != FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;



    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\createfile.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CreateFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

namespace FILEIO 
    {
    bool WriteBigFile(char *filename, DWORD size, unsigned char fill);
    }

/*

Routine Description:

    Tests the CreateFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

Notes:

    Cases for the below flags are handled in the ReadFile/WriteFile tests
        FILE_FLAG_RANDOM_ACCESS
        FILE_FLAG_SEQUENTIAL_SCAN
        FILE_FLAG_WRITE_THROUGH
    
*/
DWORD FILEIO::CreateFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    extern DWORD stressMode;
    /*
    HANDLE CreateFile(
      LPCTSTR lpFileName,                         // file name
      DWORD dwDesiredAccess,                      // access mode
      DWORD dwShareMode,                          // share mode
      LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
      DWORD dwCreationDisposition,                // how to create
      DWORD dwFlagsAndAttributes,                 // file attributes
      HANDLE hTemplateFile                        // handle to template file
    );
    */
    xSetFunctionName(hLog, "CreateFile");

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FCF01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\FCF02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%s:\\FCF03_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile4[80]; sprintf(lpFile4, "%s:\\FCF04_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile5[80]; sprintf(lpFile5, "%s:\\FCF05_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%s:\\FCF06_%d.txt", BASE_DRIVE, ThreadID);
    char lpTemp[80];
    char lpTemp2[80];

    HANDLE hFile = NULL;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;
    unsigned i;

    // initialize system state
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);
    DeleteFile(lpFile4);
    DeleteFile(lpFile5);
    DeleteFile(lpFakeFile);

    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("All NUL")
        {
        hFile = CreateFile(lpNull, 0, 0, NULL, 0, 0, hNull);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("All NULL + INVALID_HANDLE_VALUE")
        {
        hFile = CreateFile(lpNull, 0, 0, NULL, 0, 0, INVALID_HANDLE_VALUE);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("NULL and Empty Name/SA")
        {
        hFile = CreateFile(lpEmpty, 0, 0, &saEmpty, 0, 0, hNull);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("NULL and Empty Name/SA (SA with size)")
        {
        hFile = CreateFile(lpEmpty, 0, 0, &saEmptyWithSize, 0, 0, hNull);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("NULL and Empty Name/SA (SA with size and empty SD)")
        {
        hFile = CreateFile(lpEmpty, 0, 0, &saWithEmptySD, 0, 0, hNull);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("NULL (SA with size and empty SD)")
        {
        hFile = CreateFile(lpNull, 0, 0, &saWithEmptySD, 0, 0, hNull);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("New file NULL (SA with size and empty SD)")
        {
        hFile = CreateFile(lpFile1, 0, 0, &saWithEmptySD, 0, 0, hNull);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        DeleteFile(lpFile1);
        } ENDTESTCASE;
*/

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Create new file write")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("Create new file write/read")
        {
        hFile = CreateFile(lpFile2, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpFile2))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("Create new file read")
        {
        hFile = CreateFile(lpFile3, GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpFile3))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("Open existing file write")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        DeleteFile(lpFile1);
        } ENDTESTCASE;
    TESTCASE("Open existing file write/read")
        {
        hFile = CreateFile(lpFile2, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile2);});
    TESTCASE("Open existing file read")
        {
        hFile = CreateFile(lpFile3, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile3);});
    TESTCASE("ReOpen an opened file with read access")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile1 = CreateFile(lpFile1, STANDARD_RIGHTS_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile1 != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); CloseHandle(hFile1); DeleteFile(lpFile1);});
    TESTCASE("ReOpen an opened file with write access")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile1 = CreateFile(lpFile1, STANDARD_RIGHTS_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile1 != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); CloseHandle(hFile1); DeleteFile(lpFile1);});
    TESTCASE("ReOpen an opened file with read write access")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile1 = CreateFile(lpFile1, STANDARD_RIGHTS_WRITE | STANDARD_RIGHTS_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile1 != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); CloseHandle(hFile1); DeleteFile(lpFile1);});
    TESTCASE("TRUNCATE_EXISTING 16k")
        {
        DWORD filesize;
        sprintf(lpTemp, "%s:\\FCF08_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpTemp, 16*KILOBYTE+7); // 7 is just randomness

        hFile = CreateFile(lpTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS | TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        if((filesize=GetFileSize(hFile, NULL)) == 0)
            TESTPASS(hLog, "GetFileSize[%lu] (ec: %ld)", filesize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize[%lu] (ec: %ld)", filesize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("TRUNCATE_EXISTING 16meg")
        {
        DWORD filesize;
        sprintf(lpTemp, "%s:\\FCF08_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpTemp, 16*MEGABYTE+7); // 7 is just randomness

        hFile = CreateFile(lpTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS | TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        if((filesize=GetFileSize(hFile, NULL)) == 0)
            TESTPASS(hLog, "GetFileSize[%lu] (ec: %ld)", filesize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize[%lu] (ec: %ld)", filesize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("DELETE_ON_CLOSE existing file")
        {
        sprintf(lpTemp, "%s:\\FCF09_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpTemp, 16*MEGABYTE+7); // 7 is just randomness

        hFile = CreateFile(lpTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        CloseHandle(hFile);

        if(! FileExists(lpTemp))
            TESTPASS(hLog, "FileExists (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FileExists (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpTemp);});
    TESTCASE("DELETE_ON_CLOSE new file")
        {
        sprintf(lpTemp, "%s:\\FCF10_%d.txt", BASE_DRIVE, ThreadID);

        hFile = CreateFile(lpTemp, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        FillFile(hFile, 16*MEGABYTE+7); // 7 is just randomness

        CloseHandle(hFile);

        if(! FileExists(lpTemp))
            TESTPASS(hLog, "FileExists (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FileExists (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpTemp);});
    /*
    TESTCASE("\\Device\\Harddisk0")
        {
        hFile = CreateFile("\\Device\\Harddisk0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); });
    TESTCASE("\\Device\\HardDisk0\\Paritition1")
        {
        hFile = CreateFile("\\Device\\HardDisk0\\Paritition1", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); });
    TESTCASE("\\" BASE_DRIVE ":")
        {
        hFile = CreateFile("\\" BASE_DRIVE ":", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); });
    */
    TESTCASE("FILE_FLAG_BACKUP_SEMANTICS")
        {
        CreateFilledFile(lpFile3, 16*KILOBYTE+7); // 7 is just randomness
        hFile = CreateFile(lpFile3, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile3);});
    TESTCASE("Multiple dots")
        {
        sprintf(lpTemp, "%s:\\a.b.c.d.e.f.g.h", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("Leading dot")
        {
        sprintf(lpTemp, "%s:\\.dot", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("Trailing dot")
        {
        sprintf(lpTemp, "%s:\\dot.", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("Spaces")
        {
        sprintf(lpTemp, "%s:\\a b c d e f g h", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("Leading space")
        {
        sprintf(lpTemp, "%s:\\ space", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("Trailing space")
        {
        sprintf(lpTemp, "%s:\\space ", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("3.8")
        {
        sprintf(lpTemp, "%s:\\abc.zxcvbnmq", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("13 chars")
        {
        sprintf(lpTemp, "%s:\\0123456789012", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("20 chars")
        {
        sprintf(lpTemp, "%s:\\01234567890123456789", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("41 chars")
        {
        sprintf(lpTemp, "%s:\\01234567890123456789012345678901234567890", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("42 chars")
        {
        sprintf(lpTemp, "%s:\\012345678901234567890123456789012345678901", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("Write Open to a file with RO attrib")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_READONLY, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE_CLEAN({ SetFileAttributes(lpFile1, FILE_ATTRIBUTE_NORMAL); DeleteFile(lpFile1); });
    TESTCASE("ReadWrite Open to a file with RO attrib")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_READONLY, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE_CLEAN({ SetFileAttributes(lpFile1, FILE_ATTRIBUTE_NORMAL); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Create new \\\\?")
        {
        sprintf(lpTemp, "\\\\?\\%s:\\FCF07_%d.txt", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            DeleteFile(lpTemp);
            }
        } ENDTESTCASE;
    TESTCASE("43 chars")
        {
        sprintf(lpTemp, "%s:\\0123456789012345678901234567890123456789012", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            DeleteFile(lpTemp);
            }
        } ENDTESTCASE;
    TESTCASE("Open nonexisting file write")
        {
        hFile = CreateFile(lpFakeFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("Open new file relative")
        {
        hFile = CreateFile("FCF11.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            DeleteFile("CreateFileRel.txt");
            }
        } ENDTESTCASE;
    TESTCASE("Open nonexisting file write/read")
        {
        hFile = CreateFile(lpFakeFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("Open nonexisting file read")
        {
        hFile = CreateFile(lpFakeFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("New only on existing file")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        CloseHandle(hFile);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("New only on existing write/read")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        CloseHandle(hFile);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("New only on existing file read")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        CloseHandle(hFile);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile = CreateFile(lpFile1, GENERIC_READ, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("Open a directory read only")
        {
        sprintf(lpTemp, "%s:\\FCF12_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpTemp, NULL);
        if(!FileExists(lpTemp))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        hFile = CreateFile(lpTemp, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpTemp); });
    TESTCASE("Open a directory write")
        {
        sprintf(lpTemp, "%s:\\FCF13_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpTemp, NULL);
        if(!FileExists(lpTemp))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        hFile = CreateFile(lpTemp, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpTemp); });
    TESTCASE("ReOpen an opened file with exclusive access")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile1 = CreateFile(lpFile1, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile1 == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile1);
            }
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("TRUNCATE_EXISTING no Rights")
        {
        sprintf(lpTemp, "%s:\\FCF14_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpTemp, 16*KILOBYTE+7); // 7 is just randomness

        hFile = CreateFile(lpTemp, GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS | TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    /*
    TESTCASE("Template File")
        {
        sprintf(lpTemp, "%s:\\FCF15_%d.txt", BASE_DRIVE, ThreadID);
        sprintf(lpTemp2, "%s:\\FCF16_%d.txt", BASE_DRIVE, ThreadID);

        hFile = CreateFile(lpTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        hFile1 = CreateFile(lpTemp2, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, hFile);
        if(hFile1 == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        CloseHandle(hFile);
        CloseHandle(hFile1);
        } ENDTESTCASE_CLEAN({ DeleteFile(lpTemp); DeleteFile(lpTemp2); });
        */
    TESTCASE("\\\\.\\C:")
        {
        hFile = CreateFile("\\\\.\\C:", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("\\\\?\\Volume{GUID0}\\")
        {
        hFile = CreateFile("\\\\?\\Volume{00000000-0000-0000-0000-000000000000}\\", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("\\\\?\\Volume{GUID1}\\")
        {
        hFile = CreateFile("\\\\?\\Volume{00000000-0000-0000-0000-000000000001}\\", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("\\\\?\\Volume{GUIDF}\\")
        {
        hFile = CreateFile("\\\\?\\Volume{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\\", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            hFile = CreateFile(invalidFileNames[i], GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile == INVALID_HANDLE_VALUE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                {
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
                CloseHandle(hFile);
                }
            } ENDTESTCASE;
        }


    // TODO
    // write access to cd/dvd file


    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Close the handle twice")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(CloseHandle(hFile) == TRUE)
            TESTPASS(hLog, "1st CloseHandle (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "1st CloseHandle (ec: %ld)", GetLastError());

        if(CloseHandle(hFile) == FALSE)
            TESTPASS(hLog, "2nd CloseHandle (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "2nd CloseHandle (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });

    TESTCASE("Move Cache Entries") // for bug 1229
        {
        char *buffer = new char[1024];
        if(!buffer) break;
        DWORD size = sprintf(buffer, "Read and write to different files to screw with the cache\r\n");
        DWORD size2;
        hFile = CreateFile(lpFile1, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        hFile1 = CreateFile(lpFile2, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        // expand the files while reading and writting from them
        for(unsigned i=1024; i<15*MEGABYTE; i+=(PAGESIZE+123))
            {
            SetFilePointer(hFile, i, NULL, FILE_BEGIN);
            SetFilePointer(hFile1, i, NULL, FILE_BEGIN);
            SetEndOfFile(hFile);
            SetEndOfFile(hFile1);
            for(unsigned j=0; j<4; j++)
                {
                SetFilePointer(hFile, rand()*i/RAND_MAX, NULL, FILE_BEGIN);
                WriteFile(hFile, buffer, size, &size2, NULL);
                SetFilePointer(hFile, rand()*i/RAND_MAX, NULL, FILE_BEGIN);
                ReadFile(hFile, buffer+512, 128, &size2, NULL);

                SetFilePointer(hFile1, rand()*i/RAND_MAX, NULL, FILE_BEGIN);
                WriteFile(hFile1, buffer, size, &size2, NULL);
                SetFilePointer(hFile1, rand()*i/RAND_MAX, NULL, FILE_BEGIN);
                ReadFile(hFile1, buffer+512, 128, &size2, NULL);
                }
            }

        if(CloseHandle(hFile) == TRUE)
            TESTPASS(hLog, "CloseHandle(file1) (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CloseHandle(file1) (ec: %ld)", GetLastError());
        if(CloseHandle(hFile1) == TRUE)
            TESTPASS(hLog, "CloseHandle(file2) (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CloseHandle(file2) (ec: %ld)", GetLastError());

        delete[] buffer;
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); DeleteFile(lpFile2); });

    TESTCASE("Fragmented Cache Entries") // for bug 1229 + 4804
        {
        char *rbuffer = new char[9*MEGABYTE];
        if(!rbuffer) break;
        char *wbuffer = new char[9*MEGABYTE];
        if(!wbuffer) { delete[] rbuffer; break;}

        DWORD size, wSize, rSize;
        const unsigned NUMFILES = 4097;

        // create the files
        for(unsigned i=0; i<NUMFILES; i++)
            {
            sprintf(lpTemp, "%s:\\FCF20_%04u_%d.txt", BASE_DRIVE, i, ThreadID);
            hFile = CreateFile(lpTemp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if(i % 256 == 0)
                SetFilePointer(hFile, 8192 * 100, NULL, FILE_BEGIN);
            else
                SetFilePointer(hFile, 100, NULL, FILE_BEGIN);
            WriteFile(hFile, "FCF", 3, &wSize, NULL);
            CloseHandle(hFile);
            }
        // delete half of them
        for(unsigned i=0; i<NUMFILES; i+=2)
            {
            sprintf(lpTemp, "%s:\\FCF20_%04u_%d.txt", BASE_DRIVE, i, ThreadID);
            DeleteFile(lpTemp);
            }

        // create and write a big file
        DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxChunks = 64;
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            xLog(hLog, XLL_FAIL, "Unable to open file (ec: %ld)", GetLastError());
            }
        else
            {
            for(size=0; size<MEGABYTE*8; size++)
                {
                wbuffer[size] = (char)~size;
                }
            for(unsigned int i=0; i<maxChunks; i++)
                {
                if(i%6==0) DebugPrint("   (%d) %02d%%\n", ThreadID, 50*i/maxChunks);
                if(! (WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size))
                    break;
                }

            if(i == maxChunks)
                TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", size*i, GetLastError());
            else
                TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", size*i, GetLastError());

            if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
                {
                xLog(hLog, XLL_FAIL, "Unable to reset file pointer (ec: %ld)", GetLastError());
                }

            for(unsigned j=0; j<i; j++)
                {
                if(j%6==0) DebugPrint("   (%d) %02d%%\n", ThreadID, 50*j/maxChunks + 50);
                if(! (ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size))
                    break;

                if(! (wSize == rSize && memcmp(rbuffer, wbuffer, size) == 0))
                    break;
                }

            if(j == i)
                {
                TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", size*j, GetLastError());
                TESTPASS(hLog, "Write Buffer == Read Buffer");
                }
            else
                {
                if(! (wSize == rSize && memcmp(rbuffer, wbuffer, size) == 0))
                    {
                    TESTFAIL(hLog, "Write Buffer != Read Buffer");
                    }
                else
                    {
                    TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", size*j, GetLastError());
                    }
                }
            DebugPrint("   (%d) 100%%\n", ThreadID);
            }

        // cleanup
        for(unsigned i=1; i<NUMFILES; i+=2)
            {
            sprintf(lpTemp, "%s:\\FCF20_%04u_%d.txt", BASE_DRIVE, i, ThreadID);
            DeleteFile(lpTemp);
            }
        delete[] wbuffer;
        delete[] rbuffer;
        } ENDTESTCASE_CLEAN({  CloseHandle(hFile); DeleteFile(lpFile1); });

    TESTCASE("Evil HD Bugs")
        {
        if(stressMode != 1) break; // only run this test in stress mode
        unsigned i;
        unsigned maxStress;

        // 1 meg files
        maxStress = 5000;
        DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        for(i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
            sprintf(lpTemp, "%s:\\FCF21_%04u_%d.txt", TITLE_DRIVE, i, ThreadID);
            WriteBigFile(lpTemp, MEGABYTE, (unsigned char)i);
            }
        for(i=0; i<maxStress; i++)
            {
            sprintf(lpTemp, "%s:\\FCF21_%04u_%d.txt", TITLE_DRIVE, i, ThreadID);
            DeleteFile(lpTemp);
            }
        DebugPrint("   (%d) 100%%\n", ThreadID);

        // 50 meg files
        maxStress = 10000;
        DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        for(i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
            sprintf(lpTemp, "%s:\\FCF22_%04u_%d.txt", TITLE_DRIVE, i, ThreadID);
            WriteBigFile(lpTemp, 50*MEGABYTE, (unsigned char)i);
            }
        for(i=0; i<maxStress; i++)
            {
            sprintf(lpTemp, "%s:\\FCF22_%04u_%d.txt", TITLE_DRIVE, i, ThreadID);
            DeleteFile(lpTemp);
            }
        DebugPrint("   (%d) 100%%\n", ThreadID);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    int stressCount=0;
    int maxStress;
    if(stressMode == 1) maxStress = 500; // small number of handles in stress mode
    else maxStress = 1*MEGABYTE;
    HANDLE *handList = new HANDLE[maxStress];
    TESTCASE("Mini Stress")
        {
        if(!handList)
            {
            BLOCKED(0, "Unable to allocate memory, test skipped");
            }

        DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        for(stressCount=0; stressCount<maxStress; stressCount++)
            {
            if(stressCount%(maxStress/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, stressCount*100/maxStress);
            handList[stressCount] = CreateFile(lpFile5, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);
            if(handList[stressCount] == INVALID_HANDLE_VALUE)
                {
                xLog(hLog, XLL_INFO, "Stopped at %d (ec: %ld)", stressCount, GetLastError());
                break;
                }
            }
        } ENDTESTCASE;
    for(--stressCount; stressCount>=0; stressCount--)
        {
        CloseHandle(handList[stressCount]);
        }
    DebugPrint("   (%d) 100%%\n", ThreadID);
    delete[] handList;
    DeleteFile(lpFile5);


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    // clean up
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);
    DeleteFile(lpFile4);
    DeleteFile(lpFile5);
    DeleteFile(lpFakeFile);

    return 0;
    }

bool FILEIO::WriteBigFile(char *filename, DWORD size, unsigned char fill)
    {
    unsigned chunkSize = PAGESIZE;
    char *buffer = new char[chunkSize];
    if(!buffer) return false;
    DWORD wSize;

    memset(buffer, fill, chunkSize);

    HANDLE hFile = CreateFile(filename, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        {
        delete[] buffer;
        return false;
        }

    for(unsigned int i=0; i<size; i+=chunkSize)
        {
        if(i+chunkSize > size) wSize = size-i;
        else wSize = chunkSize;
        if(! (WriteFile(hFile, buffer, wSize, &wSize, NULL) == TRUE && wSize == size))
            {
            CloseHandle(hFile);
            delete[] buffer;
            return false;
            }
        }

    CloseHandle(hFile);
    delete[] buffer;
    return true;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\fileio.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    fileio.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xlog.h>
#include "fileio_win32API.h"
#include "commontest.h"
#include "utils.h"
#include "xtestlib.h"

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

static ULONG ThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE FileIOHeapHandle;


BOOL WINAPI FileIODllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        FileIOHeapHandle = HeapCreate(0, 0, 0);

        if(!FileIOHeapHandle)
            {
            OutputDebugString(L"FILEIO: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(FileIOHeapHandle)
            {
            HeapDestroy(FileIOHeapHandle);
            }
        }

    return TRUE;
    }

static bool wcistrstr(WCHAR *string, WCHAR *substr, size_t len=0)
    {
    if(!string || ! substr) return false;
    if(!*string) return false;
    if(!len) len = wcslen(substr);
    if(_wcsnicmp(string, substr, len) == 0) return true;

    return wcistrstr(string+1, substr, len);
    }


/*

Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    DWORD threadNumber - sequential number of the thread
    DWORD loops - # of times to run test
    WCHAR* testname - specific name of a test to run

Return Value:

    DWORD

*/
namespace FILEIO {

DWORD stressMode = 0;


static DWORD RunAll(HANDLE hLog, DWORD threadNumber, DWORD loops, WCHAR *testname)
    {
    Sleep(threadNumber*200); // stagger the thread's execution a bit

    struct APIFUNCT
        {
        APITEST_FUNC f;
        WCHAR *name;
        };
    #define BUILTAPISTRUCT(n) { n , L#n }

    // Define all the API tests
    APIFUNCT testlist[] =
        {
        /*
        */
        BUILTAPISTRUCT(FILEIO::CopyFile_Test),
        BUILTAPISTRUCT(FILEIO::CopyFileEx_Test),
        BUILTAPISTRUCT(FILEIO::CreateDirectory_Test),
        BUILTAPISTRUCT(FILEIO::DeleteFile_Test),
        BUILTAPISTRUCT(FILEIO::FindFile_Test),
        BUILTAPISTRUCT(FILEIO::FlushFileBuffers_Test),
        BUILTAPISTRUCT(FILEIO::GetDiskFreeSpaceEx_Test),
        BUILTAPISTRUCT(FILEIO::GetFileInformationByHandle_Test),
        BUILTAPISTRUCT(FILEIO::GetFileSize_Test),
        BUILTAPISTRUCT(FILEIO::GetSetFileAttributes_Test),
        BUILTAPISTRUCT(FILEIO::GetSetFileTime_Test),
        BUILTAPISTRUCT(FILEIO::GetVolumeInformation_Test),
        BUILTAPISTRUCT(FILEIO::MoveFile_Test),
        BUILTAPISTRUCT(FILEIO::MoveFileWithProgress_Test),
        BUILTAPISTRUCT(FILEIO::ReadWriteFile_Test),
        BUILTAPISTRUCT(FILEIO::ReadWriteFileEx_Test),
        BUILTAPISTRUCT(FILEIO::ReadWriteFileGatherScatter_Test),
        BUILTAPISTRUCT(FILEIO::RemoveDirectory_Test),
        BUILTAPISTRUCT(FILEIO::SetEndOfFile_Test),
        BUILTAPISTRUCT(FILEIO::SetFilePointer_Test),
        BUILTAPISTRUCT(FILEIO::SetFilePointerEx_Test),
        BUILTAPISTRUCT(FILEIO::DVDRead_Test),
        BUILTAPISTRUCT(FILEIO::HardDriveFull_Test),
        BUILTAPISTRUCT(FILEIO::CreateFile_Test),        // CreateFile put last because we want the stress test run last
        /*
        */
        };

    bool runAll = _wcsicmp(testname, L"(all)") == 0 ? true : false;

    // Run the suite of tests
    for(DWORD i=0; i<loops; i++)
        {
        // run each test
        for(unsigned j=0; j<ARRAYSIZE(testlist); j++)
            {
            if(runAll || wcistrstr(testlist[j].name, testname))
                {
                xLog(hLog, XLL_INFO, "%ws() ******************************************", testlist[j].name);
                LogResourceStatus(hLog, false);
                DebugPrint("FILEIO(%d): Entering %ws()\n", threadNumber, testlist[j].name);
                testlist[j].f(hLog, threadNumber);
                }
            }
        }

    return 0;
    }
    } // namespace FILEIO


/*
DWORD Test(void)
    {
    MEMORYSTATUS stats;
    memset(&stats, 0, sizeof(MEMORYSTATUS));
    stats.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus(&stats);

    return 0;
    }
*/
    /*
DWORD Test(void)
    {

    DebugPrint("LeakCheck: HandleCount=   %lu\n (ec: %lu)", handles, err);

    HRESULT hr = S_OK;
    DWORD status;
    char m_pvBuffer[2048];

    //while(hr == S_OK)
        //{
        if(m_pvBuffer)
            {
            status = NtQuerySystemInformation(SystemProcessInformation, m_pvBuffer, 2048, NULL);

            // If we succeeded, great, get outta here.  If not, any error other
            // than "buffer too small" is fatal, in which case we bail
            if(NT_SUCCESS(status))
                {
                SYSTEM_PROCESS_INFORMATION *stats = (SYSTEM_PROCESS_INFORMATION*)m_pvBuffer;
                DebugPrint("LeakCheck: Threads=       %lu\n", stats->NumberOfThreads);
                DebugPrint("LeakCheck: WorkingSetSize=%lu\n", stats->WorkingSetSize);
                //break;
                }
            if(status != STATUS_INFO_LENGTH_MISMATCH)
                {
                DebugPrint("LeakCheck: ERROR from NtQuerySystemInformation %lX\n", status);
                hr = E_FAIL;
                //break;
                }
            }
/
        // Buffer wasn't large enough to hold the process info table, so resize it
        // to be larger, then retry.
        if(m_pvBuffer)
            {
            VirtualFree(m_pvBuffer, 0, MEM_RELEASE);
            m_pvBuffer = NULL;
            }
        m_cbBuffer += PROCBUF_GROWSIZE;
        m_pvBuffer = VirtualAlloc(NULL, m_cbBuffer, MEM_COMMIT, PAGE_READWRITE);
        if(m_pvBuffer == NULL)
            {
            hr = E_OUTOFMEMORY;
            DebugPrint("LeakCheck: ERROR E_OUTOFMEMORY\n");
            break;
            }*
        //}

    return hr;
    return 0;
    }
*/
/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI FileIOStartTest(HANDLE hLog)
    {
    DWORD ID = 0;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &ThreadID);


    // test settings
    const int buffLen = 1024;
    WCHAR testname[buffLen];
    DWORD loops;


    // Pull out internal INI file settings
    GetProfileString(L"fileio", L"testname", L"(all)", testname, buffLen);
    loops = GetProfileInt(L"fileio", L"loops", 1);
    FILEIO::stressMode = GetProfileInt(L"GeneralSettings", L"StressTestMode", 0);


    xSetOwnerAlias(hLog, "jpoley");
    xSetComponent(hLog, "Win32 API", "FILE IO");
    DebugPrint("FILEIO(%d): **************************************************************\n", ID);
    DebugPrint("FILEIO(%d): Entering StartTest()\n", ID);
    DebugPrint("FILEIO(%d): Internal INI Settings:\n", ID);
    DebugPrint("  loops=%lu\n", loops);
    DebugPrint("  testname=%ws\n", testname);


    switch(ID)
        {
        case 0:
        case 1:
        default:
            FILEIO::RunAll(hLog, ID, loops, testname);
            break;
        }


    DebugPrint("FILEIO(%d): Leaving StartTest()\n", ID);
    DebugPrint("FILEIO(%d): **************************************************************\n", ID);
    xSetOwnerAlias(hLog, NULL);
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI FileIOEndTest(void)
    {
    ThreadID = 0;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( fileio )
#pragma data_seg()

BEGIN_EXPORT_TABLE( fileio )
    EXPORT_TABLE_ENTRY( "StartTest", FileIOStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", FileIOEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", FileIODllMain )
END_EXPORT_TABLE( fileio )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\DVDRead.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    DVDRead.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the Read data (low level) from the DVD

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    DWORD - 

*/
DWORD FILEIO::DVDRead_Test(HANDLE hLog, DWORD ThreadID)
    {
    extern DWORD stressMode;
    /*
    */
    const unsigned blockSize = 2048;
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK statusBlock;
    HANDLE hVolume;
    LARGE_INTEGER offset;
    OBJECT_STRING deviceName;
    if(stressMode != 1) return 1; // only run this test in stress mode

    char *buffer = new char[blockSize+128];
    if(!buffer)
        {
        DebugPrint("FILEIO(%u): DVDRead_Test - Could not allocate enough memory\n", ThreadID);
        return 1;
        }


    RtlInitObjectString(&deviceName, "\\Device\\CdRom0");
    InitializeObjectAttributes(&obja, (POBJECT_STRING)&deviceName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_READ,
                        &obja,
                        &statusBlock,
                        FILE_SHARE_READ,
                        FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);
    if(NT_ERROR(status))
        {
        return 1;
        }

    unsigned readErrors = 0;

    offset.QuadPart = blockSize;
    for(unsigned i=0; i<50000; i++)
        {
        status = NtReadFile(hVolume,
                             0,
                             NULL,
                             NULL,
                             &statusBlock,
                             buffer,
                             blockSize,
                             &offset
                             );
        if(NT_ERROR(status))
            {
            ++readErrors;
            }
        offset.QuadPart += blockSize;
        }

    DebugPrint("FILEIO(%u): DVD Read Error Count %u\n", ThreadID, readErrors);

    delete[] buffer;
    NtClose(hVolume);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\fileio_win32api.h ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    fileio_win32API.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/

typedef DWORD (*APITEST_FUNC)(HANDLE hLog, DWORD ThreadID);

namespace FILEIO
    {
    //
    //  Win32 FILE IO Tests
    //
    extern DWORD CopyFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD CopyFileEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD CreateDirectory_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD CreateFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD DeleteFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD FindFile_Test(HANDLE hLog, DWORD ThreadID);
    //extern DWORD FindFirstFileEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD FlushFileBuffers_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetDiskFreeSpaceEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetDriveType_Test(HANDLE hLog, DWORD ThreadID);
    //extern DWORD GetFileAttributesEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetFileInformationByHandle_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetFileSize_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetLogicalDrives_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetSetFileAttributes_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetSetFileTime_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetVolumeInformation_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD MoveFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD MoveFileWithProgress_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD ReadWriteFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD ReadWriteFileEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD ReadWriteFileGatherScatter_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD RemoveDirectory_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD ReplaceFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD SetEndOfFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD SetFilePointer_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD SetFilePointerEx_Test(HANDLE hLog, DWORD ThreadID);

    extern DWORD DVDRead_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD HardDriveFull_Test(HANDLE hLog, DWORD ThreadID);

    } // namespace FILEIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\getdrivetype.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    GetDriveType.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the GetDriveType API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::GetDriveType_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    UINT GetDriveType(
      LPCTSTR lpRootPathName   // root directory
    );
    */
    xSetFunctionName(hLog, "GetDriveType");

    UINT type;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NU")
        {
        type = GetDriveType(lpNull);
        if(type == DRIVE_NO_ROOT_DIR)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Empty Root")
        {
        type = GetDriveType(lpEmpty);
        if(type == DRIVE_NO_ROOT_DIR)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Valid Root Drive")
        {
        type = GetDriveType(BASE_DRIVE ":\\");
        if(type == DRIVE_FIXED)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Valid Root Drive (UNC style)")
        {
        type = GetDriveType("\\\\?\\" BASE_DRIVE ":\\");
        if(type == DRIVE_FIXED)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == " BASE_DRIVE ":")
        {
        type = GetDriveType(BASE_DRIVE ":");
        if(type == DRIVE_FIXED)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("C:\\")
        {
        type = GetDriveType("C:\\");
        if(type == DRIVE_NO_ROOT_DIR)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Invalid Root Drive")
        {
        type = GetDriveType("Fuzzy");
        if(type == DRIVE_NO_ROOT_DIR)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == \" \"")
        {
        type = GetDriveType(" ");
        if(type == DRIVE_NO_ROOT_DIR)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == \":\\\"")
        {
        type = GetDriveType(":\\");
        if(type == DRIVE_NO_ROOT_DIR)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == \"C\\\"")
        {
        type = GetDriveType("C\\");
        if(type == DRIVE_NO_ROOT_DIR)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == \"CC:\\\"")
        {
        type = GetDriveType("CC:\\");
        if(type == DRIVE_NO_ROOT_DIR)
            TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        else
            TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////


    // go through each drive and verify output based on actual xbox hardware
    Pchar drives = new char[64];
    unsigned size = GetLogicalDriveStrings(64, drives);

    for(unsigned i=0; i<size/4; i++)
        {
        char testcase[64];
        sprintf(testcase, "Verify: %s", &drives[i*4]);
        TESTCASE(testcase)
            {
            type = GetDriveType(&drives[i*4]);
            // TODO verify actual drive w/ expected
            if(type == DRIVE_REMOVABLE || type == DRIVE_FIXED || type == DRIVE_CDROM)
                {
                TESTPASS(hLog, "Type = %d (ec: %ld)", type, GetLastError());
                }
            else
                {
                TESTFAIL(hLog, "Type = %d (ec: %ld)", type, GetLastError());
                }
            } ENDTESTCASE;
        }

    delete[] drives;


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\findfile.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    FindFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the FindFirstFile / FindNextFile / FindClose APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::FindFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL FindClose(
      HANDLE hFindFile   // file search handle
    );

    HANDLE FindFirstFile(
      LPCTSTR lpFileName,               // file name
      LPWIN32_FIND_DATA lpFindFileData  // data buffer
    );

    BOOL FindNextFile(
      HANDLE hFindFile,                // search handle 
      LPWIN32_FIND_DATA lpFindFileData // data buffer
    );
    */
    xSetFunctionName(hLog, "FindFile");

    WIN32_FIND_DATA findData;
    HANDLE hFind;
    unsigned i;

    char lpFile1[80];
    char lpFile2[80];

    // TODO verify data in fileData

    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE(TITLE_DRIVE ":\\*.*")
        {
        sprintf(lpFile1, "%s:\\*.*", TITLE_DRIVE);
        hFind = FindFirstFile(lpFile1, &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        do
            {
            // TODO verify
            } while(FindNextFile(hFind, &findData) == TRUE);
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("\\x*")
        {
        sprintf(lpFile1, "%s:\\FFF01_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, FALSE);
        sprintf(lpFile2, "%s:\\F*", BASE_DRIVE);
        hFind = FindFirstFile(lpFile2, &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        do
            {
            // TODO verify
            } while(FindNextFile(hFind, &findData) == TRUE);
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });
    TESTCASE("one match \\FFF*.*")
        {
        sprintf(lpFile1, "%s:\\FFF02_%d", BASE_DRIVE, ThreadID);
        sprintf(lpFile2, "%s*.*", lpFile1);
        CreateDirectory(lpFile1, FALSE);
        hFind = FindFirstFile(lpFile2, &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("C:\\*")
        {
        hFind = FindFirstFile("C:\\*", &findData);
        if(hFind == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        do
            {
            // TODO verify
            } while(FindNextFile(hFind, &findData) == TRUE);
        if(FindClose(hFind) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("no match \\qrz")
        {
        sprintf(lpFile1, "%s:\\qrz", BASE_DRIVE);
        hFind = FindFirstFile(lpFile1, &findData);
        if(hFind == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("\".\"")
        {
        hFind = FindFirstFile(".", &findData);
        if(hFind == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("\"..\"")
        {
        hFind = FindFirstFile("..", &findData);
        if(hFind == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("..\\*.*")
        {
        hFind = FindFirstFile("..\\*.*", &findData);
        if(hFind == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE(".\\*.*")
        {
        hFind = FindFirstFile(".\\*.*", &findData);
        if(hFind == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("FindFirst, FindClose, FindNext")
        {
        BUGGEDPASS(61, "Crash \"By Design\"");

        hFind = FindFirstFile("Z:\\*.*", &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("FindFirst, CloseHandle, FindNext, FindClose")
        {
        BUGGEDPASS(62, "Crash \"By Design\"");

        hFind = FindFirstFile("Z:\\*.*", &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(CloseHandle(hFind) != FALSE)
            TESTPASS(hLog, "CloseHandle (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CloseHandle (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;

    // Find Close tests
    /*
    TESTCASE("FindClose(NULL)")
        {
        if(FindClose(hNull) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("FindClose(INVALID_HANDLE_VALUE)")
        {
        if(FindClose(INVALID_HANDLE_VALUE) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("FindClose(bogus)")
        {
        if(FindClose(hBogus) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
        */
    TESTCASE("FileClose the handle twice")
        {
        BUGGEDPASS(63, "Crash \"By Design\"");

        hFind = FindFirstFile(BASE_DRIVE ":\\*", &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        if(FindClose(hFind) == FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        if(strstr(invalidFileNames[i], BASE_DRIVE ":\\<") != 0)
            {
            // This test should pass because of undocumented "feature" where '<' == '*'
            continue;
            }
        else if(strstr(invalidFileNames[i], BASE_DRIVE ":\\>") != 0)
            {
            // This test should pass because of undocumented "feature" where '<' == '*'
            continue;
            }
        else if(strstr(invalidFileNames[i], BASE_DRIVE ":\\*") != 0)
            {
            continue;
            }
        else if(strstr(invalidFileNames[i], BASE_DRIVE ":\\?") != 0)
            {
            continue;
            }
        TESTCASE(invalidFileNames[i])
            {
            hFind = FindFirstFile(invalidFileNames[i], &findData);
            if(hFind == INVALID_HANDLE_VALUE)
                TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
            if(FindNextFile(hFind, &findData) == FALSE)
                TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
            if(FindClose(hFind) == FALSE)
                TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }



    // FindNextFile
        // handle tests
            // NULL
            // bogus address
            // valid file handle
            // closed file handle
            // ro file
            // device handle
            // valid find file handle
            // closed find file handle (using FindClose)
            // closed file handle (using CloseHandle)
            // memory handle
        // LPWIN32_FIND_DATA
            // NULL
            // bogus address
        // find next when only 0 files match
        // find next when only 1 file matches
        // find next when only many files match
        // create a file that matches the criteria after i start searching
        // delete a file that matches the criteria after i start searching
        // verify LPWIN32_FIND_DATA is zeroed


    // FindFirstFile
        // filename tests
            // NULL
            // ""
            // filename/directories with spaces, etc.
            // * and ? wild cards
            // maxpath, 32000
            // use mixed / and \
            // spaces
            // .
            // ..
            // with < > : " / \ |
            // using device names: aux, con, lpt1, and prn
            // unc: \\?\UNC\poleyland1\public\tests
            // case insensitivity
        // LPWIN32_FIND_DATA
            // NULL
            // bogus address
        // find first when only 0 files match
        // find first when only 1 file matches
        // find first when only many files match


    // FindClose
        // handle tests
            // NULL
            // bogus address
            // valid file handle
            // closed file handle
            // ro file
            // device handle
            // valid find file handle
            // closed find file handle (using FindClose)
            // closed file handle (using CloseHandle)
            // memory handle


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\getdiskfreespaceex.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    GetDiskFreeSpaceEx.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the GetDiskFreeSpaceEx API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::GetDiskFreeSpaceEx_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL GetDiskFreeSpaceEx(
      LPCTSTR lpDirectoryName,                 // directory name
      PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
      PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
      PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
    );
    */
    xSetFunctionName(hLog, "GetDiskFreeSpaceEx");

    ULARGE_INTEGER available;
    ULARGE_INTEGER total;
    ULARGE_INTEGER free;
    unsigned i;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("GetDiskFreeSpaceEx(NULL, NULL, NULL, NULL)")
        {/*
        if(GetDiskFreeSpaceEx(lpNull, NULL, NULL, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());*/
        } ENDTESTCASE;
    TESTCASE("GetDiskFreeSpaceEx(\"\", NULL, NULL, NULL)")
        {
        if(GetDiskFreeSpaceEx(lpEmpty, NULL, NULL, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GetDiskFreeSpaceEx(\" \", NULL, NULL, NULL)")
        {
        if(GetDiskFreeSpaceEx(lpSpace, NULL, NULL, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("lpPathName == \"" CACHE_DRIVE ":\\\"")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx(CACHE_DRIVE ":\\", &available, &total, &free) == TRUE && available.QuadPart < total.QuadPart && available.QuadPart != ulBogus.QuadPart)
            TESTPASS(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        else
            TESTFAIL(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        } ENDTESTCASE;
    TESTCASE("lpPathName == \"" TITLE_DRIVE ":\\\"")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx(TITLE_DRIVE ":\\", &available, &total, &free) == TRUE && available.QuadPart < total.QuadPart && available.QuadPart != ulBogus.QuadPart)
            TESTPASS(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        else
            TESTFAIL(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        } ENDTESTCASE;
    TESTCASE("lpPathName == \"" USER_DRIVE ":\\\"")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx(USER_DRIVE ":\\", &available, &total, &free) == TRUE && available.QuadPart < total.QuadPart && available.QuadPart != ulBogus.QuadPart)
            TESTPASS(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        else
            TESTFAIL(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("lpPathName == \"c:\\\"")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx("c:\\", &available, &total, &free) == FALSE)
            TESTPASS(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        else
            TESTFAIL(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        } ENDTESTCASE;
    TESTCASE("lpPathName == .")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx(".", &available, &total, &free) == FALSE)
            TESTPASS(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        else
            TESTFAIL(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        } ENDTESTCASE;
    TESTCASE("lpPathName == \\")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx("\\", &available, &total, &free) == FALSE)
            TESTPASS(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        else
            TESTFAIL(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        } ENDTESTCASE;
    TESTCASE("(\"\\\", &a, &a, &a)")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx("\\", &available, &available, &available) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("lpPathName == \"y:\\\"")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx("y:\\", &available, &total, &free) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("lpPathName == GetDiskFreeSpaceEx")
        {
        available = total = free = ulBogus;
        if(GetDiskFreeSpaceEx("GetDiskFreeSpaceEx", &available, &total, &free) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            available = total = free = ulBogus;
            if(GetDiskFreeSpaceEx(invalidFileNames[i], &available, &total, &free) == FALSE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        //DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        for(i=0; i<100; i++)
            {
            //DebugPrint("   (%d) %02d%%\n", ThreadID, i*10);
            available = total = free = ulBogus;
            GetDiskFreeSpaceEx(BASE_DRIVE ":\\", &available, &total, &free);
            }
        } ENDTESTCASE_CLEAN({ /*DebugPrint("   (%d) 100%%\n", ThreadID);*/ });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    
    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\getfileinformationbyhandle.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    GetFileInformationByHandle.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the GetFileInformationByHandle API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::GetFileInformationByHandle_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL GetFileInformationByHandle(
      HANDLE hFile,                                  // handle to file 
      LPBY_HANDLE_FILE_INFORMATION lpFileInformation // buffer
    );
    */
    xSetFunctionName(hLog, "GetFileInformationByHandle");

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FGI01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\FGI02_%d.txt", BASE_DRIVE, ThreadID);
    unsigned i;

    CreateFilledFile(lpFile1, KILOBYTE);        // below tests rely on the exact file size
    CreateFilledFile(lpFile2, KILOBYTE*124);    // below tests rely on the exact file size

    HANDLE hFile = NULL;
    BY_HANDLE_FILE_INFORMATION fileInfo;

    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("(NULL, NULL)")
        {
        if(GetFileInformationByHandle(hNull, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(INVALID_HANDLE_VALUE, NULL)")
        {
        if(GetFileInformationByHandle(INVALID_HANDLE_VALUE, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(NULL, valid)")
        {
        if(GetFileInformationByHandle(hNull, &fileInfo) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(valid, NULL)")
        {
        hFile = FileOpen(lpFile1);
        BUGGEDPASS(136, "ACCESS VIOLATION \"By Design\"");
        if(GetFileInformationByHandle(hFile, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN( { CloseHandle(hFile); } );
*/

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("valid file")
        {
        hFile = FileOpen(lpFile1);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to open file");
            }
        if(GetFileInformationByHandle(hFile, &fileInfo) == TRUE && fileInfo.nFileSizeLow == KILOBYTE)
            TESTPASS(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        else
            TESTFAIL(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        } ENDTESTCASE_CLEAN( { CloseHandle(hFile); } );
    TESTCASE("valid file 2")
        {
        hFile = FileOpen(lpFile2);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to open file");
            }
        if(GetFileInformationByHandle(hFile, &fileInfo) == TRUE && fileInfo.nFileSizeLow == KILOBYTE*124)
            TESTPASS(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        else
            TESTFAIL(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        } ENDTESTCASE_CLEAN( { CloseHandle(hFile); } );


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Closed Handle")
        {
        hFile = FileOpen(lpFile1);
        CloseHandle(hFile);
        if(GetFileInformationByHandle(hFile, &fileInfo) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    // handle tests
        // NULL
        // bogus address
        // valid file where nothing has been written
        // ro file (off cd/dvd)
        // device handle
        // find file handle
        // memory handle

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\flushfilebuffers.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    FlushFileBuffers.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the FlushFileBuffers API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::FlushFileBuffers_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL FlushFileBuffers(
      HANDLE hFile  // handle to file
    );
    */
    xSetFunctionName(hLog, "FlushFileBuffers");

    char lpFile[80]; sprintf(lpFile, "%s:\\FFB01_%d.txt", BASE_DRIVE, ThreadID);
    HANDLE hFile;

    char *wbuffer = new char[MEGABYTE*16];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    DWORD wSize, size;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NUL")
        {
        if(FlushFileBuffers(hNull) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE")
        {
        if(FlushFileBuffers(INVALID_HANDLE_VALUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Bogus Handle")
        {
        if(FlushFileBuffers(hBogus) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Write 0 bytes")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        size = sprintf(wbuffer, "");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write 1 byte")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        size = sprintf(wbuffer, "1");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write 2 bytes")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "69");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write short text")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a FlushFileBuffers() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write long text")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a FlushFileBuffers() API Test!\r\n\r\n"
                "The quick brown fox jumps over the lazy dog\r\n"
                "1234567890\t-=`~!@#$%^&*()_+[]}{\\|';:\"/.,<>?\r\n\r\n"
                "This is a story about Ranet Jeno, the wicked witch from a swamp called DC.\r\n\r\n"
                "(All persons, places, and events are fictitious and bear no resemblance to any living or deceased (past, present, or future) persons, places or events.)\r\n\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write really long text (0.5meg)")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(int i=0; i<8192; i++)
            {
            size += sprintf(wbuffer+size, "Hello World.\r\n\r\nThis is a FlushFileBuffers() API Test!\r\n\r\n");
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write short binary (256b)")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write a lot of binary (15meg)")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<15728640; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Closed Handle")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a FlushFileBuffers() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        CloseHandle(hFile);

        if(FlushFileBuffers(hFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile); });


    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////

    // TODO
    // ro file
    // find file handle
    // memory handle

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    delete[] wbuffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\getfilesize.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    GetFileSize.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the GetFileSize / GetFileSizeEx APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::GetFileSize_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD GetFileSize(
      HANDLE hFile,           // handle to file
      LPDWORD lpFileSizeHigh  // high-order word of file size
    );

    BOOL GetFileSizeEx(
      HANDLE hFile,              // handle to file
      PLARGE_INTEGER lpFileSize  // file size
    );
    */
    xSetFunctionName(hLog, "GetFileSize");

    HANDLE file = NULL;
    DWORD size;
    DWORD highSize;
    LARGE_INTEGER bigSize;
    bigSize.QuadPart = 0;

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FGS01_%d.txt", BASE_DRIVE, ThreadID);

    DeleteFile(lpFile1);


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("hFile == NUL")
        {
        highSize = dwBogus;
        if((highSize=GetFileSize(NULL, &highSize)) == -1)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(NULL, &bigSize) == FALSE)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE;
    TESTCASE("hFile == INVALID_HANDLE_VALUE")
        {
        highSize = dwBogus;
        if((highSize=GetFileSize(INVALID_HANDLE_VALUE, &highSize)) == -1)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(INVALID_HANDLE_VALUE, &bigSize) == FALSE)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE;
    TESTCASE("hFile == NULL && lpFileSizeHigh == NUL")
        {
        if((highSize=GetFileSize(NULL, NULL)) == -1)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(NULL, NULL) == FALSE)
            TESTPASS(hLog, "GetFileSizeEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("lpFileSizeHigh == NUL")
        {
        size = 5;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);

        BUGGEDPASS(137, "ACCESS VIOLATION \"By Design\"");

        if((highSize=GetFileSize(file, NULL)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, NULL) == FALSE)
            TESTPASS(hLog, "GetFileSizeEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("filesize = 0")
        {
        size = 0;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 1")
        {
        size = 1;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 133")
        {
        size = 133;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 16384")
        {
        size = KILOBYTE*16;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 33554432")
        {
        size = 33554432;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 134217728")
        {
        size = 134217728;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("hFile == bogus")
        {
        highSize = dwBogus;
        if((highSize=GetFileSize(hBogus, &highSize)) == -1)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(hBogus, &bigSize) == FALSE)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE;
    TESTCASE("closed handle")
        {
        highSize = dwBogus;
        CreateFilledFile(lpFile1, 133);
        file = FileOpen(lpFile1);
        CloseHandle(file);
        if((highSize=GetFileSize(file, &highSize)) == -1)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == FALSE)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // More successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("new file with nothing written")
        {
        size = 0;
        highSize = dwBogus;
        file = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("new file with some stuff written")
        {
        size = sizeof(DWORD);
        highSize = dwBogus;
        file = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        WriteFile(file, &highSize, size, &highSize, NULL);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("new file with some stuff written and a flush")
        {
        size = sizeof(DWORD);
        highSize = dwBogus;
        file = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        WriteFile(file, &highSize, sizeof(DWORD), &highSize, NULL);
        FlushFileBuffers(file);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });

    // TODO handle tests
        // ro file
        // device handle
        // find file handle
        // memory handle

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\getlogicaldrives.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    GetSetFileAttributes.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

static void ClearNulls(int num, char *buf);

/*

Routine Description:

    Tests the GetLogicalDrives / GetLogicalDriveStrings APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::GetLogicalDrives_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD GetLogicalDrives(VOID);

    DWORD GetLogicalDriveStrings(
      DWORD nBufferLength,  // size of buffer
      LPTSTR lpBuffer       // drive strings buffer
      );
    */
    xSetFunctionName(hLog, "GetLogicalDrives");

    DWORD drives = GetLogicalDrives();
    unsigned numDrives = 0;

    TESTCASE("GetLogicalDrives")
        {
        if(drives != 0)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        for(DWORD i=1; i<drives; i=i<<1)
            {
            if(drives & i) ++numDrives;
            }

        xLog(hLog, XLL_INFO, "Found %u logical drives", numDrives);
        } ENDTESTCASE;
    
    // TODO actually verify valid drives based on the hardware


    xSetFunctionName(hLog, "GetLogicalDriveStrings");

    char *buffer;
    DWORD size;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(0, NULL)")
        {
        size = GetLogicalDriveStrings(0, NULL);
        if(size == numDrives*4+1)
            TESTPASS(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        else
            TESTFAIL(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        } ENDTESTCASE;
    TESTCASE("(0xFFFF, NULL)")
        {
        BUGGEDPASS(138, "ACCESS VIOLATION \"By Design\"");
        size = GetLogicalDriveStrings(0xFFFF, NULL);
        if(size == numDrives*4+1)
            TESTPASS(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        else
            TESTFAIL(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("GetLogicalDriveStrings")
        {
        buffer = new char[numDrives*5];
        if(!buffer)
            {
            BLOCKED(0, "Memory allocation failed");
            }
        size = GetLogicalDriveStrings(numDrives*5, buffer);
        ClearNulls(size/4, buffer);
        if(size == numDrives*4)
            TESTPASS(hLog, "returned: %lu, %s (ec: %ld)", size, buffer, GetLastError());
        else
            TESTFAIL(hLog, "returned: %lu, %s (ec: %ld)", size, buffer, GetLastError());
        } ENDTESTCASE_CLEAN({ if(buffer) delete[] buffer; });
    TESTCASE("Verify D: T: Z: U:")
        {
        buffer = new char[numDrives*5];
        if(!buffer)
            {
            BLOCKED(0, "Memory allocation failed");
            }
        size = GetLogicalDriveStrings(numDrives*5, buffer);

        char drives[] = "DTZU";
        for(unsigned i=0; i<sizeof(drives)/sizeof(drives[0]) - 1; i++)
            {
            for(unsigned j=0; j<size/4; j++)
                {
                if(drives[i] == buffer[j*4])
                    break;
                }
            if(j<size/4)
                TESTPASS(hLog, "Found %s", &buffer[j*4]);
            else
                TESTFAIL(hLog, "Could not find %wc", drives[i]);
            }
        } ENDTESTCASE_CLEAN({ if(buffer) delete[] buffer; });
    TESTCASE("buffer[just enough]")
        {
        buffer = new char[numDrives*4+1];
        if(!buffer)
            {
            BLOCKED(0, "Memory allocation failed");
            }
        size = GetLogicalDriveStrings(numDrives*4+1, buffer);
        ClearNulls(size/4, buffer);
        if(size == numDrives*4)
            TESTPASS(hLog, "returned: %lu, %s (ec: %ld)", size, buffer, GetLastError());
        else
            TESTFAIL(hLog, "returned: %lu, %s (ec: %ld)", size, buffer, GetLastError());
        } ENDTESTCASE_CLEAN({ if(buffer) delete[] buffer; });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Verify No C:")
        {
        buffer = new char[numDrives*5];
        if(!buffer)
            {
            BLOCKED(0, "Memory allocation failed");
            }
        size = GetLogicalDriveStrings(numDrives*5, buffer);

        char drives[] = "C";
        for(unsigned i=0; i<sizeof(drives)/sizeof(drives[0]) - 1; i++)
            {
            for(unsigned j=0; j<size/4; j++)
                {
                if(drives[i] == buffer[j*4])
                    break;
                }
            if(j==size/4)
                TESTPASS(hLog, "Did not find %wc", drives[i]);
            else
                TESTFAIL(hLog, "Found %wc", drives[i]);
            }
        } ENDTESTCASE_CLEAN({ if(buffer) delete[] buffer; });
    TESTCASE("buffer[0]")
        {
        buffer = new char[1];
        if(!buffer)
            {
            BLOCKED(0, "Memory allocation failed");
            }
        size = GetLogicalDriveStrings(0, buffer);
        if(size == numDrives*4+1)
            TESTPASS(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        else
            TESTFAIL(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        } ENDTESTCASE_CLEAN({ if(buffer) delete[] buffer; });
    TESTCASE("buffer[1]")
        {
        buffer = new char[1];
        if(!buffer)
            {
            BLOCKED(0, "Memory allocation failed");
            }
        size = GetLogicalDriveStrings(1, buffer);
        if(size == numDrives*4+1)
            TESTPASS(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        else
            TESTFAIL(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        } ENDTESTCASE_CLEAN({ if(buffer) delete[] buffer; });
    TESTCASE("buffer[just under]")
        {
        buffer = new char[numDrives*4];
        if(!buffer)
            {
            BLOCKED(0, "Memory allocation failed");
            }
        size = GetLogicalDriveStrings(numDrives*4, buffer);
        if(size == numDrives*4+1)
            TESTPASS(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        else
            TESTFAIL(hLog, "returned: %lu (ec: %ld)", size, GetLastError());
        } ENDTESTCASE_CLEAN({ if(buffer) delete[] buffer; });

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }


/*

Routine Description:

    Removes the internal null characters so we can print out a single string
        with all the drive letters.

Arguments:

    int num - the number of drives in the buffer
    char *buf - the buffer filled by GetLogicalDriveStrings()

Return Value:

    None

*/
static void ClearNulls(int num, char *buf)
    {
    for(int i=0; i<num; i++)
        {
        buf[i*4+3] = (short)' ';
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\getvolumeinformation.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    GetVolumeInformation.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the GetVolumeInformation API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::GetVolumeInformation_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL GetVolumeInformation(
      LPCTSTR lpRootPathName,           // [in]  root directory
      LPTSTR lpVolumeNameBuffer,        // [out] volume name buffer
      DWORD nVolumeNameSize,            // [in]  length of name buffer
      LPDWORD lpVolumeSerialNumber,     // [out] volume serial number
      LPDWORD lpMaximumComponentLength, // [out] maximum file name length
      LPDWORD lpFileSystemFlags,        // [out] file system options
      LPTSTR lpFileSystemNameBuffer,    // [out] file system name buffer
      DWORD nFileSystemNameSize         // [in]  length of file system name buffer
    );
    */
    xSetFunctionName(hLog, "GetVolumeInformation");

    DWORD serialNum;
    DWORD maxFilename;
    DWORD flags;


    DWORD vnameSize = 128;
    DWORD fsnameSize = 128;
    char vnameBuffer[128];
    char fsnameBuffer[128];
    char lpFile1[80];


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NULL")
        {/*
        if(GetVolumeInformation(lpNull, NULL, 0, NULL, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());*/
        } ENDTESTCASE;
    TESTCASE("Empty Root, NULL")
        {
        if(GetVolumeInformation(lpEmpty, NULL, 0, NULL, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Valid Root Drive, NUL")
        {
        if(GetVolumeInformation(BASE_DRIVE ":\\", NULL, 0, NULL, NULL, NULL, NULL, 0) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Valid Root Drive")
        {
        if(GetVolumeInformation(BASE_DRIVE ":\\", vnameBuffer, vnameSize, &serialNum, &maxFilename, &flags, fsnameBuffer, fsnameSize) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Invalid Root Drive")
        {
        if(GetVolumeInformation("Fuzzy", NULL, 0, NULL, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == \" \"")
        {
        if(GetVolumeInformation(" ", NULL, 0, NULL, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == \":\\\"")
        {
        if(GetVolumeInformation(":\\", NULL, 0, NULL, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == \"C\\\"")
        {
        if(GetVolumeInformation("C\\", NULL, 0, NULL, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Root Drive == \"CC:\\\"")
        {
        if(GetVolumeInformation("CC:\\", NULL, 0, NULL, NULL, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Valid Root Drive but small buffers")
        {
        sprintf(lpFile1, "%s:\\", BASE_DRIVE);
        if(GetVolumeInformation(lpFile1, vnameBuffer, 1, &serialNum, &maxFilename, &flags, fsnameBuffer, 1) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////


    // go through each drive and verify output based on actual xbox hardware
    /*
    char drives[] = "A:\\\0B:\\\0C:\\\0D:\\\0E:\\\0F:\\\0G:\\\0H:\\\0I:\\\0J:\\\0K:\\\0L:\\\0M:\\\0"
                     "N:\\\0O:\\\0P:\\\0Q:\\\0R:\\\0S:\\\0T:\\\0U:\\\0V:\\\0W:\\\0X:\\\0Y:\\\0Z:\\";
                     */
    char drives[] = "T:\\\0U:\\\0Z:\\";

    for(unsigned i=0; i<ARRAYSIZE(drives)/4; i++)
        {
        char testcase[64];
        sprintf(testcase, "Verify: %s", &drives[i*4]);
        TESTCASE(testcase)
            {
            if(GetVolumeInformation(&drives[i*4], vnameBuffer, vnameSize, &serialNum, &maxFilename, &flags, fsnameBuffer, fsnameSize) == TRUE)
                {
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
                // TODO verify everything in here
                }
            else
                {
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
                }
            } ENDTESTCASE;
        }


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\getsetfiletime.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    GetSetFileTime.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the GetFileTime / SetFileTime APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::GetSetFileTime_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL GetFileTime(
      HANDLE hFile,                 // handle to file
      LPFILETIME lpCreationTime,    // creation time
      LPFILETIME lpLastAccessTime,  // last access time
      LPFILETIME lpLastWriteTime    // last write time
    );

    BOOL SetFileTime(
      HANDLE hFile,                     // handle to file
      CONST FILETIME *lpCreationTime,   // creation time
      CONST FILETIME *lpLastAccessTime, // last-access time
      CONST FILETIME *lpLastWriteTime   // last-write time
    );
    */
    xSetFunctionName(hLog, "GetFileTime / SetFileTime");

    unsigned date;
    HANDLE hFile;
    HANDLE hFile2;

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FFT01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\FFT02_%d.txt", BASE_DRIVE, ThreadID);

    FILETIME fileTime[3];
    FILETIME gfileTime[3];

    // initialize system state
    hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NULL")
        {
        if(SetFileTime(hNull, NULL, NULL, NULL) == FALSE)
            TESTPASS(hLog, "SetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetFileTime (ec: %ld)", GetLastError());
        if(GetFileTime(hNull, NULL, NULL, NULL) == FALSE)
            TESTPASS(hLog, "GetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "GetFileTime (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE NULL")
        {
        if(SetFileTime(INVALID_HANDLE_VALUE, NULL, NULL, NULL) == FALSE)
            TESTPASS(hLog, "SetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetFileTime (ec: %ld)", GetLastError());
        if(GetFileTime(INVALID_HANDLE_VALUE, NULL, NULL, NULL) == FALSE)
            TESTPASS(hLog, "GetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "GetFileTime (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Valid handle and NULL")
        {
        if(SetFileTime(hFile, NULL, NULL, NULL) == TRUE)
            TESTPASS(hLog, "SetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetFileTime (ec: %ld)", GetLastError());
        if(GetFileTime(hFile, NULL, NULL, NULL) == TRUE)
            TESTPASS(hLog, "GetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "GetFileTime (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    for(date=0; date<20; date++)
        {
        TESTCASE("Valid Dates")
            {
            for(unsigned i=0; i<3; i++)
                {
                // just create some different dates
                if(CreateFileTime(&fileTime[i], i + 2000, date % (9+i) + 1, date % (26+i) + 1, i==1? 0 :(date % (21+i)), i==1? 0 : (date % (55+i)), 0, 0) == FALSE)
                    xLog(hLog, XLL_WARN, "SystemTimeToFileTime Error: %ld", GetLastError());
                }

            if(SetFileTime(hFile, &fileTime[0], &fileTime[1], &fileTime[2]) == TRUE)
                TESTPASS(hLog, "SetFileTime (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "SetFileTime (ec: %ld)", GetLastError());

            if(GetFileTime(hFile, &gfileTime[0], &gfileTime[1], &gfileTime[2]) == TRUE)
                TESTPASS(hLog, "GetFileTime (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "GetFileTime (ec: %ld)", GetLastError());

            if(memcmp(fileTime, gfileTime, sizeof(FILETIME)*3) == 0)
                {
                SYSTEMTIME sysTime;
                char buffer[256];
                char *t = buffer;

                t += sprintf(t, "Set");
                FileTimeToSystemTime(&fileTime[0], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&fileTime[1], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&fileTime[2], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);

                t += sprintf(t, " == Get");
                FileTimeToSystemTime(&gfileTime[0], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&gfileTime[1], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&gfileTime[2], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                TESTPASS(hLog, buffer);
                }
            else
                {
                SYSTEMTIME sysTime;
                char buffer[256];
                char *t = buffer;

                t += sprintf(t, "Set");
                FileTimeToSystemTime(&fileTime[0], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&fileTime[1], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&fileTime[2], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);

                t += sprintf(t, " != Get");
                FileTimeToSystemTime(&gfileTime[0], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&gfileTime[1], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&gfileTime[2], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                TESTFAIL(hLog, buffer);
                }
            } ENDTESTCASE;
        }


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Closed Handle")
        {
        hFile2 = CreateFile(lpFile2, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        CloseHandle(hFile2);
        for(unsigned i=0; i<3; i++)
            {
            // just create some different dates
            if(CreateFileTime(&fileTime[i], 1974 + i, 6 + i, 10 + i, 12 + i, 15+ i, 0, 0) == FALSE)
                xLog(hLog, XLL_WARN, "SystemTimeToFileTime Error: %ld", GetLastError());
            }

        if(SetFileTime(hFile2, &fileTime[0], &fileTime[1], &fileTime[2]) == FALSE)
            TESTPASS(hLog, "SetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetFileTime (ec: %ld)", GetLastError());

        if(GetFileTime(hFile2, &gfileTime[0], &gfileTime[1], &gfileTime[2]) == FALSE)
            TESTPASS(hLog, "GetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "GetFileTime (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile2); });
    /*
    TESTCASE("FILETIME == 0")
        {
        for(unsigned i=0; i<3; i++)
            {
            fileTime[i].dwLowDateTime = 0;
            fileTime[i].dwHighDateTime = 0;
            }

        if(SetFileTime(hFile, &fileTime[0], &fileTime[1], &fileTime[2]) == FALSE)
            TESTPASS(hLog, "SetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetFileTime (ec: %ld)", GetLastError());

        if(GetFileTime(hFile, &gfileTime[0], &gfileTime[1], &gfileTime[2]) == FALSE)
            TESTPASS(hLog, "GetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "GetFileTime (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("FILETIME == 0xFFFFFFFFFFFFFFFF")
        {
        for(unsigned i=0; i<3; i++)
            {
            fileTime[i].dwLowDateTime = ~0;
            fileTime[i].dwHighDateTime = ~0;
            }

        if(SetFileTime(hFile, &fileTime[0], &fileTime[1], &fileTime[2]) == FALSE)
            TESTPASS(hLog, "SetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetFileTime (ec: %ld)", GetLastError());

        if(GetFileTime(hFile, &gfileTime[0], &gfileTime[1], &gfileTime[2]) == FALSE)
            TESTPASS(hLog, "GetFileTime (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "GetFileTime (ec: %ld)", GetLastError());
        } ENDTESTCASE;
*/

    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////

    // TODO
    // handle tests
        // bogus address
        // valid file where nothing has been read/written
        // valid file where stuff has been written
        // ro file handle
        // device handle
        // find file handle
        // memory handle

    // *FILETIME tests
        // FILETIMEs are all valid but the same addr
        // 0/0/0
        // 12/31/9999
        // etc.


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    CloseHandle(hFile);
    DeleteFile(lpFile1);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\movefile.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    MoveFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the MoveFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::MoveFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL MoveFile(
      LPCTSTR lpExistingFileName, // file name
      LPCTSTR lpNewFileName       // new file name
    );
    */
    xSetFunctionName(hLog, "MoveFile");

    char lpSmallFile[80]; sprintf(lpSmallFile, "%s:\\FMF01_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%s:\\FMF02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%s:\\FMF03_%d.bla", BASE_DRIVE, ThreadID);
    char lpFakeFile2[80]; sprintf(lpFakeFile2, "%s:\\FMF04_%d.bla", BASE_DRIVE, ThreadID);
    char lpDevice[80]; sprintf(lpDevice, "%s:\\FMF05_%d.txt", BASE_DRIVE, ThreadID);
    char lpDir1[80]; sprintf(lpDir1, "%s:\\FMF06_%d", BASE_DRIVE, ThreadID);
    char lpSubFile[80]; sprintf(lpSubFile, "%s:\\FMF06_%d\\FMF07_%d.txt", BASE_DRIVE, ThreadID, ThreadID);
    char lpFile1[80];
    char lpFile2[80];
    unsigned i;

    // initialize system state
    CreateDirectory(lpDir1, NULL);
    CreateFilledFile(lpSmallFile, KILOBYTE*16);
    CreateFilledFile(lpBigFile, MEGABYTE*8);
    CreateFilledFile(lpSubFile, KILOBYTE*16);


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(NULL, NULL)")
        {
        if(MoveFile(lpNull, lpNull) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(nonexist, NULL)")
        {
        if(MoveFile(lpFakeFile, lpNull) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(NULL, nonexist)")
        {
        if(MoveFile(lpNull, lpFakeFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(empty, empty)")
        {
        if(MoveFile(lpEmpty, lpEmpty) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(nonexist, empty)")
        {
        if(MoveFile(lpFakeFile, lpEmpty) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(empty, nonexist)")
        {
        if(MoveFile(lpEmpty, lpFakeFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(valid file, nonexist)")
        {
        sprintf(lpFile1, "%s:\\FMF08_%d.txt", BASE_DRIVE, ThreadID);
        if(MoveFile(lpSmallFile, lpFile1) == TRUE && FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("(valid file, nonexist)")
        {
        // this case relies on the previous test
        if(MoveFile(lpFile1, lpSmallFile) == TRUE && FileExists(lpSmallFile))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(valid dir, nonexist)")
        {
        sprintf(lpFile1, "%s:\\FMF09_%d.txt", BASE_DRIVE, ThreadID);
        sprintf(lpFile2, "%s\\FMF07_%d.txt", lpFile1, ThreadID);
        if(MoveFile(lpDir1, lpFile1) == TRUE && FileExists(lpFile1) && FileExists(lpFile2))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(valid dir, nonexist)")
        {
        if(MoveFile(lpFile1, lpDir1) == TRUE && FileExists(lpDir1) && FileExists(lpSubFile))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(valid file, existing)")
        {
        if(MoveFile(lpSmallFile, lpBigFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(valid dir, existing)")
        {
        if(MoveFile(lpDir1, lpBigFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(nonexist, nonexist)")
        {
        if(MoveFile(lpFakeFile, lpFakeFile2) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(\\, nonexist)")
        {
        sprintf(lpFile1, "%s:\\", BASE_DRIVE);
        sprintf(lpFile2, "%s:\\backup", BASE_DRIVE);
        if(MoveFile(lpFile1, lpFile2) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(file1, file1)")
        {
        if(MoveFile(lpSmallFile, lpSmallFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    

    
    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            if(MoveFile(lpSmallFile, invalidFileNames[i]) == FALSE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());

            if(MoveFile(invalidFileNames[i], lpDevice) == FALSE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }

   
    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    DeleteFile(lpSubFile);
    RemoveDirectory(lpDir1);
    DeleteFile(lpBigFile);
    DeleteFile(lpSmallFile);
    DeleteFile(lpDevice);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\harddrivefull.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    HardDriveFull.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests a bunch of APIs while the Hard Drive is full

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::HardDriveFull_Test(HANDLE hLog, DWORD ThreadID)
    {
    char drive[5]; sprintf(drive, "%s:\\", BASE_DRIVE);
    char lpBaseDirectory[80]; sprintf(lpBaseDirectory, "%sFHD_%d", drive, ThreadID);
    char lpFile1[80]; sprintf(lpFile1, "%s\\FHD01_%d.txt", lpBaseDirectory, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s\\FHD02_%d.txt", lpBaseDirectory, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%s\\FHD03_%d.txt", lpBaseDirectory, ThreadID);
    char lpTempFile1[80]; sprintf(lpTempFile1, "%s\\FHD04_%d.txt", lpBaseDirectory, ThreadID);
    char lpTempFile2[80]; sprintf(lpTempFile2, "%s\\FHD05_%d.txt", lpBaseDirectory, ThreadID);
    char lpTempFile3[80]; sprintf(lpTempFile3, "%s\\FHD06_%d.txt", lpBaseDirectory, ThreadID);
    char lpFillHDFile[80];
    char lpTemp[80];

    HANDLE hFile;
    char *wbuffer=NULL;
    char *rbuffer=NULL;

    // initialize system state
    CreateDirectory(lpBaseDirectory, NULL);
    CreateFilledFile(lpFile1, KILOBYTE*16);       // GetFileSize test below relies on this file being 16k
    CreateFilledFile(lpFile2, MEGABYTE*32);
    CreateFilledFile(lpFile3, MEGABYTE*64);

    // Fill up the HD
    FillHDPartition(drive, lpFillHDFile);

    DWORD time = GetTickCount();

    xSetFunctionName(hLog, "GetDiskFreeSpaceEx");
    TESTCASE("Full HardDrive")
        {
        ULARGE_INTEGER available;
        ULARGE_INTEGER total;
        ULARGE_INTEGER free;
        available = total = free = ulBogus;

        if(GetDiskFreeSpaceEx(BASE_DRIVE ":\\", &available, &total, &free) == TRUE && available.QuadPart < total.QuadPart && available.QuadPart != ulBogus.QuadPart)
            TESTPASS(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        else
            TESTFAIL(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);

        if(available.QuadPart != 0)
            xLog(hLog, XLL_WARN, "Hard Drive is not full! The next set of tests will FAIL.");
        } ENDTESTCASE;


    xSetFunctionName(hLog, "CopyFile");
    TESTCASE("Full HardDrive")
        {
        if(CopyFile(lpFile1, lpTempFile1, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        if(FileExists(lpFile1) && ! FileExists(lpTempFile1))
            TESTPASS(hLog, "Checking file existance (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Checking file existance (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    xSetFunctionName(hLog, "MoveFile");
    TESTCASE("Full HardDrive")
        {
        if(MoveFile(lpFile1, lpTempFile1) == TRUE)
            TESTPASS(hLog, "Move 1 (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Move 1 (ec: %ld)", GetLastError());

        if(!FileExists(lpFile1) && FileExists(lpTempFile1))
            TESTPASS(hLog, "Checking file existance (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Checking file existance (ec: %ld)", GetLastError());

        if(MoveFile(lpTempFile1, lpFile1) == TRUE)
            TESTPASS(hLog, "Move 2 (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Move 2 (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    xSetFunctionName(hLog, "CreateDirectory");
    TESTCASE("Full HardDrive")
        {
        if(CreateDirectory(BASE_DRIVE ":\\FHD07", NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        } ENDTESTCASE_CLEAN({ RemoveDirectory(BASE_DRIVE ":\\CreateDirectory"); });


    // create a new file, and try to write to it
    xSetFunctionName(hLog, "CreateFile");
    TESTCASE("Full HardDrive")
        {
        hFile = CreateFile(lpTempFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "Open new file (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Open new file (ec: %ld)", GetLastError());

        DWORD size = 15*KILOBYTE;
        xSetFunctionName(hLog, "SetFilePointer");
        if(SetFilePointer(hFile, size, NULL, FILE_BEGIN) == size)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", size, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", size, GetLastError());

        char w = 'X';
        DWORD wsize = sizeof(w);
        xSetFunctionName(hLog, "WriteFile");
        if(WriteFile(hFile, &w, wsize, &wsize, NULL) != TRUE)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wsize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wsize, GetLastError());

        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTempFile1); });


    // read and write from inside an existing file
    xSetFunctionName(hLog, "CreateFile");
    TESTCASE("Full HardDrive")
        {
        DWORD wSize, rSize, size;
        DWORD seek;

        wbuffer = new char[MEGABYTE*1];
        if(!wbuffer)
            {
            BLOCKED(0, "Unable to allocate memory");
            }
        rbuffer = new char[MEGABYTE*24];
        if(!rbuffer)
            {
            delete[] wbuffer;
            wbuffer = NULL;
            BLOCKED(0, "Unable to allocate memory");
            }

        hFile = CreateFile(lpFile3, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "Open existing file (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Open existing file (ec: %ld)", GetLastError());

        seek = 11*KILOBYTE;
        xSetFunctionName(hLog, "SetFilePointer");
        if((seek=SetFilePointer(hFile, seek, NULL, FILE_BEGIN)) == 11*KILOBYTE)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        xSetFunctionName(hLog, "WriteFile");
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        seek = 11*KILOBYTE;
        xSetFunctionName(hLog, "SetFilePointer");
        if((seek=SetFilePointer(hFile, seek, NULL, FILE_BEGIN)) == 11*KILOBYTE)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        xSetFunctionName(hLog, "ReadFile");
        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);

        } ENDTESTCASE_CLEAN({ if(wbuffer) delete[] wbuffer; if(rbuffer) delete[] rbuffer; CloseHandle(hFile); });


    xSetFunctionName(hLog, "GetVolumeInformation");
    TESTCASE("Full HardDrive")
        {
        DWORD vnameSize = 128;
        DWORD fsnameSize = 128;
        char vnameBuffer[128];
        char fsnameBuffer[128];
        DWORD serialNum;
        DWORD maxFilename;
        DWORD flags;
        if(GetVolumeInformation(BASE_DRIVE ":\\", vnameBuffer, vnameSize, &serialNum, &maxFilename, &flags, fsnameBuffer, fsnameSize) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    xSetFunctionName(hLog, "SetFileAttributes / GetFileAttributes");
    TESTCASE("Full HardDrive")
        {
        DWORD sattrib = 0;
        DWORD gattrib = 0;
        sattrib = FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());

        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;


    xSetFunctionName(hLog, "GetFileSize");
    TESTCASE("Full HardDrive")
        {
        DWORD size = KILOBYTE*16;
        DWORD highSize = 0;
        LARGE_INTEGER bigSize;
        bigSize.QuadPart = 0;
        hFile = FileOpen(lpFile1);
        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(hFile, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); });


    xSetFunctionName(hLog, "GetFileInformationByHandle");
    TESTCASE("Full HardDrive")
        {
        BY_HANDLE_FILE_INFORMATION fileInfo;
        hFile = FileOpen(lpFile1);
        if(GetFileInformationByHandle(hFile, &fileInfo) == TRUE && fileInfo.nFileSizeLow == KILOBYTE*16)
            TESTPASS(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        else
            TESTFAIL(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        } ENDTESTCASE_CLEAN( { CloseHandle(hFile); } );


    xSetFunctionName(hLog, "FindFile");
    TESTCASE("Full HardDrive")
        {
        WIN32_FIND_DATA findData;
        HANDLE hFind = FindFirstFile(BASE_DRIVE ":\\*", &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        do
            {
            // TODO verify
            } while(FindNextFile(hFind, &findData) == TRUE);
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    // TODO
        // Get/SetFileTime

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    xSetFunctionName(hLog, "(hd full tests)");
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    // unfill the HD
    DeleteFile(lpFillHDFile);

    // clean up
    DeleteFile(lpFile1);
    DeleteFile(lpFile3);
    DeleteFile(lpFile2);
    DeleteFile(lpTempFile1);
    DeleteFile(lpTempFile3);
    DeleteFile(lpTempFile2);
    RemoveDirectory(lpBaseDirectory);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\readwritefile.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    ReadWriteFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the ReadFile / WriteFile APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::ReadWriteFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReadFile(
      HANDLE hFile,                // handle to file
      LPVOID lpBuffer,             // data buffer
      DWORD nNumberOfBytesToRead,  // number of bytes to read
      LPDWORD lpNumberOfBytesRead, // number of bytes read
      LPOVERLAPPED lpOverlapped    // overlapped buffer
    );

    BOOL WriteFile(
      HANDLE hFile,                    // handle to file
      LPCVOID lpBuffer,                // data buffer
      DWORD nNumberOfBytesToWrite,     // number of bytes to write
      LPDWORD lpNumberOfBytesWritten,  // number of bytes written
      LPOVERLAPPED lpOverlapped        // overlapped buffer
    );
    */
    xSetFunctionName(hLog, "ReadFile / WriteFile");

    char *wbuffer = new char[MEGABYTE*24];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    char *rbuffer = new char[MEGABYTE*24];
    if(!rbuffer)
        {
        delete[] wbuffer;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FRW01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\FRW02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%s:\\FRW03_%d.txt", BASE_DRIVE, ThreadID);

    HANDLE hFile = NULL;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;

    DWORD wSize, rSize, size;

    // initialize state
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);

    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("All NUL")
        {
        if(WriteFile(hNull, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "WriteFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "WriteFile (ec: %ld)", GetLastError());
        if(ReadFile(hNull, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReadFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReadFile (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE NUL")
        {
        if(WriteFile(INVALID_HANDLE_VALUE, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "WriteFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "WriteFile (ec: %ld)", GetLastError());
        if(ReadFile(INVALID_HANDLE_VALUE, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReadFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReadFile (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Valid file handle, All NUL")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        BUGGEDPASS(196, "ACCESS VIOLATION \"By Design\"");
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        if(WriteFile(hFile, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "WriteFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "WriteFile (ec: %ld)", GetLastError());
        if(ReadFile(hFile, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReadFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReadFile (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
*/

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Read/Write 0 bytes")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 1 byte")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "1");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 1 space")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, " ");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 2 bytes")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "69");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write short text")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write long text")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n\r\n"
                "The quick brown fox jumps over the lazy dog\r\n"
                "1234567890\t-=`~!@#$%^&*()_+[]}{\\|';:\"/.,<>?\r\n\r\n"
                "This is a story about Ranet Jeno, the wicked witch from a swamp called DC.\r\n\r\n"
                "(All persons, places, and events are fictitious and bear no resemblance to any living or deceased (past, present, or future) persons, places or events.)\r\n\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write really long text (0.5meg)")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(int i=0; i<8192; i++)
            {
            size += sprintf(wbuffer+size, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n\r\n");
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write short binary (256b)")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("FILE_FLAG_SEQUENTIAL_SCAN")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)~size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("FILE_FLAG_RANDOM_ACCESS")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("FILE_FLAG_WRITE_THROUGH")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)~size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 15 meg")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<MEGABYTE*15; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 256 meg (8 meg chunks)")
        {
        DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxChunks = 32;
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<MEGABYTE*8; size++)
            {
            wbuffer[size] = (char)~size;
            }
        for(unsigned int i=0; i<maxChunks; i++)
            {
            if(i%6==0) DebugPrint("   (%d) %02d%%\n", ThreadID, 50*i/maxChunks);
            if(! (WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size))
                break;
            }

        if(i == maxChunks)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", size*i, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", size*i, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        for(unsigned j=0; j<i; j++)
            {
            if(j%6==0) DebugPrint("   (%d) %02d%%\n", ThreadID, 50*j/maxChunks + 50);
            if(! (ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size))
                break;

            if(! (wSize == rSize && memcmp(rbuffer, wbuffer, size) == 0))
                break;
            }

        if(j == i)
            {
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", size*j, GetLastError());
            TESTPASS(hLog, "Write Buffer == Read Buffer");
            }
        else
            {
            if(! (wSize == rSize && memcmp(rbuffer, wbuffer, size) == 0))
                {
                TESTFAIL(hLog, "Write Buffer != Read Buffer");
                }
            else
                {
                TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", size*j, GetLastError());
                }
            }
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); CloseHandle(hFile); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Read from a write only file")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == FALSE)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        // Note, the next test ("Write to a read only file") depends on this test's file.
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); });
    TESTCASE("Write to a read only file")
        {
        // This test depends on the prevous test's ("Read from a write only file") file.
        hFile = CreateFile(lpFile1, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == FALSE)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write to closed handle")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n");
        CloseHandle(hFile);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == FALSE)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == FALSE)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    delete[] wbuffer;
    delete[] rbuffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\getsetfileattributes.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    GetSetFileAttributes.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the GetFileAttributes / SetFileAttributes APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::GetSetFileAttributes_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD GetFileAttributes(
      LPCTSTR lpFileName   // name of file or directory
    );

    BOOL SetFileAttributes(
      LPCTSTR lpFileName,      // file name
      DWORD dwFileAttributes   // attributes
    );

    #define FILE_ATTRIBUTE_READONLY             0x00000001
    #define FILE_ATTRIBUTE_HIDDEN               0x00000002
    #define FILE_ATTRIBUTE_SYSTEM               0x00000004
    #define FILE_ATTRIBUTE_DIRECTORY            0x00000010
    #define FILE_ATTRIBUTE_ARCHIVE              0x00000020
    #define FILE_ATTRIBUTE_DEVICE               0x00000040
    #define FILE_ATTRIBUTE_NORMAL               0x00000080
    #define FILE_ATTRIBUTE_TEMPORARY            0x00000100
    #define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200
    #define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400
    #define FILE_ATTRIBUTE_COMPRESSED           0x00000800
    #define FILE_ATTRIBUTE_OFFLINE              0x00001000
    #define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000
    #define FILE_ATTRIBUTE_ENCRYPTED            0x00004000
    */
    xSetFunctionName(hLog, "SetFileAttributes / GetFileAttributes");

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FFA01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%s:\\FFA02_%d.txt", BASE_DRIVE, ThreadID);
    char lpDir1[80]; sprintf(lpDir1, "%s:\\FFA03_%d", BASE_DRIVE, ThreadID);

    CreateFilledFile(lpFile1, KILOBYTE*16);
    CreateDirectory(lpDir1, FALSE);
    SetFileAttributes(lpFile1, FILE_ATTRIBUTE_NORMAL);
    SetFileAttributes(lpDir1, FILE_ATTRIBUTE_NORMAL);

    DWORD sattrib = 0;
    DWORD gattrib = 0;
    unsigned i;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    /*TESTCASE("SetFileAttributes(NULL, 0)")
        {
        if(SetFileAttributes(lpNull, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;*/
    TESTCASE("GetFileAttributes(NULL)")
        {
        if(GetFileAttributes(lpNull) == -1)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("SetFileAttributes(\"\", 0)")
        {
        if(SetFileAttributes(lpEmpty, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GetFileAttributes(\"\")")
        {
        if(GetFileAttributes(lpEmpty) == -1)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("File Set read only")
        {
        sattrib = FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear read only")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("File Set archive")
        {
        sattrib = FILE_ATTRIBUTE_ARCHIVE;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear archive")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("File Set hidden")
        {
        sattrib = FILE_ATTRIBUTE_HIDDEN;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear hidden")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("File Set system")
        {
        sattrib = FILE_ATTRIBUTE_SYSTEM;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear system")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("File Set arhs")
        {
        sattrib = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear arhs")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_SYSTEM & ~FILE_ATTRIBUTE_HIDDEN & ~FILE_ATTRIBUTE_ARCHIVE & ~FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;

    TESTCASE("Directory Set read only")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear read only")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory Set archive")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_ARCHIVE;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear archive")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_ARCHIVE;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory Set hidden")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_HIDDEN;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear hidden")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_HIDDEN;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory Set system")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_SYSTEM;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear system")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_SYSTEM;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory Set arhs")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear arhs")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_SYSTEM & ~FILE_ATTRIBUTE_HIDDEN & ~FILE_ATTRIBUTE_ARCHIVE & ~FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("SetFileAttributes(missing file, 0)")
        {
        if(SetFileAttributes(lpFakeFile, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GetFileAttributes(missing file)")
        {
        if(GetFileAttributes(lpFakeFile) == -1)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            xSetFunctionName(hLog, "SetFileAttributes");
            if(SetFileAttributes(invalidFileNames[i], 0) == FALSE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());

            xSetFunctionName(hLog, "GetFileAttributes");
            if(GetFileAttributes(invalidFileNames[i]) == -1)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    xSetFunctionName(hLog, "SetFileAttributes / GetFileAttributes");
    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////

    // TODO
    // filename tests
        // filename/directories with spaces, etc.
        // * and ? wild cards
        // maxpath, 32000
        // use mixed / and \
        // spaces
        // .
        // ..
        // with < > : " / \ |
        // unc: \\?\UNC\poleyland1\public\tests
        // case insensitivity
    // open file rw, change the file attrib to ro, try to WriteFile

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    DeleteFile(lpFile1);
    RemoveDirectory(lpDir1);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\movefilewithprogress.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    MoveFileWithProgress.cpp

Abstract:



Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:


*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

#ifndef MOVEFILE_CREATE_HARDLINK
#define MOVEFILE_CREATE_HARDLINK        0x00000010
#endif

static DWORD CALLBACK MoveFileProgressRoutine(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);


/*

Routine Description:

    Tests the MoveFileWithProgress API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::MoveFileWithProgress_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL MoveFileWithProgress(
      LPCTSTR lpExistingFileName,            // file name
      LPCTSTR lpNewFileName,                 // new file name
      LPPROGRESS_ROUTINE lpProgressRoutine,  // callback function
      LPVOID lpData,                         // parameter for callback
      DWORD dwFlags                          // move options
    );
    */
    xSetFunctionName(hLog, "MoveFileWithProgress");

    char lpSmallFile[80]; sprintf(lpSmallFile, "%s:\\FMP01_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%s:\\FMP02_%d.txt", BASE_DRIVE, ThreadID);
    char lpExtraBigFile[80]; sprintf(lpExtraBigFile, "%s:\\FMP03_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%s:\\FMP04_%d.bla", BASE_DRIVE, ThreadID);
    char lpFakeFile2[80]; sprintf(lpFakeFile2, "%s:\\FMP05_%d.bla", BASE_DRIVE, ThreadID);
    char lpDevice[80]; sprintf(lpDevice, "%s:\\FMP06_%d.txt", BASE_DRIVE, ThreadID);
    char lpDir1[80]; sprintf(lpDir1, "%s:\\FMP07_%d", BASE_DRIVE, ThreadID);
    char lpSubFile[80]; sprintf(lpSubFile, "%s:\\FMP07_%d\\FMP08_%d.txt", BASE_DRIVE, ThreadID, ThreadID);
    char lpFile1[80];
    char lpFile2[80];
    unsigned i;

    // initialize system state
    CreateDirectory(lpDir1, NULL);
    CreateFilledFile(lpSmallFile, KILOBYTE*16);
    CreateFilledFile(lpBigFile, MEGABYTE*8);
    CreateFilledFile(lpExtraBigFile, MEGABYTE*32);
    CreateFilledFile(lpSubFile, KILOBYTE*16);


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NUL")
        {
        if(MoveFileWithProgress(lpNull, lpNull, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Empty")
        {
        if(MoveFileWithProgress(lpEmpty, lpEmpty, NULL, NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Small file replace")
        {
        sprintf(lpFile1, "%s:\\FMF09_%d.txt", CACHE_DRIVE, ThreadID);

        if(MoveFileWithProgress(lpSmallFile, lpFile1, MoveFileProgressRoutine, hLog, MOVEFILE_REPLACE_EXISTING) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("Small file")
        {
        // this case relies on the previous test
        if(MoveFileWithProgress(lpFile1, lpSmallFile, MoveFileProgressRoutine, hLog, 0) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpSmallFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE;

    TESTCASE("Big file replace")
        {
        sprintf(lpFile1, "%s:\\FMF09_%d.txt", CACHE_DRIVE, ThreadID);

        if(MoveFileWithProgress(lpBigFile, lpFile1, MoveFileProgressRoutine, hLog, MOVEFILE_REPLACE_EXISTING) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("Big file")
        {
        // this case relies on the previous test
        if(MoveFileWithProgress(lpFile1, lpBigFile, MoveFileProgressRoutine, hLog, 0) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpBigFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE;

    TESTCASE("Extra Big file replace")
        {
        sprintf(lpFile1, "%s:\\FMF09_%d.txt", CACHE_DRIVE, ThreadID);

        if(MoveFileWithProgress(lpExtraBigFile, lpFile1, MoveFileProgressRoutine, hLog, MOVEFILE_REPLACE_EXISTING) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("Extra Big file w/write through")
        {
        // this case relies on the previous test
        if(MoveFileWithProgress(lpFile1, lpExtraBigFile, MoveFileProgressRoutine, hLog, MOVEFILE_WRITE_THROUGH) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpExtraBigFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE;

    TESTCASE("Different volume")
        {
        sprintf(lpFile1, "%s:\\FMF09_%d.txt", TITLE_DRIVE, ThreadID);

        if(MoveFileWithProgress(lpBigFile, lpFile1, MoveFileProgressRoutine, hLog, MOVEFILE_COPY_ALLOWED) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("Different volume 2")
        {
        // this case relies on the previous test
        if(MoveFileWithProgress(lpFile1, lpBigFile, MoveFileProgressRoutine, hLog, MOVEFILE_COPY_ALLOWED) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpBigFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE;

    TESTCASE("Existing File")
        {
        sprintf(lpFile1, "%s:\\FMF10_%d.txt", CACHE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1, MEGABYTE);

        if(MoveFileWithProgress(lpBigFile, lpFile1, MoveFileProgressRoutine, hLog, MOVEFILE_REPLACE_EXISTING) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("Existing File 2")
        {
        // this case relies on the previous test
        CreateFilledFile(lpBigFile, MEGABYTE);
        if(MoveFileWithProgress(lpFile1, lpBigFile, MoveFileProgressRoutine, hLog, MOVEFILE_REPLACE_EXISTING) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpBigFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE;

    
    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            if(MoveFileWithProgress(lpSmallFile, invalidFileNames[i], MoveFileProgressRoutine, hLog, MOVEFILE_CREATE_HARDLINK) == FALSE)
                TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

            if(MoveFileWithProgress(invalidFileNames[i], lpDevice, MoveFileProgressRoutine, hLog, MOVEFILE_CREATE_HARDLINK) == FALSE)
                TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    DeleteFile(lpSubFile);
    RemoveDirectory(lpDir1);
    DeleteFile(lpBigFile);
    DeleteFile(lpExtraBigFile);
    DeleteFile(lpSmallFile);
    DeleteFile(lpDevice);

    return 0;
    }

/*

Routine Description:

    Callback function used with the CopyFileEx and MoveFileWithProgress functions
    See "CopyProgressRoutine" in MSDN

Arguments:

    LARGE_INTEGER TotalFileSize          - file size
    LARGE_INTEGER TotalBytesTransferred  - bytes transferred
    LARGE_INTEGER StreamSize             - bytes in stream
    LARGE_INTEGER StreamBytesTransferred - bytes transferred for stream
    DWORD dwStreamNumber                 - current stream
    DWORD dwCallbackReason               - callback reason
    HANDLE hSourceFile                   - handle to source file
    HANDLE hDestinationFile              - handle to destination file
    LPVOID lpData                        - user data, HANDLE to XLOG object

Return Value:

    PROGRESS_CONTINUE, PROGRESS_STOP, or PROGRESS_CANCEL

*/
static DWORD CALLBACK MoveFileProgressRoutine(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
    {
    HANDLE hLog = (HANDLE)lpData;

    xLog(hLog, XLL_INFO, "%I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);

    if(TotalBytesTransferred.QuadPart > TotalFileSize.QuadPart)
        {
        xLog(hLog, XLL_FAIL, "Transfered more than filesize: %I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);
        }

    if(TotalFileSize.QuadPart == TotalBytesTransferred.QuadPart)
        {
        }

    return PROGRESS_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\removedirectory.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    RemoveDirectory.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the RemoveDirectory API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    
*/
DWORD FILEIO::RemoveDirectory_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL RemoveDirectory(
      LPCTSTR lpPathName   // directory name
    );
    */
    xSetFunctionName(hLog, "RemoveDirectory");

    char lpFile1[256];
    char lpFile2[256];
    unsigned i;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Removing NU")
        {
        if(RemoveDirectory(lpNull) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing \"\"")
        {
        if(RemoveDirectory(lpEmpty) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Removing \\RemoveDirectory")
        {
        sprintf(lpFile1, "%s:\\FRD01_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        if(RemoveDirectory(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing SubRemoveDirectory")
        {
        sprintf(lpFile1, "%s:\\FRD02_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }

        sprintf(lpFile1, "%s:\\FRD02_%d\\FRD03_%d", BASE_DRIVE, ThreadID, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }

        if(RemoveDirectory(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        sprintf(lpFile1, "%s:\\FRD02_%d", BASE_DRIVE, ThreadID);
        if(RemoveDirectory(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    /*
    TESTCASE("Removing \\ RemoveDirectory2")
        {
        sprintf(lpFile1, "%s:\\ RemoveDirectory2_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        if(RemoveDirectory(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
*/

    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Removing \\MissingRemoveDirectory")
        {
        sprintf(lpFile1, "%s:\\FRD04", BASE_DRIVE, ThreadID);
        if(RemoveDirectory(lpFile1) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing lpSmallFile")
        {
        sprintf(lpFile1, "%s:\\FRD05_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1, KILOBYTE*16);
        if(RemoveDirectory(lpFile1) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("Removing .")
        {
        if(RemoveDirectory(lpCurrentDir) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing ..")
        {
        if(RemoveDirectory(lpParentDir) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing " BASE_DRIVE ":\\")
        {
        sprintf(lpFile1, "%s:\\", BASE_DRIVE);
        if(RemoveDirectory(lpFile1) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing Nonempty directory")
        {
        sprintf(lpFile1, "%s:\\FRD06_%d", BASE_DRIVE, ThreadID);
        sprintf(lpFile2, "%s:\\FRD06_%d\\FRD07_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, NULL);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        CreateDirectory(lpFile2, NULL);
        if(!FileExists(lpFile2))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        if(RemoveDirectory(lpFile1) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        // clean up
        if(RemoveDirectory(lpFile2) == TRUE)
            TESTPASS(hLog, "Cleanup subdir (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Cleanup subdir (ec: %ld)", GetLastError());
        if(RemoveDirectory(lpFile1) == TRUE)
            TESTPASS(hLog, "Cleanup dir (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Cleanup dir (ec: %ld)", GetLastError());
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            if(RemoveDirectory(invalidFileNames[i]) == FALSE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    // over max path and 32000
    // messing with naming convention
        // use mixed / and \
        // spaces
        // .
        // ..
        // with < > : " / \ |
        // unc: \\?\UNC\poleyland1\public\tests
        // case insensitivity

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\readwritefilegatherscatter.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    ReadWriteFileGatherScatter.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include <winioctl.h>
#include "commontest.h"
#include "fileio_win32API.h"

static void SerializeTest(HANDLE hLog, char *variation, char* filename, DWORD size);
static void FillBuffer(FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD size);
static BOOL CompareBuffer(FILE_SEGMENT_ELEMENT *aSegmentArray, FILE_SEGMENT_ELEMENT *bSegmentArray, DWORD size);

static FILE_SEGMENT_ELEMENT *rpages;
static FILE_SEGMENT_ELEMENT *wpages;

/*

Routine Description:

    Tests the ReadFileScatter / WriteFileGather APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::ReadWriteFileGatherScatter_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReadFileScatter(
      HANDLE hFile,                          // handle to file 
      FILE_SEGMENT_ELEMENT aSegmentArray[ ], // array of buffer pointers
      DWORD nNumberOfBytesToRead,            // number of bytes to read
      LPDWORD lpReserved,                    // reserved; must be NULL
      LPOVERLAPPED lpOverlapped              // OVERLAPPED structure
    );

    BOOL WriteFileGather(
      HANDLE hFile,                          // handle to file
      FILE_SEGMENT_ELEMENT aSegmentArray[ ], // array of buffer pointers
      DWORD nNumberOfBytesToWrite,           // number of bytes to write
      LPDWORD lpReserved,                    // reserved; must be NULL
      LPOVERLAPPED lpOverlapped              // overlapped buffer
    );
    */
    xSetFunctionName(hLog, "ReadFileScatter/WriteFileGather");

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FSG01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\FSG02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%s:\\FSG03_%d.txt", BASE_DRIVE, ThreadID);

    HANDLE hFile = NULL;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;

    DWORD size;
    const size_t NUM_PAGES = 4000;
    size_t page;

    // Get the sector size
    DWORD bytesPerSector = XGetDiskSectorSize(BASE_DRIVE ":\\");
    xLog(hLog, XLL_INFO, "BytesPerSector=   %lu", bytesPerSector);

    // Allocate the pages
    rpages = new FILE_SEGMENT_ELEMENT[NUM_PAGES];
    if(!rpages)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    wpages = new FILE_SEGMENT_ELEMENT[NUM_PAGES];
    if(!wpages)
        {
        delete[] rpages;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    for(page=0; page<NUM_PAGES; page++)
        {
        rpages[page].Buffer = VirtualAlloc(NULL, PAGESIZE, MEM_COMMIT, PAGE_READWRITE);
        wpages[page].Buffer = VirtualAlloc(NULL, PAGESIZE, MEM_COMMIT, PAGE_READWRITE);
        if(!rpages[page].Buffer || !wpages[page].Buffer)
            {
            for(page=0; page<NUM_PAGES; page++)
                {
                VirtualFree(rpages[page].Buffer, 0, MEM_RELEASE);
                VirtualFree(wpages[page].Buffer, 0, MEM_RELEASE);
                }
            delete[] rpages;
            delete[] wpages;
            xStartVariation(hLog, "Initializing State");
            xLog(hLog, XLL_BLOCK, "Unable to VirtualAlloc memory, all tests skipped");
            xEndVariation(hLog);
            DebugPrint("FILEIO: Unable to allocate memory, all tests skipped\n");
            return -1;
            }
        }


    DWORD time = GetTickCount();

/*
    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("All NUL")
        {
        //BUGGEDPASS(195, "ACCESS VIOLATION \"By Design\"");
        if(WriteFileGather(hNull, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "WriteFileGather (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "WriteFileGather (ec: %ld)", GetLastError());
        if(ReadFileScatter(hNull, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReadFileScatter (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReadFileScatter (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE NUL")
        {
        //BUGGEDPASS(195, "ACCESS VIOLATION \"By Design\"");
        if(WriteFileGather(INVALID_HANDLE_VALUE, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "WriteFileGather (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "WriteFileGather (ec: %ld)", GetLastError());
        if(ReadFileScatter(INVALID_HANDLE_VALUE, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReadFileScatter (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReadFileScatter (ec: %ld)", GetLastError());
        } ENDTESTCASE;
*/


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////

    // smallest block
    size = 1*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 1 sector size", lpFile1, size);

    // next smallest block
    size = 2*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 2 sector sizes", lpFile1, size);

    // 1 below standard page size (assuming 512 sector size)
    size = 7*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 7 sector sizes", lpFile1, size);

    // page size
    size = PAGESIZE;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write PAGESIZE", lpFile1, size);

    // one above
    size = 9*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 9 sector sizes", lpFile1, size);

    // unnatural number
    size = 11*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 11 sector sizes", lpFile1, size);

    // small file
    size = 1024*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 1024 sector sizes", lpFile1, size);

    // medium sized file
    size = 4096*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 4096 sector sizes", lpFile1, size);

    // big file
    size = 16384*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 16384 sector sizes", lpFile1, size);

    // big file
    size = 16385*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 16385 sector sizes", lpFile1, size);

    // bigger file
    size = 20001*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 20001 sector sizes", lpFile1, size);

    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    // TODO
    // file not opened with FILE_FLAG_OVERLAPPED
    // 


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    // clean up
    for(page=0; page<NUM_PAGES; page++)
        {
        VirtualFree(rpages[page].Buffer, 0, MEM_RELEASE);
        VirtualFree(wpages[page].Buffer, 0, MEM_RELEASE);
        }
    delete[] rpages;
    delete[] wpages;

    return 0;
    }

static void SerializeTest(HANDLE hLog, char *variation, char* filename, DWORD size)
    {
    HANDLE hFile;
    OVERLAPPED overlap = {0, 0, 0, 0, 0};
    DWORD rSize, wSize;
    DWORD numPages = size/PAGESIZE+1;
    DWORD opTime, waitTime;
    DWORD error;

    FILE_SEGMENT_ELEMENT temp = wpages[numPages];
    wpages[numPages].Buffer = NULL;

    TESTCASE(variation)
        {
        hFile = CreateFile(filename, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            char wbuffer[1024];
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        SetFilePointer(hFile, size+KILOBYTE, NULL, FILE_BEGIN);
        SetEndOfFile(hFile);

        // write the test data
        if(WriteFileGather(hFile, wpages, size, NULL, &overlap) == FALSE)
            TESTPASS(hLog, "WriteFileGather[%ld] (ec: %ld)", overlap.InternalHigh, GetLastError());
        else
            TESTFAIL(hLog, "WriteFileGather[%ld] (ec: %ld)", overlap.InternalHigh, GetLastError());

        GetOverlappedResult(hFile, &overlap, &wSize, TRUE);

        // read the data back
        opTime = GetTickCount();
        if(ReadFileScatter(hFile, rpages, size, NULL, &overlap) == FALSE && ((error=GetLastError()) == ERROR_IO_PENDING))
            TESTPASS(hLog, "ReadFileScatter (ec: %ld)", error);
        else
            TESTFAIL(hLog, "ReadFileScatter (ec: %ld)", error);
        opTime = GetTickCount()-opTime;

        // wait for the IO to complete
        waitTime = GetTickCount();
        if(GetOverlappedResult(hFile, &overlap, &rSize, (error==ERROR_IO_PENDING?TRUE:FALSE)) == TRUE)
            TESTPASS(hLog, "GetOverlappedResult[%ld] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "GetOverlappedResult[%ld] (ec: %ld)", rSize, GetLastError());
        waitTime = GetTickCount()-waitTime;

        /* Because of locking caused by logfile writes, these time tests will always fail
        if(opTime > 2*waitTime)
            TESTFAIL(hLog, "Read Operation took longer than 2*wait: %lu, %lu", opTime, waitTime);
            */

        // compare the 2 buffers
        if(!(rSize == size && wSize == size))
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        else if(CompareBuffer(wpages, rpages, size) == FALSE)
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        else
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);

        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(filename); });
    
    wpages[numPages] = temp;
    }


/*

Routine Description:

    Fills an array of buffers with data making sure data between calls is different

Arguments:

    FILE_SEGMENT_ELEMENT *aSegmentArray - array of buffers, each ptr must be 1 PAGESIZE
    DWORD size - total number of bytes to write

Return Value:

    none

*/
static void FillBuffer(FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD size)
    {
    static bool hilo=false; // so we put different data in the buffer each time we use it
    for(DWORD i=0; i<size; i++)
        {

        ((char*)aSegmentArray[i/PAGESIZE].Buffer)[i%PAGESIZE] = (char) (hilo?i:~i);
        }
    hilo = !hilo;
    }

/*

Routine Description:

    Compares two buffer arrays

Arguments:

    FILE_SEGMENT_ELEMENT *aSegmentArray - array of buffers, each ptr must be 1 PAGESIZE
    FILE_SEGMENT_ELEMENT *bSegmentArray - array of buffers, each ptr must be 1 PAGESIZE
    DWORD size - total size of the data

Return Value:

    TRUE if they are ==
    FALSE if they are !=

*/
static BOOL CompareBuffer(FILE_SEGMENT_ELEMENT *aSegmentArray, FILE_SEGMENT_ELEMENT *bSegmentArray, DWORD size)
    {
    DWORD s;
    for(DWORD i=0; i<size; i+=PAGESIZE)
        {
        if(i + PAGESIZE > size) s = size - i;
        else s = PAGESIZE;

        if(memcmp(aSegmentArray[i/PAGESIZE].Buffer, bSegmentArray[i/PAGESIZE].Buffer, s) != 0) return FALSE;
        }

    return TRUE;
    }


/*
    TODO 
        Read() off of DVD (different sector size)
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\readwritefileex.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    ReadWriteFileEx.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"


struct CompletionState
    {
    long state;         // current state 0=write 1=read 0xff=timeout
    DWORD errorCode;    // expected error code
    DWORD size;         // size of the data to read/write
    char *variation;    // name of this test variation
    HANDLE hFile;       // handle to the file
    char *filename;   // filename
    char *rbuffer;      // read buffer
    char *wbuffer;      // write buffer
    HANDLE hLog;        // handle to the logging object
    };

static void CALLBACK CompletionFunct(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);
static void SerializeTest(HANDLE hLog, char *variation, char *filename, DWORD size, char *rbuffer, char *wbuffer);
static void SerializeTestCloseEarly(HANDLE hLog, char *variation, char *filename, DWORD size, char *rbuffer, char *wbuffer);

/*

Routine Description:

    Tests the ReadFileEx / WriteFileEx APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::ReadWriteFileEx_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReadFileEx(
      HANDLE hFile,                                       // handle to file
      LPVOID lpBuffer,                                    // data buffer
      DWORD nNumberOfBytesToRead,                         // number of bytes to read
      LPOVERLAPPED lpOverlapped,                          // offset
      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine // completion routine
    );

    BOOL WriteFileEx(
      HANDLE hFile,                                       // handle to output file
      LPCVOID lpBuffer,                                   // data buffer
      DWORD nNumberOfBytesToWrite,                        // number of bytes to write
      LPOVERLAPPED lpOverlapped,                          // overlapped buffer
      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine // completion routine
    );
    */
    xSetFunctionName(hLog, "ReadFileEx / WriteFileEx");

    char *wbuffer = new char[MEGABYTE*16];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    char *rbuffer = new char[MEGABYTE*16];
    if(!rbuffer)
        {
        delete[] wbuffer;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FRWX01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\FRWX02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%s:\\FRWX03_%d.txt", BASE_DRIVE, ThreadID);

    HANDLE hFile = NULL;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;

    DWORD size;

    // initialize state
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("All NULL")
        {
        BUGGEDPASS(195, "ACCESS VIOLATION \"By Design\"");
        if(ReadFileEx(hNull, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReadFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReadFileEx (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE NULL")
        {
        BUGGEDPASS(195, "ACCESS VIOLATION \"By Design\"");
        if(ReadFileEx(INVALID_HANDLE_VALUE, NULL, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReadFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReadFileEx (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    size = sprintf(wbuffer, "");
    SerializeTest(hLog, "Read/Write 0 bytes", lpFile1, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "1");
    SerializeTest(hLog, "Read/Write 1 byte", lpFile2, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, " ");
    SerializeTest(hLog, "Read/Write 1 space", lpFile3, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "69");
    SerializeTest(hLog, "Read/Write 2 bytes", lpFile1, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "xboxboxboxboxbox");
    SerializeTest(hLog, "Read/Write 16 bytes", lpFile2, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFileEx() / WriteFileEx() API Test!\r\n");
    SerializeTest(hLog, "Read/Write short text", lpFile3, size, rbuffer, wbuffer);

    size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFileEx() / WriteFileEx() API Test!\r\n\r\n"
            "The quick brown fox jumps over the lazy dog\r\n"
            "1234567890\t-=`~!@#$%^&*()_+[]}{\\|';:\"/.,<>?\r\n\r\n"
            "This is a story about Ranet Jeno, the wicked witch from a swamp called DC.\r\n\r\n"
            "(All persons, places, and events are fictitious and bear no resemblance to any living or deceased (past, present, or future) persons, places or events.)\r\n\r\n");
    SerializeTest(hLog, "Read/Write long text", lpFile1, size, rbuffer, wbuffer);

    for(int i=0; i<8192; i++)
        {
        size += sprintf(wbuffer+size, "Hello World.\r\n\r\nThis is a ReadFileEx() / WriteFileEx() API Test!\r\n\r\n");
        }
    SerializeTest(hLog, "Read/Write really long text (0.5meg)", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<256; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write short binary (256b)", lpFile3, size, rbuffer, wbuffer);

    for(size=0; size<512; size++)
        {
        wbuffer[size] = (char)(~size);
        }
    SerializeTest(hLog, "Read/Write short binary (512b)", lpFile1, size, rbuffer, wbuffer);

    for(size=0; size<MEGABYTE*15; size++)
        {
        wbuffer[size] = (char)size;
        }
    SerializeTest(hLog, "Read/Write 15 meg", lpFile2, size, rbuffer, wbuffer);

    for(size=0; size<MEGABYTE*15; size++)
        {
        wbuffer[size] = (char)(~size);
        }
    SerializeTestCloseEarly(hLog, "Read/Write Close Early", lpFile3, size, rbuffer, wbuffer);

    for(size=0; size<MEGABYTE*15; size++)
        {
        wbuffer[size] = (char)(size);
        }
    SerializeTest(hLog, "Read/Write another 15 meg", lpFile1, size, rbuffer, wbuffer);


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////

    // TODO
    // file not opened with FILE_FLAG_OVERLAPPED
    // 

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    delete[] wbuffer;
    delete[] rbuffer;

    // cleanup
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);

    return 0;
    }



static VOID CALLBACK CompletionFunct(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
    {
    // Bad pointer
    if(!lpOverlapped)
        {
        DebugPrint("OVERLAPPED struct is null (ec: %ld)", dwErrorCode);
        return;
        }

    CompletionState *testinfo = (CompletionState*)lpOverlapped->hEvent;

    // Bad pointer
    if(!testinfo)
        {
        memset(lpOverlapped, 0, sizeof(OVERLAPPED));
        delete lpOverlapped;
        DebugPrint("OVERLAPPED struct contained invalid pointer to state information (ec: %ld)", dwErrorCode);
        return;
        }

    long stateVal = InterlockedIncrement(&testinfo->state) - 1;

    // Write Callback
    if(stateVal == 0)
        {
        if(dwNumberOfBytesTransfered == testinfo->size && dwErrorCode == testinfo->errorCode)
            TESTPASS(testinfo->hLog, "WriteFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);
        else
            TESTFAIL(testinfo->hLog, "WriteFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);

        if(ReadFileEx(testinfo->hFile, testinfo->rbuffer, testinfo->size, lpOverlapped, CompletionFunct) == TRUE)
            TESTPASS(testinfo->hLog, "ReadFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(testinfo->hLog, "ReadFileEx (ec: %ld)", GetLastError());
        }

    // Read Callback
    else if(stateVal == 1)
        {
        if(dwNumberOfBytesTransfered == testinfo->size && dwErrorCode == testinfo->errorCode)
            TESTPASS(testinfo->hLog, "ReadFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);
        else
            TESTFAIL(testinfo->hLog, "ReadFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);

        if(memcmp(testinfo->rbuffer, testinfo->wbuffer, testinfo->size) == 0)
            TESTPASS(testinfo->hLog, "Write Buffer[%d] == Read Buffer[%d]", testinfo->size, dwNumberOfBytesTransfered);
        else
            TESTFAIL(testinfo->hLog, "Write Buffer[%d] != Read Buffer[%d]", testinfo->size, dwNumberOfBytesTransfered);
        }

    // Write Callback on the close early test
    else if(stateVal == 10)
        {
        if(dwNumberOfBytesTransfered == testinfo->size && dwErrorCode == testinfo->errorCode)
            TESTPASS(testinfo->hLog, "WriteFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);
        else
            TESTFAIL(testinfo->hLog, "WriteFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);

        if(ReadFileEx(testinfo->hFile, testinfo->rbuffer, testinfo->size, lpOverlapped, CompletionFunct) == TRUE)
            TESTPASS(testinfo->hLog, "ReadFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(testinfo->hLog, "ReadFileEx (ec: %ld)", GetLastError());

        CloseHandle(testinfo->hFile);
        }

    // Read Callback on the close early test
    else if(stateVal == 11)
        {
        if(dwNumberOfBytesTransfered == testinfo->size && dwErrorCode == testinfo->errorCode)
            TESTPASS(testinfo->hLog, "ReadFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);
        else
            TESTFAIL(testinfo->hLog, "ReadFileEx[%ld] (ec: %ld)", dwNumberOfBytesTransfered, dwErrorCode);

        if(memcmp(testinfo->rbuffer, testinfo->wbuffer, testinfo->size) == 0)
            TESTPASS(testinfo->hLog, "Write Buffer[%d] == Read Buffer[%d]", testinfo->size, dwNumberOfBytesTransfered);
        else
            TESTFAIL(testinfo->hLog, "Write Buffer[%d] != Read Buffer[%d]", testinfo->size, dwNumberOfBytesTransfered);
        }

    // We hit timeout before the callback - things are messed, so cleanup and bail
    else if(stateVal == 0xFF)
        {
        CloseHandle(testinfo->hFile);
        DeleteFile(testinfo->filename);
        memset(testinfo, 0, sizeof(CompletionState));
        memset(lpOverlapped, 0, sizeof(OVERLAPPED));
        delete testinfo;
        delete lpOverlapped;
        }

    // unknown state
    else
        {
        memset(lpOverlapped, 0, sizeof(OVERLAPPED));
        delete lpOverlapped;
        TESTFAIL(testinfo->hLog, "State information contained invalid state (ec: %ld)", dwErrorCode);
        return;
        }
    }



static void SerializeTest(HANDLE hLog, char *variation, char *filename, DWORD size, char *rbuffer, char *wbuffer)
    {
    CompletionState *state = new CompletionState; // gets deleted in CompletionFunct
    if(!state) return;

    OVERLAPPED *overlap = new OVERLAPPED; // gets deleted in CompletionFunct
    if(!overlap)
        {
        delete state;
        return;
        }

    // hEvent is ignored by ReadFileEx & WriteFileEx and so they allow us to pass information via this pointer
    overlap->hEvent = (HANDLE)state;
    overlap->Internal = 0;
    overlap->InternalHigh = 0;
    overlap->Offset = 0;
    overlap->OffsetHigh = 0;

    state->rbuffer = rbuffer;
    state->wbuffer = wbuffer;
    state->errorCode = 0;
    state->filename = filename;
    state->size = size;
    state->variation = variation;
    state->state = 0;
    state->hLog = hLog;

    long stateVal=0;

    TESTCASE(variation)
        {
        state->hFile = CreateFile(state->filename, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
        if(state->hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        SetFilePointer(state->hFile, state->size+KILOBYTE, NULL, FILE_BEGIN);
        SetEndOfFile(state->hFile);

        if(WriteFileEx(state->hFile, state->wbuffer, state->size, overlap, CompletionFunct) == TRUE)
            TESTPASS(hLog, "WriteFileEx (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "WriteFileEx (ec: %ld)", GetLastError());
            CloseHandle(state->hFile);
            DeleteFile(state->filename);
            delete state;
            delete overlap;
            break;
            }

        // wait for the IO operations to finish
        DWORD status = SleepEx(15000, true);
        stateVal = InterlockedCompareExchange(&state->state, 0x33, 0x33); // just get the value
        if(stateVal < 2)
            {
            status = SleepEx(15000, true);
            stateVal = InterlockedCompareExchange(&state->state, 0x33, 0x33); // just get the value
            }

        if(status != WAIT_IO_COMPLETION)
            {
            stateVal = InterlockedExchange(&state->state, 0xFF); // tell the CompletionFunct to delete the buffers for us 
            TESTFAIL(hLog, "Hit timeout before IO Completed (memory may leak as a result) state=%d", stateVal);
            }
        else if(stateVal != 2)
            {
            stateVal = InterlockedExchange(&state->state, 0xFF); // tell the CompletionFunct to delete the buffers for us 
            TESTFAIL(hLog, "Not finished with all states (memory may leak as a result) state=%d", stateVal);
            }
        else
            {
            CloseHandle(state->hFile);
            DeleteFile(state->filename);
            delete state;
            delete overlap;
            }

        } ENDTESTCASE;
    
    return;
    }

// Added special case to test for bug 3312
static void SerializeTestCloseEarly(HANDLE hLog, char *variation, char *filename, DWORD size, char *rbuffer, char *wbuffer)
    {
    CompletionState *state = new CompletionState; // gets deleted in CompletionFunct
    if(!state) return;

    OVERLAPPED *overlap = new OVERLAPPED; // gets deleted in CompletionFunct
    if(!overlap)
        {
        delete state;
        return;
        }

    // hEvent is ignored by ReadFileEx & WriteFileEx and so they allow us to pass information via this pointer
    overlap->hEvent = (HANDLE)state;
    overlap->Internal = 0;
    overlap->InternalHigh = 0;
    overlap->Offset = 0;
    overlap->OffsetHigh = 0;

    state->rbuffer = rbuffer;
    state->wbuffer = wbuffer;
    state->errorCode = 0;
    state->filename = filename;
    state->size = size;
    state->variation = variation;
    state->state = 10;
    state->hLog = hLog;

    long stateVal=0;

    TESTCASE(variation)
        {
        state->hFile = CreateFile(state->filename, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
        if(state->hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        SetFilePointer(state->hFile, state->size+KILOBYTE, NULL, FILE_BEGIN);
        SetEndOfFile(state->hFile);

        if(WriteFileEx(state->hFile, state->wbuffer, state->size, overlap, CompletionFunct) == TRUE)
            TESTPASS(hLog, "WriteFileEx (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "WriteFileEx (ec: %ld)", GetLastError());
            CloseHandle(state->hFile);
            DeleteFile(state->filename);
            delete state;
            delete overlap;
            break;
            }

        // wait for the IO operations to finish
        DWORD status = SleepEx(15000, true);
        stateVal = InterlockedCompareExchange(&state->state, 0x33, 0x33); // just get the value
        if(stateVal < 12)
            {
            status = SleepEx(15000, true);
            stateVal = InterlockedCompareExchange(&state->state, 0x33, 0x33); // just get the value
            }

        if(status != WAIT_IO_COMPLETION)
            {
            stateVal = InterlockedExchange(&state->state, 0xFF); // tell the CompletionFunct to delete the buffers for us 
            TESTFAIL(hLog, "Hit timeout before IO Completed (memory may leak as a result) state=%d", stateVal);
            }
        else if(stateVal != 12)
            {
            stateVal = InterlockedExchange(&state->state, 0xFF); // tell the CompletionFunct to delete the buffers for us 
            TESTFAIL(hLog, "Not finished with all states (memory may leak as a result) state=%d", stateVal);
            }
        else
            {
            DeleteFile(state->filename);
            delete state;
            delete overlap;
            }

        } ENDTESTCASE;
    
    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\replacefile.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    ReplaceFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the ReplaceFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::ReplaceFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReplaceFile(
      LPCTSTR lpReplacedFileName,    // file name
      LPCTSTR lpReplacementFileName, // replacement file 
      LPCTSTR lpBackupFileName,      // optional backup file
      DWORD dwReplaceFlags,          // replace options
      LPVOID lpExclude,              // reserved
      LPVOID lpReserved              // reserved
    );
    */
    xSetFunctionName(hLog, "ReplaceFile");

    char lpFile1[80]; sprintf(lpFile1, "%s:\\ReplaceFile_file1_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\ReplaceFile_file2_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%s:\\ReplaceFile_file3_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%s:\\ReplaceFile_bigfile_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%s:\\ReplaceFile_thisFileDoesNotExist_%d.bla", BASE_DRIVE, ThreadID);
    unsigned i;

    // initialize system state
    CreateFilledFile(lpFile1, KILOBYTE*16);
    CreateFilledFile(lpFile2, KILOBYTE*16);
    CreateFilledFile(lpBigFile, MEGABYTE*32);
    DeleteFile(lpFakeFile);
    DeleteFile(lpFile3);


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NUL")
        {
        if(ReplaceFile(lpNull, lpNull, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("exists NUL")
        {
        if(ReplaceFile(lpFile1, lpNull, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("NULL exists")
        {
        if(ReplaceFile(lpNull, lpFile1, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("exists Empty")
        {
        if(ReplaceFile(lpFile1, lpEmpty, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Empty exists")
        {
        if(ReplaceFile(lpEmpty, lpFile1, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("valid valid nul")
        {
        if(ReplaceFile(lpFile1, lpFile2, lpNull, 0, NULL, NULL) == TRUE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(!FileExists(lpFile2))
            TESTPASS(hLog, "Original file removed (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file removed (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpFile2, FALSE); });
    TESTCASE("large valid valid nul")
        {
        if(ReplaceFile(lpFile1, lpBigFile, lpNull, 0, NULL, NULL) == TRUE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(!FileExists(lpBigFile))
            TESTPASS(hLog, "Original file removed (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file removed (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpBigFile, FALSE); });
    TESTCASE("valid valid backup")
        {
        if(ReplaceFile(lpFile1, lpFile2, lpFile3, 0, NULL, NULL) == TRUE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(!FileExists(lpFile2))
            TESTPASS(hLog, "Original file removed (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file removed (ec: %ld)", GetLastError());

        if(FileExists(lpFile3))
            TESTPASS(hLog, "Backup created (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Backup created (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpFile2, FALSE); DeleteFile(lpFile3); });
    TESTCASE("large valid valid backup")
        {
        if(ReplaceFile(lpFile1, lpBigFile, lpFile3, 0, NULL, NULL) == TRUE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(!FileExists(lpBigFile))
            TESTPASS(hLog, "Original file removed (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file removed (ec: %ld)", GetLastError());

        if(FileExists(lpFile3))
            TESTPASS(hLog, "Backup created (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Backup created (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpBigFile, FALSE); DeleteFile(lpFile3); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("invalid valid nul")
        {
        if(ReplaceFile(lpFakeFile, lpFile2, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(FileExists(lpFile2))
            TESTPASS(hLog, "Original file remains (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file remains (ec: %ld)", GetLastError());

        if(!FileExists(lpFakeFile))
            TESTPASS(hLog, "Invalid file created (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Invalid file created (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFakeFile); });
    TESTCASE("valid invalid nul")
        {
        if(ReplaceFile(lpFile1, lpFakeFile, lpNull, 0, NULL, NULL) == FALSE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());

        if(FileExists(lpFile1))
            TESTPASS(hLog, "Original file remains (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Original file remains (ec: %ld)", GetLastError());

        if(!FileExists(lpFakeFile))
            TESTPASS(hLog, "Invalid file created (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Invalid file created (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFakeFile); });
    TESTCASE("newfile valid null w/ extra params")
        {
        if(ReplaceFile(lpFile1, lpFile2, lpNull, 0, hBogus, hBogus) == FALSE)
            TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CopyFile(lpFile1, lpFile2, FALSE); });



    //////////////////////////////////////////////////////////////////////////
    // Invalid characters
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(invalidFileNames); i++)
        {
        TESTCASE(invalidFileNames[i])
            {
            if(ReplaceFile(invalidFileNames[i], lpFile1, lpNull, 0, NULL, NULL) == FALSE)
                TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());
            if(ReplaceFile(lpFile1, invalidFileNames[i], lpNull, 0, NULL, NULL) == FALSE)
                TESTPASS(hLog, "ReplaceFile (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "ReplaceFile (ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }



    // over maxpath, over 32000 (using \\?\c:\...)
    // (exists, nonexists, false)
    // (nonexists, nonexists, false)

    // messing with naming convention
        // use mixed / and \
        // spaces
        // .
        // ..
        // (exists, nonexists (with < > : " / \ | ), false)
        // unc: \\?\UNC\poleyland1\public\tests
        // case insensitivity


    //////////////////////////////////////////////////////////////////////////
    // copy abc to abc
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(file1, file1, true)")
        {
        if(CopyFile(lpBigFile, lpBigFile, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(file1, file1, false)")
        {
        if(CopyFile(lpBigFile, lpBigFile, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    xSetFunctionName(hLog, "DeleteFile");
    TESTCASE("Removing lpFile1")
        {
        if(DeleteFile(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing lpFile2")
        {
        if(DeleteFile(lpFile2) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing lpBigFile")
        {
        if(DeleteFile(lpBigFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

/*
#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif
*/



// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>



#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
{
ULONG DebugPrint(PCHAR Format, ...);
}


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\setendoffile.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    SetEndOfFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the SetEndOfFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::SetEndOfFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL SetEndOfFile(
      HANDLE hFile   // handle to file
    );
    */
    xSetFunctionName(hLog, "SetEndOfFile");

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FEO01_%d.txt", BASE_DRIVE, ThreadID);
    HANDLE hFile;
    DWORD size;
    DWORD highSize;

    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NUL")
        {
        if(SetEndOfFile(hNull) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE")
        {
        if(SetEndOfFile(INVALID_HANDLE_VALUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Empty File")
        {
        size = 0;
        CreateFilledFile(lpFile1, 0);
        hFile = FileOpenRW(lpFile1);

        if(SetEndOfFile(hFile) == TRUE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("filesize 1, End 1")
        {
        size = 1;
        CreateFilledFile(lpFile1, 1);
        hFile = FileOpenRW(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        if(SetEndOfFile(hFile) == TRUE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("filesize 1, End 0")
        {
        size = 0;
        CreateFilledFile(lpFile1, 1);
        hFile = FileOpenRW(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        if(SetEndOfFile(hFile) == TRUE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("filesize 13meg, End 3meg")
        {
        size = MEGABYTE*3;
        CreateFilledFile(lpFile1, MEGABYTE*15);
        hFile = FileOpenRW(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        if(SetEndOfFile(hFile) == TRUE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Read Only file")
        {
        size = 512;
        CreateFilledFile(lpFile1, KILOBYTE);
        hFile = FileOpen(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        if(SetEndOfFile(hFile) == FALSE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        if((highSize=GetFileSize(hFile, &highSize)) != size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Closed Handle")
        {
        size = 512;
        CreateFilledFile(lpFile1, KILOBYTE);
        hFile = FileOpenRW(lpFile1);

        if((highSize=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == size)
            TESTPASS(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "SetFilePointer=%ld (ec: %ld)", highSize, GetLastError());

        CloseHandle(hFile);

        if(SetEndOfFile(hFile) == FALSE)
            TESTPASS(hLog, "SetEndOfFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "SetEndOfFile (ec: %ld)", GetLastError());

        hFile = FileOpenRW(lpFile1);

        if((highSize=GetFileSize(hFile, &highSize)) != size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        //DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 20; // this must be bigger than 8
        unsigned failures = 0;

        CreateFilledFile(lpFile1, KILOBYTE);
        hFile = FileOpenRW(lpFile1);

        for(unsigned i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                //DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }
            SetFilePointer(hFile, (i%8)*1024, NULL, FILE_BEGIN);
            SetEndOfFile(hFile);
            }
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\commontest.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         L"Z"
#define TITLE_DRIVE         L"T"
#define USER_DRIVE          L"U"
#define BASE_DRIVE          CACHE_DRIVE

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    xStartVariation(hLog, variant);
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    xStartVariation(hLog, aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

#define ALLCHARS L"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f" \
    L"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

// common numbers
static DWORD dwBogus = 0xF000BAAA;
static ULARGE_INTEGER ulBogus = { 0xF000BAAA, 0xF000BAAA };

// common HANDLE parameters
static HANDLE hNull = NULL;
static HANDLE hBogus = (void*)0xF000BAAA;

// common string parameters
static LPCTSTR lpNull = NULL;
static LPCTSTR lpEmpty = L"";
static LPCTSTR lpSpace = L" ";
static LPCTSTR lpBogus = (const unsigned short*)0xF000BAAA;


// different names
static WCHAR *crazyNames[] = {
    L")#+l+RI+Td<\x12>",
    L"~`!@#$%^&*)-=_+[{\\|';:\",./?>",
    L"*",
    L"?",
    L"abc?",
    L"abc>def",
    L"abc<def",
    L"abc|def",
    L"abc:def",
    L"abc\"def",
    L">",
    L"<",
    L":",
    L"|",
    L"\"",
    L"..\\abcdef",
    L".\\..\\abcdef",
    L"abc" BASE_DRIVE L":\\def",
    L"new\nline",
    L"newline\n",
    L"Carriage\rreturn",
    L"Carriagereturn\r",
    L"\ttab",
    L"tab\t",
    L"\abell",
    L"bell\a",
    L"::\\abc",
    L"abc",
    L".",
    L"..",
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\setfilepointer.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    SetFilePointer.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

    If you make changes to the test cases, be sure to make similiar changes
    to the cases in SetFilePointerEx.cpp

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the SetFilePointer API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::SetFilePointer_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD SetFilePointer(
      HANDLE hFile,                // handle to file
      LONG lDistanceToMove,        // bytes to move pointer
      PLONG lpDistanceToMoveHigh,  // bytes to move pointer
      DWORD dwMoveMethod           // starting point
    );
    */
    xSetFunctionName(hLog, "SetFilePointer");

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FFP01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\FFP02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%s:\\FFP03_%d.txt", BASE_DRIVE, ThreadID);
    char lpFileTemp[80];

    char *stdStr = "DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);";
    DWORD size;
    DWORD wSize, rSize;

    HANDLE hFile = NULL;
    HANDLE hFileTemp;
    DWORD seek = 0;

    char *wbuffer = new char[MEGABYTE*24];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    char *rbuffer = new char[MEGABYTE*24];
    if(!rbuffer)
        {
        delete[] wbuffer;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }

    hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NUL")
        {
        if(SetFilePointer(hNull, 0, NULL, 0) == INVALID_SET_FILE_POINTER)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE")
        {
        if(SetFilePointer(INVALID_HANDLE_VALUE, 0, NULL, 0) == INVALID_SET_FILE_POINTER)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Seek(0 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, 0, NULL, FILE_BEGIN)) == 0)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if((seek=SetFilePointer(hFile, 0, NULL, FILE_BEGIN)) == 0)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(1 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, 1, NULL, FILE_BEGIN)) == 1)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if((seek=SetFilePointer(hFile, 1, NULL, FILE_BEGIN)) == 1)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(10 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, 10, NULL, FILE_BEGIN)) == 10)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if((seek=SetFilePointer(hFile, 10, NULL, FILE_BEGIN)) == 10)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(300 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, 300, NULL, FILE_BEGIN)) == 300)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if((seek=SetFilePointer(hFile, 300, NULL, FILE_BEGIN)) == 300)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(-200 FILE_END) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, -200, NULL, FILE_END)) == 100+strlen(stdStr))
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if((seek=SetFilePointer(hFile, -200, NULL, FILE_END)) == 100+strlen(stdStr))
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("FatxFreeClusters Stress Test")
        {
        int stressCount;
        const int maxStress = 1000;
        // Testcase for bug #2095: FatxFreeClusters overcounts volume free cluster count when truncating a file allocation
        sprintf(lpFileTemp, "%s:\\FFP04_%d.txt", BASE_DRIVE, ThreadID);
        hFileTemp = CreateFile(lpFileTemp, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        DebugPrint("FILEIO(%d): This test takes a long time to run...\n", ThreadID);
        for(stressCount=0; stressCount<maxStress; stressCount++)
            {
            if(stressCount%(maxStress/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, stressCount*100/maxStress);

            SetFilePointer(hFileTemp, 1000000, NULL, FILE_BEGIN);
            SetEndOfFile(hFileTemp);
            SetFilePointer(hFileTemp, 1000, NULL, FILE_BEGIN);
            SetEndOfFile(hFileTemp);
            }

        CloseHandle(hFileTemp);
        DeleteFile(lpFileTemp);
        } ENDTESTCASE_CLEAN( { DebugPrint("   (%d) 100%%\n", ThreadID); } );


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Seek(-1 FILE_BEGIN)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, -1, NULL, FILE_BEGIN)) == INVALID_SET_FILE_POINTER)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Seek(-2 FILE_BEGIN)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, -2, NULL, FILE_BEGIN)) == INVALID_SET_FILE_POINTER)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Seek(-200 FILE_BEGIN)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, -200, NULL, FILE_BEGIN)) == INVALID_SET_FILE_POINTER)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Seek(-1000 FILE_END)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, -1000, NULL, FILE_END)) == INVALID_SET_FILE_POINTER)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Seek(-1000 FILE_CURRENT)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if((seek=SetFilePointer(hFile, -1000, NULL, FILE_CURRENT)) == INVALID_SET_FILE_POINTER)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    CloseHandle(hFile);
    DeleteFile(lpFile1);
    delete[] wbuffer;
    delete[] rbuffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\setfilepointerex.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    SetFilePointerEx.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

    If you make changes to the test cases, be sure to make similiar changes
    to the cases in SetFilePointer.cpp

*/

#include "stdafx.h"
#include "commontest.h"
#include "fileio_win32API.h"

/*

Routine Description:

    Tests the SetFilePointerEx API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD FILEIO::SetFilePointerEx_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL SetFilePointerEx(
      HANDLE hFile,                    // handle to file
      LARGE_INTEGER liDistanceToMove,  // bytes to move pointer
      PLARGE_INTEGER lpNewFilePointer, // new file pointer
      DWORD dwMoveMethod               // starting point
    );
    */
    xSetFunctionName(hLog, "SetFilePointerEx");

    char lpFile1[80]; sprintf(lpFile1, "%s:\\FFPX01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%s:\\FFPX02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%s:\\FFPX03_%d.txt", BASE_DRIVE, ThreadID);

    char *stdStr = "DWORD SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);";
    DWORD size;
    DWORD wSize, rSize;
    LARGE_INTEGER i64;
    HANDLE hFile = NULL;
    DWORD seek = 0;

    char *wbuffer = new char[MEGABYTE*24];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    char *rbuffer = new char[MEGABYTE*24];
    if(!rbuffer)
        {
        delete[] wbuffer;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }

    hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NUL")
        {
        if(SetFilePointerEx(hNull, iLARGE_INTEGER(0), NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("INVALID_HANDLE_VALUE")
        {
        if(SetFilePointerEx(INVALID_HANDLE_VALUE, iLARGE_INTEGER(0), NULL, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Seek(0 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(0), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 0)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(0), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 0)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(1 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(1), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 1)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(1), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 1)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(10 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(10), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 10)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(10), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 10)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(300 FILE_BEGIN) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(300), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 300)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(300), &i64, FILE_BEGIN) == TRUE && i64.QuadPart == 300)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;
    TESTCASE("Seek(-200 FILE_END) Read/Write")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-200), &i64, FILE_END) == TRUE && i64.QuadPart == 100+strlen(stdStr))
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        size = sprintf(wbuffer, "%s", stdStr);
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-200), &i64, FILE_END) == TRUE && i64.QuadPart == 100+strlen(stdStr))
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Seek(-1 FILE_BEGIN)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-1), &i64, FILE_BEGIN) == FALSE)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Seek(-2 FILE_BEGIN)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-2), &i64, FILE_BEGIN) == FALSE)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Seek(-200 FILE_BEGIN)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-200), &i64, FILE_BEGIN) == FALSE)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Seek(-1000 FILE_END)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-1000), &i64, FILE_END) == FALSE)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Seek(-1000 FILE_CURRENT)")
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(SetFilePointerEx(hFile, iLARGE_INTEGER(-1000), &i64, FILE_CURRENT) == FALSE)
            TESTPASS(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%I64d] (ec: %ld)", i64.QuadPart, GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    CloseHandle(hFile);
    DeleteFile(lpFile1);

    delete[] wbuffer;
    delete[] rbuffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\mmtimer\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This program contains routines to test multimedia timer

Environment:

    Xbox

Revision History:

--*/


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <xtl.h>
#include <xlog.h>
#include <xtestlib.h>
#include <testutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\utils.h ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

namespace FILEIO
    {
    extern bool FileExists(const char *filename);
    extern DWORD FillFile(HANDLE hFile, DWORD size);
    extern DWORD CreateFilledFile(const char *filename, DWORD size=16384);
    extern HANDLE FileOpen(const char *filename);
    extern HANDLE FileOpenRW(const char *filename);
    extern BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec);
    extern DWORD FillHDPartition(const char *drive, char *lpFile);
    extern void LogResourceStatus(HANDLE hLog, bool debugger);

    class iLARGE_INTEGER
        {
        public: 
            __int64 value;

        public:
            iLARGE_INTEGER() { value = 0; }
            iLARGE_INTEGER(int i) { value = i; }
            iLARGE_INTEGER(DWORD i) { value = i; }
            iLARGE_INTEGER(__int64 i) { value = i; }
            iLARGE_INTEGER(const LARGE_INTEGER &i) { value = i.QuadPart; }

            operator int() {  return (int)value; }
            operator DWORD() {  return (DWORD)value; }
            operator __int64() {  return value; }
            operator LARGE_INTEGER() {  LARGE_INTEGER a; a.QuadPart=value; return a; }
        };

    } // namespace FILEIO
#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\findnickname.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    FindNickname.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

    #define NUM_NICK_ENTRIES 50
    #define MAX_NICKNAME 32
*/

#include "stdafx.h"
#include "commontest.h"
#include "Nickname.h"

bool InCollection(WCHAR *collection[], unsigned collectionSize, WCHAR *name)
    {
    for(unsigned i=0; i<collectionSize; i++)
        {
        if(_wcsicmp(collection[i], name) == 0) return true;
        }

    return false;
    }

unsigned NumItemsOfSize(WCHAR *collection[], unsigned collectionSize, unsigned size)
    {
    unsigned count = 0;

    for(unsigned i=0; i<collectionSize; i++)
        {
        if(wcslen(collection[i]) <= size) ++count;
        }

    return count;
    }

/*

Routine Description:

    Tests the XFindFirstNickname / XFindNextNickname / XFindClose APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

*/
DWORD Nickname::XFindNickname_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HANDLE XFindFirstNicknameW(
        IN BOOL fThisTitleOnly,
        OUT LPWSTR lpNickname,
        IN UINT uSize
        );

    BOOL XFindNextNicknameW(
        IN HANDLE hFindNickname,
        OUT LPWSTR lpNickname,
        IN UINT uSize);

    BOOL XFindClose(
        IN HANDLE hFind);
    */
    xSetFunctionName(hLog, "XFindNickname");

    WCHAR nickname[MAX_NICKNAME+1];
    HANDLE hFind;
    unsigned i;
    unsigned foundItems;

    WCHAR* names[] =
        {
        L"JP1",
        L"jpoley",
        L"Shadow",
        L"QuestGod",
        L"MAX_IDENTITYNAME78901234567890C",
        L"Snoopy",
        L"Dapple",
        L"JP2",
        L" ",
        L"MAX_IDENTITYNAME78901234567890D",
        L"Sam",
        L"/.",
        L"XBOX",
        L"1",
        L"Chow Yun-Fat",
        L"EastsideKILLA",
        L"Neo",
        L"atg-scorto",
        L"MAX_IDENTITYNAME78901234567890A",
        L"MAX_IDENTITYNAME78901234567890B",
        L"MAX_IDENTITYNAME78901234567890E",
        L"MAX_IDENTITYNAME78901234567890F",
        L"1jp",
        L"a"
        };

    // clear & then populate the cache with our test data
    TESTCASE("Populating Nickname file")
        {
        if(RemoveNicknameFile() == false)
            TESTFAIL(hLog, "DeleteFile(NICKNAME.XBN) failed (ec: %lu)", GetLastError());

        for(i=0; i<ARRAYSIZE(names); i++)
            {
            if(XSetNickname(names[i], FALSE) == FALSE)
                TESTFAIL(hLog, "XSetNickname (ec: %ld)", GetLastError());
            }
        } ENDTESTCASE;

    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("FindNickname length of MAX_NICKNAME")
        {
        unsigned length = MAX_NICKNAME;
        unsigned collectionSize = NumItemsOfSize(names, ARRAYSIZE(names), length);
        hFind = XFindFirstNickname(FALSE, nickname, length+1);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
            break;
            }

        foundItems = 0;
        DebugPrint("  ---------------\r\n", nickname);
        do
            {
            ++foundItems;
            DebugPrint("  '%ws'\r\n", nickname);
            if(!InCollection(names, ARRAYSIZE(names), nickname))
                TESTFAIL(hLog, "Found name is not in our collection (%ws)", nickname);
            } while(XFindNextNickname(hFind, nickname, length+1) == TRUE);
        
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());

        if(foundItems == collectionSize)
            TESTPASS(hLog, "FoundCount[%u] == collectionSize[%u]", foundItems, collectionSize);
        else
            TESTFAIL(hLog, "FoundCount[%u] != collectionSize[%u]", foundItems, collectionSize);
        } ENDTESTCASE;

    TESTCASE("FindNickname length of 1")
        {
        unsigned length = 1;
        unsigned collectionSize = NumItemsOfSize(names, ARRAYSIZE(names), length);
        hFind = XFindFirstNickname(FALSE, nickname, length+1);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
            break;
            }

        foundItems = 0;
        DebugPrint("  ---------------\r\n", nickname);
        do
            {
            ++foundItems;
            DebugPrint("  '%ws'\r\n", nickname);
            if(!InCollection(names, ARRAYSIZE(names), nickname))
                TESTFAIL(hLog, "Found name is not in our collection (%ws)", nickname);
            } while(XFindNextNickname(hFind, nickname, length+1) == TRUE);
        
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());

        if(foundItems == collectionSize)
            TESTPASS(hLog, "FoundCount[%u] == collectionSize[%u]", foundItems, collectionSize);
        else
            TESTFAIL(hLog, "FoundCount[%u] != collectionSize[%u]", foundItems, collectionSize);
        } ENDTESTCASE;

    TESTCASE("FindNickname length of 2")
        {
        unsigned length = 2;
        unsigned collectionSize = NumItemsOfSize(names, ARRAYSIZE(names), length);
        hFind = XFindFirstNickname(FALSE, nickname, length+1);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
            break;
            }

        foundItems = 0;
        DebugPrint("  ---------------\r\n", nickname);
        do
            {
            ++foundItems;
            DebugPrint("  '%ws'\r\n", nickname);
            if(!InCollection(names, ARRAYSIZE(names), nickname))
                TESTFAIL(hLog, "Found name is not in our collection (%ws)", nickname);
            } while(XFindNextNickname(hFind, nickname, length+1) == TRUE);
        
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());

        if(foundItems == collectionSize)
            TESTPASS(hLog, "FoundCount[%u] == collectionSize[%u]", foundItems, collectionSize);
        else
            TESTFAIL(hLog, "FoundCount[%u] != collectionSize[%u]", foundItems, collectionSize);
        } ENDTESTCASE;

    TESTCASE("FindNickname length of 3")
        {
        unsigned length = 3;
        unsigned collectionSize = NumItemsOfSize(names, ARRAYSIZE(names), length);
        hFind = XFindFirstNickname(FALSE, nickname, length+1);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
            break;
            }

        foundItems = 0;
        DebugPrint("  ---------------\r\n", nickname);
        do
            {
            ++foundItems;
            DebugPrint("  '%ws'\r\n", nickname);
            if(!InCollection(names, ARRAYSIZE(names), nickname))
                TESTFAIL(hLog, "Found name is not in our collection (%ws)", nickname);
            } while(XFindNextNickname(hFind, nickname, length+1) == TRUE);
        
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());

        if(foundItems == collectionSize)
            TESTPASS(hLog, "FoundCount[%u] == collectionSize[%u]", foundItems, collectionSize);
        else
            TESTFAIL(hLog, "FoundCount[%u] != collectionSize[%u]", foundItems, collectionSize);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("XFindClose(NULL)")
        {
        if(XFindClose(hNull) == FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("XFindClose(INVALID_HANDLE_VALUE)")
        {
        if(XFindClose(INVALID_HANDLE_VALUE) == FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("XFindClose(bogus)")
        {
        if(XFindClose(hBogus) == FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("XFindClose the handle twice")
        {
        hFind = FindFirstNickname(FALSE, nickname, MAX_NICKNAME);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        if(XFindClose(hFind) == FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    */


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif


// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>



#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
    {
    ULONG DebugPrint(PCHAR Format, ...);
    __declspec(dllimport) NTSTATUS NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes);
    }


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\nickname.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Nickname.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/

typedef DWORD (*APITEST_FUNC)(HANDLE hLog, DWORD ThreadID);

namespace Nickname
    {
    //
    //  XAPI Nickname Tests
    //
    extern DWORD XSetNickname_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD XFindNickname_Test(HANDLE hLog, DWORD ThreadID);
    } // namespace Nickname
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\nickname.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Nickname.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xlog.h>
#include "Nickname.h"
#include "commontest.h"
#include "utils.h"
#include "xtestlib.h"

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

static ULONG ThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE NicknameHeapHandle;


BOOL WINAPI NicknameDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        NicknameHeapHandle = HeapCreate(0, 0, 0);

        if(!NicknameHeapHandle)
            {
            OutputDebugString(L"NICKNAME: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(NicknameHeapHandle)
            {
            HeapDestroy(NicknameHeapHandle);
            }
        }

    return TRUE;
    }

static bool wcistrstr(WCHAR *string, WCHAR *substr, size_t len=0)
    {
    if(!string || ! substr) return false;
    if(!*string) return false;
    if(!len) len = wcslen(substr);
    if(_wcsnicmp(string, substr, len) == 0) return true;

    return wcistrstr(string+1, substr, len);
    }


/*

Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    DWORD threadNumber - sequential number of the thread
    DWORD loops - # of times to run test
    WCHAR* testname - specific name of a test to run

Return Value:

    DWORD

*/
namespace Nickname {
static DWORD RunAll(HANDLE hLog, DWORD threadNumber, DWORD loops, WCHAR *testname)
    {
    Sleep(threadNumber*200); // stagger the thread's execution a bit

    struct APIFUNCT
        {
        APITEST_FUNC f;
        WCHAR *name;
        };
    #define BUILTAPISTRUCT(n) { n , L#n }

    // Define all the API tests
    APIFUNCT testlist[] =
        {
        /*
        */
        BUILTAPISTRUCT(Nickname::XSetNickname_Test),
        BUILTAPISTRUCT(Nickname::XFindNickname_Test),
        /*
        */
        };

    bool runAll = _wcsicmp(testname, L"(all)") == 0 ? true : false;

    // Run the suite of tests
    for(DWORD i=0; i<loops; i++)
        {
        // run each test
        for(unsigned j=0; j<ARRAYSIZE(testlist); j++)
            {
            if(runAll || wcistrstr(testlist[j].name, testname))
                {
                xLog(hLog, XLL_INFO, "%ws() ******************************************", testlist[j].name);
                //LogResourceStatus(hLog, false);
                DebugPrint("NICKNAME(%d): Entering %ws()\n", threadNumber, testlist[j].name);
                testlist[j].f(hLog, threadNumber);
                }
            }
        }

    return 0;
    }
    } // namespace Nickname


/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI NicknameStartTest(HANDLE hLog)
    {
    DWORD ID = 0;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &ThreadID);


    // test settings
    const int buffLen = 1024;
    WCHAR testname[buffLen];
    DWORD loops;


    // Pull out internal INI file settings
    GetProfileString(L"nickname", L"testname", L"(all)", testname, buffLen);
    loops = GetProfileInt(L"nickname", L"loops", 1);


    xSetOwnerAlias(hLog, "jpoley");
    xSetComponent(hLog, "XAPI", "Nickname");
    DebugPrint("NICKNAME(%d): **************************************************************\n", ID);
    DebugPrint("NICKNAME(%d): Entering StartTest()\n", ID);
    DebugPrint("NICKNAME(%d): Internal INI Settings:\n", ID);
    DebugPrint("  loops=%lu\n", loops);
    DebugPrint("  testname=%ws\n", testname);


    switch(ID)
        {
        case 0:
        case 1:
        default:
            Nickname::RunAll(hLog, ID, loops, testname);
            break;
        }


    DebugPrint("NICKNAME(%d): Leaving StartTest()\n", ID);
    DebugPrint("NICKNAME(%d): **************************************************************\n", ID);
    xSetOwnerAlias(hLog, NULL);
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI NicknameEndTest(void)
    {
    ThreadID = 0;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( nickname )
#pragma data_seg()

BEGIN_EXPORT_TABLE( nickname )
    EXPORT_TABLE_ENTRY( "StartTest", NicknameStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", NicknameEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", NicknameDllMain )
END_EXPORT_TABLE( nickname )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\mmtimer\mmtimer.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mmtimer.cpp

Abstract:

    This program contains routines to test the following multimedia timer APIs

        timeGetSystemTime
        timeGetTime
        timeKillEvent
        timeSetEvent

Environment:

    Xbox

Revision History:

--*/


#include <precomp.h>


#define MMTIMER_TEST_DELAY1     250
#define MMTIMER_TEST_DELAY2     350
#define MAX_TIMER_TO_BE_TESTED  0x10000


VOID
MmTimerGetTimeTest(
    HANDLE LogHandle
    )
{
    DWORD time;
    MMTIME mmt;
    MMRESULT mmr;

    xSetFunctionName( LogHandle, "timeGetTime" );
    
    BEGIN_VARIATION( "basic" )
    {
        time = timeGetTime();
        LOG_PASS_FAIL( time != 0 );
    }
    END_VARIATION();

    xSetFunctionName( LogHandle, "timeGetSystemTime" );

    BEGIN_VARIATION( "basic" )
    {
        mmr = timeGetSystemTime( &mmt, sizeof(mmt) );
        LOG_PASS_FAIL( mmr == TIMERR_NOERROR );

        if ( mmr == TIMERR_NOERROR ) {
            xLog(
                LogHandle,
                XLL_INFO,
                "wType=%lu,u.ms=%lu",
                mmt.wType,
                mmt.u.ms
                );
        }
    }
    END_VARIATION();
}


VOID
CALLBACK
MmTimerCallbackProc(
    UINT uId,
    UINT uMsg,
    PLONG Counter,
    DWORD dw1,
    DWORD dw2
    )
{
    UNREFERENCED_PARAMETER( uId );
    UNREFERENCED_PARAMETER( uMsg );
    UNREFERENCED_PARAMETER( dw1 );
    UNREFERENCED_PARAMETER( dw2 );
    if ( Counter ) {
        InterlockedIncrement( Counter );
    }
}


VOID
MmTimerEventTest(
    HANDLE LogHandle
    )
{
    MMRESULT mmr;
    LONG Counter;
    HANDLE EventHandle;
    DWORD Wait;

    xSetFunctionName( LogHandle, "timeSetEvent" );

    BEGIN_VARIATION( "one-shot callback" )
    {
        Counter = 0;
        mmr = timeSetEvent(
                MMTIMER_TEST_DELAY1,
                0,
                (LPTIMECALLBACK)MmTimerCallbackProc,
                (DWORD)&Counter,
                TIME_ONESHOT | TIME_CALLBACK_FUNCTION
                );
        if ( mmr == NULL ) {
            LOG_MSG_FAIL( "timeSetEvent failed" );
        } else {
            Sleep( MMTIMER_TEST_DELAY1 * 5 );
            LOG_PASS_FAIL( Counter == 1 );
        }
    }
    END_VARIATION();

    BEGIN_VARIATION( "periodic callback" )
    {
        Counter = 0;
        mmr = timeSetEvent(
                MMTIMER_TEST_DELAY1,
                0,
                (LPTIMECALLBACK)MmTimerCallbackProc,
                (DWORD)&Counter,
                TIME_PERIODIC | TIME_CALLBACK_FUNCTION
                );
        if ( mmr == NULL ) {
            LOG_MSG_FAIL( "timeSetEvent failed" );
        } else {
            Sleep( MMTIMER_TEST_DELAY1 * 5 );
            LOG_PASS_FAIL( Counter >= 1 );
            timeKillEvent( mmr );
        }
    }
    END_VARIATION();

    EventHandle = CreateEvent( 0, TRUE, FALSE, 0 );
    if ( !EventHandle ) {
        LOG_MSG_BLOCK( "Couldn't create event" );
        return;
    }

    BEGIN_VARIATION( "one-shot event" )
    {
        mmr = timeSetEvent(
                MMTIMER_TEST_DELAY1,
                0,
                (LPTIMECALLBACK)EventHandle,
                (DWORD)&Counter,
                TIME_ONESHOT | TIME_CALLBACK_EVENT_SET
                );
        if ( mmr == NULL ) {
            LOG_MSG_FAIL( "timeSetEvent failed" );
        } else {
            Wait = WaitForSingleObject( EventHandle, MMTIMER_TEST_DELAY1 * 2 );
            switch ( Wait ) {
            case WAIT_OBJECT_0:
                LOG_PASS();
                break;
            default:
                LOG_FAIL();
            }
        }
    }
    END_VARIATION();

    BEGIN_VARIATION( "periodic event" )
    {
        Counter = 0;
        mmr = timeSetEvent(
                MMTIMER_TEST_DELAY1,
                0,
                (LPTIMECALLBACK)EventHandle,
                (DWORD)&Counter,
                TIME_PERIODIC | TIME_CALLBACK_EVENT_SET
                );
        if ( mmr == NULL ) {
            LOG_MSG_FAIL( "timeSetEvent failed" );
        } else {
            for (;;) {
                Wait = WaitForSingleObject( EventHandle, MMTIMER_TEST_DELAY1 * 2 );
                if ( Wait == WAIT_OBJECT_0 ) {
                    if ( InterlockedIncrement(&Counter) > 5 ) {
                        break;
                    }
                } else {
                    break;
                }
            }
            timeKillEvent( mmr );
            LOG_PASS_FAIL( Counter > 1 );
        }
    }
    END_VARIATION();

    CloseHandle( EventHandle );

    BEGIN_VARIATION( "stress" )
    {
        MMRESULT * TimerIDs = (MMRESULT*)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            sizeof(MMRESULT) * MAX_TIMER_TO_BE_TESTED
                                            );
        if ( !TimerIDs ) {
            LOG_MSG_BLOCK( "cound't allocate memory" );
        } else {
            __try {
                for ( Counter=0; Counter<MAX_TIMER_TO_BE_TESTED; Counter++ ) {
                    mmr = timeSetEvent(
                            MMTIMER_TEST_DELAY2,
                            0,
                            (LPTIMECALLBACK)MmTimerCallbackProc,
                            (DWORD)NULL,
                            TIME_PERIODIC | TIME_CALLBACK_FUNCTION
                            );
                    TimerIDs[Counter] = mmr;
                }
                for ( Counter=0; Counter<MAX_TIMER_TO_BE_TESTED; Counter++ ) {
                    if ( TimerIDs[Counter] ) {
                        timeKillEvent( TimerIDs[Counter] );
                    }
                }
                LOG_PASS();
            } __finally {
                HeapFree( GetProcessHeap(), 0, TimerIDs );
            }
        }
    }
    END_VARIATION();

    xSetFunctionName( LogHandle, "timeKillEvent" );

    BEGIN_VARIATION( "Valid ID" )
    {
        mmr = timeSetEvent(
                MMTIMER_TEST_DELAY1,
                0,
                (LPTIMECALLBACK)MmTimerCallbackProc,
                (DWORD)NULL,
                TIME_ONESHOT | TIME_CALLBACK_FUNCTION
                );
        if ( mmr == NULL) {
            LOG_MSG_BLOCK( "timeSetEvent failed" );
        } else {
            LOG_PASS_FAIL( timeKillEvent(mmr) == TIMERR_NOERROR );
        }
    }
    END_VARIATION();

    BEGIN_VARIATION( "Invalid ID" )
    {
        LOG_PASS_FAIL( timeKillEvent(~0UL) != TIMERR_NOERROR );
    }
    END_VARIATION();
}


VOID
WINAPI
MmTimerStartTest(
    HANDLE LogHandle
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    KdPrint(( "MMTIMER: StartTest\n" ));
    xSetComponent( LogHandle, "Win32", "mmtimer" );

    MmTimerGetTimeTest( LogHandle );
    MmTimerEventTest( LogHandle );
}


VOID
WINAPI
MmTimerEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    KdPrint(( "MMTIMER: EndTest\n" ));
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( mmtimer )
#pragma data_seg()

BEGIN_EXPORT_TABLE( mmtimer )
    EXPORT_TABLE_ENTRY( "StartTest", MmTimerStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MmTimerEndTest )
END_EXPORT_TABLE( mmtimer )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\win32\fileio\utils.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif

namespace FILEIO {

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    char* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a char string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
char* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((ULONG_PTR)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (char*)str;
    }


/*****************************************************************************

Routine Description:

    Unicode2AnsiHack

    In-place Pseudo Unicode to Ansi (wide char to char) conversion.

Arguments:

    IN unsigned short* str - wide char string to convert to char string

Return Value:

    char* - pointer to ANSI string

*****************************************************************************/
char* Unicode2AnsiHack(unsigned short *str)
    {
    if(!str) return NULL;
    char *str2 = (char*)str;

    size_t len = wcslen(str)+1;
    for(size_t i=0; i<len; i++)
        {
        str2[i] = str2[i*2];
        }

    return (char*)str;
    }

/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    char *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
bool FileExists(const char *filename)
    {
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    bool retval = false;

    hFind = FindFirstFile(filename, &FindFileData);

    if(hFind != INVALID_HANDLE_VALUE)
        {
        retval = true;
        }
    FindClose(hFind);

    return retval;
    }




/*

Routine Description:

    Creates a new file and fills it with x bytes of garbage

Arguments:

    char *filename - the name of the file to create
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD CreateFilledFile(const char *filename, DWORD size /*=16384*/)
    {
    HANDLE file = CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    size = FillFile(file, size);

    CloseHandle(file);

    return size;
    return size;
    }




/*

Routine Description:

    Fills an opened file with x bytes of garbage

Arguments:

    HANDLE hFile - handle to opened file
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD FillFile(HANDLE hFile, DWORD size)
    {
    char *error = NULL;
    char w = 'X';
    DWORD wsize = sizeof(w);
    DWORD errCode = 0;

    do
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            error = "unable to create/open file";
            errCode = GetLastError();
            break;
            }

        if(size == 0) break;

        if(SetFilePointer(hFile, size-1, NULL, FILE_BEGIN) != size-1)
            {
            error = "unable to size file";
            errCode = GetLastError();
            break;
            }

        if(WriteFile(hFile, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = "unable to write last byte";
            errCode = GetLastError();
            break;
            }
        } while(0);

    FlushFileBuffers(hFile);

    if(error)
        {
        DebugPrint("FILEIO: FillFile(%ld) - %s (ec: %d)\n", size, error, errCode);
        size = 0;
        }

    return size;
    }

/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpen(const char *filename)
    {
    return CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }



/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpenRW(const char *filename)
    {
    return CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }




/*

Routine Description:

    Generates a FILETIME structure from the date components by calling 
    SystemTimeToFileTime

Arguments:

    LPFILETIME fileTime - pointer to the FILETIME struct to populate with the date
    WORD year
    WORD month
    WORD day
    WORD hour
    WORD min
    WORD sec
    WORD msec

Return Value:

    BOOL - returns the result from SystemTimeToFileTime

*/
BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec)
    {
    SYSTEMTIME sysTime;

    sysTime.wYear = year;
    sysTime.wMonth = month;
    sysTime.wDay = day;
    sysTime.wHour = hour;
    sysTime.wMinute = min;
    sysTime.wSecond = sec;
    sysTime.wMilliseconds = msec;

    return SystemTimeToFileTime(&sysTime, fileTime);
    }

/*

Routine Description:


Arguments:

    drive - Drive to fill up, it should be in the form 
        C:\
        D:\
        etc.
    lpFile - This function will populate buffer with the name of the file created

Return Value:

    DWORD return code from GetLastError in the event of a problem

*/
DWORD FillHDPartition(const char *drive, char *lpFile)
    {
    if(!drive || !lpFile) return ERROR_INVALID_PARAMETER;

    DWORD error = 0;
    char w = 'X';
    DWORD wsize = sizeof(w);
    LARGE_INTEGER distance;
    LARGE_INTEGER size;
    ULARGE_INTEGER available;
    ULARGE_INTEGER total;
    ULARGE_INTEGER free;

    DebugPrint("FILEIO: Filling HD Partition: %s (this takes a long time)...\n", drive);

    sprintf(lpFile, "%sFHD.dmp", drive);

    HANDLE file = CreateFile(lpFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
    if(file == INVALID_HANDLE_VALUE)
        {
        return GetLastError();
        }

    // Get the disk space free
    GetDiskFreeSpaceEx(drive, &available, &total, &free);
    distance.QuadPart = (__int64)available.QuadPart - 256;
    size.QuadPart = 0;

    // Do a test write
    if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
        {
        error = GetLastError();
        CloseHandle(file);
        return error;
        }

    // write as big as a file as possible
    do
        {
        distance.QuadPart -= 256;
        if(distance.QuadPart < 0) break;

        if(SetFilePointerEx(file, distance, &size, FILE_BEGIN) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("SetFilePointerEx (ec: %lu)\n", error);
            }
        else if(size.QuadPart != distance.QuadPart)
            {
            error = 99;
            //DebugPrint("SetFilePointerEx size != dist\n");
            }
        else if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("WriteFile (ec: %lu)\n", error);
            }
        else
            {
            error = 0;
            }

        } while(error);

    // clean up
    if(FlushFileBuffers(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("FlushFileBuffers (ec: %lu)\n", error);
        }
    if(CloseHandle(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("CloseHandle (ec: %lu)\n", error);
        }

    DebugPrint("FILEIO: Filled  HD Partition. %s(%I64d)\n", lpFile, size.QuadPart);

    return error;
    }

/*

Routine Description:

    Writes system resource usage information to the specified log file 
    and/or to the debugger.

    Be sure to include extern "C" { "ntos.h" } to use MmQueryStatistics

    MM_STATISTICS:
        ULONG TotalPhysicalPages;
        ULONG AvailablePages;
        ULONG VirtualMemoryBytesCommitted;
        ULONG VirtualMemoryBytesReserved;
        ULONG CachePagesCommitted;
        ULONG PoolPagesCommitted;
        ULONG StackPagesCommitted;
        ULONG ImagePagesCommitted;

Arguments:

    HANDLE hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    bool debugger - true sends memory data to the debugger

Return Value:

    None

*/
extern "C" void FlushDiskCache(void);

void LogResourceStatus(HANDLE hLog, bool debugger)
    {
    const DWORD pageSize = 4096;
    MM_STATISTICS mmStats;
    PS_STATISTICS psStats;

    // initialize the stat info
    memset(&mmStats, 0, sizeof(MM_STATISTICS));
    mmStats.Length = sizeof(MM_STATISTICS);
    memset(&psStats, 0, sizeof(PS_STATISTICS));
    psStats.Length = sizeof(PS_STATISTICS);

    FlushDiskCache();

    // gather all the data
    MmQueryStatistics(&mmStats);
    PsQueryStatistics(&psStats);

    // display/write the data
    if(hLog)
        {
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        xLog(hLog, XLL_INFO, "   Total:     %lu", mmStats.TotalPhysicalPages*pageSize);
        xLog(hLog, XLL_INFO, "   Available: %lu", mmStats.AvailablePages*pageSize);
        xLog(hLog, XLL_INFO, "   Cache:     %lu", mmStats.CachePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Pool:      %lu", mmStats.PoolPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Stack:     %lu", mmStats.StackPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Image:     %lu", mmStats.ImagePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Handles:   %lu", psStats.HandleCount);
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        }
    if(debugger)
        {
        DebugPrint("MEM: Available=%lu, Cache=%lu, Pool=%lu, Stack=%lu, Image=%lu, Handles=%lu\n", mmStats.AvailablePages*pageSize, mmStats.CachePagesCommitted*pageSize, mmStats.PoolPagesCommitted*pageSize, mmStats.StackPagesCommitted*pageSize, mmStats.ImagePagesCommitted*pageSize, psStats.HandleCount);
        }
    }

void FlushVolume(char *volume)
    {
    HANDLE hFile = CreateFile(volume, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        DebugPrint("MEM: FlushError: %lu, 0x%x\n", GetLastError(), GetLastError());
    FlushFileBuffers(hFile);
    CloseHandle(hFile);
    }

} // namespace FILEIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\setnickname.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SetNickname.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "Nickname.h"


/*

Routine Description:

    Tests the XSetNickname API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    DWORD - 

*/
DWORD Nickname::XSetNickname_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL
    XSetNicknameW(
        IN LPCWSTR lpNickname,
        IN BOOL fPreserveCase)
    */
    xSetFunctionName(hLog, "XSetNickname");

    WCHAR *buffer = new WCHAR[1024];
    unsigned i;

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("NULL")
        {
        if(XSetNickname(NULL, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
        */
    TESTCASE("Empty")
        {
        WCHAR *nick = L"";
        if(XSetNickname(nick, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Space")
        {
        WCHAR *nick = L" ";
        if(XSetNickname(nick, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("1 char")
        {
        WCHAR *nick = L"x";
        if(XSetNickname(nick, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("2 chars")
        {
        WCHAR *nick = L"ab";
        if(XSetNickname(nick, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("3 chars")
        {
        WCHAR *nick = L"JGP";
        if(XSetNickname(nick, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("characters")
        {
        WCHAR *nick = L"abcdefghijklmnopqrstuvwxyz";
        if(XSetNickname(nick, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("numbers")
        {
        WCHAR *nick = L"1234567890";
        if(XSetNickname(nick, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("jpoley")
        {
        WCHAR *nick = L"jpoley";
        if(XSetNickname(nick, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("HdW")
        {
        WCHAR *nick = L"HdW";
        if(XSetNickname(nick, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(nick)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("max-2 chars")
        {
        swprintf(buffer, L"%*ws", MAX_NICKNAME-2, L"");
        if(XSetNickname(buffer, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(buffer)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("max-1 chars")
        {
        swprintf(buffer, L"%*ws", MAX_NICKNAME-1, L"");
        if(XSetNickname(buffer, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(!CompareFirstNickname(buffer)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("max chars")
        {
        swprintf(buffer, L"%*ws", MAX_NICKNAME, L"");
        if(XSetNickname(buffer, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(CompareFirstNickname(buffer)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("max+1 chars")
        {
        swprintf(buffer, L"%*ws", MAX_NICKNAME+1, L"");
        if(XSetNickname(buffer, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(CompareFirstNickname(buffer)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    TESTCASE("max+2 chars")
        {
        swprintf(buffer, L"%*ws", MAX_NICKNAME+2, L"");
        if(XSetNickname(buffer, TRUE) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        if(CompareFirstNickname(buffer)) TESTFAIL(hLog, "Compare failed", GetLastError());
        } ENDTESTCASE;
    */

    //////////////////////////////////////////////////////////////////////////
    // Case sensitivity tests
    //////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////
    // Crazy Names
    //////////////////////////////////////////////////////////////////////////
    for(i=0; i<ARRAYSIZE(crazyNames); i++)
        {
        TESTCASE(crazyNames[i])
            {
            if(XSetNickname(crazyNames[i], TRUE) == TRUE)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;
        }


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("NICKNAME(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 10000;
        unsigned failures = 0;
        for(i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }

            swprintf(buffer, L"nic%u", i);
            if(XSetNickname(buffer, TRUE) != TRUE)
                {
                ++failures;
                }
            }
        if(failures)
            TESTFAIL(hLog, "Mini stress failures: %u", failures);
        else
            TESTPASS(hLog, "Mini stress failures: %u", failures);
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////


    delete[] buffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\utils.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif

namespace Nickname {

bool CompareFirstNickname(WCHAR *nickname)
    {
    const unsigned MAXSIZE = MAX_NICKNAME * 2;
    WCHAR *buffer = new WCHAR[MAXSIZE];

    HANDLE hFind = XFindFirstNickname(FALSE, buffer, MAX_NICKNAME);
    if(hFind == INVALID_HANDLE_VALUE)
        {
        delete[] buffer;
        return false;
        }

    XFindClose(hFind);

    if(wcscmp(buffer, nickname) == 0) 
        {
        delete[] buffer;
        return true;
        }

    delete[] buffer;
    return false;
    }

bool RemoveNicknameFile(void)
    {
    OBJECT_STRING nicknameFile;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS status;
    RtlInitObjectString(&nicknameFile, "\\Device\\Harddisk0\\partition1\\UDATA\\NICKNAME.XBN");
    InitializeObjectAttributes(&Obja, &nicknameFile, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtDeleteFile(&Obja);
    if(!NT_SUCCESS(status)) 
        {
        SetLastError(RtlNtStatusToDosError(status));
        return false;
        }

    return true;
    }

} // namespace Nickname
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\nickname\utils.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

namespace Nickname
    {
    bool CompareFirstNickname(WCHAR *nickname);
    bool RemoveNicknameFile(void);
    } // namespace Nickname
#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\commontest.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         L"Z"
#define TITLE_DRIVE         L"T"
#define USER_DRIVE          L"U"
#define BASE_DRIVE          CACHE_DRIVE

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    xStartVariation(hLog, variant);
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    xStartVariation(hLog, aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

#define ALLCHARS L"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f" \
    L"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

// common numbers
static DWORD dwBogus = 0xF000BAAA;
static ULARGE_INTEGER ulBogus = { 0xF000BAAA, 0xF000BAAA };

// common HANDLE parameters
static HANDLE hNull = NULL;
static HANDLE hBogus = (void*)0xF000BAAA;

// common string parameters
static LPCTSTR lpNull = NULL;
static LPCTSTR lpEmpty = L"";
static LPCTSTR lpSpace = L" ";
static LPCTSTR lpBogus = (const unsigned short*)0xF000BAAA;


// different names
static WCHAR *crazyNames[] = {
    L")#+l+RI+Td<\x12>",
    L"~`!@#$%^&*)-=_+[{\\|';:\",./?>",
    L"*",
    L"?",
    L"abc?",
    L"abc>def",
    L"abc<def",
    L"abc|def",
    L"abc:def",
    L"abc\"def",
    L">",
    L"<",
    L":",
    L"|",
    L"\"",
    L"..\\abcdef",
    L".\\..\\abcdef",
    L"abc" BASE_DRIVE L":\\def",
    L"new\nline",
    L"newline\n",
    L"Carriage\rreturn",
    L"Carriagereturn\r",
    L"\ttab",
    L"tab\t",
    L"\abell",
    L"bell\a",
    L"::\\abc",
    L"abc",
    L".",
    L"..",
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\savegame\savegame.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    savegame.h

Abstract:

    support for savegame.c
    
Author:

    John Daly (johndaly) 22-June-2000

Revision History:

--*/

#ifndef _SAVEGAME_
#define _SAVEGAME_

//
// includes
//

#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <xlog.h>
#include <xtestlib.h>

namespace SaveGameNameSpace {

//
// list of all UData drives / MUs (U + MUs)
//

char UDataDrives[27] = {0};

//
// list of all found drives
//

char Drives[27] = {0};

//
// global data
//

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

LONG SaveGameThreadID = 0;

//
// Heap handle from HeapCreate
//

HANDLE HeapHandle;

WCHAR wcDbgMsgBuffer[500] = {0};
PVOID FileDataBuffer;
#define FILE_DATA_SIZE 0x4000
long holdrand;
int MaxFiles;

char DeviceLetters[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
char MULetters[] = {"FGHIJKLM"};

//
// RIP stuff
//

BYTE Aspace[5] = {0};
BYTE Bspace[4] = {0};
BYTE *Address;
BYTE *jump_target = (BYTE *)Bspace;

DWORD RIPSaveRegsEBX;
DWORD RIPSaveRegsESI;
DWORD RIPSaveRegsEDI;

#if DBG_RIP
    #define PreRIPSaveRegs              \
        _asm mov RIPSaveRegsEBX, ebx    \
        _asm mov RIPSaveRegsESI, esi    \
        _asm mov RIPSaveRegsEDI, edi

    #define RIPRestoreSaveRegs             \
        _asm mov ebx, RIPSaveRegsEBX       \
        _asm mov esi, RIPSaveRegsESI       \
        _asm mov edi, RIPSaveRegsEDI
#else
    #define PreRIPSaveRegs
    #define RIPRestoreSaveRegs
#endif

//
// macros
//

//
// macro to return the number of elements in an array
//

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))

//
// defines
//

XDEVICE_PREALLOC_TYPE deviceTypes[] = 
{
    {XDEVICE_TYPE_GAMEPAD,4},
    {XDEVICE_TYPE_MEMORY_UNIT,8},
    {XDEVICE_TYPE_VOICE_MICROPHONE,4},
    {XDEVICE_TYPE_VOICE_HEADPHONE,4}
};
    
}   //SaveGameNameSpace

//
// function declarations
//

VOID
WINAPI
test_XSignature(
    HANDLE LogHandle
    );

VOID
WINAPI
test_XCreateSaveGame(
    HANDLE LogHandle,
    char uDrive
    );

VOID
WINAPI
test_XDeleteSaveGame(
    HANDLE LogHandle,
    char uDrive
    );

VOID
WINAPI
test_XFindFirstSaveGame(
    HANDLE LogHandle,
    char uDrive
    );

VOID
WINAPI
test_XFindNextSaveGame(
    HANDLE LogHandle,
    char uDrive
    );

VOID
WINAPI
test_XFindClose(
    HANDLE LogHandle,
    char uDrive
    );

VOID
WINAPI
StartTest(
    HANDLE LogHandle
    );

VOID
WINAPI
EndTest(
    VOID
    );

BOOL
WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       fdwReason,
    LPVOID      lpReserved
    );

BOOL
WINAPI
DeleteAllSavedGames(
    char uDrive
    );

BOOL
WINAPI
SaveAGame(
    PCHAR SavePath,
    PCHAR BaseFileName,
    PCHAR FileNameExt,
    DWORD FileSize,
    DWORD FileCount
    );

PWCHAR
WINAPI
AppendRandUnicodeChar(
    PWCHAR pwStr
    );

void 
__cdecl 
xtsrand(
    unsigned int seed
    );

int 
__cdecl 
xtrand (
    void
    );

int 
Eval_Exception ( 
    PEXCEPTION_POINTERS pExceptionPointers, 
    DWORD ArgBytes
    );

void
DummyCode(
    void
    );

void
MountMUs(
    void
    );


#endif // _SAVEGAME_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\reboot\precomp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    precomp.h

Abstract:

    This program contains routines to test reboot API

--*/

#include <ntos.h>
#include <ldr.h>
#include <xtl.h>
#include <xlog.h>
#include <xtestlib.h>
#include <testutil.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\savegame\savegame.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    savegame.c

Abstract:

    test XBox saved game related APIs

Author:

    John Daly (johndaly) 22-June-2000

Environment:

    X-Box

Notes:

    savegame - test these API's
        XCreateSaveGame()
        XDeleteSaveGame()
        XFindFirstSaveGame()
        XFindNextSaveGame()
        XFindClose()

        I could have done all kinds of fancy wrappers, etc to make this a
        bit smaller, but this style makes things very easy to follow

Revision History:

    22-June-2000     johndaly
    created

Current Status:

    APIs not really final yet!!!
    we only go to 1 disk here, we'll have to support going to all save devices
    in the final version of this test, and maybe the net team will want to port
    it to online storage

    Also, add some simple multithreaded scenarios when time available

--*/

//
// includes
//

#include "savegame.h"

using namespace SaveGameNameSpace;

VOID
WINAPI
test_XSignature(
    HANDLE LogHandle
    )
/*++

Routine Description:

    test Signature functions
    XCalculateSignatureBegin()
    XCalculateSignatureUpdate()
    XCalculateSignatureEnd()

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    char uDrive - drive to use

Return Value:

    None

Notes:


--*/
{
    LONG ID;
    int x;
    DWORD y;
    DWORD BufferSize;
    DWORD RetVal;
    DWORD LastError;
    char *tmpPtr;
    HANDLE hSignatureIn;
    HANDLE hSignatureOut;
    XCALCSIG_SIGNATURE SignatureIn;
    XCALCSIG_SIGNATURE SignatureOut;
    BYTE *TestBuffer;
    DWORD MAX_ITER = 100;

    //
    // positive test cases
    //

    xSetFunctionName(LogHandle, "test_XSignature");
    xStartVariation(LogHandle, "goodparam1");

    //
    // seed random number generator
    // may want to conside saving the seed sometime
    //

    xtsrand((unsigned)GetTickCount());

    //
    // test #1
    // 2-200k, sign and check
    // basically, do I always get the same result?
    // swap key types
    // we re-use the same buffer because we never change it
    //

    //
    // make a buffer and fill it with data
    // note - we don't use the end of the buffer, it is a spare block for buffer overrun testing
    //

    BufferSize = MAX_ITER * 2048;
    TestBuffer = (BYTE *)HeapAlloc(SaveGameNameSpace::HeapHandle, 0, BufferSize);
    if (NULL == TestBuffer) {
        OutputDebugString(L"Out of memory!");
        xEndVariation( LogHandle );
        return;
    }
    tmpPtr = (char *)TestBuffer;
    for (y = 1; y < BufferSize; y++) {
        *tmpPtr = (char)(y % 16);
        ++tmpPtr;
    }

    for (x = 1; x < (int)MAX_ITER; x++) {

        BufferSize = x * 2048;

        //
        // sign it (alternate key types 0 and 1)
        //

        hSignatureIn = XCalculateSignatureBegin(x%2);
        xLog(LogHandle,
             (INVALID_HANDLE_VALUE == hSignatureIn) ? XLL_FAIL : XLL_PASS,
             "XCalculateSignatureBegin(%d):", x%2);

        RetVal = XCalculateSignatureUpdate(hSignatureIn, TestBuffer, BufferSize);
        xLog(LogHandle,
             (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
             "XCalculateSignatureUpdate:hSignatureIn:0x%8.8x buffersize:0x%8.8x",
             hSignatureIn,
             BufferSize);

        if (ERROR_SUCCESS != XCalculateSignatureEnd(hSignatureIn, &SignatureIn)) {
            LastError = GetLastError();
            xLog(LogHandle,
                 XLL_FAIL,
                 "XCalculateSignatureEnd:hSignatureIn:0x%8.8x buffersize:0x%8.8x GetLastError:0x%8.8x",
                 hSignatureIn,
                 BufferSize,
                 LastError);
        } else {
            xLog(LogHandle,
                 XLL_PASS,
                 "XCalculateSignatureEnd()");
        }

        //
        // do it again
        //

        //
        // look for buffer overrun
        //
        
        tmpPtr = (char *)TestBuffer + BufferSize;
        ++*tmpPtr;

        hSignatureOut = XCalculateSignatureBegin(x%2);
        xLog(LogHandle,
             (INVALID_HANDLE_VALUE == hSignatureOut) ? XLL_FAIL : XLL_PASS,
             "XCalculateSignatureBegin(%d):", x%2);

        RetVal = XCalculateSignatureUpdate(hSignatureOut, TestBuffer, BufferSize);
        xLog(LogHandle,
             (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
             "XCalculateSignatureUpdate:hSignatureOut:0x%8.8x buffersize:0x%8.8x",
             hSignatureOut,
             BufferSize);

        if (ERROR_SUCCESS != XCalculateSignatureEnd(hSignatureOut, &SignatureOut)) {
            LastError = GetLastError();
            xLog(LogHandle,
                 XLL_FAIL,
                 "XCalculateSignatureEnd:hSignatureOut:0x%8.8x buffersize:0x%8.8x GetLastError:0x%8.8x",
                 hSignatureOut,
                 BufferSize,
                 LastError);
        } else {
            xLog(LogHandle,
                 XLL_PASS,
                 "XCalculateSignatureEnd()");
        }

        //
        // fix buffer
        //
        
        --*tmpPtr;

        //
        // Validate the signature
        //

        if (0 != memcmp(&SignatureIn, &SignatureOut, sizeof(XCALCSIG_SIGNATURE))) {
            xLog(LogHandle,
                 XLL_FAIL,
                 "signature Mismatch!:\nSignatureIn:%*.*c \nSignatureOut:%*.*c",
                 XCALCSIG_SIGNATURE_SIZE,
                 XCALCSIG_SIGNATURE_SIZE,
                 SignatureIn,
                 XCALCSIG_SIGNATURE_SIZE,
                 XCALCSIG_SIGNATURE_SIZE,
                 SignatureOut);
        } else {
            xLog(LogHandle,
                 XLL_PASS,
                 "signature Match");
        }
    }

    xEndVariation(LogHandle);

    //
    // negative test cases
    //

    xSetFunctionName(LogHandle, "test_XSignature");
    xStartVariation(LogHandle, "badparam1");

    //
    // randomly corrupt buffer memory, make sure we fail
    // 

    for (x = 1; x < (int)MAX_ITER; x++) {

        BufferSize = x * 2048;

        //
        // sign it (alternate key types 0 and 1)
        //

        hSignatureIn = XCalculateSignatureBegin(x%2);
        xLog(LogHandle,
             (INVALID_HANDLE_VALUE == hSignatureIn) ? XLL_FAIL : XLL_PASS,
             "XCalculateSignatureBegin(%d):", x%2);

        RetVal = XCalculateSignatureUpdate(hSignatureIn, TestBuffer, BufferSize);
        xLog(LogHandle,
             (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
             "XCalculateSignatureUpdate:hSignatureIn:0x%8.8x buffersize:0x%8.8x",
             hSignatureIn,
             BufferSize);

        if (ERROR_SUCCESS != XCalculateSignatureEnd(hSignatureIn, &SignatureIn)) {
            LastError = GetLastError();
            xLog(LogHandle,
                 XLL_FAIL,
                 "XCalculateSignatureEnd:hSignatureIn:0x%8.8x buffersize:0x%8.8x GetLastError:0x%8.8x",
                 hSignatureIn,
                 BufferSize,
                 LastError);
        } else {
            xLog(LogHandle,
                 XLL_PASS,
                 "XCalculateSignatureEnd()");
        }

        //
        // do it again, but change a random place in the buffer
        // make sure this works when changing the first byte in the buffer
        // make sure this works when changing the last byte in the buffer
        //

        switch (x) {
            // make sure this works when changing the first byte in the buffer
            case 1:
                tmpPtr = (char *)TestBuffer;
                break;

                // make sure this works when changing the last byte in the buffer
            case 2:
                tmpPtr = (char *)TestBuffer + BufferSize - 1;
                break;

                // change a random place in the buffer
            default:
                tmpPtr = (char *)TestBuffer + xtrand()%(BufferSize - 1);
                break;
        }
        ++*tmpPtr;

        hSignatureOut = XCalculateSignatureBegin(x%2);
        xLog(LogHandle,
             (INVALID_HANDLE_VALUE == hSignatureOut) ? XLL_FAIL : XLL_PASS,
             "XCalculateSignatureBegin(%d):", x%2);

        RetVal = XCalculateSignatureUpdate(hSignatureOut, TestBuffer, BufferSize);
        xLog(LogHandle,
             (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
             "XCalculateSignatureUpdate:hSignatureOut:0x%8.8x buffersize:0x%8.8x",
             hSignatureOut,
             BufferSize);

        if (ERROR_SUCCESS != XCalculateSignatureEnd(hSignatureOut, &SignatureOut)) {
            LastError = GetLastError();
            xLog(LogHandle,
                 XLL_FAIL,
                 "XCalculateSignatureEnd:hSignatureOut:0x%8.8x buffersize:0x%8.8x GetLastError:0x%8.8x",
                 hSignatureOut,
                 BufferSize,
                 LastError);
        } else {
            xLog(LogHandle,
                 XLL_PASS,
                 "XCalculateSignatureEnd()");
        }

        //
        // repair the buffer
        //

        --*tmpPtr;

        //
        // Validate the signature - should be different
        //

        if (0 == memcmp(&SignatureIn, &SignatureOut, sizeof(XCALCSIG_SIGNATURE))) {
            xLog(LogHandle,
                 XLL_FAIL,
                 "signature Match!:\nSignatureIn:%*.*x \nSignatureOut:%*.*x",
                 XCALCSIG_SIGNATURE_SIZE,
                 XCALCSIG_SIGNATURE_SIZE,
                 SignatureIn,
                 XCALCSIG_SIGNATURE_SIZE,
                 XCALCSIG_SIGNATURE_SIZE,
                 SignatureOut);
        } else {
            xLog(LogHandle,
                 XLL_PASS,
                 "signature Mismatch (on purpose...)");
        }
    }

    xEndVariation(LogHandle);

    //
    // free the buffer
    //

    HeapFree(SaveGameNameSpace::HeapHandle, 0, TestBuffer);

    return;
}

VOID
WINAPI
test_XCreateSaveGame(
    HANDLE LogHandle,
    char uDrive
    )
/*++

Routine Description:

    test XCreateSaveGame
    - test with 0 saved games
    - 1 saved game
    - until the disk runs out of space, and then some
    - bad params where they make sense
    - lpRootPathName 0...N long w/ UNICODE chars
    - lpSaveGameName 0...N long w/ UNICODE chars
    - lpIdentity 0...N long w/ UNICODE chars
    - 0...5+ identities
    - lpPathBuffer normal, NULL, too short
    - dwCreationDisposition = CREATE_NEW
    - dwCreationDisposition = OPEN_ALWAYS
    - dwCreationDisposition = OPEN_EXISTING

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    char uDrive - drive to use

Return Value:

    None

Notes:

    these APIs are preliminary
    for a 'saved game' we'll use files that vary in length from 10k to 1mb

--*/
{
    CHAR SaveRoot[] = {"U:\\"};
    WCHAR gamename[_MAX_DIR + 2] = {0};
    CHAR PathBuffer[_MAX_DIR + 2] = {0};
    DWORD RetVal = 0;
    DWORD x = 0;
    PWCHAR pwTestBuffer = NULL;
    PWCHAR pwTestBuffer1 = NULL;
    PWCHAR pwName;
    DWORD dwLoopCount;
    BOOL Flag;

    //
    // point to the correct drive
    //

    SaveRoot[0] = uDrive;
    
    //
    // positive test cases
    //

    xSetFunctionName( LogHandle, "XCreateSaveGame" );
    xStartVariation( LogHandle, "goodparam1" );

    //
    // #1
    // test with 0 saved games
    // there should be 0 saved games when we get here
    //

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game1",
                             OPEN_ALWAYS,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

    xLog(LogHandle,
         (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
         "XCreateSaveGame(1): path = %s (Error=%d)",
         PathBuffer,
         RetVal);

    RetVal = SaveAGame(PathBuffer,
                       "test1",
                       "sav",
                       10000,
                       1);

    xLog(LogHandle,
         (RetVal) ? XLL_PASS : XLL_FAIL,
         "test_XCreateSaveGame(#1): path = %s",
         PathBuffer);

    //
    // #2
    // 1 saved game
    // there will be one if the first test succeeded
    //

    PathBuffer[0] = 0;

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game2",
                             OPEN_ALWAYS,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

    xLog(LogHandle,
         (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
         "XCreateSaveGame(2): path = %s (Error=%d)",
         PathBuffer,
         RetVal);

    RetVal = SaveAGame(PathBuffer,
                       "test2",
                       "sav",
                       10000,
                       1);

    xLog(LogHandle,
         (RetVal) ? XLL_PASS : XLL_FAIL,
         "test_XCreateSaveGame(#2): path = %s",
         PathBuffer);

    //
    // #3
    // lpRootPathName 0...N long w/ UNICODE chars
    // this will fail early on
    // first pass should succeed, the rest should fail
    // start with a valid path and append a lot of junk and call
    //
    // this case is now invalid, since we only allow the root in the path name
    // so chop it out
    //

#if 0

#define TEST_BUFFER_LEN 1000

    Flag = TRUE;
    pwTestBuffer = (PWCHAR)HeapAlloc(SaveGameNameSpace::HeapHandle, HEAP_ZERO_MEMORY, TEST_BUFFER_LEN * 2);
    if (NULL == pwTestBuffer) {
        xLog(LogHandle,XLL_BLOCK,"Out of memory!");
        return;
    }
    wcscpy(pwTestBuffer, SaveRoot);
    pwTestBuffer1 = (PWCHAR)((size_t)pwTestBuffer + (2 * wcslen(pwTestBuffer)));

#if DBG_RIP
    dwLoopCount = 1;
#else
    dwLoopCount = TEST_BUFFER_LEN - (pwTestBuffer1 - pwTestBuffer);
#endif

    for (x = 0; x < dwLoopCount; x++) {
        swprintf(gamename,L"GAME#%x", x);

        PreRIPSaveRegs
        RetVal = XCreateSaveGame(pwTestBuffer,
                                 gamename,
                                 OPEN_ALWAYS,
                                 0,
                                 PathBuffer,
                                 sizeof(PathBuffer));

        if (ERROR_SUCCESS == RetVal && 0 != x) {
            swprintf(wcDbgMsgBuffer,
                     L"Savegame : XCreateSaveGame unexpectedly succeeded: %s\n",
                     PathBuffer);
            OutputDebugString(wcDbgMsgBuffer);
            Flag = FALSE;
        }

        //
        // append junk to end of pwTestBuffer
        //

        pwTestBuffer1 = AppendRandUnicodeChar(pwTestBuffer1);

    }
    xLog(LogHandle, (Flag) ? XLL_PASS : XLL_FAIL, "test_XCreateSaveGame(#3)");

    HeapFree(SaveGameNameSpace::HeapHandle, 0, pwTestBuffer);
#endif // if 0

    //
    // #4
    // lpSaveGameName 0...N long w/ UNICODE chars
    //

#define TEST_BUFFER_LEN 1000

    Flag = TRUE;
    pwTestBuffer = (PWCHAR)HeapAlloc(SaveGameNameSpace::HeapHandle, HEAP_ZERO_MEMORY, TEST_BUFFER_LEN * 2);
    if (NULL == pwTestBuffer) {
        xLog(LogHandle,XLL_BLOCK,"Out of memory!");
        return;
        }
    wcscpy(pwTestBuffer, L"GAMEZ");
    pwTestBuffer1 = (PWCHAR)((size_t)pwTestBuffer + (2 * wcslen(pwTestBuffer)));

#if DBG_RIP
    dwLoopCount = TEST_BUFFER_LEN - (pwTestBuffer1 - pwTestBuffer);
#else
    dwLoopCount = MAX_GAMENAME - (pwTestBuffer1 - pwTestBuffer);
#endif

    for (x = 0; x < dwLoopCount; x++) {
        PreRIPSaveRegs
        RetVal = XCreateSaveGame(SaveRoot,
                                 pwTestBuffer,
                                 OPEN_ALWAYS,
                                 0,
                                 PathBuffer,
                                 sizeof(PathBuffer));

        //
        // the length a game name can be is MAX_GAMENAME - all the other path stuff
        // like the GUID and other top level directories
        // initial testing shows this to be 239 unicode chars long
        //

        if (ERROR_SUCCESS != RetVal &&
            wcslen(pwTestBuffer) < MAX_GAMENAME ) {
            swprintf(wcDbgMsgBuffer,
                     L"Savegame : XCreateSaveGame failed: lpSaveGameName: %S\n",
                     PathBuffer);
            //OutputDebugString(wcDbgMsgBuffer);
            Flag = FALSE;
        }

        //
        // append junk to end of pwTestBuffer
        //

        pwTestBuffer1 = AppendRandUnicodeChar(pwTestBuffer1);

    }

    xLog(LogHandle, (Flag) ? XLL_PASS : XLL_FAIL, "test_XCreateSaveGame(#4)");

    HeapFree(SaveGameNameSpace::HeapHandle, 0, pwTestBuffer);

    //
    // #5
    // lpIdentity 0...N long w/ UNICODE chars
    // note: MAX_NICKNAME 32
    //

#if DBG_RIP
    #define TEST_BUFFER_LEN1  (MAX_NICKNAME + 2)
#else
    #define TEST_BUFFER_LEN1  MAX_NICKNAME
#endif

    Flag = TRUE;
    pwTestBuffer = (PWCHAR)HeapAlloc(SaveGameNameSpace::HeapHandle, HEAP_ZERO_MEMORY, TEST_BUFFER_LEN * 2);
    if (NULL == pwTestBuffer) {
        xLog(LogHandle,XLL_BLOCK,"Out of memory!");
        return;
    }

    pwTestBuffer1 = AppendRandUnicodeChar(pwTestBuffer);

    for (x = 0; x < TEST_BUFFER_LEN1 - 1; x++) {

        _try {
            PreRIPSaveRegs
            RetVal = XCreateSaveGame(SaveRoot,
                                     gamename,
                                     OPEN_ALWAYS,
                                     0,
                                     PathBuffer,
                                     sizeof(PathBuffer));
        }
        _except ( Eval_Exception( GetExceptionInformation(), 24)) {
            OutputDebugString(L"_except function body hit - bug?\n");
            // No code; this block never executed.
        }

        //
        // the length a Identity can be: MAX_NICKNAME 32
        // when this is exceeded we'll RIP...
        // so wrap it with the RIP Wrapper
        //

        if (ERROR_SUCCESS != RetVal &&
            wcslen(pwTestBuffer) < MAX_NICKNAME) {
            swprintf(wcDbgMsgBuffer,
                     L"Savegame : XCreateSaveGame failed: pwTestBuffer1: %s  Error: %d\n",
                     pwTestBuffer1,
                     RetVal);
            //OutputDebugString(wcDbgMsgBuffer);
            Flag = FALSE;
        }

        if (ERROR_SUCCESS != RetVal &&
            ERROR_INVALID_PARAMETER != RetVal) {
            swprintf(wcDbgMsgBuffer,
                     L"Savegame : XCreateSaveGame returned bad error code: %d\n",
                     RetVal);
            OutputDebugString(wcDbgMsgBuffer);
            Flag = FALSE;
        }

        //
        // append junk to end of pwTestBuffer
        //

        pwTestBuffer1 = AppendRandUnicodeChar(pwTestBuffer1);

    }

    xLog(LogHandle, (Flag) ? XLL_PASS : XLL_FAIL, "test_XCreateSaveGame(#5)");

    HeapFree(SaveGameNameSpace::HeapHandle, 0, pwTestBuffer);

    //
    // #6
    // lpPathBuffer normal, too short
    // just manipulate the size
    // this case is irrelevant because the buffer length never gets checked
    // so pass on 0 lenght
    //

    x = 0;
    do {
        RetVal = XCreateSaveGame(SaveRoot,
                                 L"game6",
                                 OPEN_ALWAYS,
                                 0,
                                 PathBuffer,
                                 x++);
    } while (strlen(PathBuffer) == x);
    --x;

    xLog(LogHandle,
         ((ERROR_SUCCESS == RetVal) && (x > 0)) ? XLL_FAIL : XLL_PASS,
         "XCreateSaveGame(#6): PathBuffer Length=%d chars : (Error=%d)",
         x,
         RetVal);

    //
    // #8
    // dwCreationDisposition = CREATE_NEW
    // create new, then try creating again to make sure it fails
    //

    PathBuffer[0] = 0;

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game8new",
                             CREATE_NEW,
                             XSAVEGAME_NOCOPY,
                             PathBuffer,
                             sizeof(PathBuffer));

    xLog(LogHandle,
         (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
         "XCreateSaveGame(8): path = %s (Error=%d)",
         PathBuffer,
         RetVal);

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game8new",
                             CREATE_NEW,
                             XSAVEGAME_NOCOPY,
                             PathBuffer,
                             sizeof(PathBuffer));

    xLog(LogHandle,
         (ERROR_ALREADY_EXISTS == RetVal) ? XLL_PASS : XLL_FAIL,
         "XCreateSaveGame(8): path = %s (Error=%d)",
         PathBuffer,
         RetVal);

    //
    // #9
    // dwCreationDisposition = OPEN_ALWAYS
    // re-use the last game
    //

    PathBuffer[0] = 0;

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game8new",
                             OPEN_ALWAYS,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

    xLog(LogHandle,
         (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
         "XCreateSaveGame(9): path = %s (Error=%d)",
         PathBuffer,
         RetVal);

    //
    // #10
    // dwCreationDisposition = OPEN_EXISTING
    // re-use the last game
    //

    PathBuffer[0] = 0;

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game8new",
                             OPEN_EXISTING,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

    xLog(LogHandle,
         (ERROR_SUCCESS == RetVal) ? XLL_PASS : XLL_FAIL,
         "XCreateSaveGame(10): path = %s (Error=%d)",
         PathBuffer,
         RetVal);

    //
    // the fail cases
    //

#if DBG_RIP
    PathBuffer[0] = 0;

    _try {
        PreRIPSaveRegs
        RetVal = XCreateSaveGame(SaveRoot,
                             L"game8newXXX",
                             OPEN_EXISTING,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

        xLog(LogHandle,
             (ERROR_FILE_NOT_FOUND == RetVal) ? XLL_PASS : XLL_FAIL,
             "XCreateSaveGame(10a): path = %s (Error=%d)",
             PathBuffer,
             RetVal);

        PreRIPSaveRegs
        RetVal = XCreateSaveGame(SaveRoot,
                                 L"game8newXXX",
                                 OPEN_EXISTING | OPEN_ALWAYS | CREATE_NEW,
                                 0,
                                 PathBuffer,
                                 sizeof(PathBuffer));

        xLog(LogHandle,
             (ERROR_INVALID_PARAMETER == RetVal) ? XLL_PASS : XLL_FAIL,
             "XCreateSaveGame(10b): path = %s (Error=%d)",
             PathBuffer,
             RetVal);

        //
        // dwCreationDisposition = OPEN_EXISTING
        // re-use the last game, call with 1 name, should fail
        //

        PathBuffer[0] = 0;

        PreRIPSaveRegs
        RetVal = XCreateSaveGame(SaveRoot,
                                 L"game8new",
                                 OPEN_EXISTING,
                                 0,
                                 PathBuffer,
                                 sizeof(PathBuffer));

        xLog(LogHandle,
             (ERROR_INVALID_PARAMETER == RetVal) ? XLL_PASS : XLL_FAIL,
             "XCreateSaveGame(10c): path = %s (Error=%d)",
             PathBuffer,
             RetVal);

    }
        _except ( Eval_Exception( GetExceptionInformation(), 28)) {
            OutputDebugString(L"_except function body hit - bug?\n");
            // No code; this block never executed.
    }


#else
#endif

    //
    // #11
    // until the disk runs out of space, and then some
    // we do this last since the next test variation deletes games
    // if MaxFiles != -1 then only make MaxFiles number of files
    //
    // note:
    // from FatCreateNewDirent()  [fastfat\dirsup.c]:
    //
    //  A reason why we might fail, unrelated to physical reasons,
    //  is that we constrain to 64k directory entries to match the
    //  restriction on Win95.  There are fundamental reasons to do
    //  this since searching a FAT directory is a linear operation
    //  and to allow FAT32 to toss us over the cliff is not permissable.
    //
    // So it looks like you should be able to fit 65535 DIRENTs in a FAT32 directory.
    // This includes files and directories.  If you end up using LFNs, each file or
    // directory will be at least 2 DIRENTs (and may be as many as 25 DIRENTs).  SFNs
    // are 1 DIRENT per file or directory.
    //



    if (MaxFiles == -1) {
        do {
            swprintf(gamename,L"GAME#%x", x++);
            RetVal = XCreateSaveGame(SaveRoot,
                                     gamename,
                                     OPEN_ALWAYS,
                                     0,
                                     PathBuffer,
                                     sizeof(PathBuffer));

            if (ERROR_SUCCESS != RetVal) {
                break;
            }

            RetVal = SaveAGame(PathBuffer,
                               "test11",
                               "sav",
                               10000,
                               1);
        } while ( RetVal );
    } else {
        for (x = 0; x < (DWORD)MaxFiles; x++) {
            swprintf(gamename,L"GAME#%x", x);
            RetVal = XCreateSaveGame(SaveRoot,
                                     gamename,
                                     OPEN_ALWAYS,
                                     0,
                                     PathBuffer,
                                     sizeof(PathBuffer));

            if (ERROR_SUCCESS != RetVal) {
                break;
            }

            #if 0    //DBG
            OutputDebugStringA(SaveRoot);
            OutputDebugStringW(TEXT("\\"));
            OutputDebugStringW(gamename);
            OutputDebugStringW(TEXT("\r\n"));
            #endif  // DBG

            RetVal = SaveAGame(PathBuffer,
                               "test11",
                               "sav",
                               10000,
                               1);
        }
    }

    xLog(LogHandle,
         (x) ? XLL_PASS : XLL_FAIL,
         "test_XCreateSaveGame(#11) : XCreateSaveGame called = %d times",
         x);

    //
    // #12
    // try saving 100 times - should fail 100 times
    // this could get tricky during stress since other things
    // could free up disk space, so not neccessarisarily an error
    // if it works...
    // also, if MaxFiles != -1, skip, since there will probably be space left.
    //

    if (-1 == MaxFiles) {
        for (x = 0; x < 100; x++) {
            swprintf(gamename,L"GAMEz%x", x);
            RetVal = XCreateSaveGame(SaveRoot,
                                     gamename,
                                     0,
                                     0,
                                     PathBuffer,
                                     sizeof(PathBuffer));

            if (ERROR_SUCCESS == RetVal) {
                swprintf(wcDbgMsgBuffer,
                         L"Savegame : XCreateSaveGame unexpectedly succeeded: %s\n",
                         PathBuffer);
                OutputDebugString(wcDbgMsgBuffer);
                xLog(LogHandle,
                     XLL_FAIL,
                     "test_XCreateSaveGame(#12) : XCreateSaveGame unexpectedly succeeded");
            }
        }
    }

    xEndVariation( LogHandle );

    return;
}

VOID
WINAPI
test_XDeleteSaveGame(
    HANDLE LogHandle,
    char uDrive    
    )
/*++

Routine Description:

    test XDeleteSaveGame
    - a disk full of saved games (thousands!)
    - test with 0 saved games
    - 1 saved game
    - bad params where they make sense
    - saved games with 0 files
    - saved games with 1 files
    - saved games with N files

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    char uDrive - drive to use

Return Value:

    None

Notes:

    this function expects that test_XCreateSaveGame() ran first and that
    there are thousands of saved games on the disk to delete

--*/
{
    XGAME_FIND_DATA xgData;
    HANDLE hSavedGames;
    CHAR PathBuffer[_MAX_DIR + 2] = {0};
    CHAR SaveRoot[] = {"U:\\"};
    DWORD RetVal = 0;
    BOOL Flag;

    //
    // point to the correct drive
    //

    SaveRoot[0] = uDrive;
    
    //
    // positive test cases
    //

    xSetFunctionName( LogHandle, "XDeleteSaveGame" );
    xStartVariation( LogHandle, "goodparam1" );

    //
    // #1
    // enumerate and delete games
    //

    Flag = TRUE;
    hSavedGames = XFindFirstSaveGame(SaveRoot, &xgData);

    if (INVALID_HANDLE_VALUE == hSavedGames) {
        OutputDebugString( TEXT("XFindFirstSaveGame returned INVALID_HANDLE_VALUE\n"));
        xLog(LogHandle,
             XLL_BLOCK,
             "test_XDeleteSaveGame(#1) : XFindFirstSaveGame failed (LastError=%d)",
             GetLastError());
        goto XD1;
    }

    do {
        RetVal = XDeleteSaveGame(SaveRoot, xgData.szSaveGameName);

        if (ERROR_SUCCESS != RetVal) {
            swprintf(wcDbgMsgBuffer,
                     L"Savegame : XDeleteSaveGame failed: %d, dir = %s : name = %S\n",
                     RetVal,
                     xgData.szSaveGameDirectory,
                     xgData.szSaveGameName);
            OutputDebugString(wcDbgMsgBuffer);
            Flag = FALSE;
        }
    } while (XFindNextSaveGame(hSavedGames, &xgData));

    xLog(LogHandle, (Flag) ? XLL_PASS : XLL_FAIL, "test_XDeleteSaveGame(#1)");

    XFindClose(hSavedGames);

    XD1:

    //
    // #2
    // test with 0 saved games
    //

    RetVal = XDeleteSaveGame(SaveRoot, xgData.szSaveGameName);

    if (ERROR_SUCCESS == RetVal) {
        swprintf(wcDbgMsgBuffer,
                 L"Savegame : XDeleteSaveGame unexpectedly succeeded: %d, dir = %s : name = %S\n",
                 RetVal,
                 xgData.szSaveGameDirectory,
                 xgData.szSaveGameName);
        xLog(LogHandle, XLL_FAIL, "test_XDeleteSaveGame(#2)");
    } else {
        xLog(LogHandle, XLL_PASS, "test_XDeleteSaveGame(#2)");
    }

    //
    // #3
    // 1 saved game
    //

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game3",
                             OPEN_ALWAYS,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

    if (ERROR_SUCCESS == RetVal) {
        RetVal = SaveAGame(PathBuffer,
                           "test3",
                           "sav",
                           10000,
                           1);

        //
        // also add a directory here so we can make sure the delete works properly
        //

        strcat( PathBuffer, "Subdir" );
        if (FALSE == CreateDirectory( PathBuffer, NULL )) {
            OutputDebugString( TEXT("CreateDirectory returned FALSE\n"));
            xLog(LogHandle,
                 XLL_BLOCK,
                 "test_XDeleteSaveGame(#3) : CreateDirectory returned FALSE (LastError=%d)",
                 GetLastError());
        }
        
        Flag = TRUE;
        hSavedGames = XFindFirstSaveGame(SaveRoot, &xgData);

        if (INVALID_HANDLE_VALUE == hSavedGames) {
            OutputDebugString( TEXT("XFindFirstSaveGame returned INVALID_HANDLE_VALUE\n"));
            xLog(LogHandle,
                 XLL_BLOCK,
                 "test_XDeleteSaveGame(#3) : XFindFirstSaveGame failed (LastError=%d)",
                 GetLastError());
            goto XD3;
        }

        do {
            RetVal = XDeleteSaveGame(SaveRoot, xgData.szSaveGameName);

            if (ERROR_SUCCESS != RetVal) {
                swprintf(wcDbgMsgBuffer,
                         L"Savegame : XDeleteSaveGame failed: %d, dir = %s : name = %S\n",
                         RetVal,
                         xgData.szSaveGameDirectory,
                         xgData.szSaveGameName);
                OutputDebugString(wcDbgMsgBuffer);
                Flag = FALSE;
            }
        } while (XFindNextSaveGame(hSavedGames, &xgData));

        xLog(LogHandle, (Flag) ? XLL_PASS : XLL_FAIL, "test_XDeleteSaveGame(#3)");

        XFindClose(hSavedGames);
    }

    XD3:

    //
    // #4
    // saved games with 0 files
    //

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game4",
                             OPEN_ALWAYS,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

    if (ERROR_SUCCESS == RetVal) {

        Flag = TRUE;
        hSavedGames = XFindFirstSaveGame(SaveRoot, &xgData);

        if (INVALID_HANDLE_VALUE == hSavedGames) {
            OutputDebugString( TEXT("XFindFirstSaveGame returned INVALID_HANDLE_VALUE\n"));
            xLog(LogHandle,
                 XLL_BLOCK,
                 "test_XDeleteSaveGame(#4) : XFindFirstSaveGame failed (LastError=%d)",
                 GetLastError());
            goto XD4;
        }

        do {
            RetVal = XDeleteSaveGame(SaveRoot, xgData.szSaveGameName);

            if (ERROR_SUCCESS != RetVal) {
                swprintf(wcDbgMsgBuffer,
                         L"Savegame : XDeleteSaveGame failed: %d, dir = %s : name = %S\n",
                         RetVal,
                         xgData.szSaveGameDirectory,
                         xgData.szSaveGameName);
                OutputDebugString(wcDbgMsgBuffer);
                Flag = FALSE;
            }
        } while (XFindNextSaveGame(hSavedGames, &xgData));

        xLog(LogHandle, (Flag) ? XLL_PASS : XLL_FAIL, "test_XDeleteSaveGame(#4)");
        
        XFindClose(hSavedGames);
    }

    XD4:

    //
    // * skip this case (it will be more relevant in the XFindFirstSaveGame() test)
    // saved games with 1 files
    // this was already covered, test_XCreateSaveGame() creates games with 1 file
    //

    //
    // #5
    // saved games with N (1000 just to make this finish sometime in my lifetime....) files
    //

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game5",
                             OPEN_ALWAYS,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

    if (ERROR_SUCCESS == RetVal) {
        RetVal = SaveAGame(PathBuffer,
                           "test5",
                           "sav",
                           1000,
                           1000);

        Flag = TRUE;
        hSavedGames = XFindFirstSaveGame(SaveRoot, &xgData);

        if (INVALID_HANDLE_VALUE == hSavedGames) {
            OutputDebugString( TEXT("XFindFirstSaveGame returned INVALID_HANDLE_VALUE\n"));
            xLog(LogHandle,
                 XLL_BLOCK,
                 "test_XDeleteSaveGame(#5) : XFindFirstSaveGame failed (LastError=%d)",
                 GetLastError());
            goto XD5;
        }

        do {
            RetVal = XDeleteSaveGame(SaveRoot, xgData.szSaveGameName);

            if (ERROR_SUCCESS != RetVal) {
                swprintf(wcDbgMsgBuffer,
                         L"Savegame : XDeleteSaveGame failed: %d, dir = %s : name = %S\n",
                         RetVal,
                         xgData.szSaveGameDirectory,
                         xgData.szSaveGameName);
                OutputDebugString(wcDbgMsgBuffer);
                Flag = FALSE;
            }
        } while (XFindNextSaveGame(hSavedGames, &xgData));

        xLog(LogHandle, (Flag) ? XLL_PASS : XLL_FAIL, "test_XDeleteSaveGame(#5)");
        XFindClose(hSavedGames);
    }

    XD5:

    xEndVariation( LogHandle );

    //
    // negative test cases
    //

#if DBG_RIP
    _try {
        xSetFunctionName( LogHandle, "XDeleteSaveGame" );
        xStartVariation( LogHandle, "badparam1" );

        //
        // #n1
        // lpSaveGameName = NULL
        //

        PreRIPSaveRegs
        RetVal = XDeleteSaveGame(SaveRoot, NULL);

        // should RIP so don't log
        //xLog(LogHandle,
        //     (ERROR_SUCCESS != RetVal ||
        //      ERROR_INVALID_PARAMETER != GetLastError())  ? XLL_PASS : XLL_FAIL,
        //     "XDeleteSaveGame(SaveRoot, NULL): unexpectedly succeeded: (LastError=%d)",
        //     GetLastError());

        //
        // #n2
        // lpRootPathName = NULL
        //

        PreRIPSaveRegs
        RetVal = XCreateSaveGame(SaveRoot,
                                 L"gamen2",
                                 OPEN_ALWAYS,
                                 0,
                                 PathBuffer,
                                 sizeof(PathBuffer));

        if (ERROR_SUCCESS == RetVal) {

            Flag = TRUE;
            hSavedGames = XFindFirstSaveGame(SaveRoot, &xgData);

            if (INVALID_HANDLE_VALUE == hSavedGames) {
                OutputDebugString( TEXT("XFindFirstSaveGame returned INVALID_HANDLE_VALUE\n"));
                xLog(LogHandle,
                     XLL_BLOCK,
                     "test_XDeleteSaveGame(#n2) : XFindFirstSaveGame failed (LastError=%d)",
                     GetLastError());
                goto XDn2;
            }

            PreRIPSaveRegs
            RetVal = XDeleteSaveGame(NULL, L"gamen2");
            // should RIP so don't log
            //xLog(LogHandle,
            //     (ERROR_SUCCESS != RetVal ||
            //      ERROR_INVALID_PARAMETER != GetLastError())  ? XLL_PASS : XLL_FAIL,
            //     "XDeleteSaveGame(SaveRoot, NULL): unexpectedly succeeded: (LastError=%d)",
            //     GetLastError());
            
            XFindClose(hSavedGames);
        }

        XDn2:

        //
        // now really delete it...
        //

        PreRIPSaveRegs
        RetVal = XDeleteSaveGame(SaveRoot, L"gamen2");

        //
        // #n3
        // lpRootPathName = NULL
        // lpSaveGameName = NULL
        //

        PreRIPSaveRegs
        RetVal = XDeleteSaveGame(NULL, NULL);
        // should RIP so don't log
        //xLog(LogHandle,
        //     (ERROR_SUCCESS != RetVal  ||
        //      ERROR_INVALID_PARAMETER != GetLastError()) ? XLL_PASS : XLL_FAIL,
        //     "XDeleteSaveGame(NULL, NULL): unexpectedly succeeded: (LastError=%d)",
        //     GetLastError());

        xEndVariation( LogHandle );
    }
    _except ( Eval_Exception( GetExceptionInformation(), 8)) {
        OutputDebugString(L"_except function body hit - bug?\n");
        // No code; this block never executed.
    }
#endif  //DBG

    return;
}

VOID
WINAPI
test_XFindFirstSaveGame(
    HANDLE LogHandle,
    char uDrive
    )
/*++

Routine Description:

    test XFindFirstSaveGame
    - a disk full of saved games (thousands!) test_XDeleteSaveGame()
    - test with 0 saved games
    - 1 saved game - done in test_XDeleteSaveGame()
    - bad params where they make sense

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    char uDrive - drive to use

Return Value:

    None

--*/
{
    XGAME_FIND_DATA xgData;
    HANDLE hSavedGames;
    CHAR SaveRoot[] = {"U:\\"};

    //
    // point to the correct drive
    //

    SaveRoot[0] = uDrive;
    
    //
    // positive test cases
    //

    xSetFunctionName( LogHandle, "XFindFirstSaveGame" );
    xStartVariation( LogHandle, "goodparam1" );

    //
    // test with 0 saved games
    //

    DeleteAllSavedGames(uDrive);

    hSavedGames = XFindFirstSaveGame(SaveRoot, &xgData);

    if (INVALID_HANDLE_VALUE == hSavedGames) {
        xLog(LogHandle,
             XLL_PASS,
             "XFindFirstSaveGame(#1) : XFindFirstSaveGame failed correctly");
    } else {
        xLog(LogHandle,
             XLL_FAIL,
             "XFindFirstSaveGame(#1) : XFindFirstSaveGame succeeded unexpectedly (LastError=%d) Path: %s Name %S",
             GetLastError(),
             xgData.szSaveGameDirectory,
             xgData.szSaveGameName);
    }

    xEndVariation( LogHandle );

    //
    // negative test cases
    // need to stop RIPs here
    //

#if DBG_RIP
    //
    // #n1
    // lpRootPathName = NULL
    //

    _try {
        xSetFunctionName( LogHandle, "XFindFirstSaveGame" );
        xStartVariation( LogHandle, "badparam1" );

        PreRIPSaveRegs
        hSavedGames = XFindFirstSaveGame(NULL, &xgData);

        // should RIP so don't log
        //xLog(LogHandle,
        //     INVALID_HANDLE_VALUE != hSavedGames ||
        //     ERROR_INVALID_PARAMETER != GetLastError() ? XLL_FAIL : XLL_PASS,
        //     "XFindFirstSaveGame(#n1) : XFindFirstSaveGame : handle: %d : (LastError=%d)",
        //     hSavedGames,
        //     GetLastError());

        //
        // #n2
        // pFindGameData = NULL
        //

        PreRIPSaveRegs
        hSavedGames = XFindFirstSaveGame(SaveRoot, NULL);

        // should RIP so don't log
        //xLog(LogHandle,
        //     INVALID_HANDLE_VALUE != hSavedGames ||
        //     ERROR_INVALID_PARAMETER != GetLastError() ? XLL_FAIL : XLL_PASS,
        //     "XFindFirstSaveGame(#n2) : XFindFirstSaveGame : handle: %d : (LastError=%d)",
        //     hSavedGames,
        //     GetLastError());

        //
        // #n3
        // pFindGameData = NULL
        // lpRootPathName = NULL
        //

        PreRIPSaveRegs
        hSavedGames = XFindFirstSaveGame(NULL, NULL);

        // should RIP so don't log
        //xLog(LogHandle,
        //     INVALID_HANDLE_VALUE != hSavedGames ||
        //     ERROR_INVALID_PARAMETER != GetLastError() ? XLL_FAIL : XLL_PASS,
        //     "XFindFirstSaveGame(#n3) : XFindFirstSaveGame : handle: %d : (LastError=%d)",
        //     hSavedGames,
        //     GetLastError());

        xEndVariation( LogHandle );
    }
    _except ( Eval_Exception( GetExceptionInformation(), 8)) {
        OutputDebugString(L"_except function body hit - bug?\n");
        // No code; this block never executed.
    }

#endif  // DBG

    return;
}

VOID
WINAPI
test_XFindNextSaveGame(
    HANDLE LogHandle,
    char uDrive
    )
/*++

Routine Description:

    test XFindNextSaveGame
    - test with 0 saved games
    - 1 saved game - done in test_XDeleteSaveGame()
    - a disk full of saved games (thousands!) done in test_XDeleteSaveGame()
    - bad params where they make sense

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    char uDrive - drive to use

Return Value:

    None

--*/
{
    XGAME_FIND_DATA xgData;
    BOOL RetVal;

    //
    // positive test cases (none here!)
    //

    //xSetFunctionName( LogHandle, "XFindNextSaveGame" );
    //xStartVariation( LogHandle, "goodparam1" );
    //xEndVariation( LogHandle );

    //
    // negative test cases
    //

#if DBG_RIP
    _try {
        xSetFunctionName( LogHandle, "XFindNextSaveGame" );
        xStartVariation( LogHandle, "badparam1" );

        //
        // test with 0 saved games - all other cases are covered in other tests
        // do it the easy way
        //

        PreRIPSaveRegs
        RetVal = XFindNextSaveGame(INVALID_HANDLE_VALUE, &xgData);
        // should RIP so don't log
        //xLog(LogHandle,
        //     (FALSE == RetVal  &&
        //      ERROR_INVALID_PARAMETER == GetLastError()) ? XLL_PASS : XLL_FAIL,
        //     "XFindNextSaveGame(INVALID_HANDLE_VALUE, &xgData): unexpectedly succeeded: (LastError=%d) (RetVal=%d)",
        //     GetLastError(),
        //     RetVal);

        //
        // hFindGame = NULL
        //

        PreRIPSaveRegs
        RetVal = XFindNextSaveGame(NULL, &xgData);
        // should RIP so don't log
        //xLog(LogHandle,
        //     (FALSE == RetVal  &&
        //      ERROR_INVALID_PARAMETER == GetLastError()) ? XLL_PASS : XLL_FAIL,
        //     "XFindNextSaveGame(NULL, &xgData): unexpectedly succeeded: (LastError=%d) (RetVal=%d)",
        //     GetLastError(),
        //     RetVal);

        //
        // pFindGameData = NULL
        // do not build up a valid hSavedGames, just lie
        //

        PreRIPSaveRegs
        RetVal = XFindNextSaveGame((HANDLE)1, NULL);
        // should RIP so don't log
        //xLog(LogHandle,
        //     (FALSE == RetVal  &&
        //      ERROR_INVALID_PARAMETER == GetLastError()) ? XLL_PASS : XLL_FAIL,
        //     "XFindNextSaveGame(1, NULL): unexpectedly succeeded: (LastError=%d) (RetVal=%d)",
        //     GetLastError(),
        //     RetVal);

        //
        // hFindGame = NULL
        // pFindGameData = NULL
        //

        PreRIPSaveRegs
        RetVal = XFindNextSaveGame(NULL, NULL);
        // should RIP so don't log
        //xLog(LogHandle,
        //     (FALSE == RetVal  ||
        //      ERROR_INVALID_PARAMETER == GetLastError()) ? XLL_PASS : XLL_FAIL,
        //     "XFindNextSaveGame(NULL, NULL): unexpectedly succeeded: (LastError=%d) (RetVal=%d)",
        //     GetLastError(),
        //     RetVal);
        xEndVariation( LogHandle );
    }

    _except ( Eval_Exception( GetExceptionInformation(), 8)) {
        OutputDebugString(L"_except function body hit - bug?\n");
        // No code; this block never executed.
    }

#endif  // DBG
    return;
}

VOID
WINAPI
test_XFindClose(
    HANDLE LogHandle,
    char uDrive
    )
/*++

Routine Description:

    test XFindClose
    - good handle
    - bad handle
    - double close

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    char uDrive - drive to use

Return Value:

    None

Notes:

    Should be called with a clean disk

--*/
{
    XGAME_FIND_DATA xgData;
    HANDLE hSavedGames;
    CHAR PathBuffer[_MAX_DIR + 2] = {0};
    CHAR SaveRoot[] = {"U:\\"};
    DWORD RetVal = 0;
    BOOL Flag;

    //
    // point to the correct drive
    //

    SaveRoot[0] = uDrive;
    
    //
    // positive test cases
    //

    xSetFunctionName( LogHandle, "XFindClose" );
    xStartVariation( LogHandle, "goodparam1" );

    //
    // #1
    // good handle
    //

    RetVal = XCreateSaveGame(SaveRoot,
                             L"game1",
                             OPEN_ALWAYS,
                             0,
                             PathBuffer,
                             sizeof(PathBuffer));

    if (ERROR_SUCCESS == RetVal) {
        RetVal = SaveAGame(PathBuffer,
                           "test1",
                           "sav",
                           10000,
                           1);

        hSavedGames = XFindFirstSaveGame(SaveRoot, &xgData);

        if (INVALID_HANDLE_VALUE == hSavedGames) {
            OutputDebugString( TEXT("XFindFirstSaveGame returned INVALID_HANDLE_VALUE\n"));
            xLog(LogHandle,
                 XLL_BLOCK,
                 "test_XFindClose(#1) : XFindFirstSaveGame failed (LastError=%d)",
                 GetLastError());
            goto XD1;
        }
    } else {
        xLog(LogHandle,
             XLL_BLOCK,
             "test_XFindClose(#1) : XCreateSaveGame failed (Error=%d)",
             RetVal);
        goto XD1;
    }

    RetVal = XFindClose(hSavedGames);
    xLog(LogHandle, RetVal ? XLL_PASS : XLL_FAIL, "test_XFindClose(#1)");

    //
    // #2
    // double close
    // expecting 0 for return value
    // need to handle exception this will likely cause
    // NOTE: this can cause random crahshe, don't do it
    //

    //Flag = TRUE;
    //__try {
    //    RetVal = XFindClose(hSavedGames);
    //}
    //__except(EXCEPTION_EXECUTE_HANDLER) {
    //    xLog(LogHandle, XLL_PASS, "test_XFindClose(#2) - exception hit");
    //    Flag = FALSE;
    //}
    //
    //if (Flag == FALSE) {
    //    xLog(LogHandle, RetVal ? XLL_FAIL : XLL_PASS, "test_XFindClose(#2) - exception not hit");
    //}

    XD1:

    xEndVariation( LogHandle );

    //
    // negative test cases
    //

#if DBG_RIP
    _try {
        xSetFunctionName( LogHandle, "XFindClose" );
        xStartVariation( LogHandle, "badparam1" );

        //
        // #n1
        // use INVALID_HANDLE_VALUE
        //

        PreRIPSaveRegs
        RetVal = XFindClose(INVALID_HANDLE_VALUE);
        // should RIP so don't log
        //xLog(LogHandle,
        //     (RetVal || (ERROR_INVALID_HANDLE != GetLastError())) ? XLL_FAIL : XLL_PASS,
        //     "test_XFindClose(#n1)");

        //
        // #n2
        // use 0
        //

        PreRIPSaveRegs
        RetVal = XFindClose(NULL);
        // should RIP so don't log
        //xLog(LogHandle,
        //    (RetVal || (ERROR_INVALID_HANDLE != GetLastError())) ? XLL_FAIL : XLL_PASS,
        //    "test_XFindClose(#n2)");

        xEndVariation( LogHandle );
    }
   _except ( Eval_Exception( GetExceptionInformation(), 4)) {
        OutputDebugString(L"_except function body hit - bug?\n");
        // No code; this block never executed.
    }

#endif  // DBG

    return;
}

VOID
WINAPI
SaveGameStartTest(
    HANDLE LogHandle
    )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/
{
    LONG ID;
    DWORD x;
    char *tmpPtr;
    unsigned y = 0;

    OutputDebugString( TEXT("savegame: StartTest is called\n") );

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement( &SaveGameNameSpace::SaveGameThreadID );

    //
    // get parameters
    // MaxFiles - maximum number of files to create
    // -1 means creat until failure - this takes too long for BVT's
    //

    MaxFiles = GetPrivateProfileIntA("savegame",
                                     "Files",
                                     1000,
                                     "testini.ini");

    xSetComponent( LogHandle, "xapi", "savegame" );

    //
    // seed random number generator
    // may want to conside saving the seed sometime
    //

    xtsrand( (unsigned)GetTickCount() );

    //
    // create our test data buffer
    //

    FileDataBuffer = HeapAlloc(SaveGameNameSpace::HeapHandle, 0, FILE_DATA_SIZE);
    if (NULL == FileDataBuffer) {
        OutputDebugString(L"Out of memory!");
        return;
    }
    tmpPtr = (char *)FileDataBuffer;
    for (x = 1; x < FILE_DATA_SIZE; x++) {
        *tmpPtr = (char)(x % 16);
        ++tmpPtr;
    }

    //
    // mount MUs
    //

    MountMUs();
    
    //
    // run the tests
    //

    //
    // this test is independant of the drives
    //

    test_XSignature(LogHandle);

    //
    // these tests require the drives
    //

    while ( UDataDrives[y] ) {

        //
        // attempt to get everything to a known state
        //

        DeleteAllSavedGames(UDataDrives[y]);

        //
        // call the tests
        // these 3 need to be called in order, for each saved game device
        //

        test_XFindClose(LogHandle, UDataDrives[y]);         // must be 0th
    
        test_XCreateSaveGame(LogHandle, UDataDrives[y]);    // must be first
        test_XDeleteSaveGame(LogHandle, UDataDrives[y]);    // must be second
    
        test_XFindFirstSaveGame(LogHandle, UDataDrives[y]);
        test_XFindNextSaveGame(LogHandle, UDataDrives[y]);
    
        ++y;
    }
    
    //
    // clean up the mess on the last drive
    //

    if (y) {
        DeleteAllSavedGames(UDataDrives[--y]);
    }
    
    //
    // done testing, cleanup
    //
    
    HeapFree(SaveGameNameSpace::HeapHandle, 0, FileDataBuffer);

    return;
}

VOID
WINAPI
SaveGameEndTest(
    VOID
    )
/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/
{
    SaveGameNameSpace::SaveGameThreadID = 0;
    OutputDebugString( TEXT("savegame: EndTest is called\n") );
}

BOOL
WINAPI
SaveGameDllMain(
    HINSTANCE   hInstance,
    DWORD       fdwReason,
    LPVOID      lpReserved
    )
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( lpReserved );

    if ( fdwReason == DLL_PROCESS_ATTACH ) {

        SaveGameNameSpace::HeapHandle = HeapCreate( 0, 0, 0 );

        if ( !SaveGameNameSpace::HeapHandle ) {
            OutputDebugString( TEXT("savegame: Unable to create heap\n") );
            return FALSE;
        }

    } else if ( fdwReason == DLL_PROCESS_DETACH ) {

        if ( SaveGameNameSpace::HeapHandle ) {
            HeapDestroy( SaveGameNameSpace::HeapHandle );
        }
    }

    return TRUE;
}

BOOL
WINAPI
DeleteAllSavedGames(
    char uDrive
    )
/*++

Routine Description:

    quickly blow away all saved games

Arguments:

    char uDrive

Return Value:

    TRUE if any saved games were found and deleted
    FALSE otherwise

Notes:

    this may change as the APIs change
    this may make a good SDK sample

--*/
{
    BOOL bGamesDeleted = FALSE;
    XGAME_FIND_DATA xgData;
    HANDLE hSavedGames;
    // BUGBUG - hardcoded to drive U for now
    CHAR SaveRoot[] = {"U:\\"};

    //
    // point to the correct drive
    //

    SaveRoot[0] = uDrive;
    
    //
    // enumerate and delete games
    //

    hSavedGames = XFindFirstSaveGame(SaveRoot, &xgData);
    if(INVALID_HANDLE_VALUE == hSavedGames){
        OutputDebugString( TEXT("XFindFirstSaveGame returned INVALID_HANDLE_VALUE\n"));
        return(bGamesDeleted);
    }

    bGamesDeleted = TRUE;

    do {
         XDeleteSaveGame(SaveRoot, xgData.szSaveGameName);
    } while (XFindNextSaveGame(hSavedGames, &xgData));

    XFindClose(hSavedGames);

    return(bGamesDeleted);
}

BOOL
WINAPI
SaveAGame(
    PCHAR SavePath,
    PCHAR BaseFileName,
    PCHAR FileNameExt,
    DWORD FileSize,
    DWORD FileCount
    )
/*++

Routine Description:

    save a game using the specified path

Arguments:

    PWCHAR SavePath - path to save to
    PWCHAR BaseFileName - base string to form filename with
    PWCHAR FileNameExt - file name extension
    DWORD FileSize - how many bytes long the file needs to be
    DWORD FileCount - number of files

Return Value:

    TRUE file created successfully
    FALSE otherwise

Notes:

    we'll limit the number of files created to 0xFFFF

--*/
{
    HANDLE hFile;
    CHAR wcGameNamePath[MAX_PATH + 2] = {0};
    DWORD dwBytesWritten;
    DWORD dwBytesToWrite;
    BOOL bRetVal = TRUE;
    DWORD count;
    //char SavePathA[MAX_PATH] = {0};
    //char BaseFileNameA[64] = {0};
    //char FileNameExtA[4] = {0};

    //
    // check params
    // we allow 0-length files
    //

    if (NULL == SavePath ||
        NULL == BaseFileName ||
        0 == FileCount) {
        return(FALSE);
    }

    //
    // convert things to ANSI from Unicode here
    // otherwise we have to do it everywhere and it will get ugly, do later if time
    //
    //
    //WideCharToMultiByte(CP_ACP,
    //                    0,
    //                    SavePath,
    //                    wcslen(SavePath),
    //                    SavePathA,
    //                    MAX_PATH,
    //                    NULL,
    //                    NULL);
    //
    //WideCharToMultiByte(CP_ACP,
    //                    0,
    //                    BaseFileName,
    //                    wcslen(BaseFileName),
    //                    BaseFileNameA,
    //                    64,
    //                    NULL,
    //                    NULL);
    //
    //WideCharToMultiByte(CP_ACP,
    //                    0,
    //                    FileNameExt,
    //                    wcslen(FileNameExt),
    //                    FileNameExtA,
    //                    4,
    //                    NULL,
    //                    NULL);

    for (count = 0; count < FileCount; count++) {

        //
        // check lengths, make fully qualified path name
        // the + 5 is for the XXXX. added to the base filename
        //

        //if ((strlen(SavePathA) +
        //     strlen(BaseFileNameA) +
        //     strlen(FileNameExtA) + 5) > MAX_PATH) {
        //    OutputDebugString( TEXT("path name too long!\n"));
        //    return(FALSE);
        //}

        if ((strlen(SavePath) +
             strlen(BaseFileName) +
             strlen(FileNameExt) + 5) > MAX_PATH) {
            OutputDebugString( TEXT("path name too long!\n"));
            return(FALSE);
        }

        sprintf(wcGameNamePath,
                "%s%s%X.%s",
                SavePath,
                BaseFileName,
                count,
                FileNameExt);

        hFile = CreateFile(wcGameNamePath,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (INVALID_HANDLE_VALUE == hFile) {
            swprintf(wcDbgMsgBuffer,L"Savegame : CreateFile failed: path = %S: error = %d\n",
                     wcGameNamePath,
                     GetLastError());
            OutputDebugString(wcDbgMsgBuffer);
            return(FALSE);
        }

        //
        // write some easily understood pattern of data to the file
        //

        dwBytesToWrite = FileSize;
        while (dwBytesToWrite) {

            if (0 == WriteFile(hFile,
                               FileDataBuffer,
                               min(dwBytesToWrite, FILE_DATA_SIZE),
                               &dwBytesWritten,
                               NULL)) {
                swprintf(wcDbgMsgBuffer,
                         L"Savegame : WriteFile failed: path = %S: error = %d\n",
                         wcGameNamePath,
                         GetLastError());
                //OutputDebugString(wcDbgMsgBuffer);
                bRetVal = FALSE;
                CloseHandle(hFile);
                break;
            }

            if ( min(dwBytesToWrite, FILE_DATA_SIZE) != dwBytesWritten ) {

                swprintf(wcDbgMsgBuffer,
                         L"Savegame : WriteFile write length mismatch: path = %S: to write = %d : written = %d\n",
                         wcGameNamePath,
                         min(dwBytesToWrite, FILE_DATA_SIZE),
                         dwBytesWritten);
                OutputDebugString(wcDbgMsgBuffer);

                //
                // I don't expect this to happen, but I am paranoid...
                //

                DebugBreak();
                CloseHandle(hFile);
                bRetVal = FALSE;
                break;
            }

            if (dwBytesToWrite >= dwBytesWritten) {
                dwBytesToWrite -= dwBytesWritten;
            } else {
                dwBytesToWrite = 0;
            }
        }
        CloseHandle(hFile);
    }
    return(bRetVal);
}

PWCHAR
WINAPI
AppendRandUnicodeChar(
    PWCHAR pwStr
    )
/*++

Routine Description:

    Append a random unicode char, make sure that 0x0000 0x0000 is not appended
    append junk to end of pwTestBuffer
    junk == a random number between 0x0000 and 0xffff
    since rand() is 0-0x7fff we'll just use the last byte

Arguments:

    PWCHAR pwStr - string to append to

Return Value:

    pointer to next position

Notes:

    don't accidentally null terminate the string

--*/
{
    //
    // give it a random valid unicode value
    //

    *pwStr = xtrand() & 0x7fff;

    //
    // make sure it isn't a terminator
    //

    while (0 == *pwStr)
    {
        *pwStr = xtrand() & 0x7fff;
    }

    return(++pwStr);
}

//
// stolen from CRT's to make my life easier
// I made it un-thread safe
//

/***
*void srand(seed) - seed the random number generator
*
*Purpose:
*   Seeds the random number generator with the int given.  Adapted from the
*   BASIC random number generator.
*
*Entry:
*   unsigned seed - seed to seed rand # generator with
*
*Exit:
*   None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl xtsrand (
    unsigned int seed
    )
{
    holdrand = (long)seed;
}


/***
*int rand() - returns a random number
*
*Purpose:
*   returns a pseudo-random number 0 through 32767.
*
*Entry:
*   None.
*
*Exit:
*   Returns a pseudo-random number 0 through 32767.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl xtrand (
    void
    )
{
    return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
}

int
Eval_Exception (
    PEXCEPTION_POINTERS pExceptionPointers,
    DWORD ArgBytes
    )
{
    BYTE *JumpOffset;
    BYTE *pJumpOffset = (BYTE *)&JumpOffset;


    //_asm int 3

    if ( pExceptionPointers->ExceptionRecord->ExceptionCode != STATUS_BREAKPOINT) {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    OutputDebugString(L"Eval_Exception function hit - STATUS_BREAKPOINT\n");

    //
    // there is some indirection that has to happen here, because if we modify
    // the int 3, we will mangle the code for the next call, which breaks everything
    // so what we do is:
    //
    // 1.) save the contents of the code we will overwrite
    // 2.) make that code jump (not call) to a dummy code buffer
    // 3.) the dummy code buffer re-writes the int 3 and following bytes back to the function
    // 4.) this dummy code gets called when the 'bad' code gets continued
    // 5.) the dummy code than executes the correct pop+return instruction
    //

    //
    // save the address of the faulting instruction
    //

    Address = (BYTE *)pExceptionPointers->ExceptionRecord->ExceptionAddress;

    //
    // save the code that will get over written
    //

    Aspace[0] = Address[0];
    Aspace[1] = Address[1];
    Aspace[2] = Address[2];
    Aspace[3] = Address[3];
    Aspace[4] = Address[4];

    //
    // modify the code so that the function returns
    // after the bp instead of continuing with the bad parameters
    // synthesize :
    // 0xc9     leave
    // c2XXXX   ret ArgBytes
    //

    //
    // may need a few variations of this depending on the types of return codes we see
    //

    Bspace[0] = 0xc9;   // leave
    Bspace[1] = 0xc2;   // ret
    Bspace[2] = (BYTE)(ArgBytes & 0xFF);     // low byte of number
    Bspace[3] = (BYTE)((ArgBytes >> 16) & 0xFF);     // high byte of number

    //
    // write jump to DummyCode to the address that now contains the BP
    //

    //
    // 1 is size of opcode for int 3, 4 to skip entry for DummyCode
    //

    JumpOffset = (BYTE *)((BYTE *)DummyCode - Address - 2);

    Address[0] = 0xe9;  //jmp rel32
    Address[1] = pJumpOffset[0];
    Address[2] = pJumpOffset[1];
    Address[3] = pJumpOffset[2];
    Address[4] = pJumpOffset[3];

    //
    // the logging for the API may want to do some logging in the handler
    // before returning to the now-fixed code
    //

    return EXCEPTION_CONTINUE_EXECUTION ;
}

void
DummyCode(
    void
    )
{

    //
    // fix the calling code (saved in Aspace) at address (saved in Address)
    //

    //
    // the following code will be jumped to
    // examine any changes in a debugger to make sure there are no
    // pushes / pops that would mess up the synthesized return
    //

    Address[0] = Aspace[0];
    Address[1] = Aspace[1];
    Address[2] = Aspace[2];
    Address[3] = Aspace[3];
    Address[4] = Aspace[4];

    //
    // restore saved off registers
    //

    RIPRestoreSaveRegs

    //
    // execute the correct return (in Bspace)
    //

    _asm jmp jump_target;

}

void
MountMUs(
    void    
    )
/*++

Routine Description:

    log formatted text

Arguments:

    None

Return Value:

    None
    
Notes

    find and mount all MUs
    I believe the filesystem will now see them when they are present
    We will ignore unmounting them between titles 
    (unless this proves to be a bad thing to do)
    
--*/ 
{
    DWORD insertions;
    unsigned port, slot, i, x, UDataDrivesIndex = 0, DrivesIndex = 0;
    char Drive[10] = {10};
    char DeviceName[5];
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    BOOL bRetVal;

    for ( x = 0; x < 26; x++ ) {
        sprintf(DeviceName, "%c:\\", DeviceLetters[x]);
        bRetVal = GetDiskFreeSpaceEx(DeviceName,
                                     &FreeBytesAvailable,
                                     &TotalNumberOfBytes,
                                     &TotalNumberOfFreeBytes);

        if ( bRetVal ) {

            Drives[DrivesIndex] = DeviceLetters[x];

            //
            // take care of this in 1 place, rather than splitting it 
            // between here and some of the other functions that deal with drives
            //

            if ( (DeviceLetters[x] == 'U') ||
                 (DeviceLetters[x] == 'F') ||
                 (DeviceLetters[x] == 'G') ||
                 (DeviceLetters[x] == 'H') ||
                 (DeviceLetters[x] == 'I') ||
                 (DeviceLetters[x] == 'J') ||
                 (DeviceLetters[x] == 'K') ||
                 (DeviceLetters[x] == 'L') ||
                 (DeviceLetters[x] == 'M') ) {
                UDataDrives[UDataDrivesIndex++] = DeviceLetters[x];
            }
        }
    }
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( savegame )
#pragma data_seg()

BEGIN_EXPORT_TABLE( savegame )
    EXPORT_TABLE_ENTRY( "StartTest", SaveGameStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SaveGameEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", SaveGameDllMain )
END_EXPORT_TABLE( savegame )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\reboot\reboot.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    reboot.cpp

Abstract:

    This program contains routines to test the reboot API, only public
    API is tested currently.

--*/

#include <precomp.h>

typedef enum {
    RebootStateStartTest = 0x0000,
    RebootStateEndTest   = 0x0001,
    RebootStateHDDTest   = 0x1000,
    RebootStateHDDVerify = 0x1001,
    RebootStateDVDTest  = 0x2000,
    RebootStateDVDVerify = 0x2001
} RebootTestStates;

#define REBOOT_TEST_HDD_NT_PATH     OTEXT("\\??\\Z:\\reboot.xbe")
#define REBOOT_TEST_HDD_DOS_PATH    OTEXT("z:\\reboot.xbe")

#define REBOOT_TEST_LAUNCH_DATA     ((PLAUNCH_DATA)OTEXT("Reboot Test Launch Data"))

BOOL
SetRebootTestState(
    ULONG NewState,
    PULONG State OPTIONAL
    )
/*++

Routine Description:

    This routine stores state number to testini.ini before we perform a reboot

Arguments:

    State - 32-bit number

Return Value:

    TRUE/FALSE

--*/
{
    TCHAR Buffer[32];
    _stprintf( Buffer, TEXT("0x%x"), NewState );
    if ( ARGUMENT_PRESENT(State) ) {
        *State = NewState;
    }
    return WriteProfileString( TEXT("reboot"), TEXT("State"), Buffer );
}

ULONG
GetRebootTestState(
    VOID
    )
/*++

Routine Description:

    This routine gets cookie number from testini.ini

Arguments:

    None

Return Value:

    32-bit cookie number

--*/
{
    return GetProfileInt( TEXT("reboot"), TEXT("State"), ~0UL );
}

NTSTATUS
RebootTestCopyImage(
    PCOSTR Destination
    )
/*++

Routine Description:

    This routine copies the current test image to Destination

Arguments:

    Destination - full path name of destination

Return Value:

    TRUE/FALSE

--*/
{
    NTSTATUS Status = STATUS_NO_MEMORY;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_STRING DestFileName;
    HANDLE ImageFileHandle = INVALID_HANDLE_VALUE;
    HANDLE DestFileHandle = INVALID_HANDLE_VALUE;
    LPVOID Buffer = NULL;
    const ULONG BufferSize = 64 * 1024UL;

    __try {

        Buffer = VirtualAlloc( NULL, BufferSize, MEM_COMMIT, PAGE_READWRITE );
        if ( !Buffer ) {
            Status = STATUS_NO_MEMORY;
            __leave;
        }

        InitializeObjectAttributes(
            &ObjA,
            XeImageFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        //
        // Open source current image file from loader structure
        //
        Status = NtOpenFile(
                    &ImageFileHandle,
                    SYNCHRONIZE | GENERIC_READ,
                    &ObjA,
                    &IoStatusBlock,
                    FILE_SHARE_READ,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | \
                        FILE_SEQUENTIAL_ONLY
                    );

        if ( !NT_SUCCESS(Status) ) {
            __leave;
        }

        RtlInitObjectString( &DestFileName, Destination );

        InitializeObjectAttributes(
            &ObjA,
            &DestFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtCreateFile(
                    &DestFileHandle,
                    SYNCHRONIZE | GENERIC_WRITE,
                    &ObjA,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_OVERWRITE_IF,
                    FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT | \
                        FILE_SEQUENTIAL_ONLY
                    );

        if ( !NT_SUCCESS(Status) ) {
            __leave;
        }

        for (;;) {
            Status = NtReadFile(
                        ImageFileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        Buffer,
                        BufferSize,
                        NULL
                        );

            if ( Status == STATUS_PENDING ) {
                //
                // Operation must complete before return and IoStatusBlock destroyed
                //
                Status = NtWaitForSingleObject( ImageFileHandle, FALSE, NULL );
                if ( NT_SUCCESS(Status) ) {
                    Status = IoStatusBlock.Status;
                }
            }

            if ( NT_SUCCESS(Status) ) {
                Status = NtWriteFile(
                            DestFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            Buffer,
                            IoStatusBlock.Information,
                            NULL
                            );

                if ( Status == STATUS_PENDING) {
                    //
                    // Operation must complete before return and IoStatusBlock destroyed
                    //
                    Status = NtWaitForSingleObject( DestFileHandle, FALSE, NULL );
                    if ( NT_SUCCESS(Status)) {
                        Status = IoStatusBlock.Status;
                    }
                }

                if ( !NT_SUCCESS(Status) ) {
                    __leave;
                }

            } else if ( Status == STATUS_END_OF_FILE ) {
                Status = STATUS_SUCCESS;
                __leave;
            } else {
                __leave;
            }
        }

    } __finally {

        if ( Buffer ) {
            VirtualFree( Buffer, 0, MEM_RELEASE );
        }

        if ( ImageFileHandle != INVALID_HANDLE_VALUE ) {
            NtClose( ImageFileHandle );
        }

        if ( DestFileHandle != INVALID_HANDLE_VALUE ) {
            NtClose( DestFileHandle );
        }
    }

    return Status;
}

BOOL
WINAPI
RebootTestVerifyLaunchData(
    VOID
    )
/*++

    This is a helper routine used to verify the launch data retreived from
    XGetLaunchInfo

Arguments:

    None

Return Value:

    TRUE if the launch data matches the data passed to XLaunchNewImage.
    FALSE otherwise

--*/
{
    DWORD Type;
    LAUNCH_DATA Data;

    XGetLaunchInfo( &Type, &Data );
    if ( Type == LDT_TITLE && !strcmp((PCSTR)REBOOT_TEST_LAUNCH_DATA, (PCSTR)&Data) ) {
        return TRUE;
    }

    KdPrint(( "REBOOT: invalid launch data\n" ));
__asm int 3;
    return FALSE;
}

VOID
WINAPI
RebootStartTest(
    HANDLE LogHandle
    )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/
{
    ULONG State;
    DWORD FileAttributes;
    DWORD ErrorCode;
    BOOL Done = FALSE;
    NTSTATUS Status;

    KdPrint(( "REBOOT: StartTest\n" ));
    xSetComponent( LogHandle, "xapi", "Reboot APIs" );

    State = GetRebootTestState();

    while ( !Done ) {

        switch ( State ) {

        case RebootStateHDDTest:
            Status = RebootTestCopyImage(REBOOT_TEST_HDD_NT_PATH);
            if ( NT_SUCCESS(Status) ) {
                SetRebootTestState( RebootStateHDDVerify, &State );
                ErrorCode = XLaunchNewImage( REBOOT_TEST_HDD_DOS_PATH,
                                             REBOOT_TEST_LAUNCH_DATA );

                //
                // If we get here that means we couldn't reboot
                //
                KdPrint(( "REBOOT: variation %x pass\n", State ));
                SetRebootTestState( RebootStateDVDTest, &State );
            } else {
                KdPrint(( "REBOOT: unable to copy image file (%s)\n",
                          NtStatusSymbolicName(Status) ));
                SetRebootTestState( RebootStateDVDTest, &State );
            }
            break;

        case RebootStateHDDVerify:
            //
            // If we get here that means we actually reboot
            //
            RebootTestVerifyLaunchData();
            KdPrint(( "REBOOT: variation %x failed\n", State ));
            SetRebootTestState( RebootStateDVDTest, &State );
            break;

        case RebootStateDVDTest:
            SetRebootTestState( RebootStateDVDVerify, &State );
            FileAttributes = GetFileAttributes(OTEXT("d:\\default.xbe"));
            if ( FileAttributes == (DWORD)-1 ) {
                KdPrint(( "REBOOT: test blocked, no d:\\default.xbe\n" ));
            } else {
                ErrorCode = XLaunchNewImage( OTEXT("d:\\default.xbe"),
                                             REBOOT_TEST_LAUNCH_DATA );
                if ( ErrorCode != ERROR_SUCCESS ) {
                    SetRebootTestState( RebootStateEndTest, &State );
                    KdPrint(( "REBOOT: variation %x XLaunchNewImage failed (%s)\n",
                              State, WinErrorSymbolicName(ErrorCode) ));
                }
            }
            break;

        case RebootStateDVDVerify:
            RebootTestVerifyLaunchData();
            KdPrint(( "REBOOT: variation %x pass\n", State ));
            SetRebootTestState( RebootStateEndTest, &State );
            break;

        case RebootStateStartTest:
            SetRebootTestState( RebootStateHDDTest, &State );
            break;

        case RebootStateEndTest:
            Done = TRUE;
            break;

        default:
            KdPrint(( "REBOOT: invalid state\n" ));
            SetRebootTestState( RebootStateStartTest, &State );
        }
    }
}

VOID
WINAPI
RebootEndTest(
    VOID
    )
/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/
{
    KdPrint(( "REBOOT: EndTest\n" ));
    SetRebootTestState( RebootStateStartTest, 0 );

    //
    // TODO: save log from .ini to xLog file
    //
}

void __cdecl main( void )
{
    RebootStartTest( INVALID_HANDLE_VALUE );
    RebootEndTest();
    XLaunchNewImage( 0, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif


// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>



#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
    {
    ULONG DebugPrint(PCHAR Format, ...);
    __declspec(dllimport) NTSTATUS NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes);
    }


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\utils.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif

namespace Nickname {

bool CompareFirstNickname(WCHAR *nickname)
    {
    const unsigned MAXSIZE = MAX_NICKNAME * 2;
    WCHAR *buffer = new WCHAR[MAXSIZE];

    HANDLE hFind = XFindFirstNickname(FALSE, buffer, MAX_NICKNAME);
    if(hFind == INVALID_HANDLE_VALUE)
        {
        delete[] buffer;
        return false;
        }

    XFindClose(hFind);

    if(wcscmp(buffer, nickname) == 0) 
        {
        delete[] buffer;
        return true;
        }

    delete[] buffer;
    return false;
    }

bool RemoveNicknameFile(void)
    {
    OBJECT_STRING nicknameFile;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS status;
    RtlInitObjectString(&nicknameFile, "\\Device\\Harddisk0\\partition1\\UDATA\\NICKNAME.XBN");
    InitializeObjectAttributes(&Obja, &nicknameFile, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtDeleteFile(&Obja);
    if(!NT_SUCCESS(status)) 
        {
        SetLastError(RtlNtStatusToDosError(status));
        return false;
        }

    return true;
    }

} // namespace Nickname
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\utils.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

namespace Nickname
    {
    bool CompareFirstNickname(WCHAR *nickname);
    bool RemoveNicknameFile(void);
    } // namespace Nickname
#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\GetSoundtrackSongInfo.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GetSoundtrackSongInfo.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "Soundtrack.h"

/*

Routine Description:

    Tests the GetSoundtrackSongInfo API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

Notes:
    typedef struct _XSOUNDTRACK_DATA
        {
        UINT    uSoundtrackId;
        UINT    uSongCount;
        UINT    uSoundtrackLength;
        WCHAR   szName[MAX_SOUNDTRACK_NAME];
        } XSOUNDTRACK_DATA, *PXSOUNDTRACK_DATA;

*/
DWORD Soundtrack::XGetSoundtrackSongInfo_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL
    XGetSoundtrackSongInfo(
        IN DWORD dwSoundtrackId,
        IN UINT uIndex,
        OUT PDWORD pdwSongId,
        OUT PDWORD pdwSongLength,
        OUT OPTIONAL PWSTR szNameBuffer,
        IN UINT uBufferSize
        );
    */
    xSetFunctionName(hLog, "XGetSoundtrackSongInfo");

    HANDLE hFind;
    XSOUNDTRACK_DATA data;
    DWORD songID;
    DWORD songLength;
    WCHAR *songname = new WCHAR[1024];
    if(!songname)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    unsigned i;
    unsigned foundItems;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("All Songs")
        {
        hFind = XFindFirstSoundtrack(&data);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "XFindFirstSoundtrack (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "XFindFirstSoundtrack (ec: %ld)", GetLastError());
            break;
            }

        foundItems = 0;
        DebugPrint("  ---------------\r\n");
        do
            {
            ++foundItems;
            DebugPrint("  %2u %2u '%ws'\r\n", data.uSoundtrackId, data.uSongCount, data.szName);
            for(i=0; i<data.uSongCount; i++)
                {
                if(XGetSoundtrackSongInfo(data.uSoundtrackId, i, &songID, &songLength, songname, 1024) == TRUE)
                    {
                    DebugPrint("  %ws\r\n", songname);
                    TESTPASS(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
                    }
                else
                    {
                    DebugPrint("  Fail\r\n");
                    TESTFAIL(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
                    }
                }
            } while(XFindNextSoundtrack(hFind, &data) == TRUE);
        
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("szNameBuffer==NULL (uBufferSize==1024)")
        {
        if(XGetSoundtrackSongInfo(1, 0, &songID, &songLength, NULL, 1024) == TRUE)
            TESTPASS(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("szNameBuffer==NULL (uBufferSize==0)")
        {
        if(XGetSoundtrackSongInfo(1, 0, &songID, &songLength, NULL, 0) == TRUE)
            TESTPASS(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("uBufferSize==~0")
        {
        if(XGetSoundtrackSongInfo(1, 0, &songID, &songLength, songname, ~0) == TRUE)
            TESTPASS(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        } ENDTESTCASE;




    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Invalid entry 0xEFFF.0xEFFF")
        {
        if(XGetSoundtrackSongInfo(0xEFFF, 0xEFFF, &songID, &songLength, songname, 1024) == FALSE)
            TESTPASS(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Invalid entry 1.0xEFFF")
        {
        if(XGetSoundtrackSongInfo(1, 0xEFFF, &songID, &songLength, songname, 1024) == FALSE)
            TESTPASS(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Invalid entry 0xEFFF.0")
        {
        if(XGetSoundtrackSongInfo(0xEFFF, 0, &songID, &songLength, songname, 1024) == FALSE)
            TESTPASS(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    /*
    TESTCASE("pdwSongId == NULL ")
        {
        if(XGetSoundtrackSongInfo(1, 0, NULL, &songLength, songname, 1024) == FALSE)
            TESTPASS(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XGetSoundtrackSongInfo (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    */

    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("SOUNDTRACK(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 100000;
        unsigned failures = 0;
        for(i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }

            if(XGetSoundtrackSongInfo(1, 0, &songID, &songLength, songname, 1024) != TRUE)
                ++failures;
            }
        if(failures)
            TESTFAIL(hLog, "Mini stress failures: %u", failures);
        else
            TESTPASS(hLog, "Mini stress failures: %u", failures);
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    delete[] songname;
    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\soundtrack.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    soundtrack.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/

typedef DWORD (*APITEST_FUNC)(HANDLE hLog, DWORD ThreadID);

namespace Soundtrack
    {
    //
    //  XAPI soundtrack Tests
    //
    extern DWORD XFindSoundtrack_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD XGetSoundtrackSongInfo_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD XOpenSoundtrackSong_Test(HANDLE hLog, DWORD ThreadID);
    } // namespace Soundtrack
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\findsoundtrack.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    FindSoundtrack.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "Soundtrack.h"

/*

Routine Description:

    Tests the XFindFirstSoundtrack / XFindNextSoundtrack / XFindClose APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

Notes:
    typedef struct {
        UINT    uSoundtrackId;
        UINT    uSongCount;
        WCHAR   szName[MAX_SOUNDTRACK_NAME];
        } XSOUNDTRACK_DATA, *PSOUNDTRACK_DATA;

*/
DWORD Soundtrack::XFindSoundtrack_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HANDLE
    XFindFirstSoundtrack(
        OUT PSOUNDTRACK_DATA Data
        );

    BOOL
    XFindNextSoundtrack(
        IN HANDLE FindHandle
        OUT PSOUNDTRACK_DATA Data
        );

    BOOL XFindClose(
        IN HANDLE hFind);
    */
    xSetFunctionName(hLog, "XFindSoundtrack");

    HANDLE hFind;
    XSOUNDTRACK_DATA data;
    unsigned i;
    unsigned foundItems;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("FindSoundtrack")
        {
        hFind = XFindFirstSoundtrack(&data);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "XFindFirstSoundtrack (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "XFindFirstSoundtrack (ec: %ld)", GetLastError());
            break;
            }

        foundItems = 0;
        DebugPrint("  ---------------\r\n");
        do
            {
            ++foundItems;
            DebugPrint("  %2u %2u '%ws'\r\n", data.uSoundtrackId, data.uSongCount, data.szName);
            } while(XFindNextSoundtrack(hFind, &data) == TRUE);
        
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;




    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("XFindClose(NULL)")
        {
        if(XFindClose(hNull) == FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("XFindClose(INVALID_HANDLE_VALUE)")
        {
        if(XFindClose(INVALID_HANDLE_VALUE) == FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("XFindClose(bogus)")
        {
        if(XFindClose(hBogus) == FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("XFindClose the handle twice")
        {
        hFind = FindFirstNickname(FALSE, nickname, MAX_NICKNAME);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstNickname (ec: %ld)", GetLastError());
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        if(XFindClose(hFind) == FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    */


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\OpenSoundtrackSong.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XOpenSoundtrackSong.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "Soundtrack.h"

/*

Routine Description:

    Tests the XOpenSoundtrackSong API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

*/
DWORD Soundtrack::XOpenSoundtrackSong_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HANDLE
    XOpenSoundtrackSong(
        IN DWORD dwSongId,
        IN BOOL fAsyncMode
        );
    */
    xSetFunctionName(hLog, "XOpenSoundtrackSong");

    HANDLE hFile;
    HANDLE hFind;
    XSOUNDTRACK_DATA data;
    DWORD songID;
    DWORD songLength;
    unsigned i;
    unsigned foundItems;


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("All Songs")
        {
        hFind = XFindFirstSoundtrack(&data);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "XFindFirstSoundtrack (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "XFindFirstSoundtrack (ec: %ld)", GetLastError());
            break;
            }

        foundItems = 0;
        DebugPrint("  ---------------\r\n");
        do
            {
            ++foundItems;
            DebugPrint("  %2u %2u '%ws'\r\n", data.uSoundtrackId, data.uSongCount, data.szName);
            for(i=0; i<data.uSongCount; i++)
                {
                XGetSoundtrackSongInfo(data.uSoundtrackId, i, &songID, &songLength, NULL, 0);
                hFile = XOpenSoundtrackSong(songID, FALSE);
                if(hFile != INVALID_HANDLE_VALUE)
                    {
                    TESTPASS(hLog, "XOpenSoundtrackSong Non-Async (ec: %ld)", GetLastError());
                    CloseHandle(hFile);
                    }
                else
                    TESTFAIL(hLog, "XOpenSoundtrackSong Non-Async (ec: %ld)", GetLastError());

                hFile = XOpenSoundtrackSong(songID, TRUE);
                if(hFile != INVALID_HANDLE_VALUE)
                    {
                    TESTPASS(hLog, "XOpenSoundtrackSong Async (ec: %ld)", GetLastError());
                    CloseHandle(hFile);
                    }
                else
                    TESTFAIL(hLog, "XOpenSoundtrackSong Async (ec: %ld)", GetLastError());
                }
            } while(XFindNextSoundtrack(hFind, &data) == TRUE);
        
        if(XFindClose(hFind) != FALSE)
            TESTPASS(hLog, "XFindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "XFindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Invalid dwSongId ~0")
        {
        hFile = XOpenSoundtrackSong(~0, FALSE);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "XOpenSoundtrackSong Non-Async (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "XOpenSoundtrackSong Non-Async (ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("Invalid dwSongId 0xEFFF")
        {
        hFile = XOpenSoundtrackSong(0xEFFF, FALSE);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "XOpenSoundtrackSong Non-Async (ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "XOpenSoundtrackSong Non-Async (ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;

    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("SOUNDTRACK(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 100000;
        unsigned failures = 0;
        for(i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }

            hFile = XOpenSoundtrackSong(songID, FALSE);
            if(hFile == INVALID_HANDLE_VALUE)
                ++failures;
            else
                CloseHandle(hFile);
            }
        if(failures)
            TESTFAIL(hLog, "Mini stress failures: %u", failures);
        else
            TESTPASS(hLog, "Mini stress failures: %u", failures);
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\xcalcsig\xmain.c ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for XCalculateSignature* APIs

Module Name:

    xmain.c

--*/

#include <xapip.h>
#include <winbasep.h>
#include <xbox.h>
#include <xcrypt.h>
#include <xdbg.h>
#include <stdio.h>
#include <stdlib.h>

ULONG DebugPrint(PCHAR Format, ...);

//
// Use this to control whether to test romable
//
BOOL g_fTestRoamable = TRUE;

void DumpRow(PBYTE pb1, DWORD cbb1, PBYTE pb2, DWORD cbb2)
{
	BYTE	rgbRow[82];
	BYTE	b;
	DWORD	i;

	memset(rgbRow, ' ', 79);
	rgbRow[79] = '\r';
	rgbRow[80] = '\n';
	rgbRow[81] = '\0';

	for (i = 0; i < 16; i++)
	{
		if (cbb1 > i)
		{
			if ((cbb2 <= i) || (pb1[i] != pb2[i]))
				rgbRow[i*2] = '*';
			else
				rgbRow[i*2] = ' ';

			rgbRow[i*2 + 1] = ((pb1[i] >= 32) && (pb1[i] != '%'))?pb1[i]:'#';
		}

		if (cbb2 > i)
		{
			if ((cbb1 <= i) || (pb1[i] != pb2[i]))
				rgbRow[i*2 + 40] = '*';
			else
				rgbRow[i*2 + 40] = ' ';
			rgbRow[i*2 + 41] = ((pb2[i] >= 32) && (pb2[i] != '%'))?pb2[i]:'#';
		}
	}

	DebugPrint(rgbRow);
	return;
}	
	
void DumpBuffers(PBYTE pb1, DWORD cbb1, PBYTE pb2, DWORD cbb2)
{
	while ((cbb1 > 0) || (cbb2 > 0))
	{
		DumpRow(pb1, cbb1, pb2, cbb2);
		pb1 += 16;
		pb2 += 16;
		if (cbb1 >= 16)
			cbb1 -= 16;
		else
			cbb1 = 0;
			
		if (cbb2 >= 16)
			cbb2 -= 16;
		else
			cbb2 = 0;
	}
	return;	
}

HRESULT GenerateSignatureFromRandomChunks(
			PBYTE	pbBuffer, 
			DWORD	dwLen, 
			PXCALCSIG_SIGNATURE pSignature
			)
{
	HANDLE			hCalcSig = INVALID_HANDLE_VALUE;
	ULARGE_INTEGER	uliProcess;
	DWORD			dwError;

	hCalcSig = XCalculateSignatureBegin(
				g_fTestRoamable?0:XCALCSIG_FLAG_NON_ROAMABLE);
	if (hCalcSig == INVALID_HANDLE_VALUE)
	{
		RIP("Cannot init calcsig");
		return(HRESULT_FROM_WIN32(GetLastError()));
	}
	
	while (dwLen)
	{
		if (dwLen > 20000)
		{
			do {
				uliProcess.QuadPart = rand();
				uliProcess.QuadPart *= dwLen;
				uliProcess.QuadPart /= RAND_MAX;
			} while (uliProcess.QuadPart == 0);
		}	
		else
			uliProcess.QuadPart = dwLen;

		dwError = XCalculateSignatureUpdate(hCalcSig, pbBuffer, uliProcess.u.LowPart);
		if (dwError != ERROR_SUCCESS)
		{
			RIP("Cannot update calcsig");
			return(HRESULT_FROM_WIN32(dwError));
		}

		dwLen -= uliProcess.u.LowPart;
		pbBuffer += uliProcess.u.LowPart;
	}

	dwError = XCalculateSignatureEnd(hCalcSig, pSignature);
	if (dwError != ERROR_SUCCESS)
	{
		RIP("Cannot end calcsig");
		return(HRESULT_FROM_WIN32(dwError));
	}

	return(S_OK);
}

#define DATA_FILE		"t:\\test.dat"

//======================== The main function
void __cdecl main()
{
	HRESULT				hr;
	HANDLE				hFile;
	LARGE_INTEGER		liFileSize;
	ULARGE_INTEGER		uliOffset;
	ULARGE_INTEGER		uliIterations;
	BYTE				bOldValue;
	BYTE				bNewValue;
	PBYTE				pbReference = NULL;
	PBYTE				pbBuffer = NULL;
	DWORD				dwLen, dwRead, i;
	XCALCSIG_SIGNATURE	xcsReference;
	XCALCSIG_SIGNATURE	xcsSignature;

	uliIterations.QuadPart = 0;

	// Break here
	_asm int 3;
	
	// Read in the test file
	hFile = CreateFile(DATA_FILE, 
				GENERIC_READ, 
				FILE_SHARE_READ, NULL,
				OPEN_EXISTING, 
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		RIP("Cannot open file");
	}

	if (!GetFileSizeEx(hFile, &liFileSize))
	{
		RIP("Cannot get file size");
	}

	dwLen = liFileSize.u.LowPart;
	pbBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, dwLen);
	if (!pbBuffer)
	{
		RIP("Cannot allocatre memory");
	}

	if (!ReadFile(hFile, pbBuffer, dwLen, &dwRead, NULL) ||
		(dwRead != dwLen))
	{
		RIP("Cannot read data file");
	}

	CloseHandle(hFile);

	// This is the non-roamable case, we use the ROM to calculate
	// the reference so we have a second opinion
	XcHMAC(XeImageHeader()->Certificate->SignatureKey, 
				XC_SYMMETRIC_KEY_SIZE,
				pbBuffer, dwLen, NULL, 0, 
				g_fTestRoamable?xcsReference.Signature:xcsSignature.Signature);
	if (!g_fTestRoamable)
	{
		// Non-roamable, run it through the HMAC again
		XcHMAC((LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
					xcsSignature.Signature, XCALCSIG_SIGNATURE_SIZE, 
					NULL, 0, 
					xcsReference.Signature);
	}

/*
	hr = GenerateSignatureFromRandomChunks(
				pbBuffer, dwLen, &xcsReference);
	if (FAILED(hr))
	{
		RIP("Cannot generate signature");
	}
*/	

	// Keep generateing signature from random chunks, and make sure 
	// all come to the same signature
	while (1)
	{
		// Do a straight run
		hr = GenerateSignatureFromRandomChunks(
					pbBuffer, dwLen, &xcsSignature);
		if (FAILED(hr))
		{
			RIP("Cannot generate signature");
		}

		if (memcmp(xcsReference.Signature, 
					xcsSignature.Signature, XCALCSIG_SIGNATURE_SIZE) != 0)
		{
			DumpBuffers(xcsReference.Signature, XCALCSIG_SIGNATURE_SIZE,
						xcsSignature.Signature, XCALCSIG_SIGNATURE_SIZE);
			RIP("Signatures don't match");
		}

		// Now corrupt the data randomly and make sure the
		// signature validation fails.
		for (i = 0; i < 100; i++)
		{
			uliOffset.QuadPart = rand();
			uliOffset.QuadPart *= (liFileSize.QuadPart - 1);
			uliOffset.QuadPart /= RAND_MAX;

			// Save the old value and corrupt the data
			bOldValue = pbBuffer[uliOffset.QuadPart];
			
			do {
				bNewValue = (BYTE)(rand() & 0xff);
			} while (bNewValue == bOldValue);
			
			pbBuffer[uliOffset.QuadPart] = bNewValue;

			// Generate signature with corrupt data
			hr = GenerateSignatureFromRandomChunks(
						pbBuffer, dwLen, &xcsSignature);
			if (FAILED(hr))
			{
				RIP("Cannot generate signature");
			}

			if (memcmp(xcsReference.Signature, 
						xcsSignature.Signature, XCALCSIG_SIGNATURE_SIZE) == 0)
			{
				DumpBuffers(xcsReference.Signature, XCALCSIG_SIGNATURE_SIZE,
							xcsSignature.Signature, XCALCSIG_SIGNATURE_SIZE);
				RIP("Signatures of corrupt data match!");
			}			

			// Restore the original value
			pbBuffer[uliOffset.QuadPart] = bOldValue;
		}

		uliIterations.QuadPart++;
	}

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xapi\soundtrack\soundtrack.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    soundtrack.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xlog.h>
#include "soundtrack.h"
#include "commontest.h"
#include "utils.h"
#include "xtestlib.h"

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

static ULONG ThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE SoundtrackHeapHandle;


BOOL WINAPI SoundtrackDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        SoundtrackHeapHandle = HeapCreate(0, 0, 0);

        if(!SoundtrackHeapHandle)
            {
            OutputDebugString(L"SOUNDTRACK: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(SoundtrackHeapHandle)
            {
            HeapDestroy(SoundtrackHeapHandle);
            }
        }

    return TRUE;
    }

static bool wcistrstr(WCHAR *string, WCHAR *substr, size_t len=0)
    {
    if(!string || ! substr) return false;
    if(!*string) return false;
    if(!len) len = wcslen(substr);
    if(_wcsnicmp(string, substr, len) == 0) return true;

    return wcistrstr(string+1, substr, len);
    }


/*

Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    DWORD threadNumber - sequential number of the thread
    DWORD loops - # of times to run test
    WCHAR* testname - specific name of a test to run

Return Value:

    DWORD

*/
namespace Soundtrack {
static DWORD RunAll(HANDLE hLog, DWORD threadNumber, DWORD loops, WCHAR *testname)
    {
    Sleep(threadNumber*200); // stagger the thread's execution a bit

    struct APIFUNCT
        {
        APITEST_FUNC f;
        WCHAR *name;
        };
    #define BUILTAPISTRUCT(n) { n , L#n }

    // Define all the API tests
    APIFUNCT testlist[] =
        {
        /*
        */
        //BUILTAPISTRUCT(Soundtrack::XSetNickname_Test),
        BUILTAPISTRUCT(Soundtrack::XFindSoundtrack_Test),
        BUILTAPISTRUCT(Soundtrack::XGetSoundtrackSongInfo_Test),
        BUILTAPISTRUCT(Soundtrack::XOpenSoundtrackSong_Test),
        /*
        */
        };

    bool runAll = _wcsicmp(testname, L"(all)") == 0 ? true : false;

    // Run the suite of tests
    for(DWORD i=0; i<loops; i++)
        {
        // run each test
        for(unsigned j=0; j<ARRAYSIZE(testlist); j++)
            {
            if(runAll || wcistrstr(testlist[j].name, testname))
                {
                xLog(hLog, XLL_INFO, "%ws() ******************************************", testlist[j].name);
                //LogResourceStatus(hLog, false);
                DebugPrint("SOUNDTRACK(%d): Entering %ws()\n", threadNumber, testlist[j].name);
                testlist[j].f(hLog, threadNumber);
                }
            }
        }

    return 0;
    }
    } // namespace Soundtrack


/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI SoundtrackStartTest(HANDLE hLog)
    {
    DWORD ID = 0;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &ThreadID);


    // test settings
    const int buffLen = 1024;
    WCHAR testname[buffLen];
    DWORD loops;


    // Pull out internal INI file settings
    GetProfileString(L"soundtrack", L"testname", L"(all)", testname, buffLen);
    loops = GetProfileInt(L"soundtrack", L"loops", 1);


    xSetOwnerAlias(hLog, "jpoley");
    xSetComponent(hLog, "XAPI", "Soundtrack");
    DebugPrint("SOUNDTRACK(%d): **************************************************************\n", ID);
    DebugPrint("SOUNDTRACK(%d): Entering StartTest()\n", ID);
    DebugPrint("SOUNDTRACK(%d): Internal INI Settings:\n", ID);
    DebugPrint("  loops=%lu\n", loops);
    DebugPrint("  testname=%ws\n", testname);


    switch(ID)
        {
        case 0:
        case 1:
        default:
            Soundtrack::RunAll(hLog, ID, loops, testname);
            break;
        }


    DebugPrint("SOUNDTRACK(%d): Leaving StartTest()\n", ID);
    DebugPrint("SOUNDTRACK(%d): **************************************************************\n", ID);
    xSetOwnerAlias(hLog, NULL);
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI SoundtrackEndTest(void)
    {
    ThreadID = 0;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( soundtrack )
#pragma data_seg()

BEGIN_EXPORT_TABLE( soundtrack )
    EXPORT_TABLE_ENTRY( "StartTest", SoundtrackStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SoundtrackEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", SoundtrackDllMain )
END_EXPORT_TABLE( soundtrack )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\bind.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module bind:

  bind.c

Abstract:

  This modules tests bind

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define NAME_ANY       0
#define NAME_ANYADDR   1
#define NAME_ANYPORT   2
#define NAME_LOCAL     3
#define NAME_LOOPBACK  4
#define NAME_BROADCAST 5
#define NAME_MULTICAST 6
#define NAME_UNAVAIL   7
#define NAME_BAD       8
#define NAME_NULL      9



typedef struct _BIND_TABLE {
    CHAR         szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL         bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    DWORD        dwSocket1;                               // dwSocket1 indicates the first socket to be created
    DWORD        dwSocket2;                               // dwSocket2 indicates the second socket to be created
    BOOL         bBind;                                   // bBind indicates if socket is bound
    BOOL         bAddrInUse;                              // bAddrInUse indicates if address is in use
    BOOL         bReuseAddr;                              // bReuseAddr indicates if address reuse is enabled
    DWORD        dwName;                                  // dwName indicates the address
    int          bindnamelen;                             // bindnamelen is the length of the bindname buffer
    int          iReturnCode;                             // iReturnCode is the return code of bind
    int          iLastError;                              // iLastError is the error code if the operation failed
    BOOL         bRIP;                                    // Specifies a RIP test case
} BIND_TABLE, *PBIND_TABLE;

static BIND_TABLE bindTable[] =
{
    { "9.1 Not Initialized",       FALSE, SOCKET_INVALID_SOCKET,      0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "9.2 s = INT_MIN",           TRUE,  SOCKET_INT_MIN,             0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "9.3 s = -1",                TRUE,  SOCKET_NEG_ONE,             0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "9.4 s = 0",                 TRUE,  SOCKET_ZERO,                0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "9.5 s = INT_MAX",           TRUE,  SOCKET_INT_MAX,             0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "9.6 s = INVALID_SOCKET",    TRUE,  SOCKET_INVALID_SOCKET,      0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "9.7 Bcast Address TCP",     TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_BROADCAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.8 Bcast Address UDP",     TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_BROADCAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.9 Mcast Address TCP",     TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_MULTICAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.10 Mcast Address UDP",    TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_MULTICAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.11 Unavail Address TCP",  TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_UNAVAIL,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.12 Unavail Address UDP",  TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_UNAVAIL,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.13 Bad Address TCP",      TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_BAD,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.14 Bad Address UDP",      TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_BAD,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.15 NULL Address TCP",     TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_NULL,      sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.16 NULL Address UDP",     TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_NULL,      sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.17 Local Address TCP",    TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_LOCAL,     sizeof(SOCKADDR_IN),     0,            WSAEFAULT,         TRUE  },
    { "9.18 Local Address UDP",    TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_LOCAL,     sizeof(SOCKADDR_IN),     0,            WSAEFAULT,         TRUE  },
    { "9.19 Loopback Address TCP", TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            WSAEFAULT,         TRUE  },
    { "9.20 Loopback Address UDP", TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            WSAEFAULT,         TRUE  },
    { "9.21 Any Address TCP",      TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.22 Any Address UDP",      TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.23 Any Port TCP",         TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     0,            WSAEFAULT,         TRUE  },
    { "9.24 Any Port UDP",         TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     0,            WSAEFAULT,         TRUE  },
    { "9.25 Any TCP",              TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.26 Any UDP",              TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.27 Bound Socket TCP",     TRUE,  SOCKET_TCP,                 0,          TRUE,  FALSE, FALSE, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "9.28 Bound Socket UDP",     TRUE,  SOCKET_UDP,                 0,          TRUE,  FALSE, FALSE, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "9.29 Address In Use TCP",   TRUE,  SOCKET_TCP,                 SOCKET_TCP, FALSE, TRUE,  FALSE, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRINUSE,     FALSE },
    { "9.30 Address In Use UDP",   TRUE,  SOCKET_UDP,                 SOCKET_UDP, FALSE, TRUE,  FALSE, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRINUSE,     FALSE },
    { "9.31 Reuse Address TCP",    TRUE,  SOCKET_TCP,                 SOCKET_TCP, FALSE, TRUE,  TRUE,  NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.32 Reuse Address UDP",    TRUE,  SOCKET_UDP,                 SOCKET_UDP, FALSE, TRUE,  TRUE,  NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.33 TCP and UDP",          TRUE,  SOCKET_TCP,                 SOCKET_UDP, FALSE, FALSE, FALSE, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.34 Large Length TCP",     TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "9.35 Large Length UDP",     TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "9.36 Exact Length TCP",     TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.37 Exact Length UDP",     TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "9.38 Small Length TCP",     TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.39 Small Length UDP",     TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.40 Zero Length TCP",      TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.41 Zero Length UDP",      TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.42 Negative Length TCP",  TRUE,  SOCKET_TCP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.43 Negative Length UDP",  TRUE,  SOCKET_UDP,                 0,          FALSE, FALSE, FALSE, NAME_ANY,       -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "9.44 Closed Socket TCP",    TRUE,  SOCKET_TCP | SOCKET_CLOSED, 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "9.45 Closed Socket UDP",    TRUE,  SOCKET_UDP | SOCKET_CLOSED, 0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "9.46 Not Initialized",      FALSE, SOCKET_INVALID_SOCKET,      0,          FALSE, FALSE, FALSE, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define bindTableCount (sizeof(bindTable) / sizeof(BIND_TABLE))



VOID
bindTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests bind

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR           lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR           lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD           dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL            bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA         WSAData;

    // HostXnAddr is the host xnet address
    XNADDR          HostXnAddr;
    // hostaddr is the local host address
    u_long          hostaddr = 0;

    // sSocket1 is the first socket descriptor
    SOCKET          sSocket1;
    // sSocket2 is the second socket descriptor
    SOCKET          sSocket2;

    // bindport1 is the first bind port
    u_short         bindport1;
    // bindport2 is the second bind port
    u_short         bindport2;

    // localname is the local address
    SOCKADDR_IN     localname;

    // bException indicates if an exception occurred
    BOOL            bException;
    // iReturnCode is the return code of the operation
    int             iReturnCode;
    // dwReturnCode is the return code of the operation
    DWORD           dwReturnCode;
    // iLastError is the error code if the operation failed
    int             iLastError;

    // szFunctionName is the function name
    CHAR            szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "bind v%04x", WinsockVersion);
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_bind+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_bind-");

    // Initialize the net subsystem
    XNetAddRef();

    // Get the local xnaddr
    do {
        dwReturnCode = XNetGetTitleXnAddr(&HostXnAddr);
        if (0 == dwReturnCode) {
            Sleep(SLEEP_ZERO_TIME);
        }
    } while (0 == dwReturnCode);
    hostaddr = HostXnAddr.ina.s_addr;

    // Get the bind port for testing
    bindport1 = 65533;
    bindport2 = 65532;

    for (dwTableIndex = 0; dwTableIndex < bindTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, bindTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, bindTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != bindTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, bindTable[dwTableIndex].szVariationName);

        // Check the state of Winsock
        if (bWinsockInitialized != bindTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == bindTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = bindTable[dwTableIndex].bWinsockInitialized;
        }

        // Create socket 2
        sSocket2 = INVALID_SOCKET;
        if (0 != (SOCKET_TCP & bindTable[dwTableIndex].dwSocket2)) {
            sSocket2 = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & bindTable[dwTableIndex].dwSocket2)) {
            sSocket2 = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Bind socket 2
        if (INVALID_SOCKET != sSocket2) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;

            if (TRUE == bindTable[dwTableIndex].bAddrInUse) {
                localname.sin_port = htons(bindport1);
            }
            else {
                localname.sin_port = htons(bindport2);
            }

            bind(sSocket2, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Create socket 1
        sSocket1 = INVALID_SOCKET;
        if (SOCKET_INT_MIN == bindTable[dwTableIndex].dwSocket1) {
            sSocket1 = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == bindTable[dwTableIndex].dwSocket1) {
            sSocket1 = -1;
        }
        else if (SOCKET_ZERO == bindTable[dwTableIndex].dwSocket1) {
            sSocket1 = 0;
        }
        else if (SOCKET_INT_MAX == bindTable[dwTableIndex].dwSocket1) {
            sSocket1 = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == bindTable[dwTableIndex].dwSocket1) {
            sSocket1 = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & bindTable[dwTableIndex].dwSocket1)) {
            sSocket1 = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & bindTable[dwTableIndex].dwSocket1)) {
            sSocket1 = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Bind socket 1
        if (TRUE == bindTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(bindport1);

            bind(sSocket1, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Enable address reuse
        if (TRUE == bindTable[dwTableIndex].bReuseAddr) {
            setsockopt(sSocket1, SOL_SOCKET, SO_REUSEADDR, (char *) &bindTable[dwTableIndex].bReuseAddr, sizeof(bindTable[dwTableIndex].bReuseAddr));
        }

        // Set the bind name
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;

        if (NAME_ANYADDR == bindTable[dwTableIndex].dwName) {
            localname.sin_port = htons(bindport1);
        }
        else if (NAME_ANYPORT == bindTable[dwTableIndex].dwName) {
            localname.sin_addr.s_addr = hostaddr;
        }
        else if (NAME_LOCAL == bindTable[dwTableIndex].dwName) {
            localname.sin_addr.s_addr = hostaddr;
            localname.sin_port = htons(bindport1);
        }
        else if (NAME_LOOPBACK == bindTable[dwTableIndex].dwName) {
            localname.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            localname.sin_port = htons(bindport1);
        }
        else if (NAME_BROADCAST == bindTable[dwTableIndex].dwName) {
            localname.sin_addr.s_addr = htonl(INADDR_BROADCAST);
            localname.sin_port = htons(bindport1);
        }
        else if (NAME_MULTICAST == bindTable[dwTableIndex].dwName) {
            localname.sin_addr.s_addr = inet_addr("224.0.0.0");
            localname.sin_port = htons(bindport1);
        }
        else if (NAME_UNAVAIL == bindTable[dwTableIndex].dwName) {
            localname.sin_addr.s_addr = inet_addr("127.0.0.0");
            localname.sin_port = htons(bindport1);
        }
        else if (NAME_BAD == bindTable[dwTableIndex].dwName) {
            localname.sin_family = AF_UNIX;
            localname.sin_addr.s_addr = hostaddr;
            localname.sin_port = htons(bindport1);
        }

        bException = FALSE;

        // Close socket 1
        if (0 != (SOCKET_CLOSED & bindTable[dwTableIndex].dwSocket1)) {
            closesocket(sSocket1);
        }

        __try {
            // Call bind
            iReturnCode = bind(sSocket1, (NAME_NULL != bindTable[dwTableIndex].dwName) ? (SOCKADDR *) &localname : NULL, bindTable[dwTableIndex].bindnamelen);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == bindTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "bind RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "bind caused an exception - ec = 0x%08x", GetExceptionCode());
            }

            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == bindTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "bind did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == bindTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != bindTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "iLastError - EXPECTED: %u; RECEIVED: %u", bindTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "bind returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == bindTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "bind returned non-SOCKET_ERROR");
            }
            else {
                xLog(hLog, XLL_PASS, "bind succeeded");
            }
        }

        // Close socket 2
        if (INVALID_SOCKET != sSocket2) {
            closesocket(sSocket2);
        }

        // Close socket 1
        if (0 == (SOCKET_CLOSED & bindTable[dwTableIndex].dwSocket1)) {
            if ((0 != (SOCKET_TCP & bindTable[dwTableIndex].dwSocket1)) || (0 != (SOCKET_UDP & bindTable[dwTableIndex].dwSocket1))) {
                closesocket(sSocket1);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\client.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.c

Abstract:

  Entry points for xnetapi.dll

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

VOID
WINAPI
StartTest(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test entry point

Arguments:

  hLog - handle to the xLog log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is the mem object
    HANDLE  hMemObject = INVALID_HANDLE_VALUE;

    // lpszNetsyncRemoteNt is a pointer to the remote nt netsync server
    LPSTR   lpszNetsyncRemoteNt = NULL;
    // lpszNetsyncRemoteXbox is a pointer to the remote xbox netsync server
    LPSTR   lpszNetsyncRemoteXbox = NULL;

    // lpszAPITest is a pointer to the list of APIs to test
    LPSTR   lpszAPITest = NULL;
    // lpszAPISkip is a pointer to the list of APIs to skip
    LPSTR   lpszAPISkip = NULL;
    // lpszVersions is a pointer to the list of versions to test
    LPSTR   lpszVersions = NULL;
    // lpszRemotes is a pointer to the list of remotes to test vs.
    LPSTR   lpszRemotes = NULL;

    // bVersion11 is a flag to specify testing of Winsock 1.1
    BOOL    bVersion11 = TRUE;
    // bVersion22 is a flag to specify testing of Winsock 2.2
    BOOL    bVersion22 = TRUE;

    // bRemoteNt is a flag to specify remote testing vs. nt
    BOOL    bRemoteNt = TRUE;
    // bRemoteXbox is a flag to specify remote testing vs. xbox
    BOOL    bRemoteXbox = TRUE;

    // bRIPs is a flag to specify RIP testing
    BOOL    bRIPs = FALSE;



    // Create the private heap
    hMemObject = xMemCreate();
    if (INVALID_HANDLE_VALUE == hMemObject) {
        return;
    }

    // Set the component and subcomponent
    xSetComponent(hLog, "Network", "XNet");

    // Get the remote netsync addr
    lpszNetsyncRemoteNt = GetIniString(hMemObject, "xnetapi", "NetsyncRemoteNt");
    lpszNetsyncRemoteXbox = GetIniString(hMemObject, "xnetapi", "NetsyncRemoteXbox");

    // Get the APIs
    lpszAPITest = GetIniSection(hMemObject, "xnetapi_apis+");
    lpszAPISkip = GetIniSection(hMemObject, "xnetapi_apis-");

    // Get the versions
    lpszVersions = GetIniSection(hMemObject, "xnetapi_versions");
    if (NULL != lpszVersions) {
        // Check for version 1.1
        bVersion11 = FindString(lpszVersions, "1.1");

        // Check for version 2.2
        bVersion22 = FindString(lpszVersions, "2.2");
    }

    // Get the remotes
    lpszRemotes = GetIniSection(hMemObject, "xnetapi_remotes");
    if (NULL != lpszRemotes) {
        // Check for remote nt
        bRemoteNt = FindString(lpszRemotes, "nt");

        // Check for remote xbox
        bRemoteXbox = FindString(lpszRemotes, "xbox");
    }

    // Get the RIPs
    bRIPs = (BOOL) GetProfileIntA("xnetapi", "RIPs", 0);

    // Test htonl()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "htonl"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "htonl")))) {
        htonlTest(hLog, hMemObject, bRIPs);
    }

    // Test htons()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "htons"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "htons")))) {
        htonsTest(hLog, hMemObject, bRIPs);
    }

    // Test ntohl()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "ntohl"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "ntohl")))) {
        ntohlTest(hLog, hMemObject, bRIPs);
    }

    // Test ntohs()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "ntohs"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "ntohs")))) {
        ntohsTest(hLog, hMemObject, bRIPs);
    }

    // Test inet_addr()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "inet_addr"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "inet_addr")))) {
        inet_addrTest(hLog, hMemObject, bRIPs);
    }

    // Test WSAStartup()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "WSAStartup"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "WSAStartup")))) {
        WSAStartupTest(hLog, hMemObject, bRIPs);
    }

    // Test WSACleanup()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "WSACleanup"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "WSACleanup")))) {
        if (TRUE == bVersion11) {
            WSACleanupTest(hLog, hMemObject, MAKEWORD(1, 1), bRIPs);
        }

        if (TRUE == bVersion22) {
            WSACleanupTest(hLog, hMemObject, MAKEWORD(2, 2), bRIPs);
        }
    }

    // Test socket()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "socket"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "socket")))) {
        if (TRUE == bVersion11) {
            socketTest(hLog, hMemObject, MAKEWORD(1, 1), bRIPs);
        }

        if (TRUE == bVersion22) {
            socketTest(hLog, hMemObject, MAKEWORD(2, 2), bRIPs);
        }
    }

    // Test bind()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "bind"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "bind")))) {
        if (TRUE == bVersion11) {
            bindTest(hLog, hMemObject, MAKEWORD(1, 1), bRIPs);
        }

        if (TRUE == bVersion22) {
            bindTest(hLog, hMemObject, MAKEWORD(2, 2), bRIPs);
        }
    }

    // Test listen()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "listen"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "listen")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                listenTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                listenTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                listenTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                listenTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test accept()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "accept"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "accept")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                acceptTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                acceptTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                acceptTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                acceptTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test connect()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "connect"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "connect")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                connectTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                connectTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                connectTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                connectTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test send()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "send"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "send")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                sendTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                sendTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                sendTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                sendTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test WSASend()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "WSASend"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "WSASend")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                WSASendTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSASendTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                WSASendTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSASendTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test sendto()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "sendto"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "sendto")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                sendtoTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                sendtoTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                sendtoTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                sendtoTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test WSASendTo()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "WSASendTo"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "WSASendTo")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                WSASendToTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSASendToTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                WSASendToTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSASendToTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test recv()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "recv"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "recv")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                recvTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                recvTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                recvTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                recvTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test WSARecv()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "WSARecv"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "WSARecv")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                WSARecvTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSARecvTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                WSARecvTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSARecvTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test recvfrom()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "recvfrom"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "recvfrom")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                recvfromTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                recvfromTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                recvfromTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                recvfromTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test WSARecvFrom()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "WSARecvFrom"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "WSARecvFrom")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                WSARecvFromTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSARecvFromTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                WSARecvFromTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSARecvFromTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test getsockname()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "getsockname"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "getsockname")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                getsocknameTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                getsocknameTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                getsocknameTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                getsocknameTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test getpeername()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "getpeername"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "getpeername")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                getpeernameTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                getpeernameTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                getpeernameTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                getpeernameTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test ioctlsocket()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "ioctlsocket"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "ioctlsocket")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                ioctlsocketTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                ioctlsocketTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                ioctlsocketTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                ioctlsocketTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test WSAGetOverlappedResult()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "WSAGetOverlappedResult"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "WSAGetOverlappedResult")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                WSAGetOverlappedResultTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSAGetOverlappedResultTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                WSAGetOverlappedResultTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSAGetOverlappedResultTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test WSACancelOverlappedIO()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "WSACancelOverlappedIO"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "WSACancelOverlappedIO")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                WSACancelOverlappedIOTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSACancelOverlappedIOTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                WSACancelOverlappedIOTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                WSACancelOverlappedIOTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test select()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "select"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "select")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                selectTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                selectTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                selectTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                selectTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test fds macros
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "fdsmacros"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "fdsmacros")))) {
        fdsmacrosTest(hLog, hMemObject, bRIPs);
    }

    // Test shutdown()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "shutdown"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "shutdown")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                shutdownTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                shutdownTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                shutdownTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                shutdownTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test closesocket()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "closesocket"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "closesocket")))) {
        if (TRUE == bRemoteNt) {
            if (TRUE == bVersion11) {
                closesocketTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }

            if (TRUE == bVersion22) {
                closesocketTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteNt, VS_NT, bRIPs);
            }
        }

        if (TRUE == bRemoteXbox) {
            if (TRUE == bVersion11) {
                closesocketTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }

            if (TRUE == bVersion22) {
                closesocketTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, VS_XBOX, bRIPs);
            }
        }
    }

    // Test getsockopt()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "getsockopt"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "getsockopt")))) {
        if (TRUE == bVersion11) {
            getsockoptTest(hLog, hMemObject, MAKEWORD(1, 1), bRIPs);
        }

        if (TRUE == bVersion22) {
            getsockoptTest(hLog, hMemObject, MAKEWORD(2, 2), bRIPs);
        }
    }

    // Test setsockopt()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "setsockopt"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "setsockopt")))) {
        if (TRUE == bVersion11) {
            setsockoptTest(hLog, hMemObject, MAKEWORD(1, 1), bRIPs);
        }

        if (TRUE == bVersion22) {
            setsockoptTest(hLog, hMemObject, MAKEWORD(2, 2), bRIPs);
        }
    }

    // Test XNetInAddrToString()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetInAddrToString"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetInAddrToString")))) {
        XNetInAddrToStringTest(hLog, hMemObject, bRIPs);
    }

    // Test XNetRandom()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetRandom"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetRandom")))) {
        XNetRandomTest(hLog, hMemObject, bRIPs);
    }

    // Test XNetCreateKey()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetCreateKey"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetCreateKey")))) {
        XNetCreateKeyTest(hLog, hMemObject, bRIPs);
    }

    if (TRUE == bRemoteXbox) {
        // Test XNetRegisterKey()
        if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetRegisterKey"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetRegisterKey")))) {
            if (TRUE == bVersion11) {
                XNetRegisterKeyTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, bRIPs);
            }

            if (TRUE == bVersion22) {
                XNetRegisterKeyTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, bRIPs);
            }
        }

        // Test XNetUnregisterKey()
        if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetUnregisterKey"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetUnregisterKey")))) {
            if (TRUE == bVersion11) {
                XNetUnregisterKeyTest(hLog, hMemObject, MAKEWORD(1, 1), lpszNetsyncRemoteXbox, bRIPs);
            }

            if (TRUE == bVersion22) {
                XNetUnregisterKeyTest(hLog, hMemObject, MAKEWORD(2, 2), lpszNetsyncRemoteXbox, bRIPs);
            }
        }

        // Test XNetXnAddrToInAddr()
        if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetXnAddrToInAddr"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetXnAddrToInAddr")))) {
            XNetXnAddrToInAddrTest(hLog, hMemObject, lpszNetsyncRemoteXbox, bRIPs);
        }

        // Test XNetInAddrToXnAddr()
        if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetInAddrToXnAddr"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetInAddrToXnAddr")))) {
            XNetInAddrToXnAddrTest(hLog, hMemObject, lpszNetsyncRemoteXbox, bRIPs);
        }
    }

    // Test XNetDnsLookup()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetDnsLookup"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetDnsLookup")))) {
        XNetDnsLookupTest(hLog, hMemObject, bRIPs);
    }

    // Test XNetDnsRelease()
    if (((NULL == lpszAPISkip) || (FALSE == FindString(lpszAPISkip, "XNetDnsRelease"))) && ((NULL == lpszAPITest) || (TRUE == FindString(lpszAPITest, "XNetDnsRelease")))) {
        XNetDnsReleaseTest(hLog, hMemObject, bRIPs);
    }

    if (NULL != lpszRemotes) {
        xMemFree(hMemObject, lpszRemotes);
    }

    if (NULL != lpszVersions) {
        xMemFree(hMemObject, lpszVersions);
    }

    if (NULL != lpszAPISkip) {
        xMemFree(hMemObject, lpszAPISkip);
    }

    if (NULL != lpszAPITest) {
        xMemFree(hMemObject, lpszAPITest);
    }

    if (NULL != lpszNetsyncRemoteXbox) {
        xMemFree(hMemObject, lpszNetsyncRemoteXbox);
    }

    if (NULL != lpszNetsyncRemoteNt) {
        xMemFree(hMemObject, lpszNetsyncRemoteNt);
    }

    // Free the private heap
    xMemClose(hMemObject);
}



VOID
WINAPI
EndTest(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test exit point

Return Value:

  None

------------------------------------------------------------------------------*/
{
}

} // namespace XNetAPINamespace



#ifdef __cplusplus
extern "C" {
#endif

// Export table for harness

#pragma data_seg(EXPORT_SECTION_NAME)
DECLARE_EXPORT_DIRECTORY(xnetapi)
#pragma data_seg()

BEGIN_EXPORT_TABLE(xnetapi)
    EXPORT_TABLE_ENTRY("StartTest", StartTest)
    EXPORT_TABLE_ENTRY("EndTest", EndTest)
END_EXPORT_TABLE(xnetapi)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\accept.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  accept.c

Abstract:

  This modules tests accept

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// accept messages

#define ACCEPT_REQUEST_MSG   NETSYNC_MSG_USER + 110 + 1
#define ACCEPT_COMPLETE_MSG  NETSYNC_MSG_USER + 110 + 2

typedef struct _ACCEPT_REQUEST {
    DWORD    dwMessageId;
    int      nNumConnections;
    u_short  Port;
    BOOL     bSleep;
    int      nDataBuffers;
} ACCEPT_REQUEST, *PACCEPT_REQUEST;

typedef struct _ACCEPT_COMPLETE {
    DWORD    dwMessageId;
} ACCEPT_COMPLETE, *PACCEPT_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct ACCEPT_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bNonblockFirstAccept;                    // bNonblockFirstAccept indicates if the socket is to be set as non-blocking for the accept
    BOOL   bNonblockNextAccept;                     // bNonblockNextAccept indicates if the socket is to be set as non-blocking for the next accept
    BOOL   bNonblockRecv;                           // bNonblockRecv indicates if the socket is to be set as non-blocking for the recv
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    BOOL   bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    int    backlog;                                 // backlog indicates the maximum length of the queue of pending connections
    BOOL   bConnected;                              // bConnected indicates if the socket is connected
    int    nNumConnects;                            // nNumConnects indicates the number of connects that should occur
    int    nNumAccepts;                             // nNumAccepts indicates the number of accepts that should occur
    BOOL   bSleep;                                  // bSleep indicates if time should elapse before the connect
    int    nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be sent after the connect
    BOOL   bname;                                   // bname indicates if the address buffer is non-NULL
    BOOL   bnamelen;                                // bnamelen indicates if the address buffer length is non-NULL
    int    namelen;                                 // namelenlen is the length of the address buffer
    int    iReturnCode;                             // iReturnCode is the return code of accept
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} ACCEPT_TABLE, *PACCEPT_TABLE;

static ACCEPT_TABLE acceptTable[] =
{
    { "11.1 Not Initialized",    FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSANOTINITIALISED, FALSE },
    { "11.2 s = INT_MIN",        TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAENOTSOCK,       FALSE },
    { "11.3 s = -1",             TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAENOTSOCK,       FALSE },
    { "11.4 s = 0",              TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAENOTSOCK,       FALSE },
    { "11.5 s = INT_MAX",        TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAENOTSOCK,       FALSE },
    { "11.6 s = INVALID_SOCKET", TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAENOTSOCK,       FALSE },
    { "11.7 Not Bound",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAEINVAL,         FALSE },
    { "11.8 Bound",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAEINVAL,         FALSE },
    { "11.9 Pending",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.10 Pending Data",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 1, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.11 Wait",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.12 Wait Data",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               TRUE,  3, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.13 Switch Accept",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 2,               2,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.14 Switch Recv",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, TRUE,  TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               TRUE,  3, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.15 bl = INT_MIN",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  INT_MIN,   FALSE, 1,               1,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.16 bl = -1",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  -1,        FALSE, 1,               1,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.17 bl = 0",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  0,         FALSE, 1,               1,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.18 bl = SOMAXCONN",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, MAX_CONNECTIONS, MAX_CONNECTIONS, TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.19 Not Bound NB",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAEINVAL,         FALSE },
    { "11.20 Bound NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAEINVAL,         FALSE },
    { "11.21 Pending NB",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.22 Pending Data NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 1, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.23 Wait NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.24 Wait Data NB",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               TRUE,  3, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.25 Switch Accept NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SOMAXCONN, FALSE, 2,               2,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.26 Switch Recv NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               TRUE,  3, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.27 bl = INT_MIN NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  INT_MIN,   FALSE, 1,               1,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.28 bl = -1 NB",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  -1,        FALSE, 1,               1,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.29 bl = 0 NB",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,         FALSE, 1,               1,               TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.30 bl = SOMAXCONN NB", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  SOMAXCONN, FALSE, MAX_CONNECTIONS, MAX_CONNECTIONS, TRUE,  0, FALSE, FALSE, 0,                       0,              0,                 FALSE },
    { "11.31 addr = NULL",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, FALSE, TRUE,  0,                       0,              0,                 FALSE },
    { "11.32 addrlen = NULL",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, TRUE,  FALSE, 0,                       0,              WSAEFAULT,         TRUE  },
    { "11.33 Large addrlen",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,              0,                 FALSE },
    { "11.34 Exact addrlen",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,              0,                 FALSE },
    { "11.35 Small addrlen",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, INVALID_SOCKET, WSAEFAULT,         TRUE  },
    { "11.36 Zero addrlen",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, TRUE,  TRUE,  0,                       INVALID_SOCKET, WSAEFAULT,         TRUE  },
    { "11.37 Negative addrlen",  TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 1,               1,               FALSE, 0, TRUE,  TRUE,  -1,                      INVALID_SOCKET, WSAEFAULT,         TRUE  },
    { "11.38 Connected",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, TRUE,  0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAEINVAL,         FALSE },
    { "11.39 Closed Socket",     TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, TRUE,  TRUE,  SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAENOTSOCK,       FALSE },
    { "11.40 UDP",               TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSAEFAULT,         TRUE  },
    { "11.41 Not Initialized",   FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, SOMAXCONN, FALSE, 0,               1,               FALSE, 0, FALSE, FALSE, 0,                       INVALID_SOCKET, WSANOTINITIALISED, FALSE }
};

#define acceptTableCount (sizeof(acceptTable) / sizeof(ACCEPT_TABLE))

NETSYNC_TYPE_THREAD  acceptTestSessionNt =
{
    1,
    acceptTableCount,
    L"xnetapi_nt.dll",
    "acceptTestServer"
};

NETSYNC_TYPE_THREAD  acceptTestSessionXbox =
{
    1,
    acceptTableCount,
    L"xnetapi_xbox.dll",
    "acceptTestServer"
};



VOID
acceptTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests accept - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // acceptRequest is the request sent to the server
    ACCEPT_REQUEST         acceptRequest;
    
    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;
    // pnsSockets is an array of socket descriptors returned by accept
    SOCKET                 pnsSockets[MAX_CONNECTIONS];

    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // namelen is the length of the address buffer
    int                    namelen;
    // nConnection is a counter to enumerate each connection
    int                    nConnection;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                   RecvBuffer10[BUFFER_10_LEN + 1];

    // dwFirstTime is the first tick count
    DWORD                  dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                  dwSecondTime;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "accept v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_accept+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_accept-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = acceptTestSessionXbox;
    }
    else {
        NetsyncTypeSession = acceptTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < acceptTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, acceptTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, acceptTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != acceptTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, acceptTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == acceptTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != acceptTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == acceptTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = acceptTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == acceptTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == acceptTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == acceptTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == acceptTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == acceptTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == acceptTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & acceptTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & acceptTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Set the socket to non-blocking mode
        if (TRUE == acceptTable[dwTableIndex].bNonblockFirstAccept) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == acceptTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
            CurrentPort++;
        }

        // Place the socket in the listening state
        if (TRUE == acceptTable[dwTableIndex].bListen) {
            listen(sSocket, acceptTable[dwTableIndex].backlog);
        }

        if (TRUE == acceptTable[dwTableIndex].bConnected) {
            // Initialize the request
            acceptRequest.dwMessageId = ACCEPT_REQUEST_MSG;
            acceptRequest.nNumConnections = 1;
            acceptRequest.Port = ntohs(localname.sin_port);
            acceptRequest.bSleep = FALSE;
            acceptRequest.nDataBuffers = 0;

            // Send the request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(acceptRequest), (char *) &acceptRequest);

            // Wait for the complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (0 != acceptTable[dwTableIndex].nNumConnects) {
            // Initialize the request
            acceptRequest.dwMessageId = ACCEPT_REQUEST_MSG;
            acceptRequest.nNumConnections = acceptTable[dwTableIndex].nNumConnects;
            acceptRequest.Port = ntohs(localname.sin_port);
            acceptRequest.bSleep = acceptTable[dwTableIndex].bSleep;
            acceptRequest.nDataBuffers = acceptTable[dwTableIndex].nDataBuffers;

            // Send the request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(acceptRequest), (char *) &acceptRequest);
        }

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & acceptTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        for (nConnection = 0; nConnection < acceptTable[dwTableIndex].nNumAccepts; nConnection++) {
            bTestPassed = TRUE;
            bException = FALSE;

            if ((0 != acceptTable[dwTableIndex].nNumConnects) && (FALSE == acceptTable[dwTableIndex].bSleep)) {
                // Wait for the complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);
            }

            // Get the current tick count
            dwFirstTime = GetTickCount();

            // Call accept
            pnsSockets[nConnection] = INVALID_SOCKET;
            namelen = acceptTable[dwTableIndex].namelen;

            __try {
                pnsSockets[nConnection] = accept((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (TRUE == acceptTable[dwTableIndex].bname) ? (SOCKADDR *) &remotename : NULL, (TRUE == acceptTable[dwTableIndex].bnamelen) ? &namelen : NULL);
                iReturnCode = pnsSockets[nConnection];
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                if (TRUE == acceptTable[dwTableIndex].bRIP) {
                    xLog(hLog, XLL_PASS, "accept RIP'ed");
                }
                else {
                    xLog(hLog, XLL_EXCEPTION, "accept caused an exception - ec = 0x%08x", GetExceptionCode());
                }
                bException = TRUE;
            }

            if (FALSE == bException) {
                if ((TRUE == bNonblocking) && (0 == acceptTable[dwTableIndex].iReturnCode) && (TRUE == acceptTable[dwTableIndex].bSleep)) {
                    // Non-blocking socket
                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "accept returned non-SOCKET_ERROR");
                    }
                    else {
                        // Get the last error code
                        iLastError = WSAGetLastError();

                        if (WSAEWOULDBLOCK != iLastError) {
                            xLog(hLog, XLL_FAIL, "accept iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                        }
                        else {
                            xLog(hLog, XLL_PASS, "accept iLastError - OUT: %u", iLastError);

                            FD_ZERO(&readfds);
                            FD_SET(sSocket, &readfds);

                            // Wait for connect to complete
                            select(0, &readfds, NULL, NULL, NULL);

                            // Call accept
                            pnsSockets[nConnection] = INVALID_SOCKET;
                            pnsSockets[nConnection] = accept(sSocket, (TRUE == acceptTable[dwTableIndex].bname) ? (SOCKADDR *) &remotename : NULL, (TRUE == acceptTable[dwTableIndex].bnamelen) ? &namelen : NULL);
                            iReturnCode = pnsSockets[nConnection];
                        }
                    }
                }

                if (TRUE == acceptTable[dwTableIndex].bRIP) {
                    xLog(hLog, XLL_FAIL, "accept did not RIP");
                }

                if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == acceptTable[dwTableIndex].iReturnCode)) {
                    // Get the last error code
                    iLastError = WSAGetLastError();

                    if (iLastError != acceptTable[dwTableIndex].iLastError) {
                        xLog(hLog, XLL_FAIL, "accept iLastError - EXPECTED: %u; RECEIVED: %u", acceptTable[dwTableIndex].iLastError, iLastError);
                    }
                    else {
                        xLog(hLog, XLL_PASS, "accept iLastError - OUT: %u", iLastError);
                    }
                }
                else if (SOCKET_ERROR == iReturnCode) {
                    xLog(hLog, XLL_FAIL, "accept returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                }
                else if (SOCKET_ERROR == acceptTable[dwTableIndex].iReturnCode) {
                    xLog(hLog, XLL_FAIL, "accept returned non-SOCKET_ERROR");
                }
                else {
                    if ((1 == acceptTable[dwTableIndex].nDataBuffers) || (3 == acceptTable[dwTableIndex].nDataBuffers)) {
                        // Receive data
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(pnsSockets[nConnection], RecvBuffer10, sizeof(RecvBuffer10), 0);

                        if ((TRUE == bNonblocking) && (SOCKET_ERROR == iReturnCode)) {
                            // Non-blocking socket
                            // Get the last error code
                            iLastError = WSAGetLastError();

                            if (WSAEWOULDBLOCK != iLastError) {
                                xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);

                                FD_ZERO(&readfds);
                                FD_SET(pnsSockets[nConnection], &readfds);

                                // Wait for data to be queued
                                select(0, &readfds, NULL, NULL, NULL);

                                // Receive data
                                ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                                iReturnCode = recv(pnsSockets[nConnection], RecvBuffer10, sizeof(RecvBuffer10), 0);
                            }
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 1, 1);

                            if (0 != strncmp(SendBuffer10, RecvBuffer10, sizeof(RecvBuffer10))) {
                                xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv succeeded");
                            }
                        }

                        // Get the current tick count
                        dwSecondTime = GetTickCount();
                        if (FALSE == acceptTable[dwTableIndex].bSleep) {
                            if ((dwSecondTime - dwFirstTime) > SLEEP_ZERO_TIME) {
                                xLog(hLog, XLL_FAIL, "accept and recv nTime - EXPECTED: %d; RECEIVED: %d", 0, dwSecondTime - dwFirstTime);
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                                xLog(hLog, XLL_FAIL, "accept and recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                                bTestPassed = FALSE;
                            }
                        }

                        if (3 == acceptTable[dwTableIndex].nDataBuffers) {
                            // Receive data
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv(pnsSockets[nConnection], RecvBuffer10, sizeof(RecvBuffer10), 0);

                            if (TRUE == bNonblocking) {
                                // Non-blocking socket
                                if (SOCKET_ERROR != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                                    bTestPassed = FALSE;
                                }
                                else {
                                    // Get the last error code
                                    iLastError = WSAGetLastError();

                                    if (WSAEWOULDBLOCK != iLastError) {
                                        xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                                        bTestPassed = FALSE;
                                    }
                                    else {
                                        xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);

                                        FD_ZERO(&readfds);
                                        FD_SET(pnsSockets[nConnection], &readfds);

                                        // Wait for data to be queued
                                        select(0, &readfds, NULL, NULL, NULL);

                                        // Receive data
                                        iReturnCode = recv(pnsSockets[nConnection], RecvBuffer10, sizeof(RecvBuffer10), 0);
                                    }
                                }
                            }

                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else {
                                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                                sprintf(SendBuffer10, "%05d%05d", 2, 2);

                                if (0 != strcmp(SendBuffer10, RecvBuffer10)) {
                                    xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                                    bTestPassed = FALSE;
                                }
                                else {
                                    xLog(hLog, XLL_PASS, "recv succeeded");
                                }
                            }

                            // Get the current tick count
                            dwSecondTime = GetTickCount();
                            if (FALSE == acceptTable[dwTableIndex].bSleep) {
                                if ((dwSecondTime - dwFirstTime) > (SLEEP_ZERO_TIME * 2)) {
                                    xLog(hLog, XLL_FAIL, "accept and recv nTime - EXPECTED: %d; RECEIVED: %d", 0, dwSecondTime - dwFirstTime);
                                    bTestPassed = FALSE;
                                }
                            }
                            else {
                                if (((dwSecondTime - dwFirstTime) < (SLEEP_LOW_TIME * 2)) || ((dwSecondTime - dwFirstTime) > (SLEEP_HIGH_TIME * 2))) {
                                    xLog(hLog, XLL_FAIL, "accept and recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME * 2, dwSecondTime - dwFirstTime);
                                    bTestPassed = FALSE;
                                }
                            }
                            
                            // Switch the blocking mode
                            if (acceptTable[dwTableIndex].bNonblockRecv != bNonblocking) {
                                Nonblock = (TRUE == acceptTable[dwTableIndex].bNonblockRecv) ? 1 : 0;
                                ioctlsocket(pnsSockets[nConnection], FIONBIO, &Nonblock);
                            }

                            // Receive data
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv(pnsSockets[nConnection], RecvBuffer10, sizeof(RecvBuffer10), 0);

                            if (TRUE == acceptTable[dwTableIndex].bNonblockRecv) {
                                // Non-blocking socket
                                if (SOCKET_ERROR != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                                }
                                else {
                                    // Get the last error code
                                    iLastError = WSAGetLastError();

                                    if (WSAEWOULDBLOCK != iLastError) {
                                        xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                                        bTestPassed = FALSE;
                                    }
                                    else {
                                        xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);

                                        FD_ZERO(&readfds);
                                        FD_SET(pnsSockets[nConnection], &readfds);

                                        // Wait for data to be queued
                                        select(0, &readfds, NULL, NULL, NULL);

                                        // Receive data
                                        iReturnCode = recv(pnsSockets[nConnection], RecvBuffer10, sizeof(RecvBuffer10), 0);
                                    }
                                }
                            }

                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else {
                                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                                sprintf(SendBuffer10, "%05d%05d", 3, 3);

                                if (0 != strcmp(SendBuffer10, RecvBuffer10)) {
                                    xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                                    bTestPassed = FALSE;
                                }
                                else {
                                    xLog(hLog, XLL_PASS, "recv succeeded");
                                }
                            }

                            // Get the current tick count
                            dwSecondTime = GetTickCount();
                            if (FALSE == acceptTable[dwTableIndex].bSleep) {
                                if ((dwSecondTime - dwFirstTime) > (SLEEP_ZERO_TIME * 3)) {
                                    xLog(hLog, XLL_FAIL, "accept and recv nTime - EXPECTED: %d; RECEIVED: %d", 0, dwSecondTime - dwFirstTime);
                                    bTestPassed = FALSE;
                                }
                            }
                            else {
                                if (((dwSecondTime - dwFirstTime) < (SLEEP_LOW_TIME * 3)) || ((dwSecondTime - dwFirstTime) > (SLEEP_HIGH_TIME * 3))) {
                                    xLog(hLog, XLL_FAIL, "accept and recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME * 3, dwSecondTime - dwFirstTime);
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                    else {
                        // Get the current tick count
                        dwSecondTime = GetTickCount();
                        if (FALSE == acceptTable[dwTableIndex].bSleep) {
                            if ((dwSecondTime - dwFirstTime) > SLEEP_ZERO_TIME) {
                                xLog(hLog, XLL_FAIL, "accept and recv nTime - EXPECTED: %d; RECEIVED: %d", 0, dwSecondTime - dwFirstTime);
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                                xLog(hLog, XLL_FAIL, "accept and recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    if ((TRUE == acceptTable[dwTableIndex].bname) && (TRUE == acceptTable[dwTableIndex].bnamelen)) {
                        // Check the address
                        if (AF_INET != remotename.sin_family) {
                            xLog(hLog, XLL_FAIL, "addr->af - EXPECTED: %d; RECEIVED: %d", AF_INET, remotename.sin_family);
                            bTestPassed = FALSE;
                        }

                        if (NetsyncInAddr != remotename.sin_addr.s_addr) {
                            xLog(hLog, XLL_FAIL, "addr->addr - EXPECTED: %u; RECEIVED: %u", NetsyncInAddr, remotename.sin_addr.s_addr);
                            bTestPassed = FALSE;
                        }

                        // Check the address length
                        if (sizeof(SOCKADDR_IN) != namelen) {
                            xLog(hLog, XLL_FAIL, "addrlen - EXPECTED: %d; RECEIVED: %d", sizeof(SOCKADDR_IN), namelen);
                            bTestPassed = FALSE;
                        }
                    }

                    if (TRUE == bTestPassed) {
                        xLog(hLog, XLL_PASS, "accept succeeded");
                    }
                }
            }
        
            // Switch the blocking mode
            if (acceptTable[dwTableIndex].bNonblockNextAccept != bNonblocking) {
                Nonblock = (TRUE == acceptTable[dwTableIndex].bNonblockNextAccept) ? 1 : 0;
                ioctlsocket(sSocket, FIONBIO, &Nonblock);
                bNonblocking = acceptTable[dwTableIndex].bNonblockNextAccept;
            }
        }

        if ((0 != acceptTable[dwTableIndex].nNumConnects) && (TRUE == acceptTable[dwTableIndex].bSleep)) {
            // Wait for the complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        // Close the connections
        for (nConnection = 0; nConnection < acceptTable[dwTableIndex].nNumAccepts; nConnection++) {
            if (INVALID_SOCKET != pnsSockets[nConnection]) {
                closesocket(pnsSockets[nConnection]);
            }
        }

        if (0 != acceptTable[dwTableIndex].nNumConnects) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(acceptRequest), (char *) &acceptRequest);
        }

        // Close the socket
        if (INVALID_SOCKET != nsSocket) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(acceptRequest), (char *) &acceptRequest);

            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & acceptTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & acceptTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & acceptTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
acceptTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests accept - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long           FromInAddr;
    // dwMessageType is the type of received message
    DWORD            dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD            dwMessageSize;
    // pMessage is a pointer to the received message
    char             *pMessage;
    // acceptRequest is the request
    ACCEPT_REQUEST   acceptRequest;
    // acceptComplete is the result
    ACCEPT_COMPLETE  acceptComplete;

    // psSockets is an array of socket
    SOCKET           psSockets[MAX_CONNECTIONS + 1];
    // nConnection is a counter to enumerate each connection
    int              nConnection;

    // bNagle indicates if Nagle is enabled
    BOOL             bNagle = FALSE;

    // remotename is the remote address
    SOCKADDR_IN      remotename;

    // SendBuffer10 is the send buffer
    char             SendBuffer10[BUFFER_10_LEN + 1];



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&acceptRequest, pMessage, sizeof(acceptRequest));
        NetsyncFreeMessage(pMessage);

        for (nConnection = 0; nConnection < acceptRequest.nNumConnections; nConnection++) {
            if (TRUE == acceptRequest.bSleep) {
                // Sleep
                Sleep(SLEEP_MIDLOW_TIME);
            }

            // Create the socket
            psSockets[nConnection] = socket(AF_INET, SOCK_STREAM, 0);
        
            // Disable Nagle
            setsockopt(psSockets[nConnection], IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));

            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(acceptRequest.Port);
            connect(psSockets[nConnection], (SOCKADDR *) &remotename, sizeof(remotename));

            if ((1 == acceptRequest.nDataBuffers) || (3 == acceptRequest.nDataBuffers)) {
                // Send data
                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                sprintf(SendBuffer10, "%05d%05d", 1, 1);

                send(psSockets[nConnection], SendBuffer10, 10, 0);

                if (3 == acceptRequest.nDataBuffers) {
                    if (TRUE == acceptRequest.bSleep) {
                        // Sleep
                        Sleep(SLEEP_MIDLOW_TIME);
                    }

                    // Send data
                    ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);

                    send(psSockets[nConnection], SendBuffer10, 10, 0);

                    if (TRUE == acceptRequest.bSleep) {
                        // Sleep
                        Sleep(SLEEP_MIDLOW_TIME);
                    }

                    // Send data
                    ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                    sprintf(SendBuffer10, "%05d%05d", 3, 3);

                    send(psSockets[nConnection], SendBuffer10, 10, 0);
                }
            }
        }

        // Send the complete
        acceptComplete.dwMessageId = ACCEPT_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(acceptComplete), (char *) &acceptComplete);

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the array of sockets
        for (nConnection = 0; nConnection < acceptRequest.nNumConnections; nConnection++) {
            closesocket(psSockets[nConnection]);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\client.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.h

Abstract:

  This module contains the definitions for client.c

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#pragma once



namespace XNetAPINamespace {

// Function prototypes

VOID
htonlTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
htonsTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
ntohlTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
ntohsTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
inet_addrTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
WSAStartupTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
WSACleanupTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
);

VOID
socketTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
);

VOID
bindTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
);

VOID
listenTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
acceptTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
connectTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
sendTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
WSASendTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
sendtoTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
WSASendToTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
recvTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
WSARecvTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
recvfromTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
WSARecvFromTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
getsocknameTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
getpeernameTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
ioctlsocketTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
WSAGetOverlappedResultTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
WSACancelOverlappedIOTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
selectTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
fdsmacrosTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
shutdownTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
closesocketTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
);

VOID
getsockoptTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
);

VOID
setsockoptTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
);

VOID
XNetInAddrToStringTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
XNetRandomTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
XNetCreateKeyTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
XNetRegisterKeyTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN BOOL    bRIPs
);

VOID
XNetUnregisterKeyTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN BOOL    bRIPs
);

VOID
XNetXnAddrToInAddrTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN LPSTR   lpszNetsyncRemote,
    IN BOOL    bRIPs
);

VOID
XNetInAddrToXnAddrTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN LPSTR   lpszNetsyncRemote,
    IN BOOL    bRIPs
);

VOID
XNetDnsLookupTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

VOID
XNetDnsReleaseTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
);

} // namespace XNetAPINamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\common.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  common.h

Abstract:

  This module contains the common definitions

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#pragma once

#include "precomp.h"

namespace XNetAPINamespace {

// Netsync flags

#define VS_NT   1
#define VS_XBOX 2



// Misc

#define AF_UNIX          1
#define MAX_CONNECTIONS  5



// Socket flags

#define SOCKET_INT_MIN         0x00000001
#define SOCKET_NEG_ONE         0x00000002
#define SOCKET_ZERO            0x00000004
#define SOCKET_INT_MAX         0x00000008
#define SOCKET_INVALID_SOCKET  0x00000010
#define SOCKET_TCP             0x00000020
#define SOCKET_UDP             0x00000040
#define SOCKET_CLOSED          0x00000080
#define SOCKET_BROADCAST       0x00000100



// Buffers

#define BUFFER_10_LEN          10
#define BUFFER_TCPSEGMENT_LEN  1418
#define BUFFER_TCPLARGE_LEN    8192
#define BUFFER_UDPLARGE_LEN    1430
#define BUFFER_LARGE_LEN       8192


    
// Sleep times

#define SLEEP_ZERO_TIME        250
#define SLEEP_LOW_TIME         2200
#define SLEEP_MIDLOW_TIME      2400
#define SLEEP_MEAN_TIME        2500
#define SLEEP_MIDHIGH_TIME     2600
#define SLEEP_HIGH_TIME        2800

} // namespace XNetAPINamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\connect.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  connect.c

Abstract:

  This modules tests connect

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// connect messages

#define CONNECT_REQUEST_MSG   NETSYNC_MSG_USER + 120 + 1
#define CONNECT_CANCEL_MSG    NETSYNC_MSG_USER + 120 + 2
#define CONNECT_COMPLETE_MSG  NETSYNC_MSG_USER + 120 + 3

typedef struct _CONNECT_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bClientAccept;
    BOOL     bServerAccept;
    int      nDataBuffers;
} CONNECT_REQUEST, *PCONNECT_REQUEST;

typedef struct _CONNECT_COMPLETE {
    DWORD    dwMessageId;
} CONNECT_COMPLETE, *PCONNECT_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define NAME_ANY       0
#define NAME_ANYADDR   1
#define NAME_ANYPORT   2
#define NAME_LOOPBACK  3
#define NAME_BROADCAST 4
#define NAME_MULTICAST 5
#define NAME_UNAVAIL   6
#define NAME_BAD       7
#define NAME_NULL      8
#define NAME_REMOTE    9



typedef struct CONNECT_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket1;                               // dwSocket1 indicates the first socket to be created
    DWORD  dwSocket2;                               // dwSocket2 indicates the second socket to be created
    BOOL   bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the connect
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    BOOL   bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL   bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL   bPreConnect;                             // bPreConnect indicates if a connection attempt is made before it could succeed
    BOOL   bFirstConnect;                           // bFirstConnect indicates if the socket is connected
    BOOL   bSecondConnect;                          // bSecondConnect indicates if the socket will be connected
    BOOL   bFirstSend;                              // bFirstSend indicates if data will be sent on the socket after the connect but before the accept
    BOOL   bSecondSend;                             // bSecondSend indicates if data will be sent on the socket after the connect and accept
    int    nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be received after the connect
    DWORD  dwFirstName;                             // dwFirstName indicates the first connect address
    DWORD  dwSecondName;                            // dwSecondName indicates the second connect address
    int    namelen;                                 // namelen is a pointer to the length of the address buffer
    int    iReturnCode;                             // iReturnCode is the return code of connect
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} CONNECT_TABLE, *PCONNECT_TABLE;

static CONNECT_TABLE connectTable[] =
{
    { "12.1 Not Initialized",           FALSE, FALSE, SOCKET_INVALID_SOCKET,         0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "12.2 s = INT_MIN",               TRUE,  TRUE,  SOCKET_INT_MIN,                0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "12.3 s = -1",                    TRUE,  TRUE,  SOCKET_NEG_ONE,                0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "12.4 s = 0",                     TRUE,  TRUE,  SOCKET_ZERO,                   0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "12.5 s = INT_MAX",               TRUE,  TRUE,  SOCKET_INT_MAX,                0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "12.6 s = INVALID_SOCKET",        TRUE,  TRUE,  SOCKET_INVALID_SOCKET,         0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "12.7 Not Bound TCP",             TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.8 Not Bound 1 Send TCP",      TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.9 Not Bound 2 Send TCP",      TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.10 Not Bound Recv TCP",       TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 1, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.11 Not Bound Switch TCP",     TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 3, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.12 Bound TCP",                TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.13 Bound 1 Send TCP",         TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.14 Bound 2 Send TCP",         TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.15 Bound Recv TCP",           TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 1, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.16 Bound Switch TCP",         TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 3, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.17 Listening TCP",            TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "12.18 Accepted TCP",             TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEISCONN,        FALSE },
    { "12.19 Connected TCP",            TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEISCONN,        FALSE },
    { "12.20 Loopback TCP",             TRUE,  TRUE,  SOCKET_TCP,                    SOCKET_TCP, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.21 Loopback 1 Send TCP",      TRUE,  TRUE,  SOCKET_TCP,                    SOCKET_TCP, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.22 Loopback 2 Send TCP",      TRUE,  TRUE,  SOCKET_TCP,                    SOCKET_TCP, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.23 Loopback Recv TCP",        TRUE,  TRUE,  SOCKET_TCP,                    SOCKET_TCP, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 1, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.24 Refused TCP",              TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAECONNREFUSED,   FALSE },
    { "12.25 Retry TCP",                TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.26 Not Bound NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.27 Not Bound 1 Send NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.28 Not Bound 2 Send NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.29 Not Bound Recv NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 1, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.30 Not Bound Switch NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 3, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.31 Bound NB TCP",             TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.32 Bound 1 Send NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.33 Bound 2 Send NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.34 Bound Recv NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 1, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.35 Bound Switch NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 3, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.36 Listening NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "12.37 Accepted NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEISCONN,        FALSE },
    { "12.38 Connected NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEISCONN,        FALSE },
    { "12.39 Loopback NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    SOCKET_TCP, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.40 Loopback 1 Send NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                    SOCKET_TCP, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.41 Loopback 2 Send NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                    SOCKET_TCP, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.42 Loopback Recv NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    SOCKET_TCP, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 1, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.43 Refused NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAECONNREFUSED,   FALSE },
    { "12.44 Retry NB TCP",             TRUE,  TRUE,  SOCKET_TCP,                    0,          TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.45 Not Bound UDP",            TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.46 Not Bound Send UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.47 Bound UDP",                TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.48 Bound Send UDP",           TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.49 Bound Recv UDP",           TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 1, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.50 Bound Switch UDP",         TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 3, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.51 Connected UDP",            TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.52 Connected Send UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  0, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.53 Connected Recv UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 1, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.54 Connected Switch UDP",     TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 3, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.55 Change UDP",               TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0, NAME_LOOPBACK, NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.56 Change Send UDP",          TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  0, NAME_LOOPBACK, NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.57 Change Recv UDP",          TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 1, NAME_LOOPBACK, NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.58 Change Switch UDP",        TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 3, NAME_LOOPBACK, NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.59 Reject Recv UDP",          TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 2, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.60 Flush Recv UDP",           TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 4, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.61 Reset Send UDP",           TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  0, NAME_REMOTE,   NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.62 Reset Recv UDP",           TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 5, NAME_REMOTE,   NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.63 Loopback UDP",             TRUE,  TRUE,  SOCKET_UDP,                    SOCKET_UDP, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.64 Loopback Send UDP",        TRUE,  TRUE,  SOCKET_UDP,                    SOCKET_UDP, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.65 Loopback Recv UDP",        TRUE,  TRUE,  SOCKET_UDP,                    SOCKET_UDP, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 1, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.66 Not Bound NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.67 Not Bound Send NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.68 Bound NB UDP",             TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.69 Bound Send NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.70 Bound Recv NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 1, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.71 Bound Switch NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 3, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.72 Connected NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.73 Connected Send NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  0, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.74 Connected Recv NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 1, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.75 Connected Switch NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 3, NAME_REMOTE,   NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.76 Change NB UDP",            TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0, NAME_LOOPBACK, NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.77 Change Send NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  0, NAME_LOOPBACK, NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.78 Change Recv NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 1, NAME_LOOPBACK, NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.79 Change Switch NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 3, NAME_LOOPBACK, NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.80 Reject Recv NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 2, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.81 Flush Recv NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 4, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.82 Reset Send NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  0, NAME_REMOTE,   NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.83 Reset Recv NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    0,          TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 5, NAME_REMOTE,   NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.84 Loopback NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                    SOCKET_UDP, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.85 Loopback Send NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    SOCKET_UDP, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  0, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.86 Loopback Recv NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    SOCKET_UDP, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 1, NAME_NULL,     NAME_LOOPBACK,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.87 addr = NULL TCP",          TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_NULL,      sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.88 Broadcast TCP",            TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_BROADCAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.89 Multicast TCP",            TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_MULTICAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.90 Unavail addr TCP",         TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_UNAVAIL,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.91 Bad addr TCP",             TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_BAD,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.92 Zero addr TCP",            TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.93 Any addr TCP",             TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_ANYADDR,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.94 Zero port addr TCP",       TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_ANYPORT,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.95 Large addrlen TCP",        TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "12.96 Exact addrlen TCP",        TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.97 Small addrlen TCP",        TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.98 Zero addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.99 Neg addrlen TCP",          TRUE,  TRUE,  SOCKET_TCP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.100 addr = NULL UDP",         TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_NULL,      sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.101 Broadcast UDP",           TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_BROADCAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEACCES,         FALSE },
    { "12.102 Broadcast enabled UDP",   TRUE,  TRUE,  SOCKET_UDP | SOCKET_BROADCAST, 0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.103 Multicast UDP",           TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_MULTICAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.104 Unavail addr UDP",        TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_UNAVAIL,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.105 Bad addr UDP",            TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_BAD,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.106 Zero addr UDP",           TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.107 Any addr UDP",            TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_ANYADDR,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.108 Zero port addr UDP",      TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_ANYPORT,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "12.109 Large addrlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "12.110 Exact addrlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "12.111 Small addrlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.112 Zero addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.113 Neg addrlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "12.114 Closed Socket TCP",       TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "12.115 Closed Socket UDP",       TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,    0,          FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "12.116 Not Initialized",         FALSE, FALSE, SOCKET_INVALID_SOCKET,         0,          FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, NAME_NULL,     NAME_REMOTE,    sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define connectTableCount (sizeof(connectTable) / sizeof(CONNECT_TABLE))

NETSYNC_TYPE_THREAD  connectTestSessionNt =
{
    1,
    connectTableCount * 2,
    L"xnetapi_nt.dll",
    "connectTestServer"
};

NETSYNC_TYPE_THREAD  connectTestSessionXbox =
{
    1,
    connectTableCount * 2,
    L"xnetapi_xbox.dll",
    "connectTestServer"
};



VOID
connectTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests connect - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // connectRequest is the request sent to the server
    CONNECT_REQUEST        connectRequest;

    // sSocket1 is the first socket descriptor
    SOCKET                 sSocket1;
    // sSocket2 is the second socket descriptor
    SOCKET                 sSocket2;
    // nsSocket1 is the first accepted socket descriptor
    SOCKET                 nsSocket1;
    // nsSocket2 is the second accepted socket descriptor
    SOCKET                 nsSocket2;

    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // bBroadcast indicates the socket is enabled to send broadcast data
    BOOL                   bBroadcast = TRUE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // exceptfds is the set of sockets to check for an except condition
    fd_set                 exceptfds;

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                   RecvBuffer10[BUFFER_10_LEN + 1];

    // dwFirstTime is the first tick count
    DWORD                  dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                  dwSecondTime;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "connect v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_connect+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_connect-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = connectTestSessionXbox;
    }
    else {
        NetsyncTypeSession = connectTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < connectTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, connectTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, connectTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != connectTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, connectTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == connectTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != connectTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == connectTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = connectTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == connectTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket1 = INVALID_SOCKET;
        nsSocket1 = INVALID_SOCKET;
        if (SOCKET_INT_MIN == connectTable[dwTableIndex].dwSocket1) {
            sSocket1 = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == connectTable[dwTableIndex].dwSocket1) {
            sSocket1 = -1;
        }
        else if (SOCKET_ZERO == connectTable[dwTableIndex].dwSocket1) {
            sSocket1 = 0;
        }
        else if (SOCKET_INT_MAX == connectTable[dwTableIndex].dwSocket1) {
            sSocket1 = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == connectTable[dwTableIndex].dwSocket1) {
            sSocket1 = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket1)) {
            sSocket1 = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & connectTable[dwTableIndex].dwSocket1)) {
            sSocket1 = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Create the socket
        sSocket2 = INVALID_SOCKET;
        nsSocket2 = INVALID_SOCKET;
        if (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket2)) {
            sSocket2 = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & connectTable[dwTableIndex].dwSocket2)) {
            sSocket2 = socket(AF_INET, SOCK_DGRAM, 0);
        }

        if (0 != (SOCKET_BROADCAST & connectTable[dwTableIndex].dwSocket1)) {
            setsockopt(sSocket1, SOL_SOCKET, SO_BROADCAST, (char *) &bBroadcast, sizeof(bBroadcast));
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket1)) || (0 != (SOCKET_UDP & connectTable[dwTableIndex].dwSocket1))) {
            setsockopt(sSocket1, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket1, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket1)) {
            setsockopt(sSocket1, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == connectTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket1, FIONBIO, &Nonblock);
            bNonblocking = TRUE;

            if (INVALID_SOCKET != sSocket2) {
                Nonblock = 1;
                ioctlsocket(sSocket2, FIONBIO, &Nonblock);
                bNonblocking = TRUE;
            }
        }
        else {
            bNonblocking = FALSE;
        }

        if (INVALID_SOCKET != sSocket2) {
            // Bind the socket
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort + 1);
            bind(sSocket2, (SOCKADDR *) &localname, sizeof(localname));

            if (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket2)) {
                // Place the socket in the listening state
                listen(sSocket2, SOMAXCONN);
            }
        }

        // Bind the socket
        if (TRUE == connectTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket1, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == connectTable[dwTableIndex].bListen) {
            listen(sSocket1, SOMAXCONN);
        }

        if (TRUE == connectTable[dwTableIndex].bAccept) {
            // Initialize the connect request
            connectRequest.dwMessageId = CONNECT_REQUEST_MSG;
            if (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket1)) {
                connectRequest.nSocketType = SOCK_STREAM;
            }
            else if (0 != (SOCKET_UDP & connectTable[dwTableIndex].dwSocket1)) {
                connectRequest.nSocketType = SOCK_DGRAM;
            }
            connectRequest.Port = CurrentPort;
            connectRequest.bClientAccept = TRUE;
            connectRequest.bServerAccept = FALSE;
            connectRequest.nDataBuffers = 0;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(connectRequest), (char *) &connectRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            // Accept the socket
            nsSocket1 = accept(sSocket1, NULL, NULL);
        }
        else {
            if (TRUE == connectTable[dwTableIndex].bPreConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket1, (SOCKADDR *) &remotename, sizeof(remotename));

                if (TRUE == bNonblocking) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket1, &writefds);

                    // Wait for connect to complete
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }

            if ((TRUE == connectTable[dwTableIndex].bFirstConnect) || (TRUE == connectTable[dwTableIndex].bSecondConnect)) {
                // Initialize the connect request
                connectRequest.dwMessageId = CONNECT_REQUEST_MSG;
                if (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket1)) {
                    connectRequest.nSocketType = SOCK_STREAM;
                }
                else if (0 != (SOCKET_UDP & connectTable[dwTableIndex].dwSocket1)) {
                    connectRequest.nSocketType = SOCK_DGRAM;
                }
                connectRequest.Port = CurrentPort;
                connectRequest.bClientAccept = FALSE;
                connectRequest.bServerAccept = connectTable[dwTableIndex].bSecondConnect;
                connectRequest.nDataBuffers = connectTable[dwTableIndex].nDataBuffers;

                // Send the connect request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(connectRequest), (char *) &connectRequest);

                // Wait for the connect complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                if (TRUE == connectTable[dwTableIndex].bFirstConnect) {
                    // Connect the socket
                    ZeroMemory(&remotename, sizeof(remotename));
                    remotename.sin_family = AF_INET;

                    if (NAME_REMOTE == connectTable[dwTableIndex].dwSecondName) {
                        remotename.sin_addr.s_addr = NetsyncInAddr;
                        remotename.sin_port = htons(CurrentPort);
                    }

                    connect(sSocket1, (SOCKADDR *) &remotename, sizeof(remotename));

                    if ((TRUE == bNonblocking) && (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket1))) {
                        FD_ZERO(&writefds);
                        FD_SET(sSocket1, &writefds);

                        // Wait for connect to complete
                        select(0, NULL, &writefds, NULL, NULL);
                    }
                }
            }
        }

        // Set the remote name
        ZeroMemory(&remotename, sizeof(remotename));
        remotename.sin_family = AF_INET;

        if (NAME_ANYADDR == connectTable[dwTableIndex].dwSecondName) {
            remotename.sin_port = htons(CurrentPort);
        }
        else if (NAME_ANYPORT == connectTable[dwTableIndex].dwSecondName) {
            remotename.sin_addr.s_addr = NetsyncInAddr;
        }
        else if (NAME_LOOPBACK == connectTable[dwTableIndex].dwSecondName) {
            remotename.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            remotename.sin_port = htons(CurrentPort + 1);
        }
        else if (NAME_BROADCAST == connectTable[dwTableIndex].dwSecondName) {
            remotename.sin_addr.s_addr = htonl(INADDR_BROADCAST);
            remotename.sin_port = htons(CurrentPort);
        }
        else if (NAME_MULTICAST == connectTable[dwTableIndex].dwSecondName) {
            remotename.sin_addr.s_addr = inet_addr("224.0.0.0");
            remotename.sin_port = htons(CurrentPort);
        }
        else if (NAME_UNAVAIL == connectTable[dwTableIndex].dwSecondName) {
            remotename.sin_addr.s_addr = inet_addr("127.0.0.0");
            remotename.sin_port = htons(CurrentPort);
        }
        else if (NAME_BAD == connectTable[dwTableIndex].dwSecondName) {
            remotename.sin_family = AF_UNIX;
            remotename.sin_addr.s_addr = NetsyncInAddr;
            remotename.sin_port = htons(CurrentPort);
        }
        else if (NAME_REMOTE == connectTable[dwTableIndex].dwSecondName) {
            remotename.sin_addr.s_addr = NetsyncInAddr;
            remotename.sin_port = htons(CurrentPort);
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & connectTable[dwTableIndex].dwSocket1)) {
            closesocket(sSocket1);
        }

        __try {
            // Call connect
            iReturnCode = connect((INVALID_SOCKET == nsSocket1) ? sSocket1 : nsSocket1, (NAME_NULL != connectTable[dwTableIndex].dwSecondName) ? (SOCKADDR *) &remotename : NULL, connectTable[dwTableIndex].namelen);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == connectTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "connect RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "connect caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if ((TRUE == bNonblocking) && (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket1)) && ((0 == connectTable[dwTableIndex].iReturnCode) || (WSAECONNREFUSED == connectTable[dwTableIndex].iLastError))) {
                // Non-blocking socket
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "connect returned non-SOCKET_ERROR");
                }
                else {
                    // Get the last error code
                    iLastError = WSAGetLastError();

                    if (iLastError != WSAEWOULDBLOCK) {
                        xLog(hLog, XLL_FAIL, "connect iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                    }
                    else {
                        xLog(hLog, XLL_PASS, "connect iLastError - OUT: %u", iLastError);

                        FD_ZERO(&writefds);
                        FD_ZERO(&exceptfds);
                        FD_SET(sSocket1, &writefds);
                        FD_SET(sSocket1, &exceptfds);

                        // Wait for connect to complete
                        select(0, NULL, &writefds, &exceptfds, NULL);

                        if (0 == connectTable[dwTableIndex].iReturnCode) {
                            if ((0 != FD_ISSET(sSocket1, &writefds)) && (0 == FD_ISSET(sSocket1, &exceptfds))) {
                                iReturnCode = 0;
                            }
                            else {
                                iReturnCode = SOCKET_ERROR;
                                WSASetLastError(WSAEFAULT);
                            }
                        }
                        else {
                            iReturnCode = SOCKET_ERROR;
                            if (0 != FD_ISSET(sSocket1, &exceptfds)) {
                                WSASetLastError(WSAECONNREFUSED);
                            }
                            else {
                                WSASetLastError(WSAEFAULT);
                            }
                        }
                    }
                }
            }

            if (TRUE == connectTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "connect did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == connectTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != connectTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "connect iLastError - EXPECTED: %u; RECEIVED: %u", connectTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "connect iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "connect returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (TRUE == connectTable[dwTableIndex].bSecondConnect) {
                    // Send the accept cancel
                    connectRequest.dwMessageId = CONNECT_CANCEL_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(connectRequest), (char *) &connectRequest);

                    // Wait for the accept complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);
                }
            }
            else if (SOCKET_ERROR == connectTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "connect returned non-SOCKET_ERROR");
            }
            else {
                if (TRUE == connectTable[dwTableIndex].bFirstSend) {
                    // Send data
                    ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                    sprintf(SendBuffer10, "%05d%05d", 1, 1);

                    iReturnCode = send(sSocket1, SendBuffer10, 10, 0);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "send returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                    else {
                        xLog(hLog, XLL_PASS, "send succeeded");
                    }
                }

                if (TRUE == connectTable[dwTableIndex].bSecondConnect) {
                    // Send the accept request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(connectRequest), (char *) &connectRequest);

                    // Wait for the accept complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);
                }

                if (TRUE == connectTable[dwTableIndex].bSecondSend) {
                    // Send data
                    ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);

                    iReturnCode = send(sSocket1, SendBuffer10, 10, 0);

                    if (NAME_ANY == connectTable[dwTableIndex].dwSecondName) {
                        // Send should fail
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_PASS, "send failed");
                        }
                        else {
                            xLog(hLog, XLL_FAIL, "send succeeded");
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        // Send should succeed
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "send failed");
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "send succeeded");
                        }
                    }
                }

                if (5 == connectTable[dwTableIndex].nDataBuffers) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket1, &readfds);

                    // Wait for data to be queued
                    select(0, &readfds, NULL, NULL, NULL);

                    // Receive data
                    ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                    iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);

                    if (NAME_ANY == connectTable[dwTableIndex].dwSecondName) {
                        // Recv should succeed
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv failed");
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "recv succeeded");
                        }
                    }
                }
                else if ((2 == connectTable[dwTableIndex].nDataBuffers) || (4 == connectTable[dwTableIndex].nDataBuffers)) {
                    // Get the current tick count
                    dwFirstTime = GetTickCount();

                    // Receive data
                    ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                    iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);

                    if ((TRUE == bNonblocking) && (SOCKET_ERROR == iReturnCode)) {
                        // Get the last error code
                        iLastError = WSAGetLastError();

                        if (iLastError != WSAEWOULDBLOCK) {
                            xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);

                            FD_ZERO(&readfds);
                            FD_SET(sSocket1, &readfds);

                            // Wait for data to be queued
                            select(0, &readfds, NULL, NULL, NULL);

                            // Receive data
                            iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                        }
                    }

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                    else {
                        ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                        sprintf(SendBuffer10, "%05d%05d", 1, 1);

                        if (0 != strcmp(SendBuffer10, RecvBuffer10)) {
                            xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "recv succeeded");
                        }
                    }

                    // Get the current tick count
                    dwSecondTime = GetTickCount();
                    if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                        xLog(hLog, XLL_FAIL, "recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                        bTestPassed = FALSE;
                    }

                    if (4 == connectTable[dwTableIndex].nDataBuffers) {
                        // Reset the connection
                        ZeroMemory(&remotename, sizeof(remotename));
                        remotename.sin_family = AF_INET;
                        iReturnCode = connect(sSocket1, (SOCKADDR *) &remotename, sizeof(remotename));

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "connect returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }

                    if (NAME_NULL == connectTable[dwTableIndex].dwFirstName) {
                        // Check for pending data
                        ioctlsocket(sSocket1, FIONREAD, (u_long *) &iReturnCode);

                        if (0 != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "Pending data %d bytes", iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "No pending data");
                        }
                    }
                    else {
                        // Receive data
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 2, 2);

                            if (0 != strcmp(SendBuffer10, RecvBuffer10)) {
                                xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv succeeded");
                            }
                        }
                    }
                }
                else if ((1 == connectTable[dwTableIndex].nDataBuffers) || (3 == connectTable[dwTableIndex].nDataBuffers)) {
                    if (INVALID_SOCKET != sSocket2) {
                        if (0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket2)) {
                            // Accept the connection
                            nsSocket2 = accept(sSocket2, NULL, NULL);

                            // Send data
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 1, 1);

                            send(nsSocket2, SendBuffer10, 10, 0);
                        }
                        else {
                            // Initialize localsendname
                            ZeroMemory(&remotename, sizeof(remotename));
                            remotename.sin_family = AF_INET;
                            remotename.sin_port = htons(CurrentPort);
                            remotename.sin_addr.s_addr = inet_addr("127.0.0.1");

                            // Call connect
                            connect(sSocket2, (SOCKADDR *) &remotename, sizeof(remotename));

                            // Send data
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 1, 1);

                            send(sSocket2, SendBuffer10, 10, 0);
                        }

                        // Receive data
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);

                        if ((TRUE == bNonblocking) && (SOCKET_ERROR == iReturnCode)) {
                            // Get the last error code
                            iLastError = WSAGetLastError();

                            if (iLastError != WSAEWOULDBLOCK) {
                                xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);

                                FD_ZERO(&readfds);
                                FD_SET(sSocket1, &readfds);

                                // Wait for data to be queued
                                select(0, &readfds, NULL, NULL, NULL);

                                // Receive data
                                iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                            }
                        }
                    
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 1, 1);

                            if (0 != strcmp(SendBuffer10, RecvBuffer10)) {
                                xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv succeeded");
                            }
                        }
                    }
                    else {
                        // Get the current tick count
                        dwFirstTime = GetTickCount();

                        // Receive data
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);

                        if (TRUE == bNonblocking) {
                            // Non-blocking socket
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else {
                                // Get the last error code
                                iLastError = WSAGetLastError();

                                if (iLastError != WSAEWOULDBLOCK) {
                                    xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                                    bTestPassed = FALSE;
                                }
                                else {
                                    xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);

                                    FD_ZERO(&readfds);
                                    FD_SET(sSocket1, &readfds);

                                    // Wait for data to be queued
                                    select(0, &readfds, NULL, NULL, NULL);

                                    // Receive data
                                    iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                                }
                            }
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 1, 1);

                            if (0 != strcmp(SendBuffer10, RecvBuffer10)) {
                                xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv succeeded");
                            }
                        }

                        // Get the current tick count
                        dwSecondTime = GetTickCount();
                        if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                            xLog(hLog, XLL_FAIL, "recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                            bTestPassed = FALSE;
                        }
                    }

                    if (3 == connectTable[dwTableIndex].nDataBuffers) {
                        // Switch the blocking mode
                        Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                        ioctlsocket(sSocket1, FIONBIO, &Nonblock);
                        bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                        // Receive data
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);

                        if (TRUE == bNonblocking) {
                            // Non-blocking socket
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else {
                                // Get the last error code
                                iLastError = WSAGetLastError();

                                if (iLastError != WSAEWOULDBLOCK) {
                                    xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                                    bTestPassed = FALSE;
                                }
                                else {
                                    xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);

                                    FD_ZERO(&readfds);
                                    FD_SET(sSocket1, &readfds);

                                    // Wait for data to be queued
                                    select(0, &readfds, NULL, NULL, NULL);

                                    // Receive data
                                    iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                                }
                            }
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 2, 2);

                            if (0 != strcmp(SendBuffer10, RecvBuffer10)) {
                                xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv succeeded");
                            }
                        }

                        // Get the current tick count
                        dwSecondTime = GetTickCount();
                        if (((dwSecondTime - dwFirstTime) < (SLEEP_LOW_TIME * 2)) || ((dwSecondTime - dwFirstTime) > (SLEEP_HIGH_TIME * 2))) {
                            xLog(hLog, XLL_FAIL, "recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME * 2, dwSecondTime - dwFirstTime);
                            bTestPassed = FALSE;
                        }

                        // Switch the blocking mode
                        Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                        ioctlsocket(sSocket1, FIONBIO, &Nonblock);
                        bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                        // Receive data
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);

                        if (TRUE == bNonblocking) {
                            // Non-blocking socket
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else {
                                // Get the last error code
                                iLastError = WSAGetLastError();

                                if (iLastError != WSAEWOULDBLOCK) {
                                    xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                                    bTestPassed = FALSE;
                                }
                                else {
                                    xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);

                                    FD_ZERO(&readfds);
                                    FD_SET(sSocket1, &readfds);

                                    // Wait for data to be queued
                                    select(0, &readfds, NULL, NULL, NULL);

                                    // Receive data
                                    iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                                }
                            }
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 3, 3);

                            if (0 != strcmp(SendBuffer10, RecvBuffer10)) {
                                xLog(hLog, XLL_FAIL, "recv buffer - EXPECTED: %s; RECEIVED: %s", SendBuffer10, RecvBuffer10);
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv succeeded");
                            }
                        }

                        // Get the current tick count
                        dwSecondTime = GetTickCount();
                        if (((dwSecondTime - dwFirstTime) < (SLEEP_LOW_TIME * 3)) || ((dwSecondTime - dwFirstTime) > (SLEEP_HIGH_TIME * 3))) {
                            xLog(hLog, XLL_FAIL, "recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME * 3, dwSecondTime - dwFirstTime);
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "connect succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (connectTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == connectTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket(sSocket1, FIONBIO, &Nonblock);
            bNonblocking = connectTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == connectTable[dwTableIndex].bAccept) || (TRUE == connectTable[dwTableIndex].bFirstConnect) || (TRUE == connectTable[dwTableIndex].bSecondConnect)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(connectRequest), (char *) &connectRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket2) {
            closesocket(nsSocket2);
        }

        if (INVALID_SOCKET != nsSocket1) {
            closesocket(nsSocket1);
        }

        if (INVALID_SOCKET != sSocket2) {
            closesocket(sSocket2);
        }

        if (0 == (SOCKET_CLOSED & connectTable[dwTableIndex].dwSocket1)) {
            if ((0 != (SOCKET_TCP & connectTable[dwTableIndex].dwSocket1)) || (0 != (SOCKET_UDP & connectTable[dwTableIndex].dwSocket1))) {
                closesocket(sSocket1);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort += 2;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
connectTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests connect - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long            FromInAddr;
    // dwMessageType is the type of received message
    DWORD             dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD             dwMessageSize;
    // pMessage is a pointer to the received message
    char              *pMessage;
    // connectRequest is the request
    CONNECT_REQUEST   connectRequest;
    // connectComplete is the result
    CONNECT_COMPLETE  connectComplete;

    // sSocket1 is the first socket descriptor
    SOCKET            sSocket1;
    // sSocket2 is the second socket descriptor
    SOCKET            sSocket2;
    // nsSocket1 is the first accepted socket descriptor
    SOCKET            nsSocket1;

    // bNagle indicates if Nagle is enabled
    BOOL              bNagle = FALSE;

    // localname is the local address
    SOCKADDR_IN       localname;
    // remotename is the remote address
    SOCKADDR_IN       remotename;

    // SendBuffer10 is the send buffer
    char              SendBuffer10[BUFFER_10_LEN + 1];
    // nSendCount is a counter to enumerate each send
    int               nSendCount;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&connectRequest, pMessage, sizeof(connectRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        nsSocket1 = INVALID_SOCKET;
        sSocket1 = socket(AF_INET, connectRequest.nSocketType, 0);

        sSocket2 = INVALID_SOCKET;
        if (2 == connectRequest.nDataBuffers) {
            sSocket2 = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Disable Nagle
        if (SOCK_STREAM == connectRequest.nSocketType) {
            setsockopt(sSocket1, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Initialize localname
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(connectRequest.Port);

        // Bind the socket
        ZeroMemory(&remotename, sizeof(remotename));
        remotename.sin_family = AF_INET;
        remotename.sin_addr.s_addr = FromInAddr;
        remotename.sin_port = htons(connectRequest.Port);
        bind(sSocket1, (SOCKADDR *) &localname, sizeof(localname));

        if (SOCK_STREAM == connectRequest.nSocketType) {
            if (TRUE == connectRequest.bClientAccept) {
                // Connect the socket
                connect(sSocket1, (SOCKADDR *) &remotename, sizeof(remotename));

                // Send the result
                connectComplete.dwMessageId = CONNECT_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(connectComplete), (char *) &connectComplete);
            }
            else {
                // Place the socket in listening mode
                listen(sSocket1, SOMAXCONN);

                // Send the complete
                connectComplete.dwMessageId = CONNECT_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(connectComplete), (char *) &connectComplete);

                if (TRUE == connectRequest.bServerAccept) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (CONNECT_CANCEL_MSG != connectRequest.dwMessageId) {
                        // Accept the connection
                        nsSocket1 = accept(sSocket1, NULL, NULL);
                    }

                    // Send the complete
                    connectComplete.dwMessageId = CONNECT_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(connectComplete), (char *) &connectComplete);
                }
            }
        }
        else {
            // Connect the socket
            connect(sSocket1, (SOCKADDR *) &remotename, sizeof(remotename));

            // Send the complete
            connectComplete.dwMessageId = CONNECT_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(connectComplete), (char *) &connectComplete);

            if (TRUE == connectRequest.bServerAccept) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                // Send the complete
                connectComplete.dwMessageId = CONNECT_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(connectComplete), (char *) &connectComplete);
            }
        }

        if (2 == connectRequest.nDataBuffers) {
            // Sleep
            Sleep(SLEEP_MIDLOW_TIME);

            // Send data
            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
            sprintf(SendBuffer10, "%05d%05d", 1, 1);

            send(sSocket1, SendBuffer10, 10, 0);
        
            // Bind the socket
            localname.sin_port = htons(connectRequest.Port + 1);
            bind(sSocket2, (SOCKADDR *) &localname, sizeof(localname));

            // Connect the socket
            connect(sSocket2, (SOCKADDR *) &remotename, sizeof(remotename));

            // Send data
            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
            sprintf(SendBuffer10, "%05d%05d", 2, 2);

            send(sSocket2, SendBuffer10, 10, 0);
        }
        else {
            for (nSendCount = 0; nSendCount < connectRequest.nDataBuffers; nSendCount++) {
                if ((4 != connectRequest.nDataBuffers) || (0 == nSendCount)) {
                    // Sleep
                    Sleep(SLEEP_MIDLOW_TIME);
                }

                // Send data
                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                sprintf(SendBuffer10, "%05d%05d", (nSendCount + 1), (nSendCount + 1));

                send((INVALID_SOCKET == nsSocket1) ? sSocket1 : nsSocket1, SendBuffer10, 10, 0);
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket1) {
            closesocket(nsSocket1);
        }

        if (INVALID_SOCKET != sSocket2) {
            closesocket(sSocket2);
        }

        if (INVALID_SOCKET != sSocket1) {
            closesocket(sSocket1);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\closesocket.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  closesocket.c

Abstract:

  This modules tests closesocket

Author:

  Steven Kehrli (steveke) 2-Mar-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// closesocket messages

#define CLOSESOCKET_REQUEST_MSG   NETSYNC_MSG_USER + 290 + 1
#define CLOSESOCKET_COMPLETE_MSG  NETSYNC_MSG_USER + 290 + 2

typedef struct _CLOSESOCKET_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    BOOL     bNonblock;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bFillSendQueue;
    BOOL     bFillReceiveQueue;
    BOOL     bClearQueue;
    INT      nSendQueueLen;
    int      linger;
    u_short  l_onoff;
    u_short  l_linger;
    BOOL     bServerClose;
} CLOSESOCKET_REQUEST, *PCLOSESOCKET_REQUEST;

typedef struct _CLOSESOCKET_COMPLETE {
    DWORD    dwMessageId;
    INT      nSendQueueLen;
    INT      nReceiveQueueLen;
} CLOSESOCKET_COMPLETE, *PCLOSESOCKET_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct CLOSESOCKET_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL     bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD    dwSocket;                                // dwSocket indicates the socket to be created
    BOOL     bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking
    BOOL     bBind;                                   // bBind indicates if the socket is to be bound
    BOOL     bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL     bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL     bConnect;                                // bConnect indicates if the socket is connected
    BOOL     bFillSendQueue;                          // bFillSendQueue specifies to fill the send queue
    BOOL     bFillReceiveQueue;                       // bFillReceiveQueue specifies to fill the receive queue
    BOOL     bClearQueue;                             // bClearQueue specifies the server to clear its queue via receive
    BOOL     bSendPending;                            // bSendPending specifies if a send operation is pending
    BOOL     bReceivePending;                         // bReceivePending specifies if a receive operation is pending
    int      linger;                                  // linger specifies the linger option
    u_short  l_onoff;                                 // l_onoff specifies if socket remains open to enable queued data to be sent
    u_short  l_linger;                                // l_linger specifies the time-out value for the socket
    BOOL     bServerClose;                            // bServerClose indicates if server closes connection
    int      iReturnCode;                             // iReturnCode is the return code of closesocket
    int      iLastError;                              // iLastError is the error code if the operation failed
    BOOL     bRIP;                                    // Specifies a RIP test case
} CLOSESOCKET_TABLE, *PCLOSESOCKET_TABLE;

static CLOSESOCKET_TABLE closesocketTable[] =
{
    { "29.1 Not Initialized",          FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "29.2 s = INT_MIN",              TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "29.3 s = -1",                   TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "29.4 s = 0",                    TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "29.5 s = INT_MAX",              TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "29.6 s = INVALID_SOCKET",       TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "29.7 TCP L NB DL",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.8 TCP L NB L0",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.9 TCP L NB L10",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.10 TCP L NB L15",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.11 TCP L B DL",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.12 TCP L B L0",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.13 TCP L B L10",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.14 TCP L B L15",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.15 TCP L L DL",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.16 TCP L L L0",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.17 TCP L L L10",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.18 TCP L L L15",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.19 TCP L A DL",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.20 TCP L A L0",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.21 TCP L A L10",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.22 TCP L A L15",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.23 TCP L C DL",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.24 TCP L C L0",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.25 TCP L C L10",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.26 TCP L C L15",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.27 TCP L C TFull DL",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.28 TCP L C TFull L0",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.29 TCP L C TFull L10",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.30 TCP L C TFull L15",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.31 TCP L C TFullC DL",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.32 TCP L C TFullC L0",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.33 TCP L C TFullC L10",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.34 TCP L C TFullC L15",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.35 TCP L C RFull DL",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.36 TCP L C RFull L0",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.37 TCP L C RFull L10",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.38 TCP L C RFull L15",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.39 TCP L C TRFull DL",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.40 TCP L C TRFull L0",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.41 TCP L C TRFull L10",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.42 TCP L C TRFull L15",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.43 TCP L C TRFullC DL",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.44 TCP L C TRFullC L0",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.45 TCP L C TRFullC L10",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.46 TCP L C TRFullC L15",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.47 TCP L C TPend DL",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.48 TCP L C TPend L0",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.49 TCP L C TPend L10",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.50 TCP L C TPend L15",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.51 TCP L C TPendC DL",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.52 TCP L C TPendC L0",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.53 TCP L C TPendC L10",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.54 TCP L C TPendC L15",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.55 TCP L C RPend DL",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.56 TCP L C RPend L0",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.57 TCP L C RPend L10",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.58 TCP L C RPend L15",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.59 TCP L C TRPend DL",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.60 TCP L C TRPend L0",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.61 TCP L C TRPend L10",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.62 TCP L C TRPend L15",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.63 TCP L C TRPendC DL",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.64 TCP L C TRPendC L0",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.65 TCP L C TRPendC L10",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.66 TCP L C TRPendC L15",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.67 TCP L NB DL NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.68 TCP L NB L0 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.69 TCP L NB L10 NB",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.70 TCP L NB L15 NB",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.71 TCP L B DL NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.72 TCP L B L0 NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.73 TCP L B L10 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.74 TCP L B L15 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.75 TCP L L DL NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.76 TCP L L L0 NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.77 TCP L L L10 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.78 TCP L L L15 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.79 TCP L A DL NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.80 TCP L A L0 NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.81 TCP L A L10 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.82 TCP L A L15 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.83 TCP L C DL NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.84 TCP L C L0 NB",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.85 TCP L C L10 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.86 TCP L C L15 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.87 TCP L C TFull DL NB",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.88 TCP L C TFull L0 NB",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.89 TCP L C TFull L10 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.90 TCP L C TFull L15 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
// BUGBUG: Xbox always does asynchronous linger
//    { "29.90 TCP L C TFull L15 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, SOCKET_ERROR, WSAEWOULDBLOCK    },
    { "29.91 TCP L C TFullC DL NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.92 TCP L C TFullC L0 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.93 TCP L C TFullC L10 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.94 TCP L C TFullC L15 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
// BUGBUG: Xbox always does asynchronous linger
//    { "29.94 TCP L C TFullC L15 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, SO_LINGER,     1, 5, FALSE, SOCKET_ERROR, WSAEWOULDBLOCK    },
    { "29.95 TCP L C RFull DL NB",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.96 TCP L C RFull L0 NB",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.97 TCP L C RFull L10 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.98 TCP L C RFull L15 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.99 TCP L C TRFull DL NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.100 TCP L C TRFull L0 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.101 TCP L C TRFull L10 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.102 TCP L C TRFull L15 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
// BUGBUG: Xbox always does asynchronous linger
//    { "29.102 TCP L C TRFull L15 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, SOCKET_ERROR, WSAEWOULDBLOCK    },
    { "29.103 TCP L C TRFullC DL NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.104 TCP L C TRFullC L0 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.105 TCP L C TRFullC L10 NB", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.106 TCP L C TRFullC L15 NB", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
// BUGBUG: Xbox always does asynchronous linger
//    { "29.106 TCP L C TRFullC L15 NB", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     1, 5, FALSE, SOCKET_ERROR, WSAEWOULDBLOCK    },
    { "29.107 TCP L C TPend DL NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.108 TCP L C TPend L0 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.109 TCP L C TPend L10 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.110 TCP L C TPend L15 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
// BUGBUG: Xbox always does asynchronous linger
//    { "29.110 TCP L C TPend L15 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, SO_LINGER,     1, 5, FALSE, SOCKET_ERROR, WSAEWOULDBLOCK    },
    { "29.111 TCP L C TPendC DL NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.112 TCP L C TPendC L0 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.113 TCP L C TPendC L10 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.114 TCP L C TPendC L15 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
// BUGBUG: Xbox always does asynchronous linger
//    { "29.114 TCP L C TPendC L15 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, SO_LINGER,     1, 5, FALSE, SOCKET_ERROR, WSAEWOULDBLOCK    },
    { "29.115 TCP L C RPend DL NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.116 TCP L C RPend L0 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.117 TCP L C RPend L10 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.118 TCP L C RPend L15 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.119 TCP L C TRPend DL NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.120 TCP L C TRPend L0 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.121 TCP L C TRPend L10 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.122 TCP L C TRPend L15 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
// BUGBUG: Xbox always does asynchronous linger
//    { "29.122 TCP L C TRPend L15 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  SO_LINGER,     1, 5, FALSE, SOCKET_ERROR, WSAEWOULDBLOCK    },
    { "29.123 TCP L C TRPendC DL NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.124 TCP L C TRPendC L0 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.125 TCP L C TRPendC L10 NB", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.126 TCP L C TRPendC L15 NB", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
// BUGBUG: Xbox always does asynchronous linger
//    { "29.126 TCP L C TRPendC L15 NB", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  SO_LINGER,     1, 5, FALSE, SOCKET_ERROR, WSAEWOULDBLOCK    },
    { "29.127 TCP R A DL NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, TRUE,  0,            0,                 FALSE },
    { "29.128 TCP R A L0 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, TRUE,  0,            0,                 FALSE },
    { "29.129 TCP R A L10 NB",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, TRUE,  0,            0,                 FALSE },
    { "29.130 TCP R A L15 NB",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, TRUE,  0,            0,                 FALSE },
    { "29.131 TCP R C DL NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, TRUE,  0,            0,                 FALSE },
    { "29.132 TCP R C L0 NB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, TRUE,  0,            0,                 FALSE },
    { "29.133 TCP R C L10 NB",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, TRUE,  0,            0,                 FALSE },
    { "29.134 TCP R C L15 NB",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, TRUE,  0,            0,                 FALSE },
    { "29.135 TCP R C TFull DL NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, TRUE,  0,            0,                 FALSE },
    { "29.136 TCP R C TFull L0 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, TRUE,  0,            0,                 FALSE },
    { "29.137 TCP R C TFull L10 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, TRUE,  0,            0,                 FALSE },
    { "29.138 TCP R C RFull DL NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, TRUE,  0,            0,                 FALSE },
    { "29.139 TCP R C RFull L0 NB",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     0, 0, TRUE,  0,            0,                 FALSE },
    { "29.140 TCP R C RFull L10 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 0, TRUE,  0,            0,                 FALSE },
    { "29.141 TCP R C RFullC DL NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, FALSE, SO_DONTLINGER, 0, 0, TRUE,  0,            0,                 FALSE },
    { "29.142 TCP R C RFullC L0 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     0, 0, TRUE,  0,            0,                 FALSE },
    { "29.143 TCP R C RFullC L10 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     1, 0, TRUE,  0,            0,                 FALSE },
    { "29.144 TCP R C TRFull DL NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, TRUE,  0,            0,                 FALSE },
    { "29.145 TCP R C TRFull L0 NB",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     0, 0, TRUE,  0,            0,                 FALSE },
    { "29.146 TCP R C TRFull L10 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, SO_LINGER,     1, 0, TRUE,  0,            0,                 FALSE },
    { "29.147 TCP R C TRFullC DL NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_DONTLINGER, 0, 0, TRUE,  0,            0,                 FALSE },
    { "29.148 TCP R C TRFullC L0 NB",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     0, 0, TRUE,  0,            0,                 FALSE },
    { "29.149 TCP R C TRFullC L10 NB", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, SO_LINGER,     1, 0, TRUE,  0,            0,                 FALSE },
    { "29.150 UDP L NB DL",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.151 UDP L NB L0",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.152 UDP L NB L10",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.153 UDP L NB L15",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.154 UDP L B DL",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.155 UDP L B L0",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.156 UDP L B L10",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.157 UDP L B L15",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.158 UDP L C DL",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.159 UDP L C L0",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.160 UDP L C L10",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.161 UDP L C L15",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.162 UDP L C RPend DL",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.163 UDP L C RPend L0",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.164 UDP L C RPend L10",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.165 UDP L C RPend L15",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.166 UDP L NB DL NB",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.167 UDP L NB L0 NB",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.168 UDP L NB L10 NB",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.169 UDP L NB L15 NB",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.170 UDP L B DL NB",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.171 UDP L B L0 NB",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.172 UDP L B L10 NB",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.173 UDP L B L15 NB",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.174 UDP L C DL NB",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.175 UDP L C L0 NB",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.176 UDP L C L10 NB",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.177 UDP L C L15 NB",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.178 UDP L C RPend DL NB",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_DONTLINGER, 0, 0, FALSE, 0,            0,                 FALSE },
    { "29.179 UDP L C RPend L0 NB",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     0, 0, FALSE, 0,            0,                 FALSE },
    { "29.180 UDP L C RPend L10 NB",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     1, 0, FALSE, 0,            0,                 FALSE },
    { "29.181 UDP L C RPend L15 NB",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  SO_LINGER,     1, 5, FALSE, 0,            0,                 FALSE },
    { "29.182 TCP Closed",             TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "29.183 UDP Closed",             TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "29.184 Not Initialized",        FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, SO_DONTLINGER, 0, 0, FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define closesocketTableCount (sizeof(closesocketTable) / sizeof(CLOSESOCKET_TABLE))

NETSYNC_TYPE_THREAD  closesocketTestSessionNt =
{
    1,
    closesocketTableCount,
    L"xnetapi_nt.dll",
    "closesocketTestServer"
};

NETSYNC_TYPE_THREAD  closesocketTestSessionXbox =
{
    1,
    closesocketTableCount,
    L"xnetapi_xbox.dll",
    "closesocketTestServer"
};



VOID
closesocketTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests closesocket - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // closesocketRequest is the request sent to the server
    CLOSESOCKET_REQUEST    closesocketRequest;
    
    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                  dwBufferSize = 1;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;

    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                   RecvBuffer10[BUFFER_10_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];

    // dwFirstTime is the first tick count
    DWORD                  dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                  dwSecondTime;

    // bsOpened indicates the sSocket socket is opened
    BOOL                   bsOpened;
    // bnsOpened indicates the nsSocket socket is opened
    BOOL                   bnsOpened;
    // nSendQueueLen is the size of the send queue
    int                    nSendQueueLen = 0;
    // nReceiveQueueLen is the size of the receive queue
    int                    nReceiveQueueLen = 0;
    // nReceiveBuffer is a counter to empty the receive queue
    int                    nReceiveBuffer;
    // bDontLinger indicates if SO_DONTLINGER is set
    BOOL                   bDontLinger;
    // linger is the linger structure
    struct linger          linger;

    // hSendEvent is a handle to the overlapped send event
    HANDLE                 hSendEvent;
    // WSASendOverlapped is the overlapped send structure
    WSAOVERLAPPED          WSASendOverlapped;
    // WSASendBuf is the WSABUF structure
    WSABUF                 WSASendBuf;
    // dwSendBytes is the number of bytes transferred for the function call
    DWORD                  dwSendBytes;
    // dwSendFlags is the transfer flags for the function call
    DWORD                  dwSendFlags;

    // hReceiveEvent is a handle to the overlapped receive event
    HANDLE                 hReceiveEvent;
    // WSAReceiveOverlapped is the overlapped receive structure
    WSAOVERLAPPED          WSAReceiveOverlapped;
    // WSAReceiveBuf is the WSABUF structure
    WSABUF                 WSAReceiveBuf;
    // dwReceiveBytes is the number of bytes transferred for the function call
    DWORD                  dwReceiveBytes;
    // dwReceiveFlags is the transfer flags for the function call
    DWORD                  dwReceiveFlags;

    // dwReturnCode is the return code of WaitForSingleObject
    DWORD                  dwReturnCode;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "closesocket v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_closesocket+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_closesocket-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = closesocketTestSessionXbox;
    }
    else {
        NetsyncTypeSession = closesocketTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < closesocketTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, closesocketTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, closesocketTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != closesocketTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, closesocketTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == closesocketTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != closesocketTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == closesocketTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = closesocketTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == closesocketTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the overlapped event
        hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hReceiveEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        // Setup the overlapped structure
        ZeroMemory(&WSASendOverlapped, sizeof(WSASendOverlapped));
        WSASendOverlapped.hEvent = hSendEvent;

        ZeroMemory(&WSAReceiveOverlapped, sizeof(WSAReceiveOverlapped));
        WSAReceiveOverlapped.hEvent = hReceiveEvent;

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == closesocketTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == closesocketTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == closesocketTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == closesocketTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == closesocketTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & closesocketTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
            bsOpened = TRUE;
        }
        else if (0 != (SOCKET_UDP & closesocketTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
            bsOpened = TRUE;
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & closesocketTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the buffer size
        if ((0 != (SOCKET_TCP & closesocketTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & closesocketTable[dwTableIndex].dwSocket))) {
            dwBufferSize = 1;
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            dwBufferSize = 1;
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the socket to non-blocking mode
        if (TRUE == closesocketTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Set the linger option
        if (SO_DONTLINGER == closesocketTable[dwTableIndex].linger) {
            bDontLinger = TRUE;
            setsockopt(sSocket, SOL_SOCKET, SO_DONTLINGER, (char *) &bDontLinger, sizeof(bDontLinger));
        }
        else {
            linger.l_onoff = closesocketTable[dwTableIndex].l_onoff;
            linger.l_linger = closesocketTable[dwTableIndex].l_linger;
            setsockopt(sSocket, SOL_SOCKET, SO_LINGER, (char *) &linger, sizeof(linger));
        }

        // Bind the socket
        if (TRUE == closesocketTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == closesocketTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if ((TRUE == closesocketTable[dwTableIndex].bAccept) || (TRUE == closesocketTable[dwTableIndex].bConnect)) {
            // Initialize the closesocket request
            closesocketRequest.dwMessageId = CLOSESOCKET_REQUEST_MSG;
            if (0 != (SOCKET_TCP & closesocketTable[dwTableIndex].dwSocket)) {
                closesocketRequest.nSocketType = SOCK_STREAM;
            }
            else {
                closesocketRequest.nSocketType = SOCK_DGRAM;
            }
            closesocketRequest.bNonblock = closesocketTable[dwTableIndex].bNonblock;
            closesocketRequest.Port = CurrentPort;
            closesocketRequest.bServerAccept = closesocketTable[dwTableIndex].bConnect;
            closesocketRequest.bFillSendQueue = closesocketTable[dwTableIndex].bFillSendQueue;
            closesocketRequest.bFillReceiveQueue = closesocketTable[dwTableIndex].bFillReceiveQueue;
            closesocketRequest.bClearQueue = closesocketTable[dwTableIndex].bClearQueue;
            closesocketRequest.nSendQueueLen = 0;
            closesocketRequest.linger = closesocketTable[dwTableIndex].linger;
            closesocketRequest.l_onoff = closesocketTable[dwTableIndex].l_onoff;
            closesocketRequest.l_linger = closesocketTable[dwTableIndex].l_linger;
            closesocketRequest.bServerClose = closesocketTable[dwTableIndex].bServerClose;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(closesocketRequest), (char *) &closesocketRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == closesocketTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

                if (0 != (SOCKET_TCP & closesocketTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else if (TRUE == closesocketTable[dwTableIndex].bAccept) {
                if (0 != (SOCKET_TCP & closesocketTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
                bnsOpened = TRUE;
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(closesocketRequest), (char *) &closesocketRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == closesocketTable[dwTableIndex].bFillSendQueue) {
                if (FALSE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                // Fill the queue
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                    closesocketRequest.nSendQueueLen++;
                    Sleep(SLEEP_ZERO_TIME);
                }

                if (FALSE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }

            // Start the pending overlapped operation
            if (TRUE == closesocketTable[dwTableIndex].bSendPending) {
                // Call WSASend
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                WSASendBuf.len = BUFFER_TCPSEGMENT_LEN;
                WSASendBuf.buf = SendBufferLarge;
                dwSendBytes = 0;

                iReturnCode = WSASend((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSASendBuf, 1, &dwSendBytes, 0, &WSASendOverlapped, NULL);

                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSASend returned non-SOCKET_ERROR");
                }
                else if (WSA_IO_PENDING != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "WSASend iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
                }
            }

            if (TRUE == closesocketTable[dwTableIndex].bReceivePending) {
                // Call WSARecv
                ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                WSAReceiveBuf.len = sizeof(RecvBuffer10);
                WSAReceiveBuf.buf = RecvBuffer10;
                dwReceiveBytes = 0;
                dwReceiveFlags = 0;

                iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAReceiveBuf, 1, &dwReceiveBytes, &dwReceiveFlags, &WSAReceiveOverlapped, NULL);

                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
                }
                else if (WSA_IO_PENDING != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
                }
            }
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & closesocketTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
            bsOpened = FALSE;
        }

        __try {
            // Call closesocket
            iReturnCode = 0;
            if (FALSE == closesocketTable[dwTableIndex].bServerClose) {
                // Get the current tick count
                dwFirstTime = GetTickCount();

                iReturnCode = closesocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket);
                iLastError = WSAGetLastError();

                // Get the current tick count
                dwSecondTime = GetTickCount();

                if (0 == iReturnCode) {
                    if (INVALID_SOCKET == nsSocket) {
                        bsOpened = FALSE;
                    }
                    else {
                        bnsOpened = FALSE;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            xLog(hLog, XLL_EXCEPTION, "closesocket caused an exception - ec = 0x%08x", GetExceptionCode());
        }

        if (FALSE == bException) {
            if (TRUE == closesocketTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "closesocket did not RIP");
            }

            if ((TRUE == closesocketTable[dwTableIndex].bAccept) || (TRUE == closesocketTable[dwTableIndex].bConnect)) {
                // Send the connect request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(closesocketRequest), (char *) &closesocketRequest);

                // Wait for the connect complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                nSendQueueLen = ((PCLOSESOCKET_COMPLETE) pMessage)->nSendQueueLen;
                nReceiveQueueLen = ((PCLOSESOCKET_COMPLETE) pMessage)->nReceiveQueueLen;
                NetsyncFreeMessage(pMessage);
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == closesocketTable[dwTableIndex].iReturnCode)) {
                if (iLastError != closesocketTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "closesocket iLastError - EXPECTED: %u; RECEIVED: %u", closesocketTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "closesocket iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "closesocket returned SOCKET_ERROR - ec = %u", iLastError);
            }
            else if (SOCKET_ERROR == closesocketTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "closesocket returned non-SOCKET_ERROR");
            }
            else {
                if (FALSE == closesocketTable[dwTableIndex].bServerClose) {
                    if ((dwSecondTime - dwFirstTime) > SLEEP_ZERO_TIME) {
                        xLog(hLog, XLL_FAIL, "closesocket nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_ZERO_TIME, dwSecondTime - dwFirstTime);
                        bTestPassed = FALSE;
                    }
                }

// BUGBUG: Xbox always does asynchronous linger
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                if (FALSE == closesocketTable[dwTableIndex].bServerClose) {
                    if ((5 == closesocketTable[dwTableIndex].l_linger) && (TRUE == closesocketTable[dwTableIndex].bFillSendQueue)) {
                        if (FALSE == closesocketTable[dwTableIndex].bClearQueue) {
                            if (((dwSecondTime - dwFirstTime) < (SLEEP_LOW_TIME * 2)) || ((dwSecondTime - dwFirstTime) > (SLEEP_HIGH_TIME * 2))) {
                                xLog(hLog, XLL_FAIL, "closesocket nTime - EXPECTED: %d; RECEIVED: %d", 5000, dwSecondTime - dwFirstTime);
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if ((dwSecondTime - dwFirstTime) > (SLEEP_HIGH_TIME * 2)) {
                                xLog(hLog, XLL_FAIL, "closesocket nTime - EXPECTED: %d; RECEIVED: %d", 5000, dwSecondTime - dwFirstTime);
                                bTestPassed = FALSE;
                            }
                        }
                    }
                    else {
                        if ((dwSecondTime - dwFirstTime) > SLEEP_ZERO_TIME) {
                            xLog(hLog, XLL_FAIL, "closesocket nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_ZERO_TIME, dwSecondTime - dwFirstTime);
                            bTestPassed = FALSE;
                        }
                    }
                }
------------------------------------------------------------------------------*/

                if (TRUE == closesocketTable[dwTableIndex].bSendPending) {
                    dwReturnCode = WaitForSingleObject(hSendEvent, 0);
                    if (WAIT_TIMEOUT == dwReturnCode) {
                        xLog(hLog, XLL_FAIL, "WaitForSingleObject send returned WAIT_TIMEOUT");
                        bTestPassed = FALSE;
                    }
                }

                if (TRUE == closesocketTable[dwTableIndex].bReceivePending) {
                    dwReturnCode = WaitForSingleObject(hReceiveEvent, 0);
                    if (WAIT_TIMEOUT == dwReturnCode) {
                        xLog(hLog, XLL_FAIL, "WaitForSingleObject receive returned WAIT_TIMEOUT");
                        bTestPassed = FALSE;
                    }
                }

                if (((TRUE == closesocketTable[dwTableIndex].bAccept) || (TRUE == closesocketTable[dwTableIndex].bConnect)) && (TRUE == closesocketTable[dwTableIndex].bClearQueue) && (FALSE == closesocketTable[dwTableIndex].bServerClose)) {
                    if ((TRUE == closesocketTable[dwTableIndex].bFillReceiveQueue) || ((1 == closesocketTable[dwTableIndex].l_onoff) && (0 == closesocketTable[dwTableIndex].l_linger))) {
                        if (nSendQueueLen >= closesocketRequest.nSendQueueLen) {
                            xLog(hLog, XLL_FAIL, "nSendQueueLen - EXPECTED: <%d; RECEIVED: %d", closesocketRequest.nSendQueueLen, nSendQueueLen);
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (nSendQueueLen != closesocketRequest.nSendQueueLen) {
                            xLog(hLog, XLL_FAIL, "nSendQueueLen - EXPECTED: %d; RECEIVED: %d", closesocketRequest.nSendQueueLen, nSendQueueLen);
                            bTestPassed = FALSE;
                        }
                    }
                }

                if ((INVALID_SOCKET == nsSocket) ? (TRUE == bsOpened) : (TRUE == bnsOpened)) {
                    if ((TRUE == closesocketTable[dwTableIndex].bFillReceiveQueue) && (TRUE == closesocketRequest.bClearQueue)) {
                        if (FALSE == bNonblocking) {
                            Nonblock = 1;
                            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                        }

                        // Clear the queue
                        nReceiveBuffer = 0;
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                        do {
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, BUFFER_TCPSEGMENT_LEN, 0);
                            if ((0 != iReturnCode) && (SOCKET_ERROR != iReturnCode)) {
                                Sleep(SLEEP_ZERO_TIME);
                                nReceiveBuffer += iReturnCode;
                            }
                        } while ((0 != iReturnCode) && (SOCKET_ERROR != iReturnCode));
                        nReceiveBuffer = (nReceiveBuffer / BUFFER_TCPSEGMENT_LEN) + ((nReceiveBuffer % BUFFER_TCPSEGMENT_LEN) ? 1 : 0);

                        if (FALSE == bNonblocking) {
                            Nonblock = 0;
                            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                        }

                        if (nReceiveBuffer != nReceiveQueueLen) {
                            xLog(hLog, XLL_FAIL, "nReceiveQueueLen - EXPECTED: %d; RECEIVED: %d", nReceiveQueueLen, nReceiveBuffer);
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "closesocket succeeded");
                }
            }
        }

        if ((TRUE == closesocketTable[dwTableIndex].bAccept) || (TRUE == closesocketTable[dwTableIndex].bConnect)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(closesocketRequest), (char *) &closesocketRequest);
        }

        // Close the sockets
        if (TRUE == bnsOpened) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (TRUE == bsOpened) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }

        // Close the event
        CloseHandle(hReceiveEvent);
        CloseHandle(hSendEvent);

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
closesocketTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests closesocket - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                FromInAddr;
    // dwMessageType is the type of received message
    DWORD                 dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                 dwMessageSize;
    // pMessage is a pointer to the received message
    char                  *pMessage;
    // closesocketRequest is the request
    CLOSESOCKET_REQUEST   closesocketRequest;
    // closesocketComplete is the result
    CLOSESOCKET_COMPLETE  closesocketComplete;

    // sSocket is the socket descriptor
    SOCKET                sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                 dwBufferSize = 1;
    // bNagle indicates if Nagle is enabled
    BOOL                  bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                  bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN           localname;
    // remotename is the remote address
    SOCKADDR_IN           remotename;

    // SendBufferLarge is the large send buffer
    char                  SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                  RecvBufferLarge[BUFFER_LARGE_LEN + 1];

    // bDontLinger indicates if SO_DONTLINGER is set
    BOOL                  bDontLinger;
    // linger is the linger structure
    struct linger         linger;

    // iReturnCode is the return code of the operation
    int                    iReturnCode;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&closesocketRequest, pMessage, sizeof(closesocketRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, closesocketRequest.nSocketType, 0);

        if (SOCK_STREAM == closesocketRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the buffer size
        dwBufferSize = 1;
        setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        dwBufferSize = 1;
        setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        // Set the socket to non-blocking mode
        if (TRUE == closesocketRequest.bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Set the linger option
        if (SO_DONTLINGER == closesocketRequest.linger) {
            bDontLinger = TRUE;
            setsockopt(sSocket, SOL_SOCKET, SO_DONTLINGER, (char *) &bDontLinger, sizeof(bDontLinger));
        }
        else {
            linger.l_onoff = closesocketRequest.l_onoff;
            linger.l_linger = closesocketRequest.l_linger;
            setsockopt(sSocket, SOL_SOCKET, SO_LINGER, (char *) &linger, sizeof(linger));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(closesocketRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == closesocketRequest.nSocketType) && (TRUE == closesocketRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(closesocketRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        closesocketComplete.dwMessageId = CLOSESOCKET_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(closesocketComplete), (char *) &closesocketComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == closesocketRequest.nSocketType) && (TRUE == closesocketRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        // Fill the receive queue
        closesocketComplete.nReceiveQueueLen = 0;
        if (TRUE == closesocketRequest.bFillReceiveQueue) {
            if (FALSE == bNonblocking) {
                Nonblock = 1;
                ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            }

            ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
            while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                closesocketComplete.nReceiveQueueLen++;
                Sleep(SLEEP_ZERO_TIME);
            }

            if (FALSE == bNonblocking) {
                Nonblock = 0;
                ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            }
        }

        // Send the complete
        closesocketComplete.dwMessageId = CLOSESOCKET_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(closesocketComplete), (char *) &closesocketComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        closesocketComplete.nSendQueueLen = 0;
        if (TRUE == closesocketRequest.bServerClose) {
            closesocket(sSocket);
        }
        else {
            if (TRUE == closesocketRequest.bClearQueue) {
                if (FALSE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                // Clear the queue
                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                do {
                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, BUFFER_TCPSEGMENT_LEN, 0);
                    if ((0 != iReturnCode) && (SOCKET_ERROR != iReturnCode)) {
                        Sleep(SLEEP_ZERO_TIME);
                        closesocketComplete.nSendQueueLen += iReturnCode;
                    }
                } while ((0 != iReturnCode) && (SOCKET_ERROR != iReturnCode));
                closesocketComplete.nSendQueueLen = (closesocketComplete.nSendQueueLen / BUFFER_TCPSEGMENT_LEN) + ((closesocketComplete.nSendQueueLen % BUFFER_TCPSEGMENT_LEN) ? 1 : 0);

                if (FALSE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Send the complete
        closesocketComplete.dwMessageId = CLOSESOCKET_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(closesocketComplete), (char *) &closesocketComplete);

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\getsockname.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  getsockname.c

Abstract:

  This modules tests getsockname

Author:

  Steven Kehrli (steveke) 8-Jan-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// getsockname messages

#define GETSOCKNAME_REQUEST_MSG   NETSYNC_MSG_USER + 210 + 1
#define GETSOCKNAME_COMPLETE_MSG  NETSYNC_MSG_USER + 210 + 2

typedef struct _GETSOCKNAME_REQUEST {
    DWORD    dwMessageId;
    BOOL     bServerAccept;
    u_short  Port;
} GETSOCKNAME_REQUEST, *PGETSOCKNAME_REQUEST;

typedef struct _GETSOCKNAME_COMPLETE {
    DWORD    dwMessageId;
} GETSOCKNAME_COMPLETE, *PGETSOCKNAME_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct GETSOCKNAME_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    BOOL   bAnyPort;                                // bAnyPort indicates if any port is used for the bind call
    BOOL   bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL   bConnect;                                // bConnect indicates if the socket is connected
    BOOL   bname;                                   // bname indicates if the address buffer is used
    BOOL   bnamelen;                                // bnamelen indicates if socknamelen is used
    int    namelen;                                 // namelen is the length of the address buffer
    int    iReturnCode;                             // iReturnCode is the return code of getsockname
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} GETSOCKNAME_TABLE, *PGETSOCKNAME_TABLE;

static GETSOCKNAME_TABLE getsocknameTable[] =
{
    { "21.1 Not Initialized",     FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "21.2 s = INT_MIN",         TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "21.3 s = -1",              TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "21.4 s = 0",               TRUE,  TRUE,  SOCKET_ZERO,                FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "21.5 s = INT_MAX",         TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "21.6 s = INVALID_SOCKET",  TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "21.7 Not Bound TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "21.8 Bound TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.9 Bound Any Port TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.10 Bound Any TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.11 Connected TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, TRUE,  TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.12 Accepted TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.13 NULL addr TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.14 addr TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.15 Large addrlen TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "21.16 Exact addrlen TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.17 Small addrlen TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.18 Zero addrlen TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.19 Neg addrlen TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.20 NULL addrlen TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.21 Not Bound UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "21.22 Bound UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.23 Bound Any Port UDP", TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.24 Bound Any UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.25 Connected UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, TRUE,  TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.26 NULL addr UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.27 addr UDP",           TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.28 Large addrlen UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "21.29 Exact addrlen UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "21.30 Small addrlen UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.31 Zero addrlen UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.32 Neg addrlen UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.33 NULL addrlen UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "21.34 Closed Socket TCP",  TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "21.35 Closed Socket UDP",  TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "21.36 Not Initialized",    FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define getsocknameTableCount (sizeof(getsocknameTable) / sizeof(GETSOCKNAME_TABLE))

NETSYNC_TYPE_THREAD  getsocknameTestSessionNt =
{
    1,
    getsocknameTableCount,
    L"xnetapi_nt.dll",
    "getsocknameTestServer"
};

NETSYNC_TYPE_THREAD  getsocknameTestSessionXbox =
{
    1,
    getsocknameTableCount,
    L"xnetapi_xbox.dll",
    "getsocknameTestServer"
};



VOID
getsocknameTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests getsockname - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // getsocknameRequest is the request sent to the server
    GETSOCKNAME_REQUEST    getsocknameRequest;
    
    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;
    // namelen is the size of the address information buffer
    int                    namelen;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "getsockname v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_getsockname+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_getsockname-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = getsocknameTestSessionXbox;
    }
    else {
        NetsyncTypeSession = getsocknameTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < getsocknameTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, getsocknameTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, getsocknameTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != getsocknameTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, getsocknameTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == getsocknameTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != getsocknameTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == getsocknameTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = getsocknameTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == getsocknameTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == getsocknameTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == getsocknameTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == getsocknameTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == getsocknameTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == getsocknameTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & getsocknameTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & getsocknameTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Bind the socket
        if (TRUE == getsocknameTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;

            if (TRUE == getsocknameTable[dwTableIndex].bAnyPort) {
                localname.sin_port = 0;
            }
            else {
                localname.sin_port = htons(CurrentPort);
            }

            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        if ((0 != (SOCKET_TCP & getsocknameTable[dwTableIndex].dwSocket)) && ((TRUE == getsocknameTable[dwTableIndex].bAccept) || (TRUE == getsocknameTable[dwTableIndex].bConnect))) {
            if (TRUE == getsocknameTable[dwTableIndex].bAccept) {
                // Listen for connection
                listen(sSocket, SOMAXCONN);
            }

            // Initialize the connect request
            getsocknameRequest.dwMessageId = GETSOCKNAME_REQUEST_MSG;
            getsocknameRequest.bServerAccept = getsocknameTable[dwTableIndex].bConnect;
            getsocknameRequest.Port = CurrentPort;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(getsocknameRequest), (char *) &getsocknameRequest);

            // Wait for the connect result
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == getsocknameTable[dwTableIndex].bAccept) {
                // Accept the connection
                nsSocket = accept(sSocket, NULL, NULL);
            }
        }

        if (TRUE == getsocknameTable[dwTableIndex].bConnect) {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(CurrentPort);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Initialize the local name
        namelen = getsocknameTable[dwTableIndex].namelen;
        ZeroMemory(&localname, sizeof(localname));

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & getsocknameTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call getsockname
            iReturnCode = getsockname((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (TRUE == getsocknameTable[dwTableIndex].bname) ? (SOCKADDR *) &localname : NULL, (TRUE == getsocknameTable[dwTableIndex].bnamelen) ? &namelen : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == getsocknameTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "getsockname RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "getsockname caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == getsocknameTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "getsockname did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == getsocknameTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != getsocknameTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "iLastError - EXPECTED: %u; RECEIVED: %u", getsocknameTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "getsockname returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == getsocknameTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "getsockname returned non-SOCKET_ERROR");
            }
            else {
                if (sizeof(localname) != namelen) {
                    xLog(hLog, XLL_FAIL, "namelen - EXPECTED: %d; RECEIVED: %d", sizeof(localname), namelen);
                    bTestPassed = FALSE;
                }

                if (AF_INET != localname.sin_family) {
                    xLog(hLog, XLL_FAIL, "sin_family - EXPECTED: %d; RECEIVED: %d", AF_INET, localname.sin_family);
                    bTestPassed = FALSE;
                }

                if (0 != localname.sin_addr.s_addr) {
                    xLog(hLog, XLL_FAIL, "sin_addr - EXPECTED: %u; RECEIVED: %u", 0, localname.sin_addr.s_addr);
                    bTestPassed = FALSE;
                }

                if ((TRUE == getsocknameTable[dwTableIndex].bBind) && (FALSE == getsocknameTable[dwTableIndex].bAnyPort) && (FALSE == getsocknameTable[dwTableIndex].bAccept)) {
                    if (htons(CurrentPort) != localname.sin_port) {
                        xLog(hLog, XLL_FAIL, "sin_port - EXPECTED: %d; RECEIVED: %d", htons(CurrentPort), localname.sin_port);
                        bTestPassed = FALSE;
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "getsockname succeeded");
                }
            }
        }

        if ((0 != (SOCKET_TCP & getsocknameTable[dwTableIndex].dwSocket)) && ((TRUE == getsocknameTable[dwTableIndex].bAccept) || (TRUE == getsocknameTable[dwTableIndex].bConnect))) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(getsocknameRequest), (char *) &getsocknameRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & getsocknameTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & getsocknameTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & getsocknameTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else


VOID
WINAPI
getsocknameTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests getsockname - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                FromInAddr;
    // dwMessageType is the type of received message
    DWORD                 dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                 dwMessageSize;
    // pMessage is a pointer to the received message
    char                  *pMessage;
    // getsocknameRequest is the request
    GETSOCKNAME_REQUEST   getsocknameRequest;
    // getsocknameComplete is the result
    GETSOCKNAME_COMPLETE  getsocknameComplete;

    // sSocket is the socket descriptor
    SOCKET                sSocket;

    // localname is the local address
    SOCKADDR_IN           localname;
    // remotename is the remote address
    SOCKADDR_IN           remotename;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&getsocknameRequest, pMessage, sizeof(getsocknameRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, SOCK_STREAM, 0);

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(getsocknameRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if (TRUE == getsocknameRequest.bServerAccept) {
            // Listen for connection
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(getsocknameRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        getsocknameComplete.dwMessageId = GETSOCKNAME_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(getsocknameComplete), (char *) &getsocknameComplete);

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the socket
        shutdown(sSocket, SD_BOTH);
        closesocket(sSocket);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\getsockopt.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  getsockopt.c

Abstract:

  This modules tests getsockopt

Author:

  Steven Kehrli (steveke) 21-Jun-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct GETSOCKOPT_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    DWORD    dwSocket;                                // dwSocket indicates the socket to be created
    int      level;                                   // level is the socket option level
    int      optname;                                 // optname is the socket option
    BOOL     boptval;                                 // boptval specifies if optval is valid
    BOOL     boptlen;                                 // boptlen specifies if optlen is valid
    int      optlen;                                  // optlen is the size of the socket option
    int      iReturnCode;                             // iReturnCode is the return code of getsockopt
    int      iLastError;                              // iLastError is the error code if the operation failed
    BOOL     bRIP;                                    // Specifies a RIP test case
} GETSOCKOPT_TABLE, *PGETSOCKOPT_TABLE;

static GETSOCKOPT_TABLE getsockoptTable[] =
{
    { "30.1 Not Initialized",          FALSE, SOCKET_INVALID_SOCKET,      0,           0,                   TRUE,  TRUE,  0,                     SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "30.2 s = INT_MIN",              TRUE,  SOCKET_INT_MIN,             0,           0,                   TRUE,  TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "30.3 s = -1",                   TRUE,  SOCKET_NEG_ONE,             0,           0,                   TRUE,  TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "30.4 s = 0",                    TRUE,  SOCKET_ZERO,                0,           0,                   TRUE,  TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "30.5 s = INT_MAX",              TRUE,  SOCKET_INT_MAX,             0,           0,                   TRUE,  TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "30.6 s = INVALID_SOCKET",       TRUE,  SOCKET_INVALID_SOCKET,      0,           0,                   TRUE,  TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "30.7 TCP SO_ACCEPTCONN",        TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_ACCEPTCONN,       TRUE,  TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "30.8 TCP SO_BROADCAST",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_BROADCAST,        TRUE,  TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "30.9 TCP SO_REUSEADDR",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_REUSEADDR,        TRUE,  TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "30.10 TCP SO_EXCLUSIVEADDRUSE", TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_EXCLUSIVEADDRUSE, TRUE,  TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "30.11 TCP SO_LINGER",           TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_LINGER,           TRUE,  TRUE,  sizeof(struct linger), 0,            0,                 FALSE },
    { "30.12 TCP SO_DONTLINGER",       TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_DONTLINGER,       TRUE,  TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "30.13 TCP SO_SNDBUF",           TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_SNDBUF,           TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.14 TCP SO_RCVBUF",           TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_RCVBUF,           TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.15 TCP SO_SNDTIMEO",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_SNDTIMEO,         TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.16 TCP SO_RCVTIMEO",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_RCVTIMEO,         TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.17 TCP SO_TYPE",             TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.18 TCP TCP_NODELAY",         TRUE,  SOCKET_TCP,                 IPPROTO_TCP, TCP_NODELAY,         TRUE,  TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "30.19 UDP SO_ACCEPTCONN",       TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_ACCEPTCONN,       TRUE,  TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "30.20 UDP SO_BROADCAST",        TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_BROADCAST,        TRUE,  TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "30.21 UDP SO_REUSEADDR",        TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_REUSEADDR,        TRUE,  TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "30.22 UDP SO_EXCLUSIVEADDRUSE", TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_EXCLUSIVEADDRUSE, TRUE,  TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "30.23 UDP SO_LINGER",           TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_LINGER,           TRUE,  TRUE,  sizeof(struct linger), SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "30.24 UDP SO_DONTLINGER",       TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_DONTLINGER,       TRUE,  TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "30.25 UDP SO_SNDBUF",           TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_SNDBUF,           TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.26 UDP SO_RCVBUF",           TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_RCVBUF,           TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.27 UDP SO_SNDTIMEO",         TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_SNDTIMEO,         TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.28 UDP SO_RCVTIMEO",         TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_RCVTIMEO,         TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.29 UDP SO_TYPE",             TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "30.30 UDP TCP_NODELAY",         TRUE,  SOCKET_UDP,                 IPPROTO_TCP, TCP_NODELAY,         TRUE,  TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "30.31 TCP 0 level",             TRUE,  SOCKET_TCP,                 0,           SO_TYPE,             TRUE,  TRUE,  sizeof(int),           SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "30.32 TCP 0 optname",           TRUE,  SOCKET_TCP,                 SOL_SOCKET,  0,                   TRUE,  TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "30.33 TCP NULL optval",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_TYPE,             FALSE, TRUE,  sizeof(int),           0,            0,                 TRUE  },
    { "30.34 TCP NULL optlen",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  FALSE, sizeof(int),           0,            0,                 TRUE  },
    { "30.35 TCP 0 optlen",            TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  FALSE, 0,                     0,            0,                 TRUE  },
    { "30.36 TCP SO_LINGER optlen",    TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_LINGER,           TRUE,  TRUE,  sizeof(u_short),       0,            0,                 TRUE  },
    { "30.37 UDP 0 level",             TRUE,  SOCKET_UDP,                 0,           SO_TYPE,             TRUE,  TRUE,  sizeof(int),           SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "30.38 UDP 0 optname",           TRUE,  SOCKET_UDP,                 SOL_SOCKET,  0,                   TRUE,  TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "30.39 UDP NULL optval",         TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_TYPE,             FALSE, TRUE,  sizeof(int),           0,            0,                 TRUE  },
    { "30.40 UDP NULL optlen",         TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  FALSE, sizeof(int),           0,            0,                 TRUE  },
    { "30.41 UDP 0 optlen",            TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  FALSE, 0,                     0,            0,                 TRUE  },
    { "30.42 TCP Closed",              TRUE,  SOCKET_TCP | SOCKET_CLOSED, SOL_SOCKET,  SO_TYPE,             TRUE,  TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "30.43 UDP Closed",              TRUE,  SOCKET_UDP | SOCKET_CLOSED, SOL_SOCKET,  SO_TYPE,             TRUE,  TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "30.44 Not Initialized",         FALSE, SOCKET_INVALID_SOCKET,      0,           0,                   TRUE,  TRUE,  0,                     SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define getsockoptTableCount (sizeof(getsockoptTable) / sizeof(GETSOCKOPT_TABLE))



VOID
getsockoptTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests getsockopt - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR          lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR          lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD          dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL           bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA        WSAData;

    // sSocket is the socket descriptor
    SOCKET         sSocket;

    // localname is the local address
    SOCKADDR_IN    localname;

    // optval is the pointer to the socket option value
    char           *optval;
    int            defaultoptval;
    // optlen is the size of the socket option
    int            optlen;

    // bAcceptConn is the value for SO_ACCEPTCONN
    BOOL           bAcceptConn;
    // bBroadcast is the value for SO_BROADCAST
    BOOL           bBroadcast;
    // bReuseAddr is the value for SO_REUSEADDR
    BOOL           bReuseAddr;
    // bExclusiveAddrUse is the value for SO_EXCLUSIVEADDRUSE
    BOOL           bExclusiveAddrUse;
    // linger is the value for SO_LINGER
    struct linger  linger;
    // bDontLinger is the value for SO_DONTLINGER
    BOOL           bDontLinger;
    // nSndBuf is the value for SO_SNDBUF
    int            nSndBuf;
    // nRcvBuf is the value for SO_RCVBUF
    int            nRcvBuf;
    // nSndTimeO is the value for SO_SNDTIMEO
    int            nSndTimeO;
    // nRcvTimeO is the value for SO_RCVTIMEO
    int            nRcvTimeO;
    // nType is the value for SO_TYPE
    int            nType;
    // bNoDelay is the value for TCP_NODELAY
    BOOL           bNoDelay;

    // bException indicates if an exception occurred
    BOOL           bException;
    // iReturnCode is the return code of the operation
    int            iReturnCode;
    // iLastError is the error code if the operation failed
    int            iLastError;
    // bTestPassed indicates if the test passed
    BOOL           bTestPassed;

    // szFunctionName is the function name
    CHAR           szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "getsockopt v%04x", WinsockVersion);
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_getsockopt+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_getsockopt-");

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < getsockoptTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, getsockoptTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, getsockoptTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != getsockoptTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, getsockoptTable[dwTableIndex].szVariationName);

        // Check the state of Winsock
        if (bWinsockInitialized != getsockoptTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == getsockoptTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = getsockoptTable[dwTableIndex].bWinsockInitialized;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == getsockoptTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == getsockoptTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == getsockoptTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == getsockoptTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == getsockoptTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & getsockoptTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & getsockoptTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Bind the socket
        if ((0 != (SOCKET_TCP & getsockoptTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & getsockoptTable[dwTableIndex].dwSocket))) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Setup optval
        optval = (char *) &defaultoptval;
        optlen = getsockoptTable[dwTableIndex].optlen;
        switch (getsockoptTable[dwTableIndex].optname) {
            case SO_ACCEPTCONN:
                optval = (char *) &bAcceptConn;
                break;

            case SO_BROADCAST:
                optval = (char *) &bBroadcast;
                break;

            case SO_REUSEADDR:
                optval = (char *) &bReuseAddr;
                break;

            case SO_EXCLUSIVEADDRUSE:
                optval = (char *) &bExclusiveAddrUse;
                break;

            case SO_LINGER:
                optval = (char *) &linger;
                break;

            case SO_DONTLINGER:
                optval = (char *) &bDontLinger;
                break;

            case SO_SNDBUF:
                optval = (char *) &nSndBuf;
                break;

            case SO_RCVBUF:
                optval = (char *) &nRcvBuf;
                break;

            case SO_SNDTIMEO:
                optval = (char *) &nSndTimeO;
                break;

            case SO_RCVTIMEO:
                optval = (char *) &nRcvTimeO;
                break;

            case SO_TYPE:
                optval = (char *) &nType;
                break;

            case TCP_NODELAY:
                optval = (char *) &bNoDelay;
                break;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & getsockoptTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call getsockopt
            iReturnCode = getsockopt(sSocket, getsockoptTable[dwTableIndex].level, getsockoptTable[dwTableIndex].optname, (TRUE == getsockoptTable[dwTableIndex].boptval) ? optval : NULL, (TRUE == getsockoptTable[dwTableIndex].boptlen) ? &optlen : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            xLog(hLog, XLL_EXCEPTION, "getsockopt caused an exception - ec = 0x%08x", GetExceptionCode());
        }

        if (FALSE == bException) {
            if (TRUE == getsockoptTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "getsockopt did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == getsockoptTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != getsockoptTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "getsockopt iLastError - EXPECTED: %u; RECEIVED: %u", getsockoptTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "getsockopt iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                // Get the last error code
                iLastError = WSAGetLastError();

                xLog(hLog, XLL_FAIL, "getsockopt returned SOCKET_ERROR - ec = %u", iLastError);
            }
            else if (SOCKET_ERROR == getsockoptTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "getsockopt returned non-SOCKET_ERROR");
            }
            else {
                // Check optlen
                if (getsockoptTable[dwTableIndex].optlen != optlen) {
                    xLog(hLog, XLL_FAIL, "optlen - EXPECTED: %d; RECEIVED: %d", getsockoptTable[dwTableIndex].optlen, optlen);
                    bTestPassed = FALSE;
                }

                // Check optval
                switch (getsockoptTable[dwTableIndex].optname) {
                    case SO_ACCEPTCONN:
                        if (FALSE != bAcceptConn) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", FALSE, bAcceptConn);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_BROADCAST:
                        if (FALSE != bBroadcast) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", FALSE, bBroadcast);
                            bTestPassed = FALSE;
                        }

                        bBroadcast = TRUE;

                        break;

                    case SO_REUSEADDR:
                        if (FALSE != bReuseAddr) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", FALSE, bReuseAddr);
                            bTestPassed = FALSE;
                        }

                        bReuseAddr = TRUE;

                        break;

                    case SO_EXCLUSIVEADDRUSE:
                        if (FALSE != bExclusiveAddrUse) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", FALSE, bExclusiveAddrUse);
                            bTestPassed = FALSE;
                        }

                        bExclusiveAddrUse = TRUE;

                        break;

                    case SO_LINGER:
                        if (0 != linger.l_onoff) {
                            xLog(hLog, XLL_FAIL, "l_onoff1 - EXPECTED: %d; RECEIVED: %d", 0, linger.l_onoff);
                            bTestPassed = FALSE;
                        }

                        if (120 != linger.l_linger) {
                            xLog(hLog, XLL_FAIL, "l_linger1 - EXPECTED: %d; RECEIVED: %d", 120, linger.l_linger);
                            bTestPassed = FALSE;
                        }

                        linger.l_onoff = 1;
                        linger.l_linger = 5;

                        break;

                    case SO_DONTLINGER:
                        if (TRUE != bDontLinger) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", TRUE, bDontLinger);
                            bTestPassed = FALSE;
                        }

                        bDontLinger = FALSE;

                        break;

                    case SO_SNDBUF:
                        if (16384 != nSndBuf) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", 16384, nSndBuf);
                            bTestPassed = FALSE;
                        }

                        nSndBuf = 1;

                        break;

                    case SO_RCVBUF:
                        if (16384 != nRcvBuf) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", 16384, nRcvBuf);
                            bTestPassed = FALSE;
                        }

                        nRcvBuf = 1;

                        break;

                    case SO_SNDTIMEO:
                        if (0 != nSndTimeO) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", 0, nSndTimeO);
                            bTestPassed = FALSE;
                        }

                        nSndTimeO = 5;

                        break;

                    case SO_RCVTIMEO:
                        if (0 != nRcvTimeO) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", 0, nRcvTimeO);
                            bTestPassed = FALSE;
                        }

                        nRcvTimeO = 5;

                        break;

                    case SO_TYPE:
                        if (0 != (SOCKET_TCP & getsockoptTable[dwTableIndex].dwSocket)) {
                            if (SOCK_STREAM != nType) {
                                xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", SOCK_STREAM, nType);
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (SOCK_DGRAM != nType) {
                                xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", SOCK_DGRAM, nType);
                                bTestPassed = FALSE;
                            }
                        }

                        break;

                    case TCP_NODELAY:
                        if (FALSE != bNoDelay) {
                            xLog(hLog, XLL_FAIL, "optval1 - EXPECTED: %d; RECEIVED: %d", FALSE, bNoDelay);
                            bTestPassed = FALSE;
                        }

                        bNoDelay = TRUE;

                        break;
                }

                // Call setsockopt
                switch (getsockoptTable[dwTableIndex].optname) {
                    case SO_ACCEPTCONN:
                        listen(sSocket, SOMAXCONN);

                        break;

                    case SO_BROADCAST:
                    case SO_REUSEADDR:
                    case SO_EXCLUSIVEADDRUSE:
                    case SO_LINGER:
                    case SO_DONTLINGER:
                    case SO_SNDBUF:
                    case SO_RCVBUF:
                    case SO_SNDTIMEO:
                    case SO_RCVTIMEO:
                    case TCP_NODELAY:
                        setsockopt(sSocket, getsockoptTable[dwTableIndex].level, getsockoptTable[dwTableIndex].optname, optval, optlen);

                        break;
                }

                // Call getsockopt
                getsockopt(sSocket, getsockoptTable[dwTableIndex].level, getsockoptTable[dwTableIndex].optname, optval, &optlen);

                // Check optlen
                if (getsockoptTable[dwTableIndex].optlen != optlen) {
                    xLog(hLog, XLL_FAIL, "optlen - EXPECTED: %d; RECEIVED: %d", getsockoptTable[dwTableIndex].optlen, optlen);
                    bTestPassed = FALSE;
                }

                // Check optval
                switch (getsockoptTable[dwTableIndex].optname) {
                    case SO_ACCEPTCONN:
                        if (TRUE != bAcceptConn) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", TRUE, bAcceptConn);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_BROADCAST:
                        if (TRUE != bBroadcast) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", TRUE, bBroadcast);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_REUSEADDR:
                        if (TRUE != bReuseAddr) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", TRUE, bReuseAddr);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_EXCLUSIVEADDRUSE:
                        if (TRUE != bExclusiveAddrUse) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", TRUE, bExclusiveAddrUse);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_LINGER:
                        if (1 != linger.l_onoff) {
                            xLog(hLog, XLL_FAIL, "l_onoff2 - EXPECTED: %d; RECEIVED: %d", 1, linger.l_onoff);
                            bTestPassed = FALSE;
                        }

                        if (5 != linger.l_linger) {
                            xLog(hLog, XLL_FAIL, "l_linger2 - EXPECTED: %d; RECEIVED: %d", 5, linger.l_linger);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_DONTLINGER:
                        if (FALSE != bDontLinger) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", FALSE, bDontLinger);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_SNDBUF:
                        if (1 != nSndBuf) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", 1, nSndBuf);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_RCVBUF:
                        if (1 != nRcvBuf) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", 1, nRcvBuf);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_SNDTIMEO:
                        if (5 != nSndTimeO) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", 5, nSndTimeO);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_RCVTIMEO:
                        if (5 != nRcvTimeO) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", 5, nRcvTimeO);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_TYPE:
                        if (0 != (SOCKET_TCP & getsockoptTable[dwTableIndex].dwSocket)) {
                            if (SOCK_STREAM != nType) {
                                xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", SOCK_STREAM, nType);
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (SOCK_DGRAM != nType) {
                                xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", SOCK_DGRAM, nType);
                                bTestPassed = FALSE;
                            }
                        }

                        break;

                    case TCP_NODELAY:
                        if (TRUE != bNoDelay) {
                            xLog(hLog, XLL_FAIL, "optval2 - EXPECTED: %d; RECEIVED: %d", TRUE, bNoDelay);
                            bTestPassed = FALSE;
                        }

                        break;
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "getsockopt succeeded");
                }
            }
        }

        if (0 == (SOCKET_CLOSED & getsockoptTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & getsockoptTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & getsockoptTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\getpeername.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  getpeername.c

Abstract:

  This modules tests getpeername

Author:

  Steven Kehrli (steveke) 8-Jan-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// getpeername messages

#define GETPEERNAME_REQUEST_MSG   NETSYNC_MSG_USER + 220 + 1
#define GETPEERNAME_COMPLETE_MSG  NETSYNC_MSG_USER + 220 + 2

typedef struct _GETPEERNAME_REQUEST {
    DWORD    dwMessageId;
    BOOL     bServerAccept;
    BOOL     bRemoteClose;
    u_short  Port;
} GETPEERNAME_REQUEST, *PGETPEERNAME_REQUEST;

typedef struct _GETPEERNAME_COMPLETE {
    DWORD    dwMessageId;
} GETPEERNAME_COMPLETE, *PGETPEERNAME_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct GETPEERNAME_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    BOOL   bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL   bConnect;                                // bConnect indicates if the socket is connected
    BOOL   bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL   bname;                                   // bname indicates if the address buffer is used
    BOOL   bnamelen;                                // bnamelen indicates if socknamelen is used
    int    namelen;                                 // namelen is the length of the address buffer
    int    iReturnCode;                             // iReturnCode is the return code of getpeername
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} GETPEERNAME_TABLE, *PGETPEERNAME_TABLE;

static GETPEERNAME_TABLE getpeernameTable[] =
{
    { "22.1 Not Initialized",      FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "22.2 s = INT_MIN",          TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "22.3 s = -1",               TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "22.4 s = 0",                TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "22.5 s = INT_MAX",          TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "22.6 s = INVALID_SOCKET",   TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "22.7 Not Bound TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "22.8 Bound TCP",            TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "22.9 Connected TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.10 Accepted TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.11 Connected Close TCP", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  TRUE,  TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.12 Accepted Close TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.13 NULL addr TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, FALSE, TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.14 addr TCP",            TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.15 Large addrlen TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "22.16 Exact addrlen TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.17 Small addrlen TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.18 Zero addrlen TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.19 Neg addrlen TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.20 NULL addrlen TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.21 Not Bound UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "22.22 Bound UDP",           TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "22.23 Connected UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.24 NULL addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, TRUE,  FALSE, FALSE, TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.25 addr UDP",            TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.26 Large addrlen UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "22.27 Exact addrlen UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "22.28 Small addrlen UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.29 Zero addrlen UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.30 Neg addrlen UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  TRUE,  -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.31 NULL addrlen UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "22.43 Closed Socket TCP",   TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "22.44 Closed Socket UDP",   TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "22.46 Not Initialized",     FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define getpeernameTableCount (sizeof(getpeernameTable) / sizeof(GETPEERNAME_TABLE))

NETSYNC_TYPE_THREAD  getpeernameTestSessionNt =
{
    1,
    getpeernameTableCount,
    L"xnetapi_nt.dll",
    "getpeernameTestServer"
};

NETSYNC_TYPE_THREAD  getpeernameTestSessionXbox =
{
    1,
    getpeernameTableCount,
    L"xnetapi_xbox.dll",
    "getpeernameTestServer"
};



VOID
getpeernameTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests getpeername - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // getpeernameRequest is the request sent to the server
    GETPEERNAME_REQUEST    getpeernameRequest;
    
    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;
    // namelen is the size of the address information buffer
    int                    namelen;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "getpeername v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_getpeername+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_getpeername-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = getpeernameTestSessionXbox;
    }
    else {
        NetsyncTypeSession = getpeernameTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < getpeernameTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, getpeernameTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, getpeernameTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != getpeernameTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, getpeernameTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == getpeernameTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != getpeernameTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == getpeernameTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = getpeernameTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == getpeernameTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == getpeernameTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == getpeernameTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == getpeernameTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == getpeernameTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == getpeernameTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & getpeernameTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & getpeernameTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Bind the socket
        if (TRUE == getpeernameTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);

            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        if ((0 != (SOCKET_TCP & getpeernameTable[dwTableIndex].dwSocket)) && ((TRUE == getpeernameTable[dwTableIndex].bAccept) || (TRUE == getpeernameTable[dwTableIndex].bConnect))) {
            if (TRUE == getpeernameTable[dwTableIndex].bAccept) {
                // Listen for connection
                listen(sSocket, SOMAXCONN);
            }

            // Initialize the connect request
            getpeernameRequest.dwMessageId = GETPEERNAME_REQUEST_MSG;
            getpeernameRequest.bServerAccept = getpeernameTable[dwTableIndex].bConnect;
            getpeernameRequest.bRemoteClose = getpeernameTable[dwTableIndex].bRemoteClose;
            getpeernameRequest.Port = CurrentPort;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(getpeernameRequest), (char *) &getpeernameRequest);

            // Wait for the connect result
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == getpeernameTable[dwTableIndex].bAccept) {
                // Accept the connection
                nsSocket = accept(sSocket, NULL, NULL);
            }
        }

        if (TRUE == getpeernameTable[dwTableIndex].bConnect) {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(CurrentPort);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        if (TRUE == getpeernameTable[dwTableIndex].bRemoteClose) {
            // Send the remote close request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(getpeernameRequest), (char *) &getpeernameRequest);

            // Wait for the remote close result
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        // Initialize the remotename name
        namelen = getpeernameTable[dwTableIndex].namelen;
        ZeroMemory(&remotename, sizeof(remotename));

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & getpeernameTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call getpeername
            iReturnCode = getpeername((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (TRUE == getpeernameTable[dwTableIndex].bname) ? (SOCKADDR *) &remotename : NULL, (TRUE == getpeernameTable[dwTableIndex].bnamelen) ? &namelen : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == getpeernameTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "getpeername RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "getpeername caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == getpeernameTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "getpeername did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == getpeernameTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != getpeernameTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "iLastError - EXPECTED: %u; RECEIVED: %u", getpeernameTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "getpeername returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == getpeernameTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "getpeername returned non-SOCKET_ERROR");
            }
            else {
                if (sizeof(remotename) != namelen) {
                    xLog(hLog, XLL_FAIL, "namelen - EXPECTED: %d; RECEIVED: %d", sizeof(remotename), namelen);
                    bTestPassed = FALSE;
                }

                if (AF_INET != remotename.sin_family) {
                    xLog(hLog, XLL_FAIL, "sin_family - EXPECTED: %d; RECEIVED: %d", AF_INET, remotename.sin_family);
                    bTestPassed = FALSE;
                }

                if (NetsyncInAddr != remotename.sin_addr.s_addr) {
                    xLog(hLog, XLL_FAIL, "sin_addr - EXPECTED: %u; RECEIVED: %u", NetsyncInAddr, remotename.sin_addr.s_addr);
                    bTestPassed = FALSE;
                }

                if (htons(CurrentPort) != remotename.sin_port) {
                    xLog(hLog, XLL_FAIL, "sin_port - EXPECTED: %d; RECEIVED: %d", htons(CurrentPort), remotename.sin_port);
                    bTestPassed = FALSE;
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "getpeername succeeded");
                }
            }
        }

        if ((0 != (SOCKET_TCP & getpeernameTable[dwTableIndex].dwSocket)) && ((TRUE == getpeernameTable[dwTableIndex].bAccept) || (TRUE == getpeernameTable[dwTableIndex].bConnect))) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(getpeernameRequest), (char *) &getpeernameRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & getpeernameTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & getpeernameTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & getpeernameTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
getpeernameTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests getpeername - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                FromInAddr;
    // dwMessageType is the type of received message
    DWORD                 dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                 dwMessageSize;
    // pMessage is a pointer to the received message
    char                  *pMessage;
    // getpeernameRequest is the request
    GETPEERNAME_REQUEST   getpeernameRequest;
    // getpeernameComplete is the result
    GETPEERNAME_COMPLETE  getpeernameComplete;

    // sSocket is the socket descriptor
    SOCKET                sSocket;

    // localname is the local address
    SOCKADDR_IN           localname;
    // remotename is the remote address
    SOCKADDR_IN           remotename;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&getpeernameRequest, pMessage, sizeof(getpeernameRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, SOCK_STREAM, 0);

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(getpeernameRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if (TRUE == getpeernameRequest.bServerAccept) {
            // Listen for connection
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(getpeernameRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        getpeernameComplete.dwMessageId = GETPEERNAME_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(getpeernameComplete), (char *) &getpeernameComplete);

        if (TRUE == getpeernameRequest.bRemoteClose) {
            // Wait for the remote close request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            // Close the socket
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);

            // Send the complete
            getpeernameComplete.dwMessageId = GETPEERNAME_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(getpeernameComplete), (char *) &getpeernameComplete);
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if (FALSE == getpeernameRequest.bRemoteClose) {
            // Close the socket
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\fdsmacros.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  fdsmacros.c

Abstract:

  This modules tests the fds macros

Author:

  Steven Kehrli (steveke) 12-Mar-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef XNETAPI_CLIENT

using namespace XNetAPINamespace;

namespace XNetAPINamespace {



VOID
fdsmacrosTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests the fds macros

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR   lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR   lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD   dwTableIndex;

    // sSocket is the socket descriptor
    SOCKET  sSocket;

    // fds is the set
    fd_set  fds;



    // Set the function name
    xSetFunctionName(hLog, "fds macros");

    // Initialize the net subsystem
    XNetAddRef();

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_fdsmacros+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_fdsmacros-");

    sSocket = INVALID_SOCKET;

    if (((NULL == lpszCaseSkip) || (FALSE == ParseAndFindString(lpszCaseSkip, "27.1 Initialize Set"))) && ((NULL == lpszCaseTest) || (TRUE == ParseAndFindString(lpszCaseTest, "27.1 Initialize Set"))) && (FALSE == bRIPs)) {
        // Start the variation
        xStartVariation(hLog, "27.1 Initialize Set");

        // Zero the set
        FD_ZERO(&fds);

        // Check if socket is in the set
        if (0 != FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is not set");
        }

        // End the variation
        xEndVariation(hLog);
    }

    if (((NULL == lpszCaseSkip) || (FALSE == ParseAndFindString(lpszCaseSkip, "27.2 Set sSocket"))) && ((NULL == lpszCaseTest) || (TRUE == ParseAndFindString(lpszCaseTest, "27.2 Set sSocket"))) && (FALSE == bRIPs)) {
        // Start the variation
        xStartVariation(hLog, "27.2 Set sSocket");

        // Zero the set
        FD_ZERO(&fds);

        // Set sSocket
        FD_SET(sSocket, &fds);

        // Check if socket is in the set
        if (0 == FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is not set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is set");
        }

        // End the variation
        xEndVariation(hLog);
    }

    if (((NULL == lpszCaseSkip) || (FALSE == ParseAndFindString(lpszCaseSkip, "27.3 Set Clear sSocket"))) && ((NULL == lpszCaseTest) || (TRUE == ParseAndFindString(lpszCaseTest, "27.3 Set Clear sSocket"))) && (FALSE == bRIPs)) {
        // Start the variation
        xStartVariation(hLog, "27.3 Set Clear sSocket");

        // Zero the set
        FD_ZERO(&fds);

        // Set sSocket
        FD_SET(sSocket, &fds);

        // Check if socket is in the set
        if (0 == FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is not set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is set");
        }

        // Clear sSocket
        FD_CLR(sSocket, &fds);

        // Check if socket is in the set
        if (0 != FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is not set");
        }

        // End the variation
        xEndVariation(hLog);
    }

    if (((NULL == lpszCaseSkip) || (FALSE == ParseAndFindString(lpszCaseSkip, "27.4 Set Zero sSocket"))) && ((NULL == lpszCaseTest) || (TRUE == ParseAndFindString(lpszCaseTest, "27.4 Set Zero sSocket"))) && (FALSE == bRIPs)) {
        // Start the variation
        xStartVariation(hLog, "27.4 Set Zero sSocket");

        // Zero the set
        FD_ZERO(&fds);

        // Set sSocket
        FD_SET(sSocket, &fds);

        // Check if socket is in the set
        if (0 == FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is not set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is set");
        }

        // Zero sSocket
        FD_ZERO(&fds);

        // Check if socket is in the set
        if (0 != FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is not set");
        }

        // End the variation
        xEndVariation(hLog);
    }

    if (((NULL == lpszCaseSkip) || (FALSE == ParseAndFindString(lpszCaseSkip, "27.5 Set Set sSocket"))) && ((NULL == lpszCaseTest) || (TRUE == ParseAndFindString(lpszCaseTest, "27.5 Set Set sSocket"))) && (FALSE == bRIPs)) {
        // Start the variation
        xStartVariation(hLog, "27.5 Set Set sSocket");

        // Zero the set
        FD_ZERO(&fds);

        // Set sSocket
        FD_SET(sSocket, &fds);

        // Check if socket is in the set
        if (0 == FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is not set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is set");
        }

        // Set sSocket
        FD_SET(sSocket, &fds);

        // Check if socket is in the set
        if (0 == FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is not set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is set");
        }

        // End the variation
        xEndVariation(hLog);
    }

    if (((NULL == lpszCaseSkip) || (FALSE == ParseAndFindString(lpszCaseSkip, "27.6 Clear sSocket"))) && ((NULL == lpszCaseTest) || (TRUE == ParseAndFindString(lpszCaseTest, "27.6 Clear sSocket"))) && (FALSE == bRIPs)) {
        // Start the variation
        xStartVariation(hLog, "27.6 Clear sSocket");

        // Zero the set
        FD_ZERO(&fds);

        // Clear sSocket
        FD_CLR(sSocket, &fds);

        // Check if socket is in the set
        if (0 != FD_ISSET(sSocket, &fds)) {
            xLog(hLog, XLL_FAIL, "sSocket is set");
        }
        else {
            xLog(hLog, XLL_PASS, "sSocket is not set");
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\htonl.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  htonl.c

Abstract:

  This modules tests htonl

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _HTONL_TABLE {
    CHAR    szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    u_long  hostlong;                                // u_long in host byte order
    u_long  netlong;                                 // u_long in network byte order
    BOOL    bRIP;                                    // Specifies a RIP test case
} HTONL_TABLE, *PHTONL_TABLE;

static HTONL_TABLE htonlTable[] =
{
    { "1.1 0x00000000", 0x00000000, 0x00000000, FALSE },
    { "1.2 0x7FFFFFFF", 0x7FFFFFFF, 0xFFFFFF7F, FALSE },
    { "1.3 0x10203040", 0x10203040, 0x40302010, FALSE },
    { "1.4 0x0000ABCD", 0x0000ABCD, 0xCDAB0000, FALSE },
    { "1.5 0x0000ABCD", 0x0000ABCD, 0xCDAB0000, FALSE },
    { "1.6 0xAAAAAAAA", 0xAAAAAAAA, 0xAAAAAAAA, FALSE },
    { "1.7 0x0000FFFF", 0x0000FFFF, 0xFFFF0000, FALSE }
};

#define htonlTableCount (sizeof(htonlTable) / sizeof(HTONL_TABLE))



VOID
htonlTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests htonl

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR   lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR   lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD   dwTableIndex;

    // netlong is the returned value in network byte order
    u_long  netlong;

    // bException indicates if an exception occurred
    BOOL    bException;



    // Set the function name
    xSetFunctionName(hLog, "htonl");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_htonl+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_htonl-");

    for (dwTableIndex = 0; dwTableIndex < htonlTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, htonlTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, htonlTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != htonlTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, htonlTable[dwTableIndex].szVariationName);

        bException = FALSE;

        __try {
            // Call htonl
            netlong = htonl(htonlTable[dwTableIndex].hostlong);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == htonlTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "htonl RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "htonl caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == htonlTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "htonl did not RIP");
            }

            if (netlong != htonlTable[dwTableIndex].netlong) {
                xLog(hLog, XLL_FAIL, "EXPECTED: 0x%08x; RECEIVED: 0x%08x", htonlTable[dwTableIndex].netlong, netlong);
            }
            else {
                xLog(hLog, XLL_PASS, "OUT: 0x%08x", netlong);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\htons.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  htons.c

Abstract:

  This modules tests htons

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _HTONS_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    u_short  hostshort;                               // u_short in host byte order
    u_short  netshort;                                // u_short in network byte order
    BOOL     bRIP;                                    // Specifies a RIP test case
} HTONS_TABLE, *PHTONS_TABLE;

static HTONS_TABLE htonsTable[] =
{
    { "2.1 0x0000", 0x0000, 0x0000, FALSE },
    { "2.2 0x7FFF", 0x7FFF, 0xFF7F, FALSE },
    { "2.3 0x3040", 0x3040, 0x4030, FALSE },
    { "2.4 0xABCD", 0xABCD, 0xCDAB, FALSE },
    { "2.5 0xABCD", 0xABCD, 0xCDAB, FALSE },
    { "2.6 0xAAAA", 0xAAAA, 0xAAAA, FALSE },
    { "2.7 0x00FF", 0x00FF, 0xFF00, FALSE }
};

#define htonsTableCount (sizeof(htonsTable) / sizeof(HTONS_TABLE))



VOID
htonsTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests htons

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD    dwTableIndex;

    // netshort is the returned value in network byte order
    u_short  netshort;

    // bException indicates if an exception occurred
    BOOL     bException;



    // Set the function name
    xSetFunctionName(hLog, "htons");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_htons+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_htons-");

    for (dwTableIndex = 0; dwTableIndex < htonsTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, htonsTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, htonsTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != htonsTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, htonsTable[dwTableIndex].szVariationName);

        bException = FALSE;

        __try {
            // Call htons
            netshort = htons(htonsTable[dwTableIndex].hostshort);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == htonsTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "htons did not RIP");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "htons caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == htonsTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "htons did not RIP");
            }

            if (netshort != htonsTable[dwTableIndex].netshort) {
                xLog(hLog, XLL_FAIL, "EXPECTED: 0x%04x; RECEIVED: 0x%04x", htonsTable[dwTableIndex].netshort, netshort);
            }
            else {
                xLog(hLog, XLL_PASS, "OUT: 0x%04x", netshort);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\inet_addr.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  inet_addr.c

Abstract:

  This modules tests inet_addr

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _INET_ADDR_TABLE {
    CHAR    szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    char    *cp;                                     // cp is the IPv4 dotted address string
    u_long  addr;                                    // addr is the u_long representation of the address given
    BOOL    bRIP;                                    // Specifies a RIP test case
} INET_ADDR_TABLE, *PINET_ADDR_TABLE;

static INET_ADDR_TABLE inet_addrTable[] =
{
    { "5.1 \"0.0.0.0\"",              "0.0.0.0",             0x00000000,  FALSE },
    { "5.2 \"4.3.2.16\"",             "4.3.2.16",            0x10020304,  FALSE },
    { "5.3 \"255.255.255.255\"",      "255.255.255.255",     0xFFFFFFFF,  FALSE },
    { "5.4 \"4.3.2.256\"",            "4.3.2.256",           0x00020304,  FALSE },
    { "5.5 \"4.3.256.16\"",           "4.3.256.16",          0x10000304,  FALSE },
    { "5.6 \"4.256.2.16\"",           "4.256.2.16",          0x10020004,  FALSE },
    { "5.7 \"256.3.2.16\"",           "256.3.2.16",          0x10020300,  FALSE },
    { "5.8 \"000.000.000.000\"",      "000.000.000.000",     0x00000000,  FALSE },
    { "5.9 \"004.003.002.020\"",      "004.003.002.020",     0x10020304,  FALSE },
    { "5.10 \"0377.0377.0377.0377\"", "0377.0377.0377.0377", 0xFFFFFFFF,  FALSE },
    { "5.11 \"004.003.002.0400\"",    "004.003.002.0400",    0x00020304,  FALSE },
    { "5.12 \"004.003.0400.020\"",    "004.003.0400.020",    0x10000304,  FALSE },
    { "5.13 \"004.0400.002.020\"",    "004.0400.002.020",    0x10020004,  FALSE },
    { "5.14 \"0400.003.002.020\"",    "0400.003.002.020",    0x10020300,  FALSE },
    { "5.15 \"0x0.0x0.0x0.0x0\"",     "0x0.0x0.0x0.0x0",     0x00000000,  FALSE },
    { "5.16 \"0x4.0x3.0x2.0x10\"",    "0x4.0x3.0x2.0x10",    0x10020304,  FALSE },
    { "5.17 \"0xFF.0xFF.0xFF.0xFF\"", "0xFF.0xFF.0xFF.0xFF", 0xFFFFFFFF,  FALSE },
    { "5.18 \"0x4.0x3.0x2.0x100\"",   "0x4.0x3.0x2.0x100",   0x00020304,  FALSE },
    { "5.19 \"0x4.0x3.0x100.0x10\"",  "0x4.0x3.0x100.0x10",  0x10000304,  FALSE },
    { "5.20 \"0x4.0x100.0x2.0x10\"",  "0x4.0x100.0x2.0x10",  0x10020004,  FALSE },
    { "5.21 \"0x100.0x3.0x2.0x10\"",  "0x100.0x3.0x2.0x10",  0x10020300,  FALSE },
    { "5.22 \"0.000.0.0x0\"",         "0.000.0.0x0",         0x00000000,  FALSE },
    { "5.23 \"000.0.0x0.0\"",         "000.0.0x0.0",         0x00000000,  FALSE },
    { "5.24 \"0.0x0.0.000\"",         "0.0x0.0.000",         0x00000000,  FALSE },
    { "5.25 \"0x0.0.000.0\"",         "0x0.0.000.0",         0x00000000,  FALSE },
    { "5.26 \"4.003.2.0x10\"",        "4.003.2.0x10",        0x10020304,  FALSE },
    { "5.27 \"004.3.0x2.16\"",        "004.3.0x2.16",        0x10020304,  FALSE },
    { "5.28 \"4.0x3.2.020\"",         "4.0x3.2.020",         0x10020304,  FALSE },
    { "5.29 \"0x4.3.002.16\"",        "0x4.3.002.16",        0x10020304,  FALSE },
    { "5.30 \"255.0377.255.0xFF\"",   "255.0377.255.0xFF",   0xFFFFFFFF,  FALSE },
    { "5.31 \"0377.255.0xFF.255\"",   "0377.255.0xFF.255",   0xFFFFFFFF,  FALSE },
    { "5.32 \"255.0xFF.255.0377\"",   "255.0xFF.255.0377",   0xFFFFFFFF,  FALSE },
    { "5.33 \"0xFF.255.0377.255\"",   "0xFF.255.0377.255",   0xFFFFFFFF,  FALSE },
    { "5.34 \"4.0400.2.0x10\"",       "4.0400.2.0x10",       0x10020004,  FALSE },
    { "5.35 \"004.3.0x100.16\"",      "004.3.0x100.16",      0x10000304,  FALSE },
    { "5.36 \"256.0x3.2.020\"",       "256.0x3.2.020",       0x10020300,  FALSE },
    { "5.37 \"0x4.3.002.256\"",       "0x4.3.002.256",       0x00020304,  FALSE },
    { "5.38 \"0.0.0\"",               "0.0.0",               0x00000000,  FALSE },
    { "5.39 \"4.3.2\"",               "4.3.2",               0x02000304,  FALSE },
    { "5.40 \"255.255.255\"",         "255.255.255",         0xFF00FFFF,  FALSE },
    { "5.41 \"4.3.256\"",             "4.3.256",             0x00010304,  FALSE },
    { "5.42 \"4.3.65536\"",           "4.3.65536",           0x00000304,  FALSE },
    { "5.43 \"0.0\"",                 "0.0",                 0x00000000,  FALSE },
    { "5.44 \"4.3\"",                 "4.3",                 0x03000004,  FALSE },
    { "5.45 \"255.255\"",             "255.255",             0xFF0000FF,  FALSE },
    { "5.46 \"4.256\"",               "4.256",               0x00010004,  FALSE },
    { "5.47 \"4.16777216\"",          "4.16777216",          0x00000004,  FALSE },
    { "5.48 \"0\"",                   "0",                   0x00000000,  FALSE },
    { "5.49 \"4\"",                   "4",                   0x04000000,  FALSE },
    { "5.50 \"255\"",                 "255",                 0xFF000000,  FALSE },
    { "5.51 \"4294967296\"",          "4294967296",          0x00000000,  FALSE },
    { "5.52 \"4.3.2.16abcdef\"",      "4.3.2.16abcdef",      INADDR_NONE, FALSE },
    { "5.53 \"4.3.2abcdef.16\"",      "4.3.2abcdef.16",      INADDR_NONE, FALSE },
    { "5.54 \"4.3abcdef.2.16\"",      "4.3abcdef.2.16",      INADDR_NONE, FALSE },
    { "5.55 \"4abcdef.3.2.16\"",      "4abcdef.3.2.16",      INADDR_NONE, FALSE },
    { "5.56 \"4.3.2.abcdef16\"",      "4.3.2.abcdef16",      INADDR_NONE, FALSE },
    { "5.57 \"4.3.abcdef2.16\"",      "4.3.abcdef2.16",      INADDR_NONE, FALSE },
    { "5.58 \"4.abcdef3.2.16\"",      "4.abcdef3.2.16",      INADDR_NONE, FALSE },
    { "5.59 \"abcdef4.3.2.16\"",      "abcdef4.3.2.16",      INADDR_NONE, FALSE },
    { "5.60 \"4.3.2.16 \"",           "4.3.2.16 ",           0x10020304,  FALSE },
    { "5.61 \"4.3.2 .16\"",           "4.3.2 .16",           0x10020304,  FALSE },
    { "5.62 \"4.3 .2.16\"",           "4.3 .2.16",           0x10020304,  FALSE },
    { "5.63 \"4 .3.2.16\"",           "4 .3.2.16",           0x10020304,  FALSE },
    { "5.64 \"4.3.2. 16\"",           "4.3.2. 16",           0x10020304,  FALSE },
    { "5.65 \"4.3. 2.16\"",           "4.3. 2.16",           0x10020304,  FALSE },
    { "5.66 \"4. 3.2.16\"",           "4. 3.2.16",           0x10020304,  FALSE },
    { "5.67 \" 4.3.2.16\"",           " 4.3.2.16",           0x10020304,  FALSE },
    { "5.68 \"\"",                    "",                    0x00000000,  FALSE },
    { "5.69 \" \"",                   " ",                   0x00000000,  FALSE },
    { "5.70 NULL",                    NULL,                  WSAEFAULT,   TRUE  }
};

#define inet_addrTableCount (sizeof(inet_addrTable) / sizeof(INET_ADDR_TABLE))



VOID
inet_addrTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests inet_addr

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR   lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR   lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD   dwTableIndex;

    // addr is the returned u_long value
    u_long  addr;

    // bException indicates if an exception occurred
    BOOL    bException;



    // Set the function name
    xSetFunctionName(hLog, "inet_addr");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_inet_addr+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_inet_addr-");

    for (dwTableIndex = 0; dwTableIndex < inet_addrTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, inet_addrTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, inet_addrTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != inet_addrTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, inet_addrTable[dwTableIndex].szVariationName);

        bException = FALSE;

        __try {
            // Call inet_addr
            addr = inet_addr(inet_addrTable[dwTableIndex].cp);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == inet_addrTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "inet_addr RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "inet_addr caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == inet_addrTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "inet_addr did not RIP");
            }

            if (addr != inet_addrTable[dwTableIndex].addr) {
                xLog(hLog, XLL_FAIL, "EXPECTED: 0x%08x; RECEIVED: 0x%08x", inet_addrTable[dwTableIndex].addr, addr);
            }
            else {
                xLog(hLog, XLL_PASS, "OUT: 0x%08x", addr);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\ioctlsocket.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  ioctlsocket.c

Abstract:

  This modules tests ioctlsocket

Author:

  Steven Kehrli (steveke) 26-Jan-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// ioctlsocket messages

#define IOCTLSOCKET_REQUEST_MSG   NETSYNC_MSG_USER + 230 + 1
#define IOCTLSOCKET_COMPLETE_MSG  NETSYNC_MSG_USER + 230 + 2

typedef struct _IOCTLSOCKET_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bServerSendData;
    DWORD    dwDataSize1;
    DWORD    dwDataSize2;
} IOCTLSOCKET_REQUEST, *PIOCTLSOCKET_REQUEST;

typedef struct _IOCTLSOCKET_COMPLETE {
    DWORD    dwMessageId;
} IOCTLSOCKET_COMPLETE, *PIOCTLSOCKET_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define SIOCATMARK  _IOR('s',  7, u_long)



typedef struct IOCTLSOCKET_TABLE {
    CHAR    szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL    bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL    bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD   dwSocket;                                // dwSocket indicates the socket to be created
    BOOL    bBind;                                   // bBind indicates if the socket is to be bound
    BOOL    bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL    bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL    bConnect;                                // bConnect indicates if the socket is connected
    BOOL    bReceiveData;                            // bReceiveData specifies if any receive data should be queued
    DWORD   dwDataSize1;                             // dwDataSize1 specifies the amount of receive data that should be queued first
    DWORD   dwDataSize2;                             // dwDataSize2 specifies the amount of receive data that should be queued second
    long    Command;                                 // ioctlsocket command
    u_long  argp_in;                                 // ioctlsocket argp in
    BOOL    bargp_out;                               // argp_out specifies if argp is used
    int     iReturnCode;                             // iReturnCode is the return code of ioctlsocket
    int     iLastError;                              // iLastError is the error code if the operation failed
    BOOL    bRIP;                                    // Specifies a RIP test case
} IOCTLSOCKET_TABLE, *PIOCTLSOCKET_TABLE;

static IOCTLSOCKET_TABLE ioctlsocketTable[] =
{
    { "23.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "23.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "23.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "23.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "23.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "23.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "23.7 FIONBIO 0 Not Bound TCP",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    0, TRUE,  0,            0,                 FALSE },
    { "23.8 FIONBIO 0 Bound TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    0, TRUE,  0,            0,                 FALSE },
    { "23.9 FIONBIO 0 Listening TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    0, TRUE,  0,            0,                 FALSE },
    { "23.10 FIONBIO 0 Accepted TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, 0,  0,  FIONBIO,    0, TRUE,  0,            0,                 FALSE },
    { "23.11 FIONBIO 0 Connected TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONBIO,    0, TRUE,  0,            0,                 FALSE },
    { "23.12 FIONBIO 0 NULL TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONBIO,    0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "23.13 FIONBIO 1 Not Bound TCP",   TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    1, TRUE,  0,            0,                 FALSE },
    { "23.14 FIONBIO 1 Bound TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    1, TRUE,  0,            0,                 FALSE },
    { "23.15 FIONBIO 1 Listening TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    1, TRUE,  0,            0,                 FALSE },
    { "23.16 FIONBIO 1 Accepted TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, 0,  0,  FIONBIO,    1, TRUE,  0,            0,                 FALSE },
    { "23.17 FIONBIO 1 Connected TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONBIO,    1, TRUE,  0,            0,                 FALSE },
    { "23.18 FIONBIO 1 NULL TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONBIO,    1, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "23.19 FIONBIO 0 Not Bound UDP",   TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    0, TRUE,  0,            0,                 FALSE },
    { "23.20 FIONBIO 0 Bound UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    0, TRUE,  0,            0,                 FALSE },
    { "23.21 FIONBIO 0 Connected UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONBIO,    0, TRUE,  0,            0,                 FALSE },
    { "23.22 FIONBIO 0 NULL UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONBIO,    0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "23.23 FIONBIO 1 Not Bound UDP",   TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    1, TRUE,  0,            0,                 FALSE },
    { "23.24 FIONBIO 1 Bound UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONBIO,    1, TRUE,  0,            0,                 FALSE },
    { "23.25 FIONBIO 1 Connected UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONBIO,    1, TRUE,  0,            0,                 FALSE },
    { "23.26 FIONBIO 1 NULL UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONBIO,    1, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "23.27 FIONREAD Not Bound TCP",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.28 FIONREAD Bound TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.29 FIONREAD Listening TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.30 FIONREAD Accepted TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.31 FIONREAD Connected TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.32 FIONREAD NULL TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONREAD,   0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "23.33 FIONREAD No Data TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.34 FIONREAD 0 Data TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  TRUE,  0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.35 FIONREAD 10 Data TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  TRUE,  10, 0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.36 FIONREAD 10 & 5 Data TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  TRUE,  10, 5,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.37 FIONREAD Not Bound UDP",    TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.38 FIONREAD Bound UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.39 FIONREAD Connected UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.40 FIONREAD NULL UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONREAD,   0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "23.41 FIONREAD No Data UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.42 FIONREAD 0 Data UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  TRUE,  0,  0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.43 FIONREAD 10 Data UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  TRUE,  10, 0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.44 FIONREAD 10 & 5 Data UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  TRUE,  10, 5,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.45 FIONREAD 10 & 0 Data UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  TRUE,  10, 0,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.46 FIONREAD 0 & 5 Data UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, TRUE,  TRUE,  0,  5,  FIONREAD,   0, TRUE,  0,            0,                 FALSE },
    { "23.47 SIOCATMARK TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  SIOCATMARK, 0, TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "23.48 SIOCATMARK UDP",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  SIOCATMARK, 0, TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "23.49 Closed Socket TCP",         TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, TRUE,  SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "23.50 Closed Socket UDP",         TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, TRUE,  SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "23.51 Not Initialized",           FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, 0,  0,  0,          0, FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define ioctlsocketTableCount (sizeof(ioctlsocketTable) / sizeof(IOCTLSOCKET_TABLE))

NETSYNC_TYPE_THREAD  ioctlsocketTestSessionNt =
{
    1,
    ioctlsocketTableCount,
    L"xnetapi_nt.dll",
    "ioctlsocketTestServer"
};

NETSYNC_TYPE_THREAD  ioctlsocketTestSessionXbox =
{
    1,
    ioctlsocketTableCount,
    L"xnetapi_xbox.dll",
    "ioctlsocketTestServer"
};



VOID
ioctlsocketTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests ioctlsocket - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // ioctlsocketRequest is the request sent to the server
    IOCTLSOCKET_REQUEST    ioctlsocketRequest;
    
    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = SLEEP_LOW_TIME;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;

    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // argp is the ioctlsocket command parameter
    u_long                 argp;

    // dwFirstTime is the first tick count
    DWORD                  dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                  dwSecondTime;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "ioctlsocket v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_ioctlsocket+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_ioctlsocket-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = ioctlsocketTestSessionXbox;
    }
    else {
        NetsyncTypeSession = ioctlsocketTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < ioctlsocketTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, ioctlsocketTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, ioctlsocketTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != ioctlsocketTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, ioctlsocketTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == ioctlsocketTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != ioctlsocketTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == ioctlsocketTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = ioctlsocketTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == ioctlsocketTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == ioctlsocketTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == ioctlsocketTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == ioctlsocketTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == ioctlsocketTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == ioctlsocketTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & ioctlsocketTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & ioctlsocketTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Set the send and receive timeout values
        if ((0 != (SOCKET_TCP  & ioctlsocketTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & ioctlsocketTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & ioctlsocketTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        if (TRUE == ioctlsocketTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == ioctlsocketTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if ((TRUE == ioctlsocketTable[dwTableIndex].bAccept) || (TRUE == ioctlsocketTable[dwTableIndex].bConnect)) {
            // Initialize the ioctlsocket request
            ioctlsocketRequest.dwMessageId = IOCTLSOCKET_REQUEST_MSG;
            if (0 != (SOCKET_TCP & ioctlsocketTable[dwTableIndex].dwSocket)) {
                ioctlsocketRequest.nSocketType = SOCK_STREAM;
            }
            else {
                ioctlsocketRequest.nSocketType = SOCK_DGRAM;
            }
            ioctlsocketRequest.Port = CurrentPort;
            ioctlsocketRequest.bServerAccept = ioctlsocketTable[dwTableIndex].bConnect;
            ioctlsocketRequest.bServerSendData = ioctlsocketTable[dwTableIndex].bReceiveData;
            ioctlsocketRequest.dwDataSize1 = ioctlsocketTable[dwTableIndex].dwDataSize1;
            ioctlsocketRequest.dwDataSize2 = ioctlsocketTable[dwTableIndex].dwDataSize2;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(ioctlsocketRequest), (char *) &ioctlsocketRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == ioctlsocketTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
            }
            else if (TRUE == ioctlsocketTable[dwTableIndex].bAccept) {
                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(ioctlsocketRequest), (char *) &ioctlsocketRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        // Initialize the socket result
        argp = ioctlsocketTable[dwTableIndex].argp_in;

        if ((0 != (SOCKET_TCP & ioctlsocketTable[dwTableIndex].dwSocket)) && (10 == ioctlsocketTable[dwTableIndex].dwDataSize1) && (5 == ioctlsocketTable[dwTableIndex].dwDataSize2)) {
            do {
                Sleep(SLEEP_LOW_TIME);

                ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket: nsSocket, FIONREAD, &argp);
            } while (15 != argp);
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & ioctlsocketTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call ioctlsocket
            iReturnCode = ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket: nsSocket, ioctlsocketTable[dwTableIndex].Command, (TRUE == ioctlsocketTable[dwTableIndex].bargp_out) ? &argp : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == ioctlsocketTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "ioctlsocket RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "ioctlsocket caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == ioctlsocketTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "ioctlsocket did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == ioctlsocketTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != ioctlsocketTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "ioctlsocket iLastError - EXPECTED: %u; RECEIVED: %u", ioctlsocketTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "ioctlsocket iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "ioctlsocket returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == ioctlsocketTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "ioctlsocket returned non-SOCKET_ERROR");
            }
            else {
                if (FIONBIO == ioctlsocketTable[dwTableIndex].Command) {
                    if ((TRUE == ioctlsocketTable[dwTableIndex].bAccept) || (TRUE == ioctlsocketTable[dwTableIndex].bConnect)) {
                        // Get the first tick count
                        dwFirstTime = GetTickCount();

                        // Call receive
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                        recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);

                        // Get the second tick count
                        dwSecondTime = GetTickCount();

                        if (0 == ioctlsocketTable[dwTableIndex].argp_in) {
                            // Blocking operation
                            if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                                xLog(hLog, XLL_FAIL, "FIONBIO nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            // Nonblocking operation
                            if ((dwSecondTime - dwFirstTime) > SLEEP_ZERO_TIME) {
                                xLog(hLog, XLL_FAIL, "FIONBIO nTime - EXPECTED: %d; RECEIVED: %d", 0, dwSecondTime - dwFirstTime);
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }
                else if (FIONREAD == ioctlsocketTable[dwTableIndex].Command) {
                    if (0 != (SOCKET_TCP & ioctlsocketTable[dwTableIndex].dwSocket)) {
                        if (argp != (ioctlsocketTable[dwTableIndex].dwDataSize1 + ioctlsocketTable[dwTableIndex].dwDataSize2)) {
                            xLog(hLog, XLL_FAIL, "FIONREAD argp1 - EXPECTED: %d; RECEIVED: %d", ioctlsocketTable[dwTableIndex].dwDataSize1 + ioctlsocketTable[dwTableIndex].dwDataSize2, argp);
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (TRUE == ioctlsocketTable[dwTableIndex].bReceiveData) {
                            if (argp != ioctlsocketTable[dwTableIndex].dwDataSize1 + (0 == ioctlsocketTable[dwTableIndex].dwDataSize1) ? 1 : 0) {
                                xLog(hLog, XLL_FAIL, "FIONREAD argp1 - EXPECTED: %d; RECEIVED: %d", ioctlsocketTable[dwTableIndex].dwDataSize1 + (0 == ioctlsocketTable[dwTableIndex].dwDataSize1) ? 1 : 0, argp);
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (argp != 0) {
                                xLog(hLog, XLL_FAIL, "FIONREAD argp1 - EXPECTED: %d; RECEIVED: %d", 0, argp);
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    if ((0 != ioctlsocketTable[dwTableIndex].dwDataSize1) || (0 != ioctlsocketTable[dwTableIndex].dwDataSize2)) {
                        // Call receive
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                        recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, ioctlsocketTable[dwTableIndex].dwDataSize1, 0);
                    
                        argp = 0;
                        iReturnCode = ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONREAD, &argp);

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "ioctlsocket returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            if (0 != (SOCKET_TCP & ioctlsocketTable[dwTableIndex].dwSocket)) {
                                if (argp != ioctlsocketTable[dwTableIndex].dwDataSize2) {
                                    xLog(hLog, XLL_FAIL, "FIONREAD argp2 - EXPECTED: %d; RECEIVED: %d", ioctlsocketTable[dwTableIndex].dwDataSize2, argp);
                                    bTestPassed = FALSE;
                                }
                            }
                            else {
                                if (argp != ioctlsocketTable[dwTableIndex].dwDataSize2 + (0 == ioctlsocketTable[dwTableIndex].dwDataSize2) ? 1 : 0) {
                                    xLog(hLog, XLL_FAIL, "FIONREAD argp2 - EXPECTED: %d; RECEIVED: %d", ioctlsocketTable[dwTableIndex].dwDataSize2 + (0 == ioctlsocketTable[dwTableIndex].dwDataSize2) ? 1 : 0, argp);
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "ioctlsocket succeeded");
                }
            }
        }

        if ((TRUE == ioctlsocketTable[dwTableIndex].bAccept) || (TRUE == ioctlsocketTable[dwTableIndex].bConnect)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(ioctlsocketRequest), (char *) &ioctlsocketRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & ioctlsocketTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & ioctlsocketTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & ioctlsocketTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
ioctlsocketTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests ioctlsocket - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                FromInAddr;
    // dwMessageType is the type of received message
    DWORD                 dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                 dwMessageSize;
    // pMessage is a pointer to the received message
    char                  *pMessage;
    // ioctlsocketRequest is the request
    IOCTLSOCKET_REQUEST   ioctlsocketRequest;
    // ioctlsocketComplete is the result
    IOCTLSOCKET_COMPLETE  ioctlsocketComplete;

    // sSocket is the socket descriptor
    SOCKET                sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                   iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                  bNagle = FALSE;

    // localname is the local address
    SOCKADDR_IN           localname;
    // remotename is the remote address
    SOCKADDR_IN           remotename;

    // SendBuffer10 is the send buffer
    char                  SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                  SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // dwFillBuffer is a counter to fill the buffers
    DWORD                 dwFillBuffer;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&ioctlsocketRequest, pMessage, sizeof(ioctlsocketRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, ioctlsocketRequest.nSocketType, 0);

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == ioctlsocketRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(ioctlsocketRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == ioctlsocketRequest.nSocketType) && (TRUE == ioctlsocketRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(ioctlsocketRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        ioctlsocketComplete.dwMessageId = IOCTLSOCKET_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(ioctlsocketComplete), (char *) &ioctlsocketComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == ioctlsocketRequest.nSocketType) && (TRUE == ioctlsocketRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == ioctlsocketRequest.bServerSendData) {
            if (0 == ioctlsocketRequest.dwDataSize1) {
                send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, NULL, 0, 0);
            }
            else {
                // Initialize the buffers
                sprintf(SendBuffer10, "%05d%05d", 1, 1);
                for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += 10) {
                    CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > 10 ? 10 : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                }

                send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, ioctlsocketRequest.dwDataSize1, 0);
            }

            if (0 == ioctlsocketRequest.dwDataSize2) {
                send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, NULL, 0, 0);
            }
            else {
                // Initialize the buffers
                sprintf(SendBuffer10, "%05d%05d", 2, 2);
                for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += 10) {
                    CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > 10 ? 10 : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                }

                send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, ioctlsocketRequest.dwDataSize2, 0);
            }
        }

        // Send the complete
        ioctlsocketComplete.dwMessageId = IOCTLSOCKET_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(ioctlsocketComplete), (char *) &ioctlsocketComplete);

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#ifdef _XBOX

#include <xtl.h>
#include <xtestlib.h>
#include <xnetref.h>

#else

#include <windows.h>
#include <winsock2.h>

#endif

#include <stdio.h>

#include <xmem.h>
#include <xlog.h>
#include <netsync.h>

#include "common.h"
#include "util.h"
#include "client.h"
#include "server.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\ntohl.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  ntohl.c

Abstract:

  This modules tests ntohl

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _NTOHL_TABLE {
    CHAR    szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    u_long  netlong;                                 // u_long in network byte order
    u_long  hostlong;                                // u_long in host byte order
    BOOL    bRIP;                                    // Specifies a RIP test case
} NTOHL_TABLE, *PNTOHL_TABLE;

static NTOHL_TABLE ntohlTable[] =
{
    { "3.1 0x00000000", 0x00000000, 0x00000000, FALSE },
    { "3.2 0x7FFFFFFF", 0x7FFFFFFF, 0xFFFFFF7F, FALSE },
    { "3.3 0x10203040", 0x10203040, 0x40302010, FALSE },
    { "3.4 0x0000ABCD", 0x0000ABCD, 0xCDAB0000, FALSE },
    { "3.5 0x0000ABCD", 0x0000ABCD, 0xCDAB0000, FALSE },
    { "3.6 0xAAAAAAAA", 0xAAAAAAAA, 0xAAAAAAAA, FALSE },
    { "3.7 0x0000FFFF", 0x0000FFFF, 0xFFFF0000, FALSE }
};

#define ntohlTableCount (sizeof(ntohlTable) / sizeof(NTOHL_TABLE))



VOID
ntohlTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests ntohl

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD    dwTableIndex;

    // hostlong is the returned value in host byte order
    u_long   hostlong;

    // bException indicates if an exception occurred
    BOOL     bException;



    // Set the function name
    xSetFunctionName(hLog, "ntohl");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_ntohl+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_ntohl-");

    for (dwTableIndex = 0; dwTableIndex < ntohlTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, ntohlTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, ntohlTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != ntohlTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, ntohlTable[dwTableIndex].szVariationName);

        bException = FALSE;

        __try {
            // Call ntohl
            hostlong = ntohl(ntohlTable[dwTableIndex].netlong);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == ntohlTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "ntohl RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "ntohl caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == ntohlTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "ntohl did not RIP");
            }

            if (hostlong != ntohlTable[dwTableIndex].hostlong) {
                xLog(hLog, XLL_FAIL, "EXPECTED: 0x%08x; RECEIVED: 0x%08x", ntohlTable[dwTableIndex].hostlong, hostlong);
            }
            else {
                xLog(hLog, XLL_PASS, "OUT: 0x%08x", hostlong);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\recv.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  recv.c

Abstract:

  This modules tests recv

Author:

  Steven Kehrli (steveke) 13-Dev-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// recv messages

#define RECV_REQUEST_MSG   NETSYNC_MSG_USER + 170 + 1
#define RECV_CANCEL_MSG    NETSYNC_MSG_USER + 170 + 2
#define RECV_COMPLETE_MSG  NETSYNC_MSG_USER + 170 + 3

typedef struct _RECV_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bRemoteShutdown;
    BOOL     bRemoteClose;
    int      nDataBuffers;
    int      nBufferlen;
} RECV_REQUEST, *PRECV_REQUEST;

typedef struct _RECV_COMPLETE {
    DWORD    dwMessageId;
} RECV_COMPLETE, *PRECV_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define BUFFER_10             0
#define BUFFER_LARGE          1
#define BUFFER_NULL           2
#define BUFFER_NULLZERO       3
#define BUFFER_ZERO           4
#define BUFFER_SMALL          5
#define BUFFER_TCPLARGE       6
#define BUFFER_UDPLARGE       7
#define BUFFER_UDPTOOLARGE    8
#define BUFFER_MULTI          9
#define BUFFER_SECOND        10
#define BUFFER_NONE          11

#define OVERLAPPED_IO_RESULT  1
#define OVERLAPPED_IO_EVENT   2



typedef struct RECVBUFFER_TABLE {
    int   nBufferlen;
} RECVBUFFER_TABLE, *PRECVBUFFER_TABLE;

RECVBUFFER_TABLE RecvBufferTcpTable[] = { { BUFFER_10_LEN       },
                                          { 0                   },
                                          { BUFFER_TCPLARGE_LEN } };
#define RecvBufferTcpTableCount  (sizeof(RecvBufferTcpTable) / sizeof(RECVBUFFER_TABLE));

RECVBUFFER_TABLE RecvBufferUdpTable[] = { { BUFFER_10_LEN       },
                                          { 0                   },
                                          { BUFFER_UDPLARGE_LEN } };
#define RecvBufferUdpTableCount  (sizeof(RecvBufferUdpTable) / sizeof(RECVBUFFER_TABLE));



typedef struct RECV_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the recv
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    BOOL   bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL   bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL   bConnect;                                // bConnect indicates if the socket is connected
    BOOL   bRemoteShutdown;                         // bRemoteShutdown indicates if the remote shutsdown the connection
    BOOL   bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL   bShutdown;                               // bShutdown indicates if the connection is shutdown
    int    nShutdown;                               // nShutdown indicates how the connection is shutdown
    int    nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be received
    DWORD  dwBuffer;                                // dwBuffer specifies the recv buffer
    int    nBufferlen;                              // nBufferlen specifies the recv data buffer length
    int    nFlags;                                  // nFlags specifies the recv flags
    BOOL   bSecondRecv;                             // bSecondRecv indicates if a second recv should occur
    int    iReturnCode;                             // iReturnCode is the return code of recv
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} RECV_TABLE, *PRECV_TABLE;

static RECV_TABLE recvTable[] =
{
    { "17.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "17.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "17.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "17.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "17.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "17.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "17.7 Not Bound TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "17.8 Listening TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "17.9 Accepted TCP",               TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.10 Connected TCP",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.11 Second Receive TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN / 2,   0, TRUE,  0,            0,                 FALSE },
    { "17.12 SD_RECEIVE Accept TCP",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.13 SD_SEND Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.14 SD_BOTH Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.15 SD_RECEIVE Connect TCP",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.16 SD_SEND Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.17 SD_BOTH Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.18 Shutdown Accept TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.19 Shutdown Connect TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.20 Close Accept TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "17.21 Close Connect TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "17.22 NULL Buffer TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.23 Neg Bufferlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, -1,                  0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.24 NULL 0 Bufferlen TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, 0,            0,                 FALSE },
    { "17.25 0 Bufferlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, 0,                   0, FALSE, 0,            0,                 FALSE },
    { "17.26 Small Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN - 1,   0, FALSE, 0,            0,                 FALSE },
    { "17.27 Exact Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.28 Large Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_TCPLARGE_LEN, 0, FALSE, 0,            0,                 FALSE },
    { "17.29 Switch Recv TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.30 Iterative Recv TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.31 flags != 0 TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       4, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.32 Not Bound NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "17.33 Listening NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "17.34 Accepted NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.35 Connected NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.36 Second Receive NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, TRUE,  0,            0,                 FALSE },
    { "17.37 SD_RECEIVE Accept NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.38 SD_SEND Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.39 SD_BOTH Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.40 SD_RECEIVE Connect NB TCP", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.41 SD_SEND Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.42 SD_BOTH Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.43 Shutdown Accept NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.44 Shutdown Connect NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.45 Close Accept NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "17.46 Close Connect NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "17.47 NULL Buffer NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.48 Neg Bufferlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, -1,                  0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.49 NULL 0 Bufferlen NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, 0,            0,                 FALSE },
    { "17.50 0 Bufferlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, 0,                   0, FALSE, 0,            0,                 FALSE },
    { "17.51 Small Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN - 1,   0, FALSE, 0,            0,                 FALSE },
    { "17.52 Exact Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.53 Large Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_TCPLARGE_LEN, 0, FALSE, 0,            0,                 FALSE },
    { "17.54 Switch Recv NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.55 Iterative Recv NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.56 flags != 0 NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       4, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.57 Not Bound UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "17.58 Not Connected UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.59 Connected UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.60 SD_RECEIVE Conn UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.61 SD_SEND Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.62 SD_BOTH Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.63 Second Receive UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN / 2,   0, TRUE,  SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "17.64 NULL Buffer UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.65 Neg Bufferlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, -1,                  0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.66 NULL 0 Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, 0,            0,                 FALSE },
    { "17.67 0 Bufferlen UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, 0,                   0, FALSE, 0,            0,                 FALSE },
    { "17.68 Small Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN - 1,   0, FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "17.69 Exact Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.70 Large Buffer UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN, 0, FALSE, 0,            0,                 FALSE },
    { "17.71 Switch Recv UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.72 Iterative Recv UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.73 flags != 0 UDP",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       4, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.74 Not Bound NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "17.75 Not Connected NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.76 Connected NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.77 SD_RECEIVE Conn NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.78 SD_SEND Conn NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.79 SD_BOTH Conn NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "17.80 Second Receive NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN / 2,   0, TRUE,  SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "17.81 NULL Buffer NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  BUFFER_10_LEN,       0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.82 Neg Bufferlen NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, -1,                  0, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.83 NULL 0 Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, 0,            0,                 FALSE },
    { "17.84 0 Bufferlen NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, 0,                   0, FALSE, 0,            0,                 FALSE },
    { "17.85 Small Bufferlen NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN - 1,   0, FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "17.86 Exact Bufferlen NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.87 Large Buffer NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN, 0, FALSE, 0,            0,                 FALSE },
    { "17.88 Switch Recv NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.89 Iterative Recv NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, 0,            0,                 FALSE },
    { "17.90 flags != 0 NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       4, FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "17.91 Closed Socket TCP",         TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "17.92 Closed Socket UDP",         TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "17.93 Not Initialized",           FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define recvTableCount (sizeof(recvTable) / sizeof(RECV_TABLE))

NETSYNC_TYPE_THREAD  recvTestSessionNt =
{
    1,
    recvTableCount,
    L"xnetapi_nt.dll",
    "recvTestServer"
};

NETSYNC_TYPE_THREAD  recvTestSessionXbox =
{
    1,
    recvTableCount,
    L"xnetapi_xbox.dll",
    "recvTestServer"
};



VOID
recvTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests recv - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // recvRequest is the request sent to the server
    RECV_REQUEST           recvRequest;
    
    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // timeout is the timeout for select
    timeval                fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                   RecvBuffer10[BUFFER_10_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // dwFillBuffer is a counter to fill the buffers
    DWORD                  dwFillBuffer;
    // nBytes is the number of bytes sent
    int                    nBytes;
    // nRecvCount is a counter to enumerate each recv
    int                    nRecvCount;

    // dwFirstTime is the first tick count
    DWORD                  dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                  dwSecondTime;

    // RecvBufferTable is the test buffer table to use for iterative recv
    PRECVBUFFER_TABLE      RecvBufferTable;
    // RecvBufferTableCount is the number of elements within the test buffer table
    size_t                 RecvBufferTableCount;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "recv v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_recv+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_recv-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = recvTestSessionXbox;
    }
    else {
        NetsyncTypeSession = recvTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < recvTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, recvTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, recvTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != recvTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, recvTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == recvTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != recvTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == recvTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = recvTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == recvTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == recvTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == recvTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == recvTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == recvTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == recvTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & recvTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & recvTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == recvTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == recvTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == recvTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
            RecvBufferTable = RecvBufferTcpTable;
            RecvBufferTableCount = RecvBufferTcpTableCount;
        }
        else {
            RecvBufferTable = RecvBufferUdpTable;
            RecvBufferTableCount = RecvBufferUdpTableCount;
        }

        if ((TRUE == recvTable[dwTableIndex].bAccept) || (TRUE == recvTable[dwTableIndex].bConnect) || (0 == recvTable[dwTableIndex].iReturnCode)) {
            // Initialize the recv request
            recvRequest.dwMessageId = RECV_REQUEST_MSG;
            if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
                recvRequest.nSocketType = SOCK_STREAM;
            }
            else {
                recvRequest.nSocketType = SOCK_DGRAM;
            }
            recvRequest.Port = CurrentPort;
            recvRequest.bServerAccept = recvTable[dwTableIndex].bConnect;
            recvRequest.bRemoteShutdown = recvTable[dwTableIndex].bRemoteShutdown;
            recvRequest.bRemoteClose = recvTable[dwTableIndex].bRemoteClose;
            if (100 == recvTable[dwTableIndex].nDataBuffers) {
                recvRequest.nDataBuffers = recvTable[dwTableIndex].nDataBuffers * RecvBufferTableCount;
            }
            else {
                recvRequest.nDataBuffers = ((0 == recvTable[dwTableIndex].iReturnCode) || (WSAEMSGSIZE == recvTable[dwTableIndex].iLastError)) ? recvTable[dwTableIndex].nDataBuffers : 0;
            }
            if (TRUE == recvTable[dwTableIndex].bSecondRecv) {
                recvRequest.nBufferlen = recvTable[dwTableIndex].nBufferlen * 2;
            }
            else if (((0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) || (WSAEMSGSIZE == recvTable[dwTableIndex].iLastError)) && (BUFFER_10_LEN > recvTable[dwTableIndex].nBufferlen)) {
                recvRequest.nBufferlen = BUFFER_10_LEN;
            }
            else {
                recvRequest.nBufferlen = recvTable[dwTableIndex].nBufferlen;
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvRequest), (char *) &recvRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == recvTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

                if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else if (TRUE == recvTable[dwTableIndex].bAccept) {
                if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvRequest), (char *) &recvRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == recvTable[dwTableIndex].bRemoteShutdown) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (0 != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }

            if (TRUE == recvTable[dwTableIndex].bRemoteClose) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Shutdown the connection
        if (TRUE == recvTable[dwTableIndex].bShutdown) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, recvTable[dwTableIndex].nShutdown);
        }

        // Zero the receive buffer
        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);
        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & recvTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        // Get the current tick count
        dwFirstTime = GetTickCount();

        __try {
            // Call recv
            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != recvTable[dwTableIndex].dwBuffer) ? RecvBufferLarge : NULL, recvTable[dwTableIndex].nBufferlen, recvTable[dwTableIndex].nFlags);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == recvTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "recv RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "recv caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if ((TRUE == bNonblocking) && (FALSE == recvTable[dwTableIndex].bRemoteShutdown) && ((0 == recvTable[dwTableIndex].iReturnCode) || (WSAEMSGSIZE == recvTable[dwTableIndex].iLastError))) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                    bTestPassed = FALSE;
                }
                else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", WSAGetLastError());

                    FD_ZERO(&readfds);
                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);

                    // Call recv
                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != recvTable[dwTableIndex].dwBuffer) ? RecvBufferLarge : NULL, recvTable[dwTableIndex].nBufferlen, recvTable[dwTableIndex].nFlags);
                }
            }

            // Get the current tick count
            dwSecondTime = GetTickCount();

            if (TRUE == recvTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "recv did not RIP");
            }

            if (TRUE == recvTable[dwTableIndex].bRemoteShutdown) {
                if (SOCKET_ERROR == iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                }
                else if (0 != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recv iReturnCode - EXPECTED: %u; RECEIVED: %u", 0, iReturnCode);
                }
                else {
                    xLog(hLog, XLL_PASS, "recv succeeded");
                }
            }
            else if (WSAEMSGSIZE == recvTable[dwTableIndex].iLastError) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                }
                else if (WSAEMSGSIZE != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEMSGSIZE, WSAGetLastError());
                }
                else {
                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != recvTable[dwTableIndex].dwBuffer) ? RecvBufferLarge : NULL, recvTable[dwTableIndex].nBufferlen, recvTable[dwTableIndex].nFlags);

                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                    }
                    else if (((TRUE == bNonblocking) && (WSAEWOULDBLOCK != WSAGetLastError())) || ((FALSE == bNonblocking) && (WSAETIMEDOUT != WSAGetLastError()))) {
                        xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", (TRUE == bNonblocking) ? WSAEWOULDBLOCK : WSAETIMEDOUT, WSAGetLastError());
                    }
                    else {
                        xLog(hLog, XLL_PASS, "recv succeeded");
                    }
                }
            }
            else if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == recvTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != recvTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", recvTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (1 < recvRequest.nDataBuffers) {
                    // Send the recv cancel
                    recvRequest.dwMessageId = RECV_CANCEL_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvRequest), (char *) &recvRequest);
                }
            }
            else if (SOCKET_ERROR == recvTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
            }
            else {
                if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                    xLog(hLog, XLL_FAIL, "recv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                    bTestPassed = FALSE;
                }

                if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
                    nBytes = iReturnCode;

                    if (TRUE == recvTable[dwTableIndex].bSecondRecv) {
                        if (recvTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", recvTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, recvTable[dwTableIndex].nBufferlen)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }

                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], recvTable[dwTableIndex].nBufferlen, recvTable[dwTableIndex].nFlags);

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            if (recvTable[dwTableIndex].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", recvTable[dwTableIndex].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(&SendBufferLarge[nBytes], &RecvBufferLarge[nBytes], recvTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }

                            nBytes += iReturnCode;
                        }
                    }

                    if (BUFFER_10_LEN <= recvTable[dwTableIndex].nBufferlen) {
                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                            if (1 == iReturnCode) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], recvTable[dwTableIndex].nBufferlen, 0);

                                if (SOCKET_ERROR != iReturnCode) {
                                    nBytes += iReturnCode;
                                }
                            }
                        } while (0 != iReturnCode);
                    }

                    iReturnCode = nBytes;
                }

                if ((recvTable[dwTableIndex].nBufferlen * ((TRUE == recvTable[dwTableIndex].bSecondRecv) ? 2 : 1)) != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", (recvTable[dwTableIndex].nBufferlen * ((TRUE == recvTable[dwTableIndex].bSecondRecv) ? 2 : 1)), iReturnCode);
                    bTestPassed = FALSE;
                }
                else {
                    if (0 != strncmp(SendBufferLarge, RecvBufferLarge, recvTable[dwTableIndex].nBufferlen * ((TRUE == recvTable[dwTableIndex].bSecondRecv) ? 2 : 1))) {
                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                        bTestPassed = FALSE;
                    }
                }

                if (3 == recvTable[dwTableIndex].nDataBuffers) {
                    // Zero the receive buffer
                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvRequest), (char *) &recvRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call recv
                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, recvTable[dwTableIndex].nBufferlen, recvTable[dwTableIndex].nFlags);

                    if (TRUE == bNonblocking) {
                        if (SOCKET_ERROR != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                            bTestPassed = FALSE;
                        }
                        else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", WSAGetLastError());

                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                            select(0, &readfds, NULL, NULL, NULL);

                            // Call recv
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, recvTable[dwTableIndex].nBufferlen, recvTable[dwTableIndex].nFlags);
                        }
                    }

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        recvRequest.dwMessageId = RECV_CANCEL_MSG;
                    }
                    else {
                        if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
                            nBytes = iReturnCode;

                            do {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                if (1 == iReturnCode) {
                                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], recvTable[dwTableIndex].nBufferlen, 0);

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                }
                            } while (0 != iReturnCode);

                            iReturnCode = nBytes;
                        }

                        if (recvTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", recvTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else {
                            if (0 != strncmp(SendBufferLarge, RecvBufferLarge, recvTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }

                        recvRequest.dwMessageId = RECV_REQUEST_MSG;
                    }

                    // Zero the receive buffer
                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 3, 3);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvRequest), (char *) &recvRequest);

                    if (RECV_CANCEL_MSG != recvRequest.dwMessageId) {
                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        // Switch the blocking mode
                        Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                        ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                        bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                        // Call recv
                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, recvTable[dwTableIndex].nBufferlen, recvTable[dwTableIndex].nFlags);

                        if (TRUE == bNonblocking) {
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "recv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recv iLastError - OUT: %u", WSAGetLastError());

                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);

                                // Call recv
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, recvTable[dwTableIndex].nBufferlen, recvTable[dwTableIndex].nFlags);
                            }
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
                                nBytes = iReturnCode;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], recvTable[dwTableIndex].nBufferlen, 0);

                                        if (SOCKET_ERROR != iReturnCode) {
                                            nBytes += iReturnCode;
                                        }
                                    }
                                } while (0 != iReturnCode);

                                iReturnCode = nBytes;
                            }

                            if (recvTable[dwTableIndex].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", recvTable[dwTableIndex].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else {
                                if (0 != strncmp(SendBufferLarge, RecvBufferLarge, recvTable[dwTableIndex].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }
                else if (100 == recvTable[dwTableIndex].nDataBuffers) {
                    for (nRecvCount = 0; nRecvCount < (int) (recvTable[dwTableIndex].nDataBuffers * RecvBufferTableCount); nRecvCount++) {
                        // Zero the receive buffer
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 2 + nRecvCount, 2 + nRecvCount);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }

                        xLog(hLog, XLL_INFO, "Iteration %d", nRecvCount);

                        // Send the recv request
                        recvRequest.nBufferlen = RecvBufferTable[nRecvCount % RecvBufferTableCount].nBufferlen;
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvRequest), (char *) &recvRequest);

                        if (RECV_CANCEL_MSG == recvRequest.dwMessageId) {
                            break;
                        }

                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        if ((0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) && (0 == RecvBufferTable[nRecvCount % RecvBufferTableCount].nBufferlen)) {
                            iReturnCode = 0;
                        }
                        else {
                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            // Call recv
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, RecvBufferTable[nRecvCount % RecvBufferTableCount].nBufferlen, 0);
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            recvRequest.dwMessageId = RECV_CANCEL_MSG;
                            bTestPassed = FALSE;
                        }
                        else {
                            if (0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) {
                                nBytes = iReturnCode;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], RecvBufferTable[nRecvCount % RecvBufferTableCount].nBufferlen, 0);

                                        if (SOCKET_ERROR != iReturnCode) {
                                            nBytes += iReturnCode;
                                        }
                                    }
                                } while (0 != iReturnCode);

                                iReturnCode = nBytes;
                            }

                            if (RecvBufferTable[nRecvCount % RecvBufferTableCount].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", RecvBufferTable[nRecvCount % RecvBufferTableCount].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else {
                                if (0 != strncmp(SendBufferLarge, RecvBufferLarge, RecvBufferTable[nRecvCount % RecvBufferTableCount].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "recv succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (recvTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == recvTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            bNonblocking = recvTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == recvTable[dwTableIndex].bAccept) || (TRUE == recvTable[dwTableIndex].bConnect) || (0 == recvTable[dwTableIndex].iReturnCode)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvRequest), (char *) &recvRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & recvTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & recvTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & recvTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
recvTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests recv - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long         FromInAddr;
    // dwMessageType is the type of received message
    DWORD          dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD          dwMessageSize;
    // pMessage is a pointer to the received message
    char           *pMessage;
    // recvRequest is the request
    RECV_REQUEST   recvRequest;
    // recvComplete is the result
    RECV_COMPLETE  recvComplete;

    // sSocket is the socket descriptor
    SOCKET         sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET         nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int            iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL           bNagle = FALSE;

    // localname is the local address
    SOCKADDR_IN    localname;
    // remotename is the remote address
    SOCKADDR_IN    remotename;

    // SendBuffer10 is the send buffer
    char           SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char           SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // dwFillBuffer is a counter to fill the buffers
    DWORD          dwFillBuffer;
    // nSendCount is a counter to enumerate each send
    int            nSendCount;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&recvRequest, pMessage, sizeof(recvRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, recvRequest.nSocketType, 0);

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == recvRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(recvRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == recvRequest.nSocketType) && (TRUE == recvRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(recvRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        recvComplete.dwMessageId = RECV_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvComplete), (char *) &recvComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == recvRequest.nSocketType) && (TRUE == recvRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == recvRequest.bRemoteShutdown) {
            // Shutdown the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
            }
        }

        if (TRUE == recvRequest.bRemoteClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
                closesocket(nsSocket);
                nsSocket = INVALID_SOCKET;
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
                sSocket = INVALID_SOCKET;
            }
        }

        // Send the complete
        recvComplete.dwMessageId = RECV_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvComplete), (char *) &recvComplete);

        if (0 < recvRequest.nDataBuffers) {
            // Sleep
            Sleep(SLEEP_MIDLOW_TIME);

            // Initialize the buffer
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
            }

            // Send the buffer
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, recvRequest.nBufferlen, 0);

            if (3 == recvRequest.nDataBuffers) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                
                if (RECV_CANCEL_MSG != ((PRECV_REQUEST) pMessage)->dwMessageId) {
                    // Send the complete
                    recvComplete.dwMessageId = RECV_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvComplete), (char *) &recvComplete);

                    // Sleep
                    Sleep(SLEEP_MIDLOW_TIME);

                    // Initialize the buffer
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                    }

                    // Send the buffer
                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, recvRequest.nBufferlen, 0);

                    NetsyncFreeMessage(pMessage);

                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if (RECV_CANCEL_MSG != ((PRECV_REQUEST) pMessage)->dwMessageId) {
                        // Send the complete
                        recvComplete.dwMessageId = RECV_COMPLETE_MSG;
                        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvComplete), (char *) &recvComplete);

                        // Sleep
                        Sleep(SLEEP_MIDLOW_TIME);

                        // Initialize the buffer
                        sprintf(SendBuffer10, "%05d%05d", 3, 3);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                        }

                        // Send the buffer
                        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, recvRequest.nBufferlen, 0);
                    }
                }

                NetsyncFreeMessage(pMessage);
            }
            else if (100 <= recvRequest.nDataBuffers) {
                for (nSendCount = 0; nSendCount < recvRequest.nDataBuffers; nSendCount++) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if (RECV_CANCEL_MSG == ((PRECV_REQUEST) pMessage)->dwMessageId) {
                        NetsyncFreeMessage(pMessage);
                        break;
                    }

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2 + nSendCount, 2 + nSendCount);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                    }

                    // Send the buffer
                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, ((PRECV_REQUEST) pMessage)->nBufferlen, 0);

                    NetsyncFreeMessage(pMessage);

                    // Send the complete
                    recvComplete.dwMessageId = RECV_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvComplete), (char *) &recvComplete);
                }
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\listen.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  listen.c

Abstract:

  This modules tests listen

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// listen messages

#define LISTEN_REQUEST_MSG   NETSYNC_MSG_USER + 100 + 1
#define LISTEN_COMPLETE_MSG  NETSYNC_MSG_USER + 100 + 2

typedef struct _LISTEN_REQUEST {
    DWORD    dwMessageId;
    int      nNumConnections;
    u_short  Port;
} LISTEN_REQUEST, *PLISTEN_REQUEST;

typedef struct _LISTEN_COMPLETE {
    DWORD    dwMessageId;
} LISTEN_COMPLETE, *PLISTEN_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct LISTEN_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    int    backlog1;                                // backlog1 indicates the maximum length of the queue of pending connections
    int    backlog2;                                // backlog2 indicates if the maximum length of the queue of pending connections should be updated
    BOOL   bQueueConnections;                       // bQueueConnections indicates if the connect should occur before the final listen
    BOOL   bConnected;                              // bConnected indicates if the accept should occur before the final listen
    int    nNumConnections;                         // nNumConnections indicates the number of connections that should occur
    int    iReturnCode;                             // iReturnCode is the return code of listen
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} LISTEN_TABLE, *PLISTEN_TABLE;

static LISTEN_TABLE listenTable[] =
{
    { "10.1 Not Initialized",    FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "10.2 s = INT_MIN",        TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "10.3 s = -1",             TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "10.4 s = 0",              TRUE,  TRUE,  SOCKET_ZERO,                FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "10.5 s = INT_MAX",        TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "10.6 s = INVALID_SOCKET", TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "10.7 Not Bound",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "10.8 Bound",              TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   0,            0,                 FALSE },
    { "10.9 bl = INT_MIN",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  INT_MIN,   INT_MIN,   FALSE, FALSE, 1,                   0,            0,                 FALSE },
    { "10.10 bl = -1",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  -1,        -1,        FALSE, FALSE, 1,                   0,            0,                 FALSE },
    { "10.11 bl = 0",            TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  0,         0,         FALSE, FALSE, 1,                   0,            0,                 FALSE },
    { "10.12 bl = SOMAXCONN",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  SOMAXCONN, SOMAXCONN, FALSE, FALSE, MAX_CONNECTIONS + 1, 0,            0,                 FALSE },
    { "10.13 Increase bl",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  1,         SOMAXCONN, FALSE, FALSE, MAX_CONNECTIONS + 1, 0,            0,                 FALSE },
    { "10.14 Decrease bl",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  SOMAXCONN, 1,         FALSE, FALSE, 2,                   0,            0,                 FALSE },
    { "10.15 Drop Excess",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  SOMAXCONN, 1,         TRUE,  FALSE, 2,                   0,            0,                 FALSE },
    { "10.16 Connected",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  1,         SOMAXCONN, FALSE, TRUE,  1,                   SOCKET_ERROR, WSAEISCONN,        FALSE },
    { "10.17 Closed Socket",     TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, TRUE,  SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "10.18 UDP",               TRUE,  TRUE,  SOCKET_UDP,                 FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "10.19 Not Initialized",   FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, SOMAXCONN, SOMAXCONN, FALSE, FALSE, 0,                   SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define listenTableCount (sizeof(listenTable) / sizeof(LISTEN_TABLE))

NETSYNC_TYPE_THREAD  listenTestSessionNt =
{
    1,
    listenTableCount,
    L"xnetapi_nt.dll",
    "listenTestServer"
};

NETSYNC_TYPE_THREAD  listenTestSessionXbox =
{
    1,
    listenTableCount,
    L"xnetapi_xbox.dll",
    "listenTestServer"
};



VOID
listenTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests listen - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // listenRequest is the request sent to the server
    LISTEN_REQUEST         listenRequest;

    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;
    // pnsSockets is an array of socket descriptors returned by accept
    SOCKET                 pnsSockets[MAX_CONNECTIONS + 1];

    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;

    // localname is the local address
    SOCKADDR_IN            localname;

    // bAcceptConn indicates if the socket is in listening mode
    BOOL                   bAcceptConn;
    // nOptionSize is the size of the SO_ACCEPTCONN socket option
    int                    nOptionSize;
    // nConnection is a counter to enumerate each connection
    int                    nConnection;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "listen v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_listen+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_listen-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = listenTestSessionXbox;
    }
    else {
        NetsyncTypeSession = listenTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < listenTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, listenTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, listenTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != listenTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, listenTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == listenTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != listenTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == listenTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = listenTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == listenTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == listenTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == listenTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == listenTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == listenTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == listenTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & listenTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & listenTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Bind the socket
        if (TRUE == listenTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
            CurrentPort++;
        }

        if (0 != (SOCKET_TCP & listenTable[dwTableIndex].dwSocket)) {
            // Check SO_ACCEPTCONN
            nOptionSize = (int) sizeof(bAcceptConn);
            getsockopt(sSocket, SOL_SOCKET, SO_ACCEPTCONN, (char *) &bAcceptConn, &nOptionSize);
            if (FALSE != bAcceptConn) {
                xLog(hLog, XLL_FAIL, "SO_ACCEPTCONN - EXPECTED: FALSE; RECEIVED: TRUE");
            }
        }

        // Initialize the backlog, if necessary
        if (listenTable[dwTableIndex].backlog1 != listenTable[dwTableIndex].backlog2) {
            listen(sSocket, listenTable[dwTableIndex].backlog1);
        }

        if (TRUE == listenTable[dwTableIndex].bQueueConnections) {
            // Initialize the connect request
            listenRequest.dwMessageId = LISTEN_REQUEST_MSG;
            listenRequest.nNumConnections = listenTable[dwTableIndex].nNumConnections;
            listenRequest.Port = ntohs(localname.sin_port);

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(listenRequest), (char *) &listenRequest);

            // Wait for the connect result
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        if (TRUE == listenTable[dwTableIndex].bConnected) {
            // Initialize the connect request
            listenRequest.dwMessageId = LISTEN_REQUEST_MSG;
            listenRequest.nNumConnections = 1;
            listenRequest.Port = ntohs(localname.sin_port);

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(listenRequest), (char *) &listenRequest);

            // Wait for the connect result
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & listenTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call listen
            iReturnCode = listen((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, listenTable[dwTableIndex].backlog2);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == listenTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "listen RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "listen caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == listenTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "listen did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == listenTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != listenTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "iLastError - EXPECTED: %u; RECEIVED: %u", listenTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "listen returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == listenTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "listen returned non-SOCKET_ERROR");
            }
            else {
                // Check SO_ACCEPTCONN
                nOptionSize = (int) sizeof(bAcceptConn);
                getsockopt(sSocket, SOL_SOCKET, SO_ACCEPTCONN, (char *) &bAcceptConn, &nOptionSize);
                if (TRUE != bAcceptConn) {
                    xLog(hLog, XLL_FAIL, "SO_ACCEPTCONN - EXPECTED: TRUE; RECEIVED: FALSE");
                }
                else if (0 != listenTable[dwTableIndex].nNumConnections) {
                    // Set the socket to non-blocking mode
                    Nonblock = 1;
                    ioctlsocket(sSocket, FIONBIO, &Nonblock);

                    if (FALSE == listenTable[dwTableIndex].bQueueConnections) {
                        // Initialize the connect request
                        listenRequest.dwMessageId = LISTEN_REQUEST_MSG;
                        listenRequest.nNumConnections = listenTable[dwTableIndex].nNumConnections;
                        listenRequest.Port = ntohs(localname.sin_port);

                        // Send the connect request
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(listenRequest), (char *) &listenRequest);

                        // Wait for the connect result
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);
                    }

                    // Accept the connections
                    for (nConnection = 0; nConnection < listenTable[dwTableIndex].nNumConnections; nConnection++) {
                        // Accept the connection
                        pnsSockets[nConnection] = INVALID_SOCKET;
                        pnsSockets[nConnection] = accept(sSocket, NULL, NULL);

                        if (INVALID_SOCKET != pnsSockets[nConnection]) {
                            // Set the socket to blocking mode
                            Nonblock = 0;
                            ioctlsocket(pnsSockets[nConnection], FIONBIO, &Nonblock);
                        }

                        if ((nConnection < ((0 >= listenTable[dwTableIndex].backlog2) ? 1 : listenTable[dwTableIndex].backlog2)) && (nConnection < MAX_CONNECTIONS)) {
                            // Accept should succeed

                            if (INVALID_SOCKET == pnsSockets[nConnection]) {
                                xLog(hLog, XLL_FAIL, "accept returned INVALID_SOCKET - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "accept succeeded");
                            }
                        }
                        else {
                            // Connection should fail

                            if (INVALID_SOCKET != pnsSockets[nConnection]) {
                                xLog(hLog, XLL_FAIL, "accept returned non-INVALID_SOCKET", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "accept failed");
                            }
                        }
                    }

                    // Close the connections
                    for (nConnection = 0; nConnection < listenTable[dwTableIndex].nNumConnections; nConnection++) {
                        if (INVALID_SOCKET != pnsSockets[nConnection]) {
                            closesocket(pnsSockets[nConnection]);
                        }
                    }

                    // Set the socket to blocking mode
                    Nonblock = 0;
                    ioctlsocket(sSocket, FIONBIO, &Nonblock);

                    // Send the ack
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(listenRequest), (char *) &listenRequest);

                    if (TRUE == bTestPassed) {
                        xLog(hLog, XLL_PASS, "listen succeeded");
                    }
                }
                else {
                    xLog(hLog, XLL_PASS, "listen succeeded");
                }
            }
        }

        // Close the socket
        if (INVALID_SOCKET != nsSocket) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(listenRequest), (char *) &listenRequest);

            closesocket(nsSocket);
        }

        // Close the socket
        if (0 == (SOCKET_CLOSED & listenTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & listenTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & listenTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
listenTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests listen - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long           FromInAddr;
    // dwMessageType is the type of received message
    DWORD            dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD            dwMessageSize;
    // pMessage is a pointer to the received message
    char             *pMessage;
    // listenRequest is the request
    LISTEN_REQUEST   listenRequest;
    // listenComplete is the result
    LISTEN_COMPLETE  listenComplete;

    // psSockets is an array of socket
    SOCKET           psSockets[MAX_CONNECTIONS + 1];
    // nConnection is a counter to enumerate each connection
    int              nConnection;

    // remotename is the remote address
    SOCKADDR_IN      remotename;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&listenRequest, pMessage, sizeof(listenRequest));
        NetsyncFreeMessage(pMessage);

        for (nConnection = 0; nConnection < listenRequest.nNumConnections; nConnection++) {
            // Create the socket
            psSockets[nConnection] = INVALID_SOCKET;
            psSockets[nConnection] = socket(AF_INET, SOCK_STREAM, 0);
        
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(listenRequest.Port);
            connect(psSockets[nConnection], (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        listenComplete.dwMessageId = LISTEN_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(listenComplete), (char *) &listenComplete);

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the array of sockets
        for (nConnection = 0; nConnection < listenRequest.nNumConnections; nConnection++) {
            closesocket(psSockets[nConnection]);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\recvfrom.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  recvfrom.c

Abstract:

  This modules tests recvfrom

Author:

  Steven Kehrli (steveke) 13-Dev-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// recv messages

#define RECVFROM_REQUEST_MSG   NETSYNC_MSG_USER + 190 + 1
#define RECVFROM_CANCEL_MSG    NETSYNC_MSG_USER + 190 + 2
#define RECVFROM_COMPLETE_MSG  NETSYNC_MSG_USER + 190 + 3

typedef struct _RECVFROM_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bRemoteShutdown;
    BOOL     bRemoteClose;
    int      nDataBuffers;
    int      nBufferlen;
} RECVFROM_REQUEST, *PRECVFROM_REQUEST;

typedef struct _RECVFROM_COMPLETE {
    DWORD    dwMessageId;
} RECVFROM_COMPLETE, *PRECVFROM_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define BUFFER_10             0
#define BUFFER_LARGE          1
#define BUFFER_NULL           2
#define BUFFER_NULLZERO       3
#define BUFFER_ZERO           4
#define BUFFER_SMALL          5
#define BUFFER_TCPLARGE       6
#define BUFFER_UDPLARGE       7
#define BUFFER_UDPTOOLARGE    8
#define BUFFER_MULTI          9
#define BUFFER_SECOND        10
#define BUFFER_NONE          11

#define OVERLAPPED_IO_RESULT  1
#define OVERLAPPED_IO_EVENT   2



typedef struct RECVFROMBUFFER_TABLE {
    int   nBufferlen;
} RECVFROMBUFFER_TABLE, *PRECVFROMBUFFER_TABLE;

RECVFROMBUFFER_TABLE RecvFromBufferTcpTable[] = { { BUFFER_10_LEN       },
                                                  { 0                   },
                                                  { BUFFER_TCPLARGE_LEN } };
#define RecvFromBufferTcpTableCount  (sizeof(RecvFromBufferTcpTable) / sizeof(RECVFROMBUFFER_TABLE));

RECVFROMBUFFER_TABLE RecvFromBufferUdpTable[] = { { BUFFER_10_LEN       },
                                                  { 0                   },
                                                  { BUFFER_UDPLARGE_LEN } };
#define RecvFromBufferUdpTableCount  (sizeof(RecvFromBufferUdpTable) / sizeof(RECVFROMBUFFER_TABLE));



typedef struct RECVFROM_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the recvfrom
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    BOOL   bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL   bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL   bConnect;                                // bConnect indicates if the socket is connected
    BOOL   bRemoteShutdown;                         // bRemoteShutdown indicates if the remote shutsdown the connection
    BOOL   bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL   bShutdown;                               // bShutdown indicates if the connection is shutdown
    int    nShutdown;                               // nShutdown indicates how the connection is shutdown
    int    nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be received
    DWORD  dwBuffer;                                // dwBuffer specifies the recv buffer
    int    nBufferlen;                              // nBufferlen specifies the recvfrom data buffer length
    int    nFlags;                                  // nFlags specifies the recvfrom flags
    BOOL   bSecondRecv;                             // bSecondRecv indicates if a second recvfrom should occur
    BOOL   bname;                                   // bname indicates if the address buffer is used
    BOOL   bnamelen;                                // bnamelen indicates if namelen is used
    int    namelen;                                 // namelen is the length of the address buffer
    int    iReturnCode;                             // iReturnCode is the return code of recvfrom
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} RECVFROM_TABLE, *PRECVFROM_TABLE;

static RECVFROM_TABLE recvfromTable[] =
{
    { "19.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "19.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "19.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "19.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "19.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "19.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "19.7 Not Bound TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "19.8 Listening TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "19.9 Accepted TCP",               TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.10 Connected TCP",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.11 Second Receive TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN / 2,   0, TRUE,  FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.12 SD_RECEIVE Accept TCP",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.13 SD_SEND Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.14 SD_BOTH Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.15 SD_RECEIVE Connect TCP",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.16 SD_SEND Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.17 SD_BOTH Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.18 Shutdown Accept TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "19.19 Shutdown Connect TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "19.20 Close Accept TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "19.21 Close Connect TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "19.22 NULL Buffer TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.23 Neg Bufferlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, -1,                  0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.24 NULL 0 Bufferlen TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.25 0 Bufferlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, 0,                   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.26 Small Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN - 1,   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.27 Exact Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.28 Large Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_TCPLARGE_LEN, 0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.29 Switch Recv TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.30 Iterative Recv TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.31 flags != 0 TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       4, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.32 NULL addr TCP",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.33 addr TCP",                  TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.34 Large addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "19.35 Exact addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.36 Small addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN) - 1, 0,            WSAEFAULT,         TRUE  },
    { "19.37 Zero addrlen TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  0,                       0,            WSAEFAULT,         TRUE  },
    { "19.38 Neg addrlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  -1,                      0,            WSAEFAULT,         TRUE  },
    { "19.39 NULL addrlen TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   FALSE, 0,                       0,            WSAEFAULT,         TRUE  },
    { "19.40 Not Bound NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "19.41 Listening NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "19.42 Accepted NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.43 Connected NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.44 Second Receive NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, TRUE,  FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.45 SD_RECEIVE Accept NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.46 SD_SEND Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.47 SD_BOTH Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.48 SD_RECEIVE Connect NB TCP", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.49 SD_SEND Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.50 SD_BOTH Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.51 Shutdown Accept NB TCP",    FALSE, TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "19.52 Shutdown Connect NB TCP",   FALSE, TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "19.53 Close Accept NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "19.54 Close Connect NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "19.55 NULL Buffer NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.56 Neg Bufferlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, -1,                  0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.57 NULL 0 Bufferlen NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.58 0 Bufferlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, 0,                   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.59 Small Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN - 1,   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.60 Exact Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.61 Large Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_TCPLARGE_LEN, 0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.62 Switch Recv NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.63 Iterative Recv NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.64 flags != 0 NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       4, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.65 NULL addr NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.66 addr NB TCP",               TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.67 Large addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "19.68 Exact addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.69 Small addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN) - 1, 0,            WSAEFAULT,         TRUE  },
    { "19.70 Zero addrlen NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  0,                       0,            WSAEFAULT,         TRUE  },
    { "19.71 Neg addrlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  -1,                      0,            WSAEFAULT,         TRUE  },
    { "19.72 NULL addrlen NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   FALSE, 0,                       0,            WSAEFAULT,         TRUE  },
    { "19.73 Not Bound UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "19.74 Not Connected UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.75 Connected UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.76 SD_RECEIVE Conn UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.77 SD_SEND Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.78 SD_BOTH Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.79 Second Receive UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN / 2,   0, TRUE,  FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "19.80 NULL Buffer UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.81 Neg Bufferlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, -1,                  0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.82 NULL 0 Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.83 0 Bufferlen UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, 0,                   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.84 Small Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN - 1,   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "19.85 Exact Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.86 Large Buffer UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN, 0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.87 Switch Recv UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.88 Iterative Recv UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.89 flags != 0 UDP",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       4, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.90 NULL addr UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.91 Not Connect addr UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.92 Connected addr UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.93 Large addrlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "19.94 Exact addrlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.95 Small addrlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.96 Zero addrlen UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.97 Neg addrlen UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.98 NULL addrlen UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.99 Not Bound NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "19.100 Not Connected NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.101 Connected NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.102 SD_RECEIVE Conn NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.103 SD_SEND Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.104 SD_BOTH Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "19.105 Second Receive NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN / 2,   0, TRUE,  FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "19.106 NULL Buffer NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.107 Neg Bufferlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, -1,                  0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.108 NULL 0 Bufferlen NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.109 0 Bufferlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, 0,                   0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.110 Small Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN - 1,   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "19.111 Exact Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.112 Large Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN, 0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.113 Switch Recv NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.114 Iterative Recv NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  FALSE, 0,                       0,            0,                 FALSE },
    { "19.115 flags != 0 NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       4, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.116 NULL addr NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, FALSE,  TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.117 Not Connect addr NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.118 Connected addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.119 Large addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "19.120 Exact addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "19.121 Small addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.122 Zero addrlen NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.123 Neg addrlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   TRUE,  -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.124 NULL addrlen NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_10_LEN,       0, FALSE, TRUE,   FALSE, 0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "19.125 Closed Socket TCP",        TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "19.126 Closed Socket UDP",        TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "19.127 Not Initialized",          FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,  0,                   0, FALSE, FALSE,  FALSE, 0,                       SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define recvfromTableCount (sizeof(recvfromTable) / sizeof(RECVFROM_TABLE))

NETSYNC_TYPE_THREAD  recvfromTestSessionNt =
{
    1,
    recvfromTableCount,
    L"xnetapi_nt.dll",
    "recvfromTestServer"
};

NETSYNC_TYPE_THREAD  recvfromTestSessionXbox =
{
    1,
    recvfromTableCount,
    L"xnetapi_xbox.dll",
    "recvfromTestServer"
};



VOID
recvfromTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests recvfrom - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // recvfromRequest is the request sent to the server
    RECVFROM_REQUEST       recvfromRequest;

    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // timeout is the timeout for select
    timeval                fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                   RecvBuffer10[BUFFER_10_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // dwFillBuffer is a counter to fill the buffers
    DWORD                  dwFillBuffer;
    // nBytes is the number of bytes sent
    int                    nBytes;
    // nRecvCount is a counter to enumerate each recv
    int                    nRecvCount;

    // dwFirstTime is the first tick count
    DWORD                  dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                  dwSecondTime;

    // RecvFromBufferTable is the test buffer table to use for iterative recvfrom
    PRECVFROMBUFFER_TABLE  RecvFromBufferTable;
    // RecvFromBufferTableCount is the number of elements within the test buffer table
    size_t                 RecvFromBufferTableCount;
    // namelen is the size of the address buffer
    int                    namelen;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "recvfrom v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_recvfrom+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_recvfrom-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = recvfromTestSessionXbox;
    }
    else {
        NetsyncTypeSession = recvfromTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < recvfromTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, recvfromTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, recvfromTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != recvfromTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, recvfromTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == recvfromTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != recvfromTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == recvfromTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = recvfromTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == recvfromTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == recvfromTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == recvfromTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == recvfromTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == recvfromTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == recvfromTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & recvfromTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & recvfromTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == recvfromTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == recvfromTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == recvfromTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
            RecvFromBufferTable = RecvFromBufferTcpTable;
            RecvFromBufferTableCount = RecvFromBufferTcpTableCount;
        }
        else {
            RecvFromBufferTable = RecvFromBufferUdpTable;
            RecvFromBufferTableCount = RecvFromBufferUdpTableCount;
        }

        if ((TRUE == recvfromTable[dwTableIndex].bAccept) || (TRUE == recvfromTable[dwTableIndex].bConnect) || (0 == recvfromTable[dwTableIndex].iReturnCode)) {
            // Initialize the recvfrom request
            recvfromRequest.dwMessageId = RECVFROM_REQUEST_MSG;
            if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
                recvfromRequest.nSocketType = SOCK_STREAM;
            }
            else {
                recvfromRequest.nSocketType = SOCK_DGRAM;
            }
            recvfromRequest.Port = CurrentPort;
            recvfromRequest.bServerAccept = recvfromTable[dwTableIndex].bConnect;
            recvfromRequest.bRemoteShutdown = recvfromTable[dwTableIndex].bRemoteShutdown;
            recvfromRequest.bRemoteClose = recvfromTable[dwTableIndex].bRemoteClose;
            if (100 == recvfromTable[dwTableIndex].nDataBuffers) {
                recvfromRequest.nDataBuffers = recvfromTable[dwTableIndex].nDataBuffers * RecvFromBufferTableCount;
            }
            else {
                recvfromRequest.nDataBuffers = ((0 == recvfromTable[dwTableIndex].iReturnCode) || (WSAEMSGSIZE == recvfromTable[dwTableIndex].iLastError)) ? recvfromTable[dwTableIndex].nDataBuffers : 0;
            }
            if (TRUE == recvfromTable[dwTableIndex].bSecondRecv) {
                recvfromRequest.nBufferlen = recvfromTable[dwTableIndex].nBufferlen * 2;
            }
            else if (((0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) || (WSAEMSGSIZE == recvfromTable[dwTableIndex].iLastError)) && (BUFFER_10_LEN > recvfromTable[dwTableIndex].nBufferlen)) {
                recvfromRequest.nBufferlen = BUFFER_10_LEN;
            }
            else {
                recvfromRequest.nBufferlen = recvfromTable[dwTableIndex].nBufferlen;
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvfromRequest), (char *) &recvfromRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == recvfromTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

                if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else if (TRUE == recvfromTable[dwTableIndex].bAccept) {
                if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvfromRequest), (char *) &recvfromRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == recvfromTable[dwTableIndex].bRemoteShutdown) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (0 != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }

            if (TRUE == recvfromTable[dwTableIndex].bRemoteClose) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Shutdown the connection
        if (TRUE == recvfromTable[dwTableIndex].bShutdown) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, recvfromTable[dwTableIndex].nShutdown);
        }

        // Zero the receive buffer
        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);
        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
        }

        // Initialize the remote name
        namelen = recvfromTable[dwTableIndex].namelen;
        ZeroMemory(&remotename, sizeof(remotename));

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & recvfromTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        // Get the current tick count
        dwFirstTime = GetTickCount();

        __try {
            // Call recvfrom
            iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != recvfromTable[dwTableIndex].dwBuffer) ? RecvBufferLarge : NULL, recvfromTable[dwTableIndex].nBufferlen, recvfromTable[dwTableIndex].nFlags, (TRUE == recvfromTable[dwTableIndex].bname) ? (SOCKADDR *) &remotename : NULL, (TRUE == recvfromTable[dwTableIndex].bnamelen) ? &namelen : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == recvfromTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "recvfrom RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "recvfrom caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if ((TRUE == bNonblocking) && (FALSE == recvfromTable[dwTableIndex].bRemoteShutdown) && ((0 == recvfromTable[dwTableIndex].iReturnCode) || (WSAEMSGSIZE == recvfromTable[dwTableIndex].iLastError))) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recvfrom returned non-SOCKET_ERROR");
                    bTestPassed = FALSE;
                }
                else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "recvfrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "recvfrom iLastError - OUT: %u", WSAGetLastError());

                    FD_ZERO(&readfds);
                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);

                    // Call recvfrom
                    iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != recvfromTable[dwTableIndex].dwBuffer) ? RecvBufferLarge : NULL, recvfromTable[dwTableIndex].nBufferlen, recvfromTable[dwTableIndex].nFlags, (TRUE == recvfromTable[dwTableIndex].bname) ? (SOCKADDR *) &remotename : NULL, (TRUE == recvfromTable[dwTableIndex].bnamelen) ? &namelen : NULL);
                }
            }

            // Get the current tick count
            dwSecondTime = GetTickCount();

            if (TRUE == recvfromTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "recvfrom did not RIP");
            }

            if (TRUE == recvfromTable[dwTableIndex].bRemoteShutdown) {
                if (SOCKET_ERROR == iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                }
                else if (0 != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recvfrom iReturnCode - EXPECTED: %u; RECEIVED: %u", 0, iReturnCode);
                }
                else {
                    xLog(hLog, XLL_PASS, "recvfrom succeeded");
                }
            }
            else if (WSAEMSGSIZE == recvfromTable[dwTableIndex].iLastError) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recvfrom returned non-SOCKET_ERROR");
                }
                else if (WSAEMSGSIZE != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "recvfrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEMSGSIZE, WSAGetLastError());
                }
                else {
                    iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != recvfromTable[dwTableIndex].dwBuffer) ? RecvBufferLarge : NULL, recvfromTable[dwTableIndex].nBufferlen, recvfromTable[dwTableIndex].nFlags, NULL, NULL);

                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "recvfrom returned non-SOCKET_ERROR");
                    }
                    else if (((TRUE == bNonblocking) && (WSAEWOULDBLOCK != WSAGetLastError())) || ((FALSE == bNonblocking) && (WSAETIMEDOUT != WSAGetLastError()))) {
                        xLog(hLog, XLL_FAIL, "recvfrom iLastError - EXPECTED: %u; RECEIVED: %u", (TRUE == bNonblocking) ? WSAEWOULDBLOCK : WSAETIMEDOUT, WSAGetLastError());
                    }
                    else {
                        xLog(hLog, XLL_PASS, "recvfrom succeeded");
                    }
                }
            }
            else if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == recvfromTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != recvfromTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "recvfrom iLastError - EXPECTED: %u; RECEIVED: %u", recvfromTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "recvfrom iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (1 < recvfromRequest.nDataBuffers) {
                    // Send the recvfrom cancel
                    recvfromRequest.dwMessageId = RECVFROM_CANCEL_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvfromRequest), (char *) &recvfromRequest);
                }
            }
            else if (SOCKET_ERROR == recvfromTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "recvfrom returned non-SOCKET_ERROR");
            }
            else {
                if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                    xLog(hLog, XLL_FAIL, "recvfrom nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                    bTestPassed = FALSE;
                }

                if (TRUE == recvfromTable[dwTableIndex].bname) {
                    if (AF_INET != remotename.sin_family) {
                        xLog(hLog, XLL_FAIL, "recvfrom sin_family - EXPECTED: %d; RECEIVED: %d", AF_INET, remotename.sin_family);
                        bTestPassed = FALSE;
                    }

                    if (htons(CurrentPort) != remotename.sin_port) {
                        xLog(hLog, XLL_FAIL, "recvfrom sin_port - EXPECTED: %d; RECEIVED: %d", htons(CurrentPort), remotename.sin_port);
                        bTestPassed = FALSE;
                    }

                    if (NetsyncInAddr != remotename.sin_addr.s_addr) {
                        xLog(hLog, XLL_FAIL, "recvfrom sin_addr - EXPECTED: %u; RECEIVED: %u", NetsyncInAddr, remotename.sin_addr.s_addr);
                        bTestPassed = FALSE;
                    }
                }

                if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
                    nBytes = iReturnCode;

                    if (TRUE == recvfromTable[dwTableIndex].bSecondRecv) {
                        if (recvfromTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recvfrom return value - EXPECTED: %d; RECEIVED: %d", recvfromTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, recvfromTable[dwTableIndex].nBufferlen)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }

                        iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], recvfromTable[dwTableIndex].nBufferlen, recvfromTable[dwTableIndex].nFlags, NULL, NULL);

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            if (recvfromTable[dwTableIndex].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recvfrom return value - EXPECTED: %d; RECEIVED: %d", recvfromTable[dwTableIndex].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(&SendBufferLarge[nBytes], &RecvBufferLarge[nBytes], recvfromTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }

                            nBytes += iReturnCode;
                        }
                    }

                    if (BUFFER_10_LEN <= recvfromTable[dwTableIndex].nBufferlen) {
                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                            if (1 == iReturnCode) {
                                iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], recvfromTable[dwTableIndex].nBufferlen, 0, NULL, NULL);

                                if (SOCKET_ERROR != iReturnCode) {
                                    nBytes += iReturnCode;
                                }
                            }
                        } while (0 != iReturnCode);
                    }

                    iReturnCode = nBytes;
                }

                if ((recvfromTable[dwTableIndex].nBufferlen * ((TRUE == recvfromTable[dwTableIndex].bSecondRecv) ? 2 : 1)) != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "recvfrom return value - EXPECTED: %d; RECEIVED: %d", (recvfromTable[dwTableIndex].nBufferlen * ((TRUE == recvfromTable[dwTableIndex].bSecondRecv) ? 2 : 1)), iReturnCode);
                    bTestPassed = FALSE;
                }
                else {
                    if (0 != strncmp(SendBufferLarge, RecvBufferLarge, recvfromTable[dwTableIndex].nBufferlen * ((TRUE == recvfromTable[dwTableIndex].bSecondRecv) ? 2 : 1))) {
                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                        bTestPassed = FALSE;
                    }
                }

                if (3 == recvfromTable[dwTableIndex].nDataBuffers) {
                    // Zero the receive buffer
                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvfromRequest), (char *) &recvfromRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call recvfrom
                    iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, recvfromTable[dwTableIndex].nBufferlen, recvfromTable[dwTableIndex].nFlags, NULL, NULL);

                    if (TRUE == bNonblocking) {
                        if (SOCKET_ERROR != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recvfrom returned non-SOCKET_ERROR");
                            bTestPassed = FALSE;
                        }
                        else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "recvfrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "recvfrom iLastError - OUT: %u", WSAGetLastError());

                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                            select(0, &readfds, NULL, NULL, NULL);

                            // Call recvfrom
                            iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, recvfromTable[dwTableIndex].nBufferlen, recvfromTable[dwTableIndex].nFlags, NULL, NULL);
                        }
                    }

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        recvfromRequest.dwMessageId = RECVFROM_CANCEL_MSG;
                    }
                    else {
                        if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
                            nBytes = iReturnCode;

                            do {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                if (1 == iReturnCode) {
                                    iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], recvfromTable[dwTableIndex].nBufferlen, 0, NULL, NULL);

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                }
                            } while (0 != iReturnCode);

                            iReturnCode = nBytes;
                        }

                        if (recvfromTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recvfrom return value - EXPECTED: %d; RECEIVED: %d", recvfromTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else {
                            if (0 != strncmp(SendBufferLarge, RecvBufferLarge, recvfromTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }

                        recvfromRequest.dwMessageId = RECVFROM_REQUEST_MSG;
                    }

                    // Zero the receive buffer
                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 3, 3);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvfromRequest), (char *) &recvfromRequest);

                    if (RECVFROM_CANCEL_MSG != recvfromRequest.dwMessageId) {
                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        // Switch the blocking mode
                        Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                        ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                        bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                        // Call recvfrom
                        iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, recvfromTable[dwTableIndex].nBufferlen, recvfromTable[dwTableIndex].nFlags, NULL, NULL);

                        if (TRUE == bNonblocking) {
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recvfrom returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "recvfrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "recvfrom iLastError - OUT: %u", WSAGetLastError());

                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);

                                // Call recvfrom
                                iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, recvfromTable[dwTableIndex].nBufferlen, recvfromTable[dwTableIndex].nFlags, NULL, NULL);
                            }
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
                                nBytes = iReturnCode;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], recvfromTable[dwTableIndex].nBufferlen, 0, NULL, NULL);

                                        if (SOCKET_ERROR != iReturnCode) {
                                            nBytes += iReturnCode;
                                        }
                                    }
                                } while (0 != iReturnCode);

                                iReturnCode = nBytes;
                            }

                            if (recvfromTable[dwTableIndex].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recvfrom return value - EXPECTED: %d; RECEIVED: %d", recvfromTable[dwTableIndex].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else {
                                if (0 != strncmp(SendBufferLarge, RecvBufferLarge, recvfromTable[dwTableIndex].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }
                else if (100 == recvfromTable[dwTableIndex].nDataBuffers) {
                    for (nRecvCount = 0; nRecvCount < (int) (recvfromTable[dwTableIndex].nDataBuffers * RecvFromBufferTableCount); nRecvCount++) {
                        // Zero the receive buffer
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 2 + nRecvCount, 2 + nRecvCount);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }

                        xLog(hLog, XLL_INFO, "Iteration %d", nRecvCount);

                        // Send the recvfrom request
                        recvfromRequest.nBufferlen = RecvFromBufferTable[nRecvCount % RecvFromBufferTableCount].nBufferlen;
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvfromRequest), (char *) &recvfromRequest);

                        if (RECVFROM_CANCEL_MSG == recvfromRequest.dwMessageId) {
                            break;
                        }

                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        if ((0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) && (0 == RecvFromBufferTable[nRecvCount % RecvFromBufferTableCount].nBufferlen)) {
                            iReturnCode = 0;
                        }
                        else {
                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            // Call recvfrom
                            iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, RecvFromBufferTable[nRecvCount % RecvFromBufferTableCount].nBufferlen, 0, NULL, NULL);
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            recvfromRequest.dwMessageId = RECVFROM_CANCEL_MSG;
                            bTestPassed = FALSE;
                        }
                        else {
                            if (0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) {
                                nBytes = iReturnCode;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], RecvFromBufferTable[nRecvCount % RecvFromBufferTableCount].nBufferlen, 0, NULL, NULL);

                                        if (SOCKET_ERROR != iReturnCode) {
                                            nBytes += iReturnCode;
                                        }
                                    }
                                } while (0 != iReturnCode);

                                iReturnCode = nBytes;
                            }

                            if (RecvFromBufferTable[nRecvCount % RecvFromBufferTableCount].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recvfrom return value - EXPECTED: %d; RECEIVED: %d", RecvFromBufferTable[nRecvCount % RecvFromBufferTableCount].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else {
                                if (0 != strncmp(SendBufferLarge, RecvBufferLarge, RecvFromBufferTable[nRecvCount % RecvFromBufferTableCount].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "recvfrom succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (recvfromTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == recvfromTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            bNonblocking = recvfromTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == recvfromTable[dwTableIndex].bAccept) || (TRUE == recvfromTable[dwTableIndex].bConnect) || (0 == recvfromTable[dwTableIndex].iReturnCode)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(recvfromRequest), (char *) &recvfromRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & recvfromTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & recvfromTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & recvfromTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
recvfromTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests recv - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long             FromInAddr;
    // dwMessageType is the type of received message
    DWORD              dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD              dwMessageSize;
    // pMessage is a pointer to the received message
    char               *pMessage;
    // recvfromRequest is the request
    RECVFROM_REQUEST   recvfromRequest;
    // recvfromComplete is the result
    RECVFROM_COMPLETE  recvfromComplete;

    // sSocket is the socket descriptor
    SOCKET             sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET             nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL               bNagle = FALSE;

    // localname is the local address
    SOCKADDR_IN        localname;
    // remotename is the remote address
    SOCKADDR_IN        remotename;

    // SendBuffer10 is the send buffer
    char               SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char               SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // dwFillBuffer is a counter to fill the buffers
    DWORD              dwFillBuffer;
    // nSendCount is a counter to enumerate each send
    int                nSendCount;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&recvfromRequest, pMessage, sizeof(recvfromRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, recvfromRequest.nSocketType, 0);

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == recvfromRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(recvfromRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == recvfromRequest.nSocketType) && (TRUE == recvfromRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(recvfromRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        recvfromComplete.dwMessageId = RECVFROM_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvfromComplete), (char *) &recvfromComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == recvfromRequest.nSocketType) && (TRUE == recvfromRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == recvfromRequest.bRemoteShutdown) {
            // Shutdown the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
            }
        }

        if (TRUE == recvfromRequest.bRemoteClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
                closesocket(nsSocket);
                nsSocket = INVALID_SOCKET;
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
                sSocket = INVALID_SOCKET;
            }
        }

        // Send the complete
        recvfromComplete.dwMessageId = RECVFROM_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvfromComplete), (char *) &recvfromComplete);

        if (0 < recvfromRequest.nDataBuffers) {
            // Sleep
            Sleep(SLEEP_MIDLOW_TIME);

            // Initialize the buffer
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
            }

            // Send the buffer
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, recvfromRequest.nBufferlen, 0);

            if (3 == recvfromRequest.nDataBuffers) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                
                if (RECVFROM_CANCEL_MSG != ((PRECVFROM_REQUEST) pMessage)->dwMessageId) {
                    // Send the complete
                    recvfromComplete.dwMessageId = RECVFROM_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvfromComplete), (char *) &recvfromComplete);

                    // Sleep
                    Sleep(SLEEP_MIDLOW_TIME);

                    // Initialize the buffer
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                    }

                    // Send the buffer
                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, recvfromRequest.nBufferlen, 0);

                    NetsyncFreeMessage(pMessage);

                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if (RECVFROM_CANCEL_MSG != ((PRECVFROM_REQUEST) pMessage)->dwMessageId) {
                        // Send the complete
                        recvfromComplete.dwMessageId = RECVFROM_COMPLETE_MSG;
                        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvfromComplete), (char *) &recvfromComplete);

                        // Sleep
                        Sleep(SLEEP_MIDLOW_TIME);

                        // Initialize the buffer
                        sprintf(SendBuffer10, "%05d%05d", 3, 3);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                        }

                        // Send the buffer
                        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, recvfromRequest.nBufferlen, 0);
                    }
                }

                NetsyncFreeMessage(pMessage);
            }
            else if (100 <= recvfromRequest.nDataBuffers) {
                for (nSendCount = 0; nSendCount < recvfromRequest.nDataBuffers; nSendCount++) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if (RECVFROM_CANCEL_MSG == ((PRECVFROM_REQUEST) pMessage)->dwMessageId) {
                        NetsyncFreeMessage(pMessage);
                        break;
                    }

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2 + nSendCount, 2 + nSendCount);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                    }

                    // Send the buffer
                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, ((PRECVFROM_REQUEST) pMessage)->nBufferlen, 0);

                    NetsyncFreeMessage(pMessage);

                    // Send the complete
                    recvfromComplete.dwMessageId = RECVFROM_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(recvfromComplete), (char *) &recvfromComplete);
                }
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\ntohs.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  ntohs.c

Abstract:

  This modules tests ntohs

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _NTOHS_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    u_short  netshort;                                // u_short in network byte order
    u_short  hostshort;                               // u_short in host byte order
    BOOL     bRIP;                                    // Specifies a RIP test case
} NTOHS_TABLE, *PNTOHS_TABLE;

static NTOHS_TABLE ntohsTable[] =
{
    { "4.1 0x0000", 0x0000, 0x0000, FALSE },
    { "4.2 0x7FFF", 0x7FFF, 0xFF7F, FALSE },
    { "4.3 0x3040", 0x3040, 0x4030, FALSE },
    { "4.4 0xABCD", 0xABCD, 0xCDAB, FALSE },
    { "4.5 0xABCD", 0xABCD, 0xCDAB, FALSE },
    { "4.6 0xAAAA", 0xAAAA, 0xAAAA, FALSE },
    { "4.7 0x00FF", 0x00FF, 0xFF00, FALSE }
};

#define ntohsTableCount (sizeof(ntohsTable) / sizeof(NTOHS_TABLE))



VOID
ntohsTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests ntohs

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD    dwTableIndex;

    // hostshort is the returned value in host byte order
    u_short  hostshort;

    // bException indicates if an exception occurred
    BOOL     bException;



    // Set the function name
    xSetFunctionName(hLog, "ntohs");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_ntohs+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_ntohs-");

    for (dwTableIndex = 0; dwTableIndex < ntohsTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, ntohsTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, ntohsTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != ntohsTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, ntohsTable[dwTableIndex].szVariationName);

        bException = FALSE;

        __try {
            // Call ntohs
            hostshort = ntohs(ntohsTable[dwTableIndex].netshort);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == ntohsTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "ntohs RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "ntohs caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == ntohsTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "ntohs did not RIP");
            }

            if (hostshort != ntohsTable[dwTableIndex].hostshort) {
                xLog(hLog, XLL_FAIL, "EXPECTED: 0x%04x; RECEIVED: 0x%04x", ntohsTable[dwTableIndex].hostshort, hostshort);
            }
            else {
                xLog(hLog, XLL_PASS, "OUT: 0x%04x", hostshort);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\send.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  send.c

Abstract:

  This modules tests send

Author:

  Steven Kehrli (steveke) 28-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// send messages

#define SEND_REQUEST_MSG   NETSYNC_MSG_USER + 130 + 1
#define SEND_CANCEL_MSG    NETSYNC_MSG_USER + 130 + 2
#define SEND_COMPLETE_MSG  NETSYNC_MSG_USER + 130 + 3

typedef struct _SEND_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bFillQueue;
    INT      nQueueLen;
    BOOL     bRemoteClose;
    int      nDataBuffers;
    int      nBufferlen;
} SEND_REQUEST, *PSEND_REQUEST;

typedef struct _SEND_COMPLETE {
    DWORD    dwMessageId;
} SEND_COMPLETE, *PSEND_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define BUFFER_10             0
#define BUFFER_LARGE          1
#define BUFFER_NULL           2
#define BUFFER_NULLZERO       3
#define BUFFER_ZERO           4
#define BUFFER_SMALL          5
#define BUFFER_TCPLARGE       6
#define BUFFER_UDPLARGE       7
#define BUFFER_UDPTOOLARGE    8
#define BUFFER_TCPMULTI       9
#define BUFFER_UDPMULTI      10
#define BUFFER_NONE          11

#define OVERLAPPED_IO_RESULT  1
#define OVERLAPPED_IO_EVENT   2



typedef struct SENDBUFFER_TABLE {
    DWORD  dwBuffer;
    int    nBufferlen;
} SENDBUFFER_TABLE, *PSENDBUFFER_TABLE;

SENDBUFFER_TABLE SendBufferTcpTable[] = { { BUFFER_10,    BUFFER_10_LEN       },
                                          { BUFFER_NULL,  0                   },
                                          { BUFFER_LARGE, BUFFER_TCPLARGE_LEN } };

#define SendBufferTcpTableCount  (sizeof(SendBufferTcpTable) / sizeof(SENDBUFFER_TABLE));

SENDBUFFER_TABLE SendBufferUdpTable[] = { { BUFFER_10,    BUFFER_10_LEN       },
                                          { BUFFER_NULL,  0                   },
                                          { BUFFER_LARGE, BUFFER_UDPLARGE_LEN } };

#define SendBufferUdpTableCount  (sizeof(SendBufferUdpTable) / sizeof(SENDBUFFER_TABLE));



typedef struct SEND_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the send
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    BOOL   bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL   bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL   bConnect;                                // bConnect indicates if the socket is connected
    BOOL   bFillQueue;                              // bFillQueue indicates if the buffer should be filled
    BOOL   bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL   bShutdown;                               // bShutdown indicates if the connection is shutdown
    int    nShutdown;                               // nShutdown indicates how the connection is shutdown
    int    nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be sent
    DWORD  dwBuffer;                                // dwBuffer specifies the send buffer
    int    nBufferlen;                              // nBufferlen specifies the send data buffer length
    int    nFlags;                                  // nFlags specifies the send flags
    int    iReturnCode;                             // iReturnCode is the return code of send
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} SEND_TABLE, *PSEND_TABLE;

static SEND_TABLE sendTable[] =
{
    { "13.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "13.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "13.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "13.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "13.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "13.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "13.7 Not Bound TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "13.8 Listening TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "13.9 Accepted TCP",               TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.10 Connected TCP",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.11 Fill Queue TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.12 SD_RECEIVE Accept TCP",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.13 SD_SEND Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.14 SD_BOTH Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.15 SD_RECEIVE Connect TCP",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.16 SD_SEND Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.17 SD_BOTH Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.18 Close Accept TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "13.19 Close Connect TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "13.20 NULL Buffer TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  BUFFER_10_LEN,           0, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.21 Neg Bufferlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    -1,                      0, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.22 NULL 0 Bufferlen TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, 0,            0,                 FALSE },
    { "13.23 0 Bufferlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    0,                       0, 0,            0,                 FALSE },
    { "13.24 Small Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN - 1,       0, 0,            0,                 FALSE },
    { "13.25 Exact Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.26 Large Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_TCPLARGE_LEN,     0, 0,            0,                 FALSE },
    { "13.27 Switch Send TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.28 Iterative Send TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.29 flags != 0 TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           4, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.30 Not Bound NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "13.31 Listening NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "13.32 Accepted NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.33 Connected NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.34 Fill Queue NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.35 SD_RECEIVE Accept NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.36 SD_SEND Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.37 SD_BOTH Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.38 SD_RECEIVE Connect NB TCP", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.39 SD_SEND Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.40 SD_BOTH Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.41 Close Accept NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "13.42 Close Connect NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "13.43 NULL Buffer NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  BUFFER_10_LEN,           0, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.44 Neg Bufferlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    -1,                      0, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.45 NULL 0 Bufferlen NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, 0,            0,                 FALSE },
    { "13.46 0 Bufferlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    0,                       0, 0,            0,                 FALSE },
    { "13.47 Small Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN - 1,       0, 0,            0,                 FALSE },
    { "13.48 Exact Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.49 Large Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_TCPLARGE_LEN,     0, 0,            0,                 FALSE },
    { "13.50 Switch Send NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.51 Iterative Send NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.52 flags != 0 NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           4, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.53 Not Bound UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "13.54 Not Connected UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "13.55 Connected UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.56 SD_RECEIVE Conn UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.57 SD_SEND Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.58 SD_BOTH Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.59 NULL Buffer UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  BUFFER_10_LEN,           0, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.60 Neg Bufferlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    -1,                      0, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.61 NULL 0 Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, 0,            0,                 FALSE },
    { "13.62 0 Bufferlen UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    0,                       0, 0,            0,                 FALSE },
    { "13.63 Small Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN - 1,       0, 0,            0,                 FALSE },
    { "13.64 Exact Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.65 Large Buffer UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN,     0, 0,            0,                 FALSE },
    { "13.66 Too Large Buffer UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN + 1, 0, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "13.67 Switch Send UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.68 Iterative Send UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.69 flags != 0 UDP",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           4, SOCKET_ERROR, WSAEFAULT,         TRUE },
    { "13.70 Not Bound NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "13.71 Not Connected NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "13.72 Connected NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.73 SD_RECEIVE Conn NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.74 SD_SEND Conn NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.75 SD_BOTH Conn NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "13.76 NULL Buffer NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  BUFFER_10_LEN,           0, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.77 Neg Bufferlen NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    -1,                      0, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.78 NULL 0 Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, 0,            0,                 FALSE },
    { "13.79 0 Bufferlen NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    0,                       0, 0,            0,                 FALSE },
    { "13.80 Small Bufferlen NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN - 1,       0, 0,            0,                 FALSE },
    { "13.81 Exact Bufferlen NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.82 Large Buffer NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN,     0, 0,            0,                 FALSE },
    { "13.83 Too Large Buffer NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN + 1, 0, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "13.84 Switch Send NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.85 Iterative Send NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,    BUFFER_10_LEN,           0, 0,            0,                 FALSE },
    { "13.86 flags != 0 NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           4, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "13.87 Closed Socket TCP",         TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "13.88 Closed Socket UDP",         TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "13.89 Not Initialized",           FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define sendTableCount (sizeof(sendTable) / sizeof(SEND_TABLE))

NETSYNC_TYPE_THREAD  sendTestSessionNt =
{
    1,
    sendTableCount,
    L"xnetapi_nt.dll",
    "sendTestServer"
};

NETSYNC_TYPE_THREAD  sendTestSessionXbox =
{
    1,
    sendTableCount,
    L"xnetapi_xbox.dll",
    "sendTestServer"
};



VOID
sendTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests send - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // sendRequest is the request sent to the server
    SEND_REQUEST           sendRequest;

    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                  dwBufferSize = 1;
    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // timeout is the timeout for select
    timeval                fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // Buffer is a pointer to the buffer
    char                   *Buffer;
    // dwFillBuffer is a counter to fill the buffers
    DWORD                  dwFillBuffer;
    // nBytes is the number of bytes sent
    int                    nBytes;
    // nSendCount is a counter to enumerate each send/recv
    int                    nSendCount;

    // SendBufferTable is the test buffer table to use for iterative send
    PSENDBUFFER_TABLE      SendBufferTable;
    // SendBufferTableCount is the number of elements within the test buffer table
    size_t                 SendBufferTableCount;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "send v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_send+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_send-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = sendTestSessionXbox;
    }
    else {
        NetsyncTypeSession = sendTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < sendTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, sendTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, sendTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != sendTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, sendTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == sendTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != sendTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == sendTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = sendTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == sendTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == sendTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == sendTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == sendTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == sendTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == sendTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & sendTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        if (TRUE == sendTable[dwTableIndex].bFillQueue) {
            // Set the buffer size
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & sendTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == sendTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == sendTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == sendTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
            SendBufferTable = SendBufferTcpTable;
            SendBufferTableCount = SendBufferTcpTableCount;
        }
        else {
            SendBufferTable = SendBufferUdpTable;
            SendBufferTableCount = SendBufferUdpTableCount;
        }

        if ((TRUE == sendTable[dwTableIndex].bAccept) || (TRUE == sendTable[dwTableIndex].bConnect)) {
            // Initialize the send request
            sendRequest.dwMessageId = SEND_REQUEST_MSG;
            if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
                sendRequest.nSocketType = SOCK_STREAM;
            }
            else {
                sendRequest.nSocketType = SOCK_DGRAM;
            }
            sendRequest.Port = CurrentPort;
            sendRequest.bServerAccept = sendTable[dwTableIndex].bConnect;
            sendRequest.bFillQueue = sendTable[dwTableIndex].bFillQueue;
            sendRequest.nQueueLen = 0;
            sendRequest.bRemoteClose = sendTable[dwTableIndex].bRemoteClose;
            if (100 == sendTable[dwTableIndex].nDataBuffers) {
                sendRequest.nDataBuffers = sendTable[dwTableIndex].nDataBuffers * SendBufferTableCount;
            }
            else {
                sendRequest.nDataBuffers = (0 == sendTable[dwTableIndex].iReturnCode) ? sendTable[dwTableIndex].nDataBuffers : 0;
            }
            sendRequest.nBufferlen = sendTable[dwTableIndex].nBufferlen;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == sendTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

                if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else {
                if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == sendTable[dwTableIndex].bFillQueue) {
                if (FALSE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                // Fill the queue
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                    sendRequest.nQueueLen++;
                    Sleep(SLEEP_ZERO_TIME);
                }
            }

            if (TRUE == sendTable[dwTableIndex].bRemoteClose) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Shutdown the connection
        if (TRUE == sendTable[dwTableIndex].bShutdown) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, sendTable[dwTableIndex].nShutdown);
        }

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);
        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
        }
        if (BUFFER_10 == sendTable[dwTableIndex].dwBuffer) {
            Buffer = SendBuffer10;
        }
        else if (BUFFER_LARGE == sendTable[dwTableIndex].dwBuffer) {
            Buffer = SendBufferLarge;
        }
        else {
            Buffer = NULL;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & sendTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call send
            iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, sendTable[dwTableIndex].nBufferlen, sendTable[dwTableIndex].nFlags);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == sendTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "send RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "send caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == sendTable[dwTableIndex].bFillQueue) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "send returned non-SOCKET_ERROR");
                }
                else {
                    // Get the last error code
                    iLastError = WSAGetLastError();

                    if (iLastError != WSAEWOULDBLOCK) {
                        xLog(hLog, XLL_FAIL, "send iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                    }
                }

                // Send the read request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);

                // Wait for the read complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                if (FALSE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
                else {
                    FD_ZERO(&writefds);
                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }

                // Call send
                iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, sendTable[dwTableIndex].nBufferlen, sendTable[dwTableIndex].nFlags);
            }

            if (TRUE == sendTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "send did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == sendTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != sendTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "send iLastError - EXPECTED: %u; RECEIVED: %u", sendTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "send iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "send returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (0 != sendRequest.nDataBuffers) {
                    // Send the send cancel
                    sendRequest.dwMessageId = SEND_CANCEL_MSG;
                    sendRequest.nDataBuffers = 0;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);
                }
            }
            else if (SOCKET_ERROR == sendTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "send returned non-SOCKET_ERROR");
            }
            else {
                if (sendTable[dwTableIndex].nBufferlen != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "send return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, iReturnCode);
                    bTestPassed = FALSE;
                }

                // Send the read request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);

                // Wait for the read complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                if ((TRUE != sendTable[dwTableIndex].bFillQueue) && (TRUE != sendTable[dwTableIndex].bShutdown)) {
                    // Call recv
                    if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
                        if (0 != sendTable[dwTableIndex].nBufferlen) {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                            nBytes = 0;

                            do {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                if (1 == iReturnCode) {
                                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                }
                                else if (0 == iReturnCode) {
                                    iReturnCode = SOCKET_ERROR;
                                    SetLastError(WSAETIMEDOUT);
                                }

                                if (SOCKET_ERROR != iReturnCode) {
                                    nBytes += iReturnCode;
                                }
                            } while (SOCKET_ERROR != iReturnCode);

                            if (WSAETIMEDOUT != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (sendTable[dwTableIndex].nBufferlen != nBytes) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, nBytes);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, sendTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                    else {
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        if (TRUE == bNonblocking) {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                            select(0, &readfds, NULL, NULL, NULL);
                        }

                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else if (sendTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, sendTable[dwTableIndex].nBufferlen)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (3 == sendTable[dwTableIndex].nDataBuffers) {
                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }
                    if (BUFFER_10 == sendTable[dwTableIndex].dwBuffer) {
                        Buffer = SendBuffer10;
                    }
                    else if (BUFFER_LARGE == sendTable[dwTableIndex].dwBuffer) {
                        Buffer = SendBufferLarge;
                    }
                    else {
                        Buffer = NULL;
                    }

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call send
                    iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, sendTable[dwTableIndex].nBufferlen, sendTable[dwTableIndex].nFlags);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "send returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        sendRequest.dwMessageId = SEND_CANCEL_MSG;
                    }
                    else {
                        if (sendTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "send return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }

                        sendRequest.dwMessageId = SEND_REQUEST_MSG;
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (SOCKET_ERROR != iReturnCode) {
                        // Call recv
                        if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
                            if (0 != sendTable[dwTableIndex].nBufferlen) {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                    }
                                    else if (0 == iReturnCode) {
                                        iReturnCode = SOCKET_ERROR;
                                        SetLastError(WSAETIMEDOUT);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while (SOCKET_ERROR != iReturnCode);

                                if (WSAETIMEDOUT != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (sendTable[dwTableIndex].nBufferlen != nBytes) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, nBytes);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, sendTable[dwTableIndex].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                        else {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (sendTable[dwTableIndex].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, sendTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 3, 3);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }
                    if (BUFFER_10 == sendTable[dwTableIndex].dwBuffer) {
                        Buffer = SendBuffer10;
                    }
                    else if (BUFFER_LARGE == sendTable[dwTableIndex].dwBuffer) {
                        Buffer = SendBufferLarge;
                    }
                    else {
                        Buffer = NULL;
                    }

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call send
                    iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, sendTable[dwTableIndex].nBufferlen, sendTable[dwTableIndex].nFlags);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "send returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        sendRequest.dwMessageId = SEND_CANCEL_MSG;
                    }
                    else {
                        if (sendTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "send return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }

                        sendRequest.dwMessageId = SEND_REQUEST_MSG;
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (SOCKET_ERROR != iReturnCode) {
                        // Call recv
                        if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
                            if (0 != sendTable[dwTableIndex].nBufferlen) {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                    }
                                    else if (0 == iReturnCode) {
                                        iReturnCode = SOCKET_ERROR;
                                        SetLastError(WSAETIMEDOUT);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while (SOCKET_ERROR != iReturnCode);

                                if (WSAETIMEDOUT != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (sendTable[dwTableIndex].nBufferlen != nBytes) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, nBytes);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, sendTable[dwTableIndex].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                        else {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (sendTable[dwTableIndex].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendTable[dwTableIndex].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, sendTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }
                else if (100 == sendTable[dwTableIndex].nDataBuffers) {
                    for (nSendCount = 0; nSendCount < (int) (sendTable[dwTableIndex].nDataBuffers * SendBufferTableCount); nSendCount++) {
                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 2 + nSendCount, 2 + nSendCount);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }
                        if (BUFFER_LARGE == SendBufferTable[nSendCount % SendBufferTableCount].dwBuffer) {
                            Buffer = SendBufferLarge;
                        }
                        else if (BUFFER_10 == SendBufferTable[nSendCount % SendBufferTableCount].dwBuffer) {
                            Buffer = SendBuffer10;
                        }
                        else {
                            Buffer = NULL;
                        }

                        xLog(hLog, XLL_INFO, "Iteration %d", nSendCount);

                        // Call send
                        iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen, 0);

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "send returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                            sendRequest.dwMessageId = SEND_CANCEL_MSG;
                        }
                        else {
                            if (SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "send return value - EXPECTED: %d; RECEIVED: %d", SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }

                            sendRequest.dwMessageId = SEND_REQUEST_MSG;
                        }

                        // Send the read request
                        sendRequest.nBufferlen = SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen;
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);

                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        if (SOCKET_ERROR != iReturnCode) {
                            // Call recv
                            if (0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) {
                                if (0 != SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen) {
                                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                    nBytes = 0;

                                    do {
                                        FD_ZERO(&readfds);
                                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                        iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                        if (1 == iReturnCode) {
                                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                        }
                                        else if (0 == iReturnCode) {
                                            iReturnCode = SOCKET_ERROR;
                                            SetLastError(WSAETIMEDOUT);
                                        }

                                        if (SOCKET_ERROR != iReturnCode) {
                                            nBytes += iReturnCode;
                                        }
                                    } while (SOCKET_ERROR != iReturnCode);

                                    if (WSAETIMEDOUT != WSAGetLastError()) {
                                        xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                        bTestPassed = FALSE;
                                    }
                                    else if (SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen != nBytes) {
                                        xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen, nBytes);
                                        bTestPassed = FALSE;
                                    }
                                    else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen)) {
                                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                        bTestPassed = FALSE;
                                    }
                                }
                            }
                            else {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                                if (TRUE == bNonblocking) {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                    select(0, &readfds, NULL, NULL, NULL);
                                }

                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
                                if (SOCKET_ERROR == iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen, iReturnCode);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, SendBufferTable[nSendCount % SendBufferTableCount].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "send succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (sendTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == sendTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            bNonblocking = sendTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == sendTable[dwTableIndex].bAccept) || (TRUE == sendTable[dwTableIndex].bConnect)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendRequest), (char *) &sendRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & sendTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & sendTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & sendTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
sendTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests send - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long         FromInAddr;
    // dwMessageType is the type of received message
    DWORD          dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD          dwMessageSize;
    // pMessage is a pointer to the received message
    char           *pMessage;
    // sendRequest is the request
    SEND_REQUEST   sendRequest;
    // sendComplete is the result
    SEND_COMPLETE  sendComplete;

    // sSocket is the socket descriptor
    SOCKET         sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET         nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD          dwBufferSize = 1;
    // iTimeout is the send and receive timeout value for the socket
    int            iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL           bNagle = FALSE;
    // nQueueLen is the size of the queue
    int            nQueueLen;

    // localname is the local address
    SOCKADDR_IN    localname;
    // remotename is the remote address
    SOCKADDR_IN    remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set         readfds;
    // timeout is the timeout for select
    timeval        fdstimeout = { 1, 0 };

    // SendBufferLarge is the large send buffer
    char           SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // nBytes is the number of bytes sent/received
    int            nBytes;
    // nSendCount is a counter to enumerate each send
    int            nSendCount;

    // iReturnCode is the return code of the operation
    int            iReturnCode;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&sendRequest, pMessage, sizeof(sendRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, sendRequest.nSocketType, 0);

        if (TRUE == sendRequest.bFillQueue) {
            // Set the buffer size
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == sendRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(sendRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == sendRequest.nSocketType) && (TRUE == sendRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(sendRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        sendComplete.dwMessageId = SEND_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendComplete), (char *) &sendComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == sendRequest.nSocketType) && (TRUE == sendRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == sendRequest.bRemoteClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
                closesocket(nsSocket);
                nsSocket = INVALID_SOCKET;
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
                sSocket = INVALID_SOCKET;
            }
        }

        // Send the complete
        sendComplete.dwMessageId = SEND_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendComplete), (char *) &sendComplete);

        if (TRUE == sendRequest.bFillQueue) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            nQueueLen = ((PSEND_REQUEST) pMessage)->nQueueLen;
            CopyMemory(&sendRequest, pMessage, sizeof(sendRequest));
            NetsyncFreeMessage(pMessage);

            if (SEND_CANCEL_MSG != sendRequest.dwMessageId) {
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                for (nSendCount = 0; nSendCount < nQueueLen; nSendCount++) {
                    recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0);
                }
            }

            // Send the complete
            sendComplete.dwMessageId = SEND_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendComplete), (char *) &sendComplete);
        }

        if (0 < sendRequest.nDataBuffers) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            CopyMemory(&sendRequest, pMessage, sizeof(sendRequest));
            NetsyncFreeMessage(pMessage);

            if ((SEND_CANCEL_MSG != sendRequest.dwMessageId) && ((0 != sendRequest.nBufferlen) || (SOCK_STREAM != sendRequest.nSocketType))) {
                if (SOCK_DGRAM == sendRequest.nSocketType) {
                    ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));

                    if (SOCKET_ERROR != recv(sSocket, SendBufferLarge, sizeof(SendBufferLarge), 0)) {
                        send(sSocket, SendBufferLarge, strlen(SendBufferLarge), 0);
                    }
                }
                else {
                    ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                    nBytes = 0;

                    do {
                        FD_ZERO(&readfds);
                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                        iReturnCode = SOCKET_ERROR;
                        if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], BUFFER_10_LEN, 0);
                        }

                        if (SOCKET_ERROR != iReturnCode) {
                            nBytes += iReturnCode;
                        }
                    } while ((SOCKET_ERROR != iReturnCode) && (nBytes < sendRequest.nBufferlen));

                    if (nBytes == sendRequest.nBufferlen) {
                        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                    }
                }
            }

            // Send the complete
            sendComplete.dwMessageId = SEND_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendComplete), (char *) &sendComplete);

            if (3 == sendRequest.nDataBuffers) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                if (SEND_CANCEL_MSG != ((PSEND_REQUEST) pMessage)->dwMessageId) {
                    if (SOCK_DGRAM == sendRequest.nSocketType) {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));

                        if (SOCKET_ERROR != recv(sSocket, SendBufferLarge, sizeof(SendBufferLarge), 0)) {
                            send(sSocket, SendBufferLarge, strlen(SendBufferLarge), 0);
                        }
                    }
                    else {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        nBytes = 0;

                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = SOCKET_ERROR;
                            if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], BUFFER_10_LEN, 0);
                            }

                            if (SOCKET_ERROR != iReturnCode) {
                                nBytes += iReturnCode;
                            }
                        } while ((SOCKET_ERROR != iReturnCode) && (nBytes < sendRequest.nBufferlen));

                        if (nBytes == sendRequest.nBufferlen) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                        }
                    }
                }
                NetsyncFreeMessage(pMessage);

                // Send the complete
                sendComplete.dwMessageId = SEND_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendComplete), (char *) &sendComplete);

                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                if (SEND_CANCEL_MSG != ((PSEND_REQUEST) pMessage)->dwMessageId) {
                    if (SOCK_DGRAM == sendRequest.nSocketType) {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));

                        if (SOCKET_ERROR != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0)) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0);
                        }
                    }
                    else {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        nBytes = 0;

                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = SOCKET_ERROR;
                            if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], BUFFER_10_LEN, 0);
                            }

                            if (SOCKET_ERROR != iReturnCode) {
                                nBytes += iReturnCode;
                            }
                        } while ((SOCKET_ERROR != iReturnCode) && (nBytes < sendRequest.nBufferlen));

                        if (nBytes == sendRequest.nBufferlen) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                        }
                    }
                }
                NetsyncFreeMessage(pMessage);

                // Send the complete
                sendComplete.dwMessageId = SEND_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendComplete), (char *) &sendComplete);
            }
            else if (100 <= sendRequest.nDataBuffers) {
                for (nSendCount = 0; nSendCount < sendRequest.nDataBuffers; nSendCount++) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if ((0 != ((PSEND_REQUEST) pMessage)->nBufferlen) || (SOCK_STREAM != sendRequest.nSocketType)) {
                        if (SEND_CANCEL_MSG != ((PSEND_REQUEST) pMessage)->dwMessageId) {
                            if (SOCK_DGRAM == sendRequest.nSocketType) {
                                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));

                                if (SOCKET_ERROR != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0)) {
                                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0);
                                }
                            }
                            else {
                                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = SOCKET_ERROR;
                                    if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while ((SOCKET_ERROR != iReturnCode) && (nBytes < ((PSEND_REQUEST) pMessage)->nBufferlen));

                                if (nBytes == ((PSEND_REQUEST) pMessage)->nBufferlen) {
                                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                                }
                            }
                        }
                    }
                    NetsyncFreeMessage(pMessage);

                    // Send the complete
                    sendComplete.dwMessageId = SEND_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendComplete), (char *) &sendComplete);
                }
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\server.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.c

Abstract:

  This modules contains the server side exports

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

#ifdef __cplusplus
extern "C" {
#endif

// Netsync export table for syncsrv

#pragma data_seg(NETSYNC_EXPORT_SECTION_NAME)
DECLARE_NETSYNC_EXPORT_DIRECTORY(xnetapi_xbox)
#pragma data_seg()

BEGIN_NETSYNC_EXPORT_TABLE(xnetapi_xbox)
    NETSYNC_EXPORT_TABLE_ENTRY("listenTestServer", listenTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("acceptTestServer", acceptTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("connectTestServer", connectTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("sendTestServer", sendTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("WSASendTestServer", WSASendTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("sendtoTestServer", sendtoTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("WSASendToTestServer", WSASendToTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("recvTestServer", recvTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("WSARecvTestServer", WSARecvTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("recvfromTestServer", recvfromTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("WSARecvFromTestServer", WSARecvFromTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("getsocknameTestServer", getsocknameTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("getpeernameTestServer", getpeernameTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("ioctlsocketTestServer", ioctlsocketTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("WSAGetOverlappedResultTestServer", WSAGetOverlappedResultTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("WSACancelOverlappedIOTestServer", WSACancelOverlappedIOTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("selectTestServer", selectTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("shutdownTestServer", shutdownTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("closesocketTestServer", closesocketTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("XNetRegisterKeyTestServer", XNetRegisterKeyTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("XNetUnregisterKeyTestServer", XNetUnregisterKeyTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("XNetXnAddrToInAddrTestServer", XNetXnAddrToInAddrTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("XNetInAddrToXnAddrTestServer", XNetInAddrToXnAddrTestServer)
END_NETSYNC_EXPORT_TABLE(xnetapi_xbox)

#ifdef __cplusplus
}
#endif

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\select.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  select.c

Abstract:

  This modules tests select

Author:

  Steven Kehrli (steveke) 25-Feb-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// select messages

#define SELECT_REQUEST_MSG   NETSYNC_MSG_USER + 260 + 1
#define SELECT_COMPLETE_MSG  NETSYNC_MSG_USER + 260 + 2

typedef struct _SELECT_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    int      nSockets;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bServerConnect;
    BOOL     bServerClose;
    BOOL     bServerSend;
    DWORD    dwWaitTime;
} SELECT_REQUEST, *PSELECT_REQUEST;

typedef struct _SELECT_COMPLETE {
    DWORD    dwMessageId;
} SELECT_COMPLETE, *PSELECT_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define FDSET_READ        0x00000001
#define FDSET_WRITE       0x00000002
#define FDSET_EXCEPT      0x00000004

#define FUNC_ACCEPT       0x00000001
#define FUNC_ACCEPT_FAIL  0x00000002
#define FUNC_READ         0x00000010
#define FUNC_READ_FAIL    0x00000020
#define FUNC_CLOSE        0x00000100
#define FUNC_CLOSE_FAIL   0x00000200
#define FUNC_CONNECT      0x00001000
#define FUNC_CONNECT_FAIL 0x00002000
#define FUNC_SEND         0x00010000
#define FUNC_SEND_FAIL    0x00020000

typedef struct SELECT_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket1;                               // dwSocket1 indicates the first socket to be created
    DWORD  dwSocket2;                               // dwSocket2 indicates the second socket to be created
    DWORD  dwAddSets;                               // dwAddSets specifies the fd_set structures to add the socket to
    DWORD  dwCheckSets;                             // dwCheckSets specifies the fd_set structures to check
    DWORD  dwFunction;                              // dwFunction specifies the function for select
    BOOL   bTimeout;                                // bTimeout indicates if the timeout is used
    long   tv_usec;                                 // timeout value, in micro-seconds
    int    iReturnCode;                             // iReturnCode is the return code of select
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} SELECT_TABLE, *PSELECT_TABLE;

static SELECT_TABLE selectTable[] =
{
    { "26.1 Not Initialized",             FALSE, FALSE, SOCKET_INVALID_SOCKET,       0,          0,                                       0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "26.2 r s = INT_MIN",               TRUE,  TRUE,  SOCKET_INT_MIN,              0,          FDSET_READ,                              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.3 r s = -1",                    TRUE,  TRUE,  SOCKET_NEG_ONE,              0,          FDSET_READ,                              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.4 r s = 0",                     TRUE,  TRUE,  SOCKET_ZERO,                 0,          FDSET_READ,                              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.5 r s = INT_MAX",               TRUE,  TRUE,  SOCKET_INT_MAX,              0,          FDSET_READ,                              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.6 r s = INVALID_SOCKET",        TRUE,  TRUE,  SOCKET_INVALID_SOCKET,       0,          FDSET_READ,                              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.7 w s = INT_MIN",               TRUE,  TRUE,  SOCKET_INT_MIN,              0,          FDSET_WRITE,                             0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.8 w s = -1",                    TRUE,  TRUE,  SOCKET_NEG_ONE,              0,          FDSET_WRITE,                             0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.9 w s = 0",                     TRUE,  TRUE,  SOCKET_ZERO,                 0,          FDSET_WRITE,                             0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.10 w s = INT_MAX",              TRUE,  TRUE,  SOCKET_INT_MAX,              0,          FDSET_WRITE,                             0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.11 w s = INVALID_SOCKET",       TRUE,  TRUE,  SOCKET_INVALID_SOCKET,       0,          FDSET_WRITE,                             0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.12 e s = INT_MIN",              TRUE,  TRUE,  SOCKET_INT_MIN,              0,          FDSET_EXCEPT,                            0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.13 e s = -1",                   TRUE,  TRUE,  SOCKET_NEG_ONE,              0,          FDSET_EXCEPT,                            0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.14 e s = 0",                    TRUE,  TRUE,  SOCKET_ZERO,                 0,          FDSET_EXCEPT,                            0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.15 e s = INT_MAX",              TRUE,  TRUE,  SOCKET_INT_MAX,              0,          FDSET_EXCEPT,                            0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.16 e s = INVALID_SOCKET",       TRUE,  TRUE,  SOCKET_INVALID_SOCKET,       0,          FDSET_EXCEPT,                            0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.17 rw s = INT_MIN",             TRUE,  TRUE,  SOCKET_INT_MIN,              0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.18 rw s = -1",                  TRUE,  TRUE,  SOCKET_NEG_ONE,              0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.19 rw s = 0",                   TRUE,  TRUE,  SOCKET_ZERO,                 0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.20 rw s = INT_MAX",             TRUE,  TRUE,  SOCKET_INT_MAX,              0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.21 rw s = INVALID_SOCKET",      TRUE,  TRUE,  SOCKET_INVALID_SOCKET,       0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.22 re s = INT_MIN",             TRUE,  TRUE,  SOCKET_INT_MIN,              0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.23 re s = -1",                  TRUE,  TRUE,  SOCKET_NEG_ONE,              0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.24 re s = 0",                   TRUE,  TRUE,  SOCKET_ZERO,                 0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.25 re s = INT_MAX",             TRUE,  TRUE,  SOCKET_INT_MAX,              0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.26 re s = INVALID_SOCKET",      TRUE,  TRUE,  SOCKET_INVALID_SOCKET,       0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.27 we s = INT_MIN",             TRUE,  TRUE,  SOCKET_INT_MIN,              0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.28 we s = -1",                  TRUE,  TRUE,  SOCKET_NEG_ONE,              0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.29 we s = 0",                   TRUE,  TRUE,  SOCKET_ZERO,                 0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.30 we s = INT_MAX",             TRUE,  TRUE,  SOCKET_INT_MAX,              0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.31 we s = INVALID_SOCKET",      TRUE,  TRUE,  SOCKET_INVALID_SOCKET,       0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.32 rwe s = INT_MIN",            TRUE,  TRUE,  SOCKET_INT_MIN,              0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.33 rwe s = -1",                 TRUE,  TRUE,  SOCKET_NEG_ONE,              0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.34 rwe s = 0",                  TRUE,  TRUE,  SOCKET_ZERO,                 0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.35 rwe s = INT_MAX",            TRUE,  TRUE,  SOCKET_INT_MAX,              0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.36 rwe s = INVALID_SOCKET",     TRUE,  TRUE,  SOCKET_INVALID_SOCKET,       0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.37 r0 none TCP",                TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              0,                                       0,                 TRUE,  0,                      0,            0,                 FALSE },
    { "26.38 rw0 none TCP",               TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 TRUE,  0,                      0,            0,                 FALSE },
    { "26.39 re0 none TCP",               TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 TRUE,  0,                      0,            0,                 FALSE },
    { "26.40 we0 none TCP",               TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 TRUE,  0,                      0,            0,                 FALSE },
    { "26.41 rwe0 none TCP",              TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 TRUE,  0,                      0,            0,                 FALSE },
    { "26.42 r0 none UDP",                TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ,                              0,                                       0,                 TRUE,  0,                      0,            0,                 FALSE },
    { "26.43 rw0 none UDP",               TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_WRITE,                             0,                 TRUE,  0,                      1,            0,                 FALSE },
    { "26.44 re0 none UDP",               TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 TRUE,  0,                      0,            0,                 FALSE },
    { "26.45 we0 none UDP",               TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             0,                 TRUE,  0,                      1,            0,                 FALSE },
    { "26.46 rwe0 none UDP",              TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_WRITE,                             0,                 TRUE,  0,                      1,            0,                 FALSE },
    { "26.47 r0 accept pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_ACCEPT,       TRUE,  0,                      1,            0,                 FALSE },
    { "26.48 r0 accept fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              0,                                       FUNC_ACCEPT_FAIL,  TRUE,  0,                      0,            0,                 FALSE },
    { "26.49 r5 accept pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_ACCEPT,       TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.50 r5 accept fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              0,                                       FUNC_ACCEPT_FAIL,  TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.51 rNULL accept pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_ACCEPT,       FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.52 rw0 accept pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_ACCEPT,       TRUE,  0,                      1,            0,                 FALSE },
    { "26.53 rw0 accept fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                0,                                       FUNC_ACCEPT_FAIL,  TRUE,  0,                      0,            0,                 FALSE },
    { "26.54 rw5 accept pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_ACCEPT,       TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.55 rw5 accept fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                0,                                       FUNC_ACCEPT_FAIL,  TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.56 rwNULL accept pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_ACCEPT,       FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.57 re0 accept pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_ACCEPT,       TRUE,  0,                      1,            0,                 FALSE },
    { "26.58 re0 accept fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_ACCEPT_FAIL,  TRUE,  0,                      0,            0,                 FALSE },
    { "26.59 re5 accept pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_ACCEPT,       TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.60 re5 accept fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_ACCEPT_FAIL,  TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.61 reNULL accept pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_ACCEPT,       FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.62 rwe0 accept pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_ACCEPT,       TRUE,  0,                      1,            0,                 FALSE },
    { "26.63 rwe0 accept fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_ACCEPT_FAIL,  TRUE,  0,                      0,            0,                 FALSE },
    { "26.64 rwe5 accept pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_ACCEPT,       TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.65 rwe5 accept fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_ACCEPT_FAIL,  TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.66 rweNULL accept pass TCP",    TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_ACCEPT,       FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.67 r0 read pass TCP",           TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_READ,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.68 r0 read fail TCP",           TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.69 r5 read pass TCP",           TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.70 r5 read fail TCP",           TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.71 rNULL read pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.72 rw0 read pass TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_READ,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.73 rw0 read fail TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.74 rw5 read pass TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.75 rw5 read fail TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.76 rwNULL read pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.77 re0 read pass TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.78 re0 read fail TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.79 re5 read pass TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.80 re5 read fail TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.81 reNULL read pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.82 rwe0 read pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_READ,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.83 rwe0 read fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.84 rwe5 read pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.85 rwe5 read fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.86 rweNULL read pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.87 r0 read pass UDP",           TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_READ,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.88 r0 read fail UDP",           TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ,                              0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.89 r5 read pass UDP",           TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.90 r5 read fail UDP",           TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ,                              0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.91 rNULL read pass UDP",        TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.92 re0 read pass UDP",          TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.93 re0 read fail UDP",          TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.94 re5 read pass UDP",          TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.95 re5 read fail UDP",          TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.96 reNULL read pass UDP",       TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.97 r0 close pass TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_CLOSE,        TRUE,  0,                      1,            0,                 FALSE },
    { "26.98 r0 close fail TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              0,                                       FUNC_CLOSE_FAIL,   TRUE,  0,                      0,            0,                 FALSE },
    { "26.99 r5 close pass TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_CLOSE,        TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.100 r5 close fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              0,                                       FUNC_CLOSE_FAIL,   TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.101 rNULL close pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ,                              FDSET_READ,                              FUNC_CLOSE,        FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.102 rw0 close pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        TRUE,  0,                      2,            0,                 FALSE },
    { "26.103 rw0 close fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                0,                                       FUNC_CLOSE_FAIL,   TRUE,  0,                      0,            0,                 FALSE },
    { "26.104 rw5 close pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.105 rw5 close fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                0,                                       FUNC_CLOSE_FAIL,   TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.106 rwNULL close pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE,                FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.107 re0 close pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_CLOSE,        TRUE,  0,                      1,            0,                 FALSE },
    { "26.108 re0 close fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_CLOSE_FAIL,   TRUE,  0,                      0,            0,                 FALSE },
    { "26.109 re5 close pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_CLOSE,        TRUE,  SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.110 re5 close fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_CLOSE_FAIL,   TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.111 reNULL close pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_CLOSE,        FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.112 rwe0 close pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        TRUE,  0,                      2,            0,                 FALSE },
    { "26.113 rwe0 close fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_CLOSE_FAIL,   TRUE,  0,                      0,            0,                 FALSE },
    { "26.114 rwe5 close pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.115 rwe5 close fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_CLOSE_FAIL,   TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.116 rweNULL close pass TCP",    TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.117 wNULL conn pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE,                             FDSET_WRITE,                             FUNC_CONNECT,      FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.118 wrNULL conn pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_CONNECT,      FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.119 weNULL conn pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_CONNECT,      FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.120 wreNULL conn pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_CONNECT,      FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.121 w0 send pass TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE,                             FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.122 w0 send fail TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE,                             0,                                       FUNC_SEND_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.123 w5 send fail TCP",          TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE,                             0,                                       FUNC_SEND_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.124 wNULL send pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE,                             FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.125 wr0 send pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.126 wr0 send fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ,                0,                                       FUNC_SEND_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.127 wr5 send fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ,                0,                                       FUNC_SEND_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.128 wrNULL send pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.129 we0 send pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.130 we0 send fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       FUNC_SEND_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.131 we5 send fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       FUNC_SEND_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.132 weNULL send pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.133 wre0 send pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.134 wre0 send fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, 0,                                       FUNC_SEND_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.135 wre5 send fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, 0,                                       FUNC_SEND_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.136 wreNULL send pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.137 w0 send pass UDP",          TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE,                             FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.138 wNULL send pass UDP",       TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE,                             FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.139 wr0 send pass UDP",         TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.140 wrNULL send pass UDP",      TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.141 we0 send pass UDP",         TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.142 weNULL send pass UDP",      TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.143 wre0 send pass UDP",        TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      1,            0,                 FALSE },
    { "26.144 wreNULL send pass UDP",     TRUE,  TRUE,  SOCKET_UDP,                  0,          FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.145 eNULL conn fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_EXCEPT,                            FDSET_EXCEPT,                            FUNC_CONNECT_FAIL, FALSE, SLEEP_MEAN_TIME * 1000, 1,            0,                 FALSE },
    { "26.146 erNULL conn fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_EXCEPT | FDSET_READ,               FDSET_EXCEPT | FDSET_READ,               FUNC_CONNECT_FAIL, FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.147 ewNULL conn fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_EXCEPT | FDSET_WRITE,              FDSET_EXCEPT | FDSET_WRITE,              FUNC_CONNECT_FAIL, FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.148 erwNULL conn fail TCP",     TRUE,  TRUE,  SOCKET_TCP,                  0,          FDSET_EXCEPT | FDSET_READ | FDSET_WRITE, FDSET_EXCEPT | FDSET_READ | FDSET_WRITE, FUNC_CONNECT_FAIL, FALSE, SLEEP_MEAN_TIME * 1000, 3,            0,                 FALSE },
    { "26.149 2r0 accept pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_ACCEPT,       TRUE,  0,                      2,            0,                 FALSE },
    { "26.150 2r0 accept fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              0,                                       FUNC_ACCEPT_FAIL,  TRUE,  0,                      0,            0,                 FALSE },
    { "26.151 2r5 accept pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_ACCEPT,       TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.152 2r5 accept fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              0,                                       FUNC_ACCEPT_FAIL,  TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.153 2rNULL accept pass TCP",    TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_ACCEPT,       FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.154 2rw0 accept pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_ACCEPT,       TRUE,  0,                      2,            0,                 FALSE },
    { "26.155 2rw0 accept fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                0,                                       FUNC_ACCEPT_FAIL,  TRUE,  0,                      0,            0,                 FALSE },
    { "26.156 2rw5 accept pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_ACCEPT,       TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.157 2rw5 accept fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                0,                                       FUNC_ACCEPT_FAIL,  TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.158 2rwNULL accept pass TCP",   TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_ACCEPT,       FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.159 2re0 accept pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_ACCEPT,       TRUE,  0,                      2,            0,                 FALSE },
    { "26.160 2re0 accept fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_ACCEPT_FAIL,  TRUE,  0,                      0,            0,                 FALSE },
    { "26.161 2re5 accept pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_ACCEPT,       TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.162 2re5 accept fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_ACCEPT_FAIL,  TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.163 2reNULL accept pass TCP",   TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_ACCEPT,       FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.164 2rwe0 accept pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_ACCEPT,       TRUE,  0,                      2,            0,                 FALSE },
    { "26.165 2rwe0 accept fail TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_ACCEPT_FAIL,  TRUE,  0,                      0,            0,                 FALSE },
    { "26.166 2rwe5 accept pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_ACCEPT,       TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.167 2rwe5 accept fail TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_ACCEPT_FAIL,  TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.168 2rweNULL accept pass TCP",  TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_ACCEPT,       FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.169 2r0 read pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_READ,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.170 2r0 read fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.171 2r5 read pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.172 2r5 read fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.173 2rNULL read pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.174 2rw0 read pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_READ,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.175 2rw0 read fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.176 2rw5 read pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.177 2rw5 read fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.178 2rwNULL read pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.179 2re0 read pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.180 2re0 read fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.181 2re5 read pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.182 2re5 read fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.183 2reNULL read pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.184 2rwe0 read pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_READ,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.185 2rwe0 read fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.186 2rwe5 read pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.187 2rwe5 read fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.188 2rweNULL read pass TCP",    TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.189 2r0 read pass UDP",         TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ,                              FDSET_READ,                              FUNC_READ,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.190 2r0 read fail UDP",         TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ,                              0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.191 2r5 read pass UDP",         TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ,                              FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.192 2r5 read fail UDP",         TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ,                              0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.193 2rNULL read pass UDP",      TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ,                              FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.194 2re0 read pass UDP",        TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.195 2re0 read fail UDP",        TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_READ_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.196 2re5 read pass UDP",        TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.197 2re5 read fail UDP",        TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_READ_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.198 2reNULL read pass UDP",     TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_READ,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.199 2r0 close pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_CLOSE,        TRUE,  0,                      2,            0,                 FALSE },
    { "26.200 2r0 close fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              0,                                       FUNC_CLOSE_FAIL,   TRUE,  0,                      0,            0,                 FALSE },
    { "26.201 2r5 close pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_CLOSE,        TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.202 2r5 close fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              0,                                       FUNC_CLOSE_FAIL,   TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.203 2rNULL close pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ,                              FDSET_READ,                              FUNC_CLOSE,        FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.204 2rw0 close pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        TRUE,  0,                      4,            0,                 FALSE },
    { "26.205 2rw0 close fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                0,                                       FUNC_CLOSE_FAIL,   TRUE,  0,                      0,            0,                 FALSE },
    { "26.206 2rw5 close pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        TRUE,  SLEEP_MEAN_TIME * 1000, 4,            0,                 FALSE },
    { "26.207 2rw5 close fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                0,                                       FUNC_CLOSE_FAIL,   TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.208 2rwNULL close pass TCP",    TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE,                FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        FALSE, SLEEP_MEAN_TIME * 1000, 4,            0,                 FALSE },
    { "26.209 2re0 close pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_CLOSE,        TRUE,  0,                      2,            0,                 FALSE },
    { "26.210 2re0 close fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_CLOSE_FAIL,   TRUE,  0,                      0,            0,                 FALSE },
    { "26.211 2re5 close pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_CLOSE,        TRUE,  SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.212 2re5 close fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               0,                                       FUNC_CLOSE_FAIL,   TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.213 2reNULL close pass TCP",    TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_EXCEPT,               FDSET_READ,                              FUNC_CLOSE,        FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.214 2rwe0 close pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        TRUE,  0,                      4,            0,                 FALSE },
    { "26.215 2rwe0 close fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_CLOSE_FAIL,   TRUE,  0,                      0,            0,                 FALSE },
    { "26.216 2rwe5 close pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        TRUE,  SLEEP_MEAN_TIME * 1000, 4,            0,                 FALSE },
    { "26.217 2rwe5 close fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       FUNC_CLOSE_FAIL,   TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.218 2rweNULL close pass TCP",   TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, FDSET_READ | FDSET_WRITE,                FUNC_CLOSE,        FALSE, SLEEP_MEAN_TIME * 1000, 4,            0,                 FALSE },
    { "26.219 2wNULL conn pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE,                             FDSET_WRITE,                             FUNC_CONNECT,      FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.220 2wrNULL conn pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_CONNECT,      FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.221 2weNULL conn pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_CONNECT,      FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.222 2wreNULL conn pass TCP",    TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_CONNECT,      FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.223 2w0 send pass TCP",         TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE,                             FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.224 2w0 send fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE,                             0,                                       FUNC_SEND_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.225 2w5 send fail TCP",         TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE,                             0,                                       FUNC_SEND_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.226 2wNULL send pass TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE,                             FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.227 2wr0 send pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.228 2wr0 send fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ,                0,                                       FUNC_SEND_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.229 2wr5 send fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ,                0,                                       FUNC_SEND_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.230 2wrNULL send pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.231 2we0 send pass TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.232 2we0 send fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_EXCEPT,              0,                                       FUNC_SEND_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.233 2we5 send fail TCP",        TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_EXCEPT,              0,                                       FUNC_SEND_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.234 2weNULL send pass TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.235 2wre0 send pass TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.236 2wre0 send fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, 0,                                       FUNC_SEND_FAIL,    TRUE,  0,                      0,            0,                 FALSE },
    { "26.237 2wre5 send fail TCP",       TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, 0,                                       FUNC_SEND_FAIL,    TRUE,  SLEEP_MEAN_TIME * 1000, 0,            0,                 FALSE },
    { "26.238 2wreNULL send pass TCP",    TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.239 2w0 send pass UDP",         TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_WRITE,                             FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.240 2wNULL send pass UDP",      TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_WRITE,                             FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.241 2wr0 send pass UDP",        TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.242 2wrNULL send pass UDP",     TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_WRITE | FDSET_READ,                FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.243 2we0 send pass UDP",        TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.244 2weNULL send pass UDP",     TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_WRITE | FDSET_EXCEPT,              FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.245 2wre0 send pass UDP",       TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_SEND,         TRUE,  0,                      2,            0,                 FALSE },
    { "26.246 2wreNULL send pass UDP",    TRUE,  TRUE,  SOCKET_UDP,                  SOCKET_UDP, FDSET_WRITE | FDSET_READ | FDSET_EXCEPT, FDSET_WRITE,                             FUNC_SEND,         FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.247 2eNULL conn fail TCP",      TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_EXCEPT,                            FDSET_EXCEPT,                            FUNC_CONNECT_FAIL, FALSE, SLEEP_MEAN_TIME * 1000, 2,            0,                 FALSE },
    { "26.248 2erNULL conn fail TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_EXCEPT | FDSET_READ,               FDSET_EXCEPT | FDSET_READ,               FUNC_CONNECT_FAIL, FALSE, SLEEP_MEAN_TIME * 1000, 4,            0,                 FALSE },
    { "26.249 2ewNULL conn fail TCP",     TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_EXCEPT | FDSET_WRITE,              FDSET_EXCEPT | FDSET_WRITE,              FUNC_CONNECT_FAIL, FALSE, SLEEP_MEAN_TIME * 1000, 4,            0,                 FALSE },
    { "26.250 2erwNULL conn fail TCP",    TRUE,  TRUE,  SOCKET_TCP,                  SOCKET_TCP, FDSET_EXCEPT | FDSET_READ | FDSET_WRITE, FDSET_EXCEPT | FDSET_READ | FDSET_WRITE, FUNC_CONNECT_FAIL, FALSE, SLEEP_MEAN_TIME * 1000, 6,            0,                 FALSE },
    { "26.251 r Empty",                   TRUE,  TRUE,  0,                           0,          FDSET_READ,                              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "26.252 w Empty",                   TRUE,  TRUE,  0,                           0,          FDSET_WRITE,                             0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "26.253 e Empty",                   TRUE,  TRUE,  0,                           0,          FDSET_EXCEPT,                            0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "26.254 rw Empty",                  TRUE,  TRUE,  0,                           0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "26.255 re Empty",                  TRUE,  TRUE,  0,                           0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "26.256 we Empty",                  TRUE,  TRUE,  0,                           0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "26.257 rwe Empty",                 TRUE,  TRUE,  0,                           0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "26.258 NULL sets",                 TRUE,  TRUE,  0,                           0,          0,                                       0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "26.259 r Closed Socket TCP",       TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,  0,          FDSET_READ,                              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.260 r Closed Socket UDP",       TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,  0,          FDSET_READ,                              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.261 w Closed Socket TCP",       TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,  0,          FDSET_WRITE,                             0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.262 w Closed Socket UDP",       TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,  0,          FDSET_WRITE,                             0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.263 e Closed Socket TCP",       TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,  0,          FDSET_EXCEPT,                            0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.264 e Closed Socket UDP",       TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,  0,          FDSET_EXCEPT,                            0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.265 rw Closed Socket TCP",      TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,  0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.266 rw Closed Socket UDP",      TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,  0,          FDSET_READ | FDSET_WRITE,                0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.367 re Closed Socket TCP",      TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.268 re Closed Socket UDP",      TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,  0,          FDSET_READ | FDSET_EXCEPT,               0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.269 we Closed Socket TCP",      TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,  0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.270 we Closed Socket UDP",      TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,  0,          FDSET_WRITE | FDSET_EXCEPT,              0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.271 rwe Closed Socket TCP",     TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.272 rwe Closed Socket UDP",     TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,  0,          FDSET_READ | FDSET_WRITE | FDSET_EXCEPT, 0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "26.273 Not Initialized",           FALSE, FALSE, SOCKET_INVALID_SOCKET,       0,          0,                                       0,                                       0,                 FALSE, 0,                      SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define selectTableCount (sizeof(selectTable) / sizeof(SELECT_TABLE))

NETSYNC_TYPE_THREAD  selectTestSessionNt =
{
    1,
    selectTableCount * 2,
    L"xnetapi_nt.dll",
    "selectTestServer"
};

NETSYNC_TYPE_THREAD  selectTestSessionXbox =
{
    1,
    selectTableCount * 2,
    L"xnetapi_xbox.dll",
    "selectTestServer"
};



VOID
selectTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests select - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // selectRequest is the request sent to the server
    SELECT_REQUEST         selectRequest;
    
    // sSocket1 is the first socket descriptor
    SOCKET                 sSocket1;
    // sSocket2 is the second socket descriptor
    SOCKET                 sSocket2;
    // nsSocket1 is the first accepted socket descriptor
    SOCKET                 nsSocket1;
    // nsSocket2 is the second accepted socket descriptor
    SOCKET                 nsSocket2;

    // dwBufferSize is the send/receive buffer size
    DWORD                  dwBufferSize = 1;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname1 is the first local address
    SOCKADDR_IN            localname1;
    // localname2 is the second local address
    SOCKADDR_IN            localname2;
    // remotename1 is the first remote address
    SOCKADDR_IN            remotename1;
    // remotename2 is the second remote address
    SOCKADDR_IN            remotename2;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // exceptfds is the set of sockets to check for an except condition
    fd_set                 exceptfds;
    // timeout is the timeout for select
    timeval                fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                   RecvBuffer10[BUFFER_10_LEN + 1];

    // dwFirstTime is the first tick count
    DWORD                  dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                  dwSecondTime;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "select v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_select+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_select-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = selectTestSessionXbox;
    }
    else {
        NetsyncTypeSession = selectTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < selectTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, selectTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, selectTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != selectTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, selectTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == selectTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != selectTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == selectTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = selectTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == selectTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the sockets
        sSocket1 = INVALID_SOCKET;
        sSocket2 = INVALID_SOCKET;
        nsSocket1 = INVALID_SOCKET;
        nsSocket2 = INVALID_SOCKET;
        if (SOCKET_INT_MIN == selectTable[dwTableIndex].dwSocket1) {
            sSocket1 = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == selectTable[dwTableIndex].dwSocket1) {
            sSocket1 = -1;
        }
        else if (SOCKET_ZERO == selectTable[dwTableIndex].dwSocket1) {
            sSocket1 = 0;
        }
        else if (SOCKET_INT_MAX == selectTable[dwTableIndex].dwSocket1) {
            sSocket1 = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == selectTable[dwTableIndex].dwSocket1) {
            sSocket1 = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & selectTable[dwTableIndex].dwSocket1)) {
            sSocket1 = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & selectTable[dwTableIndex].dwSocket1)) {
            sSocket1 = socket(AF_INET, SOCK_DGRAM, 0);
        }

        sSocket2 = INVALID_SOCKET;
        if (SOCKET_TCP == selectTable[dwTableIndex].dwSocket2) {
            sSocket2 = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (SOCKET_UDP == selectTable[dwTableIndex].dwSocket2) {
            sSocket2 = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & selectTable[dwTableIndex].dwSocket1)) {
            setsockopt(sSocket1, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
            if (INVALID_SOCKET != sSocket1) {
                setsockopt(sSocket1, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
            }
        }

        if ((0 != (SOCKET_TCP & selectTable[dwTableIndex].dwSocket1)) || (0 != (SOCKET_UDP & selectTable[dwTableIndex].dwSocket1))) {
            // Set the buffer size
            dwBufferSize = 1;
            setsockopt(sSocket1, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            dwBufferSize = 1;
            setsockopt(sSocket1, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            if (INVALID_SOCKET != sSocket2) {
                dwBufferSize = 1;
                setsockopt(sSocket2, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

                dwBufferSize = 1;
                setsockopt(sSocket2, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            }

            // Set the socket to non-blocking mode
            Nonblock = 1;
            ioctlsocket(sSocket1, FIONBIO, &Nonblock);
            if (INVALID_SOCKET != sSocket2) {
                ioctlsocket(sSocket2, FIONBIO, &Nonblock);
            }

            // Bind the socket
            ZeroMemory(&localname1, sizeof(localname1));
            localname1.sin_family = AF_INET;
            localname1.sin_port = htons(CurrentPort);
            bind(sSocket1, (SOCKADDR *) &localname1, sizeof(localname1));

            if (INVALID_SOCKET != sSocket2) {
                ZeroMemory(&localname2, sizeof(localname2));
                localname2.sin_family = AF_INET;
                localname2.sin_port = htons(CurrentPort + 1);
                bind(sSocket2, (SOCKADDR *) &localname2, sizeof(localname2));
            }
        }

        // Listen
        if ((FUNC_ACCEPT == selectTable[dwTableIndex].dwFunction) || (FUNC_ACCEPT_FAIL == selectTable[dwTableIndex].dwFunction)) {
            listen(sSocket1, SOMAXCONN);

            if (INVALID_SOCKET != sSocket2) {
                listen(sSocket2, SOMAXCONN);
            }
        }

        // Setup the fdset structures
        FD_ZERO(&readfds);
        FD_ZERO(&writefds);
        FD_ZERO(&exceptfds);

        if (0 != selectTable[dwTableIndex].dwSocket1) {
            if (0 != (FDSET_READ & selectTable[dwTableIndex].dwAddSets)) {
                FD_SET(sSocket1, &readfds);

                if (INVALID_SOCKET != sSocket2) {
                    FD_SET(sSocket2, &readfds);
                }
            }

            if (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwAddSets)) {
                FD_SET(sSocket1, &writefds);

                if (INVALID_SOCKET != sSocket2) {
                    FD_SET(sSocket2, &writefds);
                }
            }

            if (0 != (FDSET_EXCEPT & selectTable[dwTableIndex].dwAddSets)) {
                FD_SET(sSocket1, &exceptfds);

                if (INVALID_SOCKET != sSocket2) {
                    FD_SET(sSocket2, &exceptfds);
                }
            }
        }

        // Setup the timeout
        fdstimeout.tv_sec = 0;
        fdstimeout.tv_usec = selectTable[dwTableIndex].tv_usec;

        if (0 != selectTable[dwTableIndex].dwFunction) {
            // Initialize the select request
            selectRequest.dwMessageId = SELECT_REQUEST_MSG;
            if (0 != (SOCKET_TCP & selectTable[dwTableIndex].dwSocket1)) {
                selectRequest.nSocketType = SOCK_STREAM;
            }
            else {
                selectRequest.nSocketType = SOCK_DGRAM;
            }
            if (INVALID_SOCKET != sSocket2) {
                selectRequest.nSockets = 2;
            }
            else {
                selectRequest.nSockets = 1;
            }
            selectRequest.Port = CurrentPort;

            selectRequest.bServerAccept = FALSE;
            selectRequest.bServerConnect = FALSE;
            selectRequest.bServerClose = FALSE;
            selectRequest.bServerSend = FALSE;
            if (FUNC_ACCEPT == selectTable[dwTableIndex].dwFunction) {
                selectRequest.bServerConnect = TRUE;
            }
            else if (FUNC_READ == selectTable[dwTableIndex].dwFunction) {
                selectRequest.bServerAccept = TRUE;
                selectRequest.bServerSend = TRUE;
            }
            else if (FUNC_READ_FAIL == selectTable[dwTableIndex].dwFunction) {
                selectRequest.bServerAccept = TRUE;
            }
            else if (FUNC_CLOSE == selectTable[dwTableIndex].dwFunction) {
                selectRequest.bServerAccept = TRUE;
                selectRequest.bServerClose = TRUE;
            }
            else if (FUNC_CLOSE_FAIL == selectTable[dwTableIndex].dwFunction) {
                selectRequest.bServerAccept = TRUE;
            }
            else if (FUNC_CONNECT == selectTable[dwTableIndex].dwFunction) {
                selectRequest.bServerAccept = TRUE;
            }
            else if (FUNC_SEND == selectTable[dwTableIndex].dwFunction) {
                selectRequest.bServerAccept = TRUE;
            }
            else if (FUNC_SEND_FAIL == selectTable[dwTableIndex].dwFunction) {
                selectRequest.bServerAccept = TRUE;
            }

            selectRequest.dwWaitTime = selectTable[dwTableIndex].tv_usec;

            // Send the select request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(selectRequest), (char *) &selectRequest);

            // Wait for the select complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        // Connect
        if ((0 != selectTable[dwTableIndex].dwFunction) && (FUNC_CONNECT != selectTable[dwTableIndex].dwFunction) && (FUNC_CONNECT_FAIL != selectTable[dwTableIndex].dwFunction) && (FUNC_ACCEPT != selectTable[dwTableIndex].dwFunction) && (FUNC_ACCEPT_FAIL != selectTable[dwTableIndex].dwFunction)) {
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = NetsyncInAddr;
            remotename1.sin_port = htons(CurrentPort);

            connect(sSocket1, (SOCKADDR *) &remotename1, sizeof(remotename1));

            if (INVALID_SOCKET != sSocket2) {
                ZeroMemory(&remotename2, sizeof(remotename2));
                remotename2.sin_family = AF_INET;
                remotename2.sin_addr.s_addr = NetsyncInAddr;
                remotename2.sin_port = htons(CurrentPort + 1);

                connect(sSocket2, (SOCKADDR *) &remotename2, sizeof(remotename2));
            }
        }

        // Fill the queue, if necessary
        if ((0 != (SOCKET_TCP & selectTable[dwTableIndex].dwSocket1)) && (FUNC_CONNECT != selectTable[dwTableIndex].dwFunction) && (FUNC_CONNECT_FAIL != selectTable[dwTableIndex].dwFunction) && (FUNC_ACCEPT != selectTable[dwTableIndex].dwFunction) && (FUNC_ACCEPT_FAIL != selectTable[dwTableIndex].dwFunction) && (FUNC_SEND != selectTable[dwTableIndex].dwFunction) && (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwAddSets))) {
            ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
            do {
                Sleep(SLEEP_ZERO_TIME);
            } while (SOCKET_ERROR != send(sSocket1, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0));

            if (INVALID_SOCKET != sSocket2) {
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send(sSocket2, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0));
            }
        }

        if (0 != selectTable[dwTableIndex].dwFunction) {
            // Send the select request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(selectRequest), (char *) &selectRequest);

            // Wait for the select complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Connect
        if ((FUNC_CONNECT == selectTable[dwTableIndex].dwFunction) || (FUNC_CONNECT_FAIL == selectTable[dwTableIndex].dwFunction)) {
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = NetsyncInAddr;
            remotename1.sin_port = htons(CurrentPort);

            connect(sSocket1, (SOCKADDR *) &remotename1, sizeof(remotename1));

            if (INVALID_SOCKET != sSocket2) {
                ZeroMemory(&remotename2, sizeof(remotename2));
                remotename2.sin_family = AF_INET;
                remotename2.sin_addr.s_addr = NetsyncInAddr;
                remotename2.sin_port = htons(CurrentPort + 1);

                connect(sSocket2, (SOCKADDR *) &remotename2, sizeof(remotename2));
            }
        }

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & selectTable[dwTableIndex].dwSocket1)) {
            closesocket(sSocket1);
        }

        // Get the current tick count
        dwFirstTime = GetTickCount();

        __try {
            // Call select
            iReturnCode = select(0, (0 != (FDSET_READ & selectTable[dwTableIndex].dwAddSets)) ? &readfds : NULL, (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwAddSets)) ? &writefds: NULL, (0 != (FDSET_EXCEPT & selectTable[dwTableIndex].dwAddSets)) ? &exceptfds: NULL, (TRUE == selectTable[dwTableIndex].bTimeout) ? &fdstimeout : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == selectTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "select RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "select caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            // Get the current tick count
            dwSecondTime = GetTickCount();

            if (TRUE == selectTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "select did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == selectTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != selectTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "select iLastError - EXPECTED: %u; RECEIVED: %u", selectTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "select iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "select returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == selectTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "select returned non-SOCKET_ERROR");
            }
            else {
                // Check elapsed time
                if (FUNC_SEND == selectTable[dwTableIndex].dwFunction) {
                    if ((dwSecondTime - dwFirstTime) > SLEEP_ZERO_TIME) {
                        xLog(hLog, XLL_FAIL, "select nTime - EXPECTED: %d; RECEIVED: %d", 0, dwSecondTime - dwFirstTime);
                        bTestPassed = FALSE;
                    }
                }
                else if (FALSE == selectTable[dwTableIndex].bTimeout) {
                    if ((FUNC_CONNECT != selectTable[dwTableIndex].dwFunction) && (FUNC_CONNECT_FAIL != selectTable[dwTableIndex].dwFunction)) {
                        if (((dwSecondTime - dwFirstTime) < (SLEEP_LOW_TIME + SLEEP_MEAN_TIME)) || ((dwSecondTime - dwFirstTime) > (SLEEP_HIGH_TIME + SLEEP_MEAN_TIME))) {
                            xLog(hLog, XLL_FAIL, "select nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                            bTestPassed = FALSE;
                        }
                    }
                }
                else {
                    if (0 == selectTable[dwTableIndex].tv_usec) {
                        if ((dwSecondTime - dwFirstTime) > SLEEP_ZERO_TIME) {
                            xLog(hLog, XLL_FAIL, "select nTime - EXPECTED: %d; RECEIVED: %d", 0, dwSecondTime - dwFirstTime);
                            bTestPassed = FALSE;
                        }
                    }
                    else if ((FUNC_CONNECT != selectTable[dwTableIndex].dwFunction) && (FUNC_CONNECT_FAIL != selectTable[dwTableIndex].dwFunction)) {
                        if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                            xLog(hLog, XLL_FAIL, "select nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                            bTestPassed = FALSE;
                        }
                    }
                }

                if ((0 != selectTable[dwTableIndex].dwCheckSets) && (0 != selectTable[dwTableIndex].dwFunction) && (FUNC_SEND != selectTable[dwTableIndex].dwFunction)) {
                    if (TRUE == selectTable[dwTableIndex].bTimeout) {
                        // Check fd sets
                        if (0 != FD_ISSET(sSocket1, &readfds)) {
                            xLog(hLog, XLL_FAIL, "select0: sSocket1 in readfds");
                            bTestPassed = FALSE;
                        }

                        if (0 != FD_ISSET(sSocket1, &writefds)) {
                            xLog(hLog, XLL_FAIL, "select0: sSocket1 in writefds");
                            bTestPassed = FALSE;
                        }

                        if (0 != FD_ISSET(sSocket1, &exceptfds)) {
                            xLog(hLog, XLL_FAIL, "select0: sSocket1 in exceptfds");
                            bTestPassed = FALSE;
                        }

                        if (0 != FD_ISSET(sSocket2, &readfds)) {
                            xLog(hLog, XLL_FAIL, "select0: sSocket2 in readfds");
                            bTestPassed = FALSE;
                        }

                        if (0 != FD_ISSET(sSocket2, &writefds)) {
                            xLog(hLog, XLL_FAIL, "select0: sSocket2 in writefds");
                            bTestPassed = FALSE;
                        }

                        if (0 != FD_ISSET(sSocket2, &exceptfds)) {
                            xLog(hLog, XLL_FAIL, "select0: sSocket2 in exceptfds");
                            bTestPassed = FALSE;
                        }
                    }

                    do {
                        // Setup the fdset structures
                        FD_ZERO(&readfds);
                        FD_ZERO(&writefds);
                        FD_ZERO(&exceptfds);

                        if (0 != selectTable[dwTableIndex].dwSocket1) {
                            if (0 != (FDSET_READ & selectTable[dwTableIndex].dwAddSets)) {
                                FD_SET(sSocket1, &readfds);

                                if (INVALID_SOCKET != sSocket2) {
                                    FD_SET(sSocket2, &readfds);
                                }
                            }

                            if (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwAddSets)) {
                                FD_SET(sSocket1, &writefds);

                                if (INVALID_SOCKET != sSocket2) {
                                    FD_SET(sSocket2, &writefds);
                                }
                            }

                            if (0 != (FDSET_EXCEPT & selectTable[dwTableIndex].dwAddSets)) {
                                FD_SET(sSocket1, &exceptfds);

                                if (INVALID_SOCKET != sSocket2) {
                                    FD_SET(sSocket2, &exceptfds);
                                }
                            }
                        }

                        if (0 == selectTable[dwTableIndex].tv_usec) {
                            Sleep(SLEEP_ZERO_TIME);
                        }

                        iReturnCode = select(0, (0 != (FDSET_READ & selectTable[dwTableIndex].dwAddSets)) ? &readfds : NULL, (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwAddSets)) ? &writefds: NULL, (0 != (FDSET_EXCEPT & selectTable[dwTableIndex].dwAddSets)) ? &exceptfds: NULL, (TRUE == selectTable[dwTableIndex].bTimeout) ? &fdstimeout : NULL);
                    } while (selectTable[dwTableIndex].iReturnCode > iReturnCode);
                }

                // Check return code
                if (selectTable[dwTableIndex].iReturnCode != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "select1 iReturnCode - EXPECTED: %d; RECEIVED: %d", selectTable[dwTableIndex].iReturnCode, iReturnCode);
                    bTestPassed = FALSE;
                }

                // Check fd sets
                if (0 != (FDSET_READ & selectTable[dwTableIndex].dwCheckSets)) {
                    if (0 == FD_ISSET(sSocket1, &readfds)) {
                        xLog(hLog, XLL_FAIL, "select1: sSocket1 not in readfds");
                        bTestPassed = FALSE;
                    }
                }
                else {
                    if (0 != FD_ISSET(sSocket1, &readfds)) {
                        xLog(hLog, XLL_FAIL, "select1: sSocket1 in readfds");
                        bTestPassed = FALSE;
                    }
                }

                if (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwCheckSets)) {
                    if (0 == FD_ISSET(sSocket1, &writefds)) {
                        xLog(hLog, XLL_FAIL, "select1: sSocket1 not in writefds");
                        bTestPassed = FALSE;
                    }
                }
                else {
                    if (0 != FD_ISSET(sSocket1, &writefds)) {
                        xLog(hLog, XLL_FAIL, "select1: sSocket1 in writefds");
                        bTestPassed = FALSE;
                    }
                }

                if (0 != (FDSET_EXCEPT & selectTable[dwTableIndex].dwCheckSets)) {
                    if (0 == FD_ISSET(sSocket1, &exceptfds)) {
                        xLog(hLog, XLL_FAIL, "select1: sSocket1 not in exceptfds");
                        bTestPassed = FALSE;
                    }
                }
                else {
                    if (0 != FD_ISSET(sSocket1, &exceptfds)) {
                        xLog(hLog, XLL_FAIL, "select1: sSocket1 in exceptfds");
                        bTestPassed = FALSE;
                    }
                }

                if (INVALID_SOCKET != sSocket2) {
                    // Check fd sets
                    if (0 != (FDSET_READ & selectTable[dwTableIndex].dwCheckSets)) {
                        if (0 == FD_ISSET(sSocket2, &readfds)) {
                            xLog(hLog, XLL_FAIL, "select1: sSocket2 not in readfds");
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (0 != FD_ISSET(sSocket2, &readfds)) {
                            xLog(hLog, XLL_FAIL, "select1: sSocket2 in readfds");
                            bTestPassed = FALSE;
                        }
                    }

                    if (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwCheckSets)) {
                        if (0 == FD_ISSET(sSocket2, &writefds)) {
                            xLog(hLog, XLL_FAIL, "select1: sSocket2 not in writefds");
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (0 != FD_ISSET(sSocket2, &writefds)) {
                            xLog(hLog, XLL_FAIL, "select1: sSocket2 in writefds");
                            bTestPassed = FALSE;
                        }
                    }

                    if (0 != (FDSET_EXCEPT & selectTable[dwTableIndex].dwCheckSets)) {
                        if (0 == FD_ISSET(sSocket2, &exceptfds)) {
                            xLog(hLog, XLL_FAIL, "select1: sSocket2 not in exceptfds");
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (0 != FD_ISSET(sSocket2, &exceptfds)) {
                            xLog(hLog, XLL_FAIL, "select1: sSocket2 in exceptfds");
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    if (FUNC_ACCEPT == selectTable[dwTableIndex].dwFunction) {
                        nsSocket1 = accept(sSocket1, NULL, NULL);
                        if (INVALID_SOCKET == nsSocket1) {
                            xLog(hLog, XLL_FAIL, "accept1 failed");
                            bTestPassed = FALSE;
                        }
                        else {
                            // Setup the fdset structures
                            FD_ZERO(&readfds);
                            FD_ZERO(&writefds);
                            FD_ZERO(&exceptfds);

                            FD_SET(nsSocket1, &readfds);
                            FD_SET(nsSocket1, &writefds);
                            FD_SET(nsSocket1, &exceptfds);

                            // Setup the timeout
                            fdstimeout.tv_sec = 0;
                            fdstimeout.tv_usec = 0;

                            iReturnCode = select(0, &readfds, &writefds, &exceptfds, &fdstimeout);
                            if (1 != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "select after accept1 - EXPECTED: %d; RECEIVED: %d", 1, iReturnCode);
                                bTestPassed = FALSE;
                            }

                            if (0 != FD_ISSET(nsSocket1, &readfds)) {
                                xLog(hLog, XLL_FAIL, "select after accept1 - readfds set");
                                bTestPassed = FALSE;
                            }

                            if (0 == FD_ISSET(nsSocket1, &writefds)) {
                                xLog(hLog, XLL_FAIL, "select after accept1 - writefds not set");
                                bTestPassed = FALSE;
                            }

                            if (0 != FD_ISSET(nsSocket1, &exceptfds)) {
                                xLog(hLog, XLL_FAIL, "select after accept1 - exceptfds set");
                                bTestPassed = FALSE;
                            }
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            nsSocket2 = accept(sSocket2, NULL, NULL);
                            if (INVALID_SOCKET == nsSocket2) {
                                xLog(hLog, XLL_FAIL, "accept2 failed");
                                bTestPassed = FALSE;
                            }
                            else {
                                // Setup the fdset structures
                                FD_ZERO(&readfds);
                                FD_ZERO(&writefds);
                                FD_ZERO(&exceptfds);

                                FD_SET(nsSocket2, &readfds);
                                FD_SET(nsSocket2, &writefds);
                                FD_SET(nsSocket2, &exceptfds);

                                // Setup the timeout
                                fdstimeout.tv_sec = 0;
                                fdstimeout.tv_usec = 0;

                                iReturnCode = select(0, &readfds, &writefds, &exceptfds, &fdstimeout);
                                if (1 != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "select after accept2 - EXPECTED: %d; RECEIVED: %d", 1, iReturnCode);
                                    bTestPassed = FALSE;
                                }

                                if (0 != FD_ISSET(nsSocket2, &readfds)) {
                                    xLog(hLog, XLL_FAIL, "select after accept2 - readfds not set");
                                    bTestPassed = FALSE;
                                }

                                if (0 == FD_ISSET(nsSocket2, &writefds)) {
                                    xLog(hLog, XLL_FAIL, "select after accept2 - writefds not set");
                                    bTestPassed = FALSE;
                                }

                                if (0 != FD_ISSET(nsSocket2, &exceptfds)) {
                                    xLog(hLog, XLL_FAIL, "select after accept2 - exceptfds set");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }

                    if (FUNC_ACCEPT_FAIL == selectTable[dwTableIndex].dwFunction) {
                        nsSocket1 = accept(sSocket1, NULL, NULL);
                        if (INVALID_SOCKET != nsSocket1) {
                            xLog(hLog, XLL_FAIL, "accept1 passed");
                            bTestPassed = FALSE;
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            nsSocket2 = accept(sSocket2, NULL, NULL);
                            if (INVALID_SOCKET != nsSocket2) {
                                xLog(hLog, XLL_FAIL, "accept2 passed");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    if (FUNC_CONNECT == selectTable[dwTableIndex].dwFunction) {
                        // Setup the fdset structures
                        FD_ZERO(&readfds);
                        FD_ZERO(&writefds);
                        FD_ZERO(&exceptfds);

                        FD_SET(sSocket1, &readfds);
                        FD_SET(sSocket1, &writefds);
                        FD_SET(sSocket1, &exceptfds);

                        // Setup the timeout
                        fdstimeout.tv_sec = 0;
                        fdstimeout.tv_usec = 0;

                        iReturnCode = select(0, &readfds, &writefds, &exceptfds, &fdstimeout);
                        if (1 != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "select after connect1 - EXPECTED: %d; RECEIVED: %d", 1, iReturnCode);
                            bTestPassed = FALSE;
                        }

                        if (0 != FD_ISSET(sSocket1, &readfds)) {
                            xLog(hLog, XLL_FAIL, "select after connect1 - readfds set");
                            bTestPassed = FALSE;
                        }

                        if (0 == FD_ISSET(sSocket1, &writefds)) {
                            xLog(hLog, XLL_FAIL, "select after connect1 - writefds not set");
                            bTestPassed = FALSE;
                        }

                        if (0 != FD_ISSET(sSocket1, &exceptfds)) {
                            xLog(hLog, XLL_FAIL, "select after connect1 - exceptfds set");
                            bTestPassed = FALSE;
                        }

                        ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                        iReturnCode = send(sSocket1, SendBuffer10, 10, 0);
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "connect1 failed");
                            bTestPassed = FALSE;
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            // Setup the fdset structures
                            FD_ZERO(&readfds);
                            FD_ZERO(&writefds);
                            FD_ZERO(&exceptfds);

                            FD_SET(sSocket2, &readfds);
                            FD_SET(sSocket2, &writefds);
                            FD_SET(sSocket2, &exceptfds);

                            // Setup the timeout
                            fdstimeout.tv_sec = 0;
                            fdstimeout.tv_usec = 0;

                            iReturnCode = select(0, &readfds, &writefds, &exceptfds, &fdstimeout);
                            if (1 != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "select after connect2 - EXPECTED: %d; RECEIVED: %d", 1, iReturnCode);
                                bTestPassed = FALSE;
                            }

                            if (0 != FD_ISSET(sSocket2, &readfds)) {
                                xLog(hLog, XLL_FAIL, "select after connect2 - readfds set");
                                bTestPassed = FALSE;
                            }

                            if (0 == FD_ISSET(sSocket2, &writefds)) {
                                xLog(hLog, XLL_FAIL, "select after connect2 - writefds not set");
                                bTestPassed = FALSE;
                            }

                            if (0 != FD_ISSET(sSocket2, &exceptfds)) {
                                xLog(hLog, XLL_FAIL, "select after connect2 - exceptfds set");
                                bTestPassed = FALSE;
                            }

                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            iReturnCode = send(sSocket2, SendBuffer10, 10, 0);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "connect2 failed");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    if (FUNC_CONNECT_FAIL == selectTable[dwTableIndex].dwFunction) {
                        ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                        iReturnCode = send(sSocket1, SendBuffer10, 10, 0);
                        if (SOCKET_ERROR != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "connect1 passed");
                            bTestPassed = FALSE;
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            iReturnCode = send(sSocket2, SendBuffer10, 10, 0);
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "connect2 passed");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    if (FUNC_CLOSE == selectTable[dwTableIndex].dwFunction) {
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                        if (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwCheckSets)) {
                            if (WSAECONNRESET != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "close1 failed");
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (0 != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "close1 failed");
                                bTestPassed = FALSE;
                            }
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv(sSocket2, RecvBuffer10, sizeof(RecvBuffer10), 0);
                            if (0 != (FDSET_WRITE & selectTable[dwTableIndex].dwCheckSets)) {
                                if (WSAECONNRESET != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "close2 failed");
                                    bTestPassed = FALSE;
                                }
                            }
                            else {
                                if (0 != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "close2 failed");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }

                    if (FUNC_CLOSE_FAIL == selectTable[dwTableIndex].dwFunction) {
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                        if (WSAEWOULDBLOCK != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "close1 passed");
                            bTestPassed = FALSE;
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv(sSocket2, RecvBuffer10, sizeof(RecvBuffer10), 0);
                            if (WSAEWOULDBLOCK != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "close2 passed");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    if (FUNC_READ == selectTable[dwTableIndex].dwFunction) {
                        ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                        sprintf(SendBuffer10, "%05d%05d", 1, 1);
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv1 failed");
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBuffer10, RecvBuffer10, 10)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            sprintf(SendBuffer10, "%05d%05d", 2, 2);
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv(sSocket2, RecvBuffer10, sizeof(RecvBuffer10), 0);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv2 failed");
                                bTestPassed = FALSE;
                            }
                            else {
                            }
                        }
                    }

                    if (FUNC_READ_FAIL == selectTable[dwTableIndex].dwFunction) {
                        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                        iReturnCode = recv(sSocket1, RecvBuffer10, sizeof(RecvBuffer10), 0);
                        if (SOCKET_ERROR != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv1 passed");
                            bTestPassed = FALSE;
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv(sSocket2, RecvBuffer10, sizeof(RecvBuffer10), 0);
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv2 passed");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    if (FUNC_SEND == selectTable[dwTableIndex].dwFunction) {
                        ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                        iReturnCode = send(sSocket1, SendBuffer10, 10, 0);
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "send1 failed");
                            bTestPassed = FALSE;
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            iReturnCode = send(sSocket2, SendBuffer10, 10, 0);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "send2 failed");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    if (FUNC_SEND_FAIL == selectTable[dwTableIndex].dwFunction) {
                        ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                        iReturnCode = send(sSocket1, SendBuffer10, 10, 0);
                        if (SOCKET_ERROR != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "send1 passed");
                            bTestPassed = FALSE;
                        }

                        if (INVALID_SOCKET != sSocket2) {
                            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                            iReturnCode = send(sSocket2, SendBuffer10, 10, 0);
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "send2 passed");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "select succeeded");
                }
            }
        }

        if (0 != selectTable[dwTableIndex].dwFunction) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(selectRequest), (char *) &selectRequest);
        }

        // Close the socket
        if (INVALID_SOCKET != nsSocket2) {
            shutdown(nsSocket2, SD_BOTH);
            closesocket(nsSocket2);
        }

        if (INVALID_SOCKET != nsSocket1) {
            shutdown(nsSocket1, SD_BOTH);
            closesocket(nsSocket1);
        }

        if ((SOCKET_TCP == selectTable[dwTableIndex].dwSocket2) || (SOCKET_UDP == selectTable[dwTableIndex].dwSocket2)) {
            shutdown(sSocket2, SD_BOTH);
            closesocket(sSocket2);
        }

        if (0 == (SOCKET_CLOSED & selectTable[dwTableIndex].dwSocket1)) {
            if ((0 != (SOCKET_TCP & selectTable[dwTableIndex].dwSocket1)) || (0 != (SOCKET_UDP & selectTable[dwTableIndex].dwSocket1))) {
                shutdown(sSocket1, SD_BOTH);
                closesocket(sSocket1);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort += 2;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
selectTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests select - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long           FromInAddr;
    // dwMessageType is the type of received message
    DWORD            dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD            dwMessageSize;
    // pMessage is a pointer to the received message
    char             *pMessage;
    // selectRequest is the request
    SELECT_REQUEST   selectRequest;
    // selectComplete is the result
    SELECT_COMPLETE  selectComplete;

    // sSocket1 is the first socket descriptor
    SOCKET           sSocket1;
    // sSocket2 is the second socket descriptor
    SOCKET           sSocket2;
    // nsSocket1 is the first accepted socket descriptor
    SOCKET           nsSocket1;
    // nsSocket2 is the second accepted socket descriptor
    SOCKET           nsSocket2;

    // dwBufferSize is the send/receive buffer size
    DWORD            dwBufferSize = 1;
    // bNagle indicates if Nagle is enabled
    BOOL             bNagle = FALSE;

    // localname1 is the first local address
    SOCKADDR_IN      localname1;
    // localname2 is the second local address
    SOCKADDR_IN      localname2;
    // remotename1 is the first remote address
    SOCKADDR_IN      remotename1;
    // remotename2 is the second remote address
    SOCKADDR_IN      remotename2;

    // SendBuffer10 is the send buffer
    char             SendBuffer10[BUFFER_10_LEN + 1];



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&selectRequest, pMessage, sizeof(selectRequest));
        NetsyncFreeMessage(pMessage);

        // Create the sockets
        sSocket1 = INVALID_SOCKET;
        sSocket2 = INVALID_SOCKET;
        nsSocket1 = INVALID_SOCKET;
        nsSocket2 = INVALID_SOCKET;
        sSocket1 = socket(AF_INET, selectRequest.nSocketType, 0);
        if (2 == selectRequest.nSockets) {
            sSocket2 = socket(AF_INET, selectRequest.nSocketType, 0);
        }

        if (SOCK_STREAM == selectRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket1, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
            if (INVALID_SOCKET != sSocket2) {
                setsockopt(sSocket2, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
            }
        }

        // Set the buffer size
        dwBufferSize = 1;
        setsockopt(sSocket1, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        dwBufferSize = 1;
        setsockopt(sSocket1, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        if (INVALID_SOCKET != sSocket2) {
            dwBufferSize = 1;
            setsockopt(sSocket2, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            dwBufferSize = 1;
            setsockopt(sSocket2, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Bind the socket
        ZeroMemory(&localname1, sizeof(localname1));
        localname1.sin_family = AF_INET;
        localname1.sin_port = htons(selectRequest.Port);
        bind(sSocket1, (SOCKADDR *) &localname1, sizeof(localname1));

        if (INVALID_SOCKET != sSocket2) {
            ZeroMemory(&localname2, sizeof(localname2));
            localname2.sin_family = AF_INET;
            localname2.sin_port = htons(selectRequest.Port + 1);
            bind(sSocket2, (SOCKADDR *) &localname2, sizeof(localname2));
        }

        if ((SOCK_STREAM == selectRequest.nSocketType) && (TRUE == selectRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket1, SOMAXCONN);

            if (INVALID_SOCKET != sSocket2) {
                listen(sSocket2, SOMAXCONN);
            }
        }

        if (SOCK_DGRAM == selectRequest.nSocketType) {
            // Connect the socket
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = FromInAddr;
            remotename1.sin_port = htons(selectRequest.Port);

            connect(sSocket1, (SOCKADDR *) &remotename1, sizeof(remotename1));

            if (INVALID_SOCKET != sSocket2) {
                ZeroMemory(&remotename2, sizeof(remotename2));
                remotename2.sin_family = AF_INET;
                remotename2.sin_addr.s_addr = FromInAddr;
                remotename2.sin_port = htons(selectRequest.Port + 1);

                connect(sSocket2, (SOCKADDR *) &remotename2, sizeof(remotename2));
            }
        }

        // Send the complete
        selectComplete.dwMessageId = SELECT_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(selectComplete), (char *) &selectComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Send the complete
        selectComplete.dwMessageId = SELECT_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(selectComplete), (char *) &selectComplete);

        if ((SOCK_STREAM == selectRequest.nSocketType) && (TRUE == selectRequest.bServerAccept)) {
            // Accept the connection
            nsSocket1 = accept(sSocket1, NULL, NULL);

            if (INVALID_SOCKET != sSocket2) {
                nsSocket2 = accept(sSocket2, NULL, NULL);
            }
        }

        // Sleep
        if (0 == selectRequest.dwWaitTime) {
            Sleep(SLEEP_MIDLOW_TIME);
        }
        else {
            Sleep(SLEEP_MIDLOW_TIME + SLEEP_MEAN_TIME);
        }

        if (TRUE == selectRequest.bServerConnect) {
            // Connect the socket
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = FromInAddr;
            remotename1.sin_port = htons(selectRequest.Port);

            connect(sSocket1, (SOCKADDR *) &remotename1, sizeof(remotename1));

            if (INVALID_SOCKET != sSocket2) {
                ZeroMemory(&remotename1, sizeof(remotename1));
                remotename2.sin_family = AF_INET;
                remotename2.sin_addr.s_addr = FromInAddr;
                remotename2.sin_port = htons(selectRequest.Port + 1);

                connect(sSocket2, (SOCKADDR *) &remotename2, sizeof(remotename2));
            }
        }

        if (TRUE == selectRequest.bServerSend) {
            // Call send
            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
            sprintf(SendBuffer10, "%05d%05d", 1, 1);

            send((INVALID_SOCKET == nsSocket1) ? sSocket1 : nsSocket1, SendBuffer10, 10, 0);

            if (INVALID_SOCKET != sSocket2) {
                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                sprintf(SendBuffer10, "%05d%05d", 2, 2);

                send((INVALID_SOCKET == nsSocket2) ? sSocket2 : nsSocket2, SendBuffer10, 10, 0);
            }
        }

        if (TRUE == selectRequest.bServerClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket2) {
                shutdown(nsSocket2, SD_BOTH);
            }

            if (INVALID_SOCKET != nsSocket1) {
                shutdown(nsSocket1, SD_BOTH);
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket2) {
            shutdown(nsSocket2, SD_BOTH);
            closesocket(nsSocket2);
        }

        if (INVALID_SOCKET != nsSocket1) {
            shutdown(nsSocket1, SD_BOTH);
            closesocket(nsSocket1);
        }

        if (INVALID_SOCKET != sSocket2) {
            shutdown(sSocket2, SD_BOTH);
            closesocket(sSocket2);
        }

        if (INVALID_SOCKET != sSocket1) {
            shutdown(sSocket1, SD_BOTH);
            closesocket(sSocket1);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\server.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.h

Abstract:

  This module contains the definitions for server.c

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#pragma once



// Function prototypes

VOID
WINAPI
listenTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
acceptTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
connectTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
sendTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
WSASendTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
sendtoTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
WSASendToTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
recvTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
WSARecvTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
recvfromTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
WSARecvFromTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
getsocknameTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
getpeernameTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
ioctlsocketTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
WSAGetOverlappedResultTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
WSACancelOverlappedIOTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
selectTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
shutdownTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
closesocketTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
XNetRegisterKeyTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
XNetUnregisterKeyTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
XNetXnAddrToInAddrTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
XNetInAddrToXnAddrTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\setsockopt.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  setsockopt.c

Abstract:

  This modules tests setsockopt

Author:

  Steven Kehrli (steveke) 21-Jun-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct SETSOCKOPT_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    DWORD    dwSocket;                                // dwSocket indicates the socket to be created
    int      level;                                   // level is the socket option level
    int      optname;                                 // optname is the socket option
    BOOL     boptval;                                 // boptval specifies if optval is valid
    int      optlen;                                  // optlen is the size of the socket option
    int      iReturnCode;                             // iReturnCode is the return code of setsockopt
    int      iLastError;                              // iLastError is the error code if the operation failed
    BOOL     bRIP;                                    // Specifies a RIP test case
} SETSOCKOPT_TABLE, *PSETSOCKOPT_TABLE;

static SETSOCKOPT_TABLE setsockoptTable[] =
{
    { "31.1 Not Initialized",          FALSE, SOCKET_INVALID_SOCKET,      0,           0,                   TRUE,  0,                     SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "31.2 s = INT_MIN",              TRUE,  SOCKET_INT_MIN,             0,           0,                   TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "31.3 s = -1",                   TRUE,  SOCKET_NEG_ONE,             0,           0,                   TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "31.4 s = 0",                    TRUE,  SOCKET_ZERO,                0,           0,                   TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "31.5 s = INT_MAX",              TRUE,  SOCKET_INT_MAX,             0,           0,                   TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "31.6 s = INVALID_SOCKET",       TRUE,  SOCKET_INVALID_SOCKET,      0,           0,                   TRUE,  0,                     SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "31.7 TCP SO_ACCEPTCONN",        TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_ACCEPTCONN,       TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.8 TCP SO_BROADCAST",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_BROADCAST,        TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.9 TCP SO_REUSEADDR",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_REUSEADDR,        TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "31.10 TCP SO_EXCLUSIVEADDRUSE", TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_EXCLUSIVEADDRUSE, TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "31.11 TCP SO_LINGER",           TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_LINGER,           TRUE,  sizeof(struct linger), 0,            0,                 FALSE },
    { "31.12 TCP SO_DONTLINGER",       TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_DONTLINGER,       TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "31.13 TCP SO_SNDBUF",           TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_SNDBUF,           TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "31.14 TCP SO_RCVBUF",           TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_RCVBUF,           TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "31.15 TCP SO_SNDTIMEO",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_SNDTIMEO,         TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "31.16 TCP SO_RCVTIMEO",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_RCVTIMEO,         TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "31.17 TCP SO_TYPE",             TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.18 TCP TCP_NODELAY",         TRUE,  SOCKET_TCP,                 IPPROTO_TCP, TCP_NODELAY,         TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "31.19 UDP SO_ACCEPTCONN",       TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_ACCEPTCONN,       TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.20 UDP SO_BROADCAST",        TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_BROADCAST,        TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "31.21 UDP SO_REUSEADDR",        TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_REUSEADDR,        TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "31.22 UDP SO_EXCLUSIVEADDRUSE", TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_EXCLUSIVEADDRUSE, TRUE,  sizeof(BOOL),          0,            0,                 FALSE },
    { "31.23 UDP SO_LINGER",           TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_LINGER,           TRUE,  sizeof(struct linger), SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.24 UDP SO_DONTLINGER",       TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_DONTLINGER,       TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.25 UDP SO_SNDBUF",           TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_SNDBUF,           TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "31.26 UDP SO_RCVBUF",           TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_RCVBUF,           TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "31.27 UDP SO_SNDTIMEO",         TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_SNDTIMEO,         TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "31.28 UDP SO_RCVTIMEO",         TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_RCVTIMEO,         TRUE,  sizeof(int),           0,            0,                 FALSE },
    { "31.29 UDP SO_TYPE",             TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.30 UDP TCP_NODELAY",         TRUE,  SOCKET_UDP,                 IPPROTO_TCP, TCP_NODELAY,         TRUE,  sizeof(BOOL),          SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.31 TCP 0 level",             TRUE,  SOCKET_TCP,                 0,           SO_TYPE,             TRUE,  sizeof(int),           SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "31.32 TCP 0 optname",           TRUE,  SOCKET_TCP,                 SOL_SOCKET,  0,                   TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.33 TCP NULL optval",         TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_TYPE,             FALSE, sizeof(int),           0,            0,                 TRUE  },
    { "31.34 TCP 0 optlen",            TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  0,                     0,            0,                 TRUE  },
    { "31.35 TCP SO_LINGER optlen",    TRUE,  SOCKET_TCP,                 SOL_SOCKET,  SO_LINGER,           TRUE,  sizeof(u_short),       0,            0,                 TRUE  },
    { "31.36 UDP 0 level",             TRUE,  SOCKET_UDP,                 0,           SO_TYPE,             TRUE,  sizeof(int),           SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "31.37 UDP 0 optname",           TRUE,  SOCKET_UDP,                 SOL_SOCKET,  0,                   TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOPROTOOPT,    FALSE },
    { "31.38 UDP NULL optval",         TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_TYPE,             FALSE, sizeof(int),           0,            0,                 TRUE  },
    { "31.39 UDP 0 optlen",            TRUE,  SOCKET_UDP,                 SOL_SOCKET,  SO_TYPE,             TRUE,  0,                     0,            0,                 TRUE  },
    { "31.40 TCP Closed",              TRUE,  SOCKET_TCP | SOCKET_CLOSED, SOL_SOCKET,  SO_TYPE,             TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "31.41 UDP Closed",              TRUE,  SOCKET_UDP | SOCKET_CLOSED, SOL_SOCKET,  SO_TYPE,             TRUE,  sizeof(int),           SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "31.42 Not Initialized",         FALSE, SOCKET_INVALID_SOCKET,      0,           0,                   TRUE,  0,                     SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define setsockoptTableCount (sizeof(setsockoptTable) / sizeof(SETSOCKOPT_TABLE))



VOID
setsockoptTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests setsockopt - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // sSocket is the socket descriptor
    SOCKET                 sSocket;

    // localname is the local address
    SOCKADDR_IN            localname;

    // optval is the pointer to the socket option value
    char                   *optval;
    int                    defaultoptval;
    // optlen is the size of the socket option
    int                    optlen;

    // bAcceptConn is the value for SO_ACCEPTCONN
    BOOL                   bAcceptConn;
    // bBroadcast is the value for SO_BROADCAST
    BOOL                   bBroadcast;
    // bReuseAddr is the value for SO_REUSEADDR
    BOOL                   bReuseAddr;
    // bExclusiveAddrUse is the value for SO_EXCLUSIVEADDRUSE
    BOOL                   bExclusiveAddrUse;
    // linger is the value for SO_LINGER
    struct linger          linger;
    // bDontLinger is the value for SO_DONTLINGER
    BOOL                   bDontLinger;
    // nSndBuf is the value for SO_SNDBUF
    int                    nSndBuf;
    // nRcvBuf is the value for SO_RCVBUF
    int                    nRcvBuf;
    // nSndTimeO is the value for SO_SNDTIMEO
    int                    nSndTimeO;
    // nRcvTimeO is the value for SO_RCVTIMEO
    int                    nRcvTimeO;
    // nType is the value for SO_TYPE
    int                    nType;
    // bNoDelay is the value for TCP_NODELAY
    BOOL                   bNoDelay;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "setsockopt v%04x", WinsockVersion);
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_setsockopt+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_setsockopt-");

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < setsockoptTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, setsockoptTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, setsockoptTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != setsockoptTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, setsockoptTable[dwTableIndex].szVariationName);

        // Check the state of Winsock
        if (bWinsockInitialized != setsockoptTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == setsockoptTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = setsockoptTable[dwTableIndex].bWinsockInitialized;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == setsockoptTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == setsockoptTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == setsockoptTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == setsockoptTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == setsockoptTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & setsockoptTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & setsockoptTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Bind the socket
        if ((0 != (SOCKET_TCP & setsockoptTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & setsockoptTable[dwTableIndex].dwSocket))) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Setup optval
        optval = (char *) &defaultoptval;
        optlen = setsockoptTable[dwTableIndex].optlen;
        switch (setsockoptTable[dwTableIndex].optname) {
            case SO_ACCEPTCONN:
                bAcceptConn = TRUE;
                optval = (char *) &bAcceptConn;
                break;

            case SO_BROADCAST:
                bBroadcast = TRUE;
                optval = (char *) &bBroadcast;
                break;

            case SO_REUSEADDR:
                bReuseAddr = TRUE;
                optval = (char *) &bReuseAddr;
                break;

            case SO_EXCLUSIVEADDRUSE:
                bExclusiveAddrUse = TRUE;
                optval = (char *) &bExclusiveAddrUse;
                break;

            case SO_LINGER:
                linger.l_onoff = 0;
                linger.l_linger = 5;
                optval = (char *) &linger;
                break;

            case SO_DONTLINGER:
                bDontLinger = FALSE;
                optval = (char *) &bDontLinger;
                break;

            case SO_SNDBUF:
                nSndBuf = 1;
                optval = (char *) &nSndBuf;
                break;

            case SO_RCVBUF:
                nRcvBuf = 1;
                optval = (char *) &nRcvBuf;
                break;

            case SO_SNDTIMEO:
                nSndTimeO = 5;
                optval = (char *) &nSndTimeO;
                break;

            case SO_RCVTIMEO:
                nRcvTimeO = 5;
                optval = (char *) &nRcvTimeO;
                break;

            case SO_TYPE:
                nType = 0;
                optval = (char *) &nType;
                break;

            case TCP_NODELAY:
                bNoDelay = TRUE;
                optval = (char *) &bNoDelay;
                break;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & setsockoptTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call setsockopt
            iReturnCode = setsockopt(sSocket, setsockoptTable[dwTableIndex].level, setsockoptTable[dwTableIndex].optname, (TRUE == setsockoptTable[dwTableIndex].boptval) ? optval : NULL, setsockoptTable[dwTableIndex].optlen);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            xLog(hLog, XLL_EXCEPTION, "setsockopt caused an exception - ec = 0x%08x", GetExceptionCode());
        }

        if (FALSE == bException) {
            if (TRUE == setsockoptTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "setsockopt did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == setsockoptTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != setsockoptTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "setsockopt iLastError - EXPECTED: %u; RECEIVED: %u", setsockoptTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "setsockopt iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                // Get the last error code
                iLastError = WSAGetLastError();

                xLog(hLog, XLL_FAIL, "setsockopt returned SOCKET_ERROR - ec = %u", iLastError);
            }
            else if (SOCKET_ERROR == setsockoptTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "setsockopt returned non-SOCKET_ERROR");
            }
            else {
                // Call getsockopt
                getsockopt(sSocket, setsockoptTable[dwTableIndex].level, setsockoptTable[dwTableIndex].optname, optval, &optlen);

                // Check optlen
                if (setsockoptTable[dwTableIndex].optlen != optlen) {
                    xLog(hLog, XLL_FAIL, "optlen - EXPECTED: %d; RECEIVED: %d", setsockoptTable[dwTableIndex].optlen, optlen);
                    bTestPassed = FALSE;
                }

                // Check optval
                switch (setsockoptTable[dwTableIndex].optname) {
                    case SO_ACCEPTCONN:
                        if (TRUE != bAcceptConn) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", TRUE, bAcceptConn);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_BROADCAST:
                        if (TRUE != bBroadcast) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", TRUE, bBroadcast);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_REUSEADDR:
                        if (TRUE != bReuseAddr) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", TRUE, bReuseAddr);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_EXCLUSIVEADDRUSE:
                        if (TRUE != bExclusiveAddrUse) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", TRUE, bExclusiveAddrUse);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_LINGER:
                        if (0 != linger.l_onoff) {
                            xLog(hLog, XLL_FAIL, "l_onoff - EXPECTED: %d; RECEIVED: %d", 0, linger.l_onoff);
                            bTestPassed = FALSE;
                        }

                        if (5 != linger.l_linger) {
                            xLog(hLog, XLL_FAIL, "l_linger - EXPECTED: %d; RECEIVED: %d", 5, linger.l_linger);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_DONTLINGER:
                        if (FALSE != bDontLinger) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", FALSE, bDontLinger);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_SNDBUF:
                        if (1 != nSndBuf) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", 1, nSndBuf);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_RCVBUF:
                        if (1 != nRcvBuf) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", 1, nRcvBuf);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_SNDTIMEO:
                        if (5 != nSndTimeO) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", 5, nSndTimeO);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_RCVTIMEO:
                        if (5 != nRcvTimeO) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", 5, nRcvTimeO);
                            bTestPassed = FALSE;
                        }

                        break;

                    case SO_TYPE:
                        if (0 != (SOCKET_TCP & setsockoptTable[dwTableIndex].dwSocket)) {
                            if (SOCK_STREAM != nType) {
                                xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", SOCK_STREAM, nType);
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (SOCK_DGRAM != nType) {
                                xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", SOCK_DGRAM, nType);
                                bTestPassed = FALSE;
                            }
                        }

                        break;

                    case TCP_NODELAY:
                        if (TRUE != bNoDelay) {
                            xLog(hLog, XLL_FAIL, "optval - EXPECTED: %d; RECEIVED: %d", TRUE, bNoDelay);
                            bTestPassed = FALSE;
                        }

                        break;
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "setsockopt succeeded");
                }
            }
        }

        if (0 == (SOCKET_CLOSED & setsockoptTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & setsockoptTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & setsockoptTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\sendto.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  sendto.c

Abstract:

  This modules tests sendto

Author:

  Steven Kehrli (steveke) 1-Dec-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// sendto messages

#define SENDTO_REQUEST_MSG   NETSYNC_MSG_USER + 150 + 1
#define SENDTO_CANCEL_MSG    NETSYNC_MSG_USER + 150 + 2
#define SENDTO_COMPLETE_MSG  NETSYNC_MSG_USER + 150 + 3

typedef struct _SENDTO_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  ReceivePort;
    u_short  SendPort;
    BOOL     bServerAccept;
    BOOL     bFillQueue;
    INT      nQueueLen;
    BOOL     bRemoteClose;
    int      nDataBuffers;
    int      nBufferlen;
} SENDTO_REQUEST, *PSENDTO_REQUEST;

typedef struct _SENDTO_COMPLETE {
    DWORD    dwMessageId;
} SENDTO_COMPLETE, *PSENDTO_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define NAME_ANY              0
#define NAME_ANYADDR          1
#define NAME_ANYPORT          2
#define NAME_LOCAL            3
#define NAME_LOOPBACK         4
#define NAME_BROADCAST        5
#define NAME_MULTICAST        6
#define NAME_UNAVAIL          7
#define NAME_BAD              8
#define NAME_NULL             9
#define NAME_REMOTE_1        10
#define NAME_REMOTE_2        11

#define BUFFER_10             0
#define BUFFER_LARGE          1
#define BUFFER_NULL           2
#define BUFFER_NULLZERO       3
#define BUFFER_ZERO           4
#define BUFFER_SMALL          5
#define BUFFER_TCPLARGE       6
#define BUFFER_UDPLARGE       7
#define BUFFER_UDPTOOLARGE    8
#define BUFFER_TCPMULTI       9
#define BUFFER_UDPMULTI      10
#define BUFFER_NONE          11

#define OVERLAPPED_IO_RESULT  1
#define OVERLAPPED_IO_EVENT   2



typedef struct SENDTOBUFFER_TABLE {
    DWORD  dwBuffer;
    int    nBufferlen;
} SENDTOBUFFER_TABLE, *PSENDTOBUFFER_TABLE;

SENDTOBUFFER_TABLE SendToBufferTcpTable[] = { { BUFFER_10,    BUFFER_10_LEN       },
                                              { BUFFER_NULL,  0                   },
                                              { BUFFER_LARGE, BUFFER_TCPLARGE_LEN } };

#define SendToBufferTcpTableCount  (sizeof(SendToBufferTcpTable) / sizeof(SENDTOBUFFER_TABLE));

SENDTOBUFFER_TABLE SendToBufferUdpTable[] = { { BUFFER_10,    BUFFER_10_LEN       },
                                              { BUFFER_NULL,  0                   },
                                              { BUFFER_LARGE, BUFFER_UDPLARGE_LEN } };

#define SendToBufferUdpTableCount  (sizeof(SendToBufferUdpTable) / sizeof(SENDTOBUFFER_TABLE));



typedef struct SENDTO_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the send
    BOOL   bBind;                                   // bBind indicates if the socket is to be bound
    BOOL   bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL   bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL   bConnect;                                // bConnect indicates if the socket is connected
    BOOL   bFillQueue;                              // bFillQueue indicates if the buffer should be filled
    BOOL   bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL   bShutdown;                               // bShutdown indicates if the connection is shutdown
    int    nShutdown;                               // nShutdown indicates how the connection is shutdown
    int    nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be sent
    DWORD  dwBuffer;                                // dwBuffer specifies the send buffer
    int    nBufferlen;                              // nBufferlen specifies the send data buffer length
    int    nFlags;                                  // nFlags specifies the sendto flags
    DWORD  dwName;                                  // dwName indicates the address
    int    namelen;                                 // namelen is the length of the address buffer
    int    iReturnCode;                             // iReturnCode is the return code of sendto
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} SENDTO_TABLE, *PSENDTO_TABLE;

static SENDTO_TABLE sendtoTable[] =
{
    { "15.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "15.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "15.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "15.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                   FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "15.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "15.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "15.7 Not Bound TCP",              TRUE,  TRUE,  SOCKET_TCP,                    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "15.8 Listening TCP",              TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "15.9 Accepted TCP",               TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.10 Connected TCP",             TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.11 Fill Queue TCP",            TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.12 SD_RECEIVE Accept TCP",     TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.13 SD_SEND Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.14 SD_BOTH Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.15 SD_RECEIVE Connect TCP",    TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.16 SD_SEND Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.17 SD_BOTH Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.18 Close Accept TCP",          TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "15.19 Close Connect TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "15.20 NULL Buffer TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.21 Neg Bufferlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    -1,                      0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.22 NULL 0 Bufferlen TCP",      TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.23 0 Bufferlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    0,                       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.24 Small Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN - 1,       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.25 Exact Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.26 Large Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_TCPLARGE_LEN,     0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.27 Switch Send TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.28 Iterative Send TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.29 flags != 0 TCP",            TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           4, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.30 Same addr TCP",             TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.31 Different addr TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.32 Broadcast addr TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.33 Multicast addr TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_MULTICAST, sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.34 Bad addr TCP",              TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BAD,       sizeof(SOCKADDR_IN),     0,            WSAEFAULT,         TRUE  },
    { "15.35 Zero addr TCP",             TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.36 Any addr TCP",              TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.37 Zero port addr TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.38 Large addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "15.39 Exact addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.40 Small addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) - 1, 0,            WSAEFAULT,         TRUE  },
    { "15.41 Zero addrlen TCP",          TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  0,                       0,            WSAEFAULT,         TRUE  },
    { "15.42 Neg addrlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  -1,                      0,            WSAEFAULT,         TRUE  },
    { "15.43 Not Bound NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "15.44 Listening NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "15.45 Accepted NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.46 Connected NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.47 Fill Queue NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.48 SD_RECEIVE Accept NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.49 SD_SEND Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.50 SD_BOTH Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.51 SD_RECEIVE Connect NB TCP", TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.52 SD_SEND Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.53 SD_BOTH Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.54 Close Accept NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "15.55 Close Connect NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "15.56 NULL Buffer NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.57 Neg Bufferlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    -1,                      0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.58 NULL 0 Bufferlen NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.59 0 Bufferlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    0,                       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.60 Small Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN - 1,       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.61 Exact Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.62 Large Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_TCPLARGE_LEN,     0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.63 Switch Send NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.64 Iterative Send NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.65 flags != 0 NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           4, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.66 Same addr NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.67 Different addr NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_2,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.68 Broadcast addr NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.69 Multicast addr NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_MULTICAST, sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.70 Bad addr NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BAD,       sizeof(SOCKADDR_IN),     0,            WSAEFAULT,         TRUE  },
    { "15.71 Zero addr NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANY,       sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.72 Any addr NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.73 Zero port addr NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.74 Large addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "15.75 Exact addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.76 Small addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) - 1, 0,            WSAEFAULT,         TRUE  },
    { "15.77 Zero addrlen NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  0,                       0,            WSAEFAULT,         TRUE  },
    { "15.78 Neg addrlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  -1,                      0,            WSAEFAULT,         TRUE  },
    { "15.79 Not Bound UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "15.80 Not Connected UDP",         TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "15.81 Connected UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.82 SD_RECEIVE Conn UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.83 SD_SEND Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.84 SD_BOTH Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.85 NULL Buffer UDP",           TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.86 Neg Bufferlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    -1,                      0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.87 NULL 0 Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.88 0 Bufferlen UDP",           TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    0,                       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.89 Small Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN - 1,       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.90 Exact Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.91 Large Buffer UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN,     0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.92 Too Large Buffer UDP",      TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN + 1, 0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "15.93 Switch Send UDP",           TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.94 Iterative Send UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.95 flags != 0 UDP",            TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           4, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.96 Not Bound Addr UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.97 Bound Addr UDP",            TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.98 Same addr UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.99 Different addr UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.100 Broadcast addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEACCES,         FALSE },
    { "15.101 Broadcast enabled UDP",    TRUE,  TRUE,  SOCKET_UDP | SOCKET_BROADCAST, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.102 Multicast addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_MULTICAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "15.103 Bad addr UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BAD,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.104 Zero addr UDP",            TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "15.105 Any addr UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "15.106 Zero port addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "15.107 Large addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "15.108 Exact addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.109 Small addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.110 Zero addrlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.111 Neg addrlen UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.112 Not Bound NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "15.113 Not Connected NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "15.114 Connected NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.115 SD_RECEIVE Conn NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.116 SD_SEND Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.117 SD_BOTH Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "15.118 NULL Buffer NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  BUFFER_10_LEN,           0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.119 Neg Bufferlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    -1,                      0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.120 NULL 0 Bufferlen NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.121 0 Bufferlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    0,                       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.122 Small Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN - 1,       0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.123 Exact Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.124 Large Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN,     0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.125 Too Large Buffer NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_LARGE, BUFFER_UDPLARGE_LEN + 1, 0, NAME_NULL,      0,                       SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "15.126 Switch Send NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.127 Iterative Send NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,    BUFFER_10_LEN,           0, NAME_NULL,      0,                       0,            0,                 FALSE },
    { "15.128 flags != 0 NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           4, NAME_NULL,      0,                       SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.129 Not Bound Addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.130 Bound Addr NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.131 Same addr NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.132 Different addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_2,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.133 Broadcast addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEACCES,         FALSE },
    { "15.134 Broadcast enabled NB UDP", TRUE,  TRUE,  SOCKET_UDP | SOCKET_BROADCAST, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.135 Multicast addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_MULTICAST, sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "15.136 Bad addr NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_BAD,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.137 Zero addr NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANY,       sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "15.138 Any addr NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "15.139 Zero port addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "15.140 Large addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) + 1, 0,            0,                 FALSE },
    { "15.141 Exact addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,            0,                 FALSE },
    { "15.142 Small addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) - 1, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.143 Zero addrlen NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  0,                       SOCKET_ERROR, WSAEFAULT,         TRUE },
    { "15.144 Neg addrlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,    BUFFER_10_LEN,           0, NAME_REMOTE_1,  -1,                      SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "15.145 Closed Socket TCP",        TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "15.146 Closed Socket UDP",        TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "15.147 Not Initialized",          FALSE, FALSE, SOCKET_INVALID_SOCKET,         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,  0,                       0, NAME_NULL,      0,                       SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define sendtoTableCount (sizeof(sendtoTable) / sizeof(SENDTO_TABLE))

NETSYNC_TYPE_THREAD  sendtoTestSessionNt =
{
    1,
    sendtoTableCount * 2,
    L"xnetapi_nt.dll",
    "sendtoTestServer"
};

NETSYNC_TYPE_THREAD  sendtoTestSessionXbox =
{
    1,
    sendtoTableCount * 2,
    L"xnetapi_xbox.dll",
    "sendtoTestServer"
};



VOID
sendtoTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests sendto - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // sendtoRequest is the request sent to the server
    SENDTO_REQUEST         sendtoRequest;

    // HostXnAddr is the host xnet address
    XNADDR                 HostXnAddr;
    // hostaddr is the local host address
    u_long                 hostaddr = 0;

    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                  dwBufferSize = 1;
    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // bBroadcast indicates the socket is enabled to send broadcast data
    BOOL                   bBroadcast = TRUE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename1 is the first remote address
    SOCKADDR_IN            remotename1;
    // remotename2 is the second remote address
    SOCKADDR_IN            remotename2;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // timeout is the timeout for select
    timeval                fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // Buffer is a pointer to the buffer
    char                   *Buffer;
    // dwFillBuffer is a counter to fill the buffers
    DWORD                  dwFillBuffer;
    // nBytes is the number of bytes sent
    int                    nBytes;
    // nSendCount is a counter to enumerate each send/recv
    int                    nSendCount;

    // SendToBufferTable is the test buffer table to use for iterative send
    PSENDTOBUFFER_TABLE    SendToBufferTable;
    // SendToBufferTableCount is the number of elements within the test buffer table
    size_t                 SendToBufferTableCount;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // dwReturnCode is the return code of the operation
    DWORD                  dwReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "sendto v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_sendto+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_sendto-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = sendtoTestSessionXbox;
    }
    else {
        NetsyncTypeSession = sendtoTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    // Get the local xnaddr
    do {
        dwReturnCode = XNetGetTitleXnAddr(&HostXnAddr);
        if (0 == dwReturnCode) {
            Sleep(SLEEP_ZERO_TIME);
        }
    } while (0 == dwReturnCode);
    hostaddr = HostXnAddr.ina.s_addr;

    for (dwTableIndex = 0; dwTableIndex < sendtoTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, sendtoTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, sendtoTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != sendtoTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, sendtoTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == sendtoTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != sendtoTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == sendtoTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = sendtoTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == sendtoTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == sendtoTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == sendtoTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == sendtoTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == sendtoTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == sendtoTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & sendtoTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Set the socket for broadcast
        if (0 != (SOCKET_BROADCAST & sendtoTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, SOL_SOCKET, SO_BROADCAST, (char *) &bBroadcast, sizeof(bBroadcast));
        }

        if (TRUE == sendtoTable[dwTableIndex].bFillQueue) {
            // Set the buffer size
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & sendtoTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == sendtoTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == sendtoTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == sendtoTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
            SendToBufferTable = SendToBufferTcpTable;
            SendToBufferTableCount = SendToBufferTcpTableCount;
        }
        else {
            SendToBufferTable = SendToBufferUdpTable;
            SendToBufferTableCount = SendToBufferUdpTableCount;
        }

        if ((TRUE == sendtoTable[dwTableIndex].bAccept) || (TRUE == sendtoTable[dwTableIndex].bConnect) || (0 == sendtoTable[dwTableIndex].iReturnCode)) {
            // Initialize the sendto request
            sendtoRequest.dwMessageId = SENDTO_REQUEST_MSG;
            if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
                sendtoRequest.nSocketType = SOCK_STREAM;
            }
            else {
                sendtoRequest.nSocketType = SOCK_DGRAM;
            }
            sendtoRequest.ReceivePort = (NAME_REMOTE_2 != sendtoTable[dwTableIndex].dwName) || (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) ? CurrentPort : CurrentPort + 1;
            sendtoRequest.SendPort = (TRUE == sendtoTable[dwTableIndex].bBind) ? CurrentPort : 0;
            sendtoRequest.bServerAccept = sendtoTable[dwTableIndex].bConnect;
            sendtoRequest.bFillQueue = sendtoTable[dwTableIndex].bFillQueue;
            sendtoRequest.nQueueLen = 0;
            sendtoRequest.bRemoteClose = sendtoTable[dwTableIndex].bRemoteClose;
            if (100 == sendtoTable[dwTableIndex].nDataBuffers) {
                sendtoRequest.nDataBuffers = sendtoTable[dwTableIndex].nDataBuffers * SendToBufferTableCount;
            }
            else {
                sendtoRequest.nDataBuffers = (0 == sendtoTable[dwTableIndex].iReturnCode) ? sendtoTable[dwTableIndex].nDataBuffers : 0;
            }
            sendtoRequest.nBufferlen = sendtoTable[dwTableIndex].nBufferlen;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == sendtoTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename1, sizeof(remotename1));
                remotename1.sin_family = AF_INET;
                remotename1.sin_addr.s_addr = NetsyncInAddr;
                remotename1.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename1, sizeof(remotename1));

                if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else if (TRUE == sendtoTable[dwTableIndex].bAccept) {
                if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == sendtoTable[dwTableIndex].bFillQueue) {
                if (FALSE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                // Fill the queue
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                    sendtoRequest.nQueueLen++;
                    Sleep(SLEEP_ZERO_TIME);
                }
            }

            if (TRUE == sendtoTable[dwTableIndex].bRemoteClose) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Shutdown the connection
        if (TRUE == sendtoTable[dwTableIndex].bShutdown) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, sendtoTable[dwTableIndex].nShutdown);
        }

        // Set the remote name
        ZeroMemory(&remotename1, sizeof(remotename1));
        remotename1.sin_family = AF_INET;

        if (NAME_ANYADDR == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_ANYPORT == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = NetsyncInAddr;
        }
        else if (NAME_LOCAL == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = hostaddr;
            remotename1.sin_port = htons(CurrentPort + 1);
        }
        else if (NAME_LOOPBACK == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            remotename1.sin_port = htons(CurrentPort + 1);
        }
        else if (NAME_BROADCAST == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = htonl(INADDR_BROADCAST);
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_MULTICAST == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = inet_addr("224.0.0.0");
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_UNAVAIL == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = inet_addr("127.0.0.0");
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_BAD == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_family = AF_UNIX;
            remotename1.sin_addr.s_addr = NetsyncInAddr;
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_REMOTE_1 == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = NetsyncInAddr;
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_REMOTE_2 == sendtoTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = NetsyncInAddr;
            remotename1.sin_port = htons(CurrentPort + 1);
        }

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);
        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
        }
        if (BUFFER_10 == sendtoTable[dwTableIndex].dwBuffer) {
            Buffer = SendBuffer10;
        }
        else if (BUFFER_LARGE == sendtoTable[dwTableIndex].dwBuffer) {
            Buffer = SendBufferLarge;
        }
        else {
            Buffer = NULL;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & sendtoTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call sendto
            iReturnCode = sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, sendtoTable[dwTableIndex].nBufferlen, sendtoTable[dwTableIndex].nFlags, (NAME_NULL != sendtoTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, sendtoTable[dwTableIndex].namelen);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == sendtoTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "sendto RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "sendto caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == sendtoTable[dwTableIndex].bFillQueue) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "sendto returned non-SOCKET_ERROR");
                }
                else {
                    // Get the last error code
                    iLastError = WSAGetLastError();

                    if (iLastError != WSAEWOULDBLOCK) {
                        xLog(hLog, XLL_FAIL, "sendto iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                    }
                }

                // Send the read request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);

                // Wait for the read complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                if (FALSE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
                else {
                    FD_ZERO(&writefds);
                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }

                // Call sendto
                iReturnCode = sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, sendtoTable[dwTableIndex].nBufferlen, sendtoTable[dwTableIndex].nFlags, (NAME_NULL != sendtoTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, sendtoTable[dwTableIndex].namelen);
            }

            if (TRUE == sendtoTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "sendto did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == sendtoTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != sendtoTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "sendto iLastError - EXPECTED: %u; RECEIVED: %u", sendtoTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "sendto iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "sendto returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (0 != sendtoRequest.nDataBuffers) {
                    // Send the send cancel
                    sendtoRequest.dwMessageId = SENDTO_CANCEL_MSG;
                    sendtoRequest.nDataBuffers = 0;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);
                }
            }
            else if (SOCKET_ERROR == sendtoTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "sendto returned non-SOCKET_ERROR");
            }
            else {
                if (sendtoTable[dwTableIndex].nBufferlen != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "sendto return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, iReturnCode);
                    bTestPassed = FALSE;
                }

                if ((NAME_REMOTE_2 == sendtoTable[dwTableIndex].dwName) && (0 != (SOCKET_UDP & sendtoTable[dwTableIndex].dwSocket))) {
                    // Reset the default connection
                    ZeroMemory(&remotename2, sizeof(remotename2));
                    remotename2.sin_family = AF_INET;

                    connect(sSocket, (SOCKADDR *) &remotename2, sizeof(remotename2));
                }

                // Send the read request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);

                // Wait for the read complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                if ((TRUE != sendtoTable[dwTableIndex].bFillQueue) && (TRUE != sendtoTable[dwTableIndex].bShutdown)) {
                    // Call recv/recvfrom
                    if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
                        if (0 != sendtoTable[dwTableIndex].nBufferlen) {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                            nBytes = 0;

                            do {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                if (1 == iReturnCode) {
                                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                }
                                else if (0 == iReturnCode) {
                                    iReturnCode = SOCKET_ERROR;
                                    SetLastError(WSAETIMEDOUT);
                                }

                                if (SOCKET_ERROR != iReturnCode) {
                                    nBytes += iReturnCode;
                                }
                            } while (SOCKET_ERROR != iReturnCode);

                            if (WSAETIMEDOUT != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (sendtoTable[dwTableIndex].nBufferlen != nBytes) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, nBytes);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(RecvBufferLarge, Buffer, sendtoTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                    else {
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        if (TRUE == bNonblocking) {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                            select(0, &readfds, NULL, NULL, NULL);
                        }

                        iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0, NULL, NULL);
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv/recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else if (sendtoTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv/recvfrom return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(RecvBufferLarge, Buffer, sendtoTable[dwTableIndex].nBufferlen)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (3 == sendtoTable[dwTableIndex].nDataBuffers) {
                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }
                    if (BUFFER_10 == sendtoTable[dwTableIndex].dwBuffer) {
                        Buffer = SendBuffer10;
                    }
                    else if (BUFFER_LARGE == sendtoTable[dwTableIndex].dwBuffer) {
                        Buffer = SendBufferLarge;
                    }
                    else {
                        Buffer = NULL;
                    }

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call sendto
                    iReturnCode = sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, sendtoTable[dwTableIndex].nBufferlen, sendtoTable[dwTableIndex].nFlags, (NAME_NULL != sendtoTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, sendtoTable[dwTableIndex].namelen);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "sendto returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        sendtoRequest.dwMessageId = SENDTO_CANCEL_MSG;
                    }
                    else {
                        if (sendtoTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "sendto return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }

                        sendtoRequest.dwMessageId = SENDTO_REQUEST_MSG;
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (SOCKET_ERROR != iReturnCode) {
                        // Call recv/recvfrom
                        if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
                            if (0 != sendtoTable[dwTableIndex].nBufferlen) {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                    }
                                    else if (0 == iReturnCode) {
                                        iReturnCode = SOCKET_ERROR;
                                        SetLastError(WSAETIMEDOUT);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while (SOCKET_ERROR != iReturnCode);

                                if (WSAETIMEDOUT != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (sendtoTable[dwTableIndex].nBufferlen != nBytes) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, nBytes);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(RecvBufferLarge, Buffer, sendtoTable[dwTableIndex].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                        else {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0, NULL, NULL);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv/recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (sendtoTable[dwTableIndex].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv/recvfrom return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(RecvBufferLarge, Buffer, sendtoTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 3, 3);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }
                    if (BUFFER_10 == sendtoTable[dwTableIndex].dwBuffer) {
                        Buffer = SendBuffer10;
                    }
                    else if (BUFFER_LARGE == sendtoTable[dwTableIndex].dwBuffer) {
                        Buffer = SendBufferLarge;
                    }
                    else {
                        Buffer = NULL;
                    }

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call sendto
                    iReturnCode = sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, sendtoTable[dwTableIndex].nBufferlen, sendtoTable[dwTableIndex].nFlags, (NAME_NULL != sendtoTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, sendtoTable[dwTableIndex].namelen);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "sendto returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        sendtoRequest.dwMessageId = SENDTO_CANCEL_MSG;
                    }
                    else {
                        if (sendtoTable[dwTableIndex].nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "sendto return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }

                        sendtoRequest.dwMessageId = SENDTO_REQUEST_MSG;
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (SOCKET_ERROR != iReturnCode) {
                        // Call recv/recvfrom
                        if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
                            if (0 != sendtoTable[dwTableIndex].nBufferlen) {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                    }
                                    else if (0 == iReturnCode) {
                                        iReturnCode = SOCKET_ERROR;
                                        SetLastError(WSAETIMEDOUT);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while (SOCKET_ERROR != iReturnCode);

                                if (WSAETIMEDOUT != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (sendtoTable[dwTableIndex].nBufferlen != nBytes) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, nBytes);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(RecvBufferLarge, Buffer, sendtoTable[dwTableIndex].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                        else {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0, NULL, NULL);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv/recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (sendtoTable[dwTableIndex].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv/recvfrom return value - EXPECTED: %d; RECEIVED: %d", sendtoTable[dwTableIndex].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(RecvBufferLarge, Buffer, sendtoTable[dwTableIndex].nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }
                else if (100 == sendtoTable[dwTableIndex].nDataBuffers) {
                    for (nSendCount = 0; nSendCount < (int) (sendtoTable[dwTableIndex].nDataBuffers * SendToBufferTableCount); nSendCount++) {
                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 2 + nSendCount, 2 + nSendCount);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }
                        if (BUFFER_LARGE == SendToBufferTable[nSendCount % SendToBufferTableCount].dwBuffer) {
                            Buffer = SendBufferLarge;
                        }
                        else if (BUFFER_10 == SendToBufferTable[nSendCount % SendToBufferTableCount].dwBuffer) {
                            Buffer = SendBuffer10;
                        }
                        else {
                            Buffer = NULL;
                        }

                        xLog(hLog, XLL_INFO, "Iteration %d", nSendCount);

                        // Call sendto
                        iReturnCode = sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, Buffer, SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen, 0, (NAME_NULL != sendtoTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, sendtoTable[dwTableIndex].namelen);

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "sendto returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                            sendtoRequest.dwMessageId = SENDTO_CANCEL_MSG;
                        }
                        else {
                            if (SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "sendto return value - EXPECTED: %d; RECEIVED: %d", SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }

                            sendtoRequest.dwMessageId = SENDTO_REQUEST_MSG;
                        }

                        // Send the read request
                        sendtoRequest.nBufferlen = SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen;
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);

                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        if (SOCKET_ERROR != iReturnCode) {
                            // Call recv/recvfrom
                            if (0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) {
                                if (0 != SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen) {
                                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                    nBytes = 0;

                                    do {
                                        FD_ZERO(&readfds);
                                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                        iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                        if (1 == iReturnCode) {
                                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                        }
                                        else if (0 == iReturnCode) {
                                            iReturnCode = SOCKET_ERROR;
                                            SetLastError(WSAETIMEDOUT);
                                        }

                                        if (SOCKET_ERROR != iReturnCode) {
                                            nBytes += iReturnCode;
                                        }
                                    } while (SOCKET_ERROR != iReturnCode);

                                    if (WSAETIMEDOUT != WSAGetLastError()) {
                                        xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                        bTestPassed = FALSE;
                                    }
                                    else if (SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen != nBytes) {
                                        xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen, nBytes);
                                        bTestPassed = FALSE;
                                    }
                                    else if (0 != strncmp(RecvBufferLarge, Buffer, SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen)) {
                                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                        bTestPassed = FALSE;
                                    }
                                }
                            }
                            else {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                                if (TRUE == bNonblocking) {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                    select(0, &readfds, NULL, NULL, NULL);
                                }

                                iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0, NULL, NULL);
                                if (SOCKET_ERROR == iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv/recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv/recvfrom return value - EXPECTED: %d; RECEIVED: %d", SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen, iReturnCode);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(RecvBufferLarge, Buffer, SendToBufferTable[nSendCount % SendToBufferTableCount].nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "sendto succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (sendtoTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == sendtoTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            bNonblocking = sendtoTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == sendtoTable[dwTableIndex].bAccept) || (TRUE == sendtoTable[dwTableIndex].bConnect) || (0 == sendtoTable[dwTableIndex].iReturnCode)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(sendtoRequest), (char *) &sendtoRequest);
        }

        // Close the socket
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & sendtoTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & sendtoTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & sendtoTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort += 2;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
sendtoTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests sendto - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long           FromInAddr;
    // dwMessageType is the type of received message
    DWORD            dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD            dwMessageSize;
    // pMessage is a pointer to the received message
    char             *pMessage;
    // sendtoRequest is the request
    SENDTO_REQUEST   sendtoRequest;
    // sendtoComplete is the result
    SENDTO_COMPLETE  sendtoComplete;

    // sSocket is the socket descriptor
    SOCKET           sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET           nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD            dwBufferSize = 1;
    // iTimeout is the send and receive timeout value for the socket
    int              iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL             bNagle = FALSE;
    // nQueueLen is the size of the queue
    int              nQueueLen;

    // localname is the local address
    SOCKADDR_IN      localname;
    // remotename is the remote address
    SOCKADDR_IN      remotename;
    // namelen is the size of namelen
    int              namelen;

    // readfds is the set of sockets to check for a read condition
    fd_set           readfds;
    // timeout is the timeout for select
    timeval          fdstimeout = { 1, 0 };

    // SendBufferLarge is the large send buffer
    char             SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // nBytes is the number of bytes sent/received
    int              nBytes;
    // nSendCount is a counter to enumerate each send
    int              nSendCount;

    // iReturnCode is the return code of the operation
    int              iReturnCode;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&sendtoRequest, pMessage, sizeof(sendtoRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, sendtoRequest.nSocketType, 0);

        if (TRUE == sendtoRequest.bFillQueue) {
            // Set the buffer size
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == sendtoRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(sendtoRequest.ReceivePort);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if (SOCK_STREAM == sendtoRequest.nSocketType) {
            if (TRUE == sendtoRequest.bServerAccept) {
                // Place the socket in listening mode
                listen(sSocket, SOMAXCONN);
            }
            else {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = FromInAddr;
                remotename.sin_port = htons(sendtoRequest.SendPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
            }
        }

        // Send the complete
        sendtoComplete.dwMessageId = SENDTO_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendtoComplete), (char *) &sendtoComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == sendtoRequest.nSocketType) && (TRUE == sendtoRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == sendtoRequest.bRemoteClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
                closesocket(nsSocket);
                nsSocket = INVALID_SOCKET;
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
                sSocket = INVALID_SOCKET;
            }
        }

        // Send the complete
        sendtoComplete.dwMessageId = SENDTO_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendtoComplete), (char *) &sendtoComplete);

        if (TRUE == sendtoRequest.bFillQueue) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            nQueueLen = ((PSENDTO_REQUEST) pMessage)->nQueueLen;
            CopyMemory(&sendtoRequest, pMessage, sizeof(sendtoRequest));
            NetsyncFreeMessage(pMessage);

            if (SENDTO_CANCEL_MSG != sendtoRequest.dwMessageId) {
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                for (nSendCount = 0; nSendCount < nQueueLen; nSendCount++) {
                    recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0);
                }
            }

            // Send the complete
            sendtoComplete.dwMessageId = SENDTO_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendtoComplete), (char *) &sendtoComplete);
        }

        if (0 < sendtoRequest.nDataBuffers) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            CopyMemory(&sendtoRequest, pMessage, sizeof(sendtoRequest));
            NetsyncFreeMessage(pMessage);

            if ((SENDTO_CANCEL_MSG != sendtoRequest.dwMessageId) && ((0 != sendtoRequest.nBufferlen) || (SOCK_STREAM != sendtoRequest.nSocketType))) {
                if (SOCK_DGRAM == sendtoRequest.nSocketType) {
                    ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                    ZeroMemory(&remotename, sizeof(remotename));
                    namelen = sizeof(remotename);

                    if (SOCKET_ERROR != recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0, (SOCKADDR *) &remotename, &namelen)) {
                        remotename.sin_addr.s_addr = FromInAddr;
                        sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0, (SOCKADDR *) &remotename, sizeof(remotename));
                    }
                }
                else {
                    ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                    nBytes = 0;

                    do {
                        FD_ZERO(&readfds);
                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                        iReturnCode = SOCKET_ERROR;
                        if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], 10, 0);
                        }

                        if (SOCKET_ERROR != iReturnCode) {
                            nBytes += iReturnCode;
                        }
                    } while ((SOCKET_ERROR != iReturnCode) && (nBytes < sendtoRequest.nBufferlen));

                    if (nBytes == sendtoRequest.nBufferlen) {
                        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                    }
                }
            }

            // Send the complete
            sendtoComplete.dwMessageId = SENDTO_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendtoComplete), (char *) &sendtoComplete);

            if (3 == sendtoRequest.nDataBuffers) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                if (SENDTO_CANCEL_MSG != ((PSENDTO_REQUEST) pMessage)->dwMessageId) {
                    if (SOCK_DGRAM == sendtoRequest.nSocketType) {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        ZeroMemory(&remotename, sizeof(remotename));
                        namelen = sizeof(remotename);

                        if (SOCKET_ERROR != recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0, (SOCKADDR *) &remotename, &namelen)) {
                            remotename.sin_addr.s_addr = FromInAddr;
                            sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0, (SOCKADDR *) &remotename, sizeof(remotename));
                        }
                    }
                    else {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        nBytes = 0;

                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = SOCKET_ERROR;
                            if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], 10, 0);
                            }

                            if (SOCKET_ERROR != iReturnCode) {
                                nBytes += iReturnCode;
                            }
                        } while ((SOCKET_ERROR != iReturnCode) && (nBytes < sendtoRequest.nBufferlen));

                        if (nBytes == sendtoRequest.nBufferlen) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                        }
                    }
                }
                NetsyncFreeMessage(pMessage);

                // Send the complete
                sendtoComplete.dwMessageId = SENDTO_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendtoComplete), (char *) &sendtoComplete);

                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                if (SENDTO_CANCEL_MSG != ((PSENDTO_REQUEST) pMessage)->dwMessageId) {
                    if (SOCK_DGRAM == sendtoRequest.nSocketType) {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        ZeroMemory(&remotename, sizeof(remotename));
                        namelen = sizeof(remotename);

                        if (SOCKET_ERROR != recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0, (SOCKADDR *) &remotename, &namelen)) {
                            remotename.sin_addr.s_addr = FromInAddr;
                            sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0, (SOCKADDR *) &remotename, sizeof(remotename));
                        }
                    }
                    else {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        nBytes = 0;

                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = SOCKET_ERROR;
                            if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], 10, 0);
                            }

                            if (SOCKET_ERROR != iReturnCode) {
                                nBytes += iReturnCode;
                            }
                        } while ((SOCKET_ERROR != iReturnCode) && (nBytes < sendtoRequest.nBufferlen));

                        if (nBytes == sendtoRequest.nBufferlen) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                        }
                    }
                }
                NetsyncFreeMessage(pMessage);

                // Send the complete
                sendtoComplete.dwMessageId = SENDTO_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendtoComplete), (char *) &sendtoComplete);
            }
            else if (100 <= sendtoRequest.nDataBuffers) {
                for (nSendCount = 0; nSendCount < sendtoRequest.nDataBuffers; nSendCount++) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if ((0 != ((PSENDTO_REQUEST) pMessage)->nBufferlen) || (SOCK_STREAM != sendtoRequest.nSocketType)) {
                        if (SENDTO_CANCEL_MSG != ((PSENDTO_REQUEST) pMessage)->dwMessageId) {
                            if (SOCK_DGRAM == sendtoRequest.nSocketType) {
                                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                                ZeroMemory(&remotename, sizeof(remotename));
                                namelen = sizeof(remotename);

                                if (SOCKET_ERROR != recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0, (SOCKADDR *) &remotename, &namelen)) {
                                    remotename.sin_addr.s_addr = FromInAddr;
                                    sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0, (SOCKADDR *) &remotename, sizeof(remotename));
                                }
                            }
                            else {
                                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = SOCKET_ERROR;
                                    if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], 10, 0);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while ((SOCKET_ERROR != iReturnCode) && (nBytes < ((PSENDTO_REQUEST) pMessage)->nBufferlen));

                                if (nBytes == ((PSENDTO_REQUEST) pMessage)->nBufferlen) {
                                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                                }
                            }
                        }
                    }
                    NetsyncFreeMessage(pMessage);

                    // Send the complete
                    sendtoComplete.dwMessageId = SENDTO_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(sendtoComplete), (char *) &sendtoComplete);
                }
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\shutdown.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  shutdown.c

Abstract:

  This modules tests shutdown

Author:

  Steven Kehrli (steveke) 8-Mar-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// shutdown messages

#define SHUTDOWN_REQUEST_MSG   NETSYNC_MSG_USER + 280 + 1
#define SHUTDOWN_COMPLETE_MSG  NETSYNC_MSG_USER + 280 + 2

typedef struct _SHUTDOWN_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bServerConnect;
    BOOL     bServerFirstSend;
    BOOL     bServerSecondSend;
} SHUTDOWN_REQUEST, *PSHUTDOWN_REQUEST;

typedef struct _SHUTDOWN_COMPLETE {
    DWORD    dwMessageId;
} SHUTDOWN_COMPLETE, *PSHUTDOWN_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define SHUTDOWN_SEND     0x01
#define SHUTDOWN_RECEIVE  0x02
#define SHUTDOWN_BOTH     0x03

#define SHUTDOWN_INT_MIN  0x10
#define SHUTDOWN_NEG_ONE  0x20
#define SHUTDOWN_INT_MAX  0x30
#define SHUTDOWN_THREE    0x40



typedef struct SHUTDOWN_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    BOOL   bServerAccept;                           // bServerAccept indicates if server accepts
    BOOL   bServerConnect;                          // bServerConnect indicates if server connects
    BOOL   bServerFirstSend;                        // bServerFirstSend indicates if server sends data
    BOOL   bServerSecondSend;                       // bServerSecondSend indicates if server sends data
    DWORD  dwHow1;                                  // dwHow1 specifies how to shutdown the socket
    DWORD  dwHow2;                                  // dwHow2 specifies how to shutdown the socket
    DWORD  dwHow3;                                  // dwHow3 specifies how to shutdown the socket
    int    iReturnCode;                             // iReturnCode is the return code of shutdown
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} SHUTDOWN_TABLE, *PSHUTDOWN_TABLE;

static SHUTDOWN_TABLE shutdownTable[] =
{
    { "28.1 Not Initialized",         FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "28.2 s = INT_MIN",             TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "28.3 s = -1",                  TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "28.4 s = 0",                   TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "28.5 s = INT_MAX",             TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "28.6 s = INVALID_SOCKET",      TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "28.7 Not Connected Send",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, SHUTDOWN_SEND,    0,                0,                SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "28.8 Not Connected Receive",   TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, SHUTDOWN_RECEIVE, 0,                0,                SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "28.9 Not Connected Both",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "28.10 Connected Send",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_SEND,    0,                0,                0,            0,                 FALSE },
    { "28.11 Connected Send Data",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, SHUTDOWN_SEND,    0,                0,                0,            0,                 FALSE },
    { "28.12 Connected Receive",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_RECEIVE, 0,                0,                0,            0,                 FALSE },
    { "28.13 Connected Receive Data", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, SHUTDOWN_RECEIVE, 0,                0,                0,            0,                 FALSE },
    { "28.14 Connected Receive 2",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  SHUTDOWN_RECEIVE, 0,                0,                0,            0,                 FALSE },
    { "28.15 Connected Both",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                0,            0,                 FALSE },
    { "28.16 Connected Both Data",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, TRUE,  FALSE, SHUTDOWN_BOTH,    0,                0,                0,            0,                 FALSE },
    { "28.17 Connected Both 2",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, TRUE,  SHUTDOWN_BOTH,    0,                0,                0,            0,                 FALSE },
    { "28.18 Accepted Send",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_SEND,    0,                0,                0,            0,                 FALSE },
    { "28.19 Accepted Send Data",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, SHUTDOWN_SEND,    0,                0,                0,            0,                 FALSE },
    { "28.20 Accepted Receive",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_RECEIVE, 0,                0,                0,            0,                 FALSE },
    { "28.21 Accepted Receive Data",  TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, SHUTDOWN_RECEIVE, 0,                0,                0,            0,                 FALSE },
    { "28.22 Accepted Receive 2",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, TRUE,  SHUTDOWN_RECEIVE, 0,                0,                0,            0,                 FALSE },
    { "28.23 Accepted Both",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                0,            0,                 FALSE },
    { "28.24 Accepted Both Data",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, SHUTDOWN_BOTH,    0,                0,                0,            0,                 FALSE },
    { "28.25 Accepted Both 2",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, TRUE,  SHUTDOWN_BOTH,    0,                0,                0,            0,                 FALSE },
    { "28.26 Connected SRB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_SEND,    SHUTDOWN_RECEIVE, SHUTDOWN_BOTH,    0,            0,                 FALSE },
    { "28.27 Accepted SRB",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_SEND,    SHUTDOWN_RECEIVE, SHUTDOWN_BOTH,    0,            0,                 FALSE },
    { "28.28 Connected SBR",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_SEND,    SHUTDOWN_BOTH,    SHUTDOWN_RECEIVE, 0,            0,                 FALSE },
    { "28.29 Accepted SBR",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_SEND,    SHUTDOWN_BOTH,    SHUTDOWN_RECEIVE, 0,            0,                 FALSE },
    { "28.30 Connected RSB",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_RECEIVE, SHUTDOWN_SEND,    SHUTDOWN_BOTH,    0,            0,                 FALSE },
    { "28.31 Accepted RSB",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_RECEIVE, SHUTDOWN_SEND,    SHUTDOWN_BOTH,    0,            0,                 FALSE },
    { "28.32 Connected RBS",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_RECEIVE, SHUTDOWN_BOTH,    SHUTDOWN_SEND,    0,            0,                 FALSE },
    { "28.33 Accepted RBS",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_RECEIVE, SHUTDOWN_BOTH,    SHUTDOWN_SEND,    0,            0,                 FALSE },
    { "28.34 Connected BSR",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    SHUTDOWN_SEND,    SHUTDOWN_RECEIVE, 0,            0,                 FALSE },
    { "28.35 Accepted BSR",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_BOTH,    SHUTDOWN_SEND,    SHUTDOWN_RECEIVE, 0,            0,                 FALSE },
    { "28.36 Connected BRS",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    SHUTDOWN_RECEIVE, SHUTDOWN_SEND,    0,            0,                 FALSE },
    { "28.37 Accepted BRS",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, SHUTDOWN_BOTH,    SHUTDOWN_RECEIVE, SHUTDOWN_SEND,    0,            0,                 FALSE },
    { "28.38 UDP Send",               TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_SEND,    0,                0,                0,            0,                 FALSE },
    { "28.39 UDP Send Data",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  TRUE,  FALSE, SHUTDOWN_SEND,    0,                0,                0,            0,                 FALSE },
    { "28.40 UDP Receive",            TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_RECEIVE, 0,                0,                0,            0,                 FALSE },
    { "28.41 UDP Receive Data",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  TRUE,  FALSE, SHUTDOWN_RECEIVE, 0,                0,                0,            0,                 FALSE },
    { "28.42 UDP Both",               TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                0,            0,                 FALSE },
    { "28.43 UDP Both Data",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  TRUE,  FALSE, SHUTDOWN_BOTH,    0,                0,                0,            0,                 FALSE },
    { "28.44 UDP SRB",                TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_SEND,    SHUTDOWN_RECEIVE, SHUTDOWN_BOTH,    0,            0,                 FALSE },
    { "28.45 UDP SBR",                TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_SEND,    SHUTDOWN_BOTH,    SHUTDOWN_RECEIVE, 0,            0,                 FALSE },
    { "28.46 UDP RSB",                TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_RECEIVE, SHUTDOWN_SEND,    SHUTDOWN_BOTH,    0,            0,                 FALSE },
    { "28.47 UDP RBS",                TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_RECEIVE, SHUTDOWN_BOTH,    SHUTDOWN_SEND,    0,            0,                 FALSE },
    { "28.48 UDP BSR",                TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_BOTH,    SHUTDOWN_SEND,    SHUTDOWN_RECEIVE, 0,            0,                 FALSE },
    { "28.49 UDP BRS",                TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_BOTH,    SHUTDOWN_RECEIVE, SHUTDOWN_SEND,    0,            0,                 FALSE },
    { "28.50 how = INT_MIN TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_INT_MIN, 0,                0,                SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "28.51 how = -1 TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_NEG_ONE, 0,                0,                SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "28.52 how = INT_MAX TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_INT_MAX, 0,                0,                SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "28.53 how = 3 TCP",            TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, SHUTDOWN_THREE,   0,                0,                SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "28.54 how = INT_MIN UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_INT_MIN, 0,                0,                SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "28.55 how = -1 UDP",           TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_NEG_ONE, 0,                0,                SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "28.56 how = INT_MAX UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_INT_MAX, 0,                0,                SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "28.57 how = 3 UDP",            TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, SHUTDOWN_THREE,   0,                0,                SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "28.58 Closed Socket TCP",      TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "28.59 Closed Socket UDP",      TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "28.60 Not Initialized",        FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, SHUTDOWN_BOTH,    0,                0,                SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define shutdownTableCount (sizeof(shutdownTable) / sizeof(SHUTDOWN_TABLE))

NETSYNC_TYPE_THREAD  shutdownTestSessionNt =
{
    1,
    shutdownTableCount,
    L"xnetapi_nt.dll",
    "shutdownTestServer"
};

NETSYNC_TYPE_THREAD  shutdownTestSessionXbox =
{
    1,
    shutdownTableCount,
    L"xnetapi_xbox.dll",
    "shutdownTestServer"
};



VOID
shutdownTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests shutdown - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // shutdownRequest is the request sent to the server
    SHUTDOWN_REQUEST       shutdownRequest;
    
    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                  dwBufferSize = BUFFER_10_LEN;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                   RecvBuffer10[BUFFER_10_LEN + 1];
    // dwHow specifies how the socket is shutdown
    DWORD                  dwHow;

    // hSendEvent is a handle to the overlapped send event
    HANDLE                 hSendEvent;
    // WSASendOverlapped is the overlapped send structure
    WSAOVERLAPPED          WSASendOverlapped;
    // WSASendBuf is the WSABUF structure
    WSABUF                 WSASendBuf;
    // dwSendBytes is the number of bytes transferred for the function call
    DWORD                  dwSendBytes;
    // dwSendFlags is the transfer flags for the function call
    DWORD                  dwSendFlags;

    // hReceiveEvent is a handle to the overlapped receive event
    HANDLE                 hReceiveEvent;
    // WSAReceiveOverlapped is the overlapped receive structure
    WSAOVERLAPPED          WSAReceiveOverlapped;
    // WSAReceiveBuf is the WSABUF structure
    WSABUF                 WSAReceiveBuf;
    // dwReceiveBytes is the number of bytes transferred for the function call
    DWORD                  dwReceiveBytes;
    // dwReceiveFlags is the transfer flags for the function call
    DWORD                  dwReceiveFlags;

    // bReturnCode is the return code of WSAGetOverlappedResult
    BOOL                   bReturnCode;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "shutdown v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_shutdown+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_shutdown-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = shutdownTestSessionXbox;
    }
    else {
        NetsyncTypeSession = shutdownTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < shutdownTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, shutdownTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, shutdownTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != shutdownTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, shutdownTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == shutdownTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != shutdownTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == shutdownTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = shutdownTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == shutdownTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the overlapped event
        hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hReceiveEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        // Setup the overlapped structure
        ZeroMemory(&WSASendOverlapped, sizeof(WSASendOverlapped));
        WSASendOverlapped.hEvent = hSendEvent;

        ZeroMemory(&WSAReceiveOverlapped, sizeof(WSAReceiveOverlapped));
        WSAReceiveOverlapped.hEvent = hReceiveEvent;

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == shutdownTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == shutdownTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == shutdownTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == shutdownTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == shutdownTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & shutdownTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        if ((0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & shutdownTable[dwTableIndex].dwSocket))) {
            // Set the buffer size
            dwBufferSize = 10;
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            dwBufferSize = 10;
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            // Bind the socket
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

            if ((FALSE == shutdownTable[dwTableIndex].bServerAccept) && (TRUE == shutdownTable[dwTableIndex].bServerConnect)) {
                listen(sSocket, SOMAXCONN);
            }
        }

        if ((TRUE == shutdownTable[dwTableIndex].bServerConnect) || (TRUE == shutdownTable[dwTableIndex].bServerAccept)) {
            // Initialize the shutdown request
            shutdownRequest.dwMessageId = SHUTDOWN_REQUEST_MSG;
            if (0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) {
                shutdownRequest.nSocketType = SOCK_STREAM;
            }
            else {
                shutdownRequest.nSocketType = SOCK_DGRAM;
            }
            shutdownRequest.Port = CurrentPort;
            shutdownRequest.bServerConnect = shutdownTable[dwTableIndex].bServerConnect;
            shutdownRequest.bServerFirstSend = shutdownTable[dwTableIndex].bServerFirstSend;
            shutdownRequest.bServerSecondSend = shutdownTable[dwTableIndex].bServerSecondSend;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(shutdownRequest), (char *) &shutdownRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            // Connect the socket
            if (TRUE == shutdownTable[dwTableIndex].bServerAccept) {
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
            }
            else {
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(shutdownRequest), (char *) &shutdownRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            // Start the pending overlapped operation
            if ((0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) && (0 != (SHUTDOWN_SEND & shutdownTable[dwTableIndex].dwHow1))) {
                // Fill the queue
                Nonblock = 1;
                ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);

                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                    Sleep(SLEEP_ZERO_TIME);
                }

                Nonblock = 0;
                ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);

                // Call WSASend
                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                WSASendBuf.len = 10;
                WSASendBuf.buf = SendBuffer10;
                dwSendBytes = 0;

                iReturnCode = WSASend((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSASendBuf, 1, &dwSendBytes, 0, &WSASendOverlapped, NULL);

                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSASend returned non-SOCKET_ERROR");
                }
                else if (WSA_IO_PENDING != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "WSASend iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
                }
            }

            if ((FALSE == shutdownTable[dwTableIndex].bServerFirstSend) && (0 != (SHUTDOWN_RECEIVE & shutdownTable[dwTableIndex].dwHow1))) {
                // Call WSARecv
                ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                WSAReceiveBuf.len = sizeof(RecvBuffer10);
                WSAReceiveBuf.buf = RecvBuffer10;
                dwReceiveBytes = 0;
                dwReceiveFlags = 0;

                iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAReceiveBuf, 1, &dwReceiveBytes, &dwReceiveFlags, &WSAReceiveOverlapped, NULL);

                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
                }
                else if (WSA_IO_PENDING != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
                }
            }

            if (TRUE == shutdownTable[dwTableIndex].bServerFirstSend) {
                ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0);

                FD_ZERO(&readfds);
                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                select(0, &readfds, NULL, NULL, NULL);
            }
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & shutdownTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            if (SHUTDOWN_SEND == shutdownTable[dwTableIndex].dwHow1) {
                iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_SEND);
            }
            else if (SHUTDOWN_RECEIVE == shutdownTable[dwTableIndex].dwHow1) {
                iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_RECEIVE);
            }
            else if (SHUTDOWN_BOTH == shutdownTable[dwTableIndex].dwHow1) {
                iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_BOTH);
            }
            else if (SHUTDOWN_INT_MIN == shutdownTable[dwTableIndex].dwHow1) {
                iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, INT_MIN);
            }
            else if (SHUTDOWN_NEG_ONE == shutdownTable[dwTableIndex].dwHow1) {
                iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, -1);
            }
            else if (SHUTDOWN_INT_MAX == shutdownTable[dwTableIndex].dwHow1) {
                iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, INT_MAX);
            }
            else if (SHUTDOWN_THREE == shutdownTable[dwTableIndex].dwHow1) {
                iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, 3);
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == shutdownTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "shutdown RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "shutdown caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == shutdownTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "shutdown did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == shutdownTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != shutdownTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "shutdown1 iLastError - EXPECTED: %u; RECEIVED: %u", shutdownTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "shutdown1 iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "shutdown1 returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == shutdownTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "shutdown1 returned non-SOCKET_ERROR");
            }
            else {
                dwHow = shutdownTable[dwTableIndex].dwHow1;

                if (0 != (SHUTDOWN_RECEIVE & dwHow)) {
                    if (FALSE == shutdownTable[dwTableIndex].bServerFirstSend) {
                        bReturnCode = WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAReceiveOverlapped, &dwReceiveBytes, TRUE, &dwReceiveFlags);

                        if (FALSE != bReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult receive returned TRUE");
                            bTestPassed = FALSE;
                        }
                        else if (WSAESHUTDOWN != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult receive iLastError - EXPECTED: %u; RECEIVED: %u", WSAESHUTDOWN, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }

                    ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0);

                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "recv1a returned non-SOCKET_ERROR");
                        bTestPassed = FALSE;
                    }
                    else if ((0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) && (TRUE == shutdownTable[dwTableIndex].bServerFirstSend)) {
                        if (WSAECONNRESET != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "recv1a iLastError - EXPECTED: %u; RECEIVED: %u", WSAECONNRESET, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (WSAESHUTDOWN != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "recv1a iLastError - EXPECTED: %u; RECEIVED: %u", WSAESHUTDOWN, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }
                }
                else if (TRUE == shutdownTable[dwTableIndex].bServerFirstSend) {
                    ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "recv1a returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                }

                if (0 != (SHUTDOWN_SEND & dwHow)) {
                    if (0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) {
                        bReturnCode = WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSASendOverlapped, &dwSendBytes, TRUE, &dwSendFlags);

                        if (FALSE != bReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult send returned TRUE");
                            bTestPassed = FALSE;
                        }
                        else if ((SHUTDOWN_BOTH == dwHow) && (TRUE == shutdownTable[dwTableIndex].bServerFirstSend)) {
                            if (WSAECONNRESET != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult send iLastError - EXPECTED: %u; RECEIVED: %u", WSAECONNRESET, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (WSAESHUTDOWN != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult send iLastError - EXPECTED: %u; RECEIVED: %u", WSAESHUTDOWN, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                    iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "send1a returned non-SOCKET_ERROR");
                        bTestPassed = FALSE;
                    }
                    else if ((0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) && (SHUTDOWN_BOTH == dwHow) && (TRUE == shutdownTable[dwTableIndex].bServerFirstSend)) {
                        if (WSAECONNRESET != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "send1a iLastError - EXPECTED: %u; RECEIVED: %u", WSAECONNRESET, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (WSAESHUTDOWN != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "send1a iLastError - EXPECTED: %u; RECEIVED: %u", WSAESHUTDOWN, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }
                }
                else if ((0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) && (TRUE == shutdownTable[dwTableIndex].bServerFirstSend) && (0 != (SHUTDOWN_RECEIVE & dwHow))) {
                    ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                    iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "send1a returned non-SOCKET_ERROR");
                        bTestPassed = FALSE;
                    }
                    else if (WSAECONNRESET != WSAGetLastError()) {
                        xLog(hLog, XLL_FAIL, "send1a iLastError - EXPECTED: %u; RECEIVED: %u", WSAECONNRESET, WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                }
                else {
                    ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                    iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "send1a returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                }

                if ((0 != (SHUTDOWN_RECEIVE & dwHow)) && (TRUE == shutdownTable[dwTableIndex].bServerSecondSend)) {
                    // Send the second send request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(shutdownRequest), (char *) &shutdownRequest);

                    // Wait for the second send complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0);

                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "recv1b returned non-SOCKET_ERROR");
                        bTestPassed = FALSE;
                    }
                    else if (WSAECONNRESET != WSAGetLastError()) {
                        xLog(hLog, XLL_FAIL, "recv1b iLastError - EXPECTED: %u; RECEIVED: %u", WSAECONNRESET, WSAGetLastError());
                        bTestPassed = FALSE;
                    }

                    ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                    iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "send1b returned non-SOCKET_ERROR");
                        bTestPassed = FALSE;
                    }
                    else if (WSAECONNRESET != WSAGetLastError()) {
                        xLog(hLog, XLL_FAIL, "send1b iLastError - EXPECTED: %u; RECEIVED: %u", WSAECONNRESET, WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                }

                if (0 != shutdownTable[dwTableIndex].dwHow2) {
                    if (SHUTDOWN_SEND == shutdownTable[dwTableIndex].dwHow2) {
                        iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_SEND);
                    }
                    else if (SHUTDOWN_RECEIVE == shutdownTable[dwTableIndex].dwHow2) {
                        iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_RECEIVE);
                    }
                    else if (SHUTDOWN_BOTH == shutdownTable[dwTableIndex].dwHow2) {
                        iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_BOTH);
                    }

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "shutdown2 returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                    else {
                        dwHow |= shutdownTable[dwTableIndex].dwHow2;

                        if (0 != (SHUTDOWN_RECEIVE & dwHow)) {
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0);

                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv2 returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else if (WSAESHUTDOWN != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "recv2 iLastError - EXPECTED: %u; RECEIVED: %u", WSAESHUTDOWN, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }
                        else if (TRUE == shutdownTable[dwTableIndex].bServerFirstSend) {
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0);

                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv2 returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }

                        ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                        iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
                        if (0 != (SHUTDOWN_SEND & dwHow)) {
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "send2 returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else if (WSAESHUTDOWN != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "send2 iLastError - EXPECTED: %u; RECEIVED: %u", WSAESHUTDOWN, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "send2 returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }

                if (0 != shutdownTable[dwTableIndex].dwHow3) {
                    if (SHUTDOWN_SEND == shutdownTable[dwTableIndex].dwHow3) {
                        iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_SEND);
                    }
                    else if (SHUTDOWN_RECEIVE == shutdownTable[dwTableIndex].dwHow3) {
                        iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_RECEIVE);
                    }
                    else if (SHUTDOWN_BOTH == shutdownTable[dwTableIndex].dwHow3) {
                        iReturnCode = shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_BOTH);
                    }

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "shutdown3 returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                    else {
                        dwHow |= shutdownTable[dwTableIndex].dwHow3;

                        if (0 != (SHUTDOWN_RECEIVE & dwHow)) {
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0);

                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv3 returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else if (WSAESHUTDOWN != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "recv3 iLastError - EXPECTED: %u; RECEIVED: %u", WSAESHUTDOWN, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }
                        else if (TRUE == shutdownTable[dwTableIndex].bServerFirstSend) {
                            ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0);

                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv3 returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }

                        ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                        iReturnCode = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
                        if (0 != (SHUTDOWN_SEND & dwHow)) {
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "send3 returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else if (WSAESHUTDOWN != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "send3 iLastError - EXPECTED: %u; RECEIVED: %u", WSAESHUTDOWN, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }
                        else {
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "send3 returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "shutdown succeeded");
                }
            }
        }

        if ((TRUE == shutdownTable[dwTableIndex].bServerConnect) || (TRUE == shutdownTable[dwTableIndex].bServerAccept)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(shutdownRequest), (char *) &shutdownRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & shutdownTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & shutdownTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & shutdownTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Close the event
        CloseHandle(hReceiveEvent);
        CloseHandle(hSendEvent);

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
shutdownTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests shutdown - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long             FromInAddr;
    // dwMessageType is the type of received message
    DWORD              dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD              dwMessageSize;
    // pMessage is a pointer to the received message
    char               *pMessage;
    // shutdownRequest is the request
    SHUTDOWN_REQUEST   shutdownRequest;
    // shutdownComplete is the result
    SHUTDOWN_COMPLETE  shutdownComplete;

    // sSocket is the socket descriptor
    SOCKET             sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET             nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD              dwBufferSize = BUFFER_10_LEN;
    // bNagle indicates if Nagle is enabled
    BOOL               bNagle = FALSE;

    // localname is the local address
    SOCKADDR_IN        localname;
    // remotename is the remote address
    SOCKADDR_IN        remotename;

    // SendBuffer10 is the send buffer
    char               SendBuffer10[BUFFER_10_LEN + 1];
    // nSendCount is a counter to enumerate each send
    int                nSendCount;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&shutdownRequest, pMessage, sizeof(shutdownRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, shutdownRequest.nSocketType, 0);

        if (SOCK_STREAM == shutdownRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the buffer size
        dwBufferSize = 1;
        setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        dwBufferSize = 1;
        setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(shutdownRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == shutdownRequest.nSocketType) && (FALSE == shutdownRequest.bServerConnect)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(shutdownRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        shutdownComplete.dwMessageId = SHUTDOWN_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(shutdownComplete), (char *) &shutdownComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == shutdownRequest.nSocketType) && (FALSE == shutdownRequest.bServerConnect)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        // Send the complete
        shutdownComplete.dwMessageId = SHUTDOWN_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(shutdownComplete), (char *) &shutdownComplete);

        // Fulfill the send operations
        if (TRUE == shutdownRequest.bServerFirstSend) {
            for (nSendCount = 0; nSendCount < 10; nSendCount++) {
                // Call send
                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
            }
        }

        if (TRUE == shutdownRequest.bServerSecondSend) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
            while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0)) {
                Sleep(SLEEP_ZERO_TIME);
            }

            // Send the complete
            shutdownComplete.dwMessageId = SHUTDOWN_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(shutdownComplete), (char *) &shutdownComplete);
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETPATH=$(BASEDIR)\private\test\lib

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..\; \

SOURCES=\
    htonl.c                  \
    htons.c                  \
    ntohl.c                  \
    ntohs.c                  \
    inet_addr.c              \
    wsastartup.c             \
    wsacleanup.c             \
    socket.c                 \
    bind.c                   \
    listen.c                 \
    accept.c                 \
    connect.c                \
    send.c                   \
    wsasend.c                \
    sendto.c                 \
    wsasendto.c              \
    recv.c                   \
    wsarecv.c                \
    recvfrom.c               \
    wsarecvfrom.c            \
    getsockname.c            \
    getpeername.c            \
    ioctlsocket.c            \
    wsagetoverlappedresult.c \
    wsacanceloverlappedio.c  \
    select.c                 \
    fdsmacros.c              \
    shutdown.c               \
    closesocket.c            \
    getsockopt.c             \
    setsockopt.c             \
    XNetInAddrToString.c     \
    XNetRandom.c             \
    XNetCreateKey.c          \
    XNetRegisterKey.c        \
    XNetUnregisterKey.c      \
    XNetXnAddrToInAddr.c     \
    XNetInAddrToXnAddr.c     \
    XNetDnsLookup.c          \
    XNetDnsRelease.c         \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\socket.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  socket.c

Abstract:

  This modules tests socket

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define SOCK_RDM        4
#define SOCK_SEQPACKET  5



typedef struct _SOCKET_TABLE {
    CHAR    szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL    bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    int     af;                                      // af is the address family of the socket
    int     type;                                    // type is the type of the socket
    int     protocol;                                // protocol is the protocol of the socket
    SOCKET  sSocket;                                 // sSocket is the socket descriptor returned by socket
    int     iLastError;                              // iLastError is the error code if the operation failed
    BOOL    bRIP;                                    // Specifies a RIP test case
} SOCKET_TABLE, *PSOCKET_TABLE;

static SOCKET_TABLE socketTable[] =
{
    { "8.1 Not Initialized TCP",    FALSE, AF_INET, SOCK_STREAM,    0,            INVALID_SOCKET, WSANOTINITIALISED,  FALSE },
    { "8.2 Not Initialized UDP",    FALSE, AF_INET, SOCK_DGRAM,     0,            INVALID_SOCKET, WSANOTINITIALISED,  FALSE },
    { "8.3 af = INT_MIN TCP",       TRUE,  INT_MIN, SOCK_STREAM,    0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.4 af = INT_MIN UDP",       TRUE,  INT_MIN, SOCK_DGRAM,     0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.5 af = -1 TCP",            TRUE,  -1,      SOCK_STREAM,    0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.6 af = -1 UDP",            TRUE,  -1,      SOCK_DGRAM,     0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.7 af = 0 TCP",             TRUE,  0,       SOCK_STREAM,    0,            0,              0,                  FALSE },
    { "8.8 af = 0 UDP",             TRUE,  0,       SOCK_DGRAM,     0,            0,              0,                  FALSE },
    { "8.9 af = AF_UNIX TCP",       TRUE,  AF_UNIX, SOCK_STREAM,    0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.10 af = AF_UNIX UDP",      TRUE,  AF_UNIX, SOCK_DGRAM,     0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.11 af = AF_MAX TCP",       TRUE,  AF_MAX,  SOCK_STREAM,    0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.12 af = AF_MAX UDP",       TRUE,  AF_MAX,  SOCK_DGRAM,     0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.13 af = INT_MAX TCP",      TRUE,  INT_MAX, SOCK_STREAM,    0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.14 af = INT_MAX UDP",      TRUE,  INT_MAX, SOCK_DGRAM,     0,            INVALID_SOCKET, WSAEAFNOSUPPORT,    FALSE },
    { "8.15 type = SOCK_RDM",       TRUE,  AF_INET, SOCK_RDM,       0,            INVALID_SOCKET, WSAESOCKTNOSUPPORT, FALSE },
    { "8.16 type = SOCK_SEQPACKET", TRUE,  AF_INET, SOCK_SEQPACKET, 0,            INVALID_SOCKET, WSAESOCKTNOSUPPORT, FALSE },
    { "8.17 proto = INT_MIN TCP",   TRUE,  AF_INET, SOCK_STREAM,    INT_MIN,      INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.18 proto = -1 TCP",        TRUE,  AF_INET, SOCK_STREAM,    -1,           INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.19 proto = UDP TCP",       TRUE,  AF_INET, SOCK_STREAM,    IPPROTO_UDP,  INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.20 proto = MAX TCP",       TRUE,  AF_INET, SOCK_STREAM,    IPPROTO_MAX,  INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.21 proto = INT_MAX TCP",   TRUE,  AF_INET, SOCK_STREAM,    INT_MAX,      INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.22 proto = INT_MIN UDP",   TRUE,  AF_INET, SOCK_DGRAM,     INT_MIN,      INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.23 proto = -1 UDP",        TRUE,  AF_INET, SOCK_DGRAM,     -1,           INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.24 proto = TCP UDP",       TRUE,  AF_INET, SOCK_DGRAM,     IPPROTO_TCP,  INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.25 proto = MAX UDP",       TRUE,  AF_INET, SOCK_DGRAM,     IPPROTO_MAX,  INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.26 proto = INT_MAX UDP",   TRUE,  AF_INET, SOCK_DGRAM,     INT_MAX,      INVALID_SOCKET, WSAEPROTONOSUPPORT, FALSE },
    { "8.27 STREAM, proto = 0",     TRUE,  AF_INET, SOCK_STREAM,    0,            0,              0,                  FALSE },
    { "8.28 STREAM, proto = TCP",   TRUE,  AF_INET, SOCK_STREAM,    IPPROTO_TCP,  0,              0,                  FALSE },
    { "8.29 STREAM, af = 0",        TRUE,  0,       SOCK_STREAM,    IPPROTO_TCP,  0,              0,                  FALSE },
    { "8.30 DGRAM, proto = 0",      TRUE,  AF_INET, SOCK_DGRAM,     0,            0,              0,                  FALSE },
    { "8.31 DGRAM, proto = UDP",    TRUE,  AF_INET, SOCK_DGRAM,     IPPROTO_UDP,  0,              0,                  FALSE },
    { "8.32 DGRAM, af = 0",         TRUE,  0,       SOCK_DGRAM,     IPPROTO_UDP,  0,              0,                  FALSE },
    { "8.33 Not Initialized TCP",   FALSE, AF_INET, SOCK_STREAM,    0,            INVALID_SOCKET, WSANOTINITIALISED,  FALSE },
    { "8.34 Not Initialized UDP",   FALSE, AF_INET, SOCK_DGRAM,     0,            INVALID_SOCKET, WSANOTINITIALISED,  FALSE },
};

#define socketTableCount (sizeof(socketTable) / sizeof(SOCKET_TABLE))



VOID
socketTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests socket

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD    dwTableIndex;

    // bWinsockInitialized indicates if Winsock i